
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (n - 1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1, 2, 1] after the first step, the sequence [1, 2, 1, 3, 1, 2, 1] after the second step.

The task is to find the value of the element with index k (the elements are numbered from 1) in the obtained sequence, i. e. after (n - 1) steps.

Please help Chloe to solve the problem!

Input

The only line contains two integers n and k (1 ≤ n ≤ 50, 1 ≤ k ≤ 2n - 1).

Output

Print single integer — the integer at the k-th position in the obtained sequence.

Examples

Input

3 2


Output

2

Input

4 8


Output

4

Note

In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n and k are integers such that 1 ≤ n ≤ 50 and 1 ≤ k ≤ 2n - 1.**
def func():
    steps = 0
    index = 0
    steps, index = raw_input().split()
    steps = int(steps)
    index = int(index)
    left = 1
    right = int(math.pow(2, steps) - 1)
    if (index % 2 == 1) :
        print(1)
    else :
        while (right + left) / 2 != index:
            steps -= 1
            
            if index < (right + left) / 2:
                right = (right + left) / 2 - 1
            elif index > (right + left) / 2:
                left = right = (right + left) / 2 + 1
            
        #State of the program after the loop has been executed: `n` and `k` are integers such that 1 ≤ n ≤ 50 and 1 ≤ k ≤ 2n - 1; `steps` is an integer, `index` is the second value of the input, `left` is updated to a new value, `right` is updated to a new value such that (right + left) / 2 = index. The loop has terminated after all iterations
        print(steps)
    #State of the program after the if-else block has been executed: *`n` and `k` are integers such that 1 ≤ n ≤ 50 and 1 ≤ k ≤ 2n - 1; `steps` is an integer, `index` is the second value of the input, `left` is either 1 or a newly updated value, `right` is either calculated as `int(math.pow(2, steps) - 1)` or a newly updated value. After the execution of the if else block, the program variables will retain their initial conditions. If the index is odd, the variables stay the same, and index remains an odd number. If the index is even, `left` and `right` are updated such that (right + left) / 2 = index, and the loop completes all iterations. The final value of `steps` is printed.
#Overall this is what the function does:The function `func` reads input values for `steps` and `index`, converts them to integers, and calculates a value based on the input constraints. If the index is odd, it prints 1. If the index is even, it iterates until the midpoint between `left` and `right` is equal to the index, then prints the number of steps taken in the iteration. The function does not accept any parameters, and the return value is based on the input constraints provided for `n` and `k`.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
