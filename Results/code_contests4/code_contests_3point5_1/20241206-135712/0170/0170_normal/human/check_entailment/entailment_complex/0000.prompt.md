
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer representing the number of test cases. n is a positive integer such that 3 <= n <= 100. The input sequences a, b, and c are lists of n integers where each element is in the range [1, 100]. The elements in each sequence are distinct from each other and from the corresponding elements in the other sequences.**
def func_1():
    return int(input())
    #The program returns an integer obtained from the user input
#Overall this is what the function does:The function func_1 prompts the user to input an integer, which it then returns. The function does not explicitly specify the input parameter, but based on the annotation, it seems to expect no input parameters and directly returns the user input as an integer. It does not handle any edge cases or validation of the input.

#Function 2:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 ≤ t ≤ 100. n is an integer such that 3 ≤ n ≤ 100. a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100. a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_2():
    return input()
    #The program returns the input value without any modification
#Overall this is what the function does:The function `func_2` does not accept any parameters. It simply returns the input value without any modification. The function does not perform any additional operations or checks. However, the annotations mention preconditions about the values of `t`, `n`, `a_i`, `b_i`, and `c_i`, which are not utilized in the function itself.

#Function 3:
#State of the program right berfore the function call: **
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object that applies the int function to each element after splitting the input string by spaces
#Overall this is what the function does:The function `func_3` does not accept any parameters. It splits the input string by spaces and applies the int function to each element, returning a map object. However, the function does not handle any potential errors that may arise from the input or conversion process.

#Function 4:
#State of the program right berfore the function call: **Precondition**: The input consists of three sequences a, b, and c, each containing n integers. The integers in each sequence are distinct.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the strings of integers from the input sequences a, b, and c after splitting them by space
#Overall this is what the function does:The function func_4 does not accept any parameters. It reads input from the user, splits the input by space, and converts the integers into strings. Finally, it returns a map object containing the strings of integers. The function assumes that the input consists of three sequences of distinct integers, but it does not validate the input or handle cases where the input does not meet these requirements.

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3()
#Overall this is what the function does:The function func_5() returns a list generated by calling the function func_3().

#Function 6:
#State of the program right berfore the function call: The input consists of three sequences a, b, and c, each containing n non-negative integers where a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.**
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit and stack size, then creates a new thread that calls the `main` function. The function does not accept any parameters and operates on three sequences a, b, and c, each containing non-negative integers where no elements are equal between sequences. The function does not return any value.

#Function 7:
#State of the program right berfore the function call: ** The input consists of three sequences: a list of integers a_i, a list of integers b_i, and a list of integers c_i, where each list has n elements (3 ≤ n ≤ 100). Each element a_i, b_i, c_i is different from each other and lies in the range of 1 to 100.
def func_7(item):
    return item[1]
    #The program returns the second element of the list 'item'
#Overall this is what the function does:The function accepts a list of integers and returns the second element of the list. The function assumes the input list always has at least two elements.

#Function 8:
#State of the program right berfore the function call: **
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a sorted list 'l' in reverse order based on the custom key function 'getKey'
#Overall this is what the function does:The function accepts a list `l` and returns a sorted list in reverse order based on the custom key function `getKey`. It does not handle cases where `getKey` is not defined or where `l` is not a list.

#Function 9:
#State of the program right berfore the function call: n is an integer representing the number of elements in the sequences, m is an integer representing the number of test cases, and num is a list of lists where each sublist contains n integers representing the sequences a_i, b_i, c_i.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists where each sublist contains n integers representing the sequences a_i, b_i, c_i repeated m times
#Overall this is what the function does:The function func_9 accepts integers n and m along with a list of lists num, and returns a modified list of lists where each sublist contains n integers from the original sequences a_i, b_i, c_i, repeated m times.

#Function 10:
#State of the program right berfore the function call: **Precondition**: 
- The input consists of three sequences a, b, c each containing n elements.
- Each element in a, b, c is an integer in the range [1, 100].
- The length of the sequences is at least 3 and at most 100.
- For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_10(x):
    return x and not x & x - 1
    #The program returns x and not x & x - 1
#Overall this is what the function does:The function `func_10` accepts a parameter `x`, which is a sequence consisting of three sequences a, b, c, each containing n elements. Each element in a, b, c is an integer in the range [1, 100]. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. The function then returns the result of x and not x & x - 1.

#Function 11:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 ≤ t ≤ 100. n is an integer such that 3 ≤ n ≤ 100. a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of integer n after removing the '0b' prefix
#Overall this is what the function does:The function `func_11` accepts an integer `n` where n is between 3 and 100 inclusive. It then converts `n` to its binary representation and removes the '0b' prefix before returning the result. The function correctly performs this conversion for the given range of `n`.

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers created by converting each character in the string representation of 'n' to an integer.
#Overall this is what the function does:The function func_12 accepts a parameter n (string) and returns a list of integers created by converting each character in the string representation of n to an integer.

#Function 13:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer such that 3 ≤ n ≤ 100.
- a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100.
- For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combination formula C(n, r) where n is an integer between 3 and 100, r is an integer between 1 and n, and C(n, r) is calculated as n! / (r! * (n - r)!).
#Overall this is what the function does:The function `func_13` accepts two parameters, `n` and `r`. It calculates and returns the result of the combination formula C(n, r) using the provided formula n! / (r! * (n - r)!) where n is an integer between 3 and 100, and r is an integer between 1 and n. The function accurately computes the combination formula for the given inputs.

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- x is a list of three sequences a, b, c where each sequence is a list of n integers.
- y is an integer representing the number of test cases.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns x divided by y, where x is a list of three sequences a, b, c where each sequence is a list of n integers and y is an integer representing the number of test cases. The sum of all elements in x is divisible by y
    else :
        return x // y + 1
        #The program returns the result of dividing the list x by y and adding 1 to the quotient.
#Overall this is what the function does:The function `func_14` accepts two parameters: `x` and `y`. The precondition for `x` is that it is a list of three sequences `a`, `b`, `c`, where each sequence is a list of `n` integers. The precondition for `y` is that it is an integer representing the number of test cases. 

The function then checks if the sum of all elements in `x` is divisible by `y`. If it is divisible, the function returns the result of `x` divided by `y`. If the sum is not divisible by `y`, the function returns the result of dividing `x` by `y` and adding 1 to the quotient.

#Function 15:
#State of the program right berfore the function call: **
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res` is the final result after all iterations of the loop, `y` is 0, `x` is the final value after all iterations
    return res
    #The program returns the final result 'res' after all iterations of the loop
#Overall this is what the function does:The function `func_15` accepts three parameters `x`, `y`, and `p`. It performs calculations on `x` and `y` based on bit manipulation and modular arithmetic. After all iterations of the loop within the function, it returns the final result `res`. The function calculates the result by iteratively updating `res`, `y`, and `x` until `y` becomes 0.

#Function 16:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 <= t <= 100. n is an integer such that 3 <= n <= 100. a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x is the greatest common divisor of the initial values of x and y, y is 0
    return x
    #The program returns the greatest common divisor of the initial values of x and y, which is x
#Overall this is what the function does:The function `func_16` accepts two integer parameters `x` and `y`. It calculates the greatest common divisor of the initial values of `x` and `y` using the Euclidean algorithm and returns this value as the final result. The function ensures that `y` is not 0 to avoid division by zero errors. If `y` is 0, the function returns the initial value of `x` as the greatest common divisor. The function does not handle cases where both `x` and `y` are 0, which could potentially be considered as an edge case.

#Function 17:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 3 ≤ n ≤ 100.**
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 3 ≤ n ≤ 100. n is larger than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer such that 3 ≤ n ≤ 100. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 3 ≤ n ≤ 100 and n is larger than 3. n is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is an integer such that 3 ≤ n ≤ 100 and n is not divisible by 2 or 3; i is the smallest prime number greater than 24
    return True
    #The program returns True
#Overall this is what the function does:The function `func_17` accepts an integer parameter `n` within the range 3 ≤ n ≤ 100. The function then applies various conditions to n and returns True or False based on those conditions. If n is less than or equal to 1, the function returns False. If n is less than or equal to 3 but greater than 1, the function returns True. If n is not divisible by 2 or 3, the function returns True after checking for prime numbers. However, there are missing cases in the annotations where the function should return False if n is divisible by certain numbers.

#Function 18:
#State of the program right berfore the function call: **
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function func_18 does not accept any parameters and sets the standard input and output to read from 'input.txt' and write to 'output.txt'. It does not return any value.

#Function 19:
#State of the program right berfore the function call: **Precondition**: 
- t is a positive integer such that 1 <= t <= 100.
- n is a positive integer such that 3 <= n <= 100.
- a_i, b_i, c_i are positive integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `n` is greater than or equal to 2, `ans` contains `n` elements where each element is either `a[i]`, `b[i]`, or `c[i]` based on the conditions within the loop, `ans[0]` is assigned the value of `a[0]`, `a`, `b`, `c` are assigned the return value of `func_5()` again.
#Overall this is what the function does:The function `func_19` iterates over a range determined by the result of `func_1()`. Within each iteration, it assigns values to variables `n`, `a`, `b`, and `c` based on the results of respective `func_5()` calls. It creates a list `ans` of size `n` and populates it based on certain conditions involving `a`, `b`, and `c`. After the loop, `ans` contains elements that are either `a[i]`, `b[i]`, or `c[i]` depending on the conditions. However, the function does not return any value.

#Function 20:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100. n is an integer such that 3 ≤ n ≤ 100. a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100. a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is False, `file` has written the string representation of all elements in `args` separated by `sep`
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is False, `file` has written the string representation of all elements in `args` separated by `sep', 'flush' key has been removed from `kwargs` with a value of False.
#Overall this is what the function does:The function `func_20` is a predefined function that does not accept any parameters. It iterates over the elements in `args`, writing their string representations to the output stream specified by `file`, separated by the value of `sep`. It then writes the value of 'end' key from `kwargs` to the output stream. If the 'flush' key is present in `kwargs` with a value of True, it flushes the output stream. The function does not return any output.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.