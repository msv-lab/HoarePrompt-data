
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Given are N positive integers A_1,...,A_N.

Consider positive integers B_1, ..., B_N that satisfy the following condition.

Condition: For any i, j such that 1 \leq i < j \leq N, A_i B_i = A_j B_j holds.

Find the minimum possible value of B_1 + ... + B_N for such B_1,...,B_N.

Since the answer can be enormous, print the sum modulo (10^9 +7).

Constraints

* 1 \leq N \leq 10^4
* 1 \leq A_i \leq 10^6
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
A_1 ... A_N


Output

Print the minimum possible value of B_1 + ... + B_N for B_1,...,B_N that satisfy the condition, modulo (10^9 +7).

Examples

Input

3
2 3 4


Output

13


Input

5
12 12 12 12 12


Output

5


Input

3
1000000 999999 999998


Output

996989508
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1(a, b):
    c = a + b
    if (c >= mod) :
        c -= mod
    #State of the program after the if block has been executed: *`c` is the sum of `a` and `b`. If `c` is greater than or equal to `mod`, then the program executes the if block. Otherwise, there is no else part.
    return c
    #The program returns the sum of variables `a` and `b`

#Function 2:
#State of the program right berfore the function call: **
def func_2(a, b):
    return a * b % mod
    #The program returns the result of multiplying variables 'a' and 'b' and then taking the modulo 'mod' of the product.

#Function 3:
#State of the program right berfore the function call: N is a positive integer, A_1, ..., A_N are positive integers.
def func_3(a, b):
    if (b == 0) :
        return 1
        #The program returns the integer 1
    else :
        if (b % 2 == 1) :
            return func_2(a, func_3(a, b - 1))
            #The program returns the result of calling function func_2 with arguments a and the result of calling function func_3 with arguments a and b-1
        else :
            temp = func_3(a, b / 2)
            return func_2(temp, temp)
            #The program returns the value obtained by calling func_2(temp, temp), where temp is assigned the value returned by func_3(a, b / 2)

#Function 4:
#State of the program right berfore the function call: **
def func_4(a):
    return func_3(a, mod - 2)
    #The program returns the result of calling function 'func_3' with parameters 'a' and 'mod - 2'

#Function 5:
#State of the program right berfore the function call: a is a list of N positive integers and m is a positive integer.
def func_5(a, m):
    m0 = m
    y = 0
    x = 1
    if (m == 1) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *a is a list of N positive integers, m is a positive integer, y is 0, x is 1 and m is not equal to 1
    while a > 1:
        q = a // m
        
        t = m
        
        m = a % m
        
        a = t
        
        t = y
        
        y = x - q * y
        
        x = t
        
    #State of the program after the loop has been executed: `a` is a list of N positive integers, `m` is 1, `y` is some value, `x` is some value
    if (x < 0) :
        x = x + m0
    #State of the program after the if block has been executed: *`a` is a list of N positive integers, `m` is 1, `y` is some value, `x` is some value. If x < 0, no changes occur to the variables `a`, `m`, and `y`.
    return x
    #The program returns the value of x

#Function 6:
#State of the program right berfore the function call: **
def func_6():
    n = int(raw_input())
    arr = [int(x) for x in raw_input().split()]
    answer = {}
    for i in range(n):
        cnt = {}
        
        x = arr[i]
        
        i = 2
        
        while i * i <= x:
            while x % i == 0:
                x /= i
                cnt[i] = cnt.get(i, 0) + 1
            i += 1
        
        if x != 1:
            cnt[x] = cnt.get(x, 0) + 1
        
        for key in cnt:
            answer[key] = max(answer.get(key, 0), cnt[key])
        
    #State of the program after the  for loop has been executed: `n` is greater than 0, `answer` is a dictionary containing the maximum count of each prime factor in `cnt`, `arr` is a list of integers, `i` is greater than the square root of the original value of `x`, `cnt` is a dictionary containing the count of how many times each prime factor divides `x`, `x` is fully divided by all prime factors, if `x` is not equal to 1, `cnt[x]` is updated to its previous value incremented by 1, for the loop to execute, `cnt` has at least 1 key
    lcm = 1
    for prime in answer:
        for _ in range(answer[prime]):
            lcm = func_2(lcm, prime)
        
    #State of the program after the  for loop has been executed: `n` is greater than 0, `answer` has iterated over all keys in the dictionary, `arr` is a list of integers, `i` is greater than the square root of the original value of `x`, `cnt` is a dictionary containing the count of how many times each prime factor divides `x`, `x` is fully divided by all prime factors, if `x` is not equal to 1, `cnt[x]` is updated to its previous value incremented by 1, `cnt` has at least 1 key, `lcm` is the result of `func_2` applied to the previous value of `lcm` and each `prime`, `prime` is a key in the `answer` dictionary, `_` is equal to the total number of times the loop has executed, `lcm` is updated based on the result of `func_2`, and all keys in `answer` have been processed.
    ans = 0
    for x in arr:
        ans = func_1(ans, func_2(lcm, func_4(x)))
        
    #State of the program after the  for loop has been executed: Output State: `ans` is the result of calling `func_1` with parameters `ans` and the result of calling `func_2` with parameters `lcm` and the result of calling `func_4` with each element in `arr`. The loop will execute for each element in `arr` until all elements have been processed.
    ans = int(ans)
    print(ans)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
