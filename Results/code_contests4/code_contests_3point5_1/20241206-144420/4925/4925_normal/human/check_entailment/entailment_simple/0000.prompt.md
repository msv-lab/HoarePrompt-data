
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

Input

The first line of the input contains two integers n and m (1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5)), the number of vertices and the number of edges of weight 1 in the graph. 

The i-th of the next m lines contains two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i), the endpoints of the i-th edge of weight 1.

It is guaranteed that no edge appears twice in the input.

Output

Output a single integer, the weight of the minimum spanning tree of the graph.

Examples

Input


6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6


Output


2


Input


3 0


Output


0

Note

The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.

<image>

In the second sample, all edges have weight 0 so any spanning tree has total weight 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **Precondition**: **n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5).**
def func_1():
    n, m = func_4()
    p = list(range(n))
    r = func_7(int, n)
    sg = func_7(set, n)
    for _ in range(m):
        x, y = func_5(-1)
        
        sg[x].add(y)
        
        sg[y].add(x)
        
    #State of the program after the  for loop has been executed: n and m are integers satisfying 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5); p is a list containing integers from 0 to n-1; sg is a list of sets where sg[i] contains all elements that have been added to sg at index i
    v = min(range(n), key=lambda i: len(sg[i]))
    for i in range(n):
        if i not in sg[v]:
            union(i, v)
        else:
            for j in range(n):
                if j not in sg[i]:
                    union(i, j)
        
    #State of the program after the  for loop has been executed: n and m are integers satisfying 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5); p is a list containing integers from 0 to n-1; sg is a list of sets where sg[i] contains all elements that have been added to sg at index i; v is the index with the minimum length of the set in sg. After all iterations of the loop have finished, the sets in sg will be merged and updated according to the union(i, j) function. All elements will be present in sg as per the function's logic. All other variables will remain unchanged.
    roots = set()
    for i in range(n):
        roots.add(find(i))
        
    #State of the program after the  for loop has been executed: `v` is the index with the minimum length of the set in sg, `roots` contains the result of calling find(i) for all i in the range of n, `p` is a list containing integers from 0 to n-1, `n` is greater than or equal to 1
    print(len(roots) - 1)

#Function 2:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i, and no edge appears twice in the input.**
def find(v):
    vc = v
    while v != p[v]:
        v = p[v]
        
    #State of the program after the loop has been executed: `vc` is assigned the value of the root node that `v` belongs to after all iterations have executed, `v` is updated to the root node of the current node it is pointing to
    while vc != v:
        p[vc], vc = v, p[vc]
        
    #State of the program after the loop has been executed: `vc` is now equal to the root node that `v` is pointing to after all iterations have executed, `v` is updated to the root node of the current node it is pointing to, `p` is updated accordingly
    return v
    #The program returns the root node that variable `v` is pointing to after all iterations have executed. Variable `v` is updated to the root node of the current node it is pointing to, and variable `p` is updated accordingly.

#Function 3:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i.**
def union(u, v):
    u, v = find(u), find(v)
    if (u == v) :
        return
        #The program returns u which is equal to v
    #State of the program after the if block has been executed: *n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i. The values of u and v are not equal.
    if (r[u] < r[v]) :
        u, v = v, u
    #State of the program after the if block has been executed: *n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i. The values of u and v are not equal. If r[u] < r[v], then the values of u and v are swapped.
    p[u] = v
    if (r[u] == r[v]) :
        r[u] += 1
    #State of the program after the if block has been executed: *`n` and `m` are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). `a_i` and `b_i` are integers such that 1 ≤ `a_i`, `b_i` ≤ n, `a_i` ≠ `b_i`. The values of `u` and `v` are not equal. If `r[u]` < `r[v]`, then the values of `u` and `v` are swapped. `p[u]` is assigned the value `v`. After the execution of the if else block, if `r[u]` is equal to `r[v]`, then `r[u]` is incremented by 1.

#Function 4:
#State of the program right berfore the function call: **
def func_2(x):
    return pow(x, MOD - 2, MOD)
    #The program returns the result of raising 'x' to the power of (MOD - 2) modulo MOD

#Function 5:
#State of the program right berfore the function call: x and y are integers such that 1 <= x <= 10^5 and 0 <= y <= min((x(x-1))/2, 10^5).**
def func_3(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: 'x' and 'y' have new values based on the initial conditions, 'y' is 0 as it becomes falsy after the loop finishes
    return x
    #The program returns the final value of 'x' after the loop finishes. 'y' becomes 0 after the loop.

#Function 6:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5).**
def func_4():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained by splitting the input and converting each element to an integer.

#Function 7:
#State of the program right berfore the function call: **
def func_5(o):
    return list(map(lambda x: int(x) + o, input().split()))
    #The program returns a list of integers obtained by adding 0 to each element after converting it to an integer from the input string split by spaces.

#Function 8:
#State of the program right berfore the function call: n and m are non-negative integers such that 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5).**
def func_6(n, m):
    return [func_4() for _ in range(n)]
    #The program returns a list of length 'n', where each element is the result of calling the function func_4(). The values of 'n' and 'm' are non-negative integers such that 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5).

#Function 9:
#State of the program right berfore the function call: **Precondition**: **n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). The input edges are distinct pairs of integers a_i and b_i where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.**
def func_7(f):
    return [func_7(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list of values generated by calling func_7 with arguments f and the remaining dimensions of dim for each element in the range of dim[0], or the result of calling f if dim is empty.

#Function 10:
#State of the program right berfore the function call: n and m are integers such that 1 <= n <= 10^5, 0 <= m <= min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 <= a_i, b_i <= n and a_i ≠ b_i.**
def func_8(start, step, count):
    return range(start, start + step * count, step)
    #The program returns a range starting from 'start' with a step size of 'step' and containing 'count' elements

#Function 11:
#State of the program right berfore the function call: l is a list of tuples where each tuple contains two integers representing the endpoints of an edge in the graph. start and end are integers representing the start and end vertices of the graph. 1 <= start, end <= n, where n is the number of vertices in the graph.**
def func_9(l, start, end):
    return range(start, len(l) + end)
    #The program returns a range starting from 'start' to the length of list 'l' plus 'end'. The range represents the vertices of the graph.

#Function 12:
#State of the program right berfore the function call: **
def func_10(n):
    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """
    return 2 ** (n - 1).bit_length()
    #The program returns the value of 2 raised to the power of (n - 1), where n is the length of the list [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] minus 1

#Function 13:
#State of the program right berfore the function call: x and r are integers such that 1 <= x <= 10^5 and 0 <= r <= min((x(x-1))/2,10^5).**
def func_11(x, r):
    """ = ceil(x / r) """
    return (x + r - 1) // r
    #The program returns the value of (x + r - 1) divided by r, where x and r are integers such that 1 <= x <= 10^5 and 0 <= r <= min((x(x-1))/2,10^5). If the empty string is assigned, it is the ceiling value of x divided by r.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
