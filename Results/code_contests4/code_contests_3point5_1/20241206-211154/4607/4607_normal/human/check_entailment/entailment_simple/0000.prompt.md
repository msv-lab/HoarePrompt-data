
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    return int(input())
    #The program returns an integer obtained from user input

#Function 2:
#State of the program right berfore the function call: 
def func_2():
    return input()
    #The program returns the input value provided by the user

#Function 3:
#State of the program right berfore the function call: **
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object after converting the input values to integers and splitting them by space

#Function 4:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n. Each integer in the sequence is a positive integer and doesn't exceed 10^8.**
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a list of strings obtained by mapping the input sequence of integers, where each integer is a positive number not exceeding 10^8

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5, and the sequence of integers on Alexander's cards is non-empty.**
def func_5():
    return list(func_3())
    #The program returns a list of integers after calling the function func_3()

#Function 6:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer such that 1 ≤ n ≤ 10^5.
- The sequence of integers on Alexander's cards is represented as a list of integers.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list of integers with length n, where 1 <= n <= 10^5.**
def func_7(item):
    return item[1]
    #The program returns the second element of the list 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of integers containing n elements where 1 ≤ n ≤ 105.**
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list 'l' sorted based on the key function 'getKey'

#Function 9:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5, m is a list of n integers, each integer is positive and doesn't exceed 10^8.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each row contains the same list 'm' of integers, and there are 'n' rows in total. The integers in list 'm' are positive and do not exceed 10^8, and 'n' is an integer between 1 and 10^5.

#Function 10:
#State of the program right berfore the function call: x is a list of integers of length n where 1 <= n <= 10^5 and each integer is a positive number not exceeding 10^8.**
def func_10(x):
    return x and not x & x - 1
    #The program returns the list x and the result of the bitwise AND operation between x and the bitwise negation of x-1.

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer 'n' without the prefix '0b'

#Function 12:
#State of the program right berfore the function call: n is a positive integer and the sequence of integers on Alexander's cards is a list of positive integers.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit of the positive integer 'n'

#Function 13:
#State of the program right berfore the function call: **Precondition**: 
- x is a positive integer representing the number of cards (1 <= x <= 10^5).
- y is a list of integers representing the numbers on Alexander's cards. Each integer is a positive integer that doesn't exceed 10^8.
- p is an integer representing the number Arthur wants to add to the cards.
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: x is the updated remainder of x squared divided by p, y is an empty list (y = 0), p is an integer representing the number Arthur wants to add to the cards, res is the final updated value after all iterations of the loop have executed
    return res
    #The program returns the final updated value 'res' after all iterations of the loop have executed

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5) and y is a list of integers representing the numbers on the cards (each integer is positive and doesn't exceed 10^8).**
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x is the greatest common divisor of all the integers in the initial list y, y is 0
    return x
    #The program returns the greatest common divisor of all the integers in the initial list y, where y is 0

#Function 15:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5.**
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 1 <= n <= 10^5. n is larger than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer such that 1 <= n <= 10^5, n is larger than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 1 <= n <= 10^5, n is larger than 1 and larger than 3. n is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is an integer such that 1 <= n <= 10^5, n is larger than 1 and larger than 3, n is not divisible by 2 or 3, i is greater than the square root of n, the condition (n % i == 0 or n % (i + 2) == 0) is false
    return True
    #The program returns True

#Function 16:
#State of the program right berfore the function call: **
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, the sequence of integers on Alexander's cards is a list of positive integers in ascending order, and `a` is the return value of `func_5()`. Since there is no else part and the program exits immediately after encountering the `exit()` statement in the if part, the state of the program remains unchanged
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, the sequence of integers on Alexander's cards is a list of positive integers in ascending order, `a` is the return value of `func_5()`. After entering the if condition, `n` is equal to 2 and the program exits immediately. If the first two elements of `a` are equal to each other, then the program exits immediately. Otherwise, there is no change in the state of the program.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, the sequence of integers on Alexander's cards is a list of positive integers in ascending order, `a` is the return value of `func_5()`, `l` contains the result of the calculation if abs(g) % 2 == 0. Otherwise, no changes occur to the state of the program.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, the sequence of integers on Alexander's cards is a list of positive integers in ascending order, and `a` is the return value of `func_5()`. If `n` equals 2, the program exits immediately without changing the state of the program.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is an integer between 1 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is equal to `n - 1`
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is equal to `n - 1`. If the length of the unique elements in `g` is greater than 2, the program will return a specific result based on that condition.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is equal to `n - 1`. The length of the unique elements in `g` is not equal to 1. Additionally, there exists at least one absolute difference in `l` that is equal to 0. If the length of the unique elements in `g` is greater than or equal to 2, then the program exits without any changes to the initial state.
        #State of the program after the if block has been executed: *`n` is an integer between 1 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is equal to `n - 1`. The length of the unique elements in `g` is not equal to 1. There exists at least one absolute difference in `l` that is equal to 0. If the length of the unique elements in `g` is greater than or equal to 2 and there is an absolute difference in `l` that is 0, then the program exits without any changes to the initial state.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `n` is an integer between 1 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is equal to `n + 1`, the length of the unique elements in `g` is not equal to 1, there exists at least one absolute difference in `l` that is equal to 0, `gc` is updated based on the function `func_14` for all elements in list `l`
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `n` is an integer between 2 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is at least 2, the length of the unique elements in `g` is not equal to 1, there exists at least one absolute difference in `l` that is equal to 0, `gc` is updated based on the function `func_14` for all elements in list `l`, `x` is calculated as `a[-2] + (a[-1] - a[-2]) // 2`, `a` is appended with the value `a[-2] + (a[-1] - a[-2]) // 2`, if `abs(a[i + 1] - a[i]) != gc`, `x` is assigned the value of `a[i] + (a[i + 1] - a[i]) // 2`, and `a` is updated with the new value appended.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `l` contains the absolute differences between consecutive elements in list `a` for all elements in the range `n-1`, where `n` is the length of list `a`
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`l` contains the absolute differences between consecutive elements in list `a` for all elements in the range `n-1`, where `n` is the length of list `a`. If the unique elements in `l` have the same value, the behavior depends on the function `func_18(x)` and the initial state of the program. Otherwise, if the length of `l` is not equal to 1, the program maintains the original state of `l`.
    #State of the program after the if-else block has been executed: *`n` is an integer between 1 and 10^5, `g` contains the differences between consecutive elements of list `a`, `l` contains the absolute differences between consecutive elements of list `a`, `i` is equal to `n - 1`, `l` is sorted in ascending order. If the unique elements in `g` are greater than 2, the behavior of the program depends on the unique elements in `l`. If the length of list `l` is not equal to 1, the program maintains the original state of `l`. Otherwise, if the unique elements in `l` have the same value, the behavior depends on the function `func_18(x)` and the initial state of the program.

#Function 18:
#State of the program right berfore the function call: **Precondition**: 
- The input consists of an integer n (1 ≤ n ≤ 10^5) representing the number of cards.
- The input contains a sequence of n integers representing the numbers on Alexander's cards. 
- Each number in the sequence is a positive integer that does not exceed 10^8.
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is False, `args` is a list with at least 1 element, `x` is the last element in the list, `file` has written the values of all elements in `args` separated by `sep`
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is False, `args` is a list with at least 1 element, `x` is the last element in the list, `file` has written the values of all elements in `args` separated by `sep`, `end` has been popped from `kwargs` and written to the file. If 'flush' key is popped from `kwargs` and its value is True, the overall state remains the same.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
