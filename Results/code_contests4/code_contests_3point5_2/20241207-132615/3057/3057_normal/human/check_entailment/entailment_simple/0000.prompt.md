
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (n - 1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1, 2, 1] after the first step, the sequence [1, 2, 1, 3, 1, 2, 1] after the second step.

The task is to find the value of the element with index k (the elements are numbered from 1) in the obtained sequence, i. e. after (n - 1) steps.

Please help Chloe to solve the problem!

Input

The only line contains two integers n and k (1 ≤ n ≤ 50, 1 ≤ k ≤ 2n - 1).

Output

Print single integer — the integer at the k-th position in the obtained sequence.

Examples

Input

3 2


Output

2

Input

4 8


Output

4

Note

In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n and k are integers such that 1 ≤ n ≤ 50 and 1 ≤ k ≤ 2n - 1.**
def func():
    steps = 0
    index = 0
    steps, index = raw_input().split()
    steps = int(steps)
    index = int(index)
    left = 1
    right = int(math.pow(2, steps) - 1)
    if (index % 2 == 1) :
        print(1)
    else :
        while (right + left) / 2 != index:
            steps -= 1
            
            if index < (right + left) / 2:
                right = (right + left) / 2 - 1
            elif index > (right + left) / 2:
                left = right = (right + left) / 2 + 1
            
        #State of the program after the loop has been executed: `steps` is 0, `index` is an even integer, `left` is 1, `right` is the result of 2 raised to the power of `index` minus 1. The condition `(right + left) / 2 != index` is false, loop terminates.
        print(steps)
    #State of the program after the if-else block has been executed: *`steps` is an input integer, `index` is an integer value, `left` is 1, and `right` is the result of 2 raised to the power of `steps` minus 1. If `index` is odd, the program condition `(right + left) / 2 != index` is false, loop terminates. If `index` is even, `steps` is 0, `index` is an even integer, `left` is 1, `right` is the result of 2 raised to the power of `index` minus 1, and the program prints the value of `steps`, which is 0.

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
