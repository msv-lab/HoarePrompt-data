
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

Input

The first line contains the number of universities t, (1 ≤ t ≤ 1000) Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 109; li ≤ ri).

Output

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

Examples

Input

2
5 2 3
6 4 5


Output

Yes
No

Note

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 <= t <= 1000. Each of the next t lines contain three space-separated integers: ni, li, ri (1 <= ni, li, ri <= 10^9; li <= ri).**
def func_1():
    return int(input())
    #The program returns an integer obtained from user input
#Overall this is what the function does:Functionality: The function `func_1` does not accept any parameters. It prompts the user for input and returns the integer obtained from the user input. The functionality of the function is to return an integer obtained from user input. The function lacks error handling for cases where the input is not an integer.

#Function 2:
#State of the program right berfore the function call: t is an integer such that 1 <= t <= 1000. Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).**
def func_2():
    return input()
    #The program returns the input t, where t is an integer such that 1 <= t <= 1000. Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri)
#Overall this is what the function does:The function func_2 does not accept any parameters. It simply returns the input provided by the user, which is expected to be an integer t where 1 <= t <= 1000, followed by t lines containing three space-separated integers ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).

#Function 3:
#State of the program right berfore the function call: **Precondition**: The input consists of t requests, each containing three integers ni, li, and ri where 1 ≤ t ≤ 1000, 1 ≤ ni, li, ri ≤ 109, and li ≤ ri.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers after splitting the input string by space and converting each element to an integer
#Overall this is what the function does:The function func_3 does not accept any parameters. It reads input from the console, splits the input string by space, converts each element to an integer, and returns a map object containing these integers. The code does not specify how the input is structured or what the map object will be used for further. Edge cases such as handling invalid input or empty input are not addressed in the annotations.

#Function 4:
#State of the program right berfore the function call: **Precondition**: The input consists of t requests, each containing three integers ni, li, ri where 1 ≤ t ≤ 1000, 1 ≤ ni, li, ri ≤ 10^9, and li ≤ ri.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the input values after splitting them by space.
#Overall this is what the function does:The function func_4 does not accept any parameters. It reads an input line, splits it by space, converts each element to a string, and returns a map object containing these string representations. The code does not handle the processing of t requests containing three integers ni, li, ri as described in the annotations. Additionally, the function does not impose any restrictions on the input format or handle any edge cases related to the input values.

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(func_3())
    #The program returns a list that is the result of calling the function 'func_3()'
#Overall this is what the function does:The function func_5 does not accept any parameters and returns a list that is the result of calling the function 'func_3()'.

#Function 6:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer, ni, li, ri are positive integers such that 1 <= ni, li, ri <= 10^9 and li <= ri.**
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` does not accept any parameters. It initializes the recursion limit and stack size, creates a new thread with the `main` function as the target, and starts the thread. The function does not explicitly return any value, and its purpose seems to be to initiate a parallel task using threading. The actual computations and results are expected to be handled within the `main` function that is being targeted by the thread. The annotations provide preconditions regarding the values of variables `t`, `ni`, `li`, and `ri`, but the function itself does not perform any significant calculations or return specific results based on these constraints.

#Function 7:
#State of the program right berfore the function call: **
def func_7(item):
    return item[1]
    #The program returns the value of the element at index 1 of the variable 'item'
#Overall this is what the function does:The function accepts a parameter `item` which is expected to be an iterable (e.g., list, tuple) and returns the value of the element at index 1 of the variable 'item'.

#Function 8:
#State of the program right berfore the function call: l is a list where each element is a tuple of three integers ni, li, ri such that 1 <= ni, li, ri <= 10^9 and li <= ri.**
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted based on the custom key function getKey in descending order
#Overall this is what the function does:The function func_8 accepts a list 'l' where each element is a tuple of three integers. It then sorts the list 'l' in descending order based on a custom key function getKey.

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the number of universities, m is a list of tuples where each tuple contains three positive integers ni, li, ri (1 <= ni, li, ri <= 10^9) where li <= ri.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program creates a 2D list where each row represents a university and contains 'm' tuples, each tuple consists of three positive integers ni, li, ri (1 <= ni, li, ri <= 10^9) where li <= ri.
#Overall this is what the function does:The function `func_9` accepts three parameters: `n`, `m`, and `num`. `n` is a positive integer representing the number of universities. `m` is a list of tuples where each tuple contains three positive integers ni, li, ri (1 <= ni, li, ri <= 10^9) where li <= ri. `num` is not used in the program. The function creates a 2D list where each row represents a university and contains 'm' tuples, each tuple consisting of three positive integers ni, li, ri (1 <= ni, li, ri <= 10^9) where li <= ri.

#Function 10:
#State of the program right berfore the function call: t is a positive integer (1 <= t <= 1000). Each query contains three integers ni, li, ri where 1 <= ni, li, ri <= 10^9 and li <= ri.**
def func_10(x):
    return x and not x & x - 1
    #The program returns the result of performing a bitwise operation on x and not x & x - 1
#Overall this is what the function does:The function func_10 accepts a positive integer `x` and returns the result of performing a bitwise operation on x and not x & x - 1. The function checks if x is a power of 2 by performing a bitwise operation and returns True if x is a power of 2, otherwise it returns False.

#Function 11:
#State of the program right berfore the function call: **Precondition**: 
- t is a positive integer such that 1 ≤ t ≤ 1000.
- For each of the t queries:
  - ni, li, ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9.
  - li is less than or equal to ri.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n after removing the '0b' prefix
#Overall this is what the function does:The function `func_11` accepts a positive integer `n` and returns its binary representation after removing the '0b' prefix. The function does not specify any conditions related to the values of `ni`, `li`, and `ri` mentioned in the annotations. It solely focuses on converting `n` to binary format.

#Function 12:
#State of the program right berfore the function call: t is a positive integer (1 <= t <= 1000) and for each query, ni, li, ri are positive integers such that 1 <= ni, li, ri <= 10^9 and li <= ri.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each element is a digit of the positive integer 'n'. 'n' is a positive integer with 1 <= n <= 1000.
#Overall this is what the function does:The function func_12 accepts a positive integer n with 1 <= n <= 1000 and returns a list of integers where each element is a digit of n. The function correctly converts the positive integer n into a list of its individual digits.

#Function 13:
#State of the program right berfore the function call: **
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combination formula calculation based on the values of 'n' and 'r'.
#Overall this is what the function does:The function func_13 accepts two integer parameters, n and r, and calculates the result of the combination formula using these values. It returns the result of nCr (n choose r) where n and r are the inputs provided to the function.

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 1000.
- For each query, ni, li, ri are integers such that 1 <= ni, li, ri <= 10^9 and li <= ri.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer value of x divided by y
    else :
        return x // y + 1
        #The program returns the result of dividing x by y, rounding up to the nearest integer
#Overall this is what the function does:The function `func_14` accepts two integer parameters `x` and `y`. It checks if `x` is divisible by `y`. If it is divisible, it returns the integer value of the division. If it is not divisible, it returns the result of dividing `x` by `y` and rounding up to the nearest integer.

#Function 15:
#State of the program right berfore the function call: x, y, and p are integers such that 1 <= x, y, p <= 109 and x <= p.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x`, `y`, and `p` are integers such that 1 <= x, y, p <= 109 and x <= p; `y` is 0; `res` is updated based on the multiplication and modulo operations according to the conditions met during the loop execution
    return res
    #The program returns the final value of 'res' after executing the loop based on the conditions met during the execution. The initial values are x, y, and p as integers such that 1 <= x, y, p <= 109 and x <= p. 'y' is initially set to 0.
#Overall this is what the function does:The function `func_15` accepts three integer parameters `x`, `y`, and `p` within the specified constraints. The parameter `y` is initially set to 0. The function then performs a series of modulo, multiplication, and bitwise operations inside a loop to update the value of `res`. Finally, it returns the final value of `res` after the loop has been executed. The function iterates through the loop based on the conditions met during the execution, updating `res` accordingly.

#Function 16:
#State of the program right berfore the function call: **
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` and `y` have been swapped, `x` is assigned the result of the modulo operation of the original `x` and `y`, `y` is 0
    return x
    #The program returns the result of the modulo operation of the original 'x' and 'y', where 'y' is 0
#Overall this is what the function does:The function func_16 accepts two parameters x and y, swaps their values iteratively until y becomes 0, and then returns the result of the modulo operation of the original x and y, where y is 0. The function essentially implements the Euclidean algorithm to find the greatest common divisor of x and y.

#Function 17:
#State of the program right berfore the function call: **
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer. n is larger than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is an integer. n is larger than 1, n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer. n is larger than 1 and larger than 3. n is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer larger than 1 and 3, not divisible by 2 or 3, the loop terminates with `i` adjusted to a value greater than the square root of `n`
    return True
    #The program returns True
#Overall this is what the function does:The function `func_17` accepts an integer parameter `n` and returns False if `n` is less than or equal to 1, True if `n` is less than or equal to 3, False if `n` is divisible by 2 or 3, and True otherwise after checking for divisibility by numbers starting from 5 in increments of 6 until reaching the square root of `n`.

#Function 18:
#State of the program right berfore the function call: 
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_18` reassigns the standard input and output to read from 'input.txt' and write to 'output.txt'. The function then returns the number 18.

#Function 19:
#State of the program right berfore the function call: **
def func_19():
    for _ in range(func_1()):
        n, l, r = func_3()
        
        low = 1
        
        high = 1000000000
        
        f = 0
        
        while low <= high:
            mid = (low + high) // 2
            x = l * mid
            y = r * mid
            if x <= n and n <= y:
                f = 1
                break
            if y < n:
                low = mid + 1
            else:
                high = mid - 1
        
        if f:
            func_20('Yes')
        else:
            func_20('No')
        
    #State of the program after the  for loop has been executed: After all iterations of the loop, 'n', 'l', 'r' are greater than 0; 'low' is greater than high; 'mid' is the value that satisfies the conditions in the loop; 'x' is the product of 'l' and 'mid'; 'y' is the product of 'r' and 'mid'. The loop will terminate when 'low' becomes greater than 'high' or when the condition 'x <= n and n <= y' is met. If 'f' is true, the program will execute the if part with the given conditions. If 'f' is false, the program will execute the else part with the same conditions.
#Overall this is what the function does:The function `func_19` does not accept any parameters and iterates a loop multiple times. Within each iteration, it calculates whether a given condition is satisfied based on the values of `n`, `l`, and `r`. If the condition is met, it calls `func_20` with the argument 'Yes', otherwise with 'No'. After all iterations, the function always returns the number 19.

#Function 20:
#State of the program right berfore the function call: **
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` and `file` have specific values, `at_start` is False, all elements in `args` have been written as strings to the file specified by `file`
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` and `file` have specific values, `at_start` is False, all elements in `args` have been written as strings to the file specified by `file`. The `kwargs` dictionary pops the value associated with the key 'end' and writes it to the file. If the 'flush' key with a value of False is present in `kwargs`, then it is popped from the dictionary.
#Overall this is what the function does:The function `func_20` does not accept any parameters and writes the elements in `args` to a specified file with a separator `sep`. It then writes the value associated with the key 'end' in the `kwargs` dictionary to the file. If the key 'flush' with a value of False exists in `kwargs`, it flushes the file. The function does not return any value.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.