
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given n strings. Each string consists of lowercase English letters. Rearrange (reorder) the given strings in such a way that for every string, all strings that are placed before it are its substrings.

String a is a substring of string b if it is possible to choose several consecutive letters in b in such a way that they form a. For example, string "for" is contained as a substring in strings "codeforces", "for" and "therefore", but is not contained as a substring in strings "four", "fofo" and "rof".

Input

The first line contains an integer n (1 ≤ n ≤ 100) — the number of strings.

The next n lines contain the given strings. The number of letters in each string is from 1 to 100, inclusive. Each string consists of lowercase English letters.

Some strings might be equal.

Output

If it is impossible to reorder n given strings in required order, print "NO" (without quotes).

Otherwise print "YES" (without quotes) and n given strings in required order.

Examples

Input

5
a
aba
abacaba
ba
aba


Output

YES
a
ba
aba
aba
abacaba


Input

5
a
abacaba
ba
aba
abab


Output

NO


Input

3
qwerty
qwerty
qwerty


Output

YES
qwerty
qwerty
qwerty

Note

In the second example you cannot reorder the strings because the string "abab" is not a substring of the string "abacaba".
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: **
def func():
    t = int(raw_input())
    ls = []
    while t > 0:
        a = raw_input()
        
        ls.append(a)
        
        t = t - 1
        
    #State of the program after the loop has been executed: `t` is 0, `ls` contains all the values of `a` inputted during the loop iterations, `a` is assigned the value of the last raw input
    dict1 = {}
    for x in ls:
        count = 0
        
        for z in ls:
            if x in z:
                count = count + 1
        
        dict1[x] = count
        
    #State of the program after the  for loop has been executed: `t` is 0, `ls` contains all the values inputted during the loop iterations, `a` is assigned the value of the last raw input, `count` is the total number of times `x` appears in `ls`, `x` is the last value in `ls`, `dict1[x]` is equal to `count`, and `x` is in each `z` in `ls
    sorted_x = sorted(dict1.items(), key=operator.itemgetter(1))
    sorted_x.reverse()
    c2 = 0
    for item in sorted_x:
        if item[1] == 1:
            c2 = c2 + 1
        
    #State of the program after the  for loop has been executed: `sorted_x` contains the items of `dict1` sorted based on the values in descending order, `c2` is the number of items in `sorted_x` where the second element of the item is equal to 1.
    if (c2 > 1) :
        print('NO')
    else :
        print('YES')
        for x in sorted_x:
            c1 = ls.count(x[0])
            
            for z in range(c1):
                print(x[0])
            
        #State of the program after the  for loop has been executed: All characters of all items in `sorted_x` are printed according to their count in `ls`, `sorted_x` has `c1+1` items, count of `x[0]` in `ls` is now `c1+2`, `c1` is assigned the count of `x[0]` in `ls`, `z` is 0
    #State of the program after the if-else block has been executed: *`sorted_x` contains the items of `dict1` sorted based on the values in descending order, `c2` is the number of items in `sorted_x` where the second element of the item is equal to 1. If `c2` is greater than 1, the original state is maintained. Otherwise, all characters of all items in `sorted_x` are printed according to their count in `ls`, `sorted_x` has `c1+1` items, count of `x[0]` in `ls` is now `c1+2`, `c1` is assigned the count of `x[0]` in `ls`, and `z` is 0.
#Overall this is what the function does:The function reads an integer `t` from the user as input. Then, it reads `t` strings and stores them in a list `ls`. After that, it creates a dictionary `dict1` where the keys are the strings from `ls` and the values represent how many times each string appears in `ls`. The function then sorts `dict1` based on the values in descending order and checks if there is more than one item with a count of 1. If there is, it prints 'NO', otherwise it prints 'YES'. Additionally, it prints out the characters based on their count in the sorted dictionary. The function does not accept any parameters and returns the output based on the described conditions.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
