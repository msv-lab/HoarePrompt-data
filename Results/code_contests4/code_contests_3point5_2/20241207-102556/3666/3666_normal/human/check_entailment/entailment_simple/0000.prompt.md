
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given two segments [l_1; r_1] and [l_2; r_2] on the x-axis. It is guaranteed that l_1 < r_1 and l_2 < r_2. Segments may intersect, overlap or even coincide with each other.

<image> The example of two segments on the x-axis.

Your problem is to find two integers a and b such that l_1 ≤ a ≤ r_1, l_2 ≤ b ≤ r_2 and a ≠ b. In other words, you have to choose two distinct integer points in such a way that the first point belongs to the segment [l_1; r_1] and the second one belongs to the segment [l_2; r_2].

It is guaranteed that the answer exists. If there are multiple answers, you can print any of them.

You have to answer q independent queries.

Input

The first line of the input contains one integer q (1 ≤ q ≤ 500) — the number of queries.

Each of the next q lines contains four integers l_{1_i}, r_{1_i}, l_{2_i} and r_{2_i} (1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}) — the ends of the segments in the i-th query.

Output

Print 2q integers. For the i-th query print two integers a_i and b_i — such numbers that l_{1_i} ≤ a_i ≤ r_{1_i}, l_{2_i} ≤ b_i ≤ r_{2_i} and a_i ≠ b_i. Queries are numbered in order of the input.

It is guaranteed that the answer exists. If there are multiple answers, you can print any.

Example

Input


5
1 2 1 2
2 6 3 4
2 4 1 3
1 2 1 3
1 4 5 8


Output


2 1
3 4
3 2
1 2
3 7
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    return int(input())
    #The program returns an integer obtained from user input

#Function 2:
#State of the program right berfore the function call: **
def func_2():
    return input()
    #The program returns the user input as a string

#Function 3:
#State of the program right berfore the function call: **
def func_3():
    return map(int, input().split(' '))
    #The program returns a map object created by applying the int function to each element of the input obtained from splitting the user input by spaces.

#Function 4:
#State of the program right berfore the function call: **
def func_4():
    return map(str, input().split(' '))
    #The program returns a map object that applies the str function to each element after splitting the input string by spaces

#Function 5:
#State of the program right berfore the function call: Each query consists of four integers l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} where 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.**
def func_5():
    return list(func_3())
    #The program returns a list after calling the function func_3()

#Function 6:
#State of the program right berfore the function call: Each query contains four integers l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9 and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.**
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: Each query contains four integers l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.**
def func_7(n):
    sum = 0
    while n > 0:
        sum += int(n % 10)
        
        n = int(n / 10)
        
    #State of the program after the loop has been executed: `sum` is the sum of all the digits of the original value of `n`, `n` is 0
    return sum
    #The program returns the sum of all the digits of the original value of 'n', where 'n' is 0.

#Function 8:
#State of the program right berfore the function call: **
def func_8(x):
    return x and not x & x - 1
    #The program returns 0 if 'x' is 0, otherwise it returns 1

#Function 9:
#State of the program right berfore the function call: **
def func_9(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor of the original `x` and `y`, `y` is 0
    return x
    #The program returns the greatest common divisor of the original 'x' and 0, which is 'x' itself

#Function 10:
#State of the program right berfore the function call: **
def func_10(a, b):
    if (a == 0) :
        return b, 0, 1
        #The program returns values of 'b', 0, and 1
    #State of the program after the if block has been executed: *a is equal to 0 and all other conditions remain the same, a is not equal to 0 after the else block is executed
    gcd, x1, y1 = func_10(b % a, a)
    x = y1 - b // a * x1
    y = x1
    return gcd, x, y
    #The program returns the values of gcd, x, and y. The value of x is dependent on variables y1, b, and x1. The value of y is assigned the value of x1.

#Function 11:
#State of the program right berfore the function call: **For each query, l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} are integers such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.
def func_11(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *For each query, l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} are integers such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i>. n is an integer larger than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *For each query, l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} are integers such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i>. n is an integer larger than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *For each query, l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} are integers such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i>. n is an integer larger than 1 and n is larger than 3. n is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: If neither n % i == 0 nor n % (i + 2) == 0 for all values of i assigned in the loop, then the loop terminates with i being an integer greater than the square root of n.
    return True
    #The program returns True

#Function 12:
#State of the program right berfore the function call: Each query consists of four integers l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9 and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.**
def func_12(n):
    if (n == 0) :
        return 0, 1
        #The program returns 0 and 1
    #State of the program after the if block has been executed: *Each query consists of four integers l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9 and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}. n is not equal to 0 and the values of l_{1_i}, r_{1_i}, l_{2_i}, and r_{2_i} remain within the specified range
    p = func_12(n >> 1)
    c = p[0] * (2 * p[1] - p[0])
    d = p[0] * p[0] + p[1] * p[1]
    if (n & 1) :
        return c + 2 * d
        #The program returns the value of 'c' calculated based on 'p[0]' and 'p[1]' added to 2 times the value of 'd', where 'p' is the result of func_12(n >> 1) and 'n' is an odd number that is not equal to 0
    else :
        return c + d
        #The program returns the sum of 'c' and 'd', where 'c' is calculated based on the values of p[0] and p[1], and 'd' is the result of p[0] * p[0] + p[1] * p[1]

#Function 13:
#State of the program right berfore the function call: q is an integer such that 1 <= q <= 500. Each query contains four integers l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9 and l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.**
def func_13():
    sys.stdin = open('input.txt', 'r')

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- q is an integer such that 1 <= q <= 500.
- l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} are integers such that 1 <= l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} <= 10^9.
- l_{1_i} < r_{1_i} and l_{2_i} < r_{2_i} for each query.
def func_14(x, y):
    res = 1
    while y > 0:
        if y & 1:
            res = res * x
        
        x = x * x
        
        y >>= 1
        
    #State of the program after the loop has been executed: Output State: `res`, `x`, `y` are integers. If `y` is odd, `res` is multiplied by `x`, `y` is divided by 2, `x` is squared, and `y` is shifted right by 1. For the loop to execute again, `y` must be greater than 1. After the execution of the code `x = x * x`, the value of `x` is squared. Now, `y` is shifted right by 1.
    return res
    #The program returns the final value of 'res' after the loop execution

#Function 15:
#State of the program right berfore the function call: **
def func_15():
    q = func_1()
    for i in range(q):
        l1, r1, l2, r2 = func_3()
        
        func_16(l1, r2)
        
    #State of the program after the  for loop has been executed: Output State: The function `func_16` is called with arguments `l1` and `r2` for each iteration of the loop, where `l1` and `r2` are the values returned by `func_3()`. The loop will execute `q` times in total, assuming `q` is a non-negative integer returned by `func_1()`.

#Function 16:
#State of the program right berfore the function call: q is a positive integer. Each query contains four integers l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}.**
def func_16():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: q is a positive integer, at_start is False, args is not empty, x is the last element in args
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *q is a positive integer, at_start is False, args is not empty, x is the last element in args. If 'flush' key in kwargs is popped with a value of False, then the program retains the same state as before the execution of the if statement.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
