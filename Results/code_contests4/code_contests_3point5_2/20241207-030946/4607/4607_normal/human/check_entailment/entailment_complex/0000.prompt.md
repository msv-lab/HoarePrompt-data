
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    return int(input())
    #The program returns an integer value obtained from the user input
#Overall this is what the function does:The function func_1 prompts the user to input an integer value and returns that integer value.

#Function 2:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n. Each integer in the sequence is a positive integer that doesn't exceed 10^8.**
def func_2():
    return input()
    #The program returns the input value provided
#Overall this is what the function does:The function `func_2` does not accept any parameters. The functionality of the function is to simply return the input value provided. The function lacks validation or processing of the input data beyond returning it as is.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the list of positive integers from the input sequence after converting them to integers
#Overall this is what the function does:The function `func_3` does not accept any parameters. It reads an input sequence of positive integers from Alexander's cards, converts them to integers, and returns a map object containing these integers. The code does not handle any potential errors such as invalid input or empty sequences.

#Function 4:
#State of the program right berfore the function call: n is a positive integer, and the sequence of integers on Alexander's cards is a list of positive integers.**
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a list of strings where each integer in the sequence of integers on Alexander's cards is converted to a string
#Overall this is what the function does:The function does not accept any parameters. It takes a sequence of integers as input from the user, converts each integer in the sequence to a string, and returns a list of strings.

#Function 5:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 1 <= n <= 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_5():
    return list(func_3())
    #The program returns a list of positive integers, each not exceeding 10^8, generated by calling the function func_3()
#Overall this is what the function does:The function func_5 does not accept any parameters and returns a list of positive integers, each not exceeding 10^8, generated by calling the function `func_3`.

#Function 6:
#State of the program right berfore the function call: **
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit and stack size, creates a new thread running the `main` function, and starts the thread. It does not accept any input parameters. The function does not have a clear return value or specific task defined within its body.

#Function 7:
#State of the program right berfore the function call: **
def func_7(item):
    return item[1]
    #The program returns the value at index 1 of the variable 'item'
#Overall this is what the function does:The function func_7 accepts a parameter item and returns the value at index 1 of the variable 'item'.

#Function 8:
#State of the program right berfore the function call: l is a list of integers representing the numbers on Alexander's cards.**
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list 'l' sorted based on the key function 'getKey'
#Overall this is what the function does:The function func_8 accepts a list of integers representing the numbers on Alexander's cards and returns the list sorted based on the key function `getKey`. The code implements the sorting functionality correctly as per the annotations.

#Function 9:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 105), m is a list of n positive integers, each not exceeding 10^8.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of n sublists, each containing m copies of the positive integers from the list 'm'.
#Overall this is what the function does:The function func_9 accepts a positive integer n, a list of positive integers m, and an undefined parameter num. It then returns a list of n sublists, each containing m copies of the positive integer num.

#Function 10:
#State of the program right berfore the function call: **
def func_10(x):
    return x and not x & x - 1
    #The program returns the result of logical AND operation between x and the logical NOT of x AND the result of subtracting 1 from x.
#Overall this is what the function does:The function func_10 accepts a parameter x and returns the result of the logical AND operation between x and the logical NOT of x AND the result of subtracting 1 from x.

#Function 11:
#State of the program right berfore the function call: n is a positive integer.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n without the '0b' prefix
#Overall this is what the function does:The function func_11 accepts a positive integer n and returns its binary representation without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is a positive integer.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit of the positive integer n
#Overall this is what the function does:The function accepts a positive integer n and returns a list of integers where each integer is a digit of n.

#Function 13:
#State of the program right berfore the function call: **
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res` is the result of `x` to the power of `y` modulo `p`, `x` is an integer, `p` is an integer, `y` is 0
    return res
    #The program returns the result of x to the power of y modulo p, where y is 0
#Overall this is what the function does:The function `func_13` accepts three integer parameters `x`, `y`, and `p`, and calculates the result of `x` to the power of `y` modulo `p`, where `y` is 0. The function uses a loop to perform this calculation with bitwise operations. It handles cases where `y` is 0 correctly.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 <= x <= 10^5) and y is a list of integers representing the numbers on Alexander's cards.**
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x is the greatest common divisor of the original numbers in the list y, y is an empty list
    return x
    #The program returns the greatest common divisor of the original numbers in the empty list y
#Overall this is what the function does:The function accepts an integer x representing the number of cards and a list of integers y. It calculates the greatest common divisor of the original numbers in the list y and returns that value. If the list y is empty, the function returns x.

#Function 15:
#State of the program right berfore the function call: n is a positive integer.**
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is a positive integer larger than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is a positive integer larger than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: Postcondition: *n is a positive integer larger than 1. n is larger than 3. n is not divisible by 2 or 3*
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is a positive integer larger than 1, not divisible by 2 or 3, and larger than 3; i is greater than n, the loop has terminated with no return statement executed
    return True
    #The program returns True
#Overall this is what the function does:The function `func_15` accepts a positive integer `n` and determines whether `n` is a prime number. It follows a series of conditions and loops to check if `n` is divisible by numbers other than 1 and itself. If `n` passes all checks, the function returns True, indicating that `n` is a prime number. Otherwise, it returns False.

#Function 16:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_16` sets up the standard input and output to read from and write to files respectively. It does not accept any parameters explicitly but internally uses variables `n` and a sequence of integers on Alexander's cards. The function does not return any value explicitly as the output is not provided in the description.

#Function 17:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n and each integer is a positive integer not exceeding 10^8.**
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ n ≤ 10^5. If `n` equals 1, then the program returns n = 1.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ n ≤ 10^5. If `n` equals 1, the program returns n = 1. After entering the if condition where n == 2, the state of the program is such that n is equal to 2. If a[0] == a[1], then n is equal to 1.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *If a[0] == a[1], then n is equal to 1; `l` is a list containing the value of a[0] plus half of the absolute difference between a[0] and a[1]; `g` is the difference between a[0] and a[1] where the absolute value of `g` is divisible by 2.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ n ≤ 10^5. If n equals 1, the program returns n = 1. If n == 2 and a[0] == a[1], then n is equal to 1. List `l` contains a[0] plus half of the absolute difference between a[0] and a[1], a[0] - (a[1] - a[0]), a[1] + (a[1] - a[0]). The absolute value of the difference between a[0] and a[1] is divisible by 2 and stored in `g`. List `l` is sorted and the length of `l` is returned by the function `func_18`.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, and `i` is `n-1`. If the length of the list of unique elements in `g` is greater than 2, then the program does something specific based on that condition.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`, and the length of the list of unique elements in `g` is not equal to 1. Additionally, 0 is in `l`. If the length of the list of unique elements in `g` is greater than or equal to 2, then no variables are affected and the program exits immediately.
        #State of the program after the if block has been executed: *`n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`, and the length of the list of unique elements in `g` is not equal to 1. If 0 is in `l` and the length of the list of unique elements in `g` is greater than or equal to 2, then no variables are affected and the program exits immediately.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `gc` is the result of applying `func_14` to all elements in list `l` starting from the second element
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `gc` is the result of applying `func_14` to all elements in list `l` starting from the second element. The loop will break if the absolute difference between `a[i + 1]` and `a[i]` is not equal to `gc`. New elements may be appended to list `a` based on calculations for `x`.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `l` will contain the consecutive differences between elements of `a` in ascending order, `n` will be the total number of elements in `l`, and `i` will be equal to `n - 1` at the end of the loop.
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`l` contains the consecutive differences between elements of `a` in ascending order, `n` is the total number of elements in `l`, `i` is equal to `n - 1` at the end of the loop. If all elements in `l` are the same, the function `func_18` is called with the argument 1. Otherwise, the elements of `l` are not all equal.
    #State of the program after the if-else block has been executed: *`n` is at least 2, `l` contains unique elements sorted in ascending order, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`. If all elements in `l` are the same and the length of the list of unique elements in `g` is equal to 1, the function `func_18` is called with the argument 1. Otherwise, the elements of `l` are not all equal and the length of the list of unique elements in `g` is not equal to 1.
#Overall this is what the function does:The function `func_17` does not accept any parameters but operates under the preconditions specified. It computes a sequence of integers based on conditions specified within the code. The function ends with different return values based on the calculated sequence. The function may terminate with different outputs depending on the logic implemented, including returning 0, 1, or specific calculated values in the sequence.

#Function 18:
#State of the program right berfore the function call: **
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: Output State: `sep` is ' ', `file` is sys.stdout, `at_start` is False, `args` is not empty with all elements in `args` being written to the `file` separated by the `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` is sys.stdout, `at_start` is False, `args` is not empty with all elements in `args` being written to the `file` separated by the `sep`, `kwargs` has 'flush' key popped and its value is True if present.
#Overall this is what the function does:The function does not accept any parameters and prints the elements of `args` to the standard output with a space separator. It then writes a newline character to the standard output. If the 'flush' key is present in the kwargs with a value of True, it flushes the output. The function always returns the number 18.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.