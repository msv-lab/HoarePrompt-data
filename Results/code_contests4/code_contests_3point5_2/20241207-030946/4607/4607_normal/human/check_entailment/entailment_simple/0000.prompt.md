
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    return int(input())
    #The program returns an integer value obtained from the user input

#Function 2:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n. Each integer in the sequence is a positive integer that doesn't exceed 10^8.**
def func_2():
    return input()
    #The program returns the input value provided

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the list of positive integers from the input sequence after converting them to integers

#Function 4:
#State of the program right berfore the function call: n is a positive integer, and the sequence of integers on Alexander's cards is a list of positive integers.**
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a list of strings where each integer in the sequence of integers on Alexander's cards is converted to a string

#Function 5:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 1 <= n <= 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_5():
    return list(func_3())
    #The program returns a list of positive integers, each not exceeding 10^8, generated by calling the function func_3()

#Function 6:
#State of the program right berfore the function call: **
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: **
def func_7(item):
    return item[1]
    #The program returns the value at index 1 of the variable 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of integers representing the numbers on Alexander's cards.**
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list 'l' sorted based on the key function 'getKey'

#Function 9:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 105), m is a list of n positive integers, each not exceeding 10^8.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of n sublists, each containing m copies of the positive integers from the list 'm'.

#Function 10:
#State of the program right berfore the function call: **
def func_10(x):
    return x and not x & x - 1
    #The program returns the result of logical AND operation between x and the logical NOT of x AND the result of subtracting 1 from x.

#Function 11:
#State of the program right berfore the function call: n is a positive integer.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n without the '0b' prefix

#Function 12:
#State of the program right berfore the function call: n is a positive integer.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit of the positive integer n

#Function 13:
#State of the program right berfore the function call: **
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res` is the result of `x` to the power of `y` modulo `p`, `x` is an integer, `p` is an integer, `y` is 0
    return res
    #The program returns the result of x to the power of y modulo p, where y is 0

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 <= x <= 10^5) and y is a list of integers representing the numbers on Alexander's cards.**
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x is the greatest common divisor of the original numbers in the list y, y is an empty list
    return x
    #The program returns the greatest common divisor of the original numbers in the empty list y

#Function 15:
#State of the program right berfore the function call: n is a positive integer.**
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is a positive integer larger than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is a positive integer larger than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: Postcondition: *n is a positive integer larger than 1. n is larger than 3. n is not divisible by 2 or 3*
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is a positive integer larger than 1, not divisible by 2 or 3, and larger than 3; i is greater than n, the loop has terminated with no return statement executed
    return True
    #The program returns True

#Function 16:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: **Precondition**: **n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n and each integer is a positive integer not exceeding 10^8.**
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ n ≤ 10^5. If `n` equals 1, then the program returns n = 1.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ n ≤ 10^5. If `n` equals 1, the program returns n = 1. After entering the if condition where n == 2, the state of the program is such that n is equal to 2. If a[0] == a[1], then n is equal to 1.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *If a[0] == a[1], then n is equal to 1; `l` is a list containing the value of a[0] plus half of the absolute difference between a[0] and a[1]; `g` is the difference between a[0] and a[1] where the absolute value of `g` is divisible by 2.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ n ≤ 10^5. If n equals 1, the program returns n = 1. If n == 2 and a[0] == a[1], then n is equal to 1. List `l` contains a[0] plus half of the absolute difference between a[0] and a[1], a[0] - (a[1] - a[0]), a[1] + (a[1] - a[0]). The absolute value of the difference between a[0] and a[1] is divisible by 2 and stored in `g`. List `l` is sorted and the length of `l` is returned by the function `func_18`.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, and `i` is `n-1`. If the length of the list of unique elements in `g` is greater than 2, then the program does something specific based on that condition.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`, and the length of the list of unique elements in `g` is not equal to 1. Additionally, 0 is in `l`. If the length of the list of unique elements in `g` is greater than or equal to 2, then no variables are affected and the program exits immediately.
        #State of the program after the if block has been executed: *`n` is at least 2, `l` contains the absolute differences between adjacent elements of list `a`, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`, and the length of the list of unique elements in `g` is not equal to 1. If 0 is in `l` and the length of the list of unique elements in `g` is greater than or equal to 2, then no variables are affected and the program exits immediately.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `gc` is the result of applying `func_14` to all elements in list `l` starting from the second element
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `gc` is the result of applying `func_14` to all elements in list `l` starting from the second element. The loop will break if the absolute difference between `a[i + 1]` and `a[i]` is not equal to `gc`. New elements may be appended to list `a` based on calculations for `x`.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `l` will contain the consecutive differences between elements of `a` in ascending order, `n` will be the total number of elements in `l`, and `i` will be equal to `n - 1` at the end of the loop.
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`l` contains the consecutive differences between elements of `a` in ascending order, `n` is the total number of elements in `l`, `i` is equal to `n - 1` at the end of the loop. If all elements in `l` are the same, the function `func_18` is called with the argument 1. Otherwise, the elements of `l` are not all equal.
    #State of the program after the if-else block has been executed: *`n` is at least 2, `l` contains unique elements sorted in ascending order, `g` contains the differences between adjacent elements of list `a`, `i` is `n-1`. If all elements in `l` are the same and the length of the list of unique elements in `g` is equal to 1, the function `func_18` is called with the argument 1. Otherwise, the elements of `l` are not all equal and the length of the list of unique elements in `g` is not equal to 1.

#Function 18:
#State of the program right berfore the function call: **
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: Output State: `sep` is ' ', `file` is sys.stdout, `at_start` is False, `args` is not empty with all elements in `args` being written to the `file` separated by the `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` is sys.stdout, `at_start` is False, `args` is not empty with all elements in `args` being written to the `file` separated by the `sep`, `kwargs` has 'flush' key popped and its value is True if present.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
