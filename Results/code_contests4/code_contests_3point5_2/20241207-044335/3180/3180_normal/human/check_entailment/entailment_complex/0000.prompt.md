
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A sequence a_1,a_2,... ,a_n is said to be /\/\/\/ when the following conditions are satisfied:

* For each i = 1,2,..., n-2, a_i = a_{i+2}.
* Exactly two different numbers appear in the sequence.



You are given a sequence v_1,v_2,...,v_n whose length is even. We would like to make this sequence /\/\/\/ by replacing some of its elements. Find the minimum number of elements that needs to be replaced.

Constraints

* 2 \leq n \leq 10^5
* n is even.
* 1 \leq v_i \leq 10^5
* v_i is an integer.

Input

Input is given from Standard Input in the following format:


n
v_1 v_2 ... v_n


Output

Print the minimum number of elements that needs to be replaced.

Examples

Input

4
3 1 3 2


Output

1


Input

6
105 119 105 119 105 119


Output

0


Input

4
1 1 1 1


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is an even integer greater than or equal to 2. v_1, v_2, ..., v_n are integers such that 1 <= v_i <= 10^5 for i = 1, 2, ..., n.**
def func():
    n = int(raw_input())
    v = map(int, raw_input().split())
    even = [vi for i, vi in enumerate(v) if i % 2 == 0]
    odd = [vi for i, vi in enumerate(v) if i % 2 == 1]
    evenc = collections.Counter(even)
    oddc = collections.Counter(odd)
    evenc_most_common = evenc.most_common(len(set(even))) + [(None, 0)]
    oddc_most_common = oddc.most_common(len(set(odd))) + [(None, 0)]
    m = []
    for i in range(2):
        for j in range(2):
            if evenc_most_common[i][0] != oddc_most_common[j][0]:
                a = len(even) - evenc_most_common[i][1]
                b = len(odd) - oddc_most_common[j][1]
                m.append(a + b)
        
    #State of the program after the  for loop has been executed: After all iterations of the loop, `m` contains the result of `a + b` appended at the end for each iteration where `evenc_most_common[i][0] != oddc_most_common[j][0]`. If the condition `evenc_most_common[i][0] != oddc_most_common[j][0]` is false for all iterations, then `m` remains the same as the initial state.
    print(min(m))
#Overall this is what the function does:The function reads an integer n and a list of integers v. It then separates the elements of v into even and odd indexed lists, counts the occurrences of each value in the lists, finds the most common values in each list, and calculates the difference between the total number of elements and the frequency of the most common values. Finally, it prints the minimum sum of these differences.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
