
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given a rooted tree with n vertices. In each leaf vertex there's a single integer — the number of apples in this vertex. 

The weight of a subtree is the sum of all numbers in this subtree leaves. For instance, the weight of a subtree that corresponds to some leaf is the number written in the leaf.

A tree is balanced if for every vertex v of the tree all its subtrees, corresponding to the children of vertex v, are of equal weight. 

Count the minimum number of apples that you need to remove from the tree (specifically, from some of its leaves) in order to make the tree balanced. Notice that you can always achieve the goal by just removing all apples.

Input

The first line contains integer n (2 ≤ n ≤ 105), showing the number of vertices in the tree. The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 108), ai is the number of apples in the vertex number i. The number of apples in non-leaf vertices is guaranteed to be zero. 

Then follow n - 1 lines, describing the tree edges. Each line contains a pair of integers xi, yi (1 ≤ xi, yi ≤ n, xi ≠ yi) — the vertices connected by an edge. 

The vertices are indexed from 1 to n. Vertex 1 is the root.

Output

Print a single integer — the minimum number of apples to remove in order to make the tree balanced.

Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the sin, cout streams cin, cout or the %I64d specifier.

Examples

Input

6
0 0 12 13 5 6
1 2
1 3
1 4
2 5
2 6


Output

6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5.**
def func_1(n):
    return [raw_input().strip() for i in range(n)]
    #The program returns a list of n strings after stripping any leading or trailing whitespaces entered by the user for each string in the list.

#Function 2:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5. The list of integers a1, a2, ..., an is of length n and each ai is an integer such that 0 <= ai <= 10^8. The tree edges are given as pairs of integers xi, yi where 1 <= xi, yi <= n and xi != yi.**
def func_2():
    return raw_input().strip()
    #The program returns the input string after stripping any leading or trailing whitespaces

#Function 3:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5. ai is an integer such that 0 <= ai <= 10^8.**
def func_3():
    return map(int, func_2().split())
    #The program returns a map object containing integers after splitting the result of func_2()

#Function 4:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5, ai is an integer such that 0 <= ai <= 10^8 for each 1 <= i <= n, and xi, yi are integers such that 1 <= xi, yi <= n and xi != yi.**
def func_4():
    return func_3()[0]
    #The program returns the first element of the result of calling the function func_3()

#Function 5:
#State of the program right berfore the function call: o is a tuple of an integer n followed by a list of n integers representing the number of apples in each vertex of the tree, followed by n-1 tuples of two integers representing the edges in the tree.
def func_5(o):
    print(o)

#Function 6:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5. a is a list of n integers where each element ai is an integer such that 0 <= ai <= 10^8.**
def func_6(a, b):
    while b != 0:
        a %= b
        
        a, b = b, a
        
    #State of the program after the loop has been executed: `n` is an integer such that 2 <= n <= 10^5, `a` is a list of n integers modified after all iterations of the loop, `b` is 0 after all iterations
    return a
    #The program returns the list 'a' of n integers modified after all iterations of the loop

#Function 7:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5, and ai is an integer such that 0 <= ai <= 10^8 for 1 <= i <= n.**
def func_7(a, b):
    return a / func_6(a, b) * b
    #The program returns the result of dividing variable 'a' by the return value of function func_6(a, b), multiplied by variable 'b'.

#Function 8:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5, and ai is an integer such that 0 <= ai <= 10^8 for i = 1 to n. The input forms a valid rooted tree structure.**
def func_8(node, parent):
    ii = -1
    for i in range(len(node[2])):
        if node[2][i] != parent:
            func_8(node[2][i], node)
        else:
            ii = i
        
    #State of the program after the  for loop has been executed: n is an integer such that 2 <= n <= 10^5, ai is an integer such that 0 <= ai <= 10^8 for i = 1 to n forming a valid rooted tree structure, ii is an integer value representing the last index where `node[2][i]` is equal to the parent.
    if (ii >= 0) :
        node[2].pop(ii)
    #State of the program after the if block has been executed: *n is an integer such that 2 <= n <= 10^5, ai is an integer such that 0 <= ai <= 10^8 for i = 1 to n forming a valid rooted tree structure, ii is an integer value representing the last index where `node[2][i]` is equal to the parent. If ii >= 0, all the conditions mentioned hold true.

#Function 9:
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5. ai is an integer such that 0 <= ai <= 10^8. xi and yi are integers such that 1 <= xi, yi <= n and xi != yi.
def func_9(node):
    if (node[1] >= 0) :
        return
        #The program does not perform any operations and returns nothing
    #State of the program after the if block has been executed: *n is an integer such that 2 <= n <= 10^5. ai is an integer such that 0 <= ai <= 10^8. xi and yi are integers such that 1 <= xi, yi <= n and xi != yi. node[1] is less than 0
    lcm = 1
    max = -1
    for child in node[2]:
        func_9(child)
        
        lcm = func_7(lcm, child[0])
        
    #State of the program after the  for loop has been executed: lcm is updated by calling func_7 with parameters lcm and the last child in node[2], max is -1
    for child in node[2]:
        t = child[1] / lcm * lcm
        
        if max < 0 or max > t:
            max = t
        
    #State of the program after the  for loop has been executed: `lcm` is updated by calling func_7 with parameters `lcm` and the last child in node[2], `max` is the maximum value of `t` calculated in each iteration of the loop, `child` is the last child in node[2], `t` is the result of dividing the second element of `child` by `lcm` and then multiplying by `lcm`.
    node[0] = lcm
    node[1] = max * len(node[2])


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
