
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_1():
    return int(input())
    #The program returns an integer value obtained from user input.

#Function 2:
#State of the program right berfore the function call: ** The input consists of three sequences: a list of n integers a_1, a_2, ..., a_n, a list of n integers b_1, b_2, ..., b_n, and a list of n integers c_1, c_2, ..., c_n. Each integer in the sequences is between 1 and 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_2():
    return input()
    #The program returns the input consisting of three sequences: a list of n integers a_1, a_2, ..., a_n, a list of n integers b_1, b_2, ..., b_n, and a list of n integers c_1, c_2, ..., c_n. Each integer in the sequences is between 1 and 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.

#Function 3:
#State of the program right berfore the function call: **
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers obtained from the input string after splitting it by spaces.

#Function 4:
#State of the program right berfore the function call: **
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object where each element is converted to a string after stripping and splitting the input string by spaces

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. n is a positive integer such that 3 ≤ n ≤ 100. For each test case, a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_5():
    return list(func_3())
    #The program returns a list of tuples generated by func_3() where each tuple contains three integers a_i, b_i, c_i satisfying the given conditions

#Function 6:
#State of the program right berfore the function call: **
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: ** The input consists of three sequences a, b, and c, each containing n integers. Each integer in a, b, and c is in the range from 1 to 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_7(item):
    return item[1]
    #The program returns the second integer in the sequence 'item'

#Function 8:
#State of the program right berfore the function call: **
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns list 'l' sorted in reverse order based on the custom key function getKey

#Function 9:
#State of the program right berfore the function call: **
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns where each element is 'num'

#Function 10:
#State of the program right berfore the function call: **
def func_10(x):
    return x and not x & x - 1
    #The program returns 0 if x is 0, otherwise it returns 1

#Function 11:
#State of the program right berfore the function call: **Precondition**: **n is a positive integer representing the number of elements in the sequences.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer 'n' after converting it to binary and removing the prefix '0b'

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers converted from each character in the string representation of 'n'.

#Function 13:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer representing the number of elements in the given sequences, such that 3 <= n <= 100.
- r is a list of lists where each list contains n integers, representing the sequences a_i, b_i, c_i, such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of calculating factorial(n) divided by the product of factorial(r) and factorial(max(n - r, 1))

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer value of x divided by y
    else :
        return x // y + 1
        #The program returns the result of dividing x by y and adding 1 to it.

#Function 15:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer (1 ≤ t ≤ 100), n is an integer such that 3 ≤ n ≤ 100.**

**a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res`, `x`, `y` are integers, `y` is 0
    return res
    #The program returns the integer value stored in 'res'

#Function 16:
#State of the program right berfore the function call: **Precondition**: **x and y are integers.**
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` contains the greatest common divisor of the initial values of `x` and `y`, `y` is 0
    return x
    #The program returns the greatest common divisor of the initial values of `x` and `y`, which is stored in variable `x`

#Function 17:
#State of the program right berfore the function call: **
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` can have any value except a value less than or equal to 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` can have any value except a value less than or equal to 1. `n` is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` can have any value except a value less than or equal to 1 and is greater than 3. Additionally, `n` is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: After the loop finishes executing, `n` remains a prime number greater than 25 and not divisible by 2 or 3. The value of `i` is such that `i * i` is greater than `n` which means the loop condition is false. In this case, the program does not return anything, indicating that `n` has passed the primality test.
    return True
    #The program returns True, indicating that 'n' has passed the primality test

#Function 18:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 ≤ t ≤ 100.
- n is an integer such that 3 ≤ n ≤ 100.
- a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: **
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `n` is an integer greater than or equal to 1, `a`, `b`, `c` are the final return values of `func_5()`, `ans` is a list of `n` elements where each element is either from `a`, `b`, or `c` based on the conditions specified in the loop. The function `func_20` is called with the final `ans` as arguments.

#Function 20:
#State of the program right berfore the function call: **Precondition**: The input consists of three sequences a, b, and c, where each sequence contains n integers. The integers in each sequence are distinct. The length of each sequence is between 3 and 100.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: Output State: `sep` is ' ', `file` contains all the elements in `args` separated by a space, `at_start` is False, `args` is an empty list, `x` is the last element in the list.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` contains all the elements in `args` separated by a space, `at_start` is False, `args` is an empty list, `x` is the last element in the list, the value of `kwargs.pop('end', '\n')` is written to the file, and if `flush` is True, then the program executes the statements inside the if block, otherwise no changes occur.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
