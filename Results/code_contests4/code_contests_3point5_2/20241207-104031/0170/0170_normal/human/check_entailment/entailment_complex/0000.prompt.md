
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_1():
    return int(input())
    #The program returns an integer value obtained from user input.
#Overall this is what the function does:The function `func_1` does not accept any parameters. It simply returns an integer value obtained from user input. The function lacks validation or error handling for non-integer inputs or any other edge cases that could arise during user input.

#Function 2:
#State of the program right berfore the function call: ** The input consists of three sequences: a list of n integers a_1, a_2, ..., a_n, a list of n integers b_1, b_2, ..., b_n, and a list of n integers c_1, c_2, ..., c_n. Each integer in the sequences is between 1 and 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_2():
    return input()
    #The program returns the input consisting of three sequences: a list of n integers a_1, a_2, ..., a_n, a list of n integers b_1, b_2, ..., b_n, and a list of n integers c_1, c_2, ..., c_n. Each integer in the sequences is between 1 and 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
#Overall this is what the function does:The function func_2 does not accept any parameters and directly returns the input consisting of three sequences: a list of n integers a_1, a_2, ..., a_n, a list of n integers b_1, b_2, ..., b_n, and a list of n integers c_1, c_2, ..., c_n. Each integer in the sequences is between 1 and 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.

#Function 3:
#State of the program right berfore the function call: **
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers obtained from the input string after splitting it by spaces.
#Overall this is what the function does:The function `func_3` reads input from the user, splits the input string by spaces, converts each split element to an integer, and returns a map object containing these integers. However, the code does not handle any potential errors that may occur during input reading or conversion.

#Function 4:
#State of the program right berfore the function call: **
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object where each element is converted to a string after stripping and splitting the input string by spaces
#Overall this is what the function does:The function func_4 does not accept any parameters. It reads an input string, strips leading and trailing whitespaces, splits the string by spaces, converts each element to a string, and returns a map object containing these string elements. However, the function does not handle any potential errors that might occur during the input processing.

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. n is a positive integer such that 3 ≤ n ≤ 100. For each test case, a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_5():
    return list(func_3())
    #The program returns a list of tuples generated by func_3() where each tuple contains three integers a_i, b_i, c_i satisfying the given conditions
#Overall this is what the function does:The function generates a list of tuples, each tuple containing three integers a_i, b_i, c_i that satisfy specific conditions. The function does not accept any parameters explicitly, and it calls another function func_3 to generate these tuples. The generated list is then returned. However, the annotations mention parameters t and n, which are not utilized within the function, so their significance is unclear. Additionally, the specific conditions mentioned in the annotations regarding the range and inequality of a_i, b_i, c_i are not explicitly enforced within this function.

#Function 6:
#State of the program right berfore the function call: **
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit, stack size, and creates a new thread that executes the `main` function. It does not accept any parameters and does not explicitly return any value. The purpose of the function is to initiate a new thread to run a separate block of code concurrently without taking any input or providing any output.

#Function 7:
#State of the program right berfore the function call: ** The input consists of three sequences a, b, and c, each containing n integers. Each integer in a, b, and c is in the range from 1 to 100. The length of the sequences is at least 3 and at most 100. For each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_7(item):
    return item[1]
    #The program returns the second integer in the sequence 'item'
#Overall this is what the function does:The function func_7 accepts a parameter 'item', which is a sequence containing three sequences: a, b, and c, each containing n integers. It returns the second integer in the sequence 'item'. The code does exactly what the annotations describe, returning the second integer in the sequence 'item'.

#Function 8:
#State of the program right berfore the function call: **
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns list 'l' sorted in reverse order based on the custom key function getKey
#Overall this is what the function does:The function `func_8` accepts a list `l` and sorts it in reverse order based on a custom key function `getKey`. The function does not provide the implementation of the `getKey` function, so the sorting behavior is reliant on this external function. It is assumed that `getKey` is defined elsewhere in the codebase.

#Function 9:
#State of the program right berfore the function call: **
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns where each element is 'num'
#Overall this is what the function does:The function func_9 accepts three parameters: n, m, and num, and returns a 2D list with 'n' rows and 'm' columns where each element is 'num'. The function creates the 2D list by using list comprehensions to generate 'n' rows, each containing 'm' elements with the value 'num'.

#Function 10:
#State of the program right berfore the function call: **
def func_10(x):
    return x and not x & x - 1
    #The program returns 0 if x is 0, otherwise it returns 1
#Overall this is what the function does:The function func_10 accepts a parameter x and returns 0 if x is 0. Otherwise, it returns 1.

#Function 11:
#State of the program right berfore the function call: **Precondition**: **n is a positive integer representing the number of elements in the sequences.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer 'n' after converting it to binary and removing the prefix '0b'
#Overall this is what the function does:The function `func_11` accepts a positive integer `n`, representing the number of elements in the sequences. It then converts `n` to its binary representation and removes the prefix '0b' before returning the binary string.

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers converted from each character in the string representation of 'n'.
#Overall this is what the function does:The function accepts an integer parameter `n` and returns a list of integers where each integer is extracted from the characters of the string representation of `n`.

#Function 13:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer representing the number of elements in the given sequences, such that 3 <= n <= 100.
- r is a list of lists where each list contains n integers, representing the sequences a_i, b_i, c_i, such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of calculating factorial(n) divided by the product of factorial(r) and factorial(max(n - r, 1))
#Overall this is what the function does:The function func_13 accepts an integer n and a list of lists r. It calculates the factorial of n and divides it by the product of the factorials of the elements in r and the factorial of max(n - r, 1). It then returns the result of this division. However, the code has a missing implementation for the factorial function, so the actual functionality is incomplete until the factorial function is defined.

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer value of x divided by y
    else :
        return x // y + 1
        #The program returns the result of dividing x by y and adding 1 to it.
#Overall this is what the function does:The function `func_14` accepts two parameters `x` and `y`, where `x` and `y` are integers satisfying 1 <= x <= 100 and 3 <= y <= 100. The function performs integer division of x by y and returns the quotient. If x is not perfectly divisible by y, it returns the integer division result incremented by 1.

#Function 15:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer (1 ≤ t ≤ 100), n is an integer such that 3 ≤ n ≤ 100.**

**a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res`, `x`, `y` are integers, `y` is 0
    return res
    #The program returns the integer value stored in 'res'
#Overall this is what the function does:The function `func_15` accepts three parameters `x`, `y`, and `p`. It performs a series of operations on `x` and `y` based on their values and returns the calculated result stored in 'res'. The function modifies `x` by taking the modulus of `x` with respect to `p`, then enters a loop where it updates `res`, `x`, and `y` iteratively. Inside the loop, if a condition is met, `res` is updated accordingly. Once the loop is completed, the function returns the final value stored in 'res'. The function does not handle any edge cases or missing logic mentioned in the annotations, so it solely computes the result based on the provided parameters.

#Function 16:
#State of the program right berfore the function call: **Precondition**: **x and y are integers.**
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` contains the greatest common divisor of the initial values of `x` and `y`, `y` is 0
    return x
    #The program returns the greatest common divisor of the initial values of `x` and `y`, which is stored in variable `x`
#Overall this is what the function does:The function func_16 accepts two integer parameters x and y, calculates their greatest common divisor using the Euclidean algorithm, and stores the result in the variable x. If y is 0, the function returns x as the greatest common divisor.

#Function 17:
#State of the program right berfore the function call: **
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` can have any value except a value less than or equal to 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` can have any value except a value less than or equal to 1. `n` is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` can have any value except a value less than or equal to 1 and is greater than 3. Additionally, `n` is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: After the loop finishes executing, `n` remains a prime number greater than 25 and not divisible by 2 or 3. The value of `i` is such that `i * i` is greater than `n` which means the loop condition is false. In this case, the program does not return anything, indicating that `n` has passed the primality test.
    return True
    #The program returns True, indicating that 'n' has passed the primality test
#Overall this is what the function does:The function func_17 accepts an integer parameter n and performs a primality test on n. Based on different conditions, it returns False if n is less than or equal to 1, True if n is less than or equal to 3, and False if n is divisible by 2 or 3. It then conducts a more detailed primality check using a loop to determine if n is a prime number greater than 25 and not divisible by 2 or 3. If n passes this test, the function returns True to indicate that n is a prime number.

#Function 18:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 ≤ t ≤ 100.
- n is an integer such that 3 ≤ n ≤ 100.
- a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_18` sets the standard input to read from a file named 'input.txt' and the standard output to write to a file named 'output.txt'. It does not accept any parameters and does not have a return value. The function aims to redirect the input and output streams to files for a specific purpose, potentially related to I/O operations in the program.

#Function 19:
#State of the program right berfore the function call: **
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `n` is an integer greater than or equal to 1, `a`, `b`, `c` are the final return values of `func_5()`, `ans` is a list of `n` elements where each element is either from `a`, `b`, or `c` based on the conditions specified in the loop. The function `func_20` is called with the final `ans` as arguments.
#Overall this is what the function does:The function `func_19` does not accept any parameters and iterates over a loop. Within the loop, it initializes values for `n`, `a`, `b`, and `c` by calling different functions. It then creates a list `ans` of size `n` where each element is assigned based on certain conditions. After the loop, it calls `func_20` with the final `ans` list as arguments. The function always returns the number 19.

#Function 20:
#State of the program right berfore the function call: **Precondition**: The input consists of three sequences a, b, and c, where each sequence contains n integers. The integers in each sequence are distinct. The length of each sequence is between 3 and 100.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: Output State: `sep` is ' ', `file` contains all the elements in `args` separated by a space, `at_start` is False, `args` is an empty list, `x` is the last element in the list.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` contains all the elements in `args` separated by a space, `at_start` is False, `args` is an empty list, `x` is the last element in the list, the value of `kwargs.pop('end', '\n')` is written to the file, and if `flush` is True, then the program executes the statements inside the if block, otherwise no changes occur.
#Overall this is what the function does:The function func_20 does not accept any parameters. It operates on three sequences a, b, and c, each containing n distinct integers. The length of each sequence is between 3 and 100. The function prints the elements in the sequences to a stream, separated by spaces, and ends with a newline character. If the 'flush' keyword argument is set to True, it flushes the stream. The function does not return any value.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.