
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Consider a permutation p of length n, we build a graph of size n using it as follows: 

  * For every 1 ≤ i ≤ n, find the largest j such that 1 ≤ j < i and p_j > p_i, and add an undirected edge between node i and node j 
  * For every 1 ≤ i ≤ n, find the smallest j such that i < j ≤ n and p_j > p_i, and add an undirected edge between node i and node j 



In cases where no such j exists, we make no edges. Also, note that we make edges between the corresponding indices, not the values at those indices.

For clarity, consider as an example n = 4, and p = [3,1,4,2]; here, the edges of the graph are (1,3),(2,1),(2,3),(4,3).

A permutation p is cyclic if the graph built using p has at least one simple cycle. 

Given n, find the number of cyclic permutations of length n. Since the number may be very large, output it modulo 10^9+7.

Please refer to the Notes section for the formal definition of a simple cycle

Input

The first and only line contains a single integer n (3 ≤ n ≤ 10^6).

Output

Output a single integer 0 ≤ x < 10^9+7, the number of cyclic permutations of length n modulo 10^9+7.

Examples

Input


4


Output


16

Input


583291


Output


135712853

Note

There are 16 cyclic permutations for n = 4. [4,2,1,3] is one such permutation, having a cycle of length four: 4 → 3 → 2 → 1 → 4.

Nodes v_1, v_2, …, v_k form a simple cycle if the following conditions hold: 

  * k ≥ 3. 
  * v_i ≠ v_j for any pair of indices i and j. (1 ≤ i < j ≤ k) 
  * v_i and v_{i+1} share an edge for all i (1 ≤ i < k), and v_1 and v_k share an edge. 
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer such that 3 <= n <= 10^6.**
def func_1():
    return int(input())
    #The program returns an integer value entered by the user through input(). The integer value 'n' is such that 3 <= n <= 10^6.

#Function 2:
#State of the program right berfore the function call: n is an integer such that 3 <= n <= 10^6.**
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained by splitting the input string

#Function 3:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.**
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list containing all characters of the input string 's' except for the last character. The integer 'n' is such that 3 ≤ n ≤ 10^6.

#Function 4:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.**
def func_4():
    return map(int, input().split())
    #The program returns a map object containing integers after splitting the input

#Function 5:
#State of the program right berfore the function call: n is an integer such that 3 <= n <= 10^6.**
def func_5():
    s = input()
    return s.split(' ')
    #The program returns a list of substrings obtained by splitting the string 's' at each occurrence of a space character

#Function 6:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.**
def func_6(n):
    if (n == 1) :
        return [1]
        #The program returns a list containing the integer 1
    #State of the program after the if block has been executed: *n is an integer such that 3 ≤ n ≤ 10^6. n is not equal to 1
    ans = []
    i = 2
    cap = sqrt(n)
    while i <= cap:
        if n % i == 0:
            ans.append(i)
            n = n // i
            cap = sqrt(n)
        else:
            i += 1
        
    #State of the program after the loop has been executed: `n` is 1, `i` is greater than `cap`, `cap` is the square root of 1, `ans` contains the prime factors of the initial value of `n`
    if (n > 1) :
        ans.append(n)
    #State of the program after the if block has been executed: *`n` is 1, `i` is greater than `cap`, `cap` is the square root of 1, `ans` contains the prime factors of the initial value of `n`. If `n` is greater than 1, `ans` has `n` appended to it.
    return ans
    #The program returns the list 'ans' containing the prime factors of the initial value of 'n'. If 'n' is greater than 1, 'n' is appended to the list 'ans'.

#Function 7:
#State of the program right berfore the function call: n is an integer such that 3 <= n <= 10^6.**
def func_7(n, k):
    if (n == 1 or n == k) :
        return 1
        #The program returns 1
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 10^6. n is not equal to 1 or k
    if (k > n) :
        return 0
        #The program returns 0
    else :
        a = math.factorial(n)
        b = math.factorial(k)
        c = math.factorial(n - k)
        div = a // (b * c)
        return div
        #The program returns the result of the floor division of the factorial of 'n' by the product of 'b' and the factorial of 'n-k'


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
