
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A maze is composed of a grid of H \times W squares - H vertical, W horizontal.

The square at the i-th row from the top and the j-th column from the left - (i,j) - is a wall if S_{ij} is `#` and a road if S_{ij} is `.`.

There is a magician in (C_h,C_w). He can do the following two kinds of moves:

* Move A: Walk to a road square that is vertically or horizontally adjacent to the square he is currently in.
* Move B: Use magic to warp himself to a road square in the 5\times 5 area centered at the square he is currently in.



In either case, he cannot go out of the maze.

At least how many times does he need to use the magic to reach (D_h, D_w)?

Constraints

* 1 \leq H,W \leq 10^3
* 1 \leq C_h,D_h \leq H
* 1 \leq C_w,D_w \leq W
* S_{ij} is `#` or `.`.
* S_{C_h C_w} and S_{D_h D_w} are `.`.
* (C_h,C_w) \neq (D_h,D_w)

Input

Input is given from Standard Input in the following format:


H W
C_h C_w
D_h D_w
S_{11}\ldots S_{1W}
\vdots
S_{H1}\ldots S_{HW}


Output

Print the minimum number of times the magician needs to use the magic. If he cannot reach (D_h,D_w), print `-1` instead.

Examples

Input

4 4
1 1
4 4
..#.
..#.
.#..
.#..


Output

1


Input

4 4
1 4
4 1
.##.


.##.


Output

-1


Input

4 4
2 2
3 3
....
....
....
....


Output

0


Input

4 5
1 2
2 5
.###
.
..##
..##


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: **
def func():
    input = lambda : sys.stdin.readline().rstrip()
    sys.setrecursionlimit(max(1000, 10 ** 9))
    write = lambda x: sys.stdout.write(x + '\n')
    h, w = map(int, input().split())
    ch, cw = map(int, input().split())
    dh, dw = map(int, input().split())
    ch -= 1
    cw -= 1
    dh -= 1
    dw -= 1
    rows, cols = h, w
    OK = '.'
    NG = '#'
    ns = defaultdict(set)
    ss = [None] * rows
    for i in range(rows):
        s = input()
        
        ss[i] = s
        
    #State of the program after the  for loop has been executed: `h` is assigned an integer value obtained from input split by space, `w` is assigned an integer value obtained from input split by space, `dh` is an integer determined by input - 1, `dw` is an integer determined by input - 1, `ch` is decremented by 1, `cw` is decremented by 1, `rows` is assigned the value of `h`, `cols` is assigned the value of `w`, `OK` is assigned the string '.', `NG` is assigned the string '#', `ns` is initialized as a defaultdict containing sets, `ss` is a list of size `rows` filled with the input values
    n = rows * cols
    start = ch * w + cw
    goal = dh * w + dw
    seen = [None] * n
    seen[start] = 0
    q = [(0, start)]
    dx = []
    dy = []
    vvs = []
    for i in range(-2, 3):
        for j in range(-2, 3):
            if not i == j == 0:
                dx.append(i)
                dy.append(j)
                if abs(i) + abs(j) > 1:
                    vvs.append(1)
                else:
                    vvs.append(0)
        
    #State of the program after the  for loop has been executed: After the loop finishes executing, `j` will be in the range of -2 to 2, `dy` will contain values ranging from -2 to 4, `vvs` will have elements based on the condition in the loop with additional values of 1 if abs(i) + abs(j) > 1, `dx` will contain the value of 4 repeatedly. All other variables will retain their previous values.
    while q:
        pnum, pu = hpp(q)
        
        ux, uy = divmod(pu, w)
        
        if pu == goal:
            break
        
        for xx, yy, vv in zip(dx, dy, vvs):
            x, y = ux + xx, uy + yy
            u = x * w + y
            num = pnum + vv
            if x < 0 or y < 0 or x >= h or y >= w or ss[x][y] == '#':
                continue
            if seen[u] is None or seen[u] > num:
                seen[u] = num
                hp(q, (num, u))
        
    #State of the program after the loop has been executed: After the loop finishes executing, `seen` will contain the minimum `num` value for each `u`, `x` and `y` will be updated based on the values of `ux`, `xx`, `uy`, and `yy`, `u` will be calculated as `x * w + y`, and the conditions for updating `seen[u]` will be based on the values of `num` and `seen[u]`. The loop control variable `q` will be False, as the loop terminates when `pu` is equal to `goal`.
    val = seen[goal]
    if (val is None) :
        print(-1)
    else :
        print(val)
    #State of the program after the if-else block has been executed: *After the loop finishes executing, `seen` will contain the minimum `num` value for each `u`, `x` and `y` will be updated based on the values of `ux`, `xx`, `uy`, and `yy`, `u` will be calculated as `x * w + y`, and the conditions for updating `seen[u]` will be based on the values of `num` and `seen[u]`. The loop control variable `q` will be False, as the loop terminates when `pu` is equal to `goal`. `val` is assigned the value of `seen[goal]`. If `val` is None, nothing changes in the program state, the loop finishes executing with no modifications to any variables. Otherwise, the value stored in `val` is printed and all other variables retain their calculated values after the loop execution.
#Overall this is what the function does:The function reads input values for a grid, starting and goal positions, then performs a search algorithm to find the shortest path between the start and goal positions in the grid. It prints the minimum number of steps required to reach the goal position from the start position. If the goal position is unreachable, it prints -1. The function does not accept any parameters and does not return any specific output.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
