# Your task:
Problem description: This problem differs from the previous one only in the absence of the constraint on the equal length of all numbers a_1, a_2, ..., a_n.

A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don't know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem.

Let's denote a function that alternates digits of two numbers f(a_1 a_2 ... a_{p - 1} a_p, b_1 b_2 ... b_{q - 1} b_q), where a_1 ... a_p and b_1 ... b_q are digits of two integers written in the decimal notation without leading zeros.

In other words, the function f(x, y) alternately shuffles the digits of the numbers x and y by writing them from the lowest digits to the older ones, starting with the number y. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out.

Formally,

if p ≥ q then f(a_1 ... a_p, b_1 ... b_q) = a_1 a_2 ... a_{p - q + 1} b_1 a_{p - q + 2} b_2 ... a_{p - 1} b_{q - 1} a_p b_q; 
if p < q then f(a_1 ... a_p, b_1 ... b_q) = b_1 b_2 ... b_{q - p} a_1 b_{q - p + 1} a_2 ... a_{p - 1} b_{q - 1} a_p b_q. 

Mishanya gives you an array consisting of n integers a_i, your task is to help students to calculate ∑_{i = 1}^{n}∑_{j = 1}^{n} f(a_i, a_j) modulo 998 244 353.

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of elements in the array. The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the elements of the array.

Output

Print the answer modulo 998 244 353.

Examples

Input

3
12 3 45

Output

12330

Input

2
123 456

Output

1115598

Functions with output description for each function:
Function number 1:
Code:
```
def func_1():
    mod = 998244353
    n = int(input())
    l1 = list(input().split())
    arr = [0] * 10
    for item in l1:
        arr[len(item) - 1] += 1
    ans = 0
    for item in l1:
        for i in range(1, 11):
            if arr[i - 1] == 0:
                continue
            x = len(item)
            res = 0
            if x <= i:
                for j in range(x - 1, -1, -1):
                    res = (res + int(item[j]) * pow(10, (x - j - 1) * 2, mod)) % mod
                    res = (res + int(item[j]) * pow(10, (x - j) * 2 - 1, mod)) % mod
                ans = ans + arr[i - 1] * res
            else:
                x -= 1
                i -= 1
                j = 0
                while x > i:
                    res = (res + 2 * int(item[j]) * pow(10, x - i + 2 * (i + 1) - 1, mod)) % mod
                    x -= 1
                    j += 1
                i += 1
                x = len(item)
                for j in range(i - 1, -1, -1):
                    res = (res + int(item[j + (x - i)]) * pow(10, (i - j - 1) * 2, mod)) % mod
                    res = (res + int(item[j + (x - i)]) * pow(10, (i - j) * 2 - 1, mod)) % mod
                ans = ans + arr[i - 1] * res
    print(ans)
```

Output description for function 1: The function `func_1` reads an input integer `n`, followed by a list of strings `l1`. It then calculates a result `ans` based on specific conditions involving the elements of `l1` and their lengths. The function prints the final calculated `ans` value. The function does not accept any parameters and does not return any value.

Function number 2:
Code:
```
def power(x, y, p):
    res = 1
    x = x % p
    while y > 0:
        if y & 1 == 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
```

Output description for function 2: The function power accepts three integer parameters: x, y, and p. It calculates x raised to the power of y modulo p and returns the result. The function correctly updates the variables x, y, and res within the loop. However, the function is missing a check for the case when y is not greater than 0, which might lead to unexpected behavior if y is negative or 0. Additionally, the annotations suggest that the value of x after the loop will be the final result, but in reality, the final result is the value of res, which is always 1.

Function number 3:
Code:
```
def count_next_smaller_elements(xs):
    ys = sorted(((x, i) for (i, x) in enumerate(xs)))
    zs = [0] * len(ys)
    for i in range(1, len(ys)):
        zs[ys[i][1]] = zs[ys[i - 1][1]]
        if ys[i][0] != ys[i - 1][0]:
            zs[ys[i][1]] += 1
    ts = [0] * (zs[ys[-1][1]] + 1)
    us = [0] * len(xs)
    for i in range(len(xs) - 1, -1, -1):
        x = zs[i] + 1
        while True:
            us[i] += ts[x - 1]
            x -= x & -x
            if x <= 0:
                break
            x = zs[i] + 1
        while True:
            x += x & -x
            if x > len(ts):
                break
            ts[x - 1] += 1
    return us
```

Output description for function 3: The function `count_next_smaller_elements` takes a list of n integers `xs` where 1 ≤ n ≤ 100,000 and 1 ≤ xs[i] ≤ 10^9 for 1 ≤ i ≤ n. It then processes the list to calculate and update a new list of integers `us` based on certain conditions within the loops. Finally, the function returns the updated list `us`. The functionality does not explain the purpose behind the calculations or the expected behavior of the updated list `us`, leaving room for further analysis or clarification.

Function number 4:
Code:
```
def func_2(zero=0):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            i += 1
    except:
        pass
    if s and s[-1] >= b'0'[0]:
        A.append(sign * numb)
    return A
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
class ostream:

    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
if __name__ == '__main__':
    func_1()
```

Output description for function 4: The function func_2 accepts a positive integer zero and reads a sequence of bytes from standard input. It then processes the bytes to extract integers based on certain conditions, storing them in a list A. For each integer found, it calculates sign * numb and adds it to the list. If the input is not valid, an empty list is returned. The code may not handle cases where the input sequence ends abruptly or contains unexpected characters, potentially leading to incorrect results.

I will now assess the correctness of the provided code based on the problem description and the output hints:

1. **Function 1 (`func_1`):**
   - The function reads an integer `n` and a list of strings `l1`.
   - It calculates a result `ans` based on specific conditions involving the elements of `l1` and their lengths.
   - The function prints the final calculated `ans` value.
   - The code seems to follow the problem description by iterating over the list of integers and performing the alternating digit shuffling operation as described.
   - The output hints are aligned with the code functionality, detailing the calculations and the modulo operation used.

Correctness: **True**

2. **Function 2 (`power`):**
   - The function calculates x raised to the power of y modulo p.
   - It correctly updates x, y, and res within the loop.
   - There is a missing check for the case when y is not greater than 0, which might lead to unexpected behavior if y is negative or 0.
   - Additionally, the final result is the value of res, not x as suggested in the annotations.

Correctness: **False**

3. **Function 3 (`count_next_smaller_elements`):**
   - The function processes a list of integers to calculate and update a new list based on certain conditions within the loops.
   - The purpose behind the calculations and the expected behavior of the updated list `us` are not explicitly explained in the output hints.
   - Without a clear understanding of the requirements and expected outcomes, it is challenging to determine if the function follows the problem description correctly.

Correctness: **False**

4. **Function 4 (`func_2`):**
   - The function reads a sequence of bytes from standard input and processes them to extract integers.
   - It stores the extracted integers in a list A and performs the necessary calculations.
   - The code may not handle cases where the input sequence ends abruptly or contains unexpected characters, potentially leading to incorrect results.
   - The function might not handle all edge cases effectively due to the complex implementation.

Correctness: **False**