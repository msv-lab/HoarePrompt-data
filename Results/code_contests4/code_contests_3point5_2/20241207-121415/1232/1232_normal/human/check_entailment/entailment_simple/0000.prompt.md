
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are playing another computer game, and now you have to slay n monsters. These monsters are standing in a circle, numbered clockwise from 1 to n. Initially, the i-th monster has a_i health.

You may shoot the monsters to kill them. Each shot requires exactly one bullet and decreases the health of the targeted monster by 1 (deals 1 damage to it). Furthermore, when the health of some monster i becomes 0 or less than 0, it dies and explodes, dealing b_i damage to the next monster (monster i + 1, if i < n, or monster 1, if i = n). If the next monster is already dead, then nothing happens. If the explosion kills the next monster, it explodes too, damaging the monster after it and possibly triggering another explosion, and so on.

You have to calculate the minimum number of bullets you have to fire to kill all n monsters in the circle.

Input

The first line contains one integer T (1 ≤ T ≤ 150000) — the number of test cases.

Then the test cases follow, each test case begins with a line containing one integer n (2 ≤ n ≤ 300000) — the number of monsters. Then n lines follow, each containing two integers a_i and b_i (1 ≤ a_i, b_i ≤ 10^{12}) — the parameters of the i-th monster in the circle.

It is guaranteed that the total number of monsters in all test cases does not exceed 300000.

Output

For each test case, print one integer — the minimum number of bullets you have to fire to kill all of the monsters.

Example

Input


1
3
7 15
2 14
5 3


Output


6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: **
def func():
    stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    stdout = BytesIO()
    res = []
    inp = stdin.readlines()
    T = int(inp[0])
    _i = 1
    for t in range(T):
        N = int(inp[_i])
        
        _i += 1
        
        monsters = []
        
        mnShots = 0
        
        start = maxint
        
        for n in range(N):
            cur = map(int, inp[_i].split())
            _i += 1
            monsters.append(cur)
            if n > 0:
                dam = max(0, cur[0] - monsters[n - 1][1])
                mnShots += dam
                start = min(start, cur[0] - dam)
        
        dam = max(0, monsters[0][0] - monsters[-1][1])
        
        mnShots += dam
        
        start = min(start, monsters[0][0] - dam)
        
        res.append(mnShots + start)
        
    #State of the program after the  for loop has been executed: After all iterations of the loop, `stdin` is a BytesIO object containing input from standard input, `stdout` is a new BytesIO object, `res` contains the results of `mnShots + start` for each iteration of the loop, `inp` contains all lines from the input, `T` is greater than 0, `_i` is equal to the total number of lines in `inp`, `N` is assigned the last integer value from the input, `monsters` contains all `cur` values appended in each iteration of the loop, `mnShots` is the sum of the maximum of 0 and the differences between the first elements of each `cur` and the second elements of the previous `cur` in `monsters`, `start` is updated as described above, `n` is equal to `N - 1`, `cur` contains the last set of integers mapped from the last input line, `dam` is calculated as the maximum of 0 and the difference between the first element of `cur` and the second element of the second-to-last element in `monsters`, and the final result of `mnShots + start` for each iteration is stored in `res`.
    os.write(1, '\n'.join(str(x) for x in res))

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
