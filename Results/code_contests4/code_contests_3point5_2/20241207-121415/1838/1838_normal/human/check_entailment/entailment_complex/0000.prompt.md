
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths a, b, and c. Now he needs to find out some possible integer length d of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to a, b, c, and d. Help Yura, find any possible length of the fourth side.

A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself.

Input

The first line contains a single integer t — the number of test cases (1 ≤ t ≤ 1000). The next t lines describe the test cases.

Each line contains three integers a, b, and c — the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).

Output

For each test case print a single integer d — the length of the fourth fence segment that is suitable for building the fence. If there are multiple answers, print any. We can show that an answer always exists.

Example

Input


2
1 2 3
12 34 56


Output


4
42

Note

We can build a quadrilateral with sides 1, 2, 3, 4.

We can build a quadrilateral with sides 12, 34, 56, 42.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    return int(input())
    #The program returns an integer that is taken as input from the user
#Overall this is what the function does:The function `func_1` prompts the user to input an integer and then returns that integer.

#Function 2:
#State of the program right berfore the function call: **
def func_2():
    return input()
    #The program returns the value entered by the user as input
#Overall this is what the function does:The function func_2 does not accept any parameters. It prompts the user to enter a value as input and then returns the value entered by the user.

#Function 3:
#State of the program right berfore the function call: **
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object created by applying the 'int' function to each element after splitting the input string by spaces
#Overall this is what the function does:The function `func_3` does not accept any parameters. It reads an input string, splits it by spaces, converts each element to an integer using the 'int' function, and returns a map object with the converted integers. The code does not handle any errors that may occur during the conversion or input reading process.

#Function 4:
#State of the program right berfore the function call: **
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that applies the str function to each element of the input after stripping and splitting it by spaces.
#Overall this is what the function does:The function `func_4` does not accept any parameters. It reads input from the user, strips leading and trailing whitespaces, splits the input by spaces, and returns a map object that applies the `str` function to each element of the input.

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(func_3())
    #The program returns a list generated by calling the function func_3()
#Overall this is what the function does:The function `func_5` does not accept any parameters. The program returns a list generated by calling the function `func_3()`. The functionality of the function `func_5` is accurately described by the annotations provided.

#Function 6:
#State of the program right berfore the function call: # Precondition

**a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.**
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit and stack size, then starts a new thread targeting the `main` function. This function does not accept any parameters and does not have a specific return value. The annotations specify that `a`, `b`, and `c` are integers between 1 and 10^9, but these variables are not utilized within the function.

#Function 7:
#State of the program right berfore the function call: **
def func_7(item):
    return item[1]
    #The program returns the element at index 1 of the variable 'item'.
#Overall this is what the function does:The function func_7 accepts a parameter item and returns the element at index 1 of the variable 'item'.

#Function 8:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c representing the lengths of three fence segments. 1 ≤ a, b, c ≤ 10^9.**
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in descending order based on the custom key function 'getKey'
#Overall this is what the function does:The function accepts a list 'l' containing three integers representing fence segment lengths. It sorts the list in descending order based on a custom key function 'getKey' and returns the sorted list. The function assumes that the input list 'l' will always contain three integers. If the input list contains more or fewer than three integers, the function may not behave as expected.

#Function 9:
#State of the program right berfore the function call: **
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2-dimensional list with 'n' rows and 'm' columns, where each element in the list is 'num'.
#Overall this is what the function does:The function `func_9` accepts three integers `n`, `m`, and `num`, and returns a 2-dimensional list with `n` rows and `m` columns, where each element in the list is `num`.

#Function 10:
#State of the program right berfore the function call: **
def func_10(x):
    return x and not x & x - 1
    #The program returns True if x is a power of 2 (e.g., 1, 2, 4, 8, etc.), otherwise it returns False.
#Overall this is what the function does:The function func_10 accepts a parameter x and returns True if x is a power of 2; otherwise, it returns False. Specifically, it checks if x is a power of 2 by performing a bitwise operation.

#Function 11:
#State of the program right berfore the function call: **
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer 'n' without the '0b' prefix
#Overall this is what the function does:The function func_11 accepts an integer parameter n and returns the binary representation of the integer n without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers converted from each character in the string representation of variable 'n'.
#Overall this is what the function does:The function accepts an integer `n` and converts the string representation of `n` into a list of integers, returning the list of integers. Each character in the string representation of `n` is converted to an integer.

#Function 13:
#State of the program right berfore the function call: The input values a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.**
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combination formula C(n, r) where n is the value of 'a', r is the value of 'b', and the function factorial calculates the factorial of a number.
#Overall this is what the function does:The function func_13 accepts two integer parameters, n and r. It calculates the combination formula C(n, r) where n is the value of 'a' and r is the value of 'b' using the factorial function. The input values a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.

#Function 14:
#State of the program right berfore the function call: **
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the result of integer division of x by y, where x is divisible by y
    else :
        return x // y + 1
        #The program returns the result of integer division of x by y plus 1
#Overall this is what the function does:The function `func_14` accepts two integer parameters `x` and `y`. If `x` is divisible by `y`, it returns the result of the integer division of `x` by `y`. If `x` is not divisible by `y`, it returns the result of the integer division of `x` by `y` plus 1.

#Function 15:
#State of the program right berfore the function call: x, y, and p are integers such that 1 ≤ x, y, p ≤ 10^9.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x`, `y`, `p` are integers such that 1 ≤ x, y, p ≤ 10^9; `res` is updated based on the calculations in the loop. The loop will terminate when `y` becomes 0.
    return res
    #The program returns the final value of 'res' after the loop terminates.
#Overall this is what the function does:The function `func_15` accepts three parameters `x`, `y`, and `p`, which are integers such that 1 ≤ x, y, p ≤ 10^9. It calculates the result `res` based on the conditions inside the loop and returns this final value after the loop terminates. The loop processes bitwise operations on `y` and updates `res`, `x`, and `y` accordingly until `y` becomes 0. The function operates within the constraints specified for the parameters x, y, and p.

#Function 16:
#State of the program right berfore the function call: **
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` and `y` have been swapped, and `y` has been updated to the remainder of the previous `x` divided by the previous `y`, `y` will eventually become 0 to end the loop
    return x
    #The program returns the final value of variable 'x' after swapping 'x' and 'y' multiple times until 'y' becomes 0, where 'y' is updated to the remainder of the previous 'x' divided by the previous 'y'
#Overall this is what the function does:The function `func_16` accepts two integer parameters `x` and `y`. It continuously swaps the values of `x` and `y` until `y` becomes 0. During each swap, `y` is updated to the remainder of the previous value of `x` divided by the previous value of `y`. The final value of `x` after these swaps is returned as the output. The functionality does not handle cases where `y` is initially 0, which could lead to a potential division by zero error.

#Function 17:
#State of the program right berfore the function call: The input values for a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.**
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9. n is larger than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9. n is larger than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9. n is larger than 1 and n is larger than 3. n is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: If n is not divisible by any number i or i + 2 where i is a multiple of 6 starting from 5, then the program returns True. Otherwise, it returns False.
    return True
    #The program returns True if n is not divisible by any number i or i + 2 where i is a multiple of 6 starting from 5, otherwise it returns False
#Overall this is what the function does:The function `func_17` accepts an integer parameter `n` and returns True or False based on whether `n` is divisible by any number i or i + 2 where i is a multiple of 6 starting from 5. If `n` is less than or equal to 1, the function returns False. If `n` is less than or equal to 3, the function returns True. If `n` is divisible by 2 or 3, the function returns False. If none of these conditions are met and `n` is not divisible by any number i or i + 2 where i is a multiple of 6 starting from 5, the function returns True.

#Function 18:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c where 1 ≤ a, b, c ≤ 10^9.**
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_18` sets up the standard input and output to read from 'input.txt' and write to 'output.txt'. It is supposed to accept three parameters a, b, and c, where 1 ≤ a, b, c ≤ 10^9. However, the function does not explicitly return any value, and its actual functionality beyond the file redirection setup is not specified. It lacks clarity on what it should do with the input parameters.

#Function 19:
#State of the program right berfore the function call: a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_19():
    for _ in range(func_1()):
        a, b, c = func_3()
        
        func_20(c + 1)
        
    #State of the program after the  for loop has been executed: a, b, and c are assigned the return values of func_3() after all iterations of the loop have finished
#Overall this is what the function does:The function `func_19` iterates over a range of values returned by `func_1`, assigns the return values of `func_3` to variables a, b, and c, and calls `func_20` with the value of c increased by 1. The function does not calculate the sum of the squares of three integers a, b, and c as stated in the annotations.

#Function 20:
#State of the program right berfore the function call: **
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is False, `args` is not empty, all elements in `args` have been written to the `file` object.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is False, `args` is not empty, all elements in `args` have been written to the `file` object, kwargs does not contain the key 'flush', and the internal buffer of the `file` object has been flushed if 'flush' key is present in kwargs.
#Overall this is what the function does:The function `func_20` does not accept any parameters and writes the elements in `args` to an output stream. It separates elements by the value of `sep` or space if not provided. It writes a newline character by default at the end. If 'flush' key is present in the keyword arguments, it flushes the internal buffer of the output stream.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.