
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret!

A password is an array a of n positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index i such that 1 ≤ i < n and a_{i} ≠ a_{i+1}, delete both a_i and a_{i+1} from the array and put a_{i}+a_{i+1} in their place. 

For example, for array [7, 4, 3, 7] you can choose i = 2 and the array will become [7, 4+3, 7] = [7, 7, 7]. Note that in this array you can't apply this operation anymore.

Notice that one operation will decrease the size of the password by 1. What is the shortest possible length of the password after some number (possibly 0) of operations?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the password.

The second line of each test case contains n integers a_{1},a_{2},...,a_{n} (1 ≤ a_{i} ≤ 10^9) — the initial contents of your password.

The sum of n over all test cases will not exceed 2 ⋅ 10^5.

Output

For each password, print one integer: the shortest possible length of the password after some number of operations.

Example

Input


2
4
2 1 3 1
2
420 420


Output


1
2

Note

In the first test case, you can do the following to achieve a length of 1:

Pick i=2 to get [2, 4, 1]

Pick i=1 to get [6, 1]

Pick i=1 to get [7]

In the second test case, you can't perform any operations because there is no valid i that satisfies the requirements mentioned above.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    fact = [1]
    for i in range(1, 100005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` is a list containing the factorials modulo mod from 1 to 100004, `i` is 100005
    ifact = [0] * 100005
    ifact[100004] = pow(fact[100004], mod - 2, mod)
    for i in range(100004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` is a list containing the factorials modulo mod from 1 to 100004, `i` is 0, `ifact` is a list of 100005 elements all updated based on the formula mentioned above
    return fact, ifact
    #The program returns the list `fact` containing factorials modulo `mod` from 1 to 100004 and the list `ifact` containing 100005 elements updated based on the formula mentioned above
#Overall this is what the function does:The function `func_1` calculates and returns two lists: `fact` containing factorials modulo `mod` from 1 to 100004, and `ifact` containing 100005 elements updated based on a specific formula. The function correctly computes the factorials and their modulo values as described in the annotations.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, and p is a list of n positive integers representing the initial contents of the password.**
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of raising n to the power of p-2 modulo p
#Overall this is what the function does:The function accepts two parameters `n` and `p`, where `n` is a positive integer representing the length of the password, and `p` is a list of `n` positive integers representing the initial contents of the password. The function then calculates and returns the result of raising `n` to the power of `p-2` modulo `p`.

#Function 3:
#State of the program right berfore the function call: **
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of 't', which cannot be determined with the provided initial state
#Overall this is what the function does:The function `func_3` accepts four parameters: `n`, `r`, `fact`, and `ifact`. It calculates the value of 't' based on the provided formulas involving the elements of `fact`, `ifact`, and `mod`. The specific value of 't' returned by the function cannot be determined with the given initial state.

#Function 4:
#State of the program right berfore the function call: **
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns a map object containing integers converted from the input read from the standard input
#Overall this is what the function does:The function `func_4` reads input from the standard input, converts the input into integers using the `map` function, and returns a map object containing these integers. The code does what the annotations describe, converting input to integers and returning a map object.

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers after mapping the input values from standard input and splitting them
#Overall this is what the function does:The function `func_5` reads input from the standard input, maps the input values to integers, splits them, and returns a list of integers.

#Function 6:
#State of the program right berfore the function call: t is a positive integer. For each test case, n is a positive integer such that 1 ≤ n ≤ 2 ⋅ 10^5. Each a_i is a positive integer such that 1 ≤ a_{i} ≤ 10^9.**
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a string obtained by stripping the input read from sys.stdin
#Overall this is what the function does:The function `func_6` does not accept any parameters. It reads input from the standard input (stdin) and returns a string obtained by stripping the input read from sys.stdin. The input consists of a positive integer `t`, followed by `t` test cases. Each test case includes a positive integer `n` followed by `n` positive integers `a_i`. The function processes the input and returns a string obtained by stripping the input read from sys.stdin.

#Function 7:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer representing the number of test cases. n is a positive integer representing the length of the password. a is a list of n positive integers representing the initial contents of the password. Each element in a is a positive integer less than or equal to 10^9.**
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x and y are updated accordingly, the loop will terminate when y becomes 0
    return x
    #The program returns the final value of x after the loop terminates when y becomes 0
#Overall this is what the function does:The function func_7 accepts two parameters, x and y. It then performs the Euclidean algorithm to find the greatest common divisor of x and y. The function returns the final value of x after the loop terminates when y becomes 0. If x and y are initially 0, the function will return 0. If y is 0 initially, the function will return the absolute value of x.

#Function 8:
#State of the program right berfore the function call: x is a list of positive integers with length n, and y is a positive integer representing the number of test cases.**
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the result of multiplying the list of positive integers x by the positive integer y and then dividing the result by the value returned by the function func_7(x, y)
#Overall this is what the function does:The function `func_8` accepts two parameters: `x`, a list of positive integers with length n, and `y`, a positive integer representing the number of test cases. It then calculates the result by multiplying the list of positive integers `x` by the positive integer `y` and dividing the outcome by the value returned by the function `func_7(x, y)`. The function performs this computation and returns the final result. However, there is a potential edge case if `func_7(x, y)` returns 0, resulting in a division by zero error. This case is not handled in the current implementation.

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the length of the password and the array a contains n positive integers.**
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns one of the following based on the value of n: n if n%4 is 0, 1 if n%4 is 1, n+1 if n%4 is 2, and 0 if n%4 is 3
#Overall this is what the function does:The function `func_9` accepts a positive integer `n` representing the length of the password and an array `a` containing `n` positive integers. It returns `n` if `n % 4` is 0, 1 if `n % 4` is 1, `n + 1` if `n % 4` is 2, and 0 if `n % 4` is 3. The function directly returns one of these values based on the result of the modulo operation.

#Function 10:
#State of the program right berfore the function call: **
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            res %= MOD
            b -= 1
        else:
            a = a * a
            a %= MOD
            b >>= 1
        
    #State of the program after the loop has been executed: `res` is an integer, `b` is 0. If `b` was initially non-zero, `res` is the result of `a` raised to the power of the initial `b` value modulo `MOD`. If `b` was initially 0, `res` remains 1.
    res %= MOD
    return res
    #The program returns the updated value of 'res' based on the conditions mentioned in the code snippet
#Overall this is what the function does:The function `func_10` accepts two parameters, `a` and `b`, which are both integers. It calculates the result of `a` raised to the power of `b` modulo `MOD` using a bitwise operation loop. The function returns the final result stored in the variable `res`. If `b` is 0 initially, the function returns 1.

#Function 11:
#State of the program right berfore the function call: **
def func_11(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns the value of 'ans' calculated based on the formula (-1 + sqrt(1 + 8 * P)) // 2, where the value of 'P' is unknown
#Overall this is what the function does:The function accepts a parameter P, calculates the value of 'ans' based on the formula (-1 + sqrt(1 + 8 * P)) // 2, and returns the result. It is important to note that the code snippet is missing the import statement for the sqrt function, which could lead to a NameError. Additionally, there could be a potential division by zero error if the denominator becomes zero during the calculation of 'ans'.

#Function 12:
#State of the program right berfore the function call: **
def func_12():
    T = int(func_6())
    while T:
        n = int(func_6())
        
        Arr = func_5()
        
        p = Arr[0]
        
        flag = 0
        
        for i in Arr[1:]:
            if i != p:
                flag = 1
                break
        
        if flag == 1:
            print(1)
        else:
            print(n)
        
        T -= 1
        
    #State of the program after the loop has been executed: `T` is 0, `n`, `Arr`, `p`, `i`, `flag` are integers resulting from `func_6()` and `func_5()`. The loop has finished executing, and all elements in `Arr` are the same, resulting in `flag` being 0. The loop printed the value of `n` after each iteration.
#Overall this is what the function does:The function `func_12()` does not accept any parameters and iterates a loop `T` number of times. It retrieves an integer `n`, an array `Arr`, and the first element `p` from functions `func_6()` and `func_5()` respectively. It then checks if all elements in `Arr` are the same, setting `flag` accordingly. If `flag` is 1, it prints 1; otherwise, it prints the value of `n`. After each iteration, the loop decrements `T`. The function does not have explicit return values and prints specific outputs based on the conditions met during each iteration of the loop.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.