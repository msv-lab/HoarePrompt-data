
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

Input

The first line of the input contains two integers n and m (1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5)), the number of vertices and the number of edges of weight 1 in the graph. 

The i-th of the next m lines contains two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i), the endpoints of the i-th edge of weight 1.

It is guaranteed that no edge appears twice in the input.

Output

Output a single integer, the weight of the minimum spanning tree of the graph.

Examples

Input


6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6


Output


2


Input


3 0


Output


0

Note

The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.

<image>

In the second sample, all edges have weight 0 so any spanning tree has total weight 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n and m are integers such that 1 <= n <= 10^5, 0 <= m <= min((n(n-1))/(2),10^5).**
def func_1():
    n, m = func_4()
    p = list(range(n))
    r = func_7(int, n)
    sg = func_7(set, n)
    for _ in range(m):
        x, y = func_5(-1)
        
        sg[x].add(y)
        
        sg[y].add(x)
        
    #State of the program after the  for loop has been executed: `n` and `m` are integers such that 1 <= n <= 10^5, 0 <= m <= min((n(n-1))/(2),10^5; `p` is a list containing elements from 0 to n-1, `sg` is the value returned by calling the function `func_7` with arguments `set` and `n. The loop will execute `m` times, and after all iterations, `sg` will contain the updated sets after adding corresponding `y` values to `x` sets and vice versa from the function `func_5(-1)`
    v = min(range(n), key=lambda i: len(sg[i]))
    for i in range(n):
        if i not in sg[v]:
            union(i, v)
        else:
            for j in range(n):
                if j not in sg[i]:
                    union(i, j)
        
    #State of the program after the  for loop has been executed: After all iterations of the loop have finished, `n`, `m`, `p`, `sg`, and `v` have been updated based on the conditions within the loop. If `i` is not in the set at index `v` in `sg`, then all variables remain the same except the set at index `v` in `sg` is updated by adding the set at index `i` to it. If `i` is in the set at index `v` in `sg`, then all elements in `sg[i]` are unioned with `i`.
    roots = set()
    for i in range(n):
        roots.add(find(i))
        
    #State of the program after the  for loop has been executed: `roots` contains the result of `find(i)` for each `i` in the range of `n`, where `n` is a non-negative integer
    print(len(roots) - 1)

#Function 2:
#State of the program right berfore the function call: 
def find(v):
    vc = v
    while v != p[v]:
        v = p[v]
        
    #State of the program after the loop has been executed: `vc` is assigned the value of `v`, `v` is equal to `p[v]` after all iterations of the loop have executed
    while vc != v:
        p[vc], vc = v, p[vc]
        
    #State of the program after the loop has been executed: `vc` is equal to `p[p[v]]`, `v` remains unchanged
    return v
    #The program returns the value of variable 'v' without any changes

#Function 3:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.**
def union(u, v):
    u, v = find(u), find(v)
    if (u == v) :
        return
        #The program returns the value of u or v, which are equal
    #State of the program after the if block has been executed: *n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i. The values of u and v are not equal.
    if (r[u] < r[v]) :
        u, v = v, u
    #State of the program after the if block has been executed: *n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i. The values of u and v are not equal. If r[u] < r[v], then u holds the initial value of v and v holds the initial value of u.
    p[u] = v
    if (r[u] == r[v]) :
        r[u] += 1
    #State of the program after the if block has been executed: *p[u] is assigned the value of v, r[u] and r[v] are equal. After the execution, p[u] will be equal to v and r[u] will be incremented by 1 if r[u] is equal to r[v].

#Function 4:
#State of the program right berfore the function call: **
def func_2(x):
    return pow(x, MOD - 2, MOD)
    #The program returns the result of calculating x raised to the power of MOD - 2, modulo MOD

#Function 5:
#State of the program right berfore the function call: x and y are integers such that 1 ≤ x ≤ 10^5, 0 ≤ y ≤ min((x(x-1))/(2),10^5).**
def func_3(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` and `y` are updated integers satisfying the given conditions where `y` is 0, indicating the loop has finished executing.
    return x
    #The program returns the updated integer value of 'x' after the loop has finished executing. The value of 'y' is 0, indicating the loop has finished.

#Function 6:
#State of the program right berfore the function call: n and m are non-negative integers such that 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5).**
def func_4():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained by mapping the input values

#Function 7:
#State of the program right berfore the function call: **
def func_5(o):
    return list(map(lambda x: int(x) + o, input().split()))
    #The program returns a list of integers obtained by adding 0 to each element of the input list after converting them to integers

#Function 8:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5).**
def func_6(n, m):
    return [func_4() for _ in range(n)]
    #The program returns a list of length n, where each element is the result of the function func_4() called in a loop n times

#Function 9:
#State of the program right berfore the function call: **
def func_7(f):
    return [func_7(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list of values obtained by calling 'func_7' with arguments from 'dim' list after the first element for a number of times specified by the first element of 'dim'. If 'dim' is empty, then the program returns the result of calling 'f'.

#Function 10:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i.**
def func_8(start, step, count):
    return range(start, start + step * count, step)
    #The program returns a range starting from 'start' with a step size of 'step' and 'count' number of elements

#Function 11:
#State of the program right berfore the function call: l is a list of tuples where each tuple contains two integers representing the endpoints of an edge in the graph. start and end are integers representing the start and end vertices of the graph.**
def func_9(l, start, end):
    return range(start, len(l) + end)
    #The program returns a range starting from the 'start' vertex to the end of the list 'l' plus the 'end' vertex.

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the graph.**
def func_10(n):
    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """
    return 2 ** (n - 1).bit_length()
    #The program returns the position of the highest set bit in the binary representation of 2 raised to the power of (n - 1)

#Function 13:
#State of the program right berfore the function call: **
def func_11(x, r):
    """ = ceil(x / r) """
    return (x + r - 1) // r
    #The program returns the value of `(x + r - 1) // r` where `x` and `r` are known variables.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
