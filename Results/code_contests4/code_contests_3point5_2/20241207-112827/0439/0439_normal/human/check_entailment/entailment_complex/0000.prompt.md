
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: A monopole magnet is a magnet that only has one pole, either north or south. They don't actually exist since real magnets have two poles, but this is a programming contest problem, so we don't care.

There is an n× m grid. Initially, you may place some north magnets and some south magnets into the cells. You are allowed to place as many magnets as you like, even multiple in the same cell.

An operation is performed as follows. Choose a north magnet and a south magnet to activate. If they are in the same row or the same column and they occupy different cells, then the north magnet moves one unit closer to the south magnet. Otherwise, if they occupy the same cell or do not share a row or column, then nothing changes. Note that the south magnets are immovable.

Each cell of the grid is colored black or white. Let's consider ways to place magnets in the cells so that the following conditions are met.

  1. There is at least one south magnet in every row and every column. 
  2. If a cell is colored black, then it is possible for a north magnet to occupy this cell after some sequence of operations from the initial placement. 
  3. If a cell is colored white, then it is impossible for a north magnet to occupy this cell after some sequence of operations from the initial placement. 



Determine if it is possible to place magnets such that these conditions are met. If it is possible, find the minimum number of north magnets required (there are no requirements on the number of south magnets).

Input

The first line contains two integers n and m (1≤ n,m≤ 1000) — the number of rows and the number of columns, respectively.

The next n lines describe the coloring. The i-th of these lines contains a string of length m, where the j-th character denotes the color of the cell in row i and column j. The characters "#" and "." represent black and white, respectively. It is guaranteed, that the string will not contain any other characters.

Output

Output a single integer, the minimum possible number of north magnets required.

If there is no placement of magnets that satisfies all conditions, print a single integer -1.

Examples

Input


3 3
.#.
###
##.


Output


1


Input


4 2
##
.#
.#
##


Output


-1


Input


4 5
....#
####.
.###.
.#...


Output


2


Input


2 1
.
#


Output


-1


Input


3 5
.....
.....
.....


Output


0

Note

In the first test, here is an example placement of magnets:

<image>

In the second test, we can show that no required placement of magnets exists. Here are three example placements that fail to meet the requirements. The first example violates rule 3 since we can move the north magnet down onto a white square. The second example violates rule 2 since we cannot move the north magnet to the bottom-left black square by any sequence of operations. The third example violates rule 1 since there is no south magnet in the first column.

<image>

In the third test, here is an example placement of magnets. We can show that there is no required placement of magnets with fewer north magnets.

<image>

In the fourth test, we can show that no required placement of magnets exists. Here are two example placements that fail to meet the requirements. The first example violates rule 1 since there is no south magnet in the first row. The second example violates rules 1 and 3 since there is no south magnet in the second row and we can move the north magnet up one unit onto a white square.

<image>

In the fifth test, we can put the south magnet in each cell and no north magnets. Because there are no black cells, it will be a correct placement.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: n and m are positive integers such that 1 <= n, m <= 1000. grid is a 2D list of characters representing the coloring of the grid with "#" for black cells and "." for white cells.**
def func_1(n, m, grid):
    components, visited = 0, [([False] * m) for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if not visited[i][j] and grid[i][j] == '#':
                components += dfs(i, j)
        
    #State of the program after the  for loop has been executed: `n` is greater than 0, `i` is `n-1`, `components` is updated by the sum of values returned by `dfs` function for all valid (i, j) pairs where `not visited[i][j]` and `grid[i][j]` == '#'
    return components
    #The program returns the sum of values obtained by the `dfs` function for all valid (i, j) pairs where `not visited[i][j]` and `grid[i][j]` == '#'
#Overall this is what the function does:The function `func_1` accepts three parameters: `n`, `m`, and `grid`. `n` and `m` are positive integers representing the dimensions of the grid, while `grid` is a 2D list of characters with "#" for black cells and "." for white cells. The function iterates through the grid, incrementing a count based on the result of the `dfs` function for valid black cell pairs. Finally, it returns the total count of these components. However, the code does not include the implementation of the `dfs` function, and its behavior is not defined in the provided context.

#Function 2:
#State of the program right berfore the function call: **
def get_adj(i, j):
    adj = [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]
    res = []
    for (ai, aj) in adj:
        if 0 <= ai < n and 0 <= aj < m and grid[ai][aj] == '#':
            res.append((ai, aj))
        
    #State of the program after the  for loop has been executed: `adj` is a list of tuples containing all valid tuples where 0 <= ai < n and 0 <= aj < m, and grid[ai][aj] == '#', `res` contains all tuples that satisfy these conditions.
    return res
    #The program returns all tuples in the list 'res' that satisfy the conditions where 0 <= ai < n, 0 <= aj < m, and grid[ai][aj] == '#'
#Overall this is what the function does:The function `get_adj` accepts two integer parameters `i` and `j`. It generates a list `adj` containing tuples representing adjacent positions, then filters those tuples based on certain conditions involving the dimensions `n` and `m` and the content of the `grid`. The function finally returns a list `res` containing the tuples that meet the specified conditions.

#Function 3:
#State of the program right berfore the function call: n and m are positive integers such that 1 <= n, m <= 1000. The input grid is a valid grid of size n x m consisting of characters "#" and "." only.**
def dfs(i, j):
    component, stack = 1, [(i, j)]
    while stack:
        si, sj = stack[-1]
        
        if visited[si][sj]:
            stack.pop()
            continue
        else:
            visited[si][sj] = True
            component = 1
            for ai, aj in get_adj(si, sj):
                if not visited[ai][aj]:
                    stack.append((ai, aj))
        
    #State of the program after the loop has been executed: All elements in the grid have been visited, `visited` matrix is updated accordingly, `component` is 1, and `stack` is empty. `si` and `sj` are updated to the coordinates of the last element in the stack before it was emptied.
    return component
    #The program returns the value of the variable `component`, which is currently set to 1
#Overall this is what the function does:The function `dfs` accepts two positive integer parameters `i` and `j`, representing cell coordinates in a grid. It initializes a variable `component` to 1 and a stack with the initial cell coordinates. It then iteratively visits cells in the grid using a depth-first search (DFS) approach until all cells have been visited. The function updates a `visited` matrix, and upon completion, it returns the value of the variable `component`, which is always 1 in the current implementation. However, the current implementation of the DFS algorithm does not properly update the `component` variable during traversal, potentially leading to incorrect results.

#Function 4:
#State of the program right berfore the function call: 
def func_2():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    if (grid == [('.' * m) for _ in range(n)]) :
        func_3(0)
        return
        #The program does not affect any variables and returns nothing
    #State of the program after the if block has been executed: *`n` and `m` are input integers, `grid` is a list of `n` input strings. The `grid` is not equal to ['.' * m for _ in range(n)]
    for row in grid:
        start, stop = row.find('#'), row.rfind('#')
        
        if start == -1 or '.' in row[start:stop + 1]:
            func_3(-1)
            return
        
    #State of the program after the  for loop has been executed: n is an input integer, m is an input integer, grid is a list of n input strings where grid is not equal to ['.' * m for _ in range(n)]. If there is at least one row where start == -1 or '.' is found in the substring of row from start to stop (inclusive), then the program calls func_3(-1) and returns. Otherwise, the loop executes for all rows in the grid without returning any specific value.
    grit = transpose(grid)
    for row in grit:
        start, stop = row.find('#'), row.rfind('#')
        
        if start == -1 or '.' in row[start:stop + 1]:
            func_3(-1)
            return
        
    #State of the program after the  for loop has been executed: After the loop finishes executing, `n` and `m` are integers, `grid` is a list of `n` strings, `grid` is not equal to `['.' * m for _ in range(n)]`, `func_3(-1)` is called if conditions are met, `grit` is the transpose of `grid` which is not empty, `start` and `stop` are assigned the index of the first and last occurrence of '#' in the string `row`, `start` is not -1, and there are no '.' between indexes `start` and `stop` in the string `row`. The loop will continue until all rows in `grit` meet the specified conditions, and `start` and `stop` are updated based on the indexes of the first and last occurrence of '#' in the string `row`.
    func_3(func_1(n, m, grid))
#Overall this is what the function does:The function `func_2` reads input integers `n` and `m`, constructs a grid of strings based on the input, and performs checks on the grid rows. If any row contains invalid characters or missing '#' symbols, it calls `func_3(-1)`. The function then transposes the grid and repeats the row checks. Finally, it calls `func_3(func_1(n, m, grid))` with the result of conditions being met for the initial state. The functionality may vary based on the actual behavior of `func_1`, `func_3`, and the correctness of the grid checks, which are not explicitly described in the annotations.

#Function 5:
#State of the program right berfore the function call: **Precondition**: **n and m are positive integers such that 1 ≤ n, m ≤ 1000. The input grid contains only "#" and "." characters.**
def func_3():
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n`, `m` are positive integers such that 1 ≤ n, m ≤ 1000, `at_start` is False. For the loop to execute, `args` is a list with at least one element, and all elements of `args` have been written to the file.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n`, `m` are positive integers such that 1 ≤ n, m ≤ 1000, `at_start` is False, a new line character is written to the file, and the keyword argument 'flush' is popped from kwargs.
#Overall this is what the function does:The function `func_3` does not accept any parameters. It iterates over the elements in `args`, writing each element to a file with the specified separator. It then writes a newline character to the file and flushes the file if the 'flush' keyword argument is set to True. The function does not return any value.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.