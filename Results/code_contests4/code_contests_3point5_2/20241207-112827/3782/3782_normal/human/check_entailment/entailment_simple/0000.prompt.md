
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: For a finite set of integers X, let f(X)=\max X - \min X.

Given are N integers A_1,...,A_N.

We will choose K of them and let S be the set of the integers chosen. If we distinguish elements with different indices even when their values are the same, there are {}_N C_K ways to make this choice. Find the sum of f(S) over all those ways.

Since the answer can be enormous, print it \bmod (10^9+7).

Constraints

* 1 \leq N \leq 10^5
* 1 \leq K \leq N
* |A_i| \leq 10^9

Input

Input is given from Standard Input in the following format:


N K
A_1 ... A_N


Output

Print the answer \bmod (10^9+7).

Examples

Input

4 2
1 1 3 4


Output

11


Input

6 3
10 10 10 -10 -10 -10


Output

360


Input

3 1
1 1 1


Output

0


Input

10 6
1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0


Output

999998537
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1(a, b):
    c = a + b
    if (c >= mod) :
        c -= mod
    #State of the program after the if block has been executed: *`c` is the sum of `a + b`. If `c` is greater than or equal to `mod`, the program retains the initial values of `a` and `b`, and `c` remains the sum of `a + b`.
    return c
    #The program returns the sum of 'a' and 'b', which is stored in 'c'. If 'c' is greater than or equal to 'mod', the initial values of 'a' and 'b' are retained.

#Function 2:
#State of the program right berfore the function call: **
def func_2(a, b):
    return (a - b) % mod
    #The program returns the result of subtracting 'b' from 'a', then taking the modulus 'mod' of the result

#Function 3:
#State of the program right berfore the function call: **
def func_3(a, b):
    return a * b % mod
    #The program returns the result of multiplying variable 'a' by variable 'b' and then taking the modulus of the result by variable 'mod'.

#Function 4:
#State of the program right berfore the function call: **
def func_4(a, b):
    if (b == 0) :
        return 1
        #The program returns the integer 1
    #State of the program after the if block has been executed: *All variables in the precondition remain unchanged. `b` is not equal to 0
    if (b % 2 == 1) :
        return func_3(a, func_4(a, b - 1))
        #The program returns the result of calling function `func_3` with arguments `a` and the result of calling function `func_4` with arguments `a` and `b-1`
    else :
        temp = func_4(a, b / 2)
        return temp * temp
        #The program returns the result of squaring the value of `temp` which is the result of `func_4(a, b / 2)

#Function 5:
#State of the program right berfore the function call: N and K are positive integers such that 1 <= K <= N. A_i are integers where 1 <= i <= N and |A_i| <= 10^9.**
def func_5(a):
    return func_4(a, mod - 2)
    #The program returns the result of func_4(a, mod - 2)

#Function 6:
#State of the program right berfore the function call: N and K are positive integers such that 1 <= K <= N. A_i are integers with absolute values less than or equal to 10^9.**
def func_6(n, k, fac):
    if (k > n) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *N and K are positive integers such that 1 <= K <= N. A_i are integers with absolute values less than or equal to 10^9. K is less than or equal to n
    return func_3(fac[n], func_5(func_3(fac[n - k], fac[k])))
    #The program returns the result of func_3(fac[n]) where n is a positive integer and the result of func_5(func_3(fac[n - k], fac[k])) where k is a positive integer less than or equal to n

#Function 7:
#State of the program right berfore the function call: N and K are positive integers such that 1 <= K <= N. A_i are integers such that |A_i| <= 10^9.**
def func_7():
    n, k = [int(x) for x in raw_input().split()]
    a = [int(x) for x in raw_input().split()]
    fac = [0] * (n + 5)
    fac[0] = 1
    for i in range(1, n + 5):
        fac[i] = func_3(fac[i - 1], i)
        
    #State of the program after the  for loop has been executed: `n` and `k` are positive integers satisfying 1 <= k <= n, list `a` is created from the input values, `fac[0]` is 1, `fac[i]` contains the result of `func_3` for each index `i` in the range 1 to n+4
    a.sort()
    ans = 0
    for i in range(n - 1):
        diff = func_2(a[i + 1], a[i])
        
        ways = func_6(n, k, fac)
        
        ways = func_2(ways, func_6(i + 1, k, fac))
        
        ways = func_2(ways, func_6(n - i - 1, k, fac))
        
        ans = func_1(ans, func_3(diff, ways))
        
    #State of the program after the  for loop has been executed: `n` is greater than or equal to 2, `k` is a positive integer satisfying 1 <= k <= n, `a` is sorted, `fac[0]` is 1, `fac[i]` contains the result of `func_3` for each index `i` in the range 1 to n+4, `ans` is updated by calling `func_1` with parameters `ans` and the result of `func_3(diff, ways)`, where `diff` is the result of `func_2(a[i], a[i - 1]) for the last iteration, and `ways` is updated by calling `func_2(ways, func_6(n - i - 1, k, fac)) for the last iteration
    print(ans)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
