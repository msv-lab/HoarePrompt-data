
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: This problem differs from the previous one only in the absence of the constraint on the equal length of all numbers a_1, a_2, ..., a_n.

A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don't know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem.

Let's denote a function that alternates digits of two numbers f(a_1 a_2 ... a_{p - 1} a_p, b_1 b_2 ... b_{q - 1} b_q), where a_1 ... a_p and b_1 ... b_q are digits of two integers written in the decimal notation without leading zeros.

In other words, the function f(x, y) alternately shuffles the digits of the numbers x and y by writing them from the lowest digits to the older ones, starting with the number y. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below.

For example: $$$f(1111, 2222) = 12121212 f(7777, 888) = 7787878 f(33, 44444) = 4443434 f(555, 6) = 5556 f(111, 2222) = 2121212$$$

Formally,

  * if p ≥ q then f(a_1 ... a_p, b_1 ... b_q) = a_1 a_2 ... a_{p - q + 1} b_1 a_{p - q + 2} b_2 ... a_{p - 1} b_{q - 1} a_p b_q; 
  * if p < q then f(a_1 ... a_p, b_1 ... b_q) = b_1 b_2 ... b_{q - p} a_1 b_{q - p + 1} a_2 ... a_{p - 1} b_{q - 1} a_p b_q. 



Mishanya gives you an array consisting of n integers a_i, your task is to help students to calculate ∑_{i = 1}^{n}∑_{j = 1}^{n} f(a_i, a_j) modulo 998 244 353.

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of elements in the array. The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the elements of the array.

Output

Print the answer modulo 998 244 353.

Examples

Input


3
12 3 45


Output


12330

Input


2
123 456


Output


1115598
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    mod = 998244353
    n = int(input())
    l1 = list(input().split())
    arr = [0] * 10
    for item in l1:
        arr[len(item) - 1] += 1
        
    #State of the program after the  for loop has been executed: `mod` is 998244353, `n` is an input integer, `l1` is a list of elements, `arr` is a list with 10 elements where each element represents the count of elements in `l1` with a specific length
    ans = 0
    for item in l1:
        for i in range(1, 11):
            if arr[i - 1] == 0:
                continue
            x = len(item)
            res = 0
            if x <= i:
                for j in range(x - 1, -1, -1):
                    res = (res + int(item[j]) * pow(10, (x - j - 1) * 2, mod)) % mod
                    res = (res + int(item[j]) * pow(10, (x - j) * 2 - 1, mod)) % mod
                ans = ans + arr[i - 1] * res
            else:
                x -= 1
                i -= 1
                j = 0
                while x > i:
                    res = (res + 2 * int(item[j]) * pow(10, x - i + 2 * (i + 1) - 1,
                        mod)) % mod
                    x -= 1
                    j += 1
                i += 1
                x = len(item)
                for j in range(i - 1, -1, -1):
                    res = (res + int(item[j + (x - i)]) * pow(10, (i - j - 1) * 2, mod)
                        ) % mod
                    res = (res + int(item[j + (x - i)]) * pow(10, (i - j) * 2 - 1, mod)
                        ) % mod
                ans = ans + arr[i - 1] * res
        
    #State of the program after the  for loop has been executed: `mod` is 998244353, `n` is an input integer, `l1` is a list of elements with at least 1 element, `arr` is a list with 10 elements, `ans` is the final calculated value after all iterations of the loop, `item` is the last element in `l1`, `i` is 10, `x` is the length of the last element in `l1`, `res` contains the final computed value after all iterations of the loop, `j` is either -1 or -10 based on the condition
    print(ans)
#Overall this is what the function does:The function `func_1` initializes variables and performs calculations based on the input provided by the user. It calculates a final value `ans` by iterating over elements in the input list `l1`. The function does not accept any parameters and does not return any output.

#Function 2:
#State of the program right berfore the function call: **n is a positive integer. The elements in the array a_i are positive integers less than or equal to 10^9.
def power(x, y, p):
    res = 1
    x = x % p
    while y > 0:
        if y & 1 == 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res`, `x`, and `p` are integers. The final value of `res` is calculated based on the conditions inside the loop. `y` is 0 after the loop finishes executing.
    return res
    #The program returns the final value of integer 'res' after the loop execution. The integer 'y' is 0 after the loop finishes executing.
#Overall this is what the function does:The function power accepts three parameters x, y, and p. It performs a loop operation where it calculates the value of res based on the conditions inside the loop. The final result of res is returned after the loop finishes executing, and the integer y is guaranteed to be 0 at the end of the function execution.

#Function 3:
#State of the program right berfore the function call: **
def count_next_smaller_elements(xs):
    ys = sorted((x, i) for i, x in enumerate(xs))
    zs = [0] * len(ys)
    for i in range(1, len(ys)):
        zs[ys[i][1]] = zs[ys[i - 1][1]]
        
        if ys[i][0] != ys[i - 1][0]:
            zs[ys[i][1]] += 1
        
    #State of the program after the  for loop has been executed: `ys` is a sorted list of tuples where each tuple contains an element from `xs` and its index with at least 2 elements, `zs` is a list of zeros with the same length as `ys` with at least 2 zeros where the value at index `ys[i][1]` is updated to match the value at index `ys[i - 1][1]` for all `i` in the range from 1 to len(ys). If the element at index `i` in `ys` is not equal to the element at index `i - 1`, the value at index `ys[i][1]` in `zs` is incremented by 1 for all `i` in the range from 1 to len(ys).
    ts = [0] * (zs[ys[-1][1]] + 1)
    us = [0] * len(xs)
    for i in range(len(xs) - 1, -1, -1):
        x = zs[i] + 1
        
        while True:
            us[i] += ts[x - 1]
            x -= x & -x
            if x <= 0:
                break
            x = zs[i] + 1
        
        while True:
            x += x & -x
            if x > len(ts):
                break
            ts[x - 1] += 1
        
    #State of the program after the  for loop has been executed: `ys` is a sorted list of tuples where each tuple contains an element from `xs` and its index, `zs` has been updated with the new values at each index, `ts` has been updated based on the conditions inside the loop, `us` has been updated such that each element has been incremented by the cumulative sum of `ts[x - 1]` for all iterations of the loop, the loop has finished executing
    return us
    #The program returns the list `us` where each element has been incremented by the cumulative sum of `ts[x - 1]` for all iterations of the loop
#Overall this is what the function does:The function `count_next_smaller_elements` takes a list `xs` as a parameter. It sorts the elements of `xs` along with their indices and then performs calculations to modify elements in a new list `us`. Each element in `us` is incremented by the cumulative sum of certain values calculated during the execution of the function. The function returns the modified list `us`.

#Function 4:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 100,000 and a_i is an integer such that 1 <= a_i <= 10^9 for 1 <= i <= n.**
def func_2(zero):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            
            i += 1
            
        #State of the program after the loop has been executed: `n` is an integer such that 1 <= n <= 100,000, `a_i` is an integer such that 1 <= a_i <= 10^9 for 1 <= i <= n, `conv` is assigned the function `ord` if Python version is 2, otherwise, it is assigned a lambda function, `A` contains the appended values of sign * numb based on the conditions met during each iteration of the loop, `numb` is the final value after all calculations, `sign` is the final value after all calculations, `i` is the index of the last character in string `s` after the loop finishes execution.
    except:
        pass
    #State of the program after the try-except block has been executed: `n` is an integer such that 1 <= n <= 100,000, `a_i` is an integer such that 1 <= a_i <= 10^9 for 1 <= i <= n, `conv` is assigned the function `ord` if Python version is 2, otherwise, it is assigned a lambda function, `A` contains the appended values of sign * numb based on the conditions met during each iteration of the loop, `numb` is the final value after all calculations, `sign` is the final value after all calculations, `i` is the index of the last character in string `s` after the loop finishes execution.
    if (s and s[-1] >= b'0'[0]) :
        A.append(sign * numb)
    #State of the program after the if block has been executed: *`n` is an integer such that 1 <= n <= 100,000, `a_i` is an integer such that 1 <= a_i <= 10^9 for 1 <= i <= n, `conv` is a function, `A` contains appended values based on conditions met during iterations, `numb` is the final value after calculations, `sign` is the final value after calculations, `i` is the index of the last character in string `s`. If `s` is not empty and the last character is greater than or equal to '0', then the program updates the variables `A`, `numb`, `sign`, and `i` based on certain conditions.
    return A
    #The program returns the list `A` containing appended values based on conditions met during iterations
#Overall this is what the function does:The function accepts an integer n and reads a string from stdin. It then iterates through the string, parsing integers based on specific conditions, and appends them to a list A. The function returns the list A containing the parsed integers. If the string s is not empty and the last character is a digit, it appends the last parsed integer to A. The function handles the conversion function based on the Python version.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.