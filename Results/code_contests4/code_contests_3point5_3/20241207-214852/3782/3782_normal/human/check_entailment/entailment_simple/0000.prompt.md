
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: For a finite set of integers X, let f(X)=\max X - \min X.

Given are N integers A_1,...,A_N.

We will choose K of them and let S be the set of the integers chosen. If we distinguish elements with different indices even when their values are the same, there are {}_N C_K ways to make this choice. Find the sum of f(S) over all those ways.

Since the answer can be enormous, print it \bmod (10^9+7).

Constraints

* 1 \leq N \leq 10^5
* 1 \leq K \leq N
* |A_i| \leq 10^9

Input

Input is given from Standard Input in the following format:


N K
A_1 ... A_N


Output

Print the answer \bmod (10^9+7).

Examples

Input

4 2
1 1 3 4


Output

11


Input

6 3
10 10 10 -10 -10 -10


Output

360


Input

3 1
1 1 1


Output

0


Input

10 6
1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0


Output

999998537
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1(a, b):
    c = a + b
    if (c >= mod) :
        c -= mod
    #State of the program after the if block has been executed: *`c` is a value greater than or equal to `mod`. When `c` is greater than or equal to `mod`, the program does not change the values of any variables.
    return c
    #The program returns the value of 'c', which is greater than or equal to 'mod'.

#Function 2:
#State of the program right berfore the function call: **
def func_2(a, b):
    return (a - b) % mod
    #The program returns the result of subtracting variable 'b' from variable 'a' and then taking the modulus 'mod' of the result

#Function 3:
#State of the program right berfore the function call: **
def func_3(a, b):
    return a * b % mod
    #The program returns the result of the product of 'a' and 'b' modulo 'mod'

#Function 4:
#State of the program right berfore the function call: **N and K are positive integers such that 1 <= K <= N. A_i are integers where 1 <= i <= N and |A_i| <= 10^9.
def func_4(a, b):
    if (b == 0) :
        return 1
        #The program returns 1
    #State of the program after the if block has been executed: *N and K are positive integers such that 1 <= K <= N. A_i are integers where 1 <= i <= N and |A_i| <= 10^9. b is not equal to 0
    if (b % 2 == 1) :
        return func_3(a, func_4(a, b - 1))
        #The program returns the result of calling function func_3 with parameters a and the result of calling function func_4 with parameters a and (b-1)
    else :
        temp = func_4(a, b / 2)
        return temp * temp
        #The program returns the result of calling `func_4(a, b / 2)` squared

#Function 5:
#State of the program right berfore the function call: N and K are positive integers such that 1 <= K <= N, and A_i are integers such that |A_i| <= 10^9.**
def func_5(a):
    return func_4(a, mod - 2)
    #The program returns the result of calling func_4(a, mod - 2)

#Function 6:
#State of the program right berfore the function call: **
def func_6(n, k, fac):
    if (k > n) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: `k`, `n` are integers. `k` is less than or equal to `n`
    return func_3(fac[n], func_5(func_3(fac[n - k], fac[k])))
    #The program returns the result of func_3(fac[n]) multiplied by the result of func_5(func_3(fac[n - k], fac[k]))

#Function 7:
#State of the program right berfore the function call: N and K are positive integers such that 1 <= K <= N. A_i are integers such that |A_i| <= 10^9.**
def func_7():
    n, k = [int(x) for x in raw_input().split()]
    a = [int(x) for x in raw_input().split()]
    fac = [0] * (n + 5)
    fac[0] = 1
    for i in range(1, n + 5):
        fac[i] = func_3(fac[i - 1], i)
        
    #State of the program after the  for loop has been executed: fac contains the result of applying func_3 iteratively on fac[0] to fac[n+4]
    a.sort()
    ans = 0
    for i in range(n - 1):
        diff = func_2(a[i + 1], a[i])
        
        ways = func_6(n, k, fac)
        
        ways = func_2(ways, func_6(i + 1, k, fac))
        
        ways = func_2(ways, func_6(n - i - 1, k, fac))
        
        ans = func_1(ans, func_3(diff, ways))
        
    #State of the program after the  for loop has been executed: `fac` contains the result of applying `func_3` iteratively on `fac[0]` to `fac[n+4]`, `a` is sorted, `ans` is the final result after applying `func_1` iteratively on the results of `func_3(diff, ways)` for all iterations of the loop, `i` is `n - 1`, `diff` is the result of `func_2(a[i + 1], a[i])` for the last iteration, `ways` is the final result after applying all `func_2` and `func_6` functions iteratively for all iterations of the loop
    print(ans)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
