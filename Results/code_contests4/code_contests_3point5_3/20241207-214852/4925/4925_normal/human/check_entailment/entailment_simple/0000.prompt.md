
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

Input

The first line of the input contains two integers n and m (1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5)), the number of vertices and the number of edges of weight 1 in the graph. 

The i-th of the next m lines contains two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i), the endpoints of the i-th edge of weight 1.

It is guaranteed that no edge appears twice in the input.

Output

Output a single integer, the weight of the minimum spanning tree of the graph.

Examples

Input


6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6


Output


2


Input


3 0


Output


0

Note

The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.

<image>

In the second sample, all edges have weight 0 so any spanning tree has total weight 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **Precondition**: 
- n and m are integers such that 1 <= n <= 10^5 and 0 <= m <= min((n(n-1))/(2),10^5).
- a_i and b_i are integers such that 1 <= a_i, b_i <= n and a_i ≠ b_i.
def func_1():
    n, m = func_4()
    p = list(range(n))
    r = func_7(int, n)
    sg = func_7(set, n)
    for _ in range(m):
        x, y = func_5(-1)
        
        sg[x].add(y)
        
        sg[y].add(x)
        
    #State of the program after the  for loop has been executed: `n` and `m` are integers, `p` is a list containing numbers from 0 to n-1, `sg` is a dictionary where each key is a number from 0 to n-1 and the corresponding value is a set containing numbers that have been added to `sg[key]` during the loop execution.
    v = min(range(n), key=lambda i: len(sg[i]))
    for i in range(n):
        if i not in sg[v]:
            union(i, v)
        else:
            for j in range(n):
                if j not in sg[i]:
                    union(i, j)
        
    #State of the program after the  for loop has been executed: All sets in `sg` are fully populated with elements from 0 to n-1. Each set contains all the numbers from 0 to n-1. The index `v` of the set in `sg` with the minimum length will be any index since all sets have the same length.
    roots = set()
    for i in range(n):
        roots.add(find(i))
        
    #State of the program after the  for loop has been executed: All sets in `sg` are fully populated with elements from 0 to n-1, index `v` of the set in `sg` with the minimum length can be any index, `roots` contains the result of `find(n-1)`
    print(len(roots) - 1)

#Function 2:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). Each pair of integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i) represents the endpoints of an edge of weight 1 in the graph.**
def find(v):
    vc = v
    while v != p[v]:
        v = p[v]
        
    #State of the program after the loop has been executed: `vc` is assigned the same value as `v`, `v` is equal to `p[v]`
    while vc != v:
        p[vc], vc = v, p[vc]
        
    #State of the program after the loop has been executed: vc` is equal to `v`, `v` is equal to `p[v]`, `p[vc]` is equal to `p[v]`
    return v
    #The program returns the value of variable `v`, which is equal to `p[v]` and `p[vc]` is equal to `p[v`]`.

#Function 3:
#State of the program right berfore the function call: **Precondition**: **n and m are integers such that 1 <= n <= 10^5 and 0 <= m <= min((n(n-1))/(2),10^5). The input edges are represented as pairs of integers where each integer is between 1 and n, inclusive, and the two integers are not equal to each other.**
def union(u, v):
    u, v = find(u), find(v)
    if (u == v) :
        return
        #The program returns the value of variable `u` which is equal to variable `v`
    #State of the program after the if block has been executed: *u and v are not equal
    if (r[u] < r[v]) :
        u, v = v, u
    #State of the program after the if block has been executed: *u and v are not equal. If r[u] < r[v], u and v have swapped values while r[u] and r[v] remain integers.
    p[u] = v
    if (r[u] == r[v]) :
        r[u] += 1
    #State of the program after the if block has been executed: *`u` and `v` are integers and `u` is not equal to `v`. If `r[u]` is equal to `r[v]`, then `u` and `v` have swapped values while `r[u]` and `r[v]` remain integers with `r[u]` being one more than `r[v]`. Additionally, `p[u]` is `v`.

#Function 4:
#State of the program right berfore the function call: x is an integer greater than or equal to 0.**
def func_2(x):
    return pow(x, MOD - 2, MOD)
    #The program returns the result of calculating x raised to the power of (MOD - 2) modulo MOD

#Function 5:
#State of the program right berfore the function call: x and y are non-negative integers such that 1 ≤ x ≤ 10^5, 0 ≤ y ≤ min((x(x-1))/(2),10^5).**
def func_3(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x and y are non-negative integers satisfying the given constraints, with x being the greatest common divisor of the initial values of x and y, and y being 0
    return x
    #The program returns the greatest common divisor of the initial values of x and y, which is x.

#Function 6:
#State of the program right berfore the function call: n and m are non-negative integers such that 1 <= n <= 10^5 and 0 <= m <= min((n(n-1))/(2),10^5).**
def func_4():
    return list(map(int, input().split()))
    #The program returns a list of integers by mapping the input values after splitting them.

#Function 7:
#State of the program right berfore the function call: **Precondition**: **n and m are non-negative integers such that 1 <= n <= 10^5 and 0 <= m <= min((n*(n-1))/2, 10^5). a_i and b_i are integers representing the endpoints of each edge with 1 <= a_i, b_i <= n and a_i != b_i.**
def func_5(o):
    return list(map(lambda x: int(x) + o, input().split()))
    #The program returns a list where each element is the integer value of the input split by spaces plus the value of variable 'o'

#Function 8:
#State of the program right berfore the function call: **Precondition**: **n and m are integers such that 1 <= n <= 10^5 and 0 <= m <= min((n(n-1))/(2),10^5).**
def func_6(n, m):
    return [func_4() for _ in range(n)]
    #The program returns a list of results from calling func_4() n times

#Function 9:
#State of the program right berfore the function call: **
def func_7(f):
    return [func_7(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list of values obtained by calling function `func_7` with arguments `f` and unpacked `dim[1:]` for each value in the range of `dim[0]` if `dim` is not empty. Otherwise, it returns the result of calling function `f`.

#Function 10:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i.**
def func_8(start, step, count):
    return range(start, start + step * count, step)
    #The program returns a range starting from 'start' with a step size of 'step' and containing 'count' elements

#Function 11:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5). a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n, a_i ≠ b_i.**
def func_9(l, start, end):
    return range(start, len(l) + end)
    #The program returns a range starting from index 'start' up to the length of list 'l' plus 'end'.

#Function 12:
#State of the program right berfore the function call: n is a tuple of two integers where the first integer represents the number of vertices (1 ≤ n ≤ 10^5) and the second integer represents the number of edges of weight 1 in the graph (0 ≤ m ≤ min((n(n-1))/(2),10^5)).**
def func_10(n):
    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """
    return 2 ** (n - 1).bit_length()
    #The program returns the smallest power of 2 that is greater than or equal to the number of vertices in the graph

#Function 13:
#State of the program right berfore the function call: x and r are integers such that 1 ≤ x ≤ 10^5 and 0 ≤ r ≤ min((x(x-1))/(2),10^5).**
def func_11(x, r):
    """ = ceil(x / r) """
    return (x + r - 1) // r
    #The program returns the result of the expression (x + r - 1) divided by r, rounded up to the nearest integer


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
