
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

Input

The first line contains the number of universities t, (1 ≤ t ≤ 1000) Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 109; li ≤ ri).

Output

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

Examples

Input

2
5 2 3
6 4 5


Output

Yes
No

Note

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is a positive integer, ni, li, ri are positive integers such that 1 ≤ ni, li, ri ≤ 109 and li ≤ ri.**
def func_1():
    return int(input())
    #The program returns the integer input by the user.

#Function 2:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) and for each query, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.**
def func_2():
    return input()
    #The program returns the input value t

#Function 3:
#State of the program right berfore the function call: **Precondition**: The input consists of t requests, where each request contains three integers ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object consisting of integers after converting the input string into a list of integers

#Function 4:
#State of the program right berfore the function call: **
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representation of the input values after stripping and splitting them by space

#Function 5:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) and for each query, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) where li ≤ ri.**
def func_5():
    return list(func_3())
    #The program returns a list of values calculated by calling func_3() for each query. The values of t, ni, li, and ri are positive integers within the specified ranges

#Function 6:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer representing the number of universities. Each query contains three space-separated integers ni, li, ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.**
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 1000.
- For each of the t queries:
  - ni, li, and ri are integers such that 1 <= ni, li, ri <= 10^9 and li <= ri.
def func_7(item):
    return item[1]
    #The program returns the second element of the 'item' variable

#Function 8:
#State of the program right berfore the function call: **
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in reverse order based on the custom key function 'getKey'

#Function 9:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer (1 ≤ t ≤ 1000). Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each row contains 'm' repetitions of 'num' and there are 'n' rows in total.

#Function 10:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 ≤ t ≤ 1000.
- For each query, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_10(x):
    return x and not x & x - 1
    #The program returns the result of bitwise AND operation between 'x' and the complement of 'x' bitwise AND 'x' minus 1.

#Function 11:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer, ni, li, ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer 'n' after removing the '0b' prefix

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers obtained by converting each character in the string representation of variable 'n' to an integer

#Function 13:
#State of the program right berfore the function call: n is a positive integer and r is a list of tuples where each tuple contains three positive integers (ni, li, ri) satisfying 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.**
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of dividing the factorial of n by the product of the factorial of r and the factorial of the maximum value between n-r and 1

#Function 14:
#State of the program right berfore the function call: **
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the result of integer division of 'x' by 'y', where 'x' is an integer and 'y' is an integer such that 'x' is divisible by 'y'
    else :
        return x // y + 1
        #The program returns the result of dividing 'x' by 'y' (integer division) and then adding 1 to the result. The value of 'x' is not divisible by 'y'.

#Function 15:
#State of the program right berfore the function call: **
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res` is updated to the final result after all iterations of the loop based on the initial values of `x`, `y`, and `p`, `x` is updated to the final value after all iterations of the loop, `y` becomes 0 after all iterations of the loop
    return res
    #The program returns the final result stored in variable `res` after all iterations of the loop. Variable `y` becomes 0 after all iterations of the loop.

#Function 16:
#State of the program right berfore the function call: t is an integer such that 1 <= t <= 1000. Each query contains three integers ni, li, ri such that 1 <= ni, li, ri <= 10^9 and li <= ri.**
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x is the greatest common divisor of the initial values of x and y, y is 0
    return x
    #The program returns the greatest common divisor of the initial values of x and y, which is x

#Function 17:
#State of the program right berfore the function call: n is a positive integer representing the number of universities. Each university query contains three integers ni, li, ri where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.**
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is a positive integer representing the number of universities. Each university query contains three integers ni, li, ri where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. n is larger than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is a positive integer representing the number of universities. Each university query contains three integers ni, li, ri where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is a positive integer representing the number of universities. Each university query contains three integers ni, li, ri where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. n is larger than 3. n is not divisible by 2 and 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is a positive integer larger than 3 and not divisible by 2 and 3, i is greater than the square root of n. The loop has finished executing, and the condition (n % i == 0 or n % (i + 2) == 0) is false for all iterations.
    return True
    #The program returns True

#Function 18:
#State of the program right berfore the function call: **
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: ** The input consists of t queries, each containing three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).
def func_19():
    for _ in range(func_1()):
        n, l, r = func_3()
        
        low = 1
        
        high = 1000000000
        
        f = 0
        
        while low <= high:
            mid = (low + high) // 2
            x = l * mid
            y = r * mid
            if x <= n and n <= y:
                f = 1
                break
            if y < n:
                low = mid + 1
            else:
                high = mid - 1
        
        if f:
            func_20('Yes')
        else:
            func_20('No')
        
    #State of the program after the  for loop has been executed: After all the iterations of the loop have finished, the final values of the variables depend on the values returned by func_1() and func_3(). If the conditions in the loop are met at least once, the final state will have 'f' set to 1 and the program will output 'Yes'. If the conditions are never met, 'f' will remain 0 and the program will output 'No'. The final values of 'n', 'l', 'r', 'low', 'high', 'mid', 'x', 'y' will depend on the specific values assigned at the end of the loop execution based on the conditions met during the loop iterations.

#Function 20:
#State of the program right berfore the function call: **Precondition**: The input consists of t requests, where t is an integer such that 1 <= t <= 1000. Each request contains three space-separated integers: ni, li, ri (1 <= ni, li, ri <= 10^9; li <= ri).
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` and `file` have assigned values, all elements in `args` have been written to the file separated by `sep`, `at_start` is False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep`, `file`, `args` have assigned values. All elements in `args` have been written to the file separated by `sep`. `at_start` is False. A newline character `'\n'` has been written to the file. If the keyword argument 'flush' is True, it has been popped from `kwargs`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
