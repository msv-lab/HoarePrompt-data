
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Students in a class are making towers of blocks. Each student makes a (non-zero) tower by stacking pieces lengthwise on top of each other. n of the students use pieces made of two blocks and m of the students use pieces made of three blocks.

The students don’t want to use too many blocks, but they also want to be unique, so no two students’ towers may contain the same number of blocks. Find the minimum height necessary for the tallest of the students' towers.

Input

The first line of the input contains two space-separated integers n and m (0 ≤ n, m ≤ 1 000 000, n + m > 0) — the number of students using two-block pieces and the number of students using three-block pieces, respectively.

Output

Print a single integer, denoting the minimum possible height of the tallest tower.

Examples

Input

1 3


Output

9


Input

3 2


Output

8


Input

5 0


Output

10

Note

In the first case, the student using two-block pieces can make a tower of height 4, and the students using three-block pieces can make towers of height 3, 6, and 9 blocks. The tallest tower has a height of 9 blocks.

In the second case, the students can make towers of heights 2, 4, and 8 with two-block pieces and towers of heights 3 and 6 with three-block pieces, for a maximum height of 8 blocks.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_1():
    return int(input())
    #The program returns an integer value obtained from the user input

#Function 2:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_2():
    return input()
    #The program returns the value of the input() function, which could be any input provided by the user

#Function 3:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers obtained by splitting the input string after stripping any leading or trailing whitespaces

#Function 4:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representation of the input values after stripping and splitting them by space

#Function 5:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3()

#Function 6:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_7(item):
    return item[1]
    #The program returns the second element of the 'item' variable

#Function 8:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in reverse order based on the function 'getKey'

#Function 9:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns where each element is 'num'

#Function 10:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_10(x):
    return x and not x & x - 1
    #The program returns the bitwise AND operation between x and the complement of x, i.e., not x & (x - 1)

#Function 11:
#State of the program right berfore the function call: n is a tuple of two non-negative integers representing the number of students using two-block pieces and three-block pieces, respectively.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns a binary representation of the tuple 'n' after removing the '0b' prefix

#Function 12:
#State of the program right berfore the function call: n is a tuple of two non-negative integers where the first integer represents the number of students using two-block pieces and the second integer represents the number of students using three-block pieces.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of two integers, where the first integer is the number of students using two-block pieces and the second integer is the number of students using three-block pieces from the tuple 'n'.

#Function 13:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r))
    #The program returns the result of calculating the combination of choosing r items from a set of n items, where n and r are non-negative integers such that n + r > 0.

#Function 14:
#State of the program right berfore the function call: x and y are non-negative integers such that x + y > 0.**
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the result of x divided by y using integer division
    else :
        return x // y + 1
        #The program returns the result of integer division of x by y, incremented by 1

#Function 15:
#State of the program right berfore the function call: x and y are non-negative integers such that x + y > 0, and p is a positive integer.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x`, `y`, `res` are integers, `y` is 0, `x` is updated according to the conditions mentioned in the loop
    return res
    #The program returns the integer value stored in 'res' after running the loop where 'x' is updated based on the conditions mentioned. 'y' is 0 at the beginning of the program.

#Function 16:
#State of the program right berfore the function call: x and y are non-negative integers such that x + y > 0.**
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: x is the greatest common divisor of the initial values of x and y, y is 0
    return x
    #The program returns the greatest common divisor of the initial values of x and y, which is x

#Function 17:
#State of the program right berfore the function call: n is a tuple of two non-negative integers representing the number of students using two-block pieces and three-block pieces, respectively.**
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is a tuple of two non-negative integers representing the number of students using two-block pieces and three-block pieces, respectively. The number of students is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is a tuple of two non-negative integers representing the number of students using two-block pieces and three-block pieces, respectively. The number of students is greater than 1. The number of students using two-block pieces and three-block pieces combined is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is a tuple of two non-negative integers representing the number of students using two-block pieces and three-block pieces, respectively. The number of students is greater than 1. The number of students using two-block pieces and three-block pieces combined is greater than 3. n is not divisible by 2 and not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: After the loop executes, the value of 'i' will be an integer that is greater than the square root of n. The loop control variable 'i' will not satisfy the condition 'i * i <= n' and the loop will terminate.
    return True
    #The program returns True after the loop terminates when the value of 'i' becomes an integer greater than the square root of n and no longer satisfies the condition 'i * i <= n'

#Function 18:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: n and m are non-negative integers such that n + m > 0.**
def func_19():
    n, m = func_3()
    for i in range(1, 1000001):
        if n <= i // 2 and m <= i // 3 and n + m <= i // 2 + i // 3 - i // 6:
            func_20(i)
            break
        
    #State of the program after the  for loop has been executed: If `n` and `m` are non-negative integers such that `n + m > 0`, then after all iterations of the loop have finished, `n` will be less than 500001, `m` will be less than 333334, and `n + m` will be less than 666667.

#Function 20:
#State of the program right berfore the function call: n and m are non-negative integers.**
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` and `m` are non-negative integers, `sep` is ' ', `file` is sys.stdout, `at_start` is False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n` and `m` are non-negative integers, `sep` is ' ', `file` is sys.stdout, `at_start` is False, a newline character is written to the file. If kwargs.pop('flush', False) is True, the file is flushed. Otherwise, no change occurs in the program state.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
