#State of the program right berfore the function call: **Precondition**: 
- The input integer n is such that 1 ≤ n ≤ 105.
- The sequence of integers on Alexander's cards is provided as input.
- Each integer in the sequence is a positive integer that does not exceed 10^8.
def func_1():
    return int(input())
    #The program returns an integer obtained from the input
#Overall this is what the function does:The function does not accept any parameters and simply returns an integer obtained from the input sequence of integers on Alexander's cards. The function ensures that the returned integer is within the valid range and adheres to the given constraints.

#State of the program right berfore the function call: n is a positive integer. The sequence of integers on Alexander's cards is a list of positive integers.**
def func_2():
    return input()
    #The program returns the input value n, which is a positive integer.
#Overall this is what the function does:The function does not accept any parameters and simply returns the input value n, which is expected to be a positive integer.

#State of the program right berfore the function call: n is a positive integer. The sequence of integers on Alexander's cards is a list of positive integers where each integer doesn't exceed 10^8.**
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers after converting them to integers from the input sequence of positive integers on Alexander's cards
#Overall this is what the function does:The function `func_3` reads an input sequence of positive integers from the user, splits the sequence by spaces, converts the elements into integers, and returns a list of these integers. The function assumes that the input sequence consists of positive integers only.

#State of the program right berfore the function call: ** The input consists of an integer n (1 ≤ n ≤ 10^5) representing the number of cards, followed by a sequence of n integers representing the numbers on Alexander's cards. Each integer is a positive number not exceeding 10^8.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the integers inputted as cards by Alexander
#Overall this is what the function does:The function `func_4` reads an integer `n` followed by a sequence of `n` integers representing the numbers on Alexander's cards. It then converts these integers to strings and returns a map object containing these string representations. The function does not handle the constraints on the range of input values (1 ≤ n ≤ 10^5, integers not exceeding 10^8) as described in the annotations.

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n. Each integer in the sequence is a positive integer and doesn't exceed 10^8.**
def func_5():
    return list(func_3())
    #The program returns a list of integers generated by calling the function `func_3()`
#Overall this is what the function does:The function `func_5` does not accept any parameters. It generates a list of integers by calling the function `func_3()` and returns this list. The function assumes that `func_3` will always return a valid list of integers. It does not handle any potential errors or edge cases related to the list generation process.

#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit and thread stack size, then starts a new thread that executes the `main` function. It does not accept any parameters and likely performs operations or calculations on a sequence of integers representing Alexander's cards. The function does not return any specific value, but it potentially handles tasks concurrently due to the threading implementation.

#State of the program right berfore the function call: **
def func_7(item):
    return item[1]
    #The program returns the element at index 1 of the list or tuple 'item'
#Overall this is what the function does:The function func_7 accepts a list or tuple as input and returns the element at index 1.

#State of the program right berfore the function call: l is a list of integers of length n (1 ≤ n ≤ 105).**
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list 'l' sorted based on the specified key function getKey
#Overall this is what the function does:The function func_8 accepts a list of integers 'l' and returns the list 'l' sorted based on the specified key function 'getKey'.

#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), m is a list of n positive integers, each not exceeding 10^8.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each row contains 'm' copies of the corresponding integer from the list 'm', repeated 'n' times
#Overall this is what the function does:The function func_9 accepts three parameters: n, m, and num. It returns a 2D list where each row contains 'm' copies of the corresponding integer 'num' from the list 'm', repeated 'n' times.

#State of the program right berfore the function call: x is a list of integers with length n (1 ≤ n ≤ 10^5).**
def func_10(x):
    return x and not x & x - 1
    #The program returns the list 'x' and the result of the bitwise AND operation between 'x' and the bitwise negation of 'x'
#Overall this is what the function does:The function accepts a list of integers `x` and returns the result of the bitwise AND operation between `x` and the bitwise negation of `x`.

#State of the program right berfore the function call: n is a positive integer.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n after removing the '0b' prefix
#Overall this is what the function does:The function accepts a positive integer n and returns its binary representation without the '0b' prefix.

#State of the program right berfore the function call: n is a positive integer greater than or equal to 1.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit of the positive integer 'n'
#Overall this is what the function does:The function `func_12` accepts a positive integer `n` greater than or equal to 1 and returns a list of integers where each integer is a digit of the positive integer `n`.

#State of the program right berfore the function call: x and y are integers representing the number of cards and the sequence of integers on the cards respectively. p is a positive integer that doesn't exceed 10^8.**
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x`, `p`, `res` are integers
    return res
    #The program returns the integer value stored in variable 'res'
#Overall this is what the function does:The function `func_13` accepts three parameters: `x`, `y`, and `p`. `x` and `y` are integers representing the number of cards and the sequence of integers on the cards respectively. `p` is a positive integer that doesn't exceed 10^8. The function calculates a result based on the values of `x`, `y`, and `p` using bitwise operations and modular arithmetic. It then returns the calculated result.

#State of the program right berfore the function call: x is an integer representing the number of cards (1 <= x <= 10^5), y is a list of integers representing the numbers on Alexander's cards.**
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is now assigned the value of the greatest common divisor of the numbers on Alexander's cards, `y` is 0
    return x
    #The program returns the greatest common divisor of the numbers on Alexander's cards stored in variable 'x'
#Overall this is what the function does:The function accepts an integer x representing the number of cards and a list of integers y representing the numbers on Alexander's cards. It calculates the greatest common divisor of the numbers in the list y and returns that value. If the list y is empty, the function returns 0.

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5.**
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 1 ≤ n ≤ 10^5. n is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer such that 1 ≤ n ≤ 10^5. n is greater than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 1 ≤ n ≤ 10^5, n is greater than 1 and larger than 3. n is not divisible by 2 and 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is an integer such that 1 ≤ n ≤ 10^5, n is greater than 1, not divisible by 2 and 3; i is the smallest prime number greater than the square root of n
    return True
    #The program returns True
#Overall this is what the function does:The function `func_15` accepts an integer `n` within the range 1 ≤ n ≤ 10^5 and determines if `n` is a prime number. The function returns True if `n` is prime and False otherwise. The code iterates through certain conditions to check for divisibility and returns the appropriate result. It covers cases where `n` is less than or equal to 1, less than or equal to 3, divisible by 2 or 3, and checks for other factors to determine primality.

#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 105) and the sequence of integers on Alexander's cards is a list of positive integers where each integer doesn't exceed 10^8.**
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_16` sets the standard input to read from a file named 'input.txt' and the standard output to write to a file named 'output.txt'. This function does not accept any parameters and does not return any value. It initializes the input and output streams for file handling.

#State of the program right berfore the function call: **Precondition**: 
- n is an integer such that 1 <= n <= 10^5.
- The sequence of integers on Alexander's cards has length n.
- Each integer in the sequence is a positive integer and doesn't exceed 10^8.
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`a` is a list sorted in ascending order. If `n` is equal to 1, `n` is 0 and we exit the program.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`a` is a list sorted in ascending order. If `a[0]` is equal to `a[1]`, `n` is 0 and the program exits. If `n` is equal to 1, `n` becomes 0 and the program exits. If `n` is equal to 2, `n` becomes 0 and the program continues with the rest of the code.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `l` contains the value of the first element of `a` plus half of the absolute difference between the second and first elements of `a` if the absolute value of the difference between the second and first elements of `a` is even.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`a` is a list sorted in ascending order. If `n` is equal to 1, `n` is 0 and we exit the program. If `n` is equal to 2, the program exits.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the length of unique elements in `g` is greater than 2, the program exits.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the length of unique elements in `g` is greater than or equal to 2, the length of unique elements in `g` is not equal to 1, and 0 is present in `l`, then the program exits.
        #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the length of unique elements in `g` is greater than or equal to 2, the length of unique elements in `g` is not equal to 1, and 0 is present in `l`, then the program exits.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the absolute difference between `a[i + 1]` and `a[i]` is not equal to `gc` for any iteration, then the loop breaks and the postcondition remains the same as the precondition.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is the total number of elements in list `a`, `g` contains positive differences between adjacent elements of list `a`, `l` contains all the differences `a[i + 1] - a[i]` for each iteration of the loop
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is the total number of elements in list `a`, `g` contains positive differences between adjacent elements of list `a`, `l` contains all the differences `a[i + 1] - a[i]` for each iteration of the loop. If the length of the list `l` after removing duplicates is equal to 1, then the function func_18(x) is called with no impact on the initial state variables. Otherwise, the length of the unique elements in list `l` is not equal to 1.
    #State of the program after the if-else block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains the result of the calculation `a[0] - (a[1] - a[0])` and `a[-1] + (a[1] - a[0])` appended at the end, `l` is a list containing unique elements, `l` is sorted in ascending order. If the length of unique elements in `g` is greater than 2, the program exits. If the length of list `g` after removing duplicates is equal to 1, then `func_18` is executed with the length of `l` as the parameter. Otherwise, `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is the total number of elements in list `a`, `g` contains positive differences between adjacent elements of list `a`, `l` contains all the differences `a[i + 1] - a[i]` for each iteration of the loop. If the length of the list `l` after removing duplicates is equal to 1, then the function `func_18` is called with no impact on the initial state variables. Otherwise, the length of the unique elements in list `l` is not equal to 1.
#Overall this is what the function does:The function `func_17` processes a sequence of integers present on Alexander's cards. It does not accept any parameters and operates independently. The sequence has a length `n`, where `n` is an integer satisfying 1 <= n <= 10^5. Each integer in the sequence is a positive integer and does not exceed 10^8. The function performs various operations on the sequence, such as sorting, calculation of differences between elements, and handling specific cases based on the length of the sequence. It uses conditions to determine actions to take based on the characteristics of the input sequence. The final functionality of the function is to process the given sequence of integers on Alexander's cards according to the specified constraints.

#State of the program right berfore the function call: **
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is ' ', `file` is `sys.stdout`, `at_start` is False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` is `sys.stdout`, `at_start` is False. If the 'flush' key is present in kwargs and set to True, then it is removed from kwargs. Otherwise, no changes are made.
#Overall this is what the function does:The function func_18 does not accept any parameters and writes the integer 18 to the default output stream. It handles printing a sequence of values separated by spaces, ending with a newline character. If the 'flush' key is present in the input dictionary kwargs and set to True, the stream will be flushed after writing.

