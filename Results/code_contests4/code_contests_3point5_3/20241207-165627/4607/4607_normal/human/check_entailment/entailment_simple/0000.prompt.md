
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **Precondition**: 
- The input integer n is such that 1 ≤ n ≤ 105.
- The sequence of integers on Alexander's cards is provided as input.
- Each integer in the sequence is a positive integer that does not exceed 10^8.
def func_1():
    return int(input())
    #The program returns an integer obtained from the input

#Function 2:
#State of the program right berfore the function call: n is a positive integer. The sequence of integers on Alexander's cards is a list of positive integers.**
def func_2():
    return input()
    #The program returns the input value n, which is a positive integer.

#Function 3:
#State of the program right berfore the function call: n is a positive integer. The sequence of integers on Alexander's cards is a list of positive integers where each integer doesn't exceed 10^8.**
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers after converting them to integers from the input sequence of positive integers on Alexander's cards

#Function 4:
#State of the program right berfore the function call: ** The input consists of an integer n (1 ≤ n ≤ 10^5) representing the number of cards, followed by a sequence of n integers representing the numbers on Alexander's cards. Each integer is a positive number not exceeding 10^8.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the integers inputted as cards by Alexander

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequence of integers on Alexander's cards has length n. Each integer in the sequence is a positive integer and doesn't exceed 10^8.**
def func_5():
    return list(func_3())
    #The program returns a list of integers generated by calling the function `func_3()`

#Function 6:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 10^5. The sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.**
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: **
def func_7(item):
    return item[1]
    #The program returns the element at index 1 of the list or tuple 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of integers of length n (1 ≤ n ≤ 105).**
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list 'l' sorted based on the specified key function getKey

#Function 9:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), m is a list of n positive integers, each not exceeding 10^8.**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each row contains 'm' copies of the corresponding integer from the list 'm', repeated 'n' times

#Function 10:
#State of the program right berfore the function call: x is a list of integers with length n (1 ≤ n ≤ 10^5).**
def func_10(x):
    return x and not x & x - 1
    #The program returns the list 'x' and the result of the bitwise AND operation between 'x' and the bitwise negation of 'x'

#Function 11:
#State of the program right berfore the function call: n is a positive integer.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n after removing the '0b' prefix

#Function 12:
#State of the program right berfore the function call: n is a positive integer greater than or equal to 1.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit of the positive integer 'n'

#Function 13:
#State of the program right berfore the function call: x and y are integers representing the number of cards and the sequence of integers on the cards respectively. p is a positive integer that doesn't exceed 10^8.**
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x`, `p`, `res` are integers
    return res
    #The program returns the integer value stored in variable 'res'

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 <= x <= 10^5), y is a list of integers representing the numbers on Alexander's cards.**
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is now assigned the value of the greatest common divisor of the numbers on Alexander's cards, `y` is 0
    return x
    #The program returns the greatest common divisor of the numbers on Alexander's cards stored in variable 'x'

#Function 15:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5.**
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 1 ≤ n ≤ 10^5. n is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer such that 1 ≤ n ≤ 10^5. n is greater than 1. n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 1 ≤ n ≤ 10^5, n is greater than 1 and larger than 3. n is not divisible by 2 and 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: n is an integer such that 1 ≤ n ≤ 10^5, n is greater than 1, not divisible by 2 and 3; i is the smallest prime number greater than the square root of n
    return True
    #The program returns True

#Function 16:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 105) and the sequence of integers on Alexander's cards is a list of positive integers where each integer doesn't exceed 10^8.**
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer such that 1 <= n <= 10^5.
- The sequence of integers on Alexander's cards has length n.
- Each integer in the sequence is a positive integer and doesn't exceed 10^8.
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`a` is a list sorted in ascending order. If `n` is equal to 1, `n` is 0 and we exit the program.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`a` is a list sorted in ascending order. If `a[0]` is equal to `a[1]`, `n` is 0 and the program exits. If `n` is equal to 1, `n` becomes 0 and the program exits. If `n` is equal to 2, `n` becomes 0 and the program continues with the rest of the code.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `l` contains the value of the first element of `a` plus half of the absolute difference between the second and first elements of `a` if the absolute value of the difference between the second and first elements of `a` is even.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`a` is a list sorted in ascending order. If `n` is equal to 1, `n` is 0 and we exit the program. If `n` is equal to 2, the program exits.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the length of unique elements in `g` is greater than 2, the program exits.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the length of unique elements in `g` is greater than or equal to 2, the length of unique elements in `g` is not equal to 1, and 0 is present in `l`, then the program exits.
        #State of the program after the if block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the length of unique elements in `g` is greater than or equal to 2, the length of unique elements in `g` is not equal to 1, and 0 is present in `l`, then the program exits.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains absolute differences between adjacent elements of list `a`. If the absolute difference between `a[i + 1]` and `a[i]` is not equal to `gc` for any iteration, then the loop breaks and the postcondition remains the same as the precondition.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is the total number of elements in list `a`, `g` contains positive differences between adjacent elements of list `a`, `l` contains all the differences `a[i + 1] - a[i]` for each iteration of the loop
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is the total number of elements in list `a`, `g` contains positive differences between adjacent elements of list `a`, `l` contains all the differences `a[i + 1] - a[i]` for each iteration of the loop. If the length of the list `l` after removing duplicates is equal to 1, then the function func_18(x) is called with no impact on the initial state variables. Otherwise, the length of the unique elements in list `l` is not equal to 1.
    #State of the program after the if-else block has been executed: *`a` is a list sorted in ascending order, `n` is 2, `g` contains positive differences between adjacent elements of list `a`, `l` contains the result of the calculation `a[0] - (a[1] - a[0])` and `a[-1] + (a[1] - a[0])` appended at the end, `l` is a list containing unique elements, `l` is sorted in ascending order. If the length of unique elements in `g` is greater than 2, the program exits. If the length of list `g` after removing duplicates is equal to 1, then `func_18` is executed with the length of `l` as the parameter. Otherwise, `gc` is assigned the value returned by `func_14(gc, l[len(l)-1])`, `a` is a list sorted in ascending order with additional elements calculated based on the formula `a[i] + (a[i + 1] - a[i]) // 2` for each iteration of the loop, `n` is the total number of elements in list `a`, `g` contains positive differences between adjacent elements of list `a`, `l` contains all the differences `a[i + 1] - a[i]` for each iteration of the loop. If the length of the list `l` after removing duplicates is equal to 1, then the function `func_18` is called with no impact on the initial state variables. Otherwise, the length of the unique elements in list `l` is not equal to 1.

#Function 18:
#State of the program right berfore the function call: **
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is ' ', `file` is `sys.stdout`, `at_start` is False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` is `sys.stdout`, `at_start` is False. If the 'flush' key is present in kwargs and set to True, then it is removed from kwargs. Otherwise, no changes are made.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
