
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **Precondition**: The input consists of t test cases where each test case contains three sequences of n integers (a_1, a_2, ..., a_n), (b_1, b_2, ..., b_n), and (c_1, c_2, ..., c_n) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i. The value of n is between 3 and 100, and the values of a_i, b_i, and c_i are between 1 and 100.
def func_1():
    return int(input())
    #The program returns an integer value obtained from the input

#Function 2:
#State of the program right berfore the function call: **
def func_2():
    return input()
    #The program returns the input provided by the user

#Function 3:
#State of the program right berfore the function call: **Precondition**: The input consists of t test cases, where each test case contains:
- An integer n (3 ≤ n ≤ 100)
- Three sequences of n integers a_i, b_i, c_i (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers that are extracted from the input after stripping and splitting by space

#Function 4:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object with elements converted to strings after splitting the input string

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3()

#Function 6:
#State of the program right berfore the function call: **Precondition**: 
- t is a positive integer such that 1 <= t <= 100.
- n is a positive integer such that 3 <= n <= 100.
- a_i, b_i, c_i are positive integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_7(item):
    return item[1]
    #The program returns the second item from the input list 'item'.

#Function 8:
#State of the program right berfore the function call: **
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns list 'l' sorted in reverse order based on the custom key function 'getKey'

#Function 9:
#State of the program right berfore the function call: **Precondition**: **n is an integer representing the number of test cases (1 ≤ n ≤ 100), m is an integer representing the number of elements in the sequences (3 ≤ m ≤ 100), num is a list of lists where each inner list contains n integers representing the elements of the sequences (1 ≤ num[i][j] ≤ 100).**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists where each inner list contains n integers representing the elements of the sequences, repeated m times

#Function 10:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_10(x):
    return x and not x & x - 1
    #The program returns the result of the logical operation "x and not x & x - 1"

#Function 11:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 <= t <= 100. n is an integer such that 3 <= n <= 100. a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of integer 'n' after removing the '0b' prefix

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers converted from each character in the string representation of variable 'n'

#Function 13:
#State of the program right berfore the function call: **
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of combination calculation using the given values of n and r

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- x is an integer representing the number of test cases, such that 1 <= x <= 100.
- y is a list of tuples where each tuple contains three integers a, b, c such that a != b, a != c, and b != c.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer value of x divided by the list y
    else :
        return x // y + 1
        #The program returns the result of the division of x by y plus 1

#Function 15:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 <= t <= 100. n is an integer such that 3 <= n <= 100. a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100. a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res`, `x`, and `y` are integers. If `y` & 1 is true, `res` is updated to the result of `res * x % p`, `y` is shifted right by 1 bit, `x` is updated to the result of `x * x % p`. The loop continues until `y` becomes 0.
    return res
    #The program returns the updated value of 'res' after executing the loop until 'y' becomes 0.

#Function 16:
#State of the program right berfore the function call: **
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` now holds the final value of `x % y`, `y` now holds 0
    return x
    #The program returns the final value of `x % y`, which is the value that `x` holds after performing the modulo operation with `y`. `y` now holds the value 0.

#Function 17:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer such that 3 <= n <= 100.
- The input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100.
- For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 100. The input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. n is larger than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 100, the input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. n is larger than 1 and n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 100, the input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. n is larger than 1 and n is larger than 3. n is not divisible by 2 and 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: If the loop finishes executing, n is a prime number
    return True
    #The program returns True if the loop finishes executing and n is a prime number

#Function 18:
#State of the program right berfore the function call: ** The input consists of t test cases, where each test case includes an integer n (3 ≤ n ≤ 100) representing the number of elements in the sequences, followed by three lines containing n integers each representing the sequences a, b, and c respectively. Each integer a_i, b_i, c_i (1 ≤ a_i, b_i, c_i ≤ 100) is such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: **
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: Output State: At the end of the loop, `a`, `b`, `c` will retain their original values from `func_5()`. `n` will be the value returned by `func_1()`. `ans` will be a list of length `n` where each element is determined based on the comparisons between the elements of `a`, `b`, and `c` at each index during the loop iterations.

#Function 20:
#State of the program right berfore the function call: **
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is ' ', `file` is `sys.stdout`, `at_start` is False, `args` list has at least 1 element and all elements have been written to the output separated by a space ' '
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` is `sys.stdout`, `at_start` is False, `args` list has at least 1 element and all elements have been written to the output separated by a space ' '. If the 'flush' key is present in `kwargs` and set to True, the output is flushed. Otherwise, no changes occur.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
