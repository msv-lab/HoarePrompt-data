
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **Precondition**: The input consists of t test cases where each test case contains three sequences of n integers (a_1, a_2, ..., a_n), (b_1, b_2, ..., b_n), and (c_1, c_2, ..., c_n) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i. The value of n is between 3 and 100, and the values of a_i, b_i, and c_i are between 1 and 100.
def func_1():
    return int(input())
    #The program returns an integer value obtained from the input
#Overall this is what the function does:The function `func_1` processes t test cases where each test case contains three sequences of n integers and returns an integer value obtained from the input. The function accepts no parameters. The preconditions state that the input consists of t test cases with specific constraints on the sequences of integers. However, the actual function does not process any test cases or sequences as indicated by the annotations. It simply returns an integer value obtained from the input.

#Function 2:
#State of the program right berfore the function call: **
def func_2():
    return input()
    #The program returns the input provided by the user
#Overall this is what the function does:The function func_2 does not accept any parameters and simply returns the input provided by the user. This means that the program will wait for user input and return whatever the user inputs.

#Function 3:
#State of the program right berfore the function call: **Precondition**: The input consists of t test cases, where each test case contains:
- An integer n (3 ≤ n ≤ 100)
- Three sequences of n integers a_i, b_i, c_i (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers that are extracted from the input after stripping and splitting by space
#Overall this is what the function does:The function func_3 reads t test cases, each containing an integer n and three sequences of n integers. It then extracts these integers from the input by stripping and splitting by space, returning a map object. The function does not enforce the constraints of 3 ≤ n ≤ 100, and 1 ≤ a_i, b_i, c_i ≤ 100, and the conditions a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i described in the annotation.

#Function 4:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object with elements converted to strings after splitting the input string
#Overall this is what the function does:The function `func_4` does not accept any parameters. It processes an input string by splitting it into elements, then converts these elements to strings and returns a map object containing the converted elements. The function does not consider the initial conditions mentioned in the annotations regarding the range of `t`, `n`, `a_i`, `b_i`, and `c_i`. It solely focuses on processing the input string.

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3()
#Overall this is what the function does:The function func_5 does not have any parameters and returns a list generated by calling the function func_3().

#Function 6:
#State of the program right berfore the function call: **Precondition**: 
- t is a positive integer such that 1 <= t <= 100.
- n is a positive integer such that 3 <= n <= 100.
- a_i, b_i, c_i are positive integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit and stack size, creates a new thread targeting the `main` function, and starts the thread. It does not accept any parameters and does not have a specific return value. The purpose of the function is to initialize certain settings and create a new thread for further operations based on the provided preconditions.

#Function 7:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_7(item):
    return item[1]
    #The program returns the second item from the input list 'item'.
#Overall this is what the function does:The function func_7 accepts a list 'item' as a parameter and returns the second item from the list. The function does not consider any edge cases or missing functionality as it directly returns the second item from the input list without any conditions.

#Function 8:
#State of the program right berfore the function call: **
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns list 'l' sorted in reverse order based on the custom key function 'getKey'
#Overall this is what the function does:The function func_8 accepts a list 'l' and returns the list sorted in reverse order based on the custom key function 'getKey'.

#Function 9:
#State of the program right berfore the function call: **Precondition**: **n is an integer representing the number of test cases (1 ≤ n ≤ 100), m is an integer representing the number of elements in the sequences (3 ≤ m ≤ 100), num is a list of lists where each inner list contains n integers representing the elements of the sequences (1 ≤ num[i][j] ≤ 100).**
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists where each inner list contains n integers representing the elements of the sequences, repeated m times
#Overall this is what the function does:The function func_9 accepts three parameters: n, m, and num. It returns a list of lists where each inner list contains n integers representing the elements of the sequences, repeated m times. The function assumes the input parameters n and m fall within the specified ranges.

#Function 10:
#State of the program right berfore the function call: **Precondition**: 
- t is an integer such that 1 <= t <= 100.
- n is an integer such that 3 <= n <= 100.
- a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100.
- a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_10(x):
    return x and not x & x - 1
    #The program returns the result of the logical operation "x and not x & x - 1"
#Overall this is what the function does:The function accepts a boolean parameter x and returns the result of the logical operation "x and not x & x - 1".

#Function 11:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 <= t <= 100. n is an integer such that 3 <= n <= 100. a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of integer 'n' after removing the '0b' prefix
#Overall this is what the function does:The function func_11 accepts an integer n within the range of 3 to 100 and returns the binary representation of integer 'n' after removing the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: **
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers converted from each character in the string representation of variable 'n'
#Overall this is what the function does:The function func_12 accepts a parameter `n` and converts each character in the string representation of `n` into an integer, returning a list of these integers.

#Function 13:
#State of the program right berfore the function call: **
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of combination calculation using the given values of n and r
#Overall this is what the function does:The function `func_13` accepts two integer parameters `n` and `r`, and calculates the result of the combination calculation using these values by utilizing the factorial function. The calculated result is returned by the function. The function does not handle cases where `n` or `r` are negative as factorial calculations are not defined for negative integers. Additionally, the function does not account for potential errors that might occur during the factorial calculation, such as overflow errors for large values of `n` and `r`.

#Function 14:
#State of the program right berfore the function call: **Precondition**: 
- x is an integer representing the number of test cases, such that 1 <= x <= 100.
- y is a list of tuples where each tuple contains three integers a, b, c such that a != b, a != c, and b != c.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer value of x divided by the list y
    else :
        return x // y + 1
        #The program returns the result of the division of x by y plus 1
#Overall this is what the function does:The function `func_14` accepts two parameters: `x`, an integer representing the number of test cases, and `y`, a list of tuples where each tuple contains three integers a, b, c such that a != b, a != c, and b != c. The function then performs two different calculations based on the input parameters: 
- Case_1: If x is divisible by y, it returns the integer value of x divided by y.
- Case_2: If x is not divisible by y, it returns the result of the division of x by y plus 1.

#Function 15:
#State of the program right berfore the function call: **Precondition**: **t is an integer such that 1 <= t <= 100. n is an integer such that 3 <= n <= 100. a_i, b_i, c_i are integers such that 1 <= a_i, b_i, c_i <= 100. a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res`, `x`, and `y` are integers. If `y` & 1 is true, `res` is updated to the result of `res * x % p`, `y` is shifted right by 1 bit, `x` is updated to the result of `x * x % p`. The loop continues until `y` becomes 0.
    return res
    #The program returns the updated value of 'res' after executing the loop until 'y' becomes 0.
#Overall this is what the function does:The function `func_15` accepts three parameters `x`, `y`, and `p`. It performs a series of calculations on `x` and `y` based on the conditions within the loop until `y` becomes 0. The function then returns the updated value of `res`. The loop iterates through the binary representation of `y`, updating `res`, `x`, and `y` accordingly. The function does not handle edge cases where `p` is 0, negative, or not provided as it might lead to division by zero errors or incorrect results.

#Function 16:
#State of the program right berfore the function call: **
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` now holds the final value of `x % y`, `y` now holds 0
    return x
    #The program returns the final value of `x % y`, which is the value that `x` holds after performing the modulo operation with `y`. `y` now holds the value 0.
#Overall this is what the function does:The function accepts two integer parameters `x` and `y`, and iteratively calculates the final value of `x % y` until `y` becomes 0. The function then returns the last calculated value of `x % y`, which is the value that `x` holds after the modulo operation with `y`. `y` is updated to 0 after the operation.

#Function 17:
#State of the program right berfore the function call: **Precondition**: 
- n is an integer such that 3 <= n <= 100.
- The input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100.
- For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 100. The input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. n is larger than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 100, the input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. n is larger than 1 and n is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer such that 3 <= n <= 100, the input sequences a_i, b_i, c_i are lists of integers of length n, where 1 ≤ a_i, b_i, c_i ≤ 100. For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. n is larger than 1 and n is larger than 3. n is not divisible by 2 and 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: If the loop finishes executing, n is a prime number
    return True
    #The program returns True if the loop finishes executing and n is a prime number
#Overall this is what the function does:The function `func_17` accepts an integer `n` within the range 3 <= n <= 100. It checks various conditions and returns True or False based on those conditions. If n is less than or equal to 1, it returns False. If n equals 3, it returns True. If n is divisible by 2 or 3, it returns False. It then checks if n is a prime number by iterating through a loop. If the loop finishes execution and n is a prime number, it returns True. The function returns different values depending on the specified conditions. It does not return what the annotations suggest for some cases, indicating potential discrepancies between the code and annotations.

#Function 18:
#State of the program right berfore the function call: ** The input consists of t test cases, where each test case includes an integer n (3 ≤ n ≤ 100) representing the number of elements in the sequences, followed by three lines containing n integers each representing the sequences a, b, and c respectively. Each integer a_i, b_i, c_i (1 ≤ a_i, b_i, c_i ≤ 100) is such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_18` is designed to handle multiple test cases. It opens an input file and an output file for reading and writing respectively. It does not accept any parameters. Each test case consists of an integer n representing the number of elements in sequences a, b, and c. The function does not return any specific output.

#Function 19:
#State of the program right berfore the function call: **
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: Output State: At the end of the loop, `a`, `b`, `c` will retain their original values from `func_5()`. `n` will be the value returned by `func_1()`. `ans` will be a list of length `n` where each element is determined based on the comparisons between the elements of `a`, `b`, and `c` at each index during the loop iterations.
#Overall this is what the function does:The function func_19 does not accept any parameters and always returns the value 19. It iterates over a loop where it assigns values to variables a, b, c based on the return values of func_5(). It then creates a list ans of length n and populates it based on comparisons between elements of a, b, and c. Finally, it calls func_20 with the elements of ans.

#Function 20:
#State of the program right berfore the function call: **
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is ' ', `file` is `sys.stdout`, `at_start` is False, `args` list has at least 1 element and all elements have been written to the output separated by a space ' '
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' ', `file` is `sys.stdout`, `at_start` is False, `args` list has at least 1 element and all elements have been written to the output separated by a space ' '. If the 'flush' key is present in `kwargs` and set to True, the output is flushed. Otherwise, no changes occur.
#Overall this is what the function does:The function `func_20` does not accept any parameters. It iterates through the elements in `args`, writing each element to the output stream separated by a space ' '. After writing all elements, it writes a newline character '\n' by default. If the 'flush' key is present in the keyword arguments and set to True, the output is flushed. The function does not return any value explicitly.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.