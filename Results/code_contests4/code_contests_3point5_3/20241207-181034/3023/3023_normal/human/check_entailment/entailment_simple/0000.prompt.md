
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: `N` is greater than 0, `balls` list contains N arrays, `_` is N
    func_8(func_2(N, balls))

#Function 2:
#State of the program right berfore the function call: **
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `bdict` is a defaultdict of sets with all `y` values added to the corresponding sets for each `x` from the `balls` list
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `bdict` is a defaultdict of sets with all `y` values added to the corresponding sets for each `x` from the `balls` list. `tried` contains all unique tuples `(p, q)` and `(-p, -q)` where `p` and `q` are the differences in x and y coordinates between all pairs of balls. The function `score(p, q)` has been called with various values of `p` and `q`, resulting in different `points` values. The `ans` variable holds the minimum `points` value calculated for all pairs of balls. `i` is equal to `n-1`, `n` is greater than 0.
    return ans
    #The program returns the minimum points value calculated for all pairs of balls

#Function 3:
#State of the program right berfore the function call: **
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `out` is equal to the initial value of `n`. The loop will iterate through all the values in the list `balls`, updating `nx` and `ny` accordingly. If the value of `ny` is in the list associated with key `nx` in `bdict`, then `out` will be decreased by 1 for each occurrence. Otherwise, no changes occur to the variables `out`, `balls`, `nx`, `ny`, and `bdict`.
    return out
    #The program returns the updated value of 'out' after iterating through the list 'balls' and updating 'nx' and 'ny' based on the conditions mentioned

#Function 4:
#State of the program right berfore the function call: **
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *The program variables remain unchanged. If 'PYCHARM_HOSTED' is not present in os.environ, the program variables also remain unchanged.

#Function 5:
#State of the program right berfore the function call: N is a positive integer, and x_i, y_i are integers such that 1 <= i <= N and |x_i|, |y_i| <= 10^9.**
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`judge` and `slow_solution` are either None or remain None. If `solution` is not None, then `judge` and `slow_solution` remain None. `test_outputs` is not None.
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *If `judge` is not None, then `judge` is not None and `slow_solution` is None. If `judge` is None, then `judge`, `slow_solution`, and `solution` are all None. `test_outputs` is not None in both cases.
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *If `judge` is not None, then `judge` is not None, `slow_solution` is None, `test_outputs` is not None, and `slow_solution` is not None. If `judge` is None, then `judge`, `slow_solution`, and `solution` are all None, `test_outputs` is not None, and `slow_solution` is not None.
    #State of the program after the if block has been executed: *If `solution` is not None, then `judge` is not None, `slow_solution` is None, `test_outputs` is not None, and `slow_solution` is not None. If `solution` is None, then `judge`, `slow_solution`, and `solution` are all None, `test_outputs` is not None, and `slow_solution` is not None.

#Function 6:
#State of the program right berfore the function call: **
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is equal to the total number of iterations of the loop, `wrong` is the number of times the condition `ans != test_ans` was true, `ans` is the result of the function `solution` after the loop finishes executing.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 7:
#State of the program right berfore the function call: **
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `wrong` is an integer, `total` is equal to the total number of inputs_gen
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 8:
#State of the program right berfore the function call: **
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: total is the total number of iterations, wrong is the number of times ans is not equal to slow, ans is the result of calling the function solution with arguments args after making a deep copy, slow is the result of calling the function solution_slow with arguments args after making a deep copy, func_8 is called with the arguments 'WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args) for each time ans is not equal to slow
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 9:
#State of the program right berfore the function call: N is a positive integer, and x_i, y_i are integers such that 1 <= i <= N and |x_i|, |y_i| <= 10^9.**
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: at_start is False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *at_start is False, '\n' is written to the file, kwargs does not contain 'flush' key. If 'flush' key is present in kwargs and set to True, the function pops the 'flush' key. Otherwise, no changes are made to the variables.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
