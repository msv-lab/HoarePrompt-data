
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: `N` is greater than 0, `balls` list contains N arrays, `_` is N
    func_8(func_2(N, balls))
#Overall this is what the function does:The function func_1 reads an integer N, creates a list of N arrays by appending integer arrays to the balls list, and then calls func_8 with the result of func_2(N, balls). The function does not accept any parameters and does not return any value.

#Function 2:
#State of the program right berfore the function call: **
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `bdict` is a defaultdict of sets with all `y` values added to the corresponding sets for each `x` from the `balls` list
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `bdict` is a defaultdict of sets with all `y` values added to the corresponding sets for each `x` from the `balls` list. `tried` contains all unique tuples `(p, q)` and `(-p, -q)` where `p` and `q` are the differences in x and y coordinates between all pairs of balls. The function `score(p, q)` has been called with various values of `p` and `q`, resulting in different `points` values. The `ans` variable holds the minimum `points` value calculated for all pairs of balls. `i` is equal to `n-1`, `n` is greater than 0.
    return ans
    #The program returns the minimum points value calculated for all pairs of balls
#Overall this is what the function does:The function `func_2` accepts two parameters `n` and `balls`. It creates a dictionary `bdict` where each key `x` holds a set of corresponding `y` values from the `balls` list. Then, it iterates over all pairs of balls, calculates the differences in coordinates, calls the `score` function to get points, and updates the minimum `ans` value. Finally, it returns the minimum points value obtained by pairing up all the balls in the list. The function does not handle cases where `n` or `balls` are empty or when the `score` function is not defined.

#Function 3:
#State of the program right berfore the function call: **
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `out` is equal to the initial value of `n`. The loop will iterate through all the values in the list `balls`, updating `nx` and `ny` accordingly. If the value of `ny` is in the list associated with key `nx` in `bdict`, then `out` will be decreased by 1 for each occurrence. Otherwise, no changes occur to the variables `out`, `balls`, `nx`, `ny`, and `bdict`.
    return out
    #The program returns the updated value of 'out' after iterating through the list 'balls' and updating 'nx' and 'ny' based on the conditions mentioned
#Overall this is what the function does:The function `score` accepts two parameters `p` and `q`, both integers. It iterates through a list of 'balls', updating 'nx' and 'ny' based on the values of 'p' and 'q'. If the value of 'ny' is in the list associated with key 'nx' in 'bdict', 'out' is decreased by 1 for each occurrence. The function then returns the final value of 'out'.

#Function 4:
#State of the program right berfore the function call: **
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *The program variables remain unchanged. If 'PYCHARM_HOSTED' is not present in os.environ, the program variables also remain unchanged.
#Overall this is what the function does:The function `func_3` does not accept any parameters. It conditionally calls either `func_4` or `func_1` based on whether 'PYCHARM_HOSTED' is in the os.environ dictionary. The program variables remain unchanged after the if-else block has been executed. The function does not have any specific output defined.

#Function 5:
#State of the program right berfore the function call: N is a positive integer, and x_i, y_i are integers such that 1 <= i <= N and |x_i|, |y_i| <= 10^9.**
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`judge` and `slow_solution` are either None or remain None. If `solution` is not None, then `judge` and `slow_solution` remain None. `test_outputs` is not None.
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *If `judge` is not None, then `judge` is not None and `slow_solution` is None. If `judge` is None, then `judge`, `slow_solution`, and `solution` are all None. `test_outputs` is not None in both cases.
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *If `judge` is not None, then `judge` is not None, `slow_solution` is None, `test_outputs` is not None, and `slow_solution` is not None. If `judge` is None, then `judge`, `slow_solution`, and `solution` are all None, `test_outputs` is not None, and `slow_solution` is not None.
    #State of the program after the if block has been executed: *If `solution` is not None, then `judge` is not None, `slow_solution` is None, `test_outputs` is not None, and `slow_solution` is not None. If `solution` is None, then `judge`, `slow_solution`, and `solution` are all None, `test_outputs` is not None, and `slow_solution` is not None.
#Overall this is what the function does:The function `func_4` is a parameterless function that does not accept any input. After execution, it performs certain calculations or logic based on the values of `solution`, `test_inputs`, `test_outputs`, `judge`, and `slow_solution`. The function interacts with other functions `func_5`, `func_6`, and `func_7` based on the conditions of these variables. The final output returned by `func_4` is dependent on the constraints specified for the parameters `N`, `x_i`, and `y_i`. The function does not have a clear defined output based on the annotations, and its actual functionality is not fully specified. It seems to serve as a control flow mechanism for interacting with other functions based on certain conditions.

#Function 6:
#State of the program right berfore the function call: **
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is equal to the total number of iterations of the loop, `wrong` is the number of times the condition `ans != test_ans` was true, `ans` is the result of the function `solution` after the loop finishes executing.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))
#Overall this is what the function does:The function `func_5` takes two parameters: `solution` representing the solution to a problem and `inputs_answers` containing input-output pairs. It iterates through the input-answer pairs, calls the `solution` function with the input arguments, compares the output to the expected answer, and prints whether the test passed or failed. The function keeps track of the total number of tests and the number of incorrect results. At the end, it prints a summary indicating if all tests passed or how many tests were incorrect. The function does not have a specific return value, as it is used for verification purposes.

#Function 7:
#State of the program right berfore the function call: **
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `wrong` is an integer, `total` is equal to the total number of inputs_gen
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))
#Overall this is what the function does:The function `func_6` accepts three parameters: `solution`, `inputs_gen`, and `judge`. It iterates through the inputs generated by `inputs_gen`, applies the `solution` function to the arguments, and checks the result using the `judge` function. It keeps track of the number of correct and wrong answers. Finally, it outputs a message indicating whether all tests passed or the number of wrong tests out of the total. The function does not have a specific return value defined in the provided information.

#Function 8:
#State of the program right berfore the function call: **
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: total is the total number of iterations, wrong is the number of times ans is not equal to slow, ans is the result of calling the function solution with arguments args after making a deep copy, slow is the result of calling the function solution_slow with arguments args after making a deep copy, func_8 is called with the arguments 'WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args) for each time ans is not equal to slow
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))
#Overall this is what the function does:The function `func_7` iterates over a generator `inputs_gen` containing arguments, calls the `solution` and `solution_slow` functions with each set of arguments after making deep copies, compares the results, and increments a counter for any mismatches. It then outputs the total number of tests run and the number of test mismatches. If all tests pass, it will print 'ALL %d TESTS PASSED', otherwise it will print '%d out of %d tests are WRONG'. The function does not explicitly return a value.

#Function 9:
#State of the program right berfore the function call: N is a positive integer, and x_i, y_i are integers such that 1 <= i <= N and |x_i|, |y_i| <= 10^9.**
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: at_start is False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *at_start is False, '\n' is written to the file, kwargs does not contain 'flush' key. If 'flush' key is present in kwargs and set to True, the function pops the 'flush' key. Otherwise, no changes are made to the variables.
#Overall this is what the function does:The function `func_8` does not accept any parameters explicitly. However, it processes keyword arguments (kwargs) such as 'sep', 'file', 'end', and 'flush'. The function iterates over the arguments provided in args, writes them to the specified file or sys.stdout with the given separator, and appends the 'end' character at the end. If the 'flush' key is present and set to True in kwargs, the file will be flushed. The function provides flexibility in handling input arguments and writing them to a stream or file.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.