
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths a, b, and c. Now he needs to find out some possible integer length d of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to a, b, c, and d. Help Yura, find any possible length of the fourth side.

A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself.

Input

The first line contains a single integer t — the number of test cases (1 ≤ t ≤ 1000). The next t lines describe the test cases.

Each line contains three integers a, b, and c — the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).

Output

For each test case print a single integer d — the length of the fourth fence segment that is suitable for building the fence. If there are multiple answers, print any. We can show that an answer always exists.

Example

Input


2
1 2 3
12 34 56


Output


4
42

Note

We can build a quadrilateral with sides 1, 2, 3, 4.

We can build a quadrilateral with sides 12, 34, 56, 42.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    return int(input())
    #The program returns an integer converted from the user input

#Function 2:
#State of the program right berfore the function call: a, b, and c are positive integers such that 1 ≤ a, b, c ≤ 10^9.
def func_2():
    return input()
    #The program returns the input value provided by the user

#Function 3:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. For each test case, a, b, and c are positive integers such that 1 ≤ a, b, c ≤ 10^9.**
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing three integers obtained from the input by stripping and splitting

#Function 4:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c where 1 ≤ a, b, c ≤ 10^9.**
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a list of three strings, each containing the value of a, b, and c after converting them to strings

#Function 5:
#State of the program right berfore the function call: **
def func_5():
    return list(func_3())
    #The program returns a list that is the result of calling the function func_3()

#Function 6:
#State of the program right berfore the function call: **Precondition**: **t is a positive integer. a, b, and c are positive integers such that 1 ≤ a, b, c ≤ 10^9.**
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. Each test case consists of three positive integers a, b, and c representing the lengths of three fence segments. (1 ≤ a, b, c ≤ 10^9)**.
def func_7(item):
    return item[1]
    #The program returns the second positive integer 'b', which represents the length of the second fence segment in each test case

#Function 8:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c representing the lengths of three fence segments, where 1 ≤ a, b, c ≤ 10^9.**
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a sorted list 'l' in reverse order based on the custom key function 'getKey'

#Function 9:
#State of the program right berfore the function call: **
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each row contains 'm' number of 'num' elements, and there are 'n' rows in total

#Function 10:
#State of the program right berfore the function call: **
def func_10(x):
    return x and not x & x - 1
    #The program returns x and not x & x - 1

#Function 11:
#State of the program right berfore the function call: **
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer 'n' without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c representing the lengths of the three fence segments where 1 ≤ a, b, c ≤ 10^9.**
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers obtained by converting the integer n to a string and then converting each character back to an integer

#Function 13:
#State of the program right berfore the function call: **
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combination calculation using the factorial function with variables n, r, and max(n-r, 1)

#Function 14:
#State of the program right berfore the function call: x and y are integers such that 1 ≤ x, y ≤ 10^9.**
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer result of dividing x by y, where x and y are integers such that 1 ≤ x, y ≤ 10^9 and x is divisible by y
    else :
        return x // y + 1
        #The program returns the result of x divided by y (ignoring the remainder) plus 1

#Function 15:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c representing the lengths of the three fence segments, where 1 ≤ a, b, c ≤ 10^9.**
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `res` and `x` are updated based on the modulus operation with `p`, `y` is 0
    return res
    #The program returns the value of 'res' after updating it based on the modulus operation with 'p'

#Function 16:
#State of the program right berfore the function call: **
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor of the initial values of `x` and `y`, `y` is 0
    return x
    #The program returns the greatest common divisor of the initial values of `x` and `y`, which is the initial value of `x`

#Function 17:
#State of the program right berfore the function call: **
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False as n is less than or equal to 1
    #State of the program after the if block has been executed: *`n` is an integer. `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True if the value of integer 'n' is less than or equal to 3 after entering the if condition
    #State of the program after the if block has been executed: *`n` is an integer. `n` is greater than 1. `n` is larger than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer. `n` is greater than 1. `n` is larger than 3. The value of `n` is not divisible by 2 or 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: If `n` is not divisible by any number `i` or `i+2` where `i` is 5, 11, 17, ..., then the function returns True. Otherwise, the function returns False.
    return True
    #The program returns True if 'n' is not divisible by any number 'i' or 'i+2' where 'i' is 5, 11, 17, ..., otherwise it returns False

#Function 18:
#State of the program right berfore the function call: **
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: Each test case consists of three integers a, b, and c representing the lengths of the three fence segments, where 1 ≤ a, b, c ≤ 10^9.**
def func_19():
    for _ in range(func_1()):
        a, b, c = func_3()
        
        func_20(c + 1)
        
    #State of the program after the  for loop has been executed: The values of a, b, and c after all iterations of the loop will be the values returned by `func_3()` for each variable.

#Function 20:
#State of the program right berfore the function call: **
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is either the value extracted from `kwargs` or ' ', `file` is the value extracted from `kwargs` or `sys.stdout`, `at_start` is False, `args` is a non-empty iterable
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is either the value extracted from `kwargs` or ' ', `file` is the value extracted from `kwargs` or `sys.stdout`, `at_start` is False, `args` is a non-empty iterable. If the 'flush' key is present in `kwargs` and its value is True, then the key is removed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
