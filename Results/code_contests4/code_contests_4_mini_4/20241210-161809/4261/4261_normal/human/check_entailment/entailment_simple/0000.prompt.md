
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Suppose you are performing the following algorithm. There is an array v_1, v_2, ..., v_n filled with zeroes at start. The following operation is applied to the array several times — at i-th step (0-indexed) you can: 

  * either choose position pos (1 ≤ pos ≤ n) and increase v_{pos} by k^i; 
  * or not choose any position and skip this step. 



You can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array v equal to the given array a (v_j = a_j for each j) after some step?

Input

The first line contains one integer T (1 ≤ T ≤ 1000) — the number of test cases. Next 2T lines contain test cases — two lines per test case.

The first line of each test case contains two integers n and k (1 ≤ n ≤ 30, 2 ≤ k ≤ 100) — the size of arrays v and a and value k used in the algorithm.

The second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{16}) — the array you'd like to achieve.

Output

For each test case print YES (case insensitive) if you can achieve the array a after some step or NO (case insensitive) otherwise.

Example

Input


5
4 100
0 0 0 0
1 2
1
3 4
1 4 1
3 2
0 1 3
3 9
0 59049 810


Output


YES
YES
NO
NO
YES

Note

In the first test case, you can stop the algorithm before the 0-th step, or don't choose any position several times and stop the algorithm.

In the second test case, you can add k^0 to v_1 and stop the algorithm.

In the third test case, you can't make two 1 in the array v.

In the fifth test case, you can skip 9^0 and 9^1, then add 9^2 and 9^3 to v_3, skip 9^4 and finally, add 9^5 to v_2.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os
import sys
from bisect import bisect_left, bisect_right
from io import BytesIO, IOBase

""" Hey stalker :) """
INF = 10 ** 10
TEST_CASES = True
class SegTreeSum:

    def __init__(self, size):
        self.n = 1 << size.bit_length()
        self.li = [0] * (self.n << 1)

    def set(self, index, ele):
        index += self.n
        self.li[index] = ele
        while index > 1:
            self.li[index >> 1] = self.li[index] + self.li[index ^ 1]
            index >>= 1

    def add(self, index, val):
        self.set(index, self.get(index) + val)

    def get(self, index):
        return self.li[self.n + index]

    def query(self, l, r):
        res = 0
        (l, r) = (l + self.n, r + self.n)
        while l <= r:
            if l & 1 == 1:
                res += self.li[l]
            if r & 1 != 1:
                res += self.li[r]
            l = l + 1 >> 1
            r = r - 1 >> 1
        return res
' FastIO Footer by @c1729 and other contributors '
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
get_int = lambda : int(input())
get_list = lambda : list(map(int, input().split()))
if __name__ == '__main__':
    if TEST_CASES:
        [func_1() for _ in range(int(input()))]
    else:
        func_1()

#Function 1:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 30), k is an integer (2 ≤ k ≤ 100), and li is a list of n non-negative integers (0 ≤ a_i ≤ 10^16).
def func_1():
    n, k = get_list()
    li = get_list()
    req = set()
    for i in li:
        r = 0
        
        while i > 0:
            j = 0
            while i % k ** (j + 1) == 0:
                j += 1
            i //= k ** j
            j += r
            if j in req:
                func_2('NO')
                return
            req.add(j)
            r = j
            i -= 1
        
    #State of the program after the  for loop has been executed: `req` contains all unique values of `j` computed during the loop iterations, `r` is equal to the last computed value of `j`, `i` is less than the original value of `i` for all elements of `li`, and all values in `req` are non-negative integers derived from the computations based on the elements of `li`. If `li` was empty, `req` remains empty, and `r` and `j` are unchanged.
    func_2('YES')

#Function 2:
#State of the program right berfore the function call: args is a variable-length argument list containing values of any type, and kwargs is a dictionary of optional keyword arguments that may include 'sep', 'file', 'end', and 'flush'.
def func_2():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a variable-length argument list containing values of any type, `x` is the last value in `args`, `at_start` is False, `file` now contains the string representations of all values in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a variable-length argument list containing values of any type, `x` is the last value in `args`, `at_start` is False, `file` contains the string representations of all values in `args` separated by `sep`, the value of `kwargs` has been updated due to the pop operation, and if the previous value associated with the key 'flush' was removed and is now True, the flush operation has been executed on `file`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
