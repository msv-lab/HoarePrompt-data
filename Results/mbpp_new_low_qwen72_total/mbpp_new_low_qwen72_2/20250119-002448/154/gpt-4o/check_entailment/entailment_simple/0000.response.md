### Reasoning:

1. **Base Case Handling**: The function checks if the input `d` is either not a dictionary or an empty dictionary. If so, it returns `1`. This is appropriate because a non-dictionary or an empty dictionary has no further nested levels, so its depth is considered to be `1`.

2. **Recursive Case**: If `d` is a non-empty dictionary, the function recursively calculates the depth of each value in the dictionary and returns `1 + max(func_1(value) for value in d.values())`. This correctly accounts for the current level plus the maximum depth of any nested dictionaries.

3. **Test Cases**:
   - `func_1({'a': 1, 'b': {'c': {'d': {}}}})` should return `4` because the deepest nesting is 4 levels deep.
   - `func_1({'a': 1, 'b': {'c': 'python'}})` should return `2` because the deepest nesting is 2 levels deep.
   - `func_1({1: 'Sun', 2: {3: {4: 'Mon'}}})` should return `3` because the deepest nesting is 3 levels deep.

4. **Edge Cases**:
   - The function correctly handles non-dictionary values by returning `1` for them.
   - It also correctly handles empty dictionaries by returning `1`.

Given the above points, the function appears to handle all the specified cases correctly.

### Correctness:
Correctness: **True**