To determine the correctness of the provided program against the problem description, let's analyze the relevant constraints and logic present in the code.

**Constraints and Logic from the Problem:**
1. There are `N` different collectible coins and Ivan currently has `K` of them. 
2. Ivan has `M` friends who want to gift him coins, and each must gift the same number.
3. At least `L` coins from the gifts must be new to Ivan's collection.
4. The output should be the minimum number of coins each friend can gift or `-1` if it's not possible to meet all conditions.

**Program Logic:**
- The program first calculates `min_x`, which is the minimum number of coins each friend needs to give in order to meet the requirement of having at least `L` new coins. This is done with the formula: `min_x = (L + M - 1) // M`, which effectively calculates the ceiling of `L/M`.
- Then it checks if `M * min_x` (total gifts) is less than or equal to the number of different coins available after accounting for the coins Ivan already has, i.e., `N - K`.

**Potential Edge Case Analysis:**
1. **Insufficient Different Coins for All Friends:**
    - If `M > N` (number of friends is greater than the available types of coins), the program will correctly output `-1`, as not every friend can give a different coin.
  
2. **Maximum Limits:**
    - If `L` is too large, making it impossible to get `L` new coins due to `N-K`, the code will check this condition and respond appropriately.

3. **Coin Distribution:**
    - The calculation of `min_x` could incorrectly evaluate the minimal coins per friend, particularly when `K` is very close to `N`, meaning there are very few new opportunities available.
  
4. **Zero or Negative Values:**
    - According to the problem constraints, these scenarios should not occur, so the code does not handle cases where `L`, `M`, or `N` could potentially lead to zero or negative differences. However, as per the assumption, all inputs must be valid.

### Conclusion

The key observation here is that the program does accurately implement the conditions described, calculating the minimum number of coins needed for the friends while correctly returning `-1` when it is impossible to meet the gifting requirements. 

For example:
- For inputs `20 15 2 3`, it calculates `min_x = 1`, which works since `15 * 1 = 15`, and `15 <= 20 - 2 = 18` is valid.
- For inputs `10 11 2 4`, it checks and correctly concludes `-1`, as `11 > 10`, meaning friends can't present different coins.

There is no evident case where the code fails under the given conditions and constraints. Thus, based on this analysis:

Correctness: **True**