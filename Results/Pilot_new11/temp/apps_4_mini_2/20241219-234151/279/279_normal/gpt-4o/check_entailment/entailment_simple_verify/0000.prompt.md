
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.

Pavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.

Unfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.

There is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k ≥ 2n), so that after k seconds each skewer visits each of the 2n placements.

It can be shown that some suitable pair of permutation p and sequence b exists for any n.


-----Input-----

The first line contain the integer n (1 ≤ n ≤ 2·10^5) — the number of skewers.

The second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) — the permutation, according to which Pavel wants to move the skewers.

The third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.


-----Output-----

Print single integer — the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.


-----Examples-----
Input
4
4 3 2 1
0 1 1 1

Output
2

Input
3
2 3 1
0 0 0

Output
1



-----Note-----

In the first example Pavel can change the permutation to 4, 3, 1, 2.

In the second example Pavel can change any element of b to 1.
Program:
```
func_1()

def func_1():
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    p = list(map(int, data[1:n + 1]))
    b = list(map(int, data[n + 1:2 * n + 1]))
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            x = i
            while not visited[x]:
                visited[x] = True
                cycle.append(x)
                x = p[x] - 1
            cycles.append(cycle)
    no_reverse_components = sum((all((b[x] == 0 for x in cycle)) for cycle in cycles))
    if len(cycles) == 1:
        print(0)
    else:
        print(no_reverse_components if no_reverse_components > 0 else 1)


```
Original Assessment: To evaluate the correctness of the provided program against the problem description, we need to understand the logic in the code and ascertain whether it comprehensively adheres to the requirements stated.

The program is designed to compute the minimum number of changes necessary in a permutation `p` and a binary sequence `b` so that after `k` seconds (where `k ≥ 2n`), every skewer has visited all `2n` positions as required.

### Key Points:

1. The function reads inputs for `n`, `p`, and `b`.
2. It initializes a `visited` list to keep track of which positions have been visited during the cycle detection.
3. It finds cycles in the permutation `p`.
4. For each cycle, if all elements in `b` for that cycle are `0`, it counts it as a component that cannot be reversed (i.e., must be changed).
5. Finally, the function handles two specific scenarios:
   - If there is only one cycle, it prints `0` as no changes are necessary.
   - Otherwise, it prints either the count of no-reverse components or `1` based on certain conditions.

### Potential Case for Failure:

A scenario where the program does not seem to work correctly is when there are multiple cycles but each has at least one `1` in `b`, which means reversals can occur freely. The program might end up returning an incorrect number due to how it determines `no_reverse_components` without accounting for cycles where reversals are possible (i.e., where at least one element of `b` in that cycle is `1`).

#### Example Case:
Consider:
- n = 4
- p = [2, 1, 4, 3]
- b = [1, 0, 1, 0]

Here:
- The cycles would be `[(0, 1), (2, 3)]`.
- `b[0]` and `b[2]` are 1s, which allow reversals in their respective cycles, but the program does not identify that the cycles can work with the current configuration since it only counts cycles without reversals and does not check if some cycles can work with existing `1`s.

Thus the value returned in this case would not reflect the actual required minimum changes correctly and would likely undercount the needed changes.

### Conclusion:
Given the reasoning above leads to a scenario where the program could fail to meet the problem requirements, I conclude that the program has inaccuracies.

Correctness: **False**.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
func_1()

#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 2 * 10^5, p is a list of integers representing a valid permutation of the numbers 1 to n, and b is a list of integers consisting of zeros and ones with length n.
def func_1():
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    p = list(map(int, data[1:n + 1]))
    b = list(map(int, data[n + 1:2 * n + 1]))
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            x = i
            while not visited[x]:
                visited[x] = True
                cycle.append(x)
                x = p[x] - 1
            cycles.append(cycle)
        
    #State of the program after the  for loop has been executed: `visited` is a list of n True values, `cycles` contains all unique cycles detected in the permutation defined by `p`, `n` remains unchanged as a positive integer.
    no_reverse_components = sum(all(b[x] == 0 for x in cycle) for cycle in cycles)
    if (len(cycles) == 1) :
        print(0)
    else :
        print(no_reverse_components if no_reverse_components > 0 else 1)
    #State of the program after the if-else block has been executed: *`visited` is a list of n True values, `cycles` contains all unique cycles detected in the permutation defined by `p`, `n` remains unchanged as a positive integer, and `no_reverse_components` is the sum of boolean conditions for all cycles in `cycles`. If `len(cycles)` is equal to 1, the value 0 has been printed. Otherwise, if `no_reverse_components` is greater than 0, the printed value is `no_reverse_components`.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
