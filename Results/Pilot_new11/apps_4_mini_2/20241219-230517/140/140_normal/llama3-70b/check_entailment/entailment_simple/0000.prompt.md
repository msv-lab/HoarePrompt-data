
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given a directed graph consisting of n vertices and m edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.

Can you make this graph acyclic by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).


-----Input-----

The first line contains two integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ min(n(n - 1), 100000)) — the number of vertices and the number of edges, respectively.

Then m lines follow. Each line contains two integers u and v denoting a directed edge going from vertex u to vertex v (1 ≤ u, v ≤ n, u ≠ v). Each ordered pair (u, v) is listed at most once (there is at most one directed edge from u to v).


-----Output-----

If it is possible to make this graph acyclic by removing at most one edge, print YES. Otherwise, print NO.


-----Examples-----
Input
3 4
1 2
2 3
3 2
3 1

Output
YES

Input
5 6
1 2
2 3
3 2
3 1
2 1
4 5

Output
NO



-----Note-----

In the first example you can remove edge $2 \rightarrow 3$, and the graph becomes acyclic.

In the second example you have to remove at least two edges (for example, $2 \rightarrow 1$ and $2 \rightarrow 3$) in order to make the graph acyclic.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
(n, m) = map(int, input().split())
graph = [[] for _ in range(n + 1)]
for _ in range(m):
    (u, v) = map(int, input().split())
    graph[u].append(v)
visited = [False] * (n + 1)
rec_stack = [False] * (n + 1)
has_cycle = False
for node in range(1, n + 1):
    if not visited[node]:
        if func_1(node, graph, visited, rec_stack):
            has_cycle = True
            break
if has_cycle:
    print('NO')
else:
    print('YES')

#State of the program right berfore the function call: node is an integer representing the current vertex, graph is a list of tuples representing the directed edges, visited is a set of integers containing the visited vertices, and rec_stack is a set of integers used to track the recursion stack of vertices.
def func_1(node, graph, visited, rec_stack):
    visited[node] = True
    rec_stack[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            if func_1(neighbor, graph, visited, rec_stack):
                return True
        elif rec_stack[neighbor]:
            return True
        
    #State of the program after the  for loop has been executed: `node` is an integer representing a valid index for `graph`, `visited` is a set of integers including all neighbors of `node` that were visited during the loop, `rec_stack` records whether any neighbors of `node` are currently in the recursion stack, and the loop concludes with no unvisited neighbors left in the graph for `node` or a cycle has been detected.
    rec_stack[node] = False
    return False
    #The program returns False, indicating that node has not been identified as part of a cycle in the graph since rec_stack[node] is False.

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
