
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Wilbur is playing with a set of n points on the coordinate plane. All points have non-negative integer coordinates. Moreover, if some point (x, y) belongs to the set, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y also belong to this set.

Now Wilbur wants to number the points in the set he has, that is assign them distinct integer numbers from 1 to n. In order to make the numbering aesthetically pleasing, Wilbur imposes the condition that if some point (x, y) gets number i, then all (x',y') from the set, such that x' ≥ x and y' ≥ y must be assigned a number not less than i. For example, for a set of four points (0, 0), (0, 1), (1, 0) and (1, 1), there are two aesthetically pleasing numberings. One is 1, 2, 3, 4 and another one is 1, 3, 2, 4.

Wilbur's friend comes along and challenges Wilbur. For any point he defines it's special value as s(x, y) = y - x. Now he gives Wilbur some w1, w2,..., wn, and asks him to find an aesthetically pleasing numbering of the points in the set, such that the point that gets number i has it's special value equal to wi, that is s(xi, yi) = yi - xi = wi.

Now Wilbur asks you to help him with this challenge.

Input

The first line of the input consists of a single integer n (1 ≤ n ≤ 100 000) — the number of points in the set Wilbur is playing with.

Next follow n lines with points descriptions. Each line contains two integers x and y (0 ≤ x, y ≤ 100 000), that give one point in Wilbur's set. It's guaranteed that all points are distinct. Also, it is guaranteed that if some point (x, y) is present in the input, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y, are also present in the input.

The last line of the input contains n integers. The i-th of them is wi ( - 100 000 ≤ wi ≤ 100 000) — the required special value of the point that gets number i in any aesthetically pleasing numbering.

Output

If there exists an aesthetically pleasant numbering of points in the set, such that s(xi, yi) = yi - xi = wi, then print "YES" on the first line of the output. Otherwise, print "NO".

If a solution exists, proceed output with n lines. On the i-th of these lines print the point of the set that gets number i. If there are multiple solutions, print any of them.

Examples

Input

5
2 0
0 0
1 0
1 1
0 1
0 -1 -2 1 0


Output

YES
0 0
1 0
2 0
0 1
1 1


Input

3
1 0
0 0
2 0
0 1 2


Output

NO

Note

In the first sample, point (2, 0) gets number 3, point (0, 0) gets number one, point (1, 0) gets number 2, point (1, 1) gets number 5 and point (0, 1) gets number 4. One can easily check that this numbering is aesthetically pleasing and yi - xi = wi.

In the second sample, the special values of the points in the set are 0,  - 1, and  - 2 while the sequence that the friend gives to Wilbur is 0, 1, 2. Therefore, the answer does not exist.
Program:
```
from sys import stdin
from collections import *

rints = lambda : [int(x) for x in stdin.readline().split()]
(n, labels) = (int(input()), [[0 for _ in range(1000)] for _ in range(1000)])
(a, w) = ([rints() for _ in range(n)], rints())
func_1()

def func_1():
    (mem, mem2, out) = (Counter(w), defaultdict(list), [])
    for (x, y) in a:
        mem2[y - x].append([x, y])
    for (i, j) in mem.items():
        if len(mem2[i]) != j:
            print('NO')
            exit()
        mem2[i].sort(reverse=True)
    for i in range(n):
        (x, y) = mem2[w[i]][-1]
        labels[x][y] = i + 1
        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:
            print('NO')
            exit()
        out.append(' '.join(map(str, mem2[w[i]].pop())))
    print('YES')
    print('\n'.join(out))


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not handle all potential cases correctly. Specifically, the program does not ensure that the aesthetic condition is satisfied for all points. 

Consider the following counterexample:

Input:
```
4
1 0
0 0
2 0
0 1
1 0 -1 1
```

Expected output:
```
YES
0 0
1 0
2 0
0 1
```

However, the program fails to produce the correct output. Let's analyze why:

1. The points are processed and sorted by their special value \( y - x \).
2. For \( w = [1, 0, -1, 1] \):
   - Point (1, 0) with \( w[0] = 1 \) should get number 1.
   - Point (0, 0) with \( w[1] = 0 \) should get number 2.
   - Point (2, 0) with \( w[2] = -1 \) should get number 3.
   - Point (0, 1) with \( w[3] = 1 \) should get number 4.

But when the program tries to assign numbers, it does not correctly check the aesthetic condition for all points. Specifically, the program does not ensure that all points (x', y') with \( x' \geq x \) and \( y' \geq y \) get numbers not less than the assigned number. 

For instance, after assigning:
- (0, 0) gets number 2,
- (1, 0) gets number 1,
- (2, 0) gets number 3,
- (0, 1) gets number 4,

the program should verify that all points (x', y') with \( x' \geq x \) and \( y' \geq y \) have numbers not less than the assigned number. However, the program does not perform this verification step, leading to potential violations of the aesthetic condition.

Therefore, the program does not correctly implement the requirement and thus is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin
from collections import *

rints = lambda : [int(x) for x in stdin.readline().split()]
(n, labels) = (int(input()), [[0 for _ in range(1000)] for _ in range(1000)])
(a, w) = ([rints() for _ in range(n)], rints())
func_1()

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100 000. The input consists of n lines, where each line contains two integers x and y such that 0 ≤ x, y ≤ 100 000, representing points in the set. It is guaranteed that all points are distinct and if some point (x, y) is present, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y, are also present. The last line of the input contains n integers wi such that -100 000 ≤ wi ≤ 100 000, representing the required special values for the points.
def func_1():
    mem, mem2, out = Counter(w), defaultdict(list), []
    for (x, y) in a:
        mem2[y - x].append([x, y])
        
    #State of the program after the  for loop has been executed: `total` is an integer such that \(1 \leq n \leq 100,000\), `mem` is a Counter object counting the occurrences of elements in the list `w`, `mem2` is a defaultdict of lists where for every pair \((x, y)\) in `a`, \([x, y]\) is appended to `mem2[y - x]` exactly once, `out` is an empty list, `a` is a non-empty list containing at least one pair \((x, y)\)
    for (i, j) in mem.items():
        if len(mem2[i]) != j:
            print('NO')
            exit()
        
        mem2[i].sort(reverse=True)
        
    #State of the program after the  for loop has been executed: `total` is an integer such that \(1 \leq total \leq 100,000\), `mem` must contain at least one key-value pair, `mem2` is a defaultdict of lists where for every key `i` in `mem`, `mem2[i]` is sorted in descending order, `out` is an empty list, `a` is a non-empty list containing at least one pair \((x, y)\).
    for i in range(n):
        x, y = mem2[w[i]][-1]
        
        labels[x][y] = i + 1
        
        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:
            print('NO')
            exit()
        
        out.append(' '.join(map(str, mem2[w[i]].pop())))
        
    #State of the program after the  for loop has been executed: `out` is a list of string representations of elements removed from `mem2[w[i]]` for each iteration, `mem2[w[i]]` is empty, `labels[x][y]` is populated based on the removed elements, and if the loop completes without exiting, no condition `labels[x + 1][y] < labels[x][y]` or `labels[x][y + 1] < labels[x][y]` is violated.
    print('YES')
    print('\n'.join(out))


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
