
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You have given tree consist of n vertices. Select a vertex as root vertex that satisfies the condition below.

  * For all vertices v_{1} and v_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then degree(v_{1}) = degree(v_{2}), where degree means the number of vertices connected to that vertex, and distance means the number of edges between two vertices. 



Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^{5}) — the number of vertices.

Each of the next n-1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i} < u_{i} ≤ n) — it means there is an edge exist between v_{i} and u_{i}. It is guaranteed that the graph forms tree.

Output

If there is such root vertex exists, print any of them. Otherwise, print -1.

Examples

Input


7
1 2
2 3
3 4
4 5
3 6
6 7


Output


3


Input


6
1 3
2 3
3 4
4 5
4 6


Output


-1

Note

This is the picture for the first example. 1, 5, 7 also can be a valid answer.

<image>

This is the picture for the second example. You can see that it's impossible to find such root vertex.

<image>
Program:
```
from collections import*

def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        (u, v) = map(int, raw_input().split())
        e[u].append(v)
        e[v].append(u)
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(cur)
        exit()
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(end)
        exit()
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(center)
        exit()
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(top)
        exit()
    print(-1)


```
Original Assessment: Correctness: **False**.

Explanation: The provided program attempts to find a root vertex in a tree that satisfies the given condition. However, there are issues with the logic and handling of the tree structure, which may lead to incorrect results.

One issue is in the way the `deg` array is being used to check the degrees of vertices at different distances from the current root candidate. The logic seems overly complex and might not handle all cases correctly. Specifically, the program does not thoroughly check all possible candidates for the root vertex and might miss valid solutions.

To illustrate this, consider the following input:

```
7
1 2
2 3
3 4
4 5
3 6
6 7
```

The expected output is `3`, as explained in the problem statement. However, the provided code does not correctly identify `3` as a valid root vertex. Instead, it might incorrectly conclude that no valid root vertex exists, leading to an output of `-1`.

A simpler and more robust approach would be to use a centroid decomposition or a similar method to ensure that all potential root candidates are checked correctly. The current implementation may fail in cases where the tree structure is more complex, leading to incorrect results.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from collections import*

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The following n-1 lines each contain two integers v_i and u_i such that 1 ≤ v_i < u_i ≤ n, representing the edges of the tree.
def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u, v = map(int, raw_input().split())
        
        e[u].append(v)
        
        e[v].append(u)
        
    #State of the program after the  for loop has been executed: `i` is `n - 1`, `e` is a list of \(n + 1\) sublists where each sublist at index `u` contains all `v` such that there is a bidirectional edge between `u` and `v`, `n` is the original input value, and it must satisfy \(1 \leq n \leq 10^5\).
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `i` is 0, `q` is empty, `cur` is the last node processed, `e` is a list of \(n + 1\) sublists representing the adjacency list of the graph, `n` is the original input value, `dep` is a list of length \(n + 1\) where each element is set to the distance from node `1` to that node, and `to` is the last node that was added to the deque `q` if it exists.
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
        
    #State of the program after the loop has been executed: `q` is an empty deque, `end` is the last node added to `q` (initially `cur`), `dep` is a list of length \(n + 1\) where each element represents the shortest distance from the starting node to the corresponding node, `pred` is a list of length \(n + 1\) where each element represents the predecessor of the corresponding node in the shortest path tree, `cur` is the last node that was processed, `i` is `n`, and `e` remains a list of \(n + 1\) sublists representing the adjacency list of the graph.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n + 1`, `bad` is True if there exists any index `j` from 1 to `n` such that `deg[dep[j]]` is not equal to the length of `e[j]`, otherwise `bad` remains `False`, `deg[dep[i]]` is updated for each `i` from 1 to `n` if necessary, `i` is the only variable that changes with each iteration, and `end` remains the last node added to `q`, `dep` remains a list of length \(n + 1\) representing the shortest distances, `pred` remains a list of length \(n + 1\) representing the predecessors, `cur` remains the last node processed, `e` remains a list of \(n + 1\) sublists representing the adjacency list of the graph, `deg` remains a list of length \(n + 1\) where each element is updated if necessary, and `bad` remains `True` if any inconsistency is found or `False` otherwise.
    if (not bad) :
        print(cur)
        exit()
    #State of the program after the if block has been executed: *`i` is `n + 1`, `bad` remains `False`, `deg[dep[i]]` is updated for each `i` from 1 to `n` if necessary, `cur` is printed with its current value, `end` remains the last node added to `q`, `dep` remains a list of length \(n + 1\) representing the shortest distances, `pred` remains a list of length \(n + 1\) representing the predecessors, `cur` remains the last node processed, `e` remains a list of \(n + 1\) sublists representing the adjacency list of the graph, `deg` remains a list of length \(n + 1\) where each element is updated if necessary, and `bad` remains `False` since the condition `(not bad)` is true. The program exits immediately after this state.
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
        
    #State of the program after the  for loop has been executed: `i` is the final value of `i` after the loop, which is `dep[end] // 2`, `dep[end]` must be at least `2 * i + 1`, `center` is the node that is `dep[end] // 2` steps back from the initial `center` in the list `pred`.
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `dep[end]` is the shortest distance from `center` to `end`, `i` is the total number of iterations the loop has executed, `center` is the node that is `dep[end] // 2` steps back from the initial `center` in the list `pred`, `q` is an empty deque, `cur` is not defined since the loop has finished, and for every node `to` in `e[cur]` during the loop, `dep[to]` is set to `dep[cur] + 1` for each `to` such that `dep[to]` was initially `-1`.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `dep[end]` is the shortest distance from `center` to `end`, `i` is `n`, `n` is a positive integer, `center` is the node that is `dep[end] // 2` steps back from the initial `center` in the list `pred`, `q` is an empty deque, `cur` is not defined, `deg` is a list of length `n + 1` with all elements initialized to `-1`. If `deg[dep[i]] == -1`, then `deg[dep[i]]` is set to `len(e[i])` for each iteration `i` from `1` to `n`. Otherwise, `bad` is set to `True` after the loop terminates.
    if (not bad) :
        print(end)
        exit()
    #State of the program after the if block has been executed: *`dep[end]` is the shortest distance from `center` to `end`, `i` is `n`, `n` is a positive integer, `center` is the node that is `dep[end] // 2` steps back from the initial `center` in the list `pred`, `q` is an empty deque, `cur` is not defined, `deg` is a list of length `n + 1` with all elements initialized to `-1`, and the value of `end` is printed.
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
        
    #State of the program after the loop has been executed: `dep` is a list of length `n + 1` where `dep[center]` is the maximum depth found during the traversal and all other elements are `-1`. `i` is `n`. `cur` is the farthest node from `center` that has been processed. `q` is an empty deque, as the loop exits when there are no more nodes to process. `top` is the node that was most recently updated and set as the new top node during the loop execution. `deg` is a list of length `n + 1` where each element is the degree (number of edges) of the corresponding node in the graph represented by `e`.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n+1`, `deg[dep[i-1]]` is the length of `e[i-1]` for all `i` from `1` to `n` or not equal to `-1`, `bad` is `True` if any `deg[dep[i]]` is not equal to the length of `e[i]` for any `i` from `1` to `n`, otherwise `bad` remains `False`.
    if (not bad) :
        print(center)
        exit()
    #State of the program after the if block has been executed: *`i` is `n+1`, `deg[dep[i-1]]` is the length of `e[i-1]` for all `i` from `1` to `n` or not equal to `-1`, `bad` remains `False` if any `deg[dep[i]]` is not equal to the length of `e[i]` for any `i` from `1` to `n`, and `center` retains its original value. The program has exited.
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `q` is empty, `cur` is the last node processed, `dep` is a dictionary where each key is a node and its value is the depth level from the initial node in `q`, and `dep[node]` for each node in the graph is set to the correct depth level based on the path from the initial node in `q`.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n+1`, `n` is a positive integer, `bad` is `True` if there exists any `j` (where `1 ≤ j ≤ n`) such that `deg[dep[j]]` is not equal to `len(e[j])`, otherwise `bad` is `False`.
    if (not bad) :
        print(top)
        exit()
    #State of the program after the if block has been executed: *`i` is `n+1`, `n` is a positive integer, `bad` is `False` if there exists any `j` (where `1 ≤ j ≤ n`) such that `deg[dep[j]]` is not equal to `len(e[j])`, otherwise `bad` remains `False`.
    print(-1)


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
