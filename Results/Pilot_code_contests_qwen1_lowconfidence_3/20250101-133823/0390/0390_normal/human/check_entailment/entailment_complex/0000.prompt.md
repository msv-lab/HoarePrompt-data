
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There is a river of width n. The left bank of the river is cell 0 and the right bank is cell n + 1 (more formally, the river can be represented as a sequence of n + 2 cells numbered from 0 to n + 1). There are also m wooden platforms on a river, the i-th platform has length c_i (so the i-th platform takes c_i consecutive cells of the river). It is guaranteed that the sum of lengths of platforms does not exceed n.

You are standing at 0 and want to reach n+1 somehow. If you are standing at the position x, you can jump to any position in the range [x + 1; x + d]. However you don't really like the water so you can jump only to such cells that belong to some wooden platform. For example, if d=1, you can jump only to the next position (if it belongs to the wooden platform). You can assume that cells 0 and n+1 belong to wooden platforms.

You want to know if it is possible to reach n+1 from 0 if you can move any platform to the left or to the right arbitrary number of times (possibly, zero) as long as they do not intersect each other (but two platforms can touch each other). It also means that you cannot change the relative order of platforms.

Note that you should move platforms until you start jumping (in other words, you first move the platforms and then start jumping).

For example, if n=7, m=3, d=2 and c = [1, 2, 1], then one of the ways to reach 8 from 0 is follow:

<image> The first example: n=7.

Input

The first line of the input contains three integers n, m and d (1 ≤ n, m, d ≤ 1000, m ≤ n) — the width of the river, the number of platforms and the maximum distance of your jump, correspondingly.

The second line of the input contains m integers c_1, c_2, ..., c_m (1 ≤ c_i ≤ n, ∑_{i=1}^{m} c_i ≤ n), where c_i is the length of the i-th platform.

Output

If it is impossible to reach n+1 from 0, print NO in the first line. Otherwise, print YES in the first line and the array a of length n in the second line — the sequence of river cells (excluding cell 0 and cell n + 1).

If the cell i does not belong to any platform, a_i should be 0. Otherwise, it should be equal to the index of the platform (1-indexed, platforms are numbered from 1 to m in order of input) to which the cell i belongs.

Note that all a_i equal to 1 should form a contiguous subsegment of the array a of length c_1, all a_i equal to 2 should form a contiguous subsegment of the array a of length c_2, ..., all a_i equal to m should form a contiguous subsegment of the array a of length c_m. The leftmost position of 2 in a should be greater than the rightmost position of 1, the leftmost position of 3 in a should be greater than the rightmost position of 2, ..., the leftmost position of m in a should be greater than the rightmost position of m-1.

See example outputs for better understanding.

Examples

Input


7 3 2
1 2 1


Output


YES
0 1 0 2 2 0 3 


Input


10 1 11
1


Output


YES
0 0 0 0 0 0 0 0 0 1 


Input


10 1 5
2


Output


YES
0 0 0 0 1 1 0 0 0 0 

Note

Consider the first example: the answer is [0, 1, 0, 2, 2, 0, 3]. The sequence of jumps you perform is 0 → 2 → 4 → 5 → 7 → 8.

Consider the second example: it does not matter how to place the platform because you always can jump from 0 to 11.

Consider the third example: the answer is [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]. The sequence of jumps you perform is 0 → 5 → 6 → 11.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from sys import stdin

#State of the program right berfore the function call: n, m, and d are non-negative integers such that 1 ≤ n, m, d ≤ 1000, and m ≤ n. The list c is a list of positive integers where each element c_i satisfies 1 ≤ c_i ≤ n, and the sum of all elements in c is less than or equal to n.
def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    n, m, d = rints()
    c, ans = rints(), [0] * n
    pos, su = [], 0
    for i in range(m - 1, -1, -1):
        pos.append(n + 1 - su - c[i])
        
        su += c[i]
        
    #State of the program after the  for loop has been executed: `c` is a list of length `n` initialized with values from `rints()`, `ans` is a list of `n` zeros, `n` is a non-negative integer between 1 and 1000, `m` is a non-negative integer between 1 and 1000 and less than or equal to `n`, `d` is a non-negative integer between 1 and 1000, `pos` contains the calculated positions based on the sum `su` and the elements in `c`, `su` equals the sum of all elements in `c`.
    pos.append(0)
    pos.reverse()
    for i in range(m):
        if pos[i + 1] - pos[i] <= d:
            for j in range(pos[i + 1], pos[i + 1] + c[i]):
                ans[j - 1] = i + 1
            continue
        
        pos[i + 1] = min(pos[i] + d, n)
        
        for j in range(pos[i + 1], pos[i + 1] + c[i]):
            ans[j - 1] = i + 1
        
        pos[i + 1] += c[i] - 1
        
    #State of the program after the  for loop has been executed: - `pos[i + 1]` is the cumulative sum of `d` and `c[i] - 1` for each `i` up to `m-1`.
    #- `ans[j - 1]` is set to `i + 1` for the range `[pos[i], pos[i + 1])` for each `i` in the range `0` to `m-1`.
    #- `ans` contains values indicating the segment assignment for each index in the range `[0, n-1]`.
    #
    #Thus, the final output state of the loop after all iterations is:
    #
    #Output State:
    if (n + 1 - (pos[-1] + c[-1] - 1) > d) :
        print('NO')
    else :
        print('YES')
        print(' '.join(map(str, ans)))
    #State of the program after the if-else block has been executed: *`pos[i + 1]` is the cumulative sum of `d` and `c[i] - 1` for each `i` up to `m-1`; `ans[j - 1]` is set to `i + 1` for the range `[pos[i], pos[i + 1])` for each `i` in the range `0` to `m-1`; `ans` contains values indicating the segment assignment for each index in the range `[0, n-1]`; if the condition `(n + 1 - (pos[-1] + c[-1] - 1) > d)` is satisfied, 'NO' is printed; otherwise, 'YES' is printed.
#Overall this is what the function does:The function `func()` accepts three non-negative integers `n`, `m`, and `d` (with constraints 1 ≤ n, m, d ≤ 1000 and m ≤ n) and a list `c` of positive integers where each element `c_i` satisfies 1 ≤ `c_i` ≤ n and the sum of all elements in `c` is less than or equal to n. It then processes these inputs to determine whether it is possible to assign segments to indices in a way that satisfies certain conditions. If it is possible, it prints "YES" followed by the segment assignments; otherwise, it prints "NO".

The function first reads `n`, `m`, and `d` from standard input and stores them in variables `n`, `m`, and `d`. It also reads the list `c` and initializes a list `ans` of length `n` filled with zeros. It calculates a list `pos` that represents the positions based on the cumulative sums of elements in `c` and `d`.

Next, it iterates over the elements in `c` and `pos` to assign segments to indices in `ans` while ensuring that the distance between consecutive segments does not exceed `d`. If the distance between two consecutive positions in `pos` is greater than or equal to `d`, it adjusts the positions and assigns segments accordingly.

Finally, it checks if the last position plus the last element in `c` minus one is within the limit defined by `d` and `n`. If the condition is met, it prints "YES" followed by the contents of `ans`; otherwise, it prints "NO".
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
