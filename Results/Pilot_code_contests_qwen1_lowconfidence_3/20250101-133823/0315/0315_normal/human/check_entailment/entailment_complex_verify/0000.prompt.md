
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: There are n piranhas with sizes a_1, a_2, …, a_n in the aquarium. Piranhas are numbered from left to right in order they live in the aquarium.

Scientists of the Berland State University want to find if there is dominant piranha in the aquarium. The piranha is called dominant if it can eat all the other piranhas in the aquarium (except itself, of course). Other piranhas will do nothing while the dominant piranha will eat them.

Because the aquarium is pretty narrow and long, the piranha can eat only one of the adjacent piranhas during one move. Piranha can do as many moves as it needs (or as it can). More precisely: 

  * The piranha i can eat the piranha i-1 if the piranha i-1 exists and a_{i - 1} < a_i. 
  * The piranha i can eat the piranha i+1 if the piranha i+1 exists and a_{i + 1} < a_i. 



When the piranha i eats some piranha, its size increases by one (a_i becomes a_i + 1).

Your task is to find any dominant piranha in the aquarium or determine if there are no such piranhas.

Note that you have to find any (exactly one) dominant piranha, you don't have to find all of them.

For example, if a = [5, 3, 4, 4, 5], then the third piranha can be dominant. Consider the sequence of its moves: 

  * The piranha eats the second piranha and a becomes [5, \underline{5}, 4, 5] (the underlined piranha is our candidate). 
  * The piranha eats the third piranha and a becomes [5, \underline{6}, 5]. 
  * The piranha eats the first piranha and a becomes [\underline{7}, 5]. 
  * The piranha eats the second piranha and a becomes [\underline{8}]. 



You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 2 ⋅ 10^4) — the number of test cases. Then t test cases follow.

The first line of the test case contains one integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the number of piranhas in the aquarium. The second line of the test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9), where a_i is the size of the i-th piranha.

It is guaranteed that the sum of n does not exceed 3 ⋅ 10^5 (∑ n ≤ 3 ⋅ 10^5).

Output

For each test case, print the answer: -1 if there are no dominant piranhas in the aquarium or index of any dominant piranha otherwise. If there are several answers, you can print any.

Example

Input


6
5
5 3 4 4 5
3
1 1 1
5
4 4 3 4 4
5
5 5 4 3 2
3
1 1 2
5
5 4 3 5 5


Output


3
-1
4
3
3
1

Note

The first test case of the example is described in the problem statement.

In the second test case of the example, there are no dominant piranhas in the aquarium.

In the third test case of the example, the fourth piranha can firstly eat the piranha to the left and the aquarium becomes [4, 4, 5, 4], then it can eat any other piranha in the aquarium.
Program:
```
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math
#Function 1:
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        m = max(a)
        f = 0
        for i in range(n):
            if a[i] == m:
                if i - 1 >= 0 and a[i] > a[i - 1] or (i + 1 < n and a[i] > a[i + 1]):
                    func_2(i + 1)
                    f = 1
                    break
        if f == 0:
            func_2(-1)

#Function 2:
def func_2(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly identify dominant piranhas in all cases. Specifically, it fails to check if a piranha can eventually become dominant by eating smaller piranhas step-by-step.

Consider the following input:
```
5
5 3 4 4 5
```

The expected output is `3` because the third piranha can become dominant as described in the example. However, the provided function does not correctly simulate the process of a piranha eating smaller piranhas step-by-step.

Here’s why the current implementation is incorrect:

1. The function `func_1` identifies the maximum size piranha but does not check if this piranha can eventually become dominant by eating smaller piranhas.
2. It checks if the maximum size piranha can directly eat its neighbors, but it does not simulate the process of eating smaller piranhas over multiple steps.

To correctly solve the problem, you need to simulate the process of a piranha eating smaller piranhas until it can no longer grow. Here’s a more appropriate approach:

```python
def is_dominant_piranha(a):
    n = len(a)
    for i in range(n):
        current_max = a[i]
        j = i - 1
        while j >= 0 and a[j] < current_max:
            current_max += 1
            j -= 1
        j = i + 1
        while j < n and a[j] < current_max:
            current_max += 1
            j += 1
        if current_max > max(a):
            return i + 1
    return -1

def dominant_piranha():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(is_dominant_piranha(a))

dominant_piranha()
```

This revised solution correctly simulates the process of a piranha growing by eating smaller piranhas and checks if it can eventually become dominant.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is an integer representing the number of test cases, n is an integer such that 2 <= n <= 3 * 10^5, and a is a list of n integers representing the sizes of the piranhas in the aquarium, where 1 <= a_i <= 10^9. The sum of all n across all test cases does not exceed 3 * 10^5.
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        
        a = list(map(int, input().split()))
        
        m = max(a)
        
        f = 0
        
        for i in range(n):
            if a[i] == m:
                if i - 1 >= 0 and a[i] > a[i - 1] or i + 1 < n and a[i] > a[i + 1]:
                    func_2(i + 1)
                    f = 1
                    break
        
        if f == 0:
            func_2(-1)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `n` is an integer input by the user, `a` is a list of integers input by the user, `m` is the maximum value in the list `a`, `f` is 1 if any element in `a` satisfies the condition `(a[i] == m and (i - 1 >= 0 and a[i] > a[i - 1] or i + 1 < n and a[i] > a[i + 1]))` during the loop, otherwise `f` is 0, and `i` is the index of the first occurrence of `m` that satisfies the condition if `f` is 1, otherwise `i` is `n`.
#Overall this is what the function does:The function processes multiple test cases, each consisting of a number of piranhas (`n`) and their sizes stored in a list (`a`). For each test case, it determines whether any piranha with the maximum size (`m`) is adjacent to another piranha that is smaller than it. If such a piranha is found, the function calls `func_2` with the index of the first such piranha. If no such piranha is found, it calls `func_2` with `-1`. The function does not return anything but performs these checks for all test cases.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. Each test case consists of n (2 ≤ n ≤ 3 ⋅ 10^5) positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) representing the sizes of piranhas in the aquarium. The sum of n across all test cases does not exceed 3 ⋅ 10^5 (∑ n ≤ 3 ⋅ 10^5). The function `func_2` is not related to solving the problem and is likely a utility function for printing, which is not used in the provided code snippet.
def func_2():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `sep` is ' ', `file` is `sys.stdout`, `args` contains all input arguments, `at_start` is `False`, each element in `args` is written to `file` with `sep` separating them except the first element.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is a positive integer, `sep` is ' ', `file` is `sys.stdout`, `args` contains all input arguments, `at_start` is `False`, each element in `args` is written to `file` with `sep` separating them except the first element, `sys.stdout` has written `\n`, and if the `kwargs.pop('flush', False)` evaluates to `True`, the buffer of `sys.stdout` is flushed.
#Overall this is what the function does:The function does not accept any parameters and does not return anything. It takes a sequence of arguments (`args`) and writes them to `sys.stdout` separated by a space (`' '`), except for the first element. If the `kwargs` contain an `end` key, it appends its value (defaulting to `\n`) to the output. If the `kwargs` contain a `flush` key set to `True`, it flushes the output buffer of `sys.stdout`. This function can be used to print a list or tuple of values to the standard output with specific formatting options. However, since the function is not called within the provided code snippet, its primary purpose is to demonstrate or test the formatting capabilities for printing.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
