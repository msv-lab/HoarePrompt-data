
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: A tree is an undirected connected graph without cycles.

Let's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).

<image> For this rooted tree the array p is [2, 3, 3, 2].

Given a sequence p1, p2, ..., pn, one is able to restore a tree:

  1. There must be exactly one index r that pr = r. A vertex r is a root of the tree. 
  2. For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. 



A sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.

You are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.

Input

The first line of the input contains an integer n (2 ≤ n ≤ 200 000) — the number of vertices in the tree.

The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n).

Output

In the first line print the minimum number of elements to change, in order to get a valid sequence.

In the second line, print any valid sequence possible to get from (a1, a2, ..., an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.

Examples

Input

4
2 3 3 4


Output

1
2 3 4 4 


Input

5
3 2 2 5 3


Output

0
3 2 2 5 3 


Input

8
2 3 5 4 1 6 6 7


Output

2
2 3 7 8 1 6 6 7

Note

In the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red.

<image>

In the second sample, the given sequence is already valid.
Program:
```
import itertools
import sys

class Solution(object):

    def find(self, ident, fa):
        if fa[ident] != ident:
            fa[ident] = self.find(fa[ident], fa)
        return fa[ident]

    def merge(self, ident_child, ident_father, fa):
        fa_child = fa[ident_child]
        fa_father = fa[ident_father]
        fa[fa_child] = fa_father

    def solve(self):
        n = self.n
        p = self.p
        issues = []
        roots = []
        fa = [i for i in xrange(n)]
        for current in xrange(n):
            parent = p[current]
            if parent == current:
                roots.append(current)
                continue
            parent_set_id = self.find(parent, fa)
            if parent_set_id == current:
                issues.append(current)
                continue
            self.merge(current, parent, fa)
        root = None
        changes = 0
        if len(roots) > 0:
            root = roots[0]
            changes = len(roots) + len(issues) - 1
        elif len(roots) == 0:
            root = roots[0] if len(roots) > 0 else issues[0]
            changes = len(roots) + len(issues)
        for ident in itertools.chain(roots, issues):
            p[ident] = root
        return (changes, p)

    def read_data(self):
        self.n = func_1()[0]
        self.p = func_1(delta=-1)

    def print_result(self, result):
        (changes, p) = result
        print(changes)
        for (idx, parent) in enumerate(p):
            sys.stdout.write(str(parent))
            if idx != len(p) - 1:
                sys.stdout.write(' ')
        sys.stdout.write('\n')

    def run(self):
        self.read_data()
        result = self.solve()
        self.print_result(result)
if len(sys.argv) > 1:
    sys.stdin = open(sys.argv[1], 'r')
    print('Redirect stdin to {0}'.format(sys.argv[1]))
Solution().run()

def func_1(delta=0):
    return [int(i) + delta for i in raw_input().split()]


```
Original Assessment: Correctness: **False**

Explanation: The provided solution does not correctly identify the root of the tree. Specifically, the logic for determining the root and calculating the number of changes is flawed. Here's why:

1. **Root Identification**: The solution attempts to find the root by checking if `parent == current`. However, this approach is incomplete. It fails to account for cases where there might be multiple potential roots that satisfy the condition `parent == current`.

2. **Merge Logic**: The merging logic is unnecessary and complicates the solution. The Disjoint Set Union (DSU) or Union-Find data structure is used but not correctly implemented for this problem.

3. **Number of Changes Calculation**: The calculation of the number of changes is based on an incorrect assumption about the root identification. The solution may overestimate the number of changes needed.

To illustrate, consider the following input:
```
4
2 3 3 4
```

The provided solution outputs:
```
1
2 3 4 4
```

This output is incorrect because:
- The root should be chosen such that the number of changes is minimized.
- In this case, choosing `root = 4` results in only one change (`p[3] = 4`), but the solution suggests changing `p[3]` to 4 and keeps `p[1]` as 2, which is not optimal.

A correct approach would be:
1. Identify all potential roots (vertices with `ai = i`).
2. Choose the root that minimizes the number of changes.
3. Ensure the chosen root forms a valid tree by making necessary adjustments.

For the given input, the correct output should be:
```
1
2 3 4 4
```

Since the provided solution does not handle all cases correctly, the correctness is **False**.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function `func_1` accepts a list of integers `delta` and expects user input in the form of a space-separated string of integers. It then processes this input by splitting the string into individual integers, converting them to integers, and adding each integer to the corresponding element in `delta`. The function returns a new list of integers, where each integer is the sum of an input integer and the corresponding element in `delta`. Potential edge cases include handling empty input strings or ensuring that the input string contains the correct number of integers to match the length of `delta`. If the input string does not contain enough integers, the function will use the remaining elements of `delta` with a value of 0 for the missing integers.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
