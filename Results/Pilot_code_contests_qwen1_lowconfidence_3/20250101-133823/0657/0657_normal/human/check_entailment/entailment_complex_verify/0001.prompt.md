
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i ∈ \{1, 2\}) — the values written on the tiles.

Output

Output a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

Examples

Input


5
1 2 1 2 1


Output


1 1 1 2 2


Input


9
1 1 2 1 1 1 2 1 1


Output


1 1 1 2 1 1 1 2 1

Note

The first solution produces the prefix sums 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.
Program:
```
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase
#Function 1:
def func_1(*args, **kwargs):
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return str(input())

#Function 4:
def func_4():
    return map(int, input().strip().split(' '))

#Function 5:
def func_5():
    return list(func_4())

#Function 6:
def func_6(item):
    return item[0]

#Function 7:
def func_7(l):
    return sorted(l, key=getKey)

#Function 8:
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 9:
def func_9(x):
    return x and (not x & x - 1)

#Function 10:
def func_10(n):
    return bin(n).replace('0b', '')

#Function 11:
def func_11(n):
    return [int(i) for i in str(n)]

#Function 12:
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res

#Function 13:
def func_13(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 14:
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    'if two==one:\n        for i in range(n):\n            if i%2==0:\n                s.append(2)\n            else:\n                s.append(1)\n        print(*s)\n        exit()\n        \n    \n    for i in range(n):\n        if a[i]==1:\n            if one !=0:\n                s.append(1)\n                one-=1\n            else:\n                s.append(2)\n                two-=1\n        else:\n            if two!=0:\n                s.append(2)\n                two-=1\n            else:\n                s.append(1)\n                one-=1\n    print(*s)   '
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
    func_1(*s)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not always produce the correct output as required by the problem description. Specifically, the logic in the program does not guarantee that the number of prefix sums that are prime is maximized for all possible inputs.

Let's consider a specific case to illustrate this:

### Example Input:
```
n = 4
l = [1, 2, 1, 2]
```

### Expected Output:
The optimal permutation should be such that the number of prefix sums that are prime is maximized. One possible correct permutation could be `[1, 2, 1, 2]` which gives the prefix sums: `1, 3, 4, 6`. This results in 2 prime numbers (`3` and `3`).

However, the program's current logic does not necessarily produce this optimal permutation. Here is what the program does:

1. It initializes a list `s` with the value `2`.
2. It then iterates through the input list `l` and tries to append either `1` or `2` to the list `s` depending on the parity of the previous sum and the counts of `1`s and `2`s left.

For the input `[1, 2, 1, 2]`, the program will start with `s = [2]`. Then, it will try to append values while ensuring the prefix sums remain prime. However, due to the way the logic is structured, it may not always append the optimal values.

### Issue:
The program does not have a clear strategy to ensure that the prefix sums are always prime and that the number of primes is maximized. For instance, if the input is `[1, 2, 1, 2]`, the program might produce a suboptimal permutation like `[2, 1, 2, 1]`, which gives the prefix sums: `2, 3, 5, 6`. This results in 3 primes (`2, 3, 5`), but the optimal permutation should result in 2 primes.

Therefore, the program does not guarantee the maximum number of prime prefix sums for all inputs, making it incorrect according to the problem description.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase

"""
Author    : raj1307 - Raj Singh
Institute : Jalpaiguri Government Engineering College
Date      : 29.04.19
"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from builtins import str as __str__
    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            (b, ptr) = (os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell())
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
            self.newlines += b.count(b'\n') + (not b)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            (self._buffer.truncate(0), self._buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
if __name__ == '__main__':
    func_14()

#Function 1:
#State of the program right berfore the function call: tiles is a list of integers where each integer is either 1 or 2, and the length of the list is between 1 and 200,000 inclusive.
def func_1():
    sep, file = kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `tiles` is a list of integers where each integer is either 1 or 2, and the length of the list is between 1 and 200,000 inclusive; `sep` is either a value from `kwargs` or `b' '`, `at_start` is `False`; `file` contains the concatenation of the string representations of all elements in `tiles` separated by `sep`.
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: `tiles` is a list of integers where each integer is either 1 or 2, and the length of the list is between 1 and 200,000 inclusive; `sep` is either a value from `kwargs` or `b' '`, `at_start` is `False`; `file` contains the concatenation of the string representations of all elements in `tiles` separated by `sep`; `kwargs` no longer contains the key `'flush'` or the value of `'flush'` is `False`; the write buffer for `file` is flushed if `kwargs` contained the key `'flush'` with the value `True`.
#Overall this is what the function does:The function `func_1` takes a list `tiles` as input, where each element in the list is either 1 or 2, and the length of the list is between 1 and 200,000 inclusive. It then writes the string representation of each element in `tiles` to a specified output stream (`file`), separated by a separator string (`sep`). The function also handles optional keyword arguments such as `end` (to append to the end of the output), and `flush` (to flush the write buffer). If the `flush` argument is `True`, the write buffer is flushed after the output is written. The function does not modify the original `tiles` list but constructs a new string representation of the list with separators and appends it to the `file`. If no `file` is provided, it defaults to `sys.stdout`.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function signature are provided, but `input()` is used to read the first integer `n` (the number of tiles), followed by a line of `n` space-separated integers representing the values on the tiles (each either 1 or 2).
def func_2():
    return int(input())
    #The program returns the first integer input by the user, which is the number of tiles, followed by a line of n space-separated integers representing the values on the tiles (each either 1 or 2)
#Overall this is what the function does:The function reads an integer `n` representing the number of tiles, followed by a line of `n` space-separated integers where each integer is either 1 or 2 representing the values on the tiles. The function then returns these values as a list of integers. There are no additional operations performed on these values within the function. Potential edge cases include when `n` is less than 1 or when the input does not consist of exactly `n` integers each being 1 or 2. If the input does not meet these requirements, the function's behavior is undefined.

#Function 3:
#State of the program right berfore the function call: None of the variables in the provided function are relevant to the problem description. The function does not take any parameters and simply reads input from the user, which contradicts the problem's requirement to manipulate a list of number tiles to maximize the number of prime prefix sums.
def func_3():
    return str(input())
    #The program returns a string input by the user
#Overall this is what the function does:The function `func_3` accepts no parameters and prompts the user to input a string. It then returns this string. There are no actions performed on the input string, and no manipulation of any list of number tiles as implied by the initial problem description. This function simply reads user input and returns it.

#Function 4:
#State of the program right berfore the function call: None of the variables in the function `func_4` are provided in the function signature. However, the function reads input from the standard input. The input consists of two lines: the first line contains a single integer `n` (1 ≤ n ≤ 200,000), representing the number of number tiles in the bag, and the second line contains `n` space-separated integers `a_1, a_2, ..., a_n` (each `a_i ∈ \{1, 2\}`), representing the values written on the tiles.
def func_4():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers converted from a line of space-separated inputs, where the input consists of a single integer `n` followed by `n` space-separated integers each being either 1 or 2.
#Overall this is what the function does:The function `func_4` reads two lines of input from the standard input. The first line contains a single integer `n` (1 ≤ n ≤ 200,000), which represents the number of number tiles in the bag. The second line contains `n` space-separated integers, each being either 1 or 2, representing the values written on the tiles. The function then returns a map object containing these integers. This map object can be iterated over to access the sequence of integers read from the input. Potential edge cases include when `n` is exactly 1 or 200,000, or when the input integers are not strictly 1 or 2, although such cases would result in an error due to the conversion to integers. The function does not handle such errors explicitly, so the caller must ensure valid input.

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the following line contains n space-separated integers where each integer is either 1 or 2.
def func_5():
    return list(func_4())
    #The program returns a list generated by func_4(), which processes n space-separated integers where each integer is either 1 or 2
#Overall this is what the function does:The function `func_5()` takes no explicit parameters and returns a list generated by `func_4()`. This list is derived from processing `n` space-separated integers (where `n` is between 1 and 200,000) that are either 1 or 2. There are no explicit input parameters mentioned in the provided code, so the value of `n` and the integers themselves are assumed to be part of the input context before the function call. The function does not modify any external variables; it solely relies on the input integers provided in the form of space-separated values and returns the processed list as output. No edge cases or missing functionalities are indicated within the provided code snippet, suggesting that the function operates correctly under the given constraints.

#Function 6:
#State of the program right berfore the function call: item is a tuple or list containing at least one element, where the first element is of a type that can be compared and sorted.
def func_6(item):
    return item[0]
    #The program returns the first element of the tuple or list 'item', which is of a type that can be compared and sorted
#Overall this is what the function does:The function `func_6` accepts a parameter `item`, which is either a tuple or a list containing at least one element. It returns the first element of `item`. Since the code only contains a single return statement, the function will always return the first element of `item`, regardless of whether `item` is a tuple or a list. This behavior is consistent with both the annotated code and the return postconditions. There are no missing functionalities or edge cases mentioned in the provided code, and the function does not perform any additional operations beyond returning the first element of `item`.

#Function 7:
#State of the program right berfore the function call: l is a list of integers where each integer is either 1 or 2.
def func_7(l):
    return sorted(l, key=getKey)
    #The program returns a list of integers sorted in ascending order, where each integer is either 1 or 2
#Overall this is what the function does:The function `func_7` accepts a list `l` of integers, where each integer is either 1 or 2. It then sorts the list in ascending order using the `sorted` function with a custom key (`getKey`), which ensures the sorting is based on the natural order of integers. The function returns a new list of integers that is sorted in ascending order, where each integer remains either 1 or 2. This means that the original list `l` is not modified; instead, a new sorted list is returned. Potential edge cases include an empty list or a list with only one element, which would both result in the same list being returned. Additionally, if `getKey` is not defined or does not work correctly, the sorting might not behave as expected, although the default sorting behavior of integers should handle the case correctly.

#Function 8:
#State of the program right berfore the function call: n and m are non-negative integers representing the dimensions of a 2D list, and num is an integer either 1 or 2.
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns, where each element in the list is the integer 'num'
#Overall this is what the function does:The function `func_8` accepts three parameters: `n`, `m`, and `num`. Here, `n` and `m` are non-negative integers representing the dimensions of a 2D list, and `num` is an integer that can be either 1 or 2. After executing, the function returns a 2D list with `n` rows and `m` columns, where each element in the list is the integer `num`. There are no missing functionalities in the provided code, and all potential edge cases are handled by the code itself, as it correctly generates the desired 2D list regardless of the values of `n`, `m`, and `num` (as long as `num` is either 1 or 2).

#Function 9:
#State of the program right berfore the function call: x is a non-negative integer.
def func_9(x):
    return x and not x & x - 1
    #The program returns True if x is 0, otherwise it returns False
#Overall this is what the function does:The function `func_9` accepts a non-negative integer `x` and returns `True` if `x` is 0, otherwise it returns `False`. This function checks whether the given non-negative integer `x` is zero. If `x` is 0, the expression `x and not x & x - 1` evaluates to `True`. For any other non-negative integer value of `x`, the expression evaluates to `False`. There are no missing functionalities or edge cases in the provided code.

#Function 10:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2^{200000}.
def func_10(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of integer `n` without the '0b' prefix
#Overall this is what the function does:The function `func_10` accepts an integer `n` such that \(1 \leq n \leq 2^{200000}\) and returns its binary representation as a string without the '0b' prefix. The function correctly converts the integer to binary and removes the '0b' prefix. There are no apparent edge cases or missing functionality in the provided code, as it accurately performs the required operation for all valid inputs within the specified range.

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000 and the binary representation of n consists only of the digits 1 and 2.
def func_11(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers, where each integer is either 1 or 2, representing the binary digits of the original integer n
#Overall this is what the function does:The function `func_11` accepts an integer `n` within the range 1 to 200,000, where the binary representation of `n` consists only of the digits 1 and 2. After processing, it returns a list of integers, where each integer is either 1 or 2, representing the binary digits of the original integer `n`. The function correctly handles the conversion of `n` to its binary representation and ensures that only the digits 1 and 2 are present. There are no edge cases mentioned in the annotations or the code itself that need special handling beyond the given constraints.

#Function 12:
#State of the program right berfore the function call: x and y are integers, and p is a prime number greater than 1.
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p1
        
    #State of the program after the loop has been executed: `y` is 0, `res` is 1, and `x` is \( x^{2^k} \mod p \)
    return res
    #The program returns res which is 1
#Overall this is what the function does:The function `func_12` accepts three parameters: `x`, `y`, and `p`, where both `x` and `y` are integers, and `p` is a prime number greater than 1. The function computes \( x^y \mod p \) using a fast exponentiation algorithm. After executing the loop, the function returns the result stored in `res`.

The final state of the program after the function concludes is as follows:
- `res` contains the value of \( x^y \mod p \).
- `y` is set to 0.
- `x` is updated to \( x^{2^k} \mod p \), where \( k \) is the number of iterations the loop performed.

Potential edge cases:
- If `y` is 0, the loop will not execute, and `res` will remain 1 regardless of the values of `x` and `p`.

Missing functionality:
- The annotation states that the program returns `res`, which is 1. However, the actual code updates `res` based on the value of `x` and `y` during the loop. Therefore, the correct return value should be `res` instead of always returning 1.

#Function 13:
#State of the program right berfore the function call: x and y are non-negative integers, and both x and y are either 1 or 2.
def func_13(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x which is the greatest common divisor (GCD) of the original values of x and y, and y is 0
#Overall this is what the function does:The function `func_13` accepts two parameters `x` and `y`, which are non-negative integers and can only be 1 or 2. It computes the greatest common divisor (GCD) of the original values of `x` and `y` using the Euclidean algorithm within a while loop. After the loop completes, the function returns `x` as the GCD and sets `y` to 0. This process works correctly for all valid inputs (i.e., `x` and `y` being 1 or 2), and the final state of the program is that `x` contains the GCD of the original `x` and `y`, and `y` is 0. There are no missing functionalities or edge cases mentioned in the provided code.

#Function 14:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and l is a list of n integers where each integer is either 1 or 2.
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    """if two==one:
        for i in range(n):
            if i%2==0:
                s.append(2)
            else:
                s.append(1)
        print(*s)
        exit()
        
    
    for i in range(n):
        if a[i]==1:
            if one !=0:
                s.append(1)
                one-=1
            else:
                s.append(2)
                two-=1
        else:
            if two!=0:
                s.append(2)
                two-=1
            else:
                s.append(1)
                one-=1
    print(*s)   """
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 200000\), `s` contains a sequence of alternating 1s and 2s, `one` is 0, `two` is 0, and `p` ends with an even number.
    func_1(*s)
#Overall this is what the function does:The function `func_14()` accepts no explicit parameters but relies on values derived from `func_2()` and `func_5()`. It generates a sequence `s` consisting of alternating 1s and 2s based on the counts of 1s and 2s in the list `l`. If the counts of 1s and 2s are equal, it creates a sequence where 1s and 2s alternate starting with 2. Otherwise, it ensures that the sequence starts and ends with the more frequent element, maintaining an alternating pattern. After constructing the sequence `s`, it calls `func_1(*s)`. Potential edge cases include when the list `l` is empty or when the counts of 1s and 2s are equal but the list length is odd. In these cases, the function ensures that the sequence `s` is correctly formed according to the given rules.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
