
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i ∈ \{1, 2\}) — the values written on the tiles.

Output

Output a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

Examples

Input


5
1 2 1 2 1


Output


1 1 1 2 2


Input


9
1 1 2 1 1 1 2 1 1


Output


1 1 1 2 1 1 1 2 1

Note

The first solution produces the prefix sums 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.
Functions with output description for each function:
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase

"""
Author    : raj1307 - Raj Singh
Institute : Jalpaiguri Government Engineering College
Date      : 29.04.19
"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from builtins import str as __str__
    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            (b, ptr) = (os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell())
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
            self.newlines += b.count(b'\n') + (not b)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            (self._buffer.truncate(0), self._buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
if __name__ == '__main__':
    func_14()

Function number 1 :
 Code:
 '''
def func_1(*args, **kwargs):
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function1:  The function `func_1` takes a list `tiles` as input, where each element in the list is either 1 or 2, and the length of the list is between 1 and 200,000 inclusive. It then writes the string representation of each element in `tiles` to a specified output stream (`file`), separated by a separator string (`sep`). The function also handles optional keyword arguments such as `end` (to append to the end of the output), and `flush` (to flush the write buffer). If the `flush` argument is `True`, the write buffer is flushed after the output is written. The function does not modify the original `tiles` list but constructs a new string representation of the list with separators and appends it to the `file`. If no `file` is provided, it defaults to `sys.stdout`.
Function number 2 :
 Code:
 '''
def func_2():
    return int(input())
''' 

 Output hints for function2:  The function reads an integer `n` representing the number of tiles, followed by a line of `n` space-separated integers where each integer is either 1 or 2 representing the values on the tiles. The function then returns these values as a list of integers. There are no additional operations performed on these values within the function. Potential edge cases include when `n` is less than 1 or when the input does not consist of exactly `n` integers each being 1 or 2. If the input does not meet these requirements, the function's behavior is undefined.
Function number 3 :
 Code:
 '''
def func_3():
    return str(input())
''' 

 Output hints for function3:  The function `func_3` accepts no parameters and prompts the user to input a string. It then returns this string. There are no actions performed on the input string, and no manipulation of any list of number tiles as implied by the initial problem description. This function simply reads user input and returns it.
Function number 4 :
 Code:
 '''
def func_4():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function4:  The function `func_4` reads two lines of input from the standard input. The first line contains a single integer `n` (1 ≤ n ≤ 200,000), which represents the number of number tiles in the bag. The second line contains `n` space-separated integers, each being either 1 or 2, representing the values written on the tiles. The function then returns a map object containing these integers. This map object can be iterated over to access the sequence of integers read from the input. Potential edge cases include when `n` is exactly 1 or 200,000, or when the input integers are not strictly 1 or 2, although such cases would result in an error due to the conversion to integers. The function does not handle such errors explicitly, so the caller must ensure valid input.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_4())
''' 

 Output hints for function5:  The function `func_5()` takes no explicit parameters and returns a list generated by `func_4()`. This list is derived from processing `n` space-separated integers (where `n` is between 1 and 200,000) that are either 1 or 2. There are no explicit input parameters mentioned in the provided code, so the value of `n` and the integers themselves are assumed to be part of the input context before the function call. The function does not modify any external variables; it solely relies on the input integers provided in the form of space-separated values and returns the processed list as output. No edge cases or missing functionalities are indicated within the provided code snippet, suggesting that the function operates correctly under the given constraints.
Function number 6 :
 Code:
 '''
def func_6(item):
    return item[0]
''' 

 Output hints for function6:  The function `func_6` accepts a parameter `item`, which is either a tuple or a list containing at least one element. It returns the first element of `item`. Since the code only contains a single return statement, the function will always return the first element of `item`, regardless of whether `item` is a tuple or a list. This behavior is consistent with both the annotated code and the return postconditions. There are no missing functionalities or edge cases mentioned in the provided code, and the function does not perform any additional operations beyond returning the first element of `item`.
Function number 7 :
 Code:
 '''
def func_7(l):
    return sorted(l, key=getKey)
''' 

 Output hints for function7:  The function `func_7` accepts a list `l` of integers, where each integer is either 1 or 2. It then sorts the list in ascending order using the `sorted` function with a custom key (`getKey`), which ensures the sorting is based on the natural order of integers. The function returns a new list of integers that is sorted in ascending order, where each integer remains either 1 or 2. This means that the original list `l` is not modified; instead, a new sorted list is returned. Potential edge cases include an empty list or a list with only one element, which would both result in the same list being returned. Additionally, if `getKey` is not defined or does not work correctly, the sorting might not behave as expected, although the default sorting behavior of integers should handle the case correctly.
Function number 8 :
 Code:
 '''
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function8:  The function `func_8` accepts three parameters: `n`, `m`, and `num`. Here, `n` and `m` are non-negative integers representing the dimensions of a 2D list, and `num` is an integer that can be either 1 or 2. After executing, the function returns a 2D list with `n` rows and `m` columns, where each element in the list is the integer `num`. There are no missing functionalities in the provided code, and all potential edge cases are handled by the code itself, as it correctly generates the desired 2D list regardless of the values of `n`, `m`, and `num` (as long as `num` is either 1 or 2).
Function number 9 :
 Code:
 '''
def func_9(x):
    return x and (not x & x - 1)
''' 

 Output hints for function9:  The function `func_9` accepts a non-negative integer `x` and returns `True` if `x` is 0, otherwise it returns `False`. This function checks whether the given non-negative integer `x` is zero. If `x` is 0, the expression `x and not x & x - 1` evaluates to `True`. For any other non-negative integer value of `x`, the expression evaluates to `False`. There are no missing functionalities or edge cases in the provided code.
Function number 10 :
 Code:
 '''
def func_10(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function10:  The function `func_10` accepts an integer `n` such that \(1 \leq n \leq 2^{200000}\) and returns its binary representation as a string without the '0b' prefix. The function correctly converts the integer to binary and removes the '0b' prefix. There are no apparent edge cases or missing functionality in the provided code, as it accurately performs the required operation for all valid inputs within the specified range.
Function number 11 :
 Code:
 '''
def func_11(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function11:  The function `func_11` accepts an integer `n` within the range 1 to 200,000, where the binary representation of `n` consists only of the digits 1 and 2. After processing, it returns a list of integers, where each integer is either 1 or 2, representing the binary digits of the original integer `n`. The function correctly handles the conversion of `n` to its binary representation and ensures that only the digits 1 and 2 are present. There are no edge cases mentioned in the annotations or the code itself that need special handling beyond the given constraints.
Function number 12 :
 Code:
 '''
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res
''' 

 Output hints for function12:  The function `func_12` accepts three parameters: `x`, `y`, and `p`, where both `x` and `y` are integers, and `p` is a prime number greater than 1. The function computes \( x^y \mod p \) using a fast exponentiation algorithm. After executing the loop, the function returns the result stored in `res`.

The final state of the program after the function concludes is as follows:
- `res` contains the value of \( x^y \mod p \).
- `y` is set to 0.
- `x` is updated to \( x^{2^k} \mod p \), where \( k \) is the number of iterations the loop performed.

Potential edge cases:
- If `y` is 0, the loop will not execute, and `res` will remain 1 regardless of the values of `x` and `p`.

Missing functionality:
- The annotation states that the program returns `res`, which is 1. However, the actual code updates `res` based on the value of `x` and `y` during the loop. Therefore, the correct return value should be `res` instead of always returning 1.
Function number 13 :
 Code:
 '''
def func_13(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function13:  The function `func_13` accepts two parameters `x` and `y`, which are non-negative integers and can only be 1 or 2. It computes the greatest common divisor (GCD) of the original values of `x` and `y` using the Euclidean algorithm within a while loop. After the loop completes, the function returns `x` as the GCD and sets `y` to 0. This process works correctly for all valid inputs (i.e., `x` and `y` being 1 or 2), and the final state of the program is that `x` contains the GCD of the original `x` and `y`, and `y` is 0. There are no missing functionalities or edge cases mentioned in the provided code.
Function number 14 :
 Code:
 '''
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    'if two==one:\n        for i in range(n):\n            if i%2==0:\n                s.append(2)\n            else:\n                s.append(1)\n        print(*s)\n        exit()\n        \n    \n    for i in range(n):\n        if a[i]==1:\n            if one !=0:\n                s.append(1)\n                one-=1\n            else:\n                s.append(2)\n                two-=1\n        else:\n            if two!=0:\n                s.append(2)\n                two-=1\n            else:\n                s.append(1)\n                one-=1\n    print(*s)   '
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
    func_1(*s)
''' 

 Output hints for function14:  The function `func_14()` accepts no explicit parameters but relies on values derived from `func_2()` and `func_5()`. It generates a sequence `s` consisting of alternating 1s and 2s based on the counts of 1s and 2s in the list `l`. If the counts of 1s and 2s are equal, it creates a sequence where 1s and 2s alternate starting with 2. Otherwise, it ensures that the sequence starts and ends with the more frequent element, maintaining an alternating pattern. After constructing the sequence `s`, it calls `func_1(*s)`. Potential edge cases include when the list `l` is empty or when the counts of 1s and 2s are equal but the list length is odd. In these cases, the function ensures that the sequence `s` is correctly formed according to the given rules.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.