
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are many anime that are about "love triangles": Alice loves Bob, and Charlie loves Bob as well, but Alice hates Charlie. You are thinking about an anime which has n characters. The characters are labeled from 1 to n. Every pair of two characters can either mutually love each other or mutually hate each other (there is no neutral state).

You hate love triangles (A-B are in love and B-C are in love, but A-C hate each other), and you also hate it when nobody is in love. So, considering any three characters, you will be happy if exactly one pair is in love (A and B love each other, and C hates both A and B), or if all three pairs are in love (A loves B, B loves C, C loves A).

You are given a list of m known relationships in the anime. You know for sure that certain pairs love each other, and certain pairs hate each other. You're wondering how many ways you can fill in the remaining relationships so you are happy with every triangle. Two ways are considered different if two characters are in love in one way but hate each other in the other. Print this count modulo 1 000 000 007.

Input

The first line of input will contain two integers n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).

The next m lines will contain the description of the known relationships. The i-th line will contain three integers ai, bi, ci. If ci is 1, then ai and bi are in love, otherwise, they hate each other (1 ≤ ai, bi ≤ n, ai ≠ bi, <image>).

Each pair of people will be described no more than once.

Output

Print a single integer equal to the number of ways to fill in the remaining pairs so that you are happy with every triangle modulo 1 000 000 007. 

Examples

Input

3 0


Output

4


Input

4 4
1 2 1
2 3 1
3 4 0
4 1 0


Output

1


Input

4 4
1 2 1
2 3 1
3 4 0
4 1 1


Output

0

Note

In the first sample, the four ways are to: 

  * Make everyone love each other 
  * Make 1 and 2 love each other, and 3 hate 1 and 2 (symmetrically, we get 3 ways from this). 



In the second sample, the only possible solution is to make 1 and 3 love each other and 2 and 4 hate each other.
Functions with output description for each function:
maxn = 100005
mod = 1000000007
e = [[] for i in range(maxn)]
vis = [False for i in range(maxn)]
func_2()

Function number 1 :
 Code:
 '''
def func_1(u):
    sz = len(e[u])
    ok = True
    for i in range(sz):
        v = e[u][i][0]
        c = e[u][i][1]
        if vis[v] == False:
            if c == True:
                vis[v] = vis[u]
            else:
                vis[v] = -vis[u]
            ok = func_1(v)
        if c == 1 and vis[v] != vis[u]:
            return False
        if c == 0 and vis[v] != -vis[u]:
            return False
    return ok
''' 

 Output hints for function1:  The function `func_1` accepts an integer `u`, a list of adjacency lists `e`, and a list `vis`. It performs a depth-first search (DFS) traversal of the graph represented by `e`, updating the `vis` list based on the relationship (love or hate) between `u` and each of its neighbors. For each neighbor `v`, if `vis[v]` is not yet set, `vis[v]` is updated to `vis[u]` if `u` and `v` love each other (`c == True`), or to `-vis[u]` if they hate each other (`c == False`). The function recursively calls itself for each neighbor. If at any point the relationships violate the conditions (either loving characters have different signs in `vis` or hating characters have the same sign), the function returns `False`. Otherwise, it returns `ok`, which is the final return value of the recursive calls, ensuring that the `vis` list maintains the required relationship signs for all connected components. The function can only return `True` (or `ok` being `True`) if the entire graph can be consistently labeled according to the given relationships without violating any conditions.
Function number 2 :
 Code:
 '''
def func_2():
    (n, m) = map(int, raw_input().split())
    for i in range(m):
        (u, v, c) = map(int, raw_input().split())
        u -= 1
        v -= 1
        e[u].append([v, c])
        e[v].append([u, c])
    cnt = 0
    for i in range(n):
        if vis[i] == False:
            vis[i] = True
            cnt += 1
            if func_1(i) == False:
                cnt = 0
                break
    ans = 1
    if cnt == 0:
        ans = 0
    for i in (1, cnt):
        ans *= 2
        ans %= mod
    print(ans)
''' 

 Output hints for function2:  The function processes a graph represented by adjacency lists `e` and determines if the graph can be split into disjoint sets such that each set is connected internally and the relationship between any two nodes within a set is "love" (denoted by `c=1`). It performs a depth-first search (DFS) to visit all nodes, ensuring no node violates the "love" condition within its set. If any node violates the condition, the function sets `cnt` to 0 and exits early. If no node violates the condition, it calculates the number of ways to partition the graph into such sets using bitwise operations and returns the result modulo \(1,000,000,007\). If no valid partitioning is possible, it returns 0.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.