
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: There are many anime that are about "love triangles": Alice loves Bob, and Charlie loves Bob as well, but Alice hates Charlie. You are thinking about an anime which has n characters. The characters are labeled from 1 to n. Every pair of two characters can either mutually love each other or mutually hate each other (there is no neutral state).

You hate love triangles (A-B are in love and B-C are in love, but A-C hate each other), and you also hate it when nobody is in love. So, considering any three characters, you will be happy if exactly one pair is in love (A and B love each other, and C hates both A and B), or if all three pairs are in love (A loves B, B loves C, C loves A).

You are given a list of m known relationships in the anime. You know for sure that certain pairs love each other, and certain pairs hate each other. You're wondering how many ways you can fill in the remaining relationships so you are happy with every triangle. Two ways are considered different if two characters are in love in one way but hate each other in the other. Print this count modulo 1 000 000 007.

Input

The first line of input will contain two integers n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).

The next m lines will contain the description of the known relationships. The i-th line will contain three integers ai, bi, ci. If ci is 1, then ai and bi are in love, otherwise, they hate each other (1 ≤ ai, bi ≤ n, ai ≠ bi, <image>).

Each pair of people will be described no more than once.

Output

Print a single integer equal to the number of ways to fill in the remaining pairs so that you are happy with every triangle modulo 1 000 000 007. 

Examples

Input

3 0


Output

4


Input

4 4
1 2 1
2 3 1
3 4 0
4 1 0


Output

1


Input

4 4
1 2 1
2 3 1
3 4 0
4 1 1


Output

0

Note

In the first sample, the four ways are to: 

  * Make everyone love each other 
  * Make 1 and 2 love each other, and 3 hate 1 and 2 (symmetrically, we get 3 ways from this). 



In the second sample, the only possible solution is to make 1 and 3 love each other and 2 and 4 hate each other.
Program:
```

#Function 1:
def func_1(u):
    sz = len(e[u])
    ok = True
    for i in range(sz):
        v = e[u][i][0]
        c = e[u][i][1]
        if vis[v] == False:
            if c == True:
                vis[v] = vis[u]
            else:
                vis[v] = -vis[u]
            ok = func_1(v)
        if c == 1 and vis[v] != vis[u]:
            return False
        if c == 0 and vis[v] != -vis[u]:
            return False
    return ok

#Function 2:
def func_2():
    (n, m) = map(int, raw_input().split())
    for i in range(m):
        (u, v, c) = map(int, raw_input().split())
        u -= 1
        v -= 1
        e[u].append([v, c])
        e[v].append([u, c])
    cnt = 0
    for i in range(n):
        if vis[i] == False:
            vis[i] = True
            cnt += 1
            if func_1(i) == False:
                cnt = 0
                break
    ans = 1
    if cnt == 0:
        ans = 0
    for i in (1, cnt):
        ans *= 2
        ans %= mod
    print(ans)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not fully address the problem description. Specifically, the function `func_1` seems to attempt to verify the consistency of the relationships starting from a given node `u`, but it does not handle the overall consistency check for all nodes and edges as required. The program also lacks handling for the cases where no valid configuration exists, which is evident in the third example provided.

Here's a breakdown of the issues:

1. **Incomplete Handling of Relationships**: The function `func_1` checks the consistency of relationships starting from a node `u`. However, it does not ensure that all relationships are consistent across the entire graph. This means that the function might not catch all invalid configurations, especially when multiple nodes and their relationships are involved.

2. **Lack of Consistency Check**: The problem requires ensuring that for every set of three characters, either exactly one pair is in love and the other two hate each other, or all three pairs are in love. The current implementation does not explicitly check this condition for every possible triplet of characters.

3. **Incorrect Modulo Operation**: The modulo operation in the final answer is performed using `mod`, which is not defined in the provided code. This needs to be defined before using it.

4. **Potential Missing Cases**: The program does not handle cases where the initial set of relationships leads to an inconsistent graph, such as the third example provided.

Given these issues, the program cannot be considered fully correct as it does not meet the requirements of the problem description for every potential case. Therefore, the correctness is **False**.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
maxn = 100005
mod = 1000000007
e = [[] for i in range(maxn)]
vis = [False for i in range(maxn)]
func_2()

#Function 1:
#State of the program right berfore the function call: u is an integer representing a character label in the range [1, n], e is a list of adjacency lists where each entry e[u] is a list of tuples (v, c), where v is another character label in the range [1, n] and c is a boolean indicating whether u and v love each other (True) or hate each other (False); vis is a list of booleans or integers representing the love/hate status of each character, initially set to False.
def func_1(u):
    sz = len(e[u])
    ok = True
    for i in range(sz):
        v = e[u][i][0]
        
        c = e[u][i][1]
        
        if vis[v] == False:
            if c == True:
                vis[v] = vis[u]
            else:
                vis[v] = -vis[u]
            ok = func_1(v)
        
        if c == 1 and vis[v] != vis[u]:
            return False
        
        if c == 0 and vis[v] != -vis[u]:
            return False
        
    #State of the program after the  for loop has been executed: `u` is an integer in the range [1, n], `e` is a list of adjacency lists, `vis` is a list of booleans or integers, `sz` is the length of the list `e[u]`, `ok` is the final return value of `func_1(v)` after all iterations of the loop, `v` is a character label in the range [1, n], and `c` is a boolean indicating whether `u` and `v` love each other (True) or hate each other (False). If the loop executes, `vis[v]` is set to `vis[u]` if `c` is True, and to `-vis[u]` if `c` is False, ensuring that for any two connected nodes, `vis[v]` is either the same as `vis[u]` if they love each other or the negation of `vis[u]` if they hate each other. If the loop does not execute (when `sz` is 0), `vis` remains as its initial state, which is False for all elements.
    return ok
    #The program returns `ok`, which is the final return value of `func_1(v)` after all iterations of the loop, considering the values of `vis[v]` based on whether `u` and `v` love or hate each other
#Overall this is what the function does:The function `func_1` accepts an integer `u`, a list of adjacency lists `e`, and a list `vis`. It performs a depth-first search (DFS) traversal of the graph represented by `e`, updating the `vis` list based on the relationship (love or hate) between `u` and each of its neighbors. For each neighbor `v`, if `vis[v]` is not yet set, `vis[v]` is updated to `vis[u]` if `u` and `v` love each other (`c == True`), or to `-vis[u]` if they hate each other (`c == False`). The function recursively calls itself for each neighbor. If at any point the relationships violate the conditions (either loving characters have different signs in `vis` or hating characters have the same sign), the function returns `False`. Otherwise, it returns `ok`, which is the final return value of the recursive calls, ensuring that the `vis` list maintains the required relationship signs for all connected components. The function can only return `True` (or `ok` being `True`) if the entire graph can be consistently labeled according to the given relationships without violating any conditions.

#Function 2:
#State of the program right berfore the function call: n and m are integers such that 3 ≤ n ≤ 100 000 and 0 ≤ m ≤ 100 000. e is a list of adjacency lists where e[i] contains pairs [v, c] for each vertex v connected to vertex i with a relationship described by c (c is 1 if they love each other and 0 if they hate each other). vis is a boolean list of length n indicating whether each character has been visited during the graph traversal. mod is an integer representing the modulo value (1 000 000 007).
def func_2():
    n, m = map(int, raw_input().split())
    for i in range(m):
        u, v, c = map(int, raw_input().split())
        
        u -= 1
        
        v -= 1
        
        e[u].append([v, c])
        
        e[v].append([u, c])
        
    #State of the program after the  for loop has been executed: `n` is an integer between 3 and 100,000 inclusive; `m` is the total number of edges added; `i` is `m-1`; `vis` is a boolean list of length `n`; `mod` is 1,000,000,007; `u` and `v` are integers representing the nodes connected by an edge, each decremented by 1; `c` is an integer representing the cost of the edge; `e[u]` and `e[v]` are adjacency lists containing all the edges added by the loop.
    cnt = 0
    for i in range(n):
        if vis[i] == False:
            vis[i] = True
            cnt += 1
            if func_1(i) == False:
                cnt = 0
                break
        
    #State of the program after the  for loop has been executed: `n` is an integer between 3 and 100,000 inclusive; `m` is the total number of edges added and satisfies `1 <= m < n+1`; `vis` is a boolean list of length `n` where exactly `m` elements are set to `True`; `mod` is 1,000,000,007; `u` and `v` are integers representing the nodes connected by an edge, each decremented by 1; `c` is an integer representing the cost of the edge; `e[u]` and `e[v]` are adjacency lists containing all the edges added by the loop; `cnt` is 0. If the loop completes all iterations without breaking, `cnt` will be 0, meaning no node was found to violate the condition in `func_1(i)` during any iteration. If the loop breaks, `cnt` will be 0 and exactly `m` nodes were visited.
    ans = 1
    if (cnt == 0) :
        ans = 0
    #State of the program after the if block has been executed: *`n` is an integer between 3 and 100,000 inclusive; `m` is the total number of edges added and satisfies `1 <= m < n+1`; `vis` is a boolean list of length `n` where exactly `m` elements are set to `True`; `mod` is 1,000,000,007; `u` and `v` are integers representing the nodes connected by an edge, each decremented by 1; `c` is an integer representing the cost of the edge; `e[u]` and `e[v]` are adjacency lists containing all the edges added by the loop; `cnt` is 0; `ans` is 1, as it starts from 1 and is not modified in the if part since `cnt == 0`.
    for i in (1, cnt):
        ans *= 2
        
        ans %= mod
        
    #State of the program after the  for loop has been executed: Output State:
    print(ans)
#Overall this is what the function does:The function processes a graph represented by adjacency lists `e` and determines if the graph can be split into disjoint sets such that each set is connected internally and the relationship between any two nodes within a set is "love" (denoted by `c=1`). It performs a depth-first search (DFS) to visit all nodes, ensuring no node violates the "love" condition within its set. If any node violates the condition, the function sets `cnt` to 0 and exits early. If no node violates the condition, it calculates the number of ways to partition the graph into such sets using bitwise operations and returns the result modulo \(1,000,000,007\). If no valid partitioning is possible, it returns 0.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
