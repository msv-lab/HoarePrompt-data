
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You've got two rectangular tables with sizes na × ma and nb × mb cells. The tables consist of zeroes and ones. We will consider the rows and columns of both tables indexed starting from 1. Then we will define the element of the first table, located at the intersection of the i-th row and the j-th column, as ai, j; we will define the element of the second table, located at the intersection of the i-th row and the j-th column, as bi, j. 

We will call the pair of integers (x, y) a shift of the second table relative to the first one. We'll call the overlap factor of the shift (x, y) value:

<image>

where the variables i, j take only such values, in which the expression ai, j·bi + x, j + y makes sense. More formally, inequalities 1 ≤ i ≤ na, 1 ≤ j ≤ ma, 1 ≤ i + x ≤ nb, 1 ≤ j + y ≤ mb must hold. If there are no values of variables i, j, that satisfy the given inequalities, the value of the sum is considered equal to 0. 

Your task is to find the shift with the maximum overlap factor among all possible shifts.

Input

The first line contains two space-separated integers na, ma (1 ≤ na, ma ≤ 50) — the number of rows and columns in the first table. Then na lines contain ma characters each — the elements of the first table. Each character is either a "0", or a "1".

The next line contains two space-separated integers nb, mb (1 ≤ nb, mb ≤ 50) — the number of rows and columns in the second table. Then follow the elements of the second table in the format, similar to the first table.

It is guaranteed that the first table has at least one number "1". It is guaranteed that the second table has at least one number "1".

Output

Print two space-separated integers x, y (|x|, |y| ≤ 109) — a shift with maximum overlap factor. If there are multiple solutions, print any of them.

Examples

Input

3 2
01
10
00
2 3
001
111


Output

0 1


Input

3 3
000
010
000
1 1
1


Output

-1 -1
Annotated Functions:
from sys import stdin

(na, ma) = [int(buf) for buf in stdin.readline().strip().split()]
a = [int(stdin.readline().strip()[::-1], 2) for i in range(0, na)]
(nb, mb) = [int(buf) for buf in stdin.readline().strip().split()]
b = [int(stdin.readline().strip()[::-1], 2) for i in range(0, nb)]
(ans, xx, yy) = (0, 0, 0)
for x in range(1 - na, nb):
    for y in range(1 - ma, mb):
        val = func_2(x, y)
        if ans < val:
            (ans, xx, yy) = (val, x, y)
print('%d %d' % (xx, yy))

#Function 1:
#State of the program right berfore the function call: x is an integer.
def func_1(x):
    x = (x & 113427455640312821154458202477256070485) + (x >> 1 & 
    113427455640312821154458202477256070485)
    x = (x & 68056473384187692692674921486353642291) + (x >> 2 & 
    68056473384187692692674921486353642291)
    x = (x & 20016609818878733144904388672456953615) + (x >> 4 & 
    20016609818878733144904388672456953615)
    x = (x & 1324055902416102970674609367438786815) + (x >> 8 & 
    1324055902416102970674609367438786815)
    x = (x & 5192217631581220737344928932233215) + (x >> 15 & 
    5192217631581220737344928932233215)
    x = (x & 79228162495817593524129366015) + (x >> 16 & 
    79228162495817593524129366015)
    x = (x & 18446744073709551615) + (x >> 32 & 18446744073709551615)
    return x
    #The program returns x that is calculated as (x & 18446744073709551615) + (x >> 32 & 18446744073709551615)
#Overall this is what the function does:The function `func_1` accepts an integer `x` and returns a modified version of `x` based on a specific bitwise operation. Specifically, it applies a series of bitwise AND and right shift operations on `x`. The final result is obtained by performing `(x & 18446744073709551615) + (x >> 32 & 18446744073709551615)`. This process involves breaking down the integer into smaller parts using bitwise operations and then combining them back together. The function does not handle any edge cases explicitly; however, it is designed to work with non-negative integers since the operations involve bitwise shifts and masks. If `x` were negative, the behavior would depend on the specific bitwise operations and the Python interpreter's handling of negative numbers.

#Function 2:
#State of the program right berfore the function call: na, ma, nb, mb are integers such that 1 ≤ na, ma ≤ 50 and 1 ≤ nb, mb ≤ 50. a and b are lists of strings representing the rows of the first and second tables respectively, where each string contains '0' and '1'. x and y are integers representing a potential shift relative to the first table.
def func_2(x, y):
    cnt = 0
    for i in range(0, na):
        if i + x in range(0, nb):
            if y > 0:
                cnt += func_1(a[i] << y & b[i + x])
            else:
                cnt += func_1(a[i] & b[i + x] << -y)
        
    #State of the program after the  for loop has been executed: `i` is an integer in the range of 0 to `na-1`, `na` is a positive integer, `x` is an integer, and `cnt` is the cumulative result of applying `func_1` according to the conditions specified in the loop body for each valid pair `(i, i + x)`. If no valid pairs are found, `cnt` remains 0.
    return cnt
    #The program returns cnt, which is the cumulative result of applying func_1 according to the conditions specified in the loop body for each valid pair (i, i + x). If no valid pairs are found, cnt remains 0.
#Overall this is what the function does:The function `func_2` accepts two integer parameters `x` and `y`. It iterates over the indices of list `a` up to the length `na`. For each index `i`, it checks if the index `i + x` is within the bounds of list `b` (length `nb`). If `y` is positive, it applies a left bit shift operation (`<<`) on `a[i]` by `y` bits, then performs a bitwise AND operation with `b[i + x]`. If `y` is negative, it applies a right bit shift operation (`>>`) on `a[i]` by `-y` bits, then performs a bitwise AND operation with `b[i + x]`. The result of these operations is passed to `func_1`, and the returned value is added to the counter `cnt`. After the loop completes, the function returns the cumulative value of `cnt`. If no valid pairs `(i, i + x)` are found, `cnt` remains 0. This means the function essentially sums the results of `func_1` applied to specific bit-shifted pairs of elements from lists `a` and `b` based on the given shift values `x` and `y`.

Potential edge cases and missing functionality:
- If `x` is negative and `i + x` is less than 0, the condition `if i + x in range(0, nb):` will fail, and no action will be taken for those cases. This could lead to ignoring certain parts of the lists `a` and `b`.
- If `y` is zero, the code does not handle this case explicitly, which might result in unnecessary operations since shifting by zero bits would not change the value.
- The function assumes that `a` and `b` are of appropriate lengths and contain valid binary strings, but it does not perform any validation on these assumptions.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.