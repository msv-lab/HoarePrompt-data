
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given a Young diagram. 

Given diagram is a histogram with n columns of lengths a_1, a_2, …, a_n (a_1 ≥ a_2 ≥ … ≥ a_n ≥ 1).

<image> Young diagram for a=[3,2,2,2,1].

Your goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a 1 × 2 or 2 × 1 rectangle.

Input

The first line of input contain one integer n (1 ≤ n ≤ 300 000): the number of columns in the given histogram.

The next line of input contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 300 000, a_i ≥ a_{i+1}): the lengths of columns.

Output

Output one integer: the largest number of non-overlapping dominos that you can draw inside of the given Young diagram.

Example

Input


5
3 2 2 2 1


Output


4

Note

Some of the possible solutions for the example:

<image> <image>
Functions with output description for each function:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_16(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_17()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function reads an integer input provided by the user, which is within the range of 1 to 300,000. After reading the input, the function returns this integer. The input must satisfy the condition \(a_i \geq a_{i+1}\), although the function itself does not check or enforce this condition. Therefore, the final state of the program after the function concludes is that it has returned an integer input from the user within the specified range, but without verifying the \(a_i \geq a_{i+1}\) condition.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` accepts a parameter `a`, which is a list of integers representing the lengths of the columns. It simply returns the same list `a` without performing any modifications or additional operations. There are no edge cases mentioned or missing functionalities in the provided code.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function3:  The function reads a single line of input from the standard input, which includes an integer \( n \) (where \( 1 \leq n \leq 300,000 \)) followed by \( n \) space-separated integers \( a_1, a_2, \ldots, a_n \) (where \( 1 \leq a_i \leq 300,000 \) and \( a_i \geq a_{i+1} \)). It then splits this input string into separate elements, strips any leading or trailing whitespace, and converts these elements into integers. The function returns a map object containing these integers. Potential edge cases include the input string being empty or containing invalid characters, which would result in a ValueError when attempting to convert the input to integers. However, the provided code does not handle such cases, so an exception might occur if the input format is not strictly adhered to.
Function number 4 :
 Code:
 '''
def func_4():
    return map(str, input().strip().split(' '))
''' 

 Output hints for function4:  The function reads an integer `n` followed by `n` space-separated integers from standard input. It then converts these integers into strings and returns a list of these string representations. This list contains exactly `n` elements, each being a string representation of one of the original integers. The function assumes that `1 ≤ n ≤ 300,000` and that each integer `a_i` satisfies `1 ≤ a_i ≤ 300,000` and `a_i ≥ a_{i+1}`. No edge cases are explicitly handled within the function; however, it is assumed that the input adheres to the given constraints.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_3())
''' 

 Output hints for function5:  The function `func_5` returns a list generated by calling `func_3` with a list `a` of length `n` (where `1 ≤ n ≤ 300,000`) consisting of integers between 1 and 300,000 inclusive. The returned list from `func_3` is a new list where each element is non-increasing. This means that each element in the returned list is less than or equal to the previous element. There are no explicit edge cases mentioned in the annotations or code that need special handling; however, the function assumes that the input list `a` is already sorted in non-increasing order, as stated in the initial program state. If the input list `a` were not sorted in non-increasing order, the behavior of `func_3` would still generate a non-increasing list, but the initial precondition would be violated.
Function number 6 :
 Code:
 '''
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function6:  The function `func_6` sets the recursion limit and stack size for a new thread, then starts a new thread named `thread` which targets the `main` function. The function accepts two parameters: `n`, an integer such that 1 ≤ n ≤ 300,000, and `a`, a list of `n` integers where each element is an integer such that 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}. After starting the thread, the function does not directly manipulate or return any values from the `main` function. The final state of the program is that a new thread has been started to execute the `main` function, and the original calling thread continues its execution.
Function number 7 :
 Code:
 '''
def func_7(item):
    return item[1]
''' 

 Output hints for function7:  The function `func_7` accepts a parameter `item`, which is expected to be a list or tuple containing at least one element. The second element of this list or tuple should be an integer representing the length of a column in the Young diagram. The function returns this integer. If `item` does not contain exactly two elements or if the second element is not an integer, the function will still execute as written, but it may not behave as intended, potentially leading to incorrect results or errors. Therefore, the final state of the program after the function concludes is that the integer representing the length of a column in the Young diagram is returned, assuming the input `item` is valid. Any invalid input will not trigger an error message but will simply return the second element of `item` if it exists and is an integer.
Function number 8 :
 Code:
 '''
def func_8(l):
    return sorted(l, key=getKey)
''' 

 Output hints for function8:  The function `func_8` accepts a parameter `l`, which is a list of non-negative integers sorted in non-increasing order. It returns a new list that is sorted in non-decreasing order using the `getKey` function as the sorting key. Given the initial state of `l`, the function performs the following actions:

1. The function uses the built-in `sorted` function to sort the list `l`.
2. The `sorted` function sorts the list in non-decreasing order based on the key returned by the `getKey` function.
3. The function does not modify the original list `l`; instead, it returns a new sorted list.

Potential edge cases and missing functionality:
- If the `getKey` function is not defined or does not return a valid sorting key, the behavior of the function is undefined. However, the provided code does not handle this case.
- The function assumes that the `getKey` function is correctly implemented and will always return a valid sorting key for the elements in `l`.

After the function concludes, the program will have a new list that is sorted in non-decreasing order based on the key returned by the `getKey` function. The original list `l` remains unchanged.
Function number 9 :
 Code:
 '''
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function9:  The function `func_9` accepts three parameters: `n` (the number of rows), `m` (the number of columns), and `num` (the value to fill the 2D list). It returns a 2D list of size `n x m`, where every element in the list is equal to `num`. There are no specific edge cases mentioned in the code itself, but it handles the general case of creating a rectangular 2D list filled with a specified value. No missing functionality is noted in the provided code.
Function number 10 :
 Code:
 '''
def func_10(x):
    return x and (not x & x - 1)
''' 

 Output hints for function10:  The function `func_10` accepts a non-negative integer `x`. It checks whether `x` is zero. If `x` is zero, the function returns `True`; otherwise, it returns `False`. There are no edge cases or missing functionalities in the provided code. The code accurately describes the intended behavior.
Function number 11 :
 Code:
 '''
def func_11(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function11:  The function `func_11` accepts an integer `n` and returns a binary string representation of `n` without the '0b' prefix. The function directly converts the integer `n` to its binary form using the `bin()` function and then removes the '0b' prefix by replacing it with an empty string. There are no additional actions performed beyond this conversion and removal. The function handles valid inputs within the specified range (1 ≤ n ≤ 300,000) and correctly processes all integers within this range, including edge cases such as the smallest and largest possible values.
Function number 12 :
 Code:
 '''
def func_12(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function12:  The function `func_12` accepts an integer `n` and returns a list of its individual digits. The function converts the integer `n` into a string, iterates over each character in the string, converts each character back into an integer, and collects these integers into a list. This process works for any non-negative integer `n`. However, the function does not handle negative integers, as converting a negative integer to a string results in a string that includes a '-' sign, which would be included in the list of digits. Therefore, the function should only be used with non-negative integers. Additionally, the function does not modify the input `n` and returns a new list of digits without altering the original integer.
Function number 13 :
 Code:
 '''
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
''' 

 Output hints for function13:  The function `func_13` takes three parameters: `x`, `y`, and `p`, where `x` and `p` are integers, and `y` is an integer representing the exponent. The function computes `(x^y) % p` using an efficient method known as modular exponentiation. Specifically, it updates `res` to the result of the expression `res * x^(y & 1) % p` after each iteration of the loop, where `res` is initialized to 1. The function iterates through the bits of `y` (from least significant to most significant), squaring `x` and reducing it modulo `p` at each step, and multiplying `res` by `x` if the current bit of `y` is 1. After the loop completes, the function returns the value of `res`, which is equivalent to `(x^y) % p`. Potential edge cases include when `y` is 0, in which case the function effectively returns `res`, which is 1, since no multiplications are performed. If `p` is 1, the result is always 0 regardless of `x` and `y`. The function also handles negative exponents by ensuring `x` is reduced modulo `p` before the loop starts.
Function number 14 :
 Code:
 '''
def func_14(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function14:  The function `func_14` accepts two non-negative integer parameters `x` and `y`. It uses the Euclidean algorithm to compute the greatest common divisor (GCD) of `x` and `y`. After the computation, the function returns `x` as the GCD and sets `y` to 0. This process handles all edge cases, including when either `x` or `y` is 0 initially, and when both are equal to 0.
Function number 15 :
 Code:
 '''
def func_15(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function15:  The function `func_15` accepts an integer `n` representing the number of columns in a Young diagram. It returns `False` if `n` is less than or equal to 1, less than or equal to 3 and not 2, or if `n` is divisible by 2 or 3. Additionally, it returns `False` if `n` has any divisors other than 1 and itself within the range up to the square root of `n`. If none of these conditions are met, the function returns `True`. The function checks specific divisibility rules and the primality of `n` by checking for divisors up to the square root of `n`, skipping even numbers and multiples of 3.
Function number 16 :
 Code:
 '''
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
''' 

 Output hints for function16:  The function `func_16()` reads a list of integers from a file named `input.txt`, where each integer represents the height of a column in a Young diagram, and writes the processed data to a file named `output.txt`. The input list is assumed to have `n` elements, where `n` is the number of columns, and each element is a non-increasing integer between 1 and 300,000. However, the function does not process or manipulate the input data; it simply reads and writes the raw input without any changes. There are no specific actions mentioned in the code for processing the data, so the final state of the program after the function concludes is that the `sys.stdin` and `sys.stdout` are redirected to `input.txt` and `output.txt`, respectively, and no further operations are performed on the input data.
Function number 17 :
 Code:
 '''
def func_17():
    n = func_1()
    a = func_5()
    w = 0
    b = 0
    for i in range(n):
        if i % 2:
            b += (a[i] + 1) // 2
            w += a[i] // 2
        else:
            w += (a[i] + 1) // 2
            b += a[i] // 2
    func_18(min(w, b))
''' 

 Output hints for function17:  The function `func_17` accepts a parameter `n` (an integer such that 1 ≤ n ≤ 300,000) and a parameter `a` (a list of n integers where each integer `a_i` satisfies 1 ≤ `a_i` ≤ 300,000 and `a_i` ≥ `a_{i+1}`), and processes them according to the description of a Young diagram. It calculates two sums, `w` and `b`, based on the elements of `a`. Specifically, for even indices `i`, `w` accumulates `(a[i] + 1) // 2` and `b` accumulates `a[i] // 2`, while for odd indices `i`, `w` accumulates `a[i] // 2` and `b` accumulates `(a[i] + 1) // 2`. After the loop, it calls `func_18` with the minimum of `w` and `b`. The final state of the program after the function concludes is that it has computed these two sums based on the given rules and passed the smaller one to `func_18`.
Function number 18 :
 Code:
 '''
def func_18(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function18:  This function accepts positional arguments `args`, keyword arguments `sep`, `file`, `end`, and `flush`. It writes each element of `args` to `file` (defaulting to `sys.stdout`) separated by `sep` (defaulting to a space), followed by `end` (defaulting to a newline). If `flush` is set to `True`, it flushes the output buffer. The function does not return any value. Potential edge cases include passing empty `args`, non-string `sep`, and invalid `file` objects. The final state of the program is that `sys.stdout` (or the specified `file`) contains the concatenated string representations of all elements in `args` separated by `sep` and followed by `end`, with the output buffer possibly flushed based on the value of `flush`.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.