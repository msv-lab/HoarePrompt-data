
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given a Young diagram. 

Given diagram is a histogram with n columns of lengths a_1, a_2, …, a_n (a_1 ≥ a_2 ≥ … ≥ a_n ≥ 1).

<image> Young diagram for a=[3,2,2,2,1].

Your goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a 1 × 2 or 2 × 1 rectangle.

Input

The first line of input contain one integer n (1 ≤ n ≤ 300 000): the number of columns in the given histogram.

The next line of input contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 300 000, a_i ≥ a_{i+1}): the lengths of columns.

Output

Output one integer: the largest number of non-overlapping dominos that you can draw inside of the given Young diagram.

Example

Input


5
3 2 2 2 1


Output


4

Note

Some of the possible solutions for the example:

<image> <image>
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_16(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_17()

#Function 1:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 300,000, and the subsequent line contains n integers a_1, a_2, …, a_n where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}.
def func_1():
    return int(input())
    #The program returns an integer input provided by the user, which is within the range of 1 to 300,000 and satisfies the condition a_i ≥ a_{i+1}

#Function 2:
#State of the program right berfore the function call: None of the variable names or their relationships are provided in the given function signature or the problem description. However, based on the problem context, `n` should be an integer representing the number of columns, and the input should be a list of integers `a` representing the lengths of the columns.
def func_2():
    return input()
    #The program returns the list of integers 'a' which represents the lengths of the columns

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 300,000, and the next line contains n integers a_1, a_2, …, a_n where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers parsed from the input string, where the input string is stripped of leading/trailing whitespace and split by spaces, and the initial state includes n being an integer such that 1 ≤ n ≤ 300,000, and the following n integers a_1, a_2, …, a_n where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}

#Function 4:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 300,000, and the next line contains n space-separated integers representing the lengths of the columns a_1, a_2, …, a_n where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a list of strings, each representing the integers from the input, converted to strings

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 300,000, and a is a list of n integers where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1} for all valid i.
def func_5():
    return list(func_3())
    #The program returns a list generated by the function `func_3()` which takes as input a list `a` of length `n` (where `1 ≤ n ≤ 300,000`) consisting of integers between 1 and 300,000 inclusive, and returns a new list where each element is non-increasing.

#Function 6:
#State of the program right berfore the function call: `n` is an integer such that 1 ≤ n ≤ 300,000, and `a` is a list of `n` integers where each element is an integer such that 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list or tuple containing at least one element, where the second element is an integer representing the length of a column in the Young diagram.
def func_7(item):
    return item[1]
    #The program returns the integer representing the length of a column in the Young diagram

#Function 8:
#State of the program right berfore the function call: l is a list of non-negative integers, where each integer represents the length of a column in the Young diagram and the list is sorted in non-increasing order. The length of the list is at least 1 and at most 300,000, and each element in the list is at least 1 and at most 300,000.
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns a list that is sorted in non-decreasing order using the getKey function as the sorting key, given that 'l' is initially a list of non-negative integers sorted in non-increasing order

#Function 9:
#State of the program right berfore the function call: n is an integer representing the number of columns in the Young diagram, m is an integer representing the length of each column, and num is an integer used to fill the 2D list created. However, this function does not contribute to solving the main problem described in the problem statement. It simply creates a 2D list filled with the value 'num' of size n x m.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list of size n x m, where every element in the list is equal to 'num'

#Function 10:
#State of the program right berfore the function call: x is a non-negative integer.
def func_10(x):
    return x and not x & x - 1
    #The program returns True if x is 0, otherwise returns False

#Function 11:
#State of the program right berfore the function call: n is an integer representing the number of columns in the Young diagram, and the lengths of the columns are provided in a list a with length n, where 1 ≤ n ≤ 300,000 and 1 ≤ a_i ≤ 300,000 such that a_i ≥ a_{i+1} for all i.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of integer 'n' with '0b' prefix removed

#Function 12:
#State of the program right berfore the function call: n is an integer representing the number of columns in the Young diagram, and the lengths of the columns are provided as a list of integers a where 1 ≤ len(a) ≤ 300, 000 and a[i] ≥ a[i + 1].
def func_12(n):
    return [int(i) for i in str(n)]
    #[int(i) for i in str(n)]

#Function 13:
#State of the program right berfore the function call: x is an integer representing the base, y is an integer representing the exponent, and p is an integer representing the modulus.
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: 'x' is updated to \( x^{2^k} \mod p \) where \( k \) is the number of times the loop has executed, 'y' is 0, 'p' remains unchanged, and 'res' is the result of the expression \( res \times x^{y \& 1} \mod p \)
    return res
    #The program returns res which is the result of the expression res * x^(y & 1) mod p

#Function 14:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, and y is 0

#Function 15:
#State of the program right berfore the function call: n is an integer representing the number of columns in the Young diagram, and a list of n integers a_1, a_2, …, a_n where 1 ≤ a_i ≤ 300 000 and a_i ≥ a_{i+1} are provided as input. However, the function `func_15` provided does not use the list of integers a_1, a_2, …, a_n, and instead checks if n (the number of columns) meets certain conditions related to divisibility and square roots. This suggests that the function is not directly related to solving the main problem of finding the largest number of non-overlapping dominos in the Young diagram.
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer representing the number of columns in the Young diagram, and a list of `n` integers `a_1, a_2, ..., a_n` where 1 ≤ `a_i` ≤ 300 000 and `a_i` ≥ `a_{i+1}`. `n` is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer representing the number of columns in the Young diagram, and a list of n integers a_1, a_2, ..., a_n where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}. n is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: n is an integer representing the number of columns in the Young diagram, and a list of n integers a_1, a_2, ..., a_n where 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}. n is greater than 3, and n is not divisible by 2 and n is not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than 3, not divisible by 2 or 3, `i` is the smallest integer greater than \(\sqrt{n}\) such that \(i \times i > n\), and `a_1, a_2, ..., a_n` is a list of n integers where \(1 \leq a_i \leq 300,000\) and \(a_i \geq a_{i+1}`.
    return True
    #The program returns True

#Function 16:
#State of the program right berfore the function call: `n` is an integer representing the number of columns in the Young diagram, and the following line contains `n` integers `a_1, a_2, ..., a_n` where each `a_i` is an integer such that `1 ≤ a_i ≤ 300 000` and `a_i ≥ a_{i+1}`.
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 300,000, representing the number of columns in the Young diagram. a is a list of n integers where each integer a_i satisfies 1 ≤ a_i ≤ 300,000 and a_i ≥ a_{i+1}, representing the lengths of the columns in the Young diagram.
def func_17():
    n = func_1()
    a = func_5()
    w = 0
    b = 0
    for i in range(n):
        if i % 2:
            b += (a[i] + 1) // 2
            w += a[i] // 2
        else:
            w += (a[i] + 1) // 2
            b += a[i] // 2
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `a` is a list of `n` integers where each integer `a_i` satisfies \(1 \leq a_i \leq 300,000\) and \(a_i \geq a_{i+1}\), `w` is the sum of every other element of `a` starting from the second element, and `b` is the sum of every other element of `a` starting from the first element.
    func_18(min(w, b))

#Function 18:
#State of the program right berfore the function call: The function does not directly relate to solving the Young diagram problem. The variables in its signature do not match those required for solving the problem. Therefore, no precondition can be derived from this function for the given problem.
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is `' '`, `file` is `sys.stdout`, `at_start` is `False`, `args` is an empty iterable, `sys.stdout` contains the concatenated string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is ' '; `file` is `sys.stdout`; `at_start` is `False`; `args` is an empty iterable; `sys.stdout` contains the concatenated string representations of all elements in `args` separated by `sep` and followed by `\n`; the call to `kwargs.pop('flush', False)` is made, and the value of `flush` remains unchanged.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
