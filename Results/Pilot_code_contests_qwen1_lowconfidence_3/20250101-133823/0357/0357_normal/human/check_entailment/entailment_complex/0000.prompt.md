
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Positive integer x is called divisor of positive integer y, if y is divisible by x without remainder. For example, 1 is a divisor of 7 and 3 is not divisor of 8.

We gave you an integer d and asked you to find the smallest positive integer a, such that 

  * a has at least 4 divisors; 
  * difference between any two divisors of a is at least d.

Input

The first line contains a single integer t (1 ≤ t ≤ 3000) — the number of test cases.

The first line of each test case contains a single integer d (1 ≤ d ≤ 10000).

Output

For each test case print one integer a — the answer for this test case.

Example

Input


2
1
2


Output


6
15

Note

In the first test case, integer 6 have following divisors: [1, 2, 3, 6]. There are 4 of them and the difference between any two of them is at least 1. There is no smaller integer with at least 4 divisors.

In the second test case, integer 15 have following divisors: [1, 3, 5, 15]. There are 4 of them and the difference between any two of them is at least 2.

The answer 12 is INVALID because divisors are [1, 2, 3, 4, 6, 12]. And the difference between, for example, divisors 2 and 3 is less than d=2.
Annotated Functions:
import sys

testing = len(sys.argv) == 4 and sys.argv[3] == 'myTest'
if testing:
    cmd = sys.stdout
    from time import time
    start_time = int(round(time() * 1000))
    input = open(sys.argv[1], 'r').readline
    readAll = open(sys.argv[1], 'r').read
    sys.stdout = open(sys.argv[2], 'w')
else:
    input = sys.stdin.readline
    readAll = sys.stdin.read
p = [False] * 21001
for i in xrange(1, 21001):
    p[i] = func_7(i)
primes = [i for (i, x) in enumerate(p) if x]
if __name__ == '__main__':
    for _ in xrange(func_1()):
        func_9()
    if testing:
        sys.stdout = cmd
        print(int(round(time() * 1000)) - start_time)

#Function 1:
#State of the program right berfore the function call: None of the variables in the function signature are provided, but based on the context, the function reads an integer input t, which represents the number of test cases, and for each test case, it reads an integer d, where 1 ≤ t ≤ 3000 and 1 ≤ d ≤ 10000.
def func_1():
    return int(input())
    #The program returns an integer input d for each test case, where 1 ≤ t ≤ 3000 and 1 ≤ d ≤ 10000
#Overall this is what the function does:The function reads an integer input `t` representing the number of test cases. For each test case, it reads an integer `d` where \(1 \leq t \leq 3000\) and \(1 \leq d \leq 10000\). The function then returns an integer input `d` for each test case. There are no explicit parameters passed to the function. Potential edge cases include when `t` is less than 1 or greater than 3000, in which case the function would read an invalid value for `t`. Similarly, if `d` is outside the range \(1 \leq d \leq 10000\), the function would read an invalid value for `d`. However, the function does not handle these edge cases; it simply returns the input `d` for each valid test case.

#Function 2:
#State of the program right berfore the function call: None of the variables' values or relationships are explicitly defined within the provided function signature. However, based on the context, we can infer that the function does not take any arguments and is expected to read input values for the number of test cases and individual test case inputs.
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained by splitting the input string and converting each element to an integer
#Overall this is what the function does:The function `func_2` reads a line of input from the user, splits it into individual elements, converts each element to an integer, and returns a list of these integers. This function does not accept any parameters and relies on standard input. It handles the case where the input string contains multiple space-separated integers. If the input string is empty or only contains spaces, the function will still process it and return an empty list. There is no error handling for non-integer inputs, which means that if the input contains anything other than digits and spaces, the program may raise a `ValueError`.

#Function 3:
#State of the program right berfore the function call: s is a string containing at least two characters.
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list of characters from the string `s` excluding the last character
#Overall this is what the function does:The function `func_3()` takes no explicit parameters but requires an input string `s` from the user. It then returns a list of characters from `s`, excluding the last character. This means if the input string `s` contains at least two characters, the returned list will have one less character than the original string. If the input string `s` contains only one character, the function will still take this input but will return an empty list since removing the last character from a single-character string results in an empty list. There are no edge cases beyond these mentioned, as the code handles the removal of the last character as specified.

#Function 4:
#State of the program right berfore the function call: s is a string representing an integer followed by a newline character, where the length of the string is at least 1 and the integer part is between 1 and 10^9 inclusive.
def func_4():
    s = input()
    return s[:len(s) - 1]
    #The program returns the string `s` without the trailing newline character
#Overall this is what the function does:The function `func_4()` accepts a single parameter `s`, which is a string representing an integer followed by a newline character. It returns the string `s` without the trailing newline character. The function correctly removes the newline character from the end of the string, regardless of the content of the integer part of the string. The length of the string is at least 1 and the integer part is between 1 and 10^9 inclusive. There are no missing functionalities or edge cases in the provided code.

#Function 5:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 3000, and d is an integer such that 1 ≤ d ≤ 10000.
def func_5(l, sep):
    print(sep.join(map(str, l)))
#Overall this is what the function does:The function `func_5` accepts two parameters: `l` and `sep`, both of which are integers. It joins the elements of list `l` (where each element is converted to a string) using the separator `sep` and prints the result. There are no return values; the function only performs printing. The function does not perform any conditional checks on the values of `l` or `sep`, and thus does not return any specific integer based on their values.

#Function 6:
#State of the program right berfore the function call: n is a positive integer representing the square of some integer.
def func_6(n):
    i = 1
    sq_n = n ** 0.5
    divs = []
    while i <= sq_n:
        if n % i == 0:
            divs.append(i)
            if n / i != i:
                divs.append(n / i)
        
        i = i + 1
        
    #State of the program after the loop has been executed: `n` is a positive integer representing the square of some integer, `i` is `sq_n + 1`, `sq_n` is the square root of `n` and must be greater than or equal to 1, `divs` contains all divisors of `n` such that each divisor `d` and `n/d` are both added to `divs` if they are distinct; `divs` also contains 1 and `n` as these are always divisors of any integer
    return sorted(divs)
    #The program returns a sorted list of all divisors of n, including 1 and n, where each divisor d and n/d are both added to divs if they are distinct
#Overall this is what the function does:The function `func_6` accepts a positive integer `n` which is guaranteed to be a perfect square. It calculates all divisors of `n`, ensuring that both `d` and `n/d` are included in the result list `divs` if they are distinct. The function then sorts the list of divisors and returns it. The function correctly handles the case where `n` is a perfect square, and includes 1 and `n` as divisors. Potential edge cases, such as when `n` is 1 (the smallest perfect square), are handled appropriately, as 1 is its only divisor. The function does not handle non-perfect square inputs; if `n` is not a perfect square, it may still execute but will not produce the expected output of all divisors.

#Function 7:
#State of the program right berfore the function call: n is an integer greater than or equal to 1.
def func_7(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than or equal to 1, and `n` is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is an integer greater than or equal to 1, and `n` is greater than 1, and n is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than or equal to 1, and `n` is not greater than 1, and `n` is not greater than 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i += 6
        
    #State of the program after the loop has been executed: 'i' is the smallest integer \( k \) such that \( k^2 > n \) and \( k \mod 6 \) is the remainder of \( i \) after the last valid increment, and the loop does not return False within the loop.
    return True
    #The program returns True
#Overall this is what the function does:The function `func_7` accepts an integer `n` and returns `True` under specific conditions and `False` otherwise. Specifically, it returns `True` if `n` is 2, 3, or if no divisors are found up to the square root of `n` when checking for divisibility by 2, 3, and numbers of the form \(6k \pm 1\). It returns `False` for all other values of `n`.

#Function 8:
#State of the program right berfore the function call: arr is a sorted list of integers, x is an integer, low is an integer representing the lower bound index for the search range, and high is an integer representing the upper bound index for the search range such that 0 <= low <= high < len(arr).
def func_8(arr, x, low, high):
    if (high >= low) :
        mid = (high + low) // 2
        if (arr[mid] == x) :
            return mid, mid
            #`The program returns mid, mid` where `mid` is calculated as (high + low) // 2 and its value is equal to `x`
        else :
            if (arr[mid] > x) :
                return func_8(arr, x, low, mid - 1)
                #The program returns the result of the function call `func_8(arr, x, low, mid - 1)` where `arr` is a sorted list of integers, `x` is an integer, `low` is the lower bound index, `mid - 1` is the new upper bound index for the search range
            else :
                return func_8(arr, x, mid + 1, high)
                #The program returns the result of the function `func_8(arr, x, mid + 1, high)` where `arr` is a sorted list of integers, `x` is an integer, `mid + 1` is the new lower bound index, and `high` remains the same upper bound index
    else :
        return high, low
        #`The program returns high and low`
#Overall this is what the function does:The function `func_8` performs a binary search on a sorted list `arr` to find the integer `x`. If `x` is found, it returns the index `mid` twice. If `x` is not found, it narrows the search range by either updating the lower bound index (`low`) or the upper bound index (`high`) and calls itself recursively. If the search range is exhausted (i.e., `high < low`), it returns the values of `high` and `low`. The function covers the following cases:
- If `x` is found at the middle index, it returns `mid, mid`.
- If `x` is less than the middle element, it searches the left half by calling `func_8(arr, x, low, mid - 1)`.
- If `x` is greater than the middle element, it searches the right half by calling `func_8(arr, x, mid + 1, high)`.
- If the search range is exhausted, it returns `high, low`.

Potential edge cases include when `x` is not present in `arr`, which causes the function to continue narrowing the search range until `high < low`.

#Function 9:
#State of the program right berfore the function call: primes is a sorted list of prime numbers, d is an integer such that 1 <= d <= 10000, and i and j are indices within the range of the primes list.
def func_9():
    d = func_1()
    i = func_8(primes, d + 1, 0, len(primes) - 1)[1]
    j = i + 1
    while primes[j] - primes[i] < d:
        j += 1
        
    #State of the program after the loop has been executed: `primes` is a sorted list of prime numbers, `d` is the value returned by `func_1()`, `i` is the first element of the tuple returned by `func_8(primes, d + 1, 0, len(primes) - 1)`, `j` is the index such that `primes[j] - primes[i]` is the smallest difference that is still less than `d`, and `j` is the last index where the condition `primes[j] - primes[i] < d` holds true.
    print(primes[i] * primes[j])
#Overall this is what the function does:The function accepts no parameters and does not return anything directly. Instead, it calculates two indices `i` and `j` within a predefined sorted list of prime numbers `primes` such that the difference between `primes[j]` and `primes[i]` is the smallest value greater than or equal to `d + 1`. After finding these indices, it prints the product of the primes at these indices. If `d` is such that no such pair of primes exists (e.g., `d` is too large), the function will either exit the loop without finding a suitable pair or raise an error if the loop conditions are not met properly.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.