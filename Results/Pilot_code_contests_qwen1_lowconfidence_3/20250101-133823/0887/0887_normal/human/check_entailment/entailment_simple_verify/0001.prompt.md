
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.

The players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.

After a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.

You are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?

Input

The first line contains a single integer n (1 ≤ n ≤ 105) — the number of black points.

The (i + 1)-th line contains two integers xi, yi ( - 105 ≤ xi, yi, ≤ 105) — the coordinates of the point where the i-th black token is initially located.

It is guaranteed that initial positions of black tokens are distinct.

Output

Print the number of points where the white token can be located initially, such that if both players play optimally, the black player wins.

Examples

Input

4
-2 -1
0 1
0 -3
2 -1


Output

4


Input

4
-2 0
-1 1
0 -2
1 -1


Output

2


Input

16
2 1
1 2
-1 1
0 1
0 0
1 1
2 -1
2 0
1 0
-1 -1
1 -1
2 2
0 -1
-1 0
0 2
-1 2


Output

4

Note

In the first and second examples initial positions of black tokens are shown with black points, possible positions of the white token (such that the black player wins) are shown with white points.

The first example: <image>

The second example: <image>

In the third example the white tokens should be located in the inner square 2 × 2, to make the black player win. <image>
Program:
```
from sys import*
from itertools import*
#Function 1:
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        if lmn[x] > y:
            lmn[x] = y
        if lmx[x] < y:
            lmx[x] = y
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
    return ans

#Function 2:
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        (x, y) = dat[i * 2:i * 2 + 2]
        s[x + y & 1].append((-x + y, x + y))
    print(func_1(s[0]) + func_1(s[1]))


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly implement the logic described in the problem statement. Specifically, the function `func_1` seems to attempt to calculate the number of valid starting positions for the white token, but it does not accurately reflect the game's rules.

1. **Incorrect Calculation of Valid Positions**: The function `func_1` uses a fixed range of 400010 and performs operations on this range without considering the actual positions of the black tokens. This fixed range is likely too large and does not account for the relative positions of the black tokens correctly.

2. **Misinterpretation of Movement Rules**: The program attempts to simulate movements and positions of tokens, but it does not correctly handle the constraints and rules of the game. For instance, it does not properly ensure that after a move by the white player, the white token cannot occupy the same position as any black token.

3. **Lack of Optimal Strategy Handling**: The problem requires the program to determine the number of starting positions for the white token such that the black player can always win if both players play optimally. The current implementation does not handle this optimal strategy correctly.

To verify this, consider the following test case:

### Test Case:
```
Input:
4
-2 0
-1 1
0 -2
1 -1
```

Expected Output:
```
2
```

However, the provided program outputs:
```
4
```

This discrepancy indicates that the program is not correctly calculating the number of valid starting positions for the white token. The program incorrectly counts more positions than it should, failing to account for the strategic constraints of the game.

Therefore, the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import*
from itertools import*

func_2()

#Function 1:
#State of the program right berfore the function call: a is a list of tuples, where each tuple contains two integers representing the x and y coordinates of a black token's initial position. All coordinates are integers within the range \([-10^5, 10^5]\), and the positions are distinct.
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        
        if lmn[x] > y:
            lmn[x] = y
        
        if lmx[x] < y:
            lmx[x] = y
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples that may or may not have had their x values updated based on the condition `lmx[x] < y` for each tuple `(x, y)` in `a`. For every tuple `(x, y)` in `a`, if `lmx[x]` was less than `y` before the update, `lmn[x]` will be set to `y` and `x` will be updated to `((x - 1) / 2 + 100005)`. The lists `lmn` and `lmx` are updated accordingly for the x values that meet the condition. If the loop does not execute at all (i.e., `a` is an empty list), then `a`, `lmn`, and `lmx` remain in their initial states.
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
        
    #State of the program after the  for loop has been executed: `lmn` is a list such that for all indices `i` (0 ≤ i < len(lmn) - 1), `lmn[i + 1]` is less than or equal to `lmn[i]`; `lmx` is in its previous state; `rmn` is a shallow copy of `lmn`; `rmx` is a shallow copy of `lmx`; `i` is 200008.
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
        
    #State of the program after the  for loop has been executed: `lmn` is a non-increasing list, `lmx` is in its previous state with `lmx[i]` for all `i` unchanged, `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`, `i` is 200009.
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
        
    #State of the program after the  for loop has been executed: `rmn[i]` is equal to the minimum value in the list `rmn` for all `i` from 0 to 200008, `rmx[i]` is unchanged for all `i`, `i` is 0.
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
        
    #State of the program after the  for loop has been executed: Let's analyze the loop step by step to determine the final state of the variables after all iterations have finished.
    #
    #### Initial State
    #- `rmn[i]` is equal to the minimum value in the list `rmn` for all `i` from 0 to 200008.
    #- `rmx[i]` is unchanged for all `i`.
    #- `i` is 0.
    #
    #### Loop Code
    #```python
    #for i in xrange(200009, 0, -1):
    #    if rmx[i - 1] < rmx[i]:
    #        rmx[i - 1] = rmx[i]
    #```
    #
    #### Observations from Provided Output States
    #- After 1 iteration (`i` is 200008): `rmx[200008]` equals `rmx[200009]`.
    #- After 2 iterations (`i` is 200007): `rmx[200006]` equals `rmx[200007]` and `rmx[200007]` equals `rmx[200008]`.
    #- After 3 iterations (`i` is 200006): `rmx[200005]` equals `rmx[200006]` and `rmx[200007]` equals `rmx[200006]`.
    #
    #### General Pattern
    #Each iteration updates `rmx[i-1]` to be equal to `rmx[i]` if the condition `rmx[i-1] < rmx[i]` is satisfied. This process continues until `i` reaches 1.
    #
    #### Final State Analysis
    #When the loop completes, `i` will be 1. At this point, the only value that hasn't been compared is `rmx[0]` and `rmx[1]`. However, since all subsequent values of `rmx` from `i=2` to `i=200008` have already been updated to be equal to the next higher index value, we need to consider the relationship between `rmx[0]` and `rmx[1]`.
    #
    #Since the loop ensures that each `rmx[i-1]` is updated to be equal to `rmx[i]` if `rmx[i-1] < rmx[i]`, and this process starts from `i=200009` down to `i=1`, the final state will ensure that `rmx[0]` is the maximum value among all `rmx[i]` for `i` from 1 to 200008.
    #
    #### Output State
    #After the loop completes, the value of `rmx[i]` for all `i` from 0 to 200008 will be equal to the maximum value of `rmx[i]` for all `i` from 1 to 200008. The variable `i` will be 1.
    #
    #**Output State:**
    #- `i` is 1.
    #- For all `i` from 0 to 200008, `rmx[i]` is the maximum value of `rmx[i]` for `i` from 1 to 200008.
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
        
    #State of the program after the  for loop has been executed: - `i` is 200009.
    #- For all `i` from 0 to 200008, `lmn[i]` is equal to `rmn[i]`.
    #
    #Output State:
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
        
    #State of the program after the  for loop has been executed: For all `i` from 0 to 200008, if `lmx[i] > rmx[i]`, then `lmn[i]` is equal to `rmn[i]` and `lmx[i]` is now equal to `rmx[i]`; otherwise, `lmn[i]` and `lmx[i]` remain unchanged as they were originally.
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
        
    #State of the program after the  for loop has been executed: `lmn` array is such that for all valid `i` (0 to 200007), `lmn[i]` is the minimum value between `lmn[i]` and `lmn[i + 1]`, `lmx` and `rmx` arrays are defined and contain appropriate values, `ans` is 0.
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
        
    #State of the program after the  for loop has been executed: `lmn` array remains such that for all valid `i` (0 to 200007), `lmn[i]` is the minimum value between `lmn[i]` and `lmn[i + 1]`; `lmx` array is updated such that for all valid `i` (0 to 200008), `lmx[i]` is equal to `lmx[i + 1]`; `rmx` array remains unchanged; `ans` is 0.
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
        
    #State of the program after the  for loop has been executed: `lmn` array remains such that for all valid `i` (0 to 200007), `lmn[i]` is the minimum value between `lmn[i]` and `lmn[i + 1]`, `lmx` array remains such that for all valid `i` (0 to 200008), `lmx[i]` is equal to `lmx[i + 1]`, `rmx` array remains unchanged, and `ans` is the sum of `(lmx[i] - lmn[i]) / 2` for all `i` where `lmn[i] < lmx[i]` and the loop iterates from `i = 0` to `i = 200008`.
    return ans
    #The program returns the sum of (lmx[i] - lmn[i]) / 2 for all i where lmn[i] < lmx[i] and the loop iterates from i = 0 to i = 200008

#Function 2:
#State of the program right berfore the function call: `n` is an integer representing the number of black tokens, and `dat` is an iterable containing pairs of integers representing the x and y coordinates of each black token. The tokens' coordinates are read from standard input in a way that `dat` is a flat sequence of 2*n integers, with each pair of integers representing the coordinates of one black token.
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        x, y = dat[i * 2:i * 2 + 2]
        
        s[x + y & 1].append((-x + y, x + y))
        
    #State of the program after the  for loop has been executed: Let's analyze the loop step by step to determine the final state of the variables after all iterations of the loop have finished.
    #
    #### Loop Code Analysis
    #The loop iterates over the range from 0 to \( n-1 \). For each iteration \( i \), it extracts two elements from the `dat` list and assigns them to `x` and `y`. It then appends a tuple `(-x + y, x + y)` to the appropriate list in `s` based on the condition `x + y & 1`.
    #
    #### Iteration Details
    #- **First Iteration (i=0):**
    #  - `x` is `dat[0]`
    #  - `y` is `dat[1]`
    #  - `s[x + y & 1]` is updated with the tuple `(-dat[0] + dat[1], dat[0] + dat[1])`
    #
    #- **Second Iteration (i=1):**
    #  - `x` is `dat[2]`
    #  - `y` is `dat[3]`
    #  - `s[x + y & 1]` is updated with the tuple `(-dat[2] + dat[3], dat[2] + dat[3])`
    #
    #- **Third Iteration (i=2):**
    #  - `x` is `dat[4]`
    #  - `y` is `dat[5]`
    #  - `s[x + y & 1]` is updated with the tuple `(-dat[4] + dat[5], dat[4] + dat[5])`
    #
    #### General Pattern
    #- After the loop finishes, the `s` list will contain two sublists where each sublist contains tuples of the form `(-x + y, x + y)` depending on whether `x + y` is even or odd.
    #
    #### Final Output State
    #Since the loop will execute exactly \( n \) times if `n > 0`, the final state of the variables will be as follows:
    #
    #- `n` will be the number of black tokens, and `n` must be a non-negative integer.
    #- `dat` will remain unchanged, as it is only read from during the loop.
    #- `s` will be a list containing two sublists. Each sublist will contain tuples `(-x + y, x + y)` where `x` and `y` are the coordinates of the black tokens such that `x + y` is even or odd respectively.
    #
    #### Output State
    #**Output State:**
    #``n` is a non-negative integer, `dat` is an iterable of integers representing the coordinates of each black token, `s` is a list containing two sublists where the first sublist contains tuples `(-x + y, x + y)` for even `x + y` and the second sublist contains tuples for odd `x + y`.
    #```
    print(func_1(s[0]) + func_1(s[1]))



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
