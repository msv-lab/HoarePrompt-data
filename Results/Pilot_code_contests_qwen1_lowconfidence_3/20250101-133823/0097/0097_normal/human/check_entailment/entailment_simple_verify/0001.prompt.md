
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Program:
```
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys
#Function 1:
def func_1():
    import sys, re, math
    from collections import deque, defaultdict, Counter, OrderedDict
    from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, floor
    from heapq import heappush, heappop, heapify, nlargest, nsmallest








    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        zz = []
        for _ in range(n):
            zz.append(LIST())
        prevplay = 0
        prevClr = 0
        flag = 0
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        if flag == 1:
            print('NO')
        else:
            print('YES')
        t -= 1

#Function 2:
def STR():
    return list(input())

#Function 3:
def INT():
    return int(input())

#Function 4:
def MAP():
    return map(int, input().split())

#Function 5:
def LIST():
    return list(map(int, input().split()))

#Function 6:
def list2d(a, b, c):
    return [[c] * b for i in range(a)]

#Function 7:
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])

#Function 8:
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
    return toret

#Function 9:
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))

#Function 10:
def func_2(zero=0):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            i += 1
    except:
        pass
    if s and s[-1] >= b'0'[0]:
        A.append(sign * numb)
    return A


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not handle all potential cases correctly according to the problem description. Specifically, the program fails to validate that the number of clears (`c_i`) never exceeds the number of plays (`p_i`) between any two consecutive moments. 

Consider the following test case:

- Input:
  ```
  1
  3
  0 0
  1 1
  1 2
  ```

- Expected Output:
  ```
  NO
  ```

- Actual Output:
  The program outputs `YES` because it does not properly handle the condition where the number of clears exceeds the number of plays.

The issue arises in the loop where the program checks if the current state of plays and clears is valid. The condition `if zz[i][1] > prevClr:` should ensure that the number of clears does not exceed the number of plays. However, the subsequent check `if temp > temp1:` only checks if the difference in clears is greater than the difference in plays, which is not sufficient to guarantee the correctness of the sequence.

To fix this, the program needs to explicitly ensure that at no point does the number of clears exceed the number of plays. Here’s a corrected version of the relevant part of the code:

```python
for i in range(n):
    if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
        flag = 1
        break
    if zz[i][1] > zz[i][0]:  # Ensure clears do not exceed plays
        flag = 1
        break
    if zz[i][1] > prevClr:
        temp = zz[i][1] - prevClr
        temp1 = zz[i][0] - prevplay
        if temp > temp1:
            flag = 1
            break
    prevplay = zz[i][0]
    prevClr = zz[i][1]
```

This ensures that the program correctly checks the condition that the number of clears should never exceed the number of plays at any point in the sequence.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
class ostream:

    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 100, and for each pair (p_i, c_i) in the input, 0 <= p_i, c_i <= 1000. The pairs (p_i, c_i) are provided in chronological order.
def func_1():
    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        
        zz = []
        
        for _ in range(n):
            zz.append(LIST())
        
        prevplay = 0
        
        prevClr = 0
        
        flag = 0
        
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        
        if flag == 1:
            print('NO')
        else:
            print('YES')
        
        t -= 1
        
    #State of the program after the loop has been executed: `t` is 0, `n` is a non-negative integer, `zz` is a list containing `n` empty lists, `prevplay` is `zz[n-1][0]` if the loop ran at least once, `prevClr` is `zz[n-1][1]` if the loop ran at least once, and the console prints 'YES' if no conditions were violated during any iteration, otherwise prints 'NO'.

#Function 2:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 500. For each test case, n is an integer such that 1 ≤ n ≤ 100. Each pair (p_i, c_i) consists of two non-negative integers such that 0 ≤ p_i, c_i ≤ 1000, and the pairs are given in chronological order.
def STR():
    return list(input())
    #The program returns a list of strings representing the input pairs (p_i, c_i)

#Function 3:
#State of the program right berfore the function call: T is an integer such that 1 <= T <= 500. For each test case, n is an integer such that 1 <= n <= 100. Each pair (p_i, c_i) consists of integers such that 0 <= p_i, c_i <= 1000, and the pairs are given in chronological order.
def INT():
    return int(input())
    #The program returns an integer input provided by the user, which is within the range of 1 <= T <= 500

#Function 4:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 500. For each test case, n is an integer such that 1 ≤ n ≤ 100. Each pair (p_i, c_i) consists of two integers such that 0 ≤ p_i, c_i ≤ 1000, and the pairs are given in chronological order.
def MAP():
    return map(int, input().split())
    #The program returns a tuple of integers (p_i, c_i) entered by the user, where the pairs are given in chronological order

#Function 5:
#State of the program right berfore the function call: T is a positive integer such that 1 <= T <= 500. For each test case, n is a positive integer such that 1 <= n <= 100. Each pair (p_i, c_i) consists of non-negative integers such that 0 <= p_i, c_i <= 1000, and the pairs are provided in chronological order.
def LIST():
    return list(map(int, input().split()))
    #The program returns a list of integers created from user input split by spaces, where each integer corresponds to the input values of T and n for each test case, followed by pairs of integers (p_i, c_i)

#Function 6:
#State of the program right berfore the function call: a and b are non-negative integers representing the dimensions of the 2D list, and c is an integer representing the value to fill the list with.
def list2d(a, b, c):
    return [([c] * b) for i in range(a)]
    #The program returns a 2D list with 'a' rows and 'b' columns, where each element in the list is filled with the integer 'c'

#Function 7:
#State of the program right berfore the function call: listOfTuples is a list of tuples, each tuple contains at least two integers, and idx is an integer representing the index of the tuple to sort by.
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])
    #`The program returns a list of tuples sorted based on the element at index 'idx' within each tuple`

#Function 8:
#State of the program right berfore the function call: 
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
        
    #State of the program after the  for loop has been executed: `passedDic` is unchanged, `temp` is an empty list or contains elements sorted by the value of key-value pairs in `passedDic` (with ties broken by key), `toret` is a dictionary containing all key-value pairs from `temp`.
    return toret
    #`theprogramreturnsadictionarycontainingallkey-valuerestfromtemp`

#Function 9:
#State of the program right berfore the function call: passedDic is a dictionary where the keys are integers representing the moments of time (starting from 0) and the values are tuples of two integers (p_i, c_i) representing the number of plays and the number of clears at that moment of time. The dictionary is ordered by keys in ascending order.
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))
    #The program returns a dictionary where the keys are integers representing the moments of time (starting from 0) and the values are tuples of two integers (p_i, c_i) representing the number of plays and the number of clears at that moment of time. The dictionary is ordered by keys in ascending order

#Function 10:
#State of the program right berfore the function call: zero is an integer representing the initial number to accumulate digits into numb, conv is a function to convert characters to their numeric value (assuming ord is used in Python 2 and a lambda function is used in Python 3), and s is a bytes object containing the input stream from stdin.
def func_2(zero):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            
            i += 1
            
        #State of the program after the loop has been executed: `s` is a non-empty bytes object, `i` is equal to the length of `s`, `sign` is -1 if the first character of `s` was `b'-'[0]`, otherwise `sign` is 1, `numb` is the integer representation of the number formed by the digits in `s` (ignoring any leading '-' sign), `zero` remains unchanged, `A` contains all the numbers formed from the segments in `s` (excluding any segments that start with `\r`), and `conv` remains unchanged.
    except:
        pass
    #State of the program after the try-except block has been executed: `s` is a non-empty bytes object, `i` is equal to the length of `s`, `sign` is -1 if the first character of `s` was `b'-'[0]`, otherwise `sign` is 1, `numb` is the integer representation of the number formed by the digits in `s` (ignoring any leading '-' sign), `zero` remains unchanged, `A` contains all the numbers formed from the segments in `s` (excluding any segments that start with `\r`), and `conv` remains unchanged.
    if (s and s[-1] >= b'0'[0]) :
        A.append(sign * numb)
    #State of the program after the if block has been executed: *`s` is a non-empty bytes object, `i` is equal to the length of `s`, `sign` is -1 if the first character of `s` was `b'-'[0]`, otherwise `sign` is 1, `numb` is the integer representation of the number formed by the digits in `s` (ignoring any leading '-' sign), `zero` remains unchanged, `A` contains all the numbers formed from the segments in `s` (excluding any segments that start with `\r`), and `conv` remains unchanged. If the last character of `s` is greater than or equal to `b'0'[0]`, then `sign * numb` is appended to `A`.
    return A
    #`A` contains all the numbers formed from the segments in `s` (excluding any segments that start with `\r`), and if the last character of `s` is greater than or equal to `b'0'[0]`, then `sign * numb` is also appended to `A`.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
