
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Program:
```
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys
#Function 1:
def func_1():
    import sys, re, math
    from collections import deque, defaultdict, Counter, OrderedDict
    from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, floor
    from heapq import heappush, heappop, heapify, nlargest, nsmallest








    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        zz = []
        for _ in range(n):
            zz.append(LIST())
        prevplay = 0
        prevClr = 0
        flag = 0
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        if flag == 1:
            print('NO')
        else:
            print('YES')
        t -= 1

#Function 2:
def STR():
    return list(input())

#Function 3:
def INT():
    return int(input())

#Function 4:
def MAP():
    return map(int, input().split())

#Function 5:
def LIST():
    return list(map(int, input().split()))

#Function 6:
def list2d(a, b, c):
    return [[c] * b for i in range(a)]

#Function 7:
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])

#Function 8:
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
    return toret

#Function 9:
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))

#Function 10:
def func_2(zero=0):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            i += 1
    except:
        pass
    if s and s[-1] >= b'0'[0]:
        A.append(sign * numb)
    return A


```
Original Assessment: Correctness: **False**

Explanation: The provided program has several issues that violate the problem description:

1. **Incorrect Handling of Decreasing Values**: The program does not handle cases where the number of clears (`c_i`) decreases relative to the previous value. For instance, if `c_i` is less than `prevClr`, it should be flagged as incorrect. However, the current logic does not account for this scenario.

2. **Incorrect Logic for Checking Play and Clear Counts**: The condition `if zz[i][0] < zz[i][1]:` should be checked to ensure that the number of plays is never less than the number of clears. The current implementation does not enforce this condition properly.

3. **Incomplete Implementation**: The program includes unused functions and seems to be a mix of different approaches. The main logic for checking the validity of the stats is not correctly implemented.

Here is an example where the program does not work as expected:

Consider the following input:
```
3
0 0
1 1
1 2
```

Expected output: **NO** because at the third moment, the number of clears increased but the number of plays did not, which is impossible according to the problem description.

However, the provided program might output **YES**, which is incorrect.

To fix these issues, the program needs to correctly implement the logic to check if the number of plays is always greater than or equal to the number of clears and ensure that the number of clears does not decrease relative to the previous value.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 10 : The function `func_2` takes an integer `zero` as a parameter and processes a bytes object `s` to extract numbers from it. It accumulates these numbers into a list `A`, excluding any segments that start with `\r`. If the last character of `s` is a digit (i.e., greater than or equal to `b'0'[0]`), it appends `sign * numb` to `A`, where `numb` is the integer representation of the number formed by the digits in `s`, and `sign` is either 1 or -1 depending on whether `s` starts with a `-`. The function ultimately returns the list `A` containing all the extracted numbers.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
