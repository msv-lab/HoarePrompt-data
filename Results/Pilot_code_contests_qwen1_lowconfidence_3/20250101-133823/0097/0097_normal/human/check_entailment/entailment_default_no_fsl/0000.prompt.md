
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Functions with output description for each function:
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
class ostream:

    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
if __name__ == '__main__':
    func_1()

Function number 1 :
 Code:
 '''
def func_1():
    import sys, re, math
    from collections import deque, defaultdict, Counter, OrderedDict
    from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, floor
    from heapq import heappush, heappop, heapify, nlargest, nsmallest








    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        zz = []
        for _ in range(n):
            zz.append(LIST())
        prevplay = 0
        prevClr = 0
        flag = 0
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        if flag == 1:
            print('NO')
        else:
            print('YES')
        t -= 1
''' 

 Output hints for function1:  The function processes a series of pairs \((p_i, c_i)\) where \(p_i\) and \(c_i\) are integers. It checks whether the sequence of pairs is valid based on specific conditions. If any condition is violated, the function prints 'NO'; otherwise, it prints 'YES'. The function does not accept any parameters and returns nothing explicitly. After the function concludes, the console will display either 'YES' or 'NO' based on the validation process. The function handles the following edge cases:
1. If \(t\) (the number of test cases) is 0, no further processing occurs.
2. If any pair \((p_i, c_i)\) violates the conditions (i.e., \(p_i < \text{prevplay}\), \(c_i < \text{prevClr}\), or \(p_i < c_i\)), the function immediately prints 'NO'.
3. If none of the conditions are violated, the function prints 'YES'.

The function also ensures that the values of `prevplay` and `prevClr` are updated correctly within the loop.
Function number 2 :
 Code:
 '''
def STR():
    return list(input())
''' 

 Output hints for function2:  The function `STR()` reads a single line of input from the user and returns it as a list of strings. This input is expected to consist of a series of pairs (p_i, c_i), where each pair is a string representation of two non-negative integers separated by whitespace. The function does not perform any validation on the input format, so it is assumed that the input adheres to the specified format. If the input does not conform to the expected format, the behavior of the function is undefined.
Function number 3 :
 Code:
 '''
def INT():
    return int(input())
''' 

 Output hints for function3:  The function `INT()` accepts no parameters and reads an integer input from the user. This input is guaranteed to be within the range of 1 to 500 (inclusive). The function then returns this integer. There are no additional actions or conditions performed by the function beyond reading the input and returning it. Potential edge cases include the user providing an input outside the specified range, in which case the behavior is not defined by the provided code; the function will simply return whatever integer is provided by the user.
Function number 4 :
 Code:
 '''
def MAP():
    return map(int, input().split())
''' 

 Output hints for function4:  The function reads a series of pairs of integers (p_i, c_i) from user input, where each pair is separated by a space and the pairs themselves are separated by newlines. It processes this input to form a tuple containing these pairs in the exact order they were entered. The function does not accept any parameters and returns the resulting tuple. The function handles the input format as specified, ensuring that the pairs are read in chronological order as provided by the user. Potential edge cases include invalid input formats (e.g., non-integer values or incorrect separators), which would result in the function terminating due to the `map` function raising a `ValueError`. If the input strictly follows the format, the function will correctly return a tuple of tuples, where each inner tuple contains two integers (p_i, c_i).
Function number 5 :
 Code:
 '''
def LIST():
    return list(map(int, input().split()))
''' 

 Output hints for function5:  Functionality: The function reads user input and processes it to create a list of integers. This list contains the number of test cases `T`, followed by the number of elements `n` for each test case, and then pairs of integers `(p_i, c_i)` for each element within the test cases. The function returns this list. 

The function handles the following cases:
- It accepts user input split by spaces, which must be in the correct format (e.g., "T n p_i c_i ...").
- It ensures that `T` is a positive integer within the range `[1, 500]`.
- It ensures that `n` is a positive integer within the range `[1, 100]`.
- It processes up to 100 pairs `(p_i, c_i)` for each test case, where each pair is a non-negative integer within the range `[0, 1000]`.

Potential edge cases include:
- If the input format is incorrect (e.g., missing values or incorrect types), the function will not correctly parse the input, leading to incorrect results.
- If the number of test cases `T` exceeds 500 or the number of elements `n` per test case exceeds 100, the function will not process additional values beyond these limits.

Missing functionality:
- There is no validation or error handling for incorrect input formats or values outside the specified ranges. If invalid input is provided, the function may produce incorrect output or unexpected behavior.
Function number 6 :
 Code:
 '''
def list2d(a, b, c):
    return [[c] * b for i in range(a)]
''' 

 Output hints for function6:  The function `list2d` accepts three parameters: `a`, `b`, and `c`. Here, `a` and `b` are non-negative integers representing the dimensions of the 2D list, and `c` is an integer representing the value to fill the list with. The function returns a 2D list with `a` rows and `b` columns, where each element in the list is filled with the integer `c`. The function handles the case where `a` or `b` is zero by creating an empty list if either dimension is zero. There is no missing functionality in the provided code.
Function number 7 :
 Code:
 '''
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])
''' 

 Output hints for function7:  The function `sortListWithIndex` accepts a list of tuples, where each tuple contains at least two integers, and an integer index `idx`. It returns a new list of tuples sorted based on the value at the specified index within each tuple. The function does not modify the original list. Potential edge cases include empty lists, lists with only one tuple, or invalid indices (e.g., indices that exceed the length of the tuples). The function correctly sorts the list based on the provided index, but it does not handle these edge cases explicitly in the given code.
Function number 8 :
 Code:
 '''
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
    return toret
''' 

 Output hints for function8:  The function `sortDictWithVal` accepts a dictionary `passedDic` as a parameter and returns a new dictionary containing all key-value pairs from `passedDic`, sorted by the values of the key-value pairs. If two key-value pairs have the same value, they are sorted by their keys. The original dictionary `passedDic` remains unchanged. After the function execution, the returned dictionary has its items sorted according to the specified criteria. Potential edge cases include handling an empty input dictionary, where the returned dictionary will also be empty. There is no missing functionality in the provided code; it correctly sorts the dictionary as described.
Function number 9 :
 Code:
 '''
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))
''' 

 Output hints for function9:  The function `sortDictWithKey` accepts a dictionary `passedDic` as a parameter. This dictionary contains key-value pairs where the keys are integers representing moments of time, starting from 0, and the values are tuples of two integers (p_i, c_i), representing the number of plays and the number of clears at those moments. The function sorts this dictionary based on its keys in ascending order and then returns the sorted dictionary. This ensures that the returned dictionary maintains the order of time moments from earliest to latest while preserving the associated (p_i, c_i) values. Potential edge cases include the scenario where the input dictionary is empty or already sorted, in which case the function still returns the same dictionary. There is no missing functionality as the provided code accurately implements the described behavior.
Function number 10 :
 Code:
 '''
def func_2(zero=0):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            i += 1
    except:
        pass
    if s and s[-1] >= b'0'[0]:
        A.append(sign * numb)
    return A
''' 

 Output hints for function10:  The function `func_2` takes an integer `zero` as a parameter and processes a bytes object `s` to extract numbers from it. It accumulates these numbers into a list `A`, excluding any segments that start with `\r`. If the last character of `s` is a digit (i.e., greater than or equal to `b'0'[0]`), it appends `sign * numb` to `A`, where `numb` is the integer representation of the number formed by the digits in `s`, and `sign` is either 1 or -1 depending on whether `s` starts with a `-`. The function ultimately returns the list `A` containing all the extracted numbers.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.