
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Mahmoud wrote a message s of length n. He wants to send it as a birthday present to his friend Moaz who likes strings. He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string. That's because this magical paper doesn't allow character number i in the English alphabet to be written on it in a string of length more than ai. For example, if a1 = 2 he can't write character 'a' on this paper in a string of length 3 or more. String "aa" is allowed while string "aaa" is not.

Mahmoud decided to split the message into some non-empty substrings so that he can write every substring on an independent magical paper and fulfill the condition. The sum of their lengths should be n and they shouldn't overlap. For example, if a1 = 2 and he wants to send string "aaa", he can split it into "a" and "aa" and use 2 magical papers, or into "a", "a" and "a" and use 3 magical papers. He can't split it into "aa" and "aa" because the sum of their lengths is greater than n. He can split the message into single string if it fulfills the conditions.

A substring of string s is a string that consists of some consecutive characters from string s, strings "ab", "abc" and "b" are substrings of string "abc", while strings "acb" and "ac" are not. Any string is a substring of itself.

While Mahmoud was thinking of how to split the message, Ehab told him that there are many ways to split it. After that Mahmoud asked you three questions: 

  * How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper, the sum of their lengths is n and they don't overlap? Compute the answer modulo 109 + 7. 
  * What is the maximum length of a substring that can appear in some valid splitting? 
  * What is the minimum number of substrings the message can be spit in? 



Two ways are considered different, if the sets of split positions differ. For example, splitting "aa|a" and "a|aa" are considered different splittings of message "aaa".

Input

The first line contains an integer n (1 ≤ n ≤ 103) denoting the length of the message.

The second line contains the message s of length n that consists of lowercase English letters.

The third line contains 26 integers a1, a2, ..., a26 (1 ≤ ax ≤ 103) — the maximum lengths of substring each letter can appear in.

Output

Print three lines.

In the first line print the number of ways to split the message into substrings and fulfill the conditions mentioned in the problem modulo 109 + 7.

In the second line print the length of the longest substring over all the ways.

In the third line print the minimum number of substrings over all the ways.

Examples

Input

3
aab
2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1


Output

3
2
2


Input

10
abcdeabcde
5 5 5 5 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1


Output

401
4
3

Note

In the first example the three ways to split the message are: 

  * a|a|b
  * aa|b
  * a|ab



The longest substrings are "aa" and "ab" of length 2.

The minimum number of substrings is 2 in "a|ab" or "aa|b".

Notice that "aab" is not a possible splitting because the letter 'a' appears in a substring of length 3, while a1 = 2.
Program:
```
from __future__ import print_function

def func():
    n = input()
    str = raw_input()
    arr = raw_input().split()
    arr = map(eval, arr)
    MOD = 1000000000.0 + 7
    dp = [0] * 3200
    dp[0] = 1
    lastMatch = [0] * 3200
    for i in range(len(lastMatch)):
        lastMatch[i] = i
    maxSubLen = 0
    for i in range(1, len(str) + 1):
        j = 1
        k = arr[ord(str[i - 1]) - ord('a')]
        while j <= k and i - j >= 0:
            maxSubLen = max(j, maxSubLen)
            dp[i] = (dp[i] + dp[i - j]) % MOD
            t = i - j - 1
            lastMatch[t + 1] = max(lastMatch[t + 1], i - 1)
            t = t if t > 0 else 0
            k = min(k, arr[ord(str[t]) - ord('a')])
            j += 1
    lastIndex = 0
    lastStrIndex = len(str) - 1
    subNum = 0
    while lastIndex != lastStrIndex:
        subNum += 1
        if lastIndex == lastMatch[lastIndex]:
            lastIndex += 1
        else:
            lastIndex = lastMatch[lastIndex]
    print(dp[len(str)], maxSubLen, subNum, sep='\n')


```
Original Assessment: Correctness: **False**.

Explanation: The provided program has several issues that make it incorrect according to the problem description:

1. **Incorrect Input Handling**: The program uses `input()` and `raw_input()` functions which are not standard Python 3 functions. Instead, it should use `int(input())` for reading integers and `input().strip()` for reading strings. However, the main issue here is that the program does not properly handle the input types and lengths as specified.

2. **Dynamic Programming Logic**: The dynamic programming logic used in the program is incorrect. It attempts to count the number of ways to split the string based on the constraints, but it does not correctly implement the logic to ensure substrings do not exceed the allowed lengths for each character.

3. **Variable Naming and Initialization**: The variable names and initializations are not consistent with the problem description. For example, `arr` should be initialized to store the maximum lengths for each character, but the program does not properly update these values based on the input.

4. **Calculation of Maximum Substring Length**: The logic to calculate the maximum substring length (`maxSubLen`) is flawed. The program updates `maxSubLen` based on the current position `i` and the length `j`, but it does not correctly account for the constraints of the magical paper.

Here is a corrected version of the program that addresses these issues:

```python
def func():
    n = int(input())
    s = input().strip()
    a = list(map(int, input().strip().split()))
    MOD = 1000000007
    dp = [0] * (n + 1)
    dp[0] = 1
    max_sub_len = 0
    last_match = [0] * (n + 1)

    for i in range(1, n + 1):
        j = 1
        k = a[ord(s[i - 1]) - ord('a')]
        while j <= k and i - j >= 0:
            max_sub_len = max(j, max_sub_len)
            dp[i] = (dp[i] + dp[i - j]) % MOD
            t = i - j - 1
            last_match[t + 1] = max(last_match[t + 1], i - 1)
            j += 1

    last_index = 0
    sub_num = 0
    while last_index < n:
        sub_num += 1
        if last_index == last_match[last_index]:
            last_index += 1
        else:
            last_index = last_match[last_index]

    print(dp[n], max_sub_len, sub_num, sep='\n')

func()
```

This corrected version ensures that the program correctly handles the input, implements the dynamic programming logic to count the number of valid splits, and calculates the maximum substring length and minimum number of substrings.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import print_function

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10³, s is a string of length n consisting of lowercase English letters, and a1, a2, ..., a26 are 26 integers such that 1 ≤ ai ≤ 10³.
def func():
    n = input()
    str = raw_input()
    arr = raw_input().split()
    arr = map(eval, arr)
    MOD = 1000000000.0 + 7
    dp = [0] * 3200
    dp[0] = 1
    lastMatch = [0] * 3200
    for i in range(len(lastMatch)):
        lastMatch[i] = i
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 10^3\), `s` is a string of length `n` consisting of lowercase English letters, `str` is a string (the input from the user), `arr` is a list of evaluated expressions, `MOD` is `1000000007.0`, `dp` is a list of 3200 elements where the first element is 1 and the rest are 0, `lastMatch` is a list of 3200 elements where each element is its index `i`, and `len(lastMatch)` is 3200.
    maxSubLen = 0
    for i in range(1, len(str) + 1):
        j = 1
        
        k = arr[ord(str[i - 1]) - ord('a')]
        
        while j <= k and i - j >= 0:
            maxSubLen = max(j, maxSubLen)
            dp[i] = (dp[i] + dp[i - j]) % MOD
            t = i - j - 1
            lastMatch[t + 1] = max(lastMatch[t + 1], i - 1)
            t = t if t > 0 else 0
            k = min(k, arr[ord(str[t]) - ord('a')])
            j += 1
        
    #State of the program after the  for loop has been executed: `dp[i]` is the final value calculated by the loop operations, `j` is `i + 1`, `k` is the minimum value it was updated to during the loop iterations, `maxSubLen` is the maximum value of `j` during the loop iterations, `t` is `0` if `i - j - 1` is 0 or less, otherwise `t` is `i - j - 1`, `lastMatch` contains the maximum values it was updated to during the loop iterations, `arr`, `MOD`, `n`, `s`, `str`, `len(lastMatch)`, `maxSubLen`, and `dp[0]` remain unchanged.
    lastIndex = 0
    lastStrIndex = len(str) - 1
    subNum = 0
    while lastIndex != lastStrIndex:
        subNum += 1
        
        if lastIndex == lastMatch[lastIndex]:
            lastIndex += 1
        else:
            lastIndex = lastMatch[lastIndex]
        
    #State of the program after the loop has been executed: `dp[i]` is the final value calculated by the loop operations, `j` is `i + 1`, `k` is the minimum value it was updated to during the loop iterations, `maxSubLen` is the maximum value of `j` during the loop iterations, `t` is `0` if `i - j - 1` is 0 or less, otherwise `t` is `i - j - 1`, `lastMatch` contains the maximum values it was updated to during the loop iterations, `arr`, `MOD`, `n`, `s`, `str`, `lastStrIndex` is `len(str) - 1`, `maxSubLen`, `dp[0]`, and `lastIndex` is `lastStrIndex`, `subNum` is the total number of iterations the loop has executed.
    print(dp[len(str)], maxSubLen, subNum, sep='\n')
#Overall this is what the function does:The function processes a string `s` of length `n` and a list of integers `arr` representing lengths, to compute three values: the number of distinct substrings that can be formed based on the given lengths, the maximum length of a substring that meets a specific condition, and the number of operations required to achieve these results. Specifically, the function calculates:

1. `dp[len(str)]`: The number of distinct substrings of `s` that can be formed under certain conditions.
2. `maxSubLen`: The maximum length of a valid substring found during the computation.
3. `subNum`: The number of operations performed to determine the valid substrings.

The function reads the string `s` and a list of integers `arr` from the standard input. It then iterates through the string to update a dynamic programming array `dp` and a list `lastMatch` to track the last occurrence of valid substrings. After processing the string, it counts the number of distinct substrings and prints the results.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
