
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: In order to celebrate Twice's 5th anniversary, Tzuyu and Sana decided to play a game.

Tzuyu gave Sana two integers a and b and a really important quest.

In order to complete the quest, Sana has to output the smallest possible value of (a ⊕ x) + (b ⊕ x) for any given x, where ⊕ denotes the [bitwise XOR operation](http://en.wikipedia.org/wiki/Bitwise_operation#XOR). 

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^{4}). Description of the test cases follows.

The only line of each test case contains two integers a and b (1 ≤ a, b ≤ 10^{9}).

Output

For each testcase, output the smallest possible value of the given expression.

Example

Input


6
6 12
4 9
59 832
28 14
4925 2912
1 1


Output


10
13
891
18
6237
0

Note

For the first test case Sana can choose x=4 and the value will be (6 ⊕ 4) + (12 ⊕ 4) = 2 + 8 = 10. It can be shown that this is the smallest possible value.
Functions with output description for each function:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_18(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_19()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function `func_1` reads an integer input from the user and returns it. This integer is guaranteed to be within the range 1 ≤ t ≤ 10^4. There are no additional actions performed by the function other than reading the input and returning it. The function assumes that the user will provide a valid integer within the specified range, and no validation or error handling is included to ensure this condition is met.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` does not accept any parameters and returns a string representing the input test case obtained from user input. After the function concludes, the program state includes a string variable containing the input test case provided by the user. This input can be further processed elsewhere in the program. However, the function does not perform any additional processing on the input; it merely returns it as-is. There are no edge cases mentioned in the provided code, and the code aligns perfectly with the return postconditions.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function3:  The function `func_3()` reads input from standard input, which consists of multiple test cases, each containing two space-separated integers `a` and `b`. It processes the input to convert these integers into a map object. The map object contains tuples of integers `(a, b)` for each test case, where `1 ≤ a, b ≤ 10^9`. There are no edge cases mentioned in the annotations or code that need special handling. The function does not perform any additional operations on the integers `a` and `b` other than converting them from string to integer type.
Function number 4 :
 Code:
 '''
def func_4():
    return map(str, input().strip().split(' '))
''' 

 Output hints for function4:  The function `func_4()` accepts no explicit parameters but relies on user input to process a series of test cases. It reads an integer `t` representing the number of test cases, followed by `t` pairs of space-separated integers `a` and `b`. Each integer pair is processed such that `a` and `b` are converted to strings. The function then returns a map object containing these string representations of the integer pairs.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_3())
''' 

 Output hints for function5:  The function `func_5` accepts no parameters and returns a list generated by `func_3()`. Since `func_3()` is not defined in the given code snippet, the behavior of `func_5` is undefined. However, assuming `func_3()` is properly defined and returns a list, `func_5` will return this list. There are no explicit preconditions mentioned for `func_5`, but implicitly, it relies on `func_3()` having a valid return value. No additional actions or state changes are performed within `func_5`.
Function number 6 :
 Code:
 '''
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function6:  The function `func_6` sets the recursion limit and stack size for a new thread, then starts a new thread to execute the `main` function. The function does not accept any parameters and does not return any value. After the function concludes, a new thread is running and executing the `main` function, which implies that the outcome depends on the behavior of the `main` function. No specific state changes or calculations are performed by `func_6` itself.
Function number 7 :
 Code:
 '''
def func_7(item):
    return item[1]
''' 

 Output hints for function7:  The function `func_7` accepts a parameter `item`, which is expected to be a tuple or list containing exactly two integers. The function returns the second integer in `item`. There are no edge cases mentioned in the annotations or code that need special handling. The function simply extracts and returns the second element of the input, ensuring that the input is a tuple or list of exactly two integers. If the input does not meet these requirements, the behavior is not specified within the given code and annotations.
Function number 8 :
 Code:
 '''
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
''' 

 Output hints for function8:  The function `func_8` accepts a single parameter `l`, which is expected to be a list containing exactly two integers `[a, b]` where `1 <= a, b <= 10^9`. It returns a new list that is a sorted version of `l` in descending order based on the result of applying the `getKey` function to each element. If `l` does not contain exactly two elements, the function will raise a `ValueError`. No other modifications are made to the input list; the function works on a copy of the input list. The function does not handle cases where `l` contains more than two elements or elements outside the specified range.
Function number 9 :
 Code:
 '''
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function9:  The function `func_9` accepts three parameters: `n`, `m`, and `num`. Here, `n` and `m` are integers specifying the dimensions of the matrix, and `num` is an integer value to fill the matrix with. The function returns a matrix (list of lists) filled with the specified number `num`, of size `n` x `m`. The function does not have any edge cases or missing functionality; it correctly constructs and returns the matrix as described.
Function number 10 :
 Code:
 '''
def func_10(x):
    return x and (not x & x - 1)
''' 

 Output hints for function10:  The function `func_10` accepts a non-negative integer `x`. It returns `True` if `x` is 0 and `False` if `x` is any other non-zero non-negative integer. The function leverages the bitwise operation `x & (x - 1)` to check if `x` is a power of two. If `x` is a power of two, `x & (x - 1)` equals zero, which would result in `not x` being `True`. However, the given code does not correctly implement this logic; instead, it directly uses `return x and not x & x - 1`, which simplifies to `return x and x == 1` due to the properties of the bitwise AND operation. This means the function will return `True` only if `x` is exactly 1 and `False` otherwise. An edge case to consider is when `x` is 0, which should also return `True`, but the current implementation does not handle this correctly. Therefore, the function should be revised to correctly handle the edge case where `x` is 0.
Function number 11 :
 Code:
 '''
def func_11(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function11:  The function `func_11` accepts an integer `n` (where \(1 \leq n \leq 10^9\)) and returns a binary string representation of `n` without the '0b' prefix. The function converts the integer to its binary form using the built-in `bin()` function and then removes the '0b' prefix. The function handles the specified range of integers and correctly returns the binary string representation for any valid input within this range. There are no edge cases mentioned in the annotations or code that need special handling beyond the given range constraints.
Function number 12 :
 Code:
 '''
def func_12(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function12:  The function `func_12` accepts an integer `n` such that \(1 \leq n \leq 10^9\) and returns a list of integers where each integer is a digit from the number `n`. The function converts the integer `n` into a string, then iterates over each character in the string representation of `n`, converting each character back into an integer, and finally returns a list of these integers. This process effectively separates the digits of `n` and presents them as a list of individual integers. Potential edge cases include when `n` is at the boundary values (1 and \(10^9\)), though the code handles typical integer values within the specified range without issues. There is no missing functionality in the provided code.
Function number 13 :
 Code:
 '''
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
''' 

 Output hints for function13:  The function `func_13` accepts two non-negative integers `n` and `r` with the constraint 0 <= r <= n. It returns the result of the expression `factorial(n) // (factorial(r) * factorial(max(n - r, 1)))`. This expression calculates the binomial coefficient, which represents the number of ways to choose `r` elements from a set of `n` elements without regard to the order of selection. The function handles the case where `r` could be 0 or `n`, ensuring that `max(n - r, 1)` avoids division by zero when `r` equals `n`. No additional edge cases or missing functionality are present in the given code.
Function number 14 :
 Code:
 '''
def func_14(x, y):
    if x % y == 0:
        return x // y
    else:
        return x // y + 1
''' 

 Output hints for function14:  The function `func_14` accepts two parameters `x` and `y`, both integers with the condition that `1 <= y <= x` and `x > 0`. It returns the integer division of `x` by `y` if `x` is divisible by `y` (i.e., `x % y == 0`). If `x` is not divisible by `y`, it returns the integer division of `x` by `y` plus one (`x // y + 1`). This ensures that the returned value is always greater than or equal to the integer division of `x` by `y`.
Function number 15 :
 Code:
 '''
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
''' 

 Output hints for function15:  The function `func_15` accepts three parameters: `x`, `y`, and `p`. It reduces `x` modulo `p` and sets `y` to 0. Then, it computes the modular exponentiation of `x` raised to the power of the original `y` value, modulo `p`, using an efficient algorithm known as exponentiation by squaring. The function returns the result of this computation.
Function number 16 :
 Code:
 '''
def func_16(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function16:  The function `func_16` accepts two positive integer parameters `x` and `y`. It uses the Euclidean algorithm to compute the greatest common divisor (GCD) of `x` and `y`. The function repeatedly updates `x` and `y` such that `x` becomes `y` and `y` becomes `x % y` until `y` is 0. At this point, the function returns `x`, which is the GCD of the initial values of `x` and `y`. The function handles the edge case where `y` is already 0, returning `x` directly without further computation.
Function number 17 :
 Code:
 '''
def func_17(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function17:  The function `func_17` accepts an integer `n` as a parameter and returns `True` if `n` is a prime number greater than 3 and not divisible by 2 or 3. It returns `False` for all other values of `n`. Specifically:
- If `n` is less than 2, it returns `False`.
- If `n` is 2 or 3, it returns `True`.
- If `n` is even or divisible by 3, it returns `False`.
- For larger values of `n`, it checks divisibility starting from 5 up to the square root of `n`, incrementing by 6 each time, to find any factors of the form `i` or `i + 2`. If such a factor is found, it returns `False`; otherwise, it returns `True`.

Potential edge cases:
- For `n < 2`, the function correctly returns `False`.
- For `n = 2` or `n = 3`, the function correctly returns `True`.
- For even numbers or multiples of 3, the function correctly returns `False`.
- For larger numbers, the function uses an optimized trial division method, checking only up to the square root of `n` and skipping multiples of 2 and 3, which ensures efficiency while still being correct for prime checking.

Missing functionality:
- The function assumes that `n` is an integer, but there is no validation to ensure this. If `n` is not an integer, the behavior is undefined.
- While the function is designed to efficiently check for primes, it does not handle very large integers optimally due to the square root calculation.
Function number 18 :
 Code:
 '''
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
''' 

 Output hints for function18:  The function does not accept any parameters and its primary action is to redirect the standard input and output streams. Specifically, it opens the file `input.txt` for reading and `output.txt` for writing, effectively changing where the program reads from and writes to. This means that any input read by the program during its execution will be taken from `input.txt`, and any output generated will be written to `output.txt`. There are no return values, and the state of the program after the function concludes is that the standard I/O streams have been redirected to these files. No other processing or transformations are performed on the input or output data.
Function number 19 :
 Code:
 '''
def func_19():
    for _ in range(func_1()):
        (x, y) = func_3()
        ans = 0
        for i in range(32):
            if x & 1 << i and y & 1 << i or (not x & 1 << i and (not y & 1 << i)):
                continue
            else:
                ans += 1 << i
        func_20(ans)
''' 

 Output hints for function19:  The function does not accept any parameters and returns nothing. It iterates a number of times specified by `func_1()`, each time calling `func_3()` to obtain two integers `x` and `y`. During each iteration, it calculates the bitwise XOR of `x` and `y` and accumulates the result in `ans`. If the bit at position `i` in `x` and `y` is either both set or both unset, the bit is skipped; otherwise, it is included in the XOR operation. After the loop completes, `func_20(ans)` is called with the accumulated XOR result as its argument. The final state of the program includes `ans` being the bitwise XOR of all pairs `(x, y)` obtained from `func_3()` over the iterations, and `x` and `y` being the values from the last iteration of the loop.
Function number 20 :
 Code:
 '''
def func_20(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function20:  The function `func_20()` accepts a variable number of positional arguments (`args`) and keyword arguments (`kwargs`). It writes these arguments to a specified output stream (`file`), which defaults to `sys.stdout`. The function writes the arguments separated by a specified separator (`sep`), which defaults to a single space. After writing the arguments, it appends an end character (`end`), which defaults to a newline character, and flushes the output buffer if requested. The function does not return any value.

- The function writes each element of `args` to `file`, separated by `sep`.
- If `args` is not empty, it ensures that `at_start` is `False` before starting the loop, ensuring proper separators are used.
- After the loop, it writes the `end` character specified in `kwargs` or the default newline character.
- If `kwargs.pop('flush', False)` is `True`, it flushes the output buffer to ensure all data is written immediately.

Potential edge cases and missing functionality:
- The function does not handle the case where `args` is an empty list; it assumes `args` will always contain at least one element.
- There is no explicit handling for invalid types in `args` or `kwargs`. The function will attempt to convert non-string elements to strings, but it does not validate their types or ranges (e.g., ensuring `a` and `b` are within the specified range).
- The function does not process the `t`, `a`, and `b` variables mentioned in the initial description, as these variables are not used within the function body.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.