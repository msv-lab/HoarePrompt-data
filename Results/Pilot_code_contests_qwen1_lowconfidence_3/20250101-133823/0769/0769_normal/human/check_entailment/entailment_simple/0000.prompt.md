
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Write a program which reads $n$ dices constructed in the same way as Dice I, and determines whether they are all different. For the determination, use the same way as Dice III.

Constraints

* $2 \leq n \leq 100$
* $0 \leq $ the integer assigned to a face $ \leq 100$

Input

In the first line, the number of dices $n$ is given. In the following $n$ lines, six integers assigned to the dice faces are given respectively in the same way as Dice III.

Output

Print "Yes" if given dices are all different, otherwise "No" in a line.

Examples

Input

3
1 2 3 4 5 6
6 2 4 3 5 1
6 5 4 3 2 1


Output

No


Input

3
1 2 3 4 5 6
6 5 4 3 2 1
5 4 3 2 1 6


Output

Yes
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
class Dice(object):
    """Dice Class

    """

    def __init__(self, numbers):
        """

        Args:
            numbers:
        """
        self.numbers_inverse = {numbers[0]: 1, numbers[1]: 2, numbers[2]: 3, numbers[3]: 4, numbers[4]: 5, numbers[5]: 6}
        self.numbers = {1: numbers[0], 2: numbers[1], 3: numbers[2], 4: numbers[3], 5: numbers[4], 6: numbers[5]}
        self.vertical = [self.numbers[1], self.numbers[2], self.numbers[6], self.numbers[5]]
        self.horizontal = [self.numbers[4], self.numbers[1], self.numbers[3], self.numbers[6]]

    def roll_dice(self, str):
        """

        Args:
            str: move direction

        Returns:

        """
        for s in str:
            if s == 'N':
                self.move_north()
            elif s == 'S':
                self.move_south()
            elif s == 'W':
                self.move_west()
            elif s == 'E':
                self.move_east()

    def set_top(self, value):
        """
        Args:
            value: target_value
        """
        counter = 0
        while counter < 4:
            if self.vertical[0] == value:
                self.map_values()
                return
            else:
                self.roll_dice('S')
            counter += 1
        counter = 0
        while counter < 4:
            if self.vertical[0] == value:
                self.map_values()
                return
            else:
                self.roll_dice('W')
            counter += 1

    def set_front(self, value):
        """
        Args:
            value: target value
        """
        counter = 0
        while counter < 4:
            if self.vertical[1] == value:
                self.map_values()
                return
            else:
                self.roll_dice('SWN')
            counter += 1

    def move_south(self):
        """move this dice towered north
        """
        self.vertical = (self.vertical * 2)[3:7]
        self.horizontal[1] = self.vertical[0]
        self.horizontal[3] = self.vertical[2]
        self.map_values()

    def move_north(self):
        """move this dice towered south
        """
        self.vertical = (self.vertical * 2)[1:5]
        self.horizontal[1] = self.vertical[0]
        self.horizontal[3] = self.vertical[2]
        self.map_values()

    def move_east(self):
        """move this dice towered east
        """
        self.horizontal = (self.horizontal * 2)[3:7]
        self.vertical[0] = self.horizontal[1]
        self.vertical[2] = self.horizontal[3]
        self.map_values()

    def move_west(self):
        """move this dice towered west
        """
        self.horizontal = (self.horizontal * 2)[1:5]
        self.vertical[0] = self.horizontal[1]
        self.vertical[2] = self.horizontal[3]
        self.map_values()

    def map_values(self):
        self.numbers[1] = self.vertical[0]
        self.numbers[2] = self.vertical[1]
        self.numbers[3] = self.horizontal[2]
        self.numbers[4] = self.horizontal[0]
        self.numbers[5] = self.vertical[3]
        self.numbers[6] = self.vertical[2]

    def get_top(self):
        return self.vertical[0]
dice_number = int(raw_input())
dices = []
counter = 0
while counter < dice_number:
    dices.append(Dice([int(x) for x in raw_input().split()]))
    counter += 1
ans = 0
for i in range(dice_number - 1):
    if ans > 0:
        break
    for j in range(i + 1, dice_number):
        ans += int(func_1(dices[i], dices[j]))
        if ans > 0:
            print('No')
            break
if ans == 0:
    print('Yes')

#State of the program right berfore the function call: dice1 and dice2 are lists of six integers each, representing the faces of two dice, where each integer is in the range [0, 100].
def func_1(dice1, dice2):
    """compare two dices

    Args:
        dice1: dice1
        dice2: dice2

    Returns:
        Bool (whether dice1 is equals to be dice2 or not)
    """
    flag = False
    if (dice1.numbers == dice2.numbers) :
        flag = True
    else :
        for i in range(6):
            dice1.set_top(i + 1)
            
            for j in xrange(4):
                dice1.roll_dice('SWN')
                if dice1.numbers == dice2.numbers:
                    flag = True
            
            dice1.roll_dice('S')
            
        #State of the program after the  for loop has been executed: `dice1.numbers` is a sequence of six integers resulting from rolling dice1 four times for each face (with the last roll being the result of `dice1.roll_dice('S')`), `dice2` is a list of six integers, `flag` is True, and `i` is 5.
    #State of the program after the if-else block has been executed: *`dice1` and `dice2` are lists of six integers. If `dice1` and `dice2` have the same numbers, then `flag` is set to True. Otherwise, `dice1` is a sequence of six integers resulting from rolling dice1 four times for each face (with the last roll being the result of `dice1.roll_dice('S')`), `dice2` is a list of six integers, and `flag` is set to True with `i` being 5.
    return flag
    #`The program returns flag which is set to True if dice1 and dice2 have the same numbers, otherwise it is set to True with i being 5`

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
