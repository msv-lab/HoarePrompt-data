
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Many computer strategy games require building cities, recruiting army, conquering tribes, collecting resources. Sometimes it leads to interesting problems. 

Let's suppose that your task is to build a square city. The world map uses the Cartesian coordinates. The sides of the city should be parallel to coordinate axes. The map contains mines with valuable resources, located at some points with integer coordinates. The sizes of mines are relatively small, i.e. they can be treated as points. The city should be built in such a way that all the mines are inside or on the border of the city square. 

Building a city takes large amount of money depending on the size of the city, so you have to build the city with the minimum area. Given the positions of the mines find the minimum possible area of the city.

Input

The first line of the input contains number n — the number of mines on the map (2 ≤ n ≤ 1000). Each of the next n lines contains a pair of integers xi and yi — the coordinates of the corresponding mine ( - 109 ≤ xi, yi ≤ 109). All points are pairwise distinct.

Output

Print the minimum area of the city that can cover all the mines with valuable resources.

Examples

Input

2
0 0
2 2


Output

4


Input

2
0 0
0 3


Output

9
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: The input consists of the number of mines n (2 ≤ n ≤ 1000) followed by n lines, each containing a pair of integers xi and yi representing the coordinates of a mine (-10^9 ≤ xi, yi ≤ 10^9). All coordinates are distinct.
def func():
    t = int(raw_input())
    maxx, maxy = -10 ** 18, -10 ** 18
    minx = 10 ** 18
    miny = 10 ** 18
    for z in xrange(t):
        a, b = map(int, raw_input().split())
        
        maxx = max(maxx, a)
        
        minx = min(minx, a)
        
        maxy = max(maxy, b)
        
        miny = min(miny, b)
        
    #State of the program after the  for loop has been executed: `n` is the number of mines (2 ≤ n ≤ 1000 and n > 0), `t` is equal to `n`, `maxx` is the maximum of `-10` and all the `a` values encountered, `minx` is the minimum of `10` and all the `a` values encountered, `miny` is the minimum of `10` and all the `b` values encountered, `a` and `b` are the last integer values from user input, `z` is `n - 1`.
    print(max(maxx - minx, maxy - miny)) ** 2
#Overall this is what the function does:The function processes the input consisting of the number of mines \( n \) (2 ≤ \( n \) ≤ 1000) followed by \( n \) lines, each containing a pair of integers \( x_i \) and \( y_i \) representing the coordinates of a mine (\(-10^9 \leq x_i, y_i \leq 10^9\)). The function calculates the maximum difference between the maximum and minimum \( x \)-coordinates and the maximum and minimum \( y \)-coordinates among the given mine coordinates. It then prints the square of the larger of these two differences. The function handles all valid inputs within the specified range and ensures that all coordinate pairs are distinct. However, it does not handle cases where the input format is incorrect or where the number of mines is outside the specified range.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
