
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

I am giving you some examples to understand the task better. Then I am giving you your task.
# Example 1

Problem description: Write a python function to identify non-prime numbers.


Functions with output hints for each function:
Function nummber 1 :
 Code:
 '''
def is_divisible(number1, number2):
    if number1 % number2 == 0:
        return True
''' 

Output hints for function1:  The function accepts 2 numbers as input, if number 1 is divisible than number2 then the function returns True.
Function nummber 2 :
 Code:
 '''
def is_not_prime(n):
    if n < 2:
        return True
    for i in range(2, n):
        if is_divisible(n,i):
            return True
    return False
''' 

Output hints for function 2:  The function returns True if n is less than 2 or if n is divisible by any integer in the range [2, n). Otherwise, it returns False.

Example Answer 1:
Explanation: The program initially seems to do what the description says. Lets see if the hints also agree with the code and if they give us any reason to think the program is incorrect. The output hints seem to agree with the program code and from their contents they reenforce our reasoning that the code is correct.
The function returns True if `n` is less than 2 or if `n` is divisible by any integer in the range [2, n). Otherwise, it returns False. Since the smallest prime number is 2 and prime numbers can only be divided by 1 and themselves, this approach correctly identifies non-prime numbers as per the given specification. 

Correctness: **True**.

# Example 2

Problem description: Write a python function to count all the substrings starting and ending with same characters.
Function nummber 1 :
 Code:
```
def count_Substring_With_Equal_Ends(s):
    count = 0
    for i in range(len(s)-1):
        for j in range(i,len(s)-1):
            if s[i] == s[j+1]:
                count += 1
    return count
```

Output hints for function number 1 : The function returns the value of the variable 'count', which is equal to the number of times a character at position 'i' in the string 's' is equal to a character at position 'j + 1' for some 'j' in the range '[i, len(s) - 2]'. This implies that 'count' represents the number of consecutive occurrences of identical characters in the string 's' that may form a substring with equal ending and beginning characters, excluding the last character of the string from this comparison.

Example Answer 2:
Explanation: The function initially seems to be correct. Lets see if the output hints agree with the code and if they give us any reason to think the code is incorrec. Indeed they agree with the code and they show that the code might not always follow the program description. The function returns the value of the variable `count`, which is equal to the number of times a character at position `i` in the string `s` is equal to a character at position `j + 1` for some `j` in the range `[i, len(s) - 2]`. This does not account for substrings of length 1, so it is incorrect.

Correctness: **False**.


# Example 3

Problem description: Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.

Functions with output hints for each function:
Function nummber 1 :
 Code:
 '''
def get_list_size(list):
    return len(list)
''' 

Output hint for function1:  The function accepts a string and returns the size of that string
Function nummber 2 :
 Code:
 '''
def find_Rotations(str1):
    n = get_list_size(str1)
    for i in range(1,n+1):
        if str1[i:] + str1[:i] == str1:
            return i
''' 

Output hint for function 2: If the string is a palindrome, the function does not return a value and the variable n remains unchanged, holding the length of the string str1. If the string is not a palindrome, then the function returns an integer i such that 0 < i < n, where n is the length of the string str1, and i represents the length of the shortest non-empty rotation of str1 to return to its original state.. If no such rotation exists, then the function does not return a value.

Example Answer 3:
Explanation: The code initially does not seem to be correct. Lets see if the output hints agree with the code and reenforce our belief that the code is incorrect. The hints do seem to agree with the code and they also show that the code does not always follow the program description. If the string is a palindrome, the function does not return a value, and the variable `n` remains unchanged, holding the length of the string `str1`. This behavior is correct as the specification states that the rotation count must be greater than 0. If the string is not a palindrome, then the function returns an integer `i` such that `0 < i < n`, where `n` is the length of the string `str1`. The value `i` represents the length of the shortest non-empty rotation of str1 to return to its original state.. However, the code iterates from `1` to `n-1`, meaning it does not include `n`. This omission is problematic because it fails to check the complete rotation case, where `i` could be equal to `n`. Consequently, the function does not meet the specification as it should return the rotation count up to `n` times. Therefore, it does not meet the specification.

Correctness: **False**.

# Your task:
Problem description: Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either "AB" or "BB". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.

For example, Zookeeper can use two such operations: AABABBA → AABBA → AAA.

Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 20000) — the number of test cases. The description of the test cases follows.

Each of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.

It is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print a single integer: the length of the shortest string that Zookeeper can make.

Example

Input


3
AAA
BABA
AABBBABBBB


Output


3
2
0

Note

For the first test case, you can't make any moves, so the answer is 3.

For the second test case, one optimal sequence of moves is BABA → BA. So, the answer is 2.

For the third test case, one optimal sequence of moves is AABBBABBBB → AABBBABB → AABBBB → ABBB → AB → (empty string). So, the answer is 0.
Functions with output description for each function:
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function `func_1()` reads an integer input from the user and returns that integer. The function assumes that the input provided by the user is a valid integer. If the user provides a non-integer input, the function will raise a `ValueError`. There are no additional actions performed by the function beyond reading the input and returning it. The function does not handle any edge cases where the input might be empty or null, as it directly returns the input value without any further processing.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` reads a single line of input from the standard input, expecting the input to be a string consisting of letters 'A' and 'B'. It then returns this string. If no input is provided or if the input is not a valid string of 'A' and 'B', the behavior is undefined since the code does not handle these cases. Potential edge cases include empty input or non-'A' and non-'B' characters in the input.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function3:  The function `func_3()` reads a single line of input from the standard input, strips leading and trailing whitespace, splits the input string into individual tokens based on spaces, converts each token into an integer using the `map` function, and returns a map object containing these integers. This function does not accept any parameters. It handles the scenario where the input string might contain multiple space-separated integers. If the input is empty or only contains whitespace, the map object will be empty. However, if the input contains non-integer values or is not properly formatted (e.g., mixed with other characters), the function will raise a `ValueError`.
Function number 4 :
 Code:
 '''
def func_4():
    return map(str, input().strip().split(' '))
''' 

 Output hints for function4:  The function `func_4` reads input from the standard input, processes it, and returns an iterator of strings. The input consists of multiple test cases, each described by a string consisting of letters 'A' and 'B'. The function splits the input string by spaces, converts each token to a string (though this conversion is redundant since the tokens are already strings), and then maps these tokens into an iterator. There are no edge cases explicitly handled in the provided code, and the function assumes that the input will always consist of valid 'A' and 'B' characters separated by spaces.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_3())
''' 

 Output hints for function5:  The function `func_5` does not accept any parameters and returns a list generated by calling `func_3()`. After the function executes, it leaves the program in a state where it contains a list that is the result of processing some input strings according to the rules defined in `func_3()`. There are no specific actions mentioned in the annotations that contradict the actual code. However, it is important to note that the function assumes `func_3()` returns an iterable object, which could be an empty iterable or an iterable containing elements based on the input strings processed by the rules in `func_3()`.
Function number 6 :
 Code:
 '''
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function6:  This function sets the recursion limit and thread stack size to allow for higher recursion depth and larger stack size, then starts a new thread to run the `main` function. The function itself does not accept any parameters and does not return any value. After the function executes, the program will have a new thread running the `main` function with the specified settings for recursion limit and stack size. There are no explicit return values or postconditions provided, but the function prepares the environment for the `main` function to run in a separate thread with enhanced resource limits.
Function number 7 :
 Code:
 '''
def func_7(item):
    return item[1]
''' 

 Output hints for function7:  The function `func_7` accepts a single parameter `item`, which must be either a tuple or a list containing at least two elements. The function returns the second element (`item[1]`) of the provided `item`. There are no edge cases mentioned in the annotations or the code itself, and the code accurately reflects the described behavior. Therefore, the function simply extracts and returns the second element from the given tuple or list.
Function number 8 :
 Code:
 '''
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
''' 

 Output hints for function8:  The function `func_8` accepts a parameter `l`, which is a list of strings composed of characters 'A' and 'B'. It returns a new list of these strings sorted in descending order based on a custom key 'getKey'. The function uses the `sorted` function with the `key=getKey` argument and `reverse=True` to achieve this sorting. There are no edge cases mentioned in the annotations, and the provided code does not include any missing functionality. The final state of the program after the function concludes is that the program returns a list of strings from `l` sorted in descending order based on the custom key 'getKey'.
Function number 9 :
 Code:
 '''
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function9:  The function `func_9` accepts three parameters: `n` (a positive integer representing the number of rows), `m` (a positive integer representing the number of columns), and `num` (an integer that will initialize all elements in the 2D list). It returns a 2D list with `n` rows and `m` columns, where each element is initialized to `num`. The function does not handle any edge cases explicitly; however, it assumes that `n`, `m`, and `num` are valid inputs (i.e., `n` and `m` are positive integers, and `num` is an integer). There are no missing functionalities in the provided code.
Function number 10 :
 Code:
 '''
def func_10(x):
    return x and (not x & x - 1)
''' 

 Output hints for function10:  The function `func_10` accepts a positive integer `x` as input and checks whether `x` is a power of two. It uses the expression `x and not x & x - 1` to determine this. This expression evaluates to `True` if `x` is a power of two and `False` otherwise. The function returns `True` if `x` is a power of two; otherwise, it returns `False`. Note that the function handles the case where `x` is `1`, which is a power of two. However, it does not handle the case where `x` is `0`, which should return `False` since `0` is not a power of two. Therefore, the final state of the program after it concludes is that it returns `True` if `x` is a power of two (including `1`), and `False` if `x` is not a power of two or is `0`.
Function number 11 :
 Code:
 '''
def func_11(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function11:  The function `func_11` accepts an integer `n` that is greater than or equal to 0, and returns its binary representation as a string without the '0b' prefix. The function correctly handles the case where `n` is 0, returning '0' as the binary representation. There are no missing functionalities or edge cases in the provided code.
Function number 12 :
 Code:
 '''
def func_12(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function12:  The function `func_12` accepts a non-negative integer `n` and returns a list of its digits as individual integers. The function correctly converts the integer `n` into a string, iterates over each character (digit) in the string, converts each character back into an integer, and collects these integers into a list. This process works for all non-negative integers, including edge cases such as `0`, which results in a list containing a single element `[0]`. There are no missing functionalities or edge cases in the provided code.
Function number 13 :
 Code:
 '''
def func_13(x, y):
    if x % y == 0:
        return x // y
    else:
        return x // y + 1
''' 

 Output hints for function13:  The function `func_13` accepts two parameters: `x` (a non-negative integer) and `y` (a positive integer). It returns either `x // y` if `x` is divisible by `y`, or `x // y + 1` if `x` is not divisible by `y`. This ensures that the returned value is the smallest integer greater than or equal to `x / y`. There are no apparent edge cases missing from the provided code; however, the function correctly handles the condition where `x` is not divisible by `y` by returning `x // y + 1`.
Function number 14 :
 Code:
 '''
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
''' 

 Output hints for function14:  The function `func_14` accepts three parameters: `x`, `y`, and `p`, where `x` and `p` are non-negative integers and `p` is greater than 1. It calculates the result of `x^y % p` using an efficient algorithm known as "Exponentiation by Squaring". The function iteratively squares the base `x` and reduces the exponent `y` until `y` becomes zero. During this process, if the current bit of `y` is set (i.e., odd), it multiplies the result by the current value of `x` and then reduces the result modulo `p`. The function finally returns the computed result, which is the remainder when `x^y` is divided by `p`.
Function number 15 :
 Code:
 '''
def func_15(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function15:  The function `func_15` accepts two non-negative integers `x` and `y` (where `x >= y > 0`). It uses the Euclidean algorithm to compute the greatest common divisor (GCD) of the original values of `x` and `y`. After the loop terminates, `x` is set to the GCD of the original `x` and `y`, and `y` is set to 0. The function then returns `x`.

Potential edge cases and considerations:
- If `x` and `y` are both 0, the function still follows the Euclidean algorithm correctly, although `y` will eventually become 0 before the first iteration, making `x` the GCD (which is 0).
- If `x` is 0 and `y` is non-zero, the function will correctly identify `y` as the GCD, and `x` will remain 0 after the loop.
- If `x` and `y` are equal and non-zero, the function will correctly identify `x` (or `y`) as the GCD, and `y` will be 0 after the loop.
Function number 16 :
 Code:
 '''
def func_16(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function16:  The function `func_16` accepts an integer `n` greater than 1 and returns `True` or `False` based on specific conditions. Specifically:
1. If `n` is less than or equal to 1, the function returns `False`.
2. If `n` is less than or equal to 3, the function returns `True`.
3. If `n` is divisible by 2 or 3, the function returns `False`.
4. For `n` greater than 3 and not divisible by 2 or 3, the function checks divisibility by numbers of the form `6k ± 1` up to the square root of `n`. If `n` is divisible by any such number, the function returns `False`.
5. If no divisors are found, the function returns `True`.

Potential edge cases and missing functionality:
- The function correctly handles all integers greater than 1, including edge cases like 2 and 3.
- The function correctly identifies even numbers (divisible by 2) and multiples of 3 as non-prime.
- The function uses an efficient algorithm to check divisibility by numbers of the form `6k ± 1`, which is sufficient to determine primality for numbers up to the square root of `n`.
- However, the function does not explicitly handle the case where `n` is a prime number greater than 3 that is not divisible by 2, 3, or any number of the form `6k ± 1` up to its square root. This is correctly handled by the algorithm, but it is worth noting that the function will return `True` for such primes.
Function number 17 :
 Code:
 '''
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
''' 

 Output hints for function17:  The function `func_17` does not accept any parameters and modifies the standard input and output streams of the Python program. It opens 'input.txt' for reading and 'output.txt' for writing, effectively redirecting the input and output operations to these files instead of the console. This change in the streams is intended to facilitate reading from 'input.txt' and writing to 'output.txt' during the execution of subsequent functions or code blocks. There are no return values, and the state of the program after the function concludes will have the standard input redirected to 'input.txt' and the standard output redirected to 'output.txt'.
Function number 18 :
 Code:
 '''
def func_18():
    for _ in range(int(input())):
        s = raw_input()

        func_19(solve(s))
''' 

 Output hints for function18:  The function `func_18` reads multiple non-empty strings consisting of only the characters 'A' and 'B' from standard input. For each input string, it calls `func_19` with the result of `solve(s)`. The function does not return any value directly but processes the input strings sequentially. The state of the program after the function concludes is that it has processed all input strings, and for each string, `func_19` has been called with the result of `solve(s)`. Potential edge cases include empty input or non-'A' and 'B' characters in the input string, which the current code does not handle explicitly.
Function number 19 :
 Code:
 '''
def solve(s):
    if s.find('AB') == -1 and s.find('BB') == -1:
        return len(s)
    while s.find('AB') != -1:
        s = s.replace('AB', '')
    while s.find('BB') != -1:
        s = s.replace('BB', '')
    return len(s)
''' 

 Output hints for function19:  The function `solve` accepts a string `s` consisting only of the characters 'A' and 'B'. It first checks if the string `s` contains the substring 'AB' or 'BB'. If `s` does not contain 'BB', it returns the length of `s`. If `s` contains 'BB', it removes all occurrences of 'BB' and then checks again if the resulting string contains 'AB'. If the final string does not contain 'BB', it returns the length of this modified string. If the string still contains 'BB' after removing all occurrences, it returns the length of the modified string.
Function number 20 :
 Code:
 '''
def func_19(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function20:  The function `func_19()` accepts a variable number of positional arguments `args` and keyword arguments `kwargs`. It processes these arguments to print them to a specified output stream, using a specified separator `sep` and end character `end`. The function does not return any value. After processing, the following state is achieved: `t` is a positive integer representing the number of test cases, `args` is a list containing exactly `t` non-empty strings consisting of 'A' and 'B', `sep` is the separator used between elements (determined during the loop execution), `file` is the output destination (determined similarly), and `at_start` is set to `False`. Additionally, if the `flush` keyword argument is set to `True`, the write buffer for the file object `file` is flushed.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.