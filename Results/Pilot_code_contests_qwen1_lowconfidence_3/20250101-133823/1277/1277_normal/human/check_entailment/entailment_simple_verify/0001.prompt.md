
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Captain Fint is involved in another treasure hunt, but have found only one strange problem. The problem may be connected to the treasure's location or may not. That's why captain Flint decided to leave the solving the problem to his crew and offered an absurdly high reward: one day off. The problem itself sounds like this...

There are two arrays a and b of length n. Initially, an ans is equal to 0 and the following operation is defined: 

  1. Choose position i (1 ≤ i ≤ n); 
  2. Add a_i to ans; 
  3. If b_i ≠ -1 then add a_i to a_{b_i}. 



What is the maximum ans you can get by performing the operation on each i (1 ≤ i ≤ n) exactly once?

Uncle Bogdan is eager to get the reward, so he is asking your help to find the optimal order of positions to perform the operation on them.

Input

The first line contains the integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of arrays a and b.

The second line contains n integers a_1, a_2, …, a_n (−10^6 ≤ a_i ≤ 10^6).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ n or b_i = -1).

Additional constraint: it's guaranteed that for any i (1 ≤ i ≤ n) the sequence b_i, b_{b_i}, b_{b_{b_i}}, … is not cyclic, in other words it will always end with -1.

Output

In the first line, print the maximum ans you can get.

In the second line, print the order of operations: n different integers p_1, p_2, …, p_n (1 ≤ p_i ≤ n). The p_i is the position which should be chosen at the i-th step. If there are multiple orders, print any of them.

Examples

Input


3
1 2 3
2 3 -1


Output


10
1 2 3 


Input


2
-1 100
2 -1


Output


99
2 1 


Input


10
-10 -1 2 2 5 -2 -3 -4 2 -6
-1 -1 2 2 -1 5 5 7 7 9


Output


-9
3 5 6 1 9 4 10 7 8 2
Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return float(input())

#Function 3:
def func_3():
    return input()

#Function 4:
def func_4():
    return map(str, input().split())

#Function 5:
def func_5():
    return map(int, input().split())

#Function 6:
def func_6():
    return list(func_5())

#Function 7:
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
def func_8(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 9:
def func_9(x, y):
    return x * y // func_8(x, y)

#Function 10:
def func_10(b, m):
    g = func_8(b, m)
    if g != 1:
        return -1
    else:
        return pow(b, m - 2, m)

#Function 11:
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if inv == -1:
        return -999999999
    else:
        return inv * a % m

#Function 12:
def func_12():
    n = func_1()
    a = func_6()
    b = func_6()
    l = [0] * n
    for i in range(n):
        if b[i] > 0:
            l[b[i] - 1] += a[i]
    l1 = []
    for i in range(n):
        l1.append([l[i], i])
    l1.sort()
    ans = 0
    l2 = []
    for i in range(n):
        l2.append(l1[i][1] + 1)
        if b[l1[i][1]] > 0:
            ans += a[l1[i][1]]
        a[l1[i][1]] += l1[i][0]
    func_13(ans)
    func_13(*l2)

#Function 13:
def func_13(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **True**

### Explanation:

The provided program correctly implements the logic described in the problem statement. Here’s a breakdown of how the program handles the requirements:

1. **Input Parsing**: The program correctly reads the input values for `n`, array `a`, and array `b`.
2. **Initialization**: It initializes an array `l` to store the cumulative sums of values that can be added during the operation.
3. **Processing**: For each position `i` where `b[i]` is not `-1`, it adds `a[i]` to `a[b[i]-1]`. This ensures that the values are added in the correct order according to the rules.
4. **Sorting**: It sorts the array `l` to process the indices in such a way that it maximizes the sum `ans`.
5. **Output**: It prints the maximum possible value of `ans` and the order of operations.

Given the constraints and the logic implemented, the program correctly handles all potential cases as per the problem description. There are no obvious edge cases or scenarios where the program would fail. Therefore, the program is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *

"""
// Author : snape_here - Susanta Mukherjee
     
 """
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
mod = 1000000007
getcontext().prec = 25
abc = 'abcdefghijklmnopqrstuvwxyz'
pi = 3.141592653589793
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_7(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_12()

#Function 1:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5. a is a list of n integers where each a_i satisfies -10^6 ≤ a_i ≤ 10^6. b is a list of n integers where each b_i is either a positive integer between 1 and n or -1.
def func_1():
    return int(input())
    #The program waits for user input and returns an integer value

#Function 2:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer a_i satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i either equals -1 or is a positive integer such that 1 ≤ b_i ≤ n.
def func_2():
    return float(input())
    #The program returns a float input from the user

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer is either a positive integer between 1 and n inclusive or -1.
def func_3():
    return input()
    #The program returns an input provided by the user

#Function 4:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies -10^6 ≤ a_i ≤ 10^6, b is a list of n integers where each integer is either a positive integer between 1 and n or -1.
def func_4():
    return map(str, input().split())
    #The program returns a map object containing strings converted from the input split by spaces, where the input is expected to be a series of integers separated by spaces

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer a_i satisfies −10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each b_i is either a positive integer such that 1 ≤ b_i ≤ n or -1, and the sequence b_i, b_{b_i}, b_{b_{b_i}}, … is not cyclic and ends with -1 for all i.
def func_5():
    return map(int, input().split())
    #The program returns a map object of integers split from input, where each integer comes from the input split by spaces

#Function 6:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer is either a positive integer between 1 and n or -1. It is also guaranteed that for any index i, the sequence b_i, b_{b_i}, b_{b_{b_i}}, … ends with -1.
def func_6():
    return list(func_5())
    #The program returns the result of `func_5()` which processes the lists `a` and `b` as described in the initial state.

#Function 7:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies −10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer is either a positive integer satisfying 1 ≤ b_i ≤ n or -1. It is also guaranteed that for any i (1 ≤ i ≤ n) the sequence b_i, b_{b_i}, b_{b_{b_i}}, … ends with -1.
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
#State of the program right berfore the function call: x and y are integers, and y is not zero (y != 0).
def func_8(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x which is the greatest common divisor (GCD) of the original values of x and y, and y is 0

#Function 9:
#State of the program right berfore the function call: x and y are integers.
def func_9(x, y):
    return x * y // func_8(x, y)
    #The program returns the integer result of x multiplied by y, then performing integer division by the result of calling the function func_8 with arguments x and y

#Function 10:
#State of the program right berfore the function call: b is an integer such that 1 < b < 10^6 and gcd(b, m) = 1 (where gcd is the greatest common divisor), and m is an integer such that m > 1.
def func_10(b, m):
    g = func_8(b, m)
    if (g != 1) :
        return -1
        #The program returns -1
    else :
        return pow(b, m - 2, m)
        #The program returns pow(b, m - 2, m), where `b` is an integer such that \(1 < b < 10^6\) and \(\gcd(b, m) = 1\), and `m` is an integer such that \(m > 1\)

#Function 11:
#State of the program right berfore the function call: a is an integer representing an element from array a, b is an integer representing an element from array b, and m is a positive integer representing the modulus.
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if (inv == -1) :
        return -999999999
        #The program returns -999999999
    else :
        return inv * a % m
        #`inv * a` modulo `m`

#Function 12:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies -10^6 ≤ a_i ≤ 10^6, b is a list of n integers where each integer either equals -1 or is an integer such that 1 ≤ b_i ≤ n.
def func_12():
    n = func_1()
    a = func_6()
    b = func_6()
    l = [0] * n
    for i in range(n):
        if b[i] > 0:
            l[b[i] - 1] += a[i]
        
    #State of the program after the  for loop has been executed: `b` is the return value of `func_6()`, `n` is the value returned by `func_1()`, and `l` is a list of `n` zeros where each element `l[j]` (for `j` in range `n`) is incremented by `a[i]` for each `i` such that `b[i] - 1 == j` and `b[i] > 0`.
    l1 = []
    for i in range(n):
        l1.append([l[i], i])
        
    #State of the program after the  for loop has been executed: `l1` is a list of lists where each sublist is `[l[j], j]` for each `j` in range `n`, `l` remains unchanged, `i` is `n-1`, and `n` remains unchanged.
    l1.sort()
    ans = 0
    l2 = []
    for i in range(n):
        l2.append(l1[i][1] + 1)
        
        if b[l1[i][1]] > 0:
            ans += a[l1[i][1]]
        
        a[l1[i][1]] += l1[i][0]
        
    #State of the program after the  for loop has been executed: `l1` is sorted based on the first element of each sublist, `l` remains unchanged, `i` is `n-1`, `n` remains unchanged, `ans` is the sum of `a[l1[i][1]]` for all valid indices where `b[l1[i][1]] > 0`, and `l2` contains the list `[l1[0][1] + 1, l1[1][1] + 1, ..., l1[n-1][1] + 1]`. `a[l1[i][1]]` is updated to `a[l1[i][1]] + l1[i][0]` for all `i` from 0 to `n-1`.
    func_13(ans)
    func_13(*l2)

#Function 13:
#State of the program right berfore the function call: args is a variable-length argument list containing integers representing the values of array `a`, and kwargs is a dictionary containing keyword arguments where `sep` is a string used to separate the values when printed, `file` is the output stream (defaulting to `sys.stdout`), `end` is a string appended after the last value (defaulting to a newline), and `flush` is a boolean indicating whether the output stream is to be flushed.
def func_13():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` must contain at least one integer, `kwargs` is a dictionary containing keyword arguments, `sep` is the original value of `kwargs['sep']` or a space `' '`, `file` is the original value of `kwargs['file']` or `sys.stdout`, `file` contains the string representation of all integers in `args` separated by `sep`, and `at_start` is `False`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` must contain at least one integer, `kwargs` does not contain the key `'end'`, `sep` is the original value of `kwargs['sep']` or a space `' '`, `file` contains the string representation of all integers in `args` separated by `sep`, `at_start` is `False`, and `kwargs` has had its `'flush'` key (with a default value of `False`) popped, resulting in either the removal of the key or its value being `None`.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
