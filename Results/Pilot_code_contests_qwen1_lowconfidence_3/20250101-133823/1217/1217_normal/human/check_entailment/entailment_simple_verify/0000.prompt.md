
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex i is equal to ai.

Ilya believes that the beauty of the vertex x is the greatest common divisor of all numbers written on the vertices on the path from the root to x, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.

For each vertex the answer must be considered independently.

The beauty of the root equals to number written on it.

Input

First line contains one integer number n — the number of vertices in tree (1 ≤ n ≤ 2·105).

Next line contains n integer numbers ai (1 ≤ i ≤ n, 1 ≤ ai ≤ 2·105).

Each of next n - 1 lines contains two integer numbers x and y (1 ≤ x, y ≤ n, x ≠ y), which means that there is an edge (x, y) in the tree.

Output

Output n numbers separated by spaces, where i-th number equals to maximum possible beauty of vertex i.

Examples

Input

2
6 2
1 2


Output

6 6 


Input

3
6 2 3
1 2
1 3


Output

6 6 6 


Input

1
10


Output

10 
Program:
```

#Function 1:
def func_1(a, b):
    return a if b == 0 else func_1(b, a % b)

#Function 2:
def func_2(n, parent):
    if visited[n]:
        return
    visited[n] = True
    if parent != -1:
        newgcd = func_1(gcdinfo[parent].gcd, a[n])
        gcdinfo[n].gcd = newgcd
        if newgcd < gcdinfo[parent].gcd:
            gcdinfo[n].tor1 = a[n]
            gcdinfo[n].ifr1 = gcdinfo[parent].gcd
            if gcdinfo[parent].ifr1 == 0:
                gcdinfo[n].tor2 = gcdinfo[parent].gcd
                gcdinfo[n].ifr2 = a[n]
        else:
            if gcdinfo[parent].ifr1:
                newgcd1 = func_1(gcdinfo[parent].ifr1, a[n])
            else:
                newgcd1 = 1
            if gcdinfo[parent].ifr2:
                newgcd2 = func_1(gcdinfo[parent].ifr2, a[n])
            else:
                newgcd2 = 1
            if newgcd1 > newgcd2:
                gcdinfo[n].tor1 = gcdinfo[parent].tor1
                gcdinfo[n].ifr1 = gcdinfo[parent].ifr1
            elif newgcd2 > newgcd1:
                gcdinfo[n].tor1 = gcdinfo[parent].tor2
                gcdinfo[n].ifr1 = gcdinfo[parent].ifr2
    for neigh in graph[n]:
        func_2(neigh, n)


```
Original Assessment: Correctness: **False**.

Explanation: The provided program does not correctly implement the solution for finding the maximum possible beauty for each vertex in the tree. The program seems to be attempting to calculate the greatest common divisor (GCD) along paths from the root, but it does not handle the process of setting a vertex's value to 0 and recalculating the GCDs correctly. Additionally, the structure and variables used (like `visited`, `gcdinfo`, `graph`) are not defined within the provided code snippet, making it difficult to understand the intended logic.

To illustrate, consider the following input:

Input:
```
3
6 2 3
1 2
1 3
```

Expected Output:
```
6 6 6
```

However, the provided program will not produce the correct output because:
- It does not properly handle the possibility of setting a vertex's value to 0.
- The logic to update the GCD values for child nodes after setting a parent node to 0 is missing.
- The program does not account for all possible changes in the GCD when setting a vertex's value to 0.

Since the program does not handle these cases correctly, it fails to meet the requirements specified in the problem description, hence the correctness is **False**.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
n = int(raw_input())
a = map(int, raw_input().split())
graph = [[] for _ in range(n)]
for i in xrange(n - 1):
    (x, y) = map(int, raw_input().split())
    x -= 1
    y -= 1
    graph[x].append(y)
    graph[y].append(x)
class Info:

    def __init__(self):
        self.gcd = 0
        self.tor1 = 0
        self.ifr1 = 0
        self.tor2 = 0
        self.ifr2 = 0

    def get(self):
        r = self.gcd
        if self.ifr1 > r:
            r = self.ifr1
        if self.ifr2 > r:
            r = self.ifr2
        return r
visited = [False] * n
gcdinfo = [Info() for _ in xrange(n)]
gcdinfo[0].gcd = a[0]
gcdinfo[0].tor1 = a[0]
gcdinfo[0].ifr1 = 0
func_2(0, -1)
s = ''
for i in xrange(n):
    s += str(gcdinfo[i].get()) + ' '
print(s)

#Function 1:
#State of the program right berfore the function call: a and b are positive integers representing the numbers written on the vertices of the tree.
def func_1(a, b):
    return a if b == 0 else func_1(b, a % b)
    #`The program returns 'a' if 'b' equals 0, otherwise it returns the result of the function 'func_1(b, a % b)' where 'a % b' is the remainder of 'a' divided by 'b'`

#Function 2:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the tree, a is a list of integers where a[i] represents the number written on vertex i+1, parent is an integer representing the parent of the current vertex n in the tree traversal, graph is a list of lists representing the adjacency list of the tree, and visited is a boolean list representing whether a vertex has been visited during the traversal.
def func_2(n, parent):
    if visited[n] :
        return
        #None
    #State of the program after the if block has been executed: n is an integer representing the number of vertices in the tree, a is a list of integers where a[i] represents the number written on vertex i+1, parent is an integer representing the parent of the current vertex n in the tree traversal, graph is a list of lists representing the adjacency list of the tree, and visited is a boolean list representing whether a vertex has been visited during the traversal. The vertex n has not been visited.
    visited[n] = True
    if (parent != -1) :
        newgcd = func_1(gcdinfo[parent].gcd, a[n])
        gcdinfo[n].gcd = newgcd
        if (newgcd < gcdinfo[parent].gcd) :
            gcdinfo[n].tor1 = a[n]
            gcdinfo[n].ifr1 = gcdinfo[parent].gcd
            if (gcdinfo[parent].ifr1 == 0) :
                gcdinfo[n].tor2 = gcdinfo[parent].gcd
                gcdinfo[n].ifr2 = a[n]
            #State of the program after the if block has been executed: `newgcd` is less than `gcdinfo[parent].gcd` and `gcdinfo[n].gcd` is `newgcd`; `gcdinfo[n].tor1` is `a[n]`; `gcdinfo[n].ifr1` is `gcdinfo[parent].gcd`; `gcdinfo[n].ifr2` is `a[n]`. If `gcdinfo[parent].ifr1` is 0, then `gcdinfo[n].ifr1` is also set to `gcdinfo[parent].gcd`.
        else :
            if gcdinfo[parent].ifr1 :
                newgcd1 = func_1(gcdinfo[parent].ifr1, a[n])
            else :
                newgcd1 = 1
            #State of the program after the if-else block has been executed: `newgcd` is assigned the value of `func_1(gcdinfo[parent].gcd, a[n])`, `gcdinfo[n].gcd` is updated to this value, `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`, `parent` is an integer representing the parent of the current vertex `n` in the tree traversal, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list representing whether a vertex has been visited during the traversal, `visited[n]` is `True`, and the `parent` of the current vertex `n` is not `-1. The newgcd is greater than or equal to gcdinfo[parent].gcd, and either the condition gcdinfo[parent].ifr1 is true, in which case `newgcd1` is `func_1(gcdinfo[parent].ifr1, a[n])`, or gcdinfo[parent].ifr1 is false, in which case `newgcd1` is 1.
            if gcdinfo[parent].ifr2 :
                newgcd2 = func_1(gcdinfo[parent].ifr2, a[n])
            else :
                newgcd2 = 1
            #State of the program after the if-else block has been executed: *`newgcd` is assigned the value of `func_1(gcdinfo[parent].gcd, a[n])`, `gcdinfo[n].gcd` is updated to this value, `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`, `parent` is an integer representing the parent of the current vertex `n` in the tree traversal, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list representing whether a vertex has been visited during the traversal, `visited[n]` is `True`, and the `parent` of the current vertex `n` is not `-1. If the condition `gcdinfo[parent].ifr2` is true, `newgcd2` is assigned the value of `func_1(gcdinfo[parent].ifr2, a[n])`; otherwise, `newgcd2` is set to 1.
            if (newgcd1 > newgcd2) :
                gcdinfo[n].tor1 = gcdinfo[parent].tor1
                gcdinfo[n].ifr1 = gcdinfo[parent].ifr1
            else :
                if (newgcd2 > newgcd1) :
                    gcdinfo[n].tor1 = gcdinfo[parent].tor2
                    gcdinfo[n].ifr1 = gcdinfo[parent].ifr2
                #State of the program after the if block has been executed: *`newgcd` is assigned the value of `func_1(gcdinfo[parent].gcd, a[n])`, `gcdinfo[n].gcd` is updated to this value, `gcdinfo[n].ifr2` is checked, if it is false, `newgcd2` is set to 1, otherwise, `newgcd2` keeps its original value, `gcdinfo[n].tor1` is `gcdinfo[parent].tor2`, `gcdinfo[n].ifr1` is `gcdinfo[parent].ifr2`, `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`, `parent` is an integer representing the parent of the current vertex `n` in the tree traversal, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list representing whether a vertex has been visited during the traversal, `visited[n]` is `True`, and the `parent` of the current vertex `n` is not `-1`.
            #State of the program after the if-else block has been executed: `newgcd` is assigned the value of `func_1(gcdinfo[parent].gcd, a[n])`, `gcdinfo[n].gcd` is updated to this value, `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`, `parent` is an integer representing the parent of the current vertex `n` in the tree traversal, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list representing whether a vertex has been visited during the traversal, `visited[n]` is `True`, and the `parent` of the current vertex `n` is not `-1`. If `newgcd1 > newgcd2`, then `gcdinfo[n].tor1` is updated to `gcdinfo[parent].tor1` and `gcdinfo[n].ifr1` is updated to `gcdinfo[parent].ifr1`. Otherwise, `gcdinfo[n].tor1` is updated to `gcdinfo[parent].tor2` and `gcdinfo[n].ifr1` is updated to `gcdinfo[parent].ifr2`.
        #State of the program after the if-else block has been executed: *`newgcd` is assigned the value of `func_1(gcdinfo[parent].gcd, a[n])`, `gcdinfo[n].gcd` is updated to this value, `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`, `parent` is an integer representing the parent of the current vertex `n` in the tree traversal, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list representing whether a vertex has been visited during the traversal, `visited[n]` is `True`, and the `parent` of the current vertex `n` is not `-1`. If `newgcd < gcdinfo[parent].gcd`, then `gcdinfo[n].tor1` is `a[n]`, `gcdinfo[n].ifr1` is `gcdinfo[parent].gcd`, and `gcdinfo[n].ifr2` is `a[n]`. If `gcdinfo[parent].ifr1` is 0, then `gcdinfo[n].ifr1` is also set to `gcdinfo[parent].gcd`. Otherwise, `gcdinfo[n].tor1` is updated to either `gcdinfo[parent].tor1` or `gcdinfo[parent].tor2` and `gcdinfo[n].ifr1` is updated to either `gcdinfo[parent].ifr1` or `gcdinfo[parent].ifr2` based on the comparison of `newgcd1` and `newgcd2`.
    #State of the program after the if block has been executed: *`n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`, `parent` is an integer representing the parent of the current vertex `n` in the tree traversal, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list representing whether a vertex has been visited during the traversal, and `visited[n]` is `True`. If `parent != -1`, `newgcd` is assigned the value of `func_1(gcdinfo[parent].gcd, a[n])`, `gcdinfo[n].gcd` is updated to this value, `gcdinfo[n].tor1`, `gcdinfo[n].ifr1`, and `gcdinfo[n].ifr2` are updated based on the comparison of `newgcd` with `gcdinfo[parent].gcd` and the conditions specified. If `parent == -1`, no changes occur.
    for neigh in graph[n]:
        func_2(neigh, n)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of vertices in the tree; `a` is a list of integers where `a[i]` represents the number written on vertex `i+1`; `parent` is an integer representing the parent of the current vertex `n` in the tree traversal; `graph` is a list of lists representing the adjacency list of the tree (must have at least one element in `graph[n]`); `visited` is a boolean list representing whether a vertex has been visited during the traversal, and `visited` is `True` for all vertices reachable from the starting vertex `n`; `a` and `parent` may have been modified by `func_2`.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
