
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Mike is trying rock climbing but he is awful at it. 

There are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai < ai + 1 for all i from 1 to n - 1; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty <image>. In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1, 2, 3, 4, 5) and remove the third element from it, we obtain the sequence (1, 2, 4, 5)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

Input

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.

The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).

Output

Print a single number — the minimum difficulty of the track after removing a single hold.

Examples

Input

3
1 4 6


Output

5


Input

5
1 2 3 4 5


Output

2


Input

5
1 2 3 7 8


Output

4

Note

In the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.

In the second test after removing every hold the difficulty equals 2.

In the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.
Annotated Functions:
import fileinput

if __name__ == '__main__':
    from sys import argv
    if argv.pop() == 'test':
        func_4()
    else:
        func_3(list(fileinput.input()), verbose=True)

#Function 1:
#State of the program right berfore the function call: s is a string containing n space-separated integers ai (1 ≤ ai ≤ 1000) representing the heights where the holds hang, and the sequence ai is increasing.
def func_1(s):
    return [int(x) for x in s.split()]
    #The program returns a list of integers converted from the string `s` which contains space-separated integers and represents the heights where the holds hang
#Overall this is what the function does:The function `func_1` accepts a single string parameter `s` that contains space-separated integers `ai` (where `1 ≤ ai ≤ 1000`), representing the heights where the holds hang, and the sequence of these integers is strictly increasing. The function processes this string and returns a list of integers derived from `s`. The function ensures that each integer in the returned list corresponds to one of the integers in the input string `s`, without any modifications or additional operations being performed. Potential edge cases include an empty string input, where the function would return an empty list, and the sequence of integers not being strictly increasing, in which case the function still processes the string into integers but the input condition is not met.

#Function 2:
#State of the program right berfore the function call: args is a list containing exactly one element, which is a list of n space-separated integers representing the heights of the holds (ai). The list has n elements where 3 ≤ n ≤ 100 and each ai is an integer such that 1 ≤ ai ≤ 1000, and the sequence ai is strictly increasing.
def func_2(args):
    a_s = tuple(func_1(args[1]))
    return a_s
    #The program returns a_s which is a tuple containing the same elements as the list in args[1]
#Overall this is what the function does:The function `func_2` accepts a single argument `args`, which is a list containing exactly one element—a list of `n` space-separated integers representing the heights of the holds (where `3 ≤ n ≤ 100` and `1 ≤ ai ≤ 1000`). It then calls another function `func_1` with the second element of the list (`args[1]`), converts the result into a tuple, and returns this tuple. The returned tuple contains the same elements as the list found at `args[1]`. There are no specified edge cases or missing functionalities in the provided code, assuming `func_1` correctly processes its input and returns a valid list.

#Function 3:
#State of the program right berfore the function call: `a_s` is a list of `n` integers where `n` is at least 3, and the integers are in strictly increasing order.
def func_3(args, verbose):
    a_s = func_2(args)
    max_1 = -float('inf')
    min_2 = float('inf')
    for k in xrange(len(a_s) - 1):
        max_1 = max(max_1, a_s[k + 1] - a_s[k])
        
    #State of the program after the  for loop has been executed: `a_s` is a list of integers in strictly increasing order, `max_1` is the maximum difference between any two consecutive elements in `a_s`, `min_2` is float('inf')
    for k in xrange(len(a_s) - 2):
        min_2 = min(min_2, a_s[k + 2] - a_s[k])
        
    #State of the program after the  for loop has been executed: `a_s` is a list of integers in strictly increasing order and must have at least 3 elements, `max_1` is the maximum difference between any two consecutive elements in `a_s`, `min_2` is the minimum difference between any two non-consecutive elements in `a_s`.
    return max(max_1, min_2)
    #The program returns the larger value between the maximum difference between any two consecutive elements (`max_1`) and the minimum difference between any two non-consecutive elements (`min_2`) in the list `a_s`
#Overall this is what the function does:The function `func_3` accepts two parameters: `args` and `verbose`. `args` is a list of at least 3 strictly increasing integers, and `verbose` is a boolean value. The function calculates the maximum difference between any two consecutive elements (`max_1`) and the minimum difference between any two non-consecutive elements (`min_2`) in the list `args`. It then returns the larger value between `max_1` and `min_2`.

The function iterates through the list `args` twice to compute these values. The first iteration calculates `max_1`, which is the maximum difference between any two consecutive elements. The second iteration calculates `min_2`, which is the minimum difference between any two non-consecutive elements.

Potential edge cases include:
- If the list `args` has exactly 3 elements, both `max_1` and `min_2` calculations will be based on the differences between these three elements.
- If `args` has more than 3 elements, `min_2` will be calculated over all possible pairs of non-consecutive elements.

Missing functionality in the annotations includes:
- The initial state of `a_s` is mentioned as being the same as `args`, but the function does not modify `args`; instead, it uses `a_s` as a temporary variable to store the list for calculation purposes.
- The `verbose` parameter is not used within the function and thus does not affect the output.

Therefore, the function's final state after execution is that it returns the larger value between `max_1` and `min_2`, which represent the maximum and minimum differences as described.

#Function 4:
#State of the program right berfore the function call: `n` is an integer such that 3 ≤ n ≤ 100, and `holds` is a list of n integers where each integer is between 1 and 1000 inclusive, and the list is sorted in strictly increasing order.
def func_4():
#Overall this is what the function does:The function `func_4` accepts two parameters: `n` (an integer such that 3 ≤ n ≤ 100) and `holds` (a list of n integers sorted in strictly increasing order). After executing, the function does not return any value. Since the function does not contain any operations that modify the input parameters or produce any output, the final state of the program remains unchanged. There are no actions performed by the function, and it does not alter the input list `holds` or generate any new data.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.