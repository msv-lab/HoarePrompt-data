
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Bob got a job as a system administrator in X corporation. His first task was to connect n servers with the help of m two-way direct connection so that it becomes possible to transmit data from one server to any other server via these connections. Each direct connection has to link two different servers, each pair of servers should have at most one direct connection. Y corporation, a business rival of X corporation, made Bob an offer that he couldn't refuse: Bob was asked to connect the servers in such a way, that when server with index v fails, the transmission of data between some other two servers becomes impossible, i.e. the system stops being connected. Help Bob connect the servers.

Input

The first input line contains 3 space-separated integer numbers n, m, v (3 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ v ≤ n), n — amount of servers, m — amount of direct connections, v — index of the server that fails and leads to the failure of the whole system.

Output

If it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each — description of all the direct connections in the system. Each direct connection is described by two numbers — indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.

Examples

Input

5 6 3


Output

1 2
2 3
3 4
4 5
1 3
3 5


Input

6 100 1


Output

-1
Program:
```
def func():
    (n, m, v) = map(int, raw_input().split())
    if m < n - 1:
        print(-1)
        exit()
    edges = [(i, i + 1) for i in xrange(n - 1)]
    m = m - len(edges)
    node1_nr = 1
    while m > 0 and node1_nr < n:
        node2_nr = node1_nr + 2
        while m > 0 and node2_nr < n:
            edges.append((node1_nr, node2_nr))
            m -= 1
            node2_nr += 1
        node1_nr += 1
    if m > 0:
        print(-1)
        exit()
    translate = [i + 1 for i in xrange(n)]
    (translate[v - 1], translate[1]) = (translate[1], translate[v - 1])
    output = ['%d %d' % (translate[n1], translate[n2]) for (n1, n2) in edges]
    print('\n'.join(output))


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not handle the case where the server with index `v` is directly connected to all other servers, making it impossible to disconnect the network by failing just that one server. Specifically, the program constructs a tree-like structure where each server is connected to the next in a sequence, and then attempts to add additional connections. However, this approach does not guarantee that the failure of server `v` will disconnect the network.

For example, consider the following input:
```
5 6 3
```

The program outputs:
```
1 2
2 3
3 4
4 5
1 3
3 5
```

In this setup, servers 1, 2, 4, and 5 are still connected even after server 3 fails, which does not satisfy the requirement that the failure of server `v` should disconnect the network.

To meet the requirement, the program needs to ensure that the server `v` is a central node in the network such that its failure would isolate parts of the network. One way to achieve this is to create a star topology where `v` is the center, and all other servers are directly connected to `v`. This would ensure that removing `v` would disconnect all other servers.

Here's a modified version of the program that should work:

```python
def func():
    (n, m, v) = map(int, input().split())
    if m < n - 1:
        print(-1)
        exit()
    
    # Create a star topology with v as the central node
    edges = [(v, i + 1) for i in range(1, n) if i != v]
    m -= len(edges)
    
    # Add remaining edges to reach the required number of edges
    start_node = 1
    while m > 0:
        end_node = start_node + 2
        while m > 0 and end_node < n:
            edges.append((start_node, end_node))
            m -= 1
            end_node += 1
        start_node += 1
    
    if m > 0:
        print(-1)
        exit()
    
    output = ['{} {}'.format(e[0], e[1]) for e in edges]
    print('\n'.join(output))
```

This version ensures that server `v` is a central node in the network, and its failure will disconnect the network.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
#State of the program right berfore the function call: n is an integer representing the number of servers, m is an integer representing the number of direct connections, and v is an integer representing the index of the server that, if it fails, will cause the system to fail. The constraints are 3 ≤ n ≤ 100000, 0 ≤ m ≤ 100000, and 1 ≤ v ≤ n.
def func():
    n, m, v = map(int, raw_input().split())
    if (m < n - 1) :
        print(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer between 3 and 100000, `m` is an integer between 0 and 100000 with `m` being less than `n - 1`, and `v` is an integer between 1 and `n`. If `m` is less than `n - 1`, no changes are made to `m` and `v` remains unchanged.
    edges = [(i, i + 1) for i in xrange(n - 1)]
    m = m - len(edges)
    node1_nr = 1
    while m > 0 and node1_nr < n:
        node2_nr = node1_nr + 2
        
        while m > 0 and node2_nr < n:
            edges.append((node1_nr, node2_nr))
            m -= 1
            node2_nr += 1
        
        node1_nr += 1
        
    #State of the program after the loop has been executed: `m` is 0, `node1_nr` is `n`, `node2_nr` is `n`, `n` is the same as the original value of `n`, `v` is an integer between 1 and `n`, `edges` is a list containing tuples from `(0, 1)` to `(n-2, n-1)` and additional tuples starting from `(1, 3)` up to `(n-2, n-1)`
    if (m > 0) :
        print(-1)
        exit()
    #State of the program after the if block has been executed: *`m` is 0, `node1_nr` is `n`, `node2_nr` is `n`, `n` is the same as the original value of `n`, `v` is an integer between 1 and `n`, `edges` is a list containing tuples from `(0, 1)` to `(n-2, n-1)` and additional tuples starting from `(1, 3)` up to `(n-2, n-1)`, and the program exits.
    translate = [(i + 1) for i in xrange(n)]
    translate[v - 1], translate[1] = translate[1], translate[v - 1]
    output = [('%d %d' % (translate[n1], translate[n2])) for n1, n2 in edges]
    print('\n'.join(output))
#Overall this is what the function does:The function takes three parameters \( n \), \( m \), and \( v \), where \( n \) is the number of servers, \( m \) is the number of direct connections, and \( v \) is the index of the critical server. The function first checks if the number of connections \( m \) is less than \( n - 1 \). If so, it prints \(-1\) and exits. Otherwise, it constructs a set of edges connecting the servers such that each server is connected to its immediate neighbor and additional connections are made to ensure the total number of connections equals \( m \). It then swaps the indices of the critical server \( v \) and the first server (index 1) in a translation list. Finally, it generates and prints a list of the translated edges. If the number of connections is still greater than 0 after constructing the edges, it prints \(-1\) and exits.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
