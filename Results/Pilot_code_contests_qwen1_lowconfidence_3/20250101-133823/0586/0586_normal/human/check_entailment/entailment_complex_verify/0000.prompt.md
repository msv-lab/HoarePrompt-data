
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Dima, Inna and Seryozha have gathered in a room. That's right, someone's got to go. To cheer Seryozha up and inspire him to have a walk, Inna decided to cook something. 

Dima and Seryozha have n fruits in the fridge. Each fruit has two parameters: the taste and the number of calories. Inna decided to make a fruit salad, so she wants to take some fruits from the fridge for it. Inna follows a certain principle as she chooses the fruits: the total taste to the total calories ratio of the chosen fruits must equal k. In other words, <image> , where aj is the taste of the j-th chosen fruit and bj is its calories.

Inna hasn't chosen the fruits yet, she is thinking: what is the maximum taste of the chosen fruits if she strictly follows her principle? Help Inna solve this culinary problem — now the happiness of a young couple is in your hands!

Inna loves Dima very much so she wants to make the salad from at least one fruit.

Input

The first line of the input contains two integers n, k (1 ≤ n ≤ 100, 1 ≤ k ≤ 10). The second line of the input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the fruits' tastes. The third line of the input contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100) — the fruits' calories. Fruit number i has taste ai and calories bi.

Output

If there is no way Inna can choose the fruits for the salad, print in the single line number -1. Otherwise, print a single integer — the maximum possible sum of the taste values of the chosen fruits.

Examples

Input

3 2
10 8 1
2 7 1


Output

18


Input

5 3
4 4 4 4 4
2 2 2 2 2


Output

-1

Note

In the first test sample we can get the total taste of the fruits equal to 18 if we choose fruit number 1 and fruit number 2, then the total calories will equal 9. The condition <image> fulfills, that's exactly what Inna wants.

In the second test sample we cannot choose the fruits so as to follow Inna's principle.
Program:
```
from collections import defaultdict

def func():
    (n, k) = map(int, raw_input().split())
    A = map(int, raw_input().split())
    B = map(int, raw_input().split())
    dp1 = defaultdict(lambda : 0, {0: 0})
    pos = 0
    for (a, b) in zip(A, B):
        cur = a - b * k
        dp2 = dp1.copy()
        for (x, y) in dp1.iteritems():
            dp2[x + cur] = max(dp2[x + cur], y + a)
        dp1 = dp2
    if dp1[0] > 0:
        print(dp1[0])
    else:
        print(-1)


```
Original Assessment: Correctness: **True**

Explanation: The provided program appears to correctly implement a dynamic programming solution to find the maximum possible sum of the taste values of the chosen fruits while maintaining the required taste-to-calories ratio. Here’s a breakdown of why the program should be correct:

1. **Dynamic Programming Initialization**: The program initializes `dp1` as a dictionary with a base case `{0: 0}` indicating that a sum of 0 can be achieved with 0 fruits.

2. **Iterative Update**: For each fruit, the program calculates a new value `cur` which represents the adjusted taste value after considering the current fruit's taste and calories against the required ratio `k`. It then updates the `dp2` dictionary with the maximum possible taste sum for each possible adjusted value.

3. **Final Check**: After processing all fruits, the program checks if a valid solution exists by looking for a key in `dp1` that equals 0 (indicating a valid set of fruits).

4. **Edge Cases Handling**: The program correctly handles cases where no valid combination of fruits can achieve the required ratio by returning `-1`.

Given the provided examples and the problem constraints, the program correctly finds the maximum possible taste sum under the given conditions. There doesn't appear to be any logical flaw or missing edge case in the provided code.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from collections import defaultdict

#State of the program right berfore the function call: n and k are positive integers such that 1 ≤ n ≤ 100 and 1 ≤ k ≤ 10. Additionally, there are two lists of integers, each containing n elements: the first list represents the tastes of the fruits, and the second list represents the calories of the fruits, with each value ranging from 1 to 100.
def func():
    n, k = map(int, raw_input().split())
    A = map(int, raw_input().split())
    B = map(int, raw_input().split())
    dp1 = defaultdict(lambda : 0, {(0): 0})
    pos = 0
    for (a, b) in zip(A, B):
        cur = a - b * k
        
        dp2 = dp1.copy()
        
        for x, y in dp1.iteritems():
            dp2[x + cur] = max(dp2[x + cur], y + a)
        
        dp1 = dp2
        
    #State of the program after the  for loop has been executed: `dp1` is a dictionary where the keys are integers formed by adding each `cur` value from the loop to the keys in the initial `dp1` dictionary, and the values are the maximum values obtained from the original `dp1` and the updated values based on the formula `y + a` for all processed key-value pairs in `dp1`; `cur` is the final value of `a - b * k` after the loop completes, `A` is the same as the initial list, `B` is the same as the initial map object.
    if (dp1[0] > 0) :
        print(dp1[0])
    else :
        print(-1)
    #State of the program after the if-else block has been executed: *`dp1` is a dictionary where the keys are integers formed by adding each `cur` value from the loop to the keys in the initial `dp1` dictionary, and the values are the maximum values obtained from the original `dp1` and the updated values based on the formula `y + a` for all processed key-value pairs in `dp1`; `cur` is the final value of `a - b * k` after the loop completes, `A` is the same as the initial list, `B` is the same as the initial map object; if `dp1[0]` is greater than 0, the function continues without additional changes. If `dp1[0]` is less than or equal to 0, the function prints -1.
#Overall this is what the function does:The function `func()` takes two positive integers `n` and `k` (with \(1 \leq n \leq 100\) and \(1 \leq k \leq 10\)), along with two lists `A` and `B` of integers, each containing `n` elements (where each element ranges from 1 to 100). The function constructs a dynamic programming table `dp1` to find the maximum taste value that can be achieved by selecting fruits under the given constraints. For each fruit, it calculates a modified taste value `cur` as `a - b * k`, where `a` and `b` are the taste and calorie values of the current fruit, respectively. The function then updates `dp1` by considering all possible combinations of previously accumulated values and the new `cur` values. After processing all fruits, the function checks if the value at `dp1[0]` is greater than 0. If so, it prints the maximum taste value; otherwise, it prints -1. Potential edge cases include scenarios where no valid combination of fruits can achieve a positive taste value, and the function handles these by printing -1.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
