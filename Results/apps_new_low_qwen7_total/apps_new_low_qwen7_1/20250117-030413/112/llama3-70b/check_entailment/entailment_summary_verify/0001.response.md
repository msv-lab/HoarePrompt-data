### Reasoning:

1. **Input Parsing**:
   - The program correctly reads two integers `n` and `k` from the input using `map(int, input().split())`. This matches the expected input format.

2. **Finding Divisors**:
   - The program iterates through numbers from 1 to the square root of `n` to find all divisors. This is a correct and efficient way to find all divisors, as each divisor `i` paired with `n // i` ensures that no divisors are missed.

3. **Sorting Divisors**:
   - The program sorts the list of divisors, which is necessary to ensure they are in ascending order. Sorting is a standard practice when you need to find the `k`-th smallest element.

4. **Checking the k-th Divisor**:
   - The program checks if `k` is greater than the number of divisors. If so, it prints `-1`, indicating that the `k`-th divisor does not exist.
   - Otherwise, it prints the `k`-th smallest divisor by accessing `divisors[k - 1]`. This is correct because `divisors` is sorted in ascending order.

However, there is a potential issue with the divisor list. The current implementation appends both `i` and `n // i` to the list of divisors. While this approach is generally correct, it could lead to redundant entries if `i` is a perfect square root of `n`. Specifically, the square root of `n` should be counted only once. 

To fix this, we can modify the loop to avoid adding the square root twice:

```python
divisors = []
for i in range(1, int(n ** 0.5) + 1):
    if n % i == 0:
        divisors.append(i)
        if i * i != n:
            divisors.append(n // i)
```

Even with the original implementation, the program still correctly identifies the `k`-th smallest divisor if the list is sorted correctly. Therefore, the original assessment is accurate.

### Conclusion:
The given program is correct based on the problem description, even though it could be optimized slightly to avoid redundancy.

**Final:** True