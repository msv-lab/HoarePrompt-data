
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:

Find k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. 

To be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \operatorname{max}_{1 \leq i \leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.

For definitions of powers and lexicographical order see notes.


-----Input-----

The first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.


-----Output-----

Output "No" (without quotes) in a single line if there does not exist such sequence. Otherwise, output "Yes" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.

It is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].


-----Examples-----
Input
23 5

Output
Yes
3 3 2 1 0 

Input
13 2

Output
No

Input
1 2

Output
Yes
-1 -1 



-----Note-----

Sample 1:

2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23

Answers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.

Answers like (4, 1, 1, 1, 0) do not have the minimum y value.

Sample 2:

It can be shown there does not exist a sequence with length 2.

Sample 3:

$2^{-1} + 2^{-1} = \frac{1}{2} + \frac{1}{2} = 1$

Powers of 2:

If x > 0, then 2^{x} = 2·2·2·...·2 (x times).

If x = 0, then 2^{x} = 1.

If x < 0, then $2^{x} = \frac{1}{2^{-x}}$.

Lexicographical order:

Given two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.

- Program: 
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

def func_1(n, k):
    if k > n:
        return 'No'
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
    if len(bits) > k:
        return 'No'
    while len(bits) < k:
        smallest = bits.pop()
        bits.append(smallest - 1)
        bits.append(smallest - 1)
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))



- Annotated Code: 
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

#State of the program right berfore the function call: n is a non-negative integer such that 1 ≤ n ≤ 10^18, and k is a positive integer such that 1 ≤ k ≤ 10^5.
def func_1(n, k):
    if (k > n) :
        return 'No'
        #The program returns 'No'
    #State of the program after the if block has been executed: n is a non-negative integer such that 1 ≤ n ≤ 10^18, k is a positive integer such that 1 ≤ k ≤ 10^5, and k is less than or equal to n
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer such that \(1 \leq n \leq 10^{18}\), `k` is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), `bits` is a list containing all indices of the set bits of `n` in descending order from 60 to 0.
    if (len(bits) > k) :
        return 'No'
        #The program returns 'No'
    #State of the program after the if block has been executed: *`n` is a non-negative integer such that \(1 \leq n \leq 10^{18}\), `k` is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), `bits` is a list containing all indices of the set bits of `n` in descending order from 60 to 0, and the length of `bits` is less than or equal to `k`
    while len(bits) < k:
        smallest = bits.pop()
        
        bits.append(smallest - 1)
        
        bits.append(smallest - 1)
        
    #State of the program after the loop has been executed: n is a non-negative integer such that \(1 \leq n \leq 10^{18}\), k is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), bits is a list with length exactly k where the last element is the result of the repeated decrement operations starting from the original smallest bit index.
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))
    #The program returns 'Yes' followed by a space-separated string of integers contained in the list `bits`, which is sorted in descending order



Beggining of Original Assessment: 
Reasoning:

1. **Understanding the Problem:**
   - The goal is to find \( k \) integers such that their binary representations sum up to \( n \).
   - The largest integer in the answer should be minimized.
   - If there are multiple solutions with the same largest integer, the lexicographically largest one should be chosen.

2. **Analyzing the Provided Solution:**
   - The code reads input using `sys.stdin.read` which is fine for handling large inputs.
   - It separates the input into \( n \) and \( k \).
   - It defines a function `func_1` to process these values.

3. **Checking Function `func_1`:**
   - It checks if \( k \) is greater than \( n \). If so, it returns `'No'`, which is correct because it's impossible to represent \( n \) with fewer than \( n \) powers of 2.
   - It initializes an empty list `bits` to store the exponents of 2 used in the representation of \( n \).
   - It iterates from 59 down to 0, checking if the \( i \)-th bit of \( n \) is set (i.e., if \( n \) is divisible by \( 2^i \)).
   - If a bit is set, it appends \( i \) to `bits`.
   - It then checks if the number of bits exceeds \( k \). If so, it returns `'No'` because it would be impossible to represent \( n \) with \( k \) integers.
   - If the number of bits is less than \( k \), it attempts to adjust the list to ensure exactly \( k \) elements by repeatedly decrementing the last element until the list has \( k \) elements.
   - Finally, it sorts the list in descending order to ensure the lexicographically largest sequence and returns the result.

4. **Edge Cases and Validations:**
   - The code handles the case where \( k \) is greater than \( n \) correctly.
   - The approach to minimize the largest integer and ensure the lexicographically largest sequence is correct.

5. **Conclusion:**
   - The provided solution seems to correctly implement the logic required by the problem statement.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

