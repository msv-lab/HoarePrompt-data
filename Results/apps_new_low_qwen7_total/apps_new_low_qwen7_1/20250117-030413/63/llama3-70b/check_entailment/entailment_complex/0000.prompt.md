
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Since most contestants do not read this part, I have to repeat that Bitlandians are quite weird. They have their own jobs, their own working method, their own lives, their own sausages and their own games!

Since you are so curious about Bitland, I'll give you the chance of peeking at one of these games.

BitLGM and BitAryo are playing yet another of their crazy-looking genius-needed Bitlandish games. They've got a sequence of n non-negative integers a_1, a_2, ..., a_{n}. The players make moves in turns. BitLGM moves first. Each player can and must do one of the two following actions in his turn:

  Take one of the integers (we'll denote it as a_{i}). Choose integer x (1 ≤ x ≤ a_{i}). And then decrease a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x.  Choose integer x $(1 \leq x \leq \operatorname{min}_{i = 1} a_{i})$. And then decrease all a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x, for all i. 

The player who cannot make a move loses.

You're given the initial sequence a_1, a_2, ..., a_{n}. Determine who wins, if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence.


-----Input-----

The first line contains an integer n (1 ≤ n ≤ 3).

The next line contains n integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} < 300).


-----Output-----

Write the name of the winner (provided that both players play optimally well). Either "BitLGM" or "BitAryo" (without the quotes).


-----Examples-----
Input
2
1 1

Output
BitLGM

Input
2
1 2

Output
BitAryo

Input
3
1 2 1

Output
BitLGM

# Annotated Program:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 3, and a_1, a_2, ..., a_n are integers such that 0 ≤ a_i < 300.
def func():
    n = int(input())

a = list(map(int, input().split()))
    while len(a) > 1:
        if min(a) == 0:
            a.remove(0)
        else:
            x = min(a)
            a = [(i - x) for i in a]
        
    #State of the program after the loop has been executed: `n` is either 2 or 3, and the length of list `a` is 1. Each element in list `a` is non-negative and less than 300, and the minimum value of `a` is 0.
    if a :
        print('BitLGM' if a[0] % 2 == 0 else 'BitAryo')
    else :
        print('BitAryo')
    #State of the program after the if-else block has been executed: *`n` is either 2 or 3, and the length of list `a` is 1. Each element in list `a` is non-negative and less than 300, and the minimum value of `a` is 0. If `a` is not an empty list, the program does not change the state of `a` or print anything. If `a` is an empty list or all elements in `a` are truthy (non-zero), 'BitAryo' is printed to the console.
#Overall this is what the function does:The function accepts a list of integers `a` where the length of the list `n` is between 1 and 3 (inclusive), and each integer in the list satisfies \(0 \leq a_i < 300\). It then removes all zeros from the list and adjusts the remaining elements by subtracting the minimum non-zero value, ensuring that the list contains at most one element. After processing, the function prints 'BitLGM' if the single remaining element (if any) is even, and 'BitAryo' otherwise. If the list becomes empty during the process, it prints 'BitAryo'.

# Your response:
Reasoning:  
Correctness: **True** or **False**

