
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Since most contestants do not read this part, I have to repeat that Bitlandians are quite weird. They have their own jobs, their own working method, their own lives, their own sausages and their own games!

Since you are so curious about Bitland, I'll give you the chance of peeking at one of these games.

BitLGM and BitAryo are playing yet another of their crazy-looking genius-needed Bitlandish games. They've got a sequence of n non-negative integers a_1, a_2, ..., a_{n}. The players make moves in turns. BitLGM moves first. Each player can and must do one of the two following actions in his turn:

  Take one of the integers (we'll denote it as a_{i}). Choose integer x (1 ≤ x ≤ a_{i}). And then decrease a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x.  Choose integer x $(1 \leq x \leq \operatorname{min}_{i = 1} a_{i})$. And then decrease all a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x, for all i. 

The player who cannot make a move loses.

You're given the initial sequence a_1, a_2, ..., a_{n}. Determine who wins, if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence.


-----Input-----

The first line contains an integer n (1 ≤ n ≤ 3).

The next line contains n integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} < 300).


-----Output-----

Write the name of the winner (provided that both players play optimally well). Either "BitLGM" or "BitAryo" (without the quotes).


-----Examples-----
Input
2
1 1

Output
BitLGM

Input
2
1 2

Output
BitAryo

Input
3
1 2 1

Output
BitLGM

- Program: 
def func():
    n = int(input())
    a = list(map(int, input().split()))
    while len(a) > 1:
        if min(a) == 0:
            a.remove(0)
        else:
            x = min(a)
            a = [i - x for i in a]
    if a:
        print('BitLGM' if a[0] % 2 == 0 else 'BitAryo')
    else:
        print('BitAryo')



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 3, and a_1, a_2, ..., a_n are integers such that 0 ≤ a_i < 300.
def func():
    n = int(input())

a = list(map(int, input().split()))
    while len(a) > 1:
        if min(a) == 0:
            a.remove(0)
        else:
            x = min(a)
            a = [(i - x) for i in a]
        
    #State of the program after the loop has been executed: `n` is either 2 or 3, and the length of list `a` is 1. Each element in list `a` is non-negative and less than 300, and the minimum value of `a` is 0.
    if a :
        print('BitLGM' if a[0] % 2 == 0 else 'BitAryo')
    else :
        print('BitAryo')
    #State of the program after the if-else block has been executed: *`n` is either 2 or 3, and the length of list `a` is 1. Each element in list `a` is non-negative and less than 300, and the minimum value of `a` is 0. If `a` is not an empty list, the program does not change the state of `a` or print anything. If `a` is an empty list or all elements in `a` are truthy (non-zero), 'BitAryo' is printed to the console.
#Overall this is what the function does:The function accepts a list of integers `a` where the length of the list `n` is between 1 and 3 (inclusive), and each integer in the list satisfies \(0 \leq a_i < 300\). It then removes all zeros from the list and adjusts the remaining elements by subtracting the minimum non-zero value, ensuring that the list contains at most one element. After processing, the function prints 'BitLGM' if the single remaining element (if any) is even, and 'BitAryo' otherwise. If the list becomes empty during the process, it prints 'BitAryo'.


Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The provided program does not correctly implement the game rules. Specifically, the program does not handle the second type of move correctly, where a player can choose an integer \(x\) such that \(1 \leq x \leq \min(a_i)\) and then decrease all \(a_i\) by \(x\). The current implementation only handles the first type of move, where a player chooses an element \(a_i\) and decreases it by \(x\).

For example, consider the input:
```
2
1 2
```
According to the problem description, the optimal play would be:
- BitLGM can choose \(a_2 = 2\) and decrease it by 1, resulting in \(a_1 = 1\) and \(a_2 = 1\).
- Now the minimum value is 1, and BitAryo can choose \(x = 1\) and decrease all elements by 1, resulting in \(a_1 = 0\) and \(a_2 = 0\).
- BitLGM cannot make a move and thus loses.

However, the provided program will incorrectly determine the winner as BitAryo because it does not handle the second type of move properly. Therefore, the program does not meet the requirements of the problem description.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

