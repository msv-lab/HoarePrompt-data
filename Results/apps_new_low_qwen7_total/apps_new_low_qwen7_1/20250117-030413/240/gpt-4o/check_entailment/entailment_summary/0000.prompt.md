
Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
You are given a rectangular grid of lattice points from (0, 0) to (n, m) inclusive. You have to choose exactly 4 different points to build a polyline possibly with self-intersections and self-touching. This polyline should be as long as possible.

A polyline defined by points p_1, p_2, p_3, p_4 consists of the line segments p_1 p_2, p_2 p_3, p_3 p_4, and its length is the sum of the lengths of the individual line segments.


-----Input-----

The only line of the input contains two integers n and m (0 ≤ n, m ≤ 1000). It is guaranteed that grid contains at least 4 different points.


-----Output-----

Print 4 lines with two integers per line separated by space — coordinates of points p_1, p_2, p_3, p_4 in order which represent the longest possible polyline.

Judge program compares your answer and jury's answer with 10^{ - 6} precision.


-----Examples-----
Input
1 1

Output
1 1
0 0
1 0
0 1

Input
0 10

Output
0 1
0 10
0 0
0 9

# Program:
(n, m) = map(int, input().split())
result = func_1(n, m)
for point in result:
    print(point[0], point[1])

def func_1(n, m):
    if n >= 2 and m >= 2:
        points = [(0, 0), (n, 0), (n, m), (0, m)]
    elif n == 0:
        points = [(0, 0), (0, m), (0, 1), (0, m - 1)]
    elif m == 0:
        points = [(0, 0), (n, 0), (1, 0), (n - 1, 0)]
    elif n == 1:
        points = [(0, 0), (1, 0), (1, m), (0, m)]
    else:
        points = [(0, 0), (0, 1), (n, 1), (n, 0)]
    return points





# Execution Summary:
The function `func_1` accepts two parameters `n` and `m`, which are non-negative integers such that 0 ≤ n, m ≤ 1000. It returns a list of points representing specific configurations based on the values of `n` and `m`. The possible configurations are:
- If both `n` and `m` are greater than or equal to 2, the function returns `[(0, 0), (n, 0), (n, m), (0, m)]`.
- If `n` is 0 and `m` is 1, the function returns `[(0, 0), (0, 1), (0, 1), (0, 0)]`.
- If `n` is 0 and `m` is greater than 1, the function returns `[(0, 0), (0, 1), (1, 0), (n - 1, 0)]`.
- If `n` is 1 and `m` is 0, the function returns `[(0, 0), (1, 0), (1, m), (0, m)]`.
- If `n` is 1 and `m` is greater than 0, the function returns `[(0, 0), (0, 1), (n, 1), (n, 0)]`.
- If `n` is greater than 1 and `m` is 0, the function returns `[(0, 0), (1, 0), (1, 1), (0, 1)]`.
- If `n` is greater than 1 and `m` is 1, the function returns `[(0, 0), (0, 1), (n, 1), (n, 0)]`.

The function covers all potential edge cases where `n` and `m` are within the specified range and ensures that at least four different points exist on the grid from (0, 0) to (n, m) inclusive.


# Your response:
Reasoning:  
Correctness: **True** or **False**

