
 Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given two arithmetic progressions: a_1k + b_1 and a_2l + b_2. Find the number of integers x such that L ≤ x ≤ R and x = a_1k' + b_1 = a_2l' + b_2, for some integers k', l' ≥ 0.


-----Input-----

The only line contains six integers a_1, b_1, a_2, b_2, L, R (0 < a_1, a_2 ≤ 2·10^9,  - 2·10^9 ≤ b_1, b_2, L, R ≤ 2·10^9, L ≤ R).


-----Output-----

Print the desired number of integers x.


-----Examples-----
Input
2 0 3 3 5 21

Output
3

Input
2 4 3 0 6 17

Output
2

# Functions with Execution Summary:
(a1, b1, a2, b2, L, R) = map(int, input().split())
print(func_2(a1, b1, a2, b2, L, R))

Function number 1 :
 Code:
 '''
def func_1(a, b):
    if a == 0:
        return (b, 0, 1)
    (gcd, x1, y1) = func_1(b % a, a)
    x = y1 - b // a * x1
    y = x1
    return (gcd, x, y)
''' 

 Output hints for function1:  The function `func_1` accepts two integer parameters `a` and `b`, and optionally `a_2`, `b_2`, `L`, and `R`. It returns either the value `b` within the range \(-2 \cdot 10^9 \leq b \leq 2 \cdot 10^9\) with specific values for the second and third return values, or the greatest common divisor (GCD) of `b % a` and `a`, along with additional calculated values `x` and `y`.

1. If `a` is zero, the function immediately returns `b`, `0`, and `1`.
2. Otherwise, the function recursively calls itself with the arguments `(b % a, a)` to compute the GCD and related values.
3. After the recursive call, it calculates `x` and `y` using the extended Euclidean algorithm.
4. The function then returns the computed GCD, `x`, and `y`.

Edge cases and missing functionality:
- The function assumes `a` is a positive integer greater than zero. If `a` is zero or negative, the behavior is undefined according to the current logic.
- The optional parameters `a_2`, `b_2`, `L`, and `R` are not used in the function body, indicating they might be unused or incorrectly referenced. These should be either used within the function or removed to avoid confusion.
Function number 2 :
 Code:
 '''
def func_2(a1, b1, a2, b2, L, R):
    A = a1
    B = -a2
    C = b2 - b1
    (gcd, x0, y0) = func_1(abs(A), abs(B))
    if C % gcd != 0:
        return -1
    x0 *= C // gcd
    y0 *= C // gcd
    if A < 0:
        x0 = -x0
    if B < 0:
        y0 = -y0
    a1_div_gcd = a1 // gcd
    a2_div_gcd = a2 // gcd

    (x0, y0) = adjust_solution(x0, y0, a1_div_gcd, a2_div_gcd, 1, -1)
    count = 0
    while True:
        val = a1 * x0 + b1
        if val > R:
            break
        if L <= val <= R:
            count += 1
        x0 += a2_div_gcd
        y0 -= a1_div_gcd
    return count
''' 

 Output hints for function2:  The function `func_2` accepts six parameters: `a1`, `b1`, `a2`, `b2`, `L`, and `R`. These parameters are integers where \(0 < a1, a2 \leq 2 \times 10^9\), \(-2 \times 10^9 \leq b1, b2, L, R \leq 2 \times 10^9\), and \(L \leq R\).

The function performs the following steps:
1. Initializes variables `A`, `B`, and `C` using the provided parameters.
2. Calls another function `func_1` to compute the greatest common divisor (`gcd`) and the coefficients `x0` and `y0` for the linear Diophantine equation \(A \cdot x + B \cdot y = C\).
3. Checks if \(C\) is divisible by `gcd`. If not, the function returns `-1`.
4. Adjusts `x0` and `y0` based on the value of `A` and `B`.
5. Divides `a1` and `a2` by `gcd` and stores the results in `a1_div_gcd` and `a2_div_gcd`, respectively.
6. Adjusts the solution `(x0, y0)` using the `adjust_solution` function.
7. Iterates through possible values of `x0` and `y0` to find how many times the expression \(val = a1 \cdot x0 + b1\) falls within the range \([L, R]\).
8. Returns the count of valid values.
Function number 3 :
 Code:
 '''
def adjust_solution(x, y, a1_div_gcd, a2_div_gcd, sign_a1, sign_a2):
    if sign_a1 > 0:
        k = (L - (b1 + a1 * x)) // (a1 * a1_div_gcd)
        x += k * a2_div_gcd
        y -= k * a1_div_gcd
    else:
        k = (R - (b1 + a1 * x)) // (a1 * a1_div_gcd)
        x += k * a2_div_gcd
        y -= k * a1_div_gcd
    if b1 + a1 * x < L:
        x += a2_div_gcd
        y -= a1_div_gcd
    if b1 + a1 * x > R:
        x -= a2_div_gcd
        y += a1_div_gcd
    return (x, y)
''' 

 Output hints for function3:  The function `adjust_solution` accepts parameters `x`, `y`, `a1_div_gcd`, `a2_div_gcd`, `sign_a1`, and `sign_a2`. It updates the values of `x` and `y` based on the given conditions and returns the updated values of `x` and `y`. Specifically, it first calculates an integer `k` based on the value of `sign_a1` and updates `x` and `y` accordingly. Then, it checks if `b1 + a1 * x` is less than `L` or greater than `R` and adjusts `x` and `y` accordingly. If `b1 + a1 * x` is within the range `[L, R]`, the function ensures that `x` and `y` are adjusted to stay within this range. If `sign_a1` is negative, similar adjustments are made but the signs of the updates to `x` and `y` are reversed. The function handles all possible edge cases where `x` and `y` are adjusted to meet the specified constraints.


# Your response:
Reasoning:  
Correctness: **True** or **False**

