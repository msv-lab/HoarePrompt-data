
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Beroffice text editor has a wide range of features that help working with text. One of the features is an automatic search for typos and suggestions of how to fix them.

Beroffice works only with small English letters (i.e. with 26 letters from a to z). Beroffice thinks that a word is typed with a typo if there are three or more consonants in a row in the word. The only exception is that if the block of consonants has all letters the same, then this block (even if its length is greater than three) is not considered a typo. Formally, a word is typed with a typo if there is a block of not less that three consonants in a row, and there are at least two different letters in this block.

For example:

  the following words have typos: "hellno", "hackcerrs" and "backtothefutttture";  the following words don't have typos: "helllllooooo", "tobeornottobe" and "oooooo". 

When Beroffice editor finds a word with a typo, it inserts as little as possible number of spaces in this word (dividing it into several words) in such a way that each of the resulting words is typed without any typos.

Implement this feature of Beroffice editor. Consider the following letters as the only vowels: 'a', 'e', 'i', 'o' and 'u'. All the other letters are consonants in this problem.


-----Input-----

The only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.


-----Output-----

Print the given word without any changes if there are no typos.

If there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.


-----Examples-----
Input
hellno

Output
hell no 

Input
abacaba

Output
abacaba 

Input
asdfasdf

Output
asd fasd f

# Annotated Program:
if __name__ == '__main__':
    word = input().strip()
    print(func_3(word))

#Function 1:
#State of the program right berfore the function call: c is a single character string consisting of a lowercase English letter.
def func_1(c):
    return c in 'aeiou'
    #The program returns True if 'c' is one of 'a', 'e', 'i', 'o', 'u', otherwise returns False

#Function 2:
#State of the program right berfore the function call: block is a non-empty substring of the input word consisting only of small English letters, and it contains at least three consecutive consonants.
def func_2(block):
    if (len(block) < 3) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: block is a non-empty substring of the input word consisting only of small English letters, and it contains at least three consecutive consonants, and the length of block is greater than or equal to 3
    first_consonant = block[0]
    for c in block:
        if c != first_consonant:
            return True
        
    #State of the program after the  for loop has been executed: `block` is a non-empty substring consisting only of the first consonant `first_consonant`, or `block` is empty, and the function returns `True` if any character in `block` is different from `first_consonant`. Otherwise, it returns `None`.
    return False
    #The program returns False

#Function 3:
#State of the program right berfore the function call: word is a non-empty string consisting of lowercase English letters, with a length between 1 and 3000.
def func_3(word):
    n = len(word)

result = []

i = 0
    while i < n:
        start = i
        
        while i < n and not func_1(word[i]):
            i += 1
        
        if i - start >= 3 and func_2(word[start:i]):
            result.append(word[start:start + 2])
            start += 2
            while start < i:
                result.append(word[start:start + 1])
                start += 1
        else:
            result.append(word[start:i])
        
        while i < n and func_1(word[i]):
            i += 1
        
        result.append(word[start:i])
        
    #State of the program after the loop has been executed: `start` is equal to the initial value of `i`, `i` is `n`, `n` remains unchanged, and `result` is a list containing all characters of `word` as individual elements.
    return ' '.join(result)
    #The program returns a string that is the result of joining all characters of `word` as individual elements with a space in between



# Your response:
Reasoning:  
Correctness: **True** or **False**

