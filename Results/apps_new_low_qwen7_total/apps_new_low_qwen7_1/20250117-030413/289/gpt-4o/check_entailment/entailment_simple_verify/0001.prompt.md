
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.

Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.

Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.


-----Input-----

The only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.


-----Output-----

Print the maximum number of games in which the winner of the tournament can take part.


-----Examples-----
Input
2

Output
1

Input
3

Output
2

Input
4

Output
2

Input
10

Output
4



-----Note-----

In all samples we consider that player number 1 is the winner.

In the first sample, there would be only one game so the answer is 1.

In the second sample, player 1 can consequently beat players 2 and 3. 

In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.

- Program: 
def func():
    n = int(input())
    max_games = n.bit_length() - 1
    print(max_games)



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^18.
def func():
    n = int(input())

max_games = n.bit_length() - 1

print(max_games)



Beggining of Original Assessment: 
Reasoning:

The problem requires us to determine the maximum number of games the winner of the tournament can play under the given constraints. The constraints specify that two players can only play if the difference in the number of games they have already played is at most 1. This implies that the tournament can only proceed in such a way that the winner plays in a sequence where the number of games played increases by at most 1 for each match until the final game.

The solution provided uses `n.bit_length() - 1` to determine the maximum number of games the winner can play. Let's break down why this works:

1. **Understanding bit_length**: The method `bit_length()` returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. For example:
   - For `n = 2`, `2.bit_length()` is 2 (binary representation is `10`).
   - For `n = 4`, `4.bit_length()` is 3 (binary representation is `100`).

2. **Max Games Calculation**:
   - The maximum number of games the winner can play is essentially the highest power of 2 less than or equal to `n`. This is because each game reduces the number of remaining players by half (knockout style), and the sequence of games played by the winner must follow the rule that the difference in games played between any two players is at most 1.
   - Therefore, `n.bit_length() - 1` gives us the highest power of 2 less than or equal to `n`.

Let's verify the examples given:
- For `n = 2`, the maximum number of games the winner can play is 1 (binary `10` -> `1`).
- For `n = 3`, the maximum number of games the winner can play is 2 (binary `11` -> `10` and `1`).
- For `n = 4`, the maximum number of games the winner can play is 2 (binary `100` -> `10` and `1`).
- For `n = 10`, the maximum number of games the winner can play is 4 (binary `1010` -> `10` and `10`).

The provided function correctly calculates the maximum number of games the winner can play based on the given constraints.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

