
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.

Anton has a special kettle, that can prepare one potions in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.  Spells of this type speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs b_{i} manapoints and changes the preparation time of each potion to a_{i} instead of x.  Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs d_{i} manapoints and instantly create c_{i} potions. 

Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.

Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions.


-----Input-----

The first line of the input contains three integers n, m, k (1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5) — the number of potions, Anton has to make, the number of spells of the first type and the number of spells of the second type.

The second line of the input contains two integers x and s (2 ≤ x ≤ 2·10^9, 1 ≤ s ≤ 2·10^9) — the initial number of seconds required to prepare one potion and the number of manapoints Anton can use.

The third line contains m integers a_{i} (1 ≤ a_{i} < x) — the number of seconds it will take to prepare one potion if the i-th spell of the first type is used.

The fourth line contains m integers b_{i} (1 ≤ b_{i} ≤ 2·10^9) — the number of manapoints to use the i-th spell of the first type.

There are k integers c_{i} (1 ≤ c_{i} ≤ n) in the fifth line — the number of potions that will be immediately created if the i-th spell of the second type is used. It's guaranteed that c_{i} are not decreasing, i.e. c_{i} ≤ c_{j} if i < j.

The sixth line contains k integers d_{i} (1 ≤ d_{i} ≤ 2·10^9) — the number of manapoints required to use the i-th spell of the second type. It's guaranteed that d_{i} are not decreasing, i.e. d_{i} ≤ d_{j} if i < j.


-----Output-----

Print one integer — the minimum time one has to spent in order to prepare n potions.


-----Examples-----
Input
20 3 2
10 99
2 4 3
20 10 40
4 15
10 80

Output
20

Input
20 3 2
10 99
2 4 3
200 100 400
4 15
100 800

Output
200



-----Note-----

In the first sample, the optimum answer is to use the second spell of the first type that costs 10 manapoints. Thus, the preparation time of each potion changes to 4 seconds. Also, Anton should use the second spell of the second type to instantly prepare 15 potions spending 80 manapoints. The total number of manapoints used is 10 + 80 = 90, and the preparation time is 4·5 = 20 seconds (15 potions were prepared instantly, and the remaining 5 will take 4 seconds each).

In the second sample, Anton can't use any of the spells, so he just prepares 20 potions, spending 10 seconds on each of them and the answer is 20·10 = 200.

- Program: 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    x = int(data[3])
    s = int(data[4])
    a = list(map(int, data[5:5 + m]))
    b = list(map(int, data[5 + m:5 + 2 * m]))
    c = list(map(int, data[5 + 2 * m:5 + 2 * m + k]))
    d = list(map(int, data[5 + 2 * m + k:5 + 2 * m + 2 * k]))
    result = func_1(n, m, k, x, s, a, b, c, d)
    print(result)

def func_1(n, m, k, x, s, a, b, c, d):
    min_time = n * x
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time_with_spell = remaining_potions * x
            min_time = min(min_time, time_with_spell)
    for i in range(m):
        if b[i] <= s:
            time_with_spell = n * a[i]
            min_time = min(min_time, time_with_spell)
    for i in range(m):
        if b[i] <= s:
            remaining_manapoints = s - b[i]
            for j in range(k):
                if d[j] <= remaining_manapoints:
                    remaining_potions = max(0, n - c[j])
                    time_with_both_spells = remaining_potions * a[i]
                    min_time = min(min_time, time_with_both_spells)
                else:
                    break
    return min_time



- Annotated Code: 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    x = int(data[3])
    s = int(data[4])
    a = list(map(int, data[5:5 + m]))
    b = list(map(int, data[5 + m:5 + 2 * m]))
    c = list(map(int, data[5 + 2 * m:5 + 2 * m + k]))
    d = list(map(int, data[5 + 2 * m + k:5 + 2 * m + 2 * k]))
    result = func_1(n, m, k, x, s, a, b, c, d)
    print(result)

#State of the program right berfore the function call: n, m, k, x, s are integers such that 1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5, 2 ≤ x ≤ 2·10^9, 1 ≤ s ≤ 2·10^9; a is a list of m integers where 1 ≤ a_i < x; b is a list of m integers where 1 ≤ b_i ≤ 2·10^9; c is a list of k integers where 1 ≤ c_i ≤ n and c_i are non-decreasing; d is a list of k integers where 1 ≤ d_i ≤ 2·10^9 and d_i are non-decreasing.
def func_1(n, m, k, x, s, a, b, c, d):
    min_time = n * x
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time_with_spell = remaining_potions * x
            min_time = min(min_time, time_with_spell)
        
    #State of the program after the  for loop has been executed: `min_time` is the minimum value of `remaining_potions * x` for all valid `i` (where `d[i] <= s`), and all other variables `n`, `m`, `k`, `x`, `s`, `a`, `b`, `c`, `d` remain in their initial states.
    for i in range(m):
        if b[i] <= s:
            time_with_spell = n * a[i]
            min_time = min(min_time, time_with_spell)
        
    #State of the program after the  for loop has been executed: `i` is `m-1`, `n`, `m`, `k`, `x`, `s`, `a`, `b`, `c`, `d`, and `min_time` are unchanged. If `b[m-1]` is less than or equal to `s`, then `min_time` is updated to the minimum value between the original `min_time` and `n * a[m-1]`. Otherwise, `min_time` remains unchanged.
    for i in range(m):
        if b[i] <= s:
            remaining_manapoints = s - b[i]
            for j in range(k):
                if d[j] <= remaining_manapoints:
                    remaining_potions = max(0, n - c[j])
                    time_with_both_spells = remaining_potions * a[i]
                    min_time = min(min_time, time_with_both_spells)
                else:
                    break
        
    #State of the program after the  for loop has been executed: `i` is `m + k`, `b[m-1]` is unchanged, `min_time` is the minimum value of `time_with_both_spells` found during the entire loop execution, `n`, `m`, `k`, `x`, `s`, `a`, `c`, and `d` are unchanged, and `remaining_manapoints` is unchanged.
    return min_time
    #The program returns min_time which is the minimum value of time_with_both_spells found during the entire loop execution



Beggining of Original Assessment: 
Reasoning:

1. The program reads the input correctly and splits it into the necessary variables.
2. The `func_1` function is designed to calculate the minimum time needed to prepare at least `n` potions using the given spells.
3. The logic in `func_1` checks the following scenarios:
   - Using only a spell of the second type.
   - Using only a spell of the first type.
   - Using both a spell of the first type and a spell of the second type.
4. For each scenario, it calculates the time required to prepare the remaining potions after accounting for the potions instantly created by the second type spell or the reduction in preparation time from the first type spell.
5. The function updates the `min_time` variable with the minimum time found across all scenarios.
6. The logic in the loops seems to cover all the necessary conditions and constraints provided in the problem statement.

Given the above analysis, the program appears to implement the solution correctly according to the problem description.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

