### Reasoning:

Let's analyze the given program step-by-step to ensure its correctness.

1. **Input Parsing:**
   - The program correctly reads the input values `n`, `m`, and `k` using `map(int, input().split())`.

2. **Area Calculation:**
   - The area of the triangle is calculated as `area = n * m / k`.
   - The program checks if this area is an integer by comparing `area` with `int(area)`. If not, it prints "NO", which is correct because non-integer areas mean no integer points can form a triangle with that exact area.

3. **Special Case for Area 0:**
   - If the area is 0, the program prints "NO". This is correct because a triangle with zero area does not exist unless all points are collinear, which isn't the intended scenario.

4. **General Case for Non-Zero Area:**
   - If the area is an integer, the program prints "YES".
   - The program then attempts to find points `(x1, y1)`, `(x2, y2)`, and `(x3, y3)` that satisfy the conditions.
   - It checks if `2 * area <= n` or `2 * area <= m` and selects appropriate coordinates accordingly.
     - If `2 * area <= n`, it sets `(x2, y2) = (2 * area, 1)` and `(x3, y3) = (0, 1)`.
     - If `2 * area <= m`, it sets `(x2, y2) = (1, 2 * area)` and `(x3, y3) = (1, 0)`.
     - Otherwise, it sets `(x2, y2) = (n, m // 2)` and `(x3, y3) = (0, m // 2)`.

5. **Edge Cases:**
   - The program handles the edge cases where `2 * area` exceeds both `n` and `m` by choosing points along the boundaries of the grid, ensuring they still form a triangle with the required area.

Given these steps, the logic of the program appears sound and should correctly handle the given constraints and requirements.

### Conclusion:
The program correctly implements the solution to the problem, considering all specified conditions and edge cases.

**Correctness: True**