
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into a pieces, and the second one — into b pieces.

Ivan knows that there will be n people at the celebration (including himself), so Ivan has set n plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:  Each piece of each cake is put on some plate;  Each plate contains at least one piece of cake;  No plate contains pieces of both cakes. 

To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number x such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least x pieces of cake.

Help Ivan to calculate this number x!


-----Input-----

The first line contains three integers n, a and b (1 ≤ a, b ≤ 100, 2 ≤ n ≤ a + b) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.


-----Output-----

Print the maximum possible number x such that Ivan can distribute the cake in such a way that each plate will contain at least x pieces of cake.


-----Examples-----
Input
5 2 3

Output
1

Input
4 7 10

Output
3



-----Note-----

In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.

- Program: 

#Function 1:
def func_1(n, a, b):
    (low, high) = (1, min(a, b) + 1)

    while low < high:
        mid = (low + high) // 2
        if can_distribute(mid):
            low = mid + 1
        else:
            high = mid
    return low - 1

#Function 2:
def can_distribute(x):
    return a // x + b // x >= n



- Annotated Code: 
(n, a, b) = map(int, input().split())
print(func_1(n, a, b))

#Function 1:
#State of the program right berfore the function call: n, a, and b are positive integers such that 1 ≤ a, b ≤ 100 and 2 ≤ n ≤ a + b.
def func_1(n, a, b):
    low, high = 1, min(a, b) + 1
    while low < high:
        mid = (low + high) // 2
        
        if can_distribute(mid):
            low = mid + 1
        else:
            high = mid
        
    #State of the program after the loop has been executed: `n` is a positive integer such that \(2 \leq n \leq a + b\), `a` is a positive integer such that \(1 \leq a \leq 100\), `b` is a positive integer such that \(1 \leq b \leq 100\), `low` = `high` and both are the value where the `can_distribute(mid)` function transitions from `False` to `True` or vice versa.
    return low - 1
    #The program returns a value that is one less than the transition point where the `can_distribute(mid)` function changes its boolean value from `False` to `True` or vice versa, denoted as `low - 1`. Given the initial conditions, `low` equals `high` at this transition point.
#Overall this is what the function does:The function `func_1` accepts three parameters: `n`, `a`, and `b`, which are positive integers such that \(2 \leq n \leq a + b\) and \(1 \leq a, b \leq 100\). It uses a binary search algorithm to find the smallest integer `k` such that `can_distribute(k)` returns `True`. The function returns `k - 1`, which is one less than the transition point where `can_distribute(mid)` changes its boolean value from `False` to `True` or vice versa. If no such `k` exists, the function will return the maximum possible value within the given constraints, i.e., `min(a, b)`.

The function performs the following actions:
1. Initializes `low` to 1 and `high` to the minimum of `a` and `b` plus one.
2. Enters a loop that continues until `low` equals `high`.
3. Inside the loop, calculates `mid` as the integer division of the sum of `low` and `high` by 2.
4. Calls the `can_distribute(mid)` function and adjusts `low` or `high` based on the result.
5. Returns `low - 1` after the loop terminates, which is the desired transition point minus one.

Potential edge cases and missing functionality:
- If `can_distribute(mid)` always returns `False`, the loop will run until `low` equals `high`, and the function will return `min(a, b) - 1`. This ensures the function handles cases where the condition is never met.

#Function 2:
#State of the program right berfore the function call: a and b are positive integers representing the number of pieces of the first and second cake, respectively, and n is a positive integer representing the number of plates such that 1 <= a, b <= 100 and 2 <= n <= a + b.
def can_distribute(x):
    return a // x + b // x >= n
    #`The program returns the result of (a // x) + (b // x) which is greater than or equal to n`
#Overall this is what the function does:The function `can_distribute` accepts a parameter `x` derived from positive integers `a` and `b` (representing the number of pieces of two cakes) and a positive integer `n` (representing the number of plates). It returns `True` if `(a // x) + (b // x)` is greater than or equal to `n`, otherwise it returns `False`. The function checks if it is possible to distribute the pieces of both cakes among `n` plates such that each plate gets at least one piece from each cake. The function does not modify the input variables `a`, `b`, and `n`. Potential edge cases include when `x` is `1` (resulting in `a + b // x`), or when `x` is greater than both `a` and `b` (resulting in `0 + 0`).




Beggining of Original Assessment: 
### Reasoning:
1. **Binary Search Approach**: The function `func_1` uses binary search to find the maximum possible value of `x` such that each plate will contain at least `x` pieces of cake.
2. **Binary Search Range**: The initial range for `low` and `high` is set correctly, considering the constraints \(1 \leq a, b \leq 100\) and \(2 \leq n \leq a + b\). The upper limit of the range is `min(a, b) + 1` because we cannot have more than `min(a, b)` plates if each plate must have at least one piece of cake from either one of the cakes.
3. **Binary Search Loop**: The loop continues until `low` equals `high`. During each iteration, `mid` is calculated, and the helper function `can_distribute(mid)` checks if it is possible to distribute the cakes such that each plate gets at least `mid` pieces of cake.
4. **Helper Function**: The `can_distribute` function correctly calculates whether it is possible to distribute the cakes by checking if the total number of pieces divided by `x` (considering both cakes) is greater than or equal to `n`.
5. **Final Result**: The result `low - 1` is returned, which represents the maximum value of `x` that satisfies the conditions.

Given the logic and the constraints, the implementation appears to be correct.

### Correctness:
**True**

The provided program correctly implements the logic to find the maximum possible number `x` such that each plate will contain at least `x` pieces of cake.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

