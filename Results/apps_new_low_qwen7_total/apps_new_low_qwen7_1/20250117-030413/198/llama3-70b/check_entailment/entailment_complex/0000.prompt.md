
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
An online contest will soon be held on ForceCoders, a large competitive programming platform. The authors have prepared $n$ problems; and since the platform is very popular, $998244351$ coder from all over the world is going to solve them.

For each problem, the authors estimated the number of people who would solve it: for the $i$-th problem, the number of accepted solutions will be between $l_i$ and $r_i$, inclusive.

The creator of ForceCoders uses different criteria to determine if the contest is good or bad. One of these criteria is the number of inversions in the problem order. An inversion is a pair of problems $(x, y)$ such that $x$ is located earlier in the contest ($x < y$), but the number of accepted solutions for $y$ is strictly greater.

Obviously, both the creator of ForceCoders and the authors of the contest want the contest to be good. Now they want to calculate the probability that there will be no inversions in the problem order, assuming that for each problem $i$, any integral number of accepted solutions for it (between $l_i$ and $r_i$) is equally probable, and all these numbers are independent.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 50$) — the number of problems in the contest.

Then $n$ lines follow, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \le l_i \le r_i \le 998244351$) — the minimum and maximum number of accepted solutions for the $i$-th problem, respectively.


-----Output-----

The probability that there will be no inversions in the contest can be expressed as an irreducible fraction $\frac{x}{y}$, where $y$ is coprime with $998244353$. Print one integer — the value of $xy^{-1}$, taken modulo $998244353$, where $y^{-1}$ is an integer such that $yy^{-1} \equiv 1$ $(mod$ $998244353)$.


-----Examples-----
Input
3
1 2
1 2
1 2

Output
499122177

Input
2
42 1337
13 420

Output
578894053

Input
2
1 1
0 0

Output
1

Input
2
1 1
1 1

Output
1



-----Note-----

The real answer in the first test is $\frac{1}{2}$.

# Annotated Functions:
import math

MOD = 998244353
n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
res = 1
for i in range(n):
    cnt = 1
    for j in range(i + 1, n):
        if a[i][0] <= a[j][1]:
            cnt = func_1(cnt, a[j][1] - a[i][0] + 1)
    res = func_1(res, cnt)
for i in range(n):
    res = func_1(res, func_3(a[i][1] - a[i][0] + 1))
print(res)

#Function 1:
#State of the program right berfore the function call: a and b are non-negative integers such that 0 <= a, b < 998244353.
def func_1(a, b):
    return a * b % MOD
    #The program returns (a * b) % 998244353
#Overall this is what the function does:The function `func_1` accepts two parameters `a` and `b`, both non-negative integers such that \(0 \leq a, b < 998244353\). It returns the result of \((a \times b) \% 998244353\). The function performs the multiplication of `a` and `b` and then takes the modulus with respect to \(998244353\). There are no edge cases mentioned in the annotations or code, and the provided return postcondition accurately reflects the intended behavior of the function.

#Function 2:
#State of the program right berfore the function call: a and b are non-negative integers, with \( b \neq 0 \). Function `func_1` is assumed to be a valid multiplication function that returns the product of its two integer arguments modulo \( 998244353 \).
def func_2(a, b):
    res = 1
    while b > 0:
        if b & 1:
            res = func_1(res, a)
        
        a = func_1(a, a)
        
        b >>= 1
        
    #State of the program after the loop has been executed: a is the result of repeatedly applying func_1(a, a) until it is applied b times, b is 0, res is the result of repeatedly applying func_1(a, a) until it is applied the same number of times as the final value of b (if b was odd, one additional application of func_1(a, a) compared to even b).
    return res
    #The program returns res which is the result of repeatedly applying func_1(a, a) until it is applied the same number of times as the final value of b (if b was odd, one additional application of func_1(a, a) compared to even b)
#Overall this is what the function does:The function `func_2` accepts two parameters `a` and `b`, where both are non-negative integers and `b` is not zero. It returns `res`, which is the result of repeatedly applying `func_1(a, a)` the appropriate number of times based on the value of `b`. Specifically, `func_1(a, a)` is applied `b` times if `b` is even, and `b + 1` times if `b` is odd. The function achieves this through a loop that halves `b` in each iteration and applies `func_1(a, a)` to `a` if `b` is odd. The variable `res` accumulates the result of these applications.

#Function 3:
#State of the program right berfore the function call: a is an integer and 1 ≤ a < 998244353.
def func_3(a):
    return func_2(a, MOD - 2)
    #The program returns the value of `func_2(a, 998244351)` where `a` is an integer and 1 ≤ a < 998244353, and `MOD` is 998244353
#Overall this is what the function does:The function `func_3` accepts an integer `a` such that 1 ≤ a < 998244353. It then calls another function `func_2` with the arguments `a` and `MOD - 2`, where `MOD` is defined as 998244353. The function returns the result of `func_2(a, 998244351)`. The potential edge case to consider is when `a` is exactly 1 or when `a` is equal to `MOD - 1`, as these values might have specific implications depending on the implementation of `func_2`. There is no missing functionality indicated in the provided code; however, without the definition of `func_2`, we cannot determine the exact nature of the operation performed by `func_2(a, 998244351)`. The final state of the program after the function concludes is that the variable holding the return value of `func_3` contains the result of `func_2(a, 998244351)`.




# Your response:
Reasoning:  
Correctness: **True** or **False**

