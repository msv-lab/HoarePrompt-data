
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Since most contestants do not read this part, I have to repeat that Bitlandians are quite weird. They have their own jobs, their own working method, their own lives, their own sausages and their own games!

Since you are so curious about Bitland, I'll give you the chance of peeking at one of these games.

BitLGM and BitAryo are playing yet another of their crazy-looking genius-needed Bitlandish games. They've got a sequence of n non-negative integers a_1, a_2, ..., a_{n}. The players make moves in turns. BitLGM moves first. Each player can and must do one of the two following actions in his turn:

  Take one of the integers (we'll denote it as a_{i}). Choose integer x (1 ≤ x ≤ a_{i}). And then decrease a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x.  Choose integer x $(1 \leq x \leq \operatorname{min}_{i = 1} a_{i})$. And then decrease all a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x, for all i. 

The player who cannot make a move loses.

You're given the initial sequence a_1, a_2, ..., a_{n}. Determine who wins, if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence.


-----Input-----

The first line contains an integer n (1 ≤ n ≤ 3).

The next line contains n integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} < 300).


-----Output-----

Write the name of the winner (provided that both players play optimally well). Either "BitLGM" or "BitAryo" (without the quotes).


-----Examples-----
Input
2
1 1

Output
BitLGM

Input
2
1 2

Output
BitAryo

Input
3
1 2 1

Output
BitLGM

- Program: 
def func():
    n = int(input())
    a = list(map(int, input().split()))
    while len(a) > 1:
        if min(a) == 0:
            a.remove(0)
        else:
            x = min(a)
            a = [i - x for i in a]
    if a:
        print('BitLGM' if a[0] % 2 == 0 else 'BitAryo')
    else:
        print('BitAryo')



- Annotated Code: 
#State of the program right berfore the function call: The input consists of two lines. The first line contains an integer n where 1 ≤ n ≤ 3. The second line contains n integers a_1, a_2, ..., a_{n} where 0 ≤ a_{i} < 300.
def func():
    n = int(input())

a = list(map(int, input().split()))
    while len(a) > 1:
        if min(a) == 0:
            a.remove(0)
        else:
            x = min(a)
            a = [(i - x) for i in a]
        
    #State of the program after the loop has been executed: a is a list with a single element, which is the minimum value of the original list `a`. n is 1.
    if a :
        print('BitLGM' if a[0] % 2 == 0 else 'BitAryo')
    else :
        print('BitAryo')
    #State of the program after the if-else block has been executed: *`a` is a list with a single element, which is the minimum value of the original list `a`. `n` remains 1 regardless of whether the if condition is met or not.



Beggining of Original Assessment: 
### Reasoning:
To determine the correctness of the given program, let's analyze its logic step-by-step and compare it with the problem statement and examples provided.

1. **Input Handling**:
   - The program correctly reads the number of elements `n` and the sequence `a`.
   
2. **Game Logic**:
   - The while loop runs until there is only one element left in the list `a`.
   - Inside the loop, the program checks if the minimum value in `a` is zero. If so, it removes that zero, indicating a valid move where no further reduction can be made.
   - If the minimum value is not zero, it chooses the minimum value `x` and subtracts `x` from each element in `a`.

3. **Winning Condition**:
   - After the loop, the program checks if there is any element left in `a`. If yes, it determines the winner based on the parity of the remaining element (`a[0]`):
     - If `a[0]` is even, BitLGM wins.
     - If `a[0]` is odd, BitAryo wins.
   - If the list `a` becomes empty during the loop, BitAryo is declared the winner (since BitLGM cannot make a move).

4. **Optimal Play**:
   - The problem requires optimal play from both players. However, the given program does not explicitly implement a strategy for optimal play but rather follows a straightforward approach based on the minimum value in the list. This approach might not always reflect optimal play in complex scenarios.

5. **Examples**:
   - For the input "2 1 1", the program correctly outputs "BitLGM".
   - For the input "2 1 2", the program correctly outputs "BitAryo".
   - For the input "3 1 2 1", the program correctly outputs "BitLGM".

Given the analysis, the program appears to handle the basic logic correctly and produce the expected output for the provided examples. However, the solution does not necessarily guarantee optimal play in all cases due to its simplistic approach.

### Conclusion:
Despite the simplicity, the provided solution seems to work correctly for the given constraints and examples. Therefore, the correctness of the program can be considered True under the assumption that the problem's constraints and examples are representative.

**Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

