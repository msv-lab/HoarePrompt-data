
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Memory and his friend Lexa are competing to get higher score in one popular computer game. Memory starts with score a and Lexa starts with score b. In a single turn, both Memory and Lexa get some integer in the range [ - k;k] (i.e. one integer among  - k,  - k + 1,  - k + 2, ...,  - 2,  - 1, 0, 1, 2, ..., k - 1, k) and add them to their current scores. The game has exactly t turns. Memory and Lexa, however, are not good at this game, so they both always get a random integer at their turn.

Memory wonders how many possible games exist such that he ends with a strictly higher score than Lexa. Two games are considered to be different if in at least one turn at least one player gets different score. There are (2k + 1)^2t games in total. Since the answer can be very large, you should print it modulo 10^9 + 7. Please solve this problem for Memory.


-----Input-----

The first and only line of input contains the four integers a, b, k, and t (1 ≤ a, b ≤ 100, 1 ≤ k ≤ 1000, 1 ≤ t ≤ 100) — the amount Memory and Lexa start with, the number k, and the number of turns respectively.


-----Output-----

Print the number of possible games satisfying the conditions modulo 1 000 000 007 (10^9 + 7) in one line.


-----Examples-----
Input
1 2 2 1

Output
6

Input
1 1 1 2

Output
31

Input
2 12 3 1

Output
0



-----Note-----

In the first sample test, Memory starts with 1 and Lexa starts with 2. If Lexa picks  - 2, Memory can pick 0, 1, or 2 to win. If Lexa picks  - 1, Memory can pick 1 or 2 to win. If Lexa picks 0, Memory can pick 2 to win. If Lexa picks 1 or 2, Memory cannot win. Thus, there are 3 + 2 + 1 = 6 possible games in which Memory wins.

- Program: 
MOD = 10 ** 9 + 7
(a, b, k, t) = map(int, input().split())
func_1(a, b, k, t)

def func_1(a, b, k, t):
    max_diff = 2 * k * t
    dp_prev = [0] * (2 * max_diff + 1)
    dp_curr = [0] * (2 * max_diff + 1)
    dp_prev[max_diff + (a - b)] = 1
    for _ in range(t):
        prefix_sum = [0] * (2 * max_diff + 3)
        for i in range(2 * max_diff + 1):
            prefix_sum[i + 1] = (prefix_sum[i] + dp_prev[i]) % MOD
        for i in range(2 * max_diff + 1):
            left = max(0, i - 2 * k)
            right = min(2 * max_diff, i + 2 * k) + 1
            dp_curr[i] = (prefix_sum[right] - prefix_sum[left]) % MOD
        (dp_prev, dp_curr) = (dp_curr, dp_prev)
    result = 0
    for i in range(max_diff + 1, 2 * max_diff + 1):
        result = (result + dp_prev[i]) % MOD
    print(result)



- Annotated Code: 
MOD = 10 ** 9 + 7
(a, b, k, t) = map(int, input().split())
func_1(a, b, k, t)

#State of the program right berfore the function call: a, b, and k are integers such that 1 ≤ a, b ≤ 100 and 1 ≤ k ≤ 1000, and t is an integer such that 1 ≤ t ≤ 100.
def func_1(a, b, k, t):
    max_diff = 2 * k * t

dp_prev = [0] * (2 * max_diff + 1)

dp_curr = [0] * (2 * max_diff + 1)

dp_prev[max_diff + (a - b)] = 1
    for _ in range(t):
        prefix_sum = [0] * (2 * max_diff + 3)
        
        for i in range(2 * max_diff + 1):
            prefix_sum[i + 1] = (prefix_sum[i] + dp_prev[i]) % MOD
        
        for i in range(2 * max_diff + 1):
            left = max(0, i - 2 * k)
            right = min(2 * max_diff, i + 2 * k) + 1
            dp_curr[i] = (prefix_sum[right] - prefix_sum[left]) % MOD
        
        dp_prev, dp_curr = dp_curr, dp_prev
        
    #State of the program after the  for loop has been executed: `t` must be greater than or equal to 3, `prefix_sum` is a list of length 2 * `max_diff` + 3 where the first two elements are 0 and the remaining elements are the cumulative sum of `dp_prev` values modulo `MOD` starting from index 1, `i` is 0, `left` is `max(0, i - 2 * k)`, `right` is `min(2 * max_diff, i + 2 * k) + 1`, `dp_prev` now holds the value of `dp_curr` from the previous iteration, `dp_curr` now holds the updated value based on the sum of `prefix_sum` values between `left` and `right` for the current iteration
    result = 0
    for i in range(max_diff + 1, 2 * max_diff + 1):
        result = (result + dp_prev[i]) % MOD
        
    #State of the program after the  for loop has been executed: Output State: `t` is greater than or equal to 3, `prefix_sum` is a list of length \(2 \times \text{max\_diff} + 3\) with the first two elements being 0 and the rest being the cumulative sum of `dp_prev` values modulo `MOD` starting from index 1, `i` is \(2 \times \text{max\_diff} + 1\), `left` is \(\max(0, (2 \times \text{max\_diff} + 1) - 2 \times k)\), `right` is \(\min(2 \times \text{max\_diff}, (2 \times \text{max\_diff} + 1) + 2 \times k) + 1\), `dp_prev` holds the value of `dp_curr` from the previous iteration, `result` is the sum of all `dp_prev` values from index \(\max(0, \text{max\_diff} + 1 - 2k)\) to \(2 \times \text{max\_diff} + 1\) modulo `MOD`.
    #
    #### Explanation:
    #1. **Analyze the Code and Initial State**:
    #   - The loop iterates from `i = max_diff + 1` to `i = 2 * max_diff`.
    #   - Inside the loop, it updates the `result` by adding the value of `dp_prev[i]` to `result` and taking the modulo `MOD`.
    #
    #2. **Track Variable Changes**:
    #   - `i` starts at `max_diff + 1` and increments by 1 in each iteration until it reaches `2 * max_diff`.
    #   - `result` is updated in each iteration by adding the value of `dp_prev[i]` and taking the modulo `MOD`.
    #   - `left` and `right` are calculated based on `i` and `k`, but their values do not affect the final `result` as the loop directly accesses `dp_prev[i]`.
    #   - `dp_prev` and `dp_curr` are updated based on the prefix sum but remain invariant in terms of the loop’s effect on `result`.
    #
    #3. **Summarize the Loop Behavior**:
    #   - After the loop completes, `i` will be \(2 \times \text{max\_diff} + 1\).
    #   - The `result` will be the sum of `dp_prev` values from `max(0, max_diff + 1 - 2k)` to \(2 \times \text{max\_diff} + 1\) modulo `MOD`.
    #
    #4. **Verify Relationships**:
    #   - The final `result` is consistent with the cumulative addition of `dp_prev` values within the specified range.
    #   - The `prefix_sum` remains unchanged and continues to hold the cumulative sums of `dp_prev` values modulo `MOD`.
    #
    #Thus, the final state after the loop has executed all its iterations is as described above.
    print(result)



Beggining of Original Assessment: 
Correctness: **True**

Explanation: The provided program appears to correctly implement the dynamic programming solution for the problem. It calculates the number of possible games where Memory ends up with a strictly higher score than Lexa after `t` turns. The approach uses a DP table (`dp_prev` and `dp_curr`) to keep track of the number of ways to achieve each possible score difference. The code handles the modulo operation correctly and iterates through all possible scenarios, ensuring that all valid games are accounted for. Given the constraints and the logic implemented, the program seems to cover all necessary cases without missing any. Therefore, it is correct according to the problem description.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

