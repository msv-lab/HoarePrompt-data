
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Memory and his friend Lexa are competing to get higher score in one popular computer game. Memory starts with score a and Lexa starts with score b. In a single turn, both Memory and Lexa get some integer in the range [ - k;k] (i.e. one integer among  - k,  - k + 1,  - k + 2, ...,  - 2,  - 1, 0, 1, 2, ..., k - 1, k) and add them to their current scores. The game has exactly t turns. Memory and Lexa, however, are not good at this game, so they both always get a random integer at their turn.

Memory wonders how many possible games exist such that he ends with a strictly higher score than Lexa. Two games are considered to be different if in at least one turn at least one player gets different score. There are (2k + 1)^2t games in total. Since the answer can be very large, you should print it modulo 10^9 + 7. Please solve this problem for Memory.


-----Input-----

The first and only line of input contains the four integers a, b, k, and t (1 ≤ a, b ≤ 100, 1 ≤ k ≤ 1000, 1 ≤ t ≤ 100) — the amount Memory and Lexa start with, the number k, and the number of turns respectively.


-----Output-----

Print the number of possible games satisfying the conditions modulo 1 000 000 007 (10^9 + 7) in one line.


-----Examples-----
Input
1 2 2 1

Output
6

Input
1 1 1 2

Output
31

Input
2 12 3 1

Output
0



-----Note-----

In the first sample test, Memory starts with 1 and Lexa starts with 2. If Lexa picks  - 2, Memory can pick 0, 1, or 2 to win. If Lexa picks  - 1, Memory can pick 1 or 2 to win. If Lexa picks 0, Memory can pick 2 to win. If Lexa picks 1 or 2, Memory cannot win. Thus, there are 3 + 2 + 1 = 6 possible games in which Memory wins.

- Program:
MOD = 10 ** 9 + 7
(a, b, k, t) = map(int, input().split())
func_1(a, b, k, t)

def func_1(a, b, k, t):
    max_diff = 2 * k * t
    dp_prev = [0] * (2 * max_diff + 1)
    dp_curr = [0] * (2 * max_diff + 1)
    dp_prev[max_diff + (a - b)] = 1
    for _ in range(t):
        prefix_sum = [0] * (2 * max_diff + 3)
        for i in range(2 * max_diff + 1):
            prefix_sum[i + 1] = (prefix_sum[i] + dp_prev[i]) % MOD
        for i in range(2 * max_diff + 1):
            left = max(0, i - 2 * k)
            right = min(2 * max_diff, i + 2 * k) + 1
            dp_curr[i] = (prefix_sum[right] - prefix_sum[left]) % MOD
        (dp_prev, dp_curr) = (dp_curr, dp_prev)
    result = 0
    for i in range(max_diff + 1, 2 * max_diff + 1):
        result = (result + dp_prev[i]) % MOD
    print(result)



- Function Summary: 
- The function does not handle the case where `t` is less than 3. If `t < 3`, the loop would not execute, and the initial values of `dp_prev` might not be properly utilized, leading to incorrect results.
- The function assumes that `MOD` is defined and known. If `MOD` is not defined, the function will raise a NameError.
- The function does not check for potential overflow issues when performing arithmetic operations modulo `MOD`.

Beggining of Original Assessment: 
### Reasoning:

1. **Problem Understanding**: 
   - The problem requires calculating the number of possible outcomes where Memory's final score is strictly greater than Lexa's final score.
   - Each turn, both players add an integer from the range \([-k, k]\) to their current scores.
   - The game has exactly `t` turns.
   - The answer must be computed modulo \(10^9 + 7\).

2. **Approach Breakdown**:
   - The solution uses dynamic programming (DP) to keep track of the number of ways each player can achieve a certain difference in scores.
   - `max_diff` is calculated as \(2kt\) since the maximum possible difference in scores over `t` turns is \(2kt\).
   - `dp_prev` and `dp_curr` arrays are used to store the DP states.
   - A `prefix_sum` array is used to efficiently compute the sum of elements in a subarray, which helps in updating the `dp_curr` array.

3. **Code Analysis**:
   - **Initialization**: `dp_prev` and `dp_curr` are initialized with size `2 * max_diff + 1`.
   - **Initial State**: `dp_prev[max_diff + (a - b)] = 1` sets the initial state where the difference between Memory's and Lexa's starting scores is considered.
   - **Dynamic Programming Transition**:
     - For each turn, `prefix_sum` is updated to keep running totals of `dp_prev`.
     - `dp_curr` is updated using the prefix sums to calculate the number of ways to achieve each possible score difference.
     - The transition ensures that the next state (`dp_curr`) is computed based on the current state (`dp_prev`).
   - **Result Calculation**: The result is obtained by summing up the values in `dp_prev` from `max_diff + 1` to `2 * max_diff`, which represents all possible ways Memory can have a higher score than Lexa.

4. **Edge Cases and Constraints**:
   - The code handles the constraints \(1 \leq a, b \leq 100\), \(1 \leq k \leq 1000\), and \(1 \leq t \leq 100\).
   - The use of modulo \(10^9 + 7\) ensures the result fits within standard integer limits.

Given the detailed analysis, the provided code appears to correctly implement the solution for the given problem.

### Conclusion:
Correctness: **True**

The provided program is correct and follows the required logic to solve the problem accurately.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

