
 Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given two arithmetic progressions: a_1k + b_1 and a_2l + b_2. Find the number of integers x such that L ≤ x ≤ R and x = a_1k' + b_1 = a_2l' + b_2, for some integers k', l' ≥ 0.


-----Input-----

The only line contains six integers a_1, b_1, a_2, b_2, L, R (0 < a_1, a_2 ≤ 2·10^9,  - 2·10^9 ≤ b_1, b_2, L, R ≤ 2·10^9, L ≤ R).


-----Output-----

Print the desired number of integers x.


-----Examples-----
Input
2 0 3 3 5 21

Output
3

Input
2 4 3 0 6 17

Output
2

# Functions with Execution Summary:
(a1, b1, a2, b2, L, R) = map(int, input().split())
print(func_2(a1, b1, a2, b2, L, R))

Function number 1 :
 Code:
 '''
def func_1(a, b):
    if a == 0:
        return (b, 0, 1)
    (gcd, x1, y1) = func_1(b % a, a)
    x = y1 - b // a * x1
    y = x1
    return (gcd, x, y)
''' 

 Output hints for function1:  The function `func_1` accepts two parameters `a` and `b`, both of which are integers with specific constraints: `0 < a, a2 ≤ 2·10^9` and `-2·10^9 ≤ b, b2 ≤ 2·10^9`. The function aims to compute the greatest common divisor (gcd) of `a` and `b`, and find the coefficients `x` and `y` such that `ax + by = gcd(a, b)`.

The function operates through recursion. If `a` is zero, it returns `b`, 0, 1 as per the base case. Otherwise, it recursively computes the gcd using the Euclidean algorithm, adjusting the coefficients `x` and `y` accordingly until the gcd is found. The function then returns the gcd and the coefficients `x` and `y`.

Potential edge cases and missing functionality:
- The function correctly handles the case where `a` is zero by returning `b`, 0, 1.
- However, the function does not explicitly handle the case where `b` is zero. In practice, if `b` is zero, the gcd would be `a` and the coefficients would be `1` and `0` respectively.
- The function assumes that the initial call to `func_1` does not have both `a` and `b` as zero, which is a valid assumption given the constraints.

After the function concludes, the program will return either `b', 0, 1` if `b` is within the specified range and `a` is zero, or `gcd, x, y` where `gcd` is the greatest common divisor of `a` and `b`, and `x` and `y` are the coefficients such that `ax + by = gcd(a, b)`.
Function number 2 :
 Code:
 '''
def func_2(a1, b1, a2, b2, L, R):
    A = a1
    B = -a2
    C = b2 - b1
    (gcd, x0, y0) = func_1(abs(A), abs(B))
    if C % gcd != 0:
        return -1
    x0 *= C // gcd
    y0 *= C // gcd
    if A < 0:
        x0 = -x0
    if B < 0:
        y0 = -y0
    a1_div_gcd = a1 // gcd
    a2_div_gcd = a2 // gcd

    (x0, y0) = adjust_solution(x0, y0, a1_div_gcd, a2_div_gcd, 1, -1)
    count = 0
    while True:
        val = a1 * x0 + b1
        if val > R:
            break
        if L <= val <= R:
            count += 1
        x0 += a2_div_gcd
        y0 -= a1_div_gcd
    return count
''' 

 Output hints for function2:  - The function handles the case where `C` is not divisible by the GCD by returning -1, ensuring that the subsequent calculations do not proceed if the conditions are not met.
- The function ensures that `x0` and `y0` are correctly adjusted based on the signs of `A` and `B` to maintain the relationship between the variables.
- The loop continues until `val` exceeds `R`, ensuring that all possible valid values are considered within the given range.
Function number 3 :
 Code:
 '''
def adjust_solution(x, y, a1_div_gcd, a2_div_gcd, sign_a1, sign_a2):
    if sign_a1 > 0:
        k = (L - (b1 + a1 * x)) // (a1 * a1_div_gcd)
        x += k * a2_div_gcd
        y -= k * a1_div_gcd
    else:
        k = (R - (b1 + a1 * x)) // (a1 * a1_div_gcd)
        x += k * a2_div_gcd
        y -= k * a1_div_gcd
    if b1 + a1 * x < L:
        x += a2_div_gcd
        y -= a1_div_gcd
    if b1 + a1 * x > R:
        x -= a2_div_gcd
        y += a1_div_gcd
    return (x, y)
''' 

 Output hints for function3:  The function `adjust_solution` accepts parameters `x`, `y`, `a1_div_gcd`, `a2_div_gcd`, `sign_a1`, and `sign_a2`. It updates the values of `x` and `y` based on the conditions involving `b1`, `a1`, `L`, and `R`. Specifically:

1. If `sign_a1 > 0`, it calculates `k` using `(L - (b1 + a1 * x)) // (a1 * a1_div_gcd)` and adjusts `x` and `y` accordingly.
2. If `b1 + a1 * x < L`, it further updates `x` to `x + a2_div_gcd` and `y` to `y - a1_div_gcd`.
3. If `b1 + a1 * x > R`, it adjusts `x` to `x - a2_div_gcd` and `y` to `y + a1_div_gcd`.

After these adjustments, the function returns the updated values of `x` and `y`.

Potential edge cases and missing functionality:
- The function assumes that `a1` and `a2` are not zero, which is not explicitly checked in the code.
- There is no handling for the case when `b1 + a1 * x == L` or `b1 + a1 * x == R`, which could lead to unexpected behavior depending on the specific requirements.
- The function does not modify `a1_div_gcd`, `a2_div_gcd`, `sign_a1`, `sign_a2`, `L`, and `R` as stated in the annotations, ensuring these parameters remain unchanged.


# Your response:
Reasoning:  
Correctness: **True** or **False**

