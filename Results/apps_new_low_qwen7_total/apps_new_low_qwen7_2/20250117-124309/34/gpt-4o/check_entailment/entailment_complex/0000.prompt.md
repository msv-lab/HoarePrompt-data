
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given two arithmetic progressions: a_1k + b_1 and a_2l + b_2. Find the number of integers x such that L ≤ x ≤ R and x = a_1k' + b_1 = a_2l' + b_2, for some integers k', l' ≥ 0.


-----Input-----

The only line contains six integers a_1, b_1, a_2, b_2, L, R (0 < a_1, a_2 ≤ 2·10^9,  - 2·10^9 ≤ b_1, b_2, L, R ≤ 2·10^9, L ≤ R).


-----Output-----

Print the desired number of integers x.


-----Examples-----
Input
2 0 3 3 5 21

Output
3

Input
2 4 3 0 6 17

Output
2

# Annotated Functions:
(a1, b1, a2, b2, L, R) = map(int, input().split())
print(func_2(a1, b1, a2, b2, L, R))

#Function 1:
#State of the program right berfore the function call: a, b, a2, b2, L, R are integers where 0 < a, a2 ≤ 2·10^9, -2·10^9 ≤ b, b2, L, R ≤ 2·10^9, and L ≤ R.
def func_1(a, b):
    if (a == 0) :
        return b, 0, 1
        #`b', 0, 1` where `b` is an integer within the range of -2·10^9 to 2·10^9
    #State of the program after the if block has been executed: a, b, a2, b2, L, R are integers where 0 < a, a2 ≤ 2·10^9, -2·10^9 ≤ b, b2, L, R ≤ 2·10^9, and L ≤ R, and a is not equal to 0
    gcd, x1, y1 = func_1(b % a, a)

x = y1 - b // a * x1

y = x1
    return gcd, x, y
    #The program returns gcd, x, and y, where gcd is the greatest common divisor of a and b, and x and y are the coefficients such that ax + by = gcd(a, b)
#Overall this is what the function does:The function `func_1` accepts two parameters `a` and `b`, both of which are integers with specific constraints: `0 < a, a2 ≤ 2·10^9` and `-2·10^9 ≤ b, b2 ≤ 2·10^9`. The function aims to compute the greatest common divisor (gcd) of `a` and `b`, and find the coefficients `x` and `y` such that `ax + by = gcd(a, b)`.

The function operates through recursion. If `a` is zero, it returns `b`, 0, 1 as per the base case. Otherwise, it recursively computes the gcd using the Euclidean algorithm, adjusting the coefficients `x` and `y` accordingly until the gcd is found. The function then returns the gcd and the coefficients `x` and `y`.

Potential edge cases and missing functionality:
- The function correctly handles the case where `a` is zero by returning `b`, 0, 1.
- However, the function does not explicitly handle the case where `b` is zero. In practice, if `b` is zero, the gcd would be `a` and the coefficients would be `1` and `0` respectively.
- The function assumes that the initial call to `func_1` does not have both `a` and `b` as zero, which is a valid assumption given the constraints.

After the function concludes, the program will return either `b', 0, 1` if `b` is within the specified range and `a` is zero, or `gcd, x, y` where `gcd` is the greatest common divisor of `a` and `b`, and `x` and `y` are the coefficients such that `ax + by = gcd(a, b)`.

#Function 2:
#State of the program right berfore the function call: a1, b1, a2, b2, L, and R are integers such that 0 < a1, a2 ≤ 2·10^9, -2·10^9 ≤ b1, b2, L, R ≤ 2·10^9, and L ≤ R.
def func_2(a1, b1, a2, b2, L, R):
    A = a1

B = -a2

C = b2 - b1

gcd, x0, y0 = func_1(abs(A), abs(B))
    if (C % gcd != 0) :
        return -1
        #The program returns -1
    #State of the program after the if block has been executed: a1 is a1, b1 is b1, a2 is a2, b2 is b2, L is L, R is R, A is a1, B is -a2, C is b2 - b1, gcd is result of func_1(abs(a1), abs(-a2)), x0 is result of func_1(abs(a1), abs(-a2)), y0 is result of func_1(abs(a1), abs(-a2)), C is divisible by gcd
    x0 *= C // gcd

y0 *= C // gcd
    if (A < 0) :
        x0 = -x0
    #State of the program after the if block has been executed: *`a1` is `a1`, `b1` is `b1`, `a2` is `a2`, `b2` is `b2`, `L` is `L`, `R` is `R`, `A` is `a1`, `B` is `-a2`, `C` is `b2 - b1`, `gcd` is the result of `func_1(abs(a1), abs(-a2))`. If `A` (which is `a1`) is less than 0, `x0` is updated to `-x0 * (C // gcd)`. Otherwise, `x0` remains as `x0 * (C // gcd)` and `y0` remains unchanged.
    if (B < 0) :
        y0 = -y0
    #State of the program after the if block has been executed: *`a1` is `a1`, `b1` is `b1`, `a2` is `a2`, `b2` is `b2`, `L` is `L`, `R` is `R`, `A` is `a1`, `B` is `-a2`, `C` is `b2 - b1`, `gcd` is the result of `func_1(abs(a1), abs(-a2))`, if `A` (which is `a1`) is less than 0 and `B` is currently less than 0, `x0` is updated to `-x0 * (C // gcd)` and `y0` is negated. Otherwise, `x0` remains as `x0 * (C // gcd)` and `y0` remains unchanged.
    a1_div_gcd = a1 // gcd

a2_div_gcd = a2 // gcd

x0, y0 = adjust_solution(x0, y0, a1_div_gcd, a2_div_gcd, 1, -1)

count = 0
    while True:
        val = a1 * x0 + b1
        
        if val > R:
            break
        
        if L <= val <= R:
            count += 1
        
        x0 += a2_div_gcd
        
        y0 -= a1_div_gcd
        
    #State of the program after the loop has been executed: Output State: x0 is (x1 - 3) + 9 * a2_div_gcd, y0 is y0 - 9 * a1_div_gcd, val is a1 * ((x0 - 3) + 9 * a2_div_gcd) + b1, R is unchanged, count is increased by 1 for each iteration where L <= val <= R, gcd is unchanged, a1 is unchanged, b1 is unchanged, a2 is unchanged, b2 is unchanged, L is unchanged, A is unchanged, B is unchanged, C is unchanged, x0 and y0 are updated as described above based on the number of iterations.
    #
    #Explanation:
    #1. **Analyze the Code and Initial State**: The loop continues indefinitely until `val` exceeds `R`. Each iteration updates `x0` by adding `a2_div_gcd` and `y0` by subtracting `a1_div_gcd`.
    #2. **Track Variable Changes**: 
    #   - `a1`, `b1`, `a2`, `b2`, `L`, `R`, `A`, `B`, `C`, `gcd`, `x0`, and `y0` change.
    #   - `val` changes with each iteration but its exact value depends on the current `x0` and `y0`.
    #3. **Summarize the Loop Behavior**: 
    #   - `x0` starts at `x0` and increases by `a2_div_gcd` each time the loop runs.
    #   - `y0` starts at `y0` and decreases by `a1_div_gcd` each time the loop runs.
    #   - `count` is incremented by 1 for each iteration where `L <= val <= R`.
    #   - The loop will continue to run until `val` becomes greater than `R`.
    #4. **Verify Relationships**: 
    #   - After `n` iterations, `x0` is `x0 - 3 + n * a2_div_gcd` and `y0` is `y0 - n * a1_div_gcd`.
    #   - The relationship between `x0` and `y0` and their initial values ensures the loop's behavior.
    #
    #Since the loop condition is `val > R` and we need to account for the maximum possible iterations, the final state will be after the loop exits, i.e., when `val > R`. Given the initial conditions and the increment/decrement of `x0` and `y0`, the final state can be expressed as shown above.
    return count
    #The program returns count which is incremented by 1 for each iteration where L <= val <= R, with val calculated as a1 * ((x0 - 3) + 9 * a2_div_gcd) + b1, and x0 and y0 updated as x0 = x0 - 3 + n * a2_div_gcd and y0 = y0 - n * a1_div_gcd after n iterations.
#Overall this is what the function does:- The function handles the case where `C` is not divisible by the GCD by returning -1, ensuring that the subsequent calculations do not proceed if the conditions are not met.
- The function ensures that `x0` and `y0` are correctly adjusted based on the signs of `A` and `B` to maintain the relationship between the variables.
- The loop continues until `val` exceeds `R`, ensuring that all possible valid values are considered within the given range.

#Function 3:
#State of the program right berfore the function call: x and y are integers, a1_div_gcd and a2_div_gcd are positive integers representing the division of a1 and a2 by their greatest common divisor (gcd), sign_a1 is either 1 or -1 indicating the sign of a1, and sign_a2 is either 1 or -1 indicating the sign of a2. Additionally, L and R are integers such that L ≤ R.
def adjust_solution(x, y, a1_div_gcd, a2_div_gcd, sign_a1, sign_a2):
    if (sign_a1 > 0) :
        k = (L - (b1 + a1 * x)) // (a1 * a1_div_gcd)

x += k * a2_div_gcd

y -= k * a1_div_gcd
    else :
        k = (R - (b1 + a1 * x)) // (a1 * a1_div_gcd)

x += k * a2_div_gcd

y -= k * a1_div_gcd
    #State of the program after the if-else block has been executed: *x and y are integers, a1_div_gcd and a2_div_gcd are positive integers, sign_a1 and sign_a2 are either 1 or -1, and L and R are integers such that L ≤ R. If sign_a1 > 0, x is updated by adding k * a2_div_gcd where k = (L - (b1 + a1 * x)) // (a1 * a1_div_gcd), and y is updated by subtracting k * a1_div_gcd. a1_div_gcd and a2_div_gcd remain unchanged, sign_a1 and sign_a2 remain unchanged, and L and R remain unchanged. Otherwise, x and y are updated to their new values, a1_div_gcd and a2_div_gcd remain unchanged, sign_a1 and sign_a2 remain unchanged, and L and R remain unchanged.
    if (b1 + a1 * x < L) :
        x += a2_div_gcd

y -= a1_div_gcd
    #State of the program after the if block has been executed: *x and y are integers. If \( b1 + a1 \times x < L \), then \( x \) is updated to its original value plus \( a2\_div\_gcd \) and \( y \) is updated to its original value minus \( a1\_div\_gcd \). Both \( a1\_div\_gcd \) and \( a2\_div\_gcd \) remain unchanged, as do \( sign\_a1 \), \( sign\_a2 \), \( L \), and \( R \). Otherwise, \( x \) and \( y \) retain their updated values from the if condition, and \( a1\_div\_gcd \), \( a2\_div\_gcd \), \( sign\_a1 \), \( sign\_a2 \), \( L \), and \( R \) remain unchanged.
    if (b1 + a1 * x > R) :
        x -= a2_div_gcd

y += a1_div_gcd
    #State of the program after the if block has been executed: *`x` and `y` are integers. If \( b1 + a1 \times x \leq R \), then \( x \) is updated to its original value plus \( a2\_div\_gcd \) and \( y \) is updated to its original value minus \( a1\_div\_gcd \). Both \( a1\_div\_gcd \), \( a2\_div\_gcd \), \( sign\_a1 \), \( sign\_a2 \), \( L \), and \( R \) remain unchanged. Otherwise, \( x \) is updated to its original value minus \( a2\_div\_gcd \) and \( y \) is updated to its original value plus \( a1\_div\_gcd \), and \( a1\_div\_gcd \), \( a2\_div\_gcd \), \( sign\_a1 \), \( sign\_a2 \), \( L \), and \( R \) remain unchanged.
    return x, y
    #`x` is updated to its original value plus \( a2\_div\_gcd \) if \( b1 + a1 \times x \leq R \), otherwise `x` is updated to its original value minus \( a2\_div\_gcd \). `y` is updated to its original value minus \( a1\_div\_gcd \) if \( b1 + a1 \times x \leq R \), otherwise `y` is updated to its original value plus \( a1\_div\_gcd \)
#Overall this is what the function does:The function `adjust_solution` accepts parameters `x`, `y`, `a1_div_gcd`, `a2_div_gcd`, `sign_a1`, and `sign_a2`. It updates the values of `x` and `y` based on the conditions involving `b1`, `a1`, `L`, and `R`. Specifically:

1. If `sign_a1 > 0`, it calculates `k` using `(L - (b1 + a1 * x)) // (a1 * a1_div_gcd)` and adjusts `x` and `y` accordingly.
2. If `b1 + a1 * x < L`, it further updates `x` to `x + a2_div_gcd` and `y` to `y - a1_div_gcd`.
3. If `b1 + a1 * x > R`, it adjusts `x` to `x - a2_div_gcd` and `y` to `y + a1_div_gcd`.

After these adjustments, the function returns the updated values of `x` and `y`.

Potential edge cases and missing functionality:
- The function assumes that `a1` and `a2` are not zero, which is not explicitly checked in the code.
- There is no handling for the case when `b1 + a1 * x == L` or `b1 + a1 * x == R`, which could lead to unexpected behavior depending on the specific requirements.
- The function does not modify `a1_div_gcd`, `a2_div_gcd`, `sign_a1`, `sign_a2`, `L`, and `R` as stated in the annotations, ensuring these parameters remain unchanged.




# Your response:
Reasoning:  
Correctness: **True** or **False**

