
Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
Карта звёздного неба представляет собой прямоугольное поле, состоящее из n строк по m символов в каждой строке. Каждый символ — это либо «.» (означает пустой участок неба), либо «*» (означает то, что в этом месте на небе есть звезда). 

Новое издание карты звёздного неба будет напечатано на квадратных листах, поэтому требуется найти минимально возможную сторону квадрата, в который могут поместиться все звезды. Границы искомого квадрата должны быть параллельны сторонам заданного прямоугольного поля.


-----Входные данные-----

В первой строке входных данных записаны два числа n и m (1 ≤ n, m ≤ 1000) — количество строк и столбцов на карте звездного неба.

В следующих n строках задано по m символов. Каждый символ — это либо «.» (пустой участок неба), либо «*» (звезда).

Гарантируется, что на небе есть хотя бы одна звезда.


-----Выходные данные-----

Выведите одно число — минимально возможную сторону квадрата, которым можно накрыть все звезды.


-----Примеры-----
Входные данные
4 4
....
..*.
...*
..**

Выходные данные
3

Входные данные
1 3
*.*

Выходные данные
3

Входные данные
2 1
.
*

Выходные данные
1



-----Примечание-----

Один из возможных ответов на первый тестовый пример:

 [Image] 

Один из возможных ответов на второй тестовый пример (обратите внимание, что покрывающий квадрат выходит за пределы карты звездного неба):

 [Image] 

Ответ на третий тестовый пример:

 [Image]

# Program:
def func():
    (n, m) = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        for (j, c) in enumerate(row):
            if c == '*':
                stars.append((j, _))
    min_x = min((x for (x, y) in stars))
    max_x = max((x for (x, y) in stars))
    min_y = min((y for (x, y) in stars))
    max_y = max((y for (x, y) in stars))
    side = max(max_x - min_x + 1, max_y - min_y + 1)
    print(side)





# Execution Summary:
The function processes a star map represented as a series of input lines, where each line consists of characters that are either '.' (empty space) or '*' (star). The map dimensions are given by the number of rows (n) and columns (m), with both values being in the range [1, 1000]. After processing, the function calculates and prints the side length of the smallest square that can contain all the stars present in the map. If there are no stars, the function still follows the same process but will print the side length of a square that would be able to contain the stars, which would be 1 in this case.


# Your response:
Reasoning:  
Correctness: **True** or **False**

