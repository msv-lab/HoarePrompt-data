
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
A frog is initially at position $0$ on the number line. The frog has two positive integers $a$ and $b$. From a position $k$, it can either jump to position $k+a$ or $k-b$.

Let $f(x)$ be the number of distinct integers the frog can reach if it never jumps on an integer outside the interval $[0, x]$. The frog doesn't need to visit all these integers in one trip, that is, an integer is counted if the frog can somehow reach it if it starts from $0$.

Given an integer $m$, find $\sum_{i=0}^{m} f(i)$. That is, find the sum of all $f(i)$ for $i$ from $0$ to $m$.


-----Input-----

The first line contains three integers $m, a, b$ ($1 \leq m \leq 10^9, 1 \leq a,b \leq 10^5$).


-----Output-----

Print a single integer, the desired sum.


-----Examples-----
Input
7 5 3

Output
19

Input
1000000000 1 2019

Output
500000001500000001

Input
100 100000 1

Output
101

Input
6 4 5

Output
10



-----Note-----

In the first example, we must find $f(0)+f(1)+\ldots+f(7)$. We have $f(0) = 1, f(1) = 1, f(2) = 1, f(3) = 1, f(4) = 1, f(5) = 3, f(6) = 3, f(7) = 8$. The sum of these values is $19$.

In the second example, we have $f(i) = i+1$, so we want to find $\sum_{i=0}^{10^9} i+1$.

In the third example, the frog can't make any jumps in any case.

# Annotated Program:
#State of the program right berfore the function call: m is an integer such that 1 <= m <= 10^9, a and b are positive integers such that 1 <= a, b <= 10^5.
def func():
    m, a, b = map(int, input().split())

dp = [0] * (m + 1)

dp[0] = 1
    for i in range(m + 1):
        if i + a <= m:
            dp[i + a] += dp[i]
        
        if i - b >= 0:
            dp[i] += dp[i - b]
        
    #State of the program after the  for loop has been executed: `i` is `m`, `m` is an integer such that 1 ≤ m ≤ 10^9, `a` is a positive integer such that 1 ≤ a ≤ 10^5, `b` is a positive integer such that 1 ≤ b ≤ 10^5, `dp` is a list of length `m+1` where all elements are 0 except `dp[0]` which is 1.
    print(sum(dp))
#Overall this is what the function does:The function reads three integers \(m\), \(a\), and \(b\) from input, where \(1 \leq m \leq 10^9\) and \(1 \leq a, b \leq 10^5\). It then constructs a dynamic programming array `dp` of length \(m+1\) initialized to zero, with `dp[0]` set to 1. For each index `i` from 0 to \(m\), it updates `dp[i+a]` and `dp[i-b]` if the indices are within bounds. After completing the loop, it prints the sum of all elements in the `dp` array. The function effectively computes a modified version of a knapsack problem where it counts the number of ways to reach each index in the array by adding `a` or subtracting `b` from previous indices. The final state of the program is that the sum of the `dp` array is printed, representing the total count of valid paths. Edge cases include the possibility of negative indices when subtracting `b`, which are handled by setting `dp[i]` to `dp[i-b]` only if `i - b` is non-negative.

# Your response:
Reasoning:  
Correctness: **True** or **False**

