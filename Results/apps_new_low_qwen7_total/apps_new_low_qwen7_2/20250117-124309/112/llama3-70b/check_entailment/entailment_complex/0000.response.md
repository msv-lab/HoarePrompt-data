Reasoning:

1. **Input Handling**: The program correctly reads two integers `n` and `k` from the standard input using `map(int, input().split())`.

2. **Divisor Calculation**: The program correctly calculates all divisors of `n` by iterating up to the square root of `n` and appending both `i` and `n // i` to the list of divisors when `i` is a divisor of `n`. This ensures that all divisors are found, including those from perfect squares.

3. **Sorting Divisors**: After calculating the divisors, the program sorts them in ascending order, which is necessary to find the k-th smallest divisor.

4. **Output Logic**: The program checks if `k` is greater than the number of divisors. If true, it prints `-1`, indicating that there are fewer than `k` divisors. Otherwise, it prints the `(k-1)`-th element of the sorted list of divisors, which corresponds to the `k`-th smallest divisor.

5. **Edge Cases**: The program handles the case where `n` is a perfect square correctly by including both the square root and its corresponding divisor only once.

6. **Range Constraints**: While the problem specifies that `1 ≤ n ≤ 10^15` and `1 ≤ k ≤ 10^9`, the code does not explicitly check these constraints. However, given the context and the nature of the problem, the code should theoretically work within these bounds.

Given the analysis, the provided program appears to correctly implement the logic required to solve the problem as described. Therefore, the program is correct.

Correctness: **True**