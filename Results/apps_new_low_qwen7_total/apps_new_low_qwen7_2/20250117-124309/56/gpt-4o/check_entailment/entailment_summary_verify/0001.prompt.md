
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:

Find k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. 

To be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \operatorname{max}_{1 \leq i \leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.

For definitions of powers and lexicographical order see notes.


-----Input-----

The first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.


-----Output-----

Output "No" (without quotes) in a single line if there does not exist such sequence. Otherwise, output "Yes" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.

It is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].


-----Examples-----
Input
23 5

Output
Yes
3 3 2 1 0 

Input
13 2

Output
No

Input
1 2

Output
Yes
-1 -1 



-----Note-----

Sample 1:

2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23

Answers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.

Answers like (4, 1, 1, 1, 0) do not have the minimum y value.

Sample 2:

It can be shown there does not exist a sequence with length 2.

Sample 3:

$2^{-1} + 2^{-1} = \frac{1}{2} + \frac{1}{2} = 1$

Powers of 2:

If x > 0, then 2^{x} = 2·2·2·...·2 (x times).

If x = 0, then 2^{x} = 1.

If x < 0, then $2^{x} = \frac{1}{2^{-x}}$.

Lexicographical order:

Given two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.

- Program:
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

def func_1(n, k):
    if k > n:
        return 'No'
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
    if len(bits) > k:
        return 'No'
    while len(bits) < k:
        smallest = bits.pop()
        bits.append(smallest - 1)
        bits.append(smallest - 1)
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))



- Function Summary: 
The function `func_1` accepts two parameters: `n` (a non-negative integer such that \(1 \leq n \leq 10^{18}\)) and `k` (a positive integer such that \(1 \leq k \leq 10^5\)). It checks if the number of set bits in the binary representation of `n` is less than or equal to `k`. If `k` is greater than `n`, it immediately returns 'No'. If the number of set bits is greater than `k`, it also returns 'No'. Otherwise, it modifies the list of set bits by appending duplicates of the smallest set bit until the list contains exactly `k` elements. Finally, it sorts the list in reverse order and returns 'Yes' followed by a space-separated string of these integers.

Beggining of Original Assessment: 
Reasoning:

1. The program reads input from standard input, which is correctly done using `sys.stdin.read`.
2. It then processes the input to extract `n` and `k`.
3. The function `func_1` is defined to check if it's possible to find `k` integers whose sum of powers of 2 equals `n`.
4. Inside `func_1`, it first checks if `k` is greater than `n`. If so, it immediately returns 'No'.
5. It then constructs the list `bits` which contains the exponents of 2 that add up to `n`. This is done by iterating over possible exponents from 60 down to 0 and checking if `n` is divisible by \(2^i\).
6. If the number of bits found exceeds `k`, it returns 'No', as we cannot form a sequence of length `k`.
7. If fewer than `k` bits are found, it tries to extend the sequence by adding smaller exponents, specifically by converting a higher exponent into two smaller ones.
8. Finally, it sorts the resulting sequence in reverse order to ensure it is lexicographically largest and returns the result.

The logic implemented in the program seems to correctly handle the constraints and requirements specified in the problem statement. Therefore, the program should work as intended.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

