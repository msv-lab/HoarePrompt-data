
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:

Find k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. 

To be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \operatorname{max}_{1 \leq i \leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.

For definitions of powers and lexicographical order see notes.


-----Input-----

The first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.


-----Output-----

Output "No" (without quotes) in a single line if there does not exist such sequence. Otherwise, output "Yes" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.

It is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].


-----Examples-----
Input
23 5

Output
Yes
3 3 2 1 0 

Input
13 2

Output
No

Input
1 2

Output
Yes
-1 -1 



-----Note-----

Sample 1:

2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23

Answers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.

Answers like (4, 1, 1, 1, 0) do not have the minimum y value.

Sample 2:

It can be shown there does not exist a sequence with length 2.

Sample 3:

$2^{-1} + 2^{-1} = \frac{1}{2} + \frac{1}{2} = 1$

Powers of 2:

If x > 0, then 2^{x} = 2·2·2·...·2 (x times).

If x = 0, then 2^{x} = 1.

If x < 0, then $2^{x} = \frac{1}{2^{-x}}$.

Lexicographical order:

Given two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.

- Program: 
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

def func_1(n, k):
    if k > n:
        return 'No'
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
    if len(bits) > k:
        return 'No'
    while len(bits) < k:
        smallest = bits.pop()
        bits.append(smallest - 1)
        bits.append(smallest - 1)
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))



- Annotated Code: 
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

#State of the program right berfore the function call: n is a non-negative integer such that 1 ≤ n ≤ 10^18, and k is a positive integer such that 1 ≤ k ≤ 10^5.
def func_1(n, k):
    if (k > n) :
        return 'No'
        #The program returns 'No'
    #State of the program after the if block has been executed: n is a non-negative integer such that 1 ≤ n ≤ 10^18, k is a positive integer such that 1 ≤ k ≤ 10^5, and k is less than or equal to n
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
        
    #State of the program after the  for loop has been executed: Output State: `i` is -1, `n` is a non-negative integer such that \(1 \leq n \leq 10^{18}\), `k` is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), `bits` is a list containing all indices `i` from 60 down to the highest set bit of `n`. The loop continues to decrement `i` from 60 to 0, appending each index where the corresponding bit of `n` is set (i.e., `n >> i & 1` evaluates to 1). Once `i` reaches -1, the loop terminates because the condition `i in range(60, -1, -1)` no longer holds true.
    #
    #Since the loop runs from 60 down to 0, it will continue to append indices to `bits` as long as the corresponding bits in `n` are set to 1. After the loop completes, `i` will be -1, indicating that all possible bits have been checked. The value of `n` remains unchanged unless the problem statement specifies otherwise, but since no operations are performed on `n` other than reading its bits, `n` remains the same. The variable `k` is not affected by the loop and remains within its initial bounds.
    if (len(bits) > k) :
        return 'No'
        #The program returns 'No'
    #State of the program after the if block has been executed: `i` is -1, `n` is a non-negative integer such that \(1 \leq n \leq 10^{18}\), `k` is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), `bits` is a list containing all indices `i` from 60 down to the highest set bit of `n`, and the length of `bits` is less than or equal to `k`
    while len(bits) < k:
        smallest = bits.pop()
        
        bits.append(smallest - 1)
        
        bits.append(smallest - 1)
        
    #State of the program after the loop has been executed: i is -1, n is a non-negative integer such that 1 ≤ n ≤ 10^18, k is a positive integer such that 1 ≤ k ≤ 10^5, and k ≤ n, bits is a list containing exactly k elements where the first len(bits) - 2 elements are unique indices of set bits in n, and the last two elements are the same and equal to the previous second-to-last element in bits.
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))
    #'Yes\n' followed by a space-separated string of integers contained in the list 'bits'
#Overall this is what the function does:The function `func_1` accepts two parameters: `n` (a non-negative integer such that \(1 \leq n \leq 10^{18}\)) and `k` (a positive integer such that \(1 \leq k \leq 10^5\)). It checks if the number of set bits in the binary representation of `n` is less than or equal to `k`. If `k` is greater than `n`, it immediately returns 'No'. If the number of set bits is greater than `k`, it also returns 'No'. Otherwise, it modifies the list of set bits by appending duplicates of the smallest set bit until the list contains exactly `k` elements. Finally, it sorts the list in reverse order and returns 'Yes' followed by a space-separated string of these integers.


Beggining of Original Assessment: 
Reasoning:

1. The program reads input from standard input, which is correctly done using `sys.stdin.read`.
2. It then processes the input to extract `n` and `k`.
3. The function `func_1` is defined to check if it's possible to find `k` integers whose sum of powers of 2 equals `n`.
4. Inside `func_1`, it first checks if `k` is greater than `n`. If so, it immediately returns 'No'.
5. It then constructs the list `bits` which contains the exponents of 2 that add up to `n`. This is done by iterating over possible exponents from 60 down to 0 and checking if `n` is divisible by \(2^i\).
6. If the number of bits found exceeds `k`, it returns 'No', as we cannot form a sequence of length `k`.
7. If fewer than `k` bits are found, it tries to extend the sequence by adding smaller exponents, specifically by converting a higher exponent into two smaller ones.
8. Finally, it sorts the resulting sequence in reverse order to ensure it is lexicographically largest and returns the result.

The logic implemented in the program seems to correctly handle the constraints and requirements specified in the problem statement. Therefore, the program should work as intended.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

