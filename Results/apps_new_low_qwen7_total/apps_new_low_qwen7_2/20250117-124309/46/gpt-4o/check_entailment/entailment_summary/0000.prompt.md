
Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
You are given positive integer number n. You should create such strictly increasing sequence of k positive numbers a_1, a_2, ..., a_{k}, that their sum is equal to n and greatest common divisor is maximal.

Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.

If there is no possible sequence then output -1.


-----Input-----

The first line consists of two numbers n and k (1 ≤ n, k ≤ 10^10).


-----Output-----

If the answer exists then output k numbers — resulting sequence. Otherwise output -1. If there are multiple answers, print any of them.


-----Examples-----
Input
6 3

Output
1 2 3

Input
8 2

Output
2 6

Input
5 3

Output
-1

# Program:
(n, k) = map(int, input().split())
result = func_1(n, k)
if result == -1:
    print(-1)
else:
    print(' '.join(map(str, result)))

def func_1(n, k):
    min_sum = k * (k + 1) // 2
    if min_sum > n:
        return -1
    d = n // min_sum
    remainder = n - d * min_sum
    sequence = [d * (i + 1) for i in range(k)]
    for i in range(k - 1, -1, -1):
        if remainder == 0:
            break
        sequence[i] += 1
        remainder -= 1
    return sequence





# Execution Summary:
The function `func_1` accepts two positive integers `n` and `k`, both within the range \(1 \leq n, k \leq 10^{10}\). It first calculates the minimum sum `min_sum` using the formula \(k \times (k + 1) // 2\). If `min_sum` is greater than `n`, the function returns -1. Otherwise, it calculates the quotient `d` of `n` divided by `min_sum` and the remainder `remainder` of `n` when divided by `min_sum`.

Next, it initializes a list `sequence` where each element is initially set to `d * (i + 1)` for `i` ranging from 0 to `k-1`. It then iteratively increments elements of `sequence` from the last to the first, reducing `remainder` by 1 until `remainder` becomes 0. After the loop, the function returns the list `sequence` where each element `sequence[i]` is calculated as `floor(n / (k * (k + 1) // 2)) * (i + 1) + i` and the remainder is guaranteed to be 0.

The function can return either -1 or a list `sequence` based on the specified conditions, ensuring that the returned list meets the required constraints.


# Your response:
Reasoning:  
Correctness: **True** or **False**

