
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given the set of vectors on the plane, each of them starting at the origin. Your task is to find a pair of vectors with the minimal non-oriented angle between them.

Non-oriented angle is non-negative value, minimal between clockwise and counterclockwise direction angles. Non-oriented angle is always between 0 and π. For example, opposite directions vectors have angle equals to π.


-----Input-----

First line of the input contains a single integer n (2 ≤ n ≤ 100 000) — the number of vectors.

The i-th of the following n lines contains two integers x_{i} and y_{i} (|x|, |y| ≤ 10 000, x^2 + y^2 > 0) — the coordinates of the i-th vector. Vectors are numbered from 1 to n in order of appearing in the input. It is guaranteed that no two vectors in the input share the same direction (but they still can have opposite directions).


-----Output-----

Print two integer numbers a and b (a ≠ b) — a pair of indices of vectors with the minimal non-oriented angle. You can print the numbers in any order. If there are many possible answers, print any.


-----Examples-----
Input
4
-1 0
0 -1
1 0
1 1

Output
3 4

Input
6
-1 0
0 -1
1 0
1 1
-4 -5
-4 -6

Output
6 5

- Program: 
import math

def func():
    n = int(input())
    v = []
    for _ in range(n):
        (x, y) = map(int, input().split())
        v.append((x, y))
    ans = (0, 1)
    ans_angle = math.pi
    v.sort(key=lambda v: math.atan2(v[1], v[0]))
    for i in range(n):
        for j in range(i + 1, min(n, i + 100)):
            angle = math.acos((v[i][0] * v[j][0] + v[i][1] * v[j][1]) / math.sqrt(v[i][0] ** 2 + v[i][1] ** 2) / math.sqrt(v[j][0] ** 2 + v[j][1] ** 2))
            if angle < ans_angle:
                ans_angle = angle
                ans = (i, j)
    print(ans[0] + 1, ans[1] + 1)



- Annotated Code: 
import math

#State of the program right berfore the function call: The input consists of two parts: first, an integer n representing the number of vectors (2 ≤ n ≤ 100 000), and second, n lines, each containing two integers x_i and y_i representing the coordinates of the i-th vector (|x_i|, |y_i| ≤ 10 000, x_i^2 + y_i^2 > 0). No two vectors share the same direction but can have opposite directions.
def func():
    n = int(input())

v = []
    for _ in range(n):
        x, y = map(int, input().split())
        
        v.append((x, y))
        
    #State of the program after the  for loop has been executed: n is an integer and greater than 0, v is a list of length 2n, x is the last input_x received, y is the last input_y received.
    ans = 0, 1

ans_angle = math.pi

v.sort(key=lambda v: math.atan2(v[1], v[0]))
    for i in range(n):
        for j in range(i + 1, min(n, i + 100)):
            angle = math.acos((v[i][0] * v[j][0] + v[i][1] * v[j][1]) / math.sqrt(v
                [i][0] ** 2 + v[i][1] ** 2) / math.sqrt(v[j][0] ** 2 + v[j][1] ** 2))
            if angle < ans_angle:
                ans_angle = angle
                ans = i, j
        
    #State of the program after the  for loop has been executed: `i` is `n-1`, `j` is the index of `v` that gives the smallest angle with `v[n-1]` when `i` is `n-1`, `ans` is `(n-1, j)`, and `ans_angle` is the minimum angle found between `v[n-1]` and any other vector `v[j]` in the list.
    print(ans[0] + 1, ans[1] + 1)
#Overall this is what the function does:The function reads an integer \( n \) and then \( n \) pairs of integers \((x_i, y_i)\) from the standard input, representing vectors. It sorts these vectors based on their polar angles and then finds the pair of vectors with the smallest angle between them. The function outputs the indices (1-based) of these two vectors. If the number of vectors \( n \) exceeds 100, the function only considers the first 100 vectors for finding the smallest angle.


Beggining of Original Assessment: 
### Reasoning:

1. **Input Handling and Vector Representation:**
   - The program correctly reads the number of vectors `n` and then processes each vector `(x, y)` by storing them in a list `v`. This part is correct.

2. **Sorting Vectors:**
   - The vectors are sorted using `math.atan2(v[1], v[0])`, which calculates the angle of each vector relative to the positive x-axis. This is a valid approach to ensure the vectors are ordered by their polar angles, making it easier to find the smallest angle.

3. **Finding Minimal Angle:**
   - The program iterates over pairs of vectors, but only up to `min(n, i + 100)`. This is an optimization to avoid unnecessary comparisons, which is valid since the number of vectors `n` is at most 100,000.
   - The angle between two vectors is calculated using the dot product formula: 
     \[
     \text{angle} = \math.acos\left(\frac{\mathbf{v}_i \cdot \mathbf{v}_j}{|\mathbf{v}_i| |\mathbf{v}_j|}\right)
     \]
     where \(\mathbf{v}_i \cdot \mathbf{v}_j\) is the dot product of the vectors, and \(|\mathbf{v}_i|\) and \(|\mathbf{v}_j|\) are their magnitudes. This calculation is correct.

4. **Updating Minimum Angle:**
   - The program updates the minimum angle and corresponding indices whenever it finds a smaller angle. This logic is also correct.

5. **Output Format:**
   - The program prints the indices of the vectors found with the minimal angle, adjusted by adding 1 to match 1-based indexing as required by the problem statement. This is correct.

### Conclusion:
The provided program appears to be correct and follows the specified problem requirements accurately. Therefore:

**Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

