
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.

Anton has a special kettle, that can prepare one potions in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.  Spells of this type speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs b_{i} manapoints and changes the preparation time of each potion to a_{i} instead of x.  Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs d_{i} manapoints and instantly create c_{i} potions. 

Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.

Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions.


-----Input-----

The first line of the input contains three integers n, m, k (1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5) — the number of potions, Anton has to make, the number of spells of the first type and the number of spells of the second type.

The second line of the input contains two integers x and s (2 ≤ x ≤ 2·10^9, 1 ≤ s ≤ 2·10^9) — the initial number of seconds required to prepare one potion and the number of manapoints Anton can use.

The third line contains m integers a_{i} (1 ≤ a_{i} < x) — the number of seconds it will take to prepare one potion if the i-th spell of the first type is used.

The fourth line contains m integers b_{i} (1 ≤ b_{i} ≤ 2·10^9) — the number of manapoints to use the i-th spell of the first type.

There are k integers c_{i} (1 ≤ c_{i} ≤ n) in the fifth line — the number of potions that will be immediately created if the i-th spell of the second type is used. It's guaranteed that c_{i} are not decreasing, i.e. c_{i} ≤ c_{j} if i < j.

The sixth line contains k integers d_{i} (1 ≤ d_{i} ≤ 2·10^9) — the number of manapoints required to use the i-th spell of the second type. It's guaranteed that d_{i} are not decreasing, i.e. d_{i} ≤ d_{j} if i < j.


-----Output-----

Print one integer — the minimum time one has to spent in order to prepare n potions.


-----Examples-----
Input
20 3 2
10 99
2 4 3
20 10 40
4 15
10 80

Output
20

Input
20 3 2
10 99
2 4 3
200 100 400
4 15
100 800

Output
200



-----Note-----

In the first sample, the optimum answer is to use the second spell of the first type that costs 10 manapoints. Thus, the preparation time of each potion changes to 4 seconds. Also, Anton should use the second spell of the second type to instantly prepare 15 potions spending 80 manapoints. The total number of manapoints used is 10 + 80 = 90, and the preparation time is 4·5 = 20 seconds (15 potions were prepared instantly, and the remaining 5 will take 4 seconds each).

In the second sample, Anton can't use any of the spells, so he just prepares 20 potions, spending 10 seconds on each of them and the answer is 20·10 = 200.

- Program: 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    x = int(data[3])
    s = int(data[4])
    a = list(map(int, data[5:5 + m]))
    b = list(map(int, data[5 + m:5 + 2 * m]))
    c = list(map(int, data[5 + 2 * m:5 + 2 * m + k]))
    d = list(map(int, data[5 + 2 * m + k:5 + 2 * m + 2 * k]))
    result = func_1(n, m, k, x, s, a, b, c, d)
    print(result)

def func_1(n, m, k, x, s, a, b, c, d):
    min_time = n * x
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time_with_spell = remaining_potions * x
            min_time = min(min_time, time_with_spell)
    for i in range(m):
        if b[i] <= s:
            time_with_spell = n * a[i]
            min_time = min(min_time, time_with_spell)
    for i in range(m):
        if b[i] <= s:
            remaining_manapoints = s - b[i]
            for j in range(k):
                if d[j] <= remaining_manapoints:
                    remaining_potions = max(0, n - c[j])
                    time_with_both_spells = remaining_potions * a[i]
                    min_time = min(min_time, time_with_both_spells)
                else:
                    break
    return min_time



- Annotated Code: 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    x = int(data[3])
    s = int(data[4])
    a = list(map(int, data[5:5 + m]))
    b = list(map(int, data[5 + m:5 + 2 * m]))
    c = list(map(int, data[5 + 2 * m:5 + 2 * m + k]))
    d = list(map(int, data[5 + 2 * m + k:5 + 2 * m + 2 * k]))
    result = func_1(n, m, k, x, s, a, b, c, d)
    print(result)

#State of the program right berfore the function call: n, m, k are non-negative integers such that 1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5; x, s are positive integers such that 2 ≤ x ≤ 2·10^9, 1 ≤ s ≤ 2·10^9; a is a list of m positive integers such that 1 ≤ a_i < x; b is a list of m positive integers such that 1 ≤ b_i ≤ 2·10^9; c is a list of k positive integers such that 1 ≤ c_i ≤ n and c_i are non-decreasing; d is a list of k positive integers such that 1 ≤ d_i ≤ 2·10^9 and d_i are non-decreasing.
def func_1(n, m, k, x, s, a, b, c, d):
    min_time = n * x
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time_with_spell = remaining_potions * x
            min_time = min(min_time, time_with_spell)
        
    #State of the program after the  for loop has been executed: `i` is `k-1`, `k` is the number of iterations the loop executed, `min_time` is the minimum value calculated by the formula `max(0, n - c[i]) * x` for each iteration where `d[i] <= s`. `n`, `x`, `m`, `s`, `a`, and `b` remain unchanged.
    for i in range(m):
        if b[i] <= s:
            time_with_spell = n * a[i]
            min_time = min(min_time, time_with_spell)
        
    #State of the program after the  for loop has been executed: `i` is between 0 and `m-1`, `k` is the number of times the loop executed, `min_time` is the minimum value calculated by the formula `max(0, n - c[i]) * x` for each iteration where `d[i] <= s`, `n`, `x`, `m`, `s`, `a`, and `b` remain unchanged.
    for i in range(m):
        if b[i] <= s:
            remaining_manapoints = s - b[i]
            for j in range(k):
                if d[j] <= remaining_manapoints:
                    remaining_potions = max(0, n - c[j])
                    time_with_both_spells = remaining_potions * a[i]
                    min_time = min(min_time, time_with_both_spells)
                else:
                    break
        
    #State of the program after the  for loop has been executed: `i` is `m`, `k` is the total number of iterations the loop completed, `min_time` is the minimum value between its initial value and `(max(0, n - c[j]) * a[i])` for all valid pairs `(i, j)` where `d[j] <= remaining_manapoints`, `remaining_manapoints` is `s - b[m-1]`, and `n`, `x`, `m`, `s`, `a`, `d`, and `b` are unchanged.
    return min_time
    #The program returns min_time which is the minimum value between its initial value and (max(0, n - c[j]) * a[i]) for all valid pairs (i, j) where d[j] <= remaining_manapoints, and remaining_manapoints is s - b[m-1]
#Overall this is what the function does:The function `func_1` accepts parameters `n`, `m`, `k`, `x`, `s`, `a`, `b`, `c`, and `d`, and returns `min_time` which is the minimum value between its initial value (`n * x`) and \(\max(0, n - c[j]) \cdot a[i]\) for all valid pairs `(i, j)` where \(d[j] \leq \text{remaining\_manapoints}\), with `remaining_manapoints` being `s - b[m-1]`.

The function performs the following actions:
1. Initializes `min_time` to `n * x`.
2. Iterates over the list `d` and updates `min_time` if `d[i] <= s`, considering the remaining potions `n - c[i]` and their effect on the time required.
3. Iterates over the list `b` and updates `min_time` if `b[i] <= s`, considering the effect of using spell `a[i]` directly on the time required.
4. Iterates over the list `b` again and calculates `remaining_manapoints` as `s - b[m-1]`. It then iterates over the list `d` and updates `min_time` for valid pairs `(i, j)` where `d[j] <= remaining_manapoints`, considering the effect of using both spells `a[i]` and `c[j]` on the time required.

The final state of the program after the function concludes is that it returns `min_time`, which is the minimum time required to achieve the desired outcome given the constraints and conditions specified in the lists and parameters.


Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The program does not handle the case where using both types of spells simultaneously can reduce the preparation time further. Specifically, the program only considers the scenarios where either a spell of the first type or a spell of the second type is used individually, but it does not check the scenario where both types of spells are used together. This can lead to suboptimal results.

For example, consider the following input:

```
20 3 2
10 99
2 4 3
20 10 40
4 15
10 80
```

- Using the second spell of the first type (costing 10 manapoints, reducing preparation time to 4 seconds) and the second spell of the second type (costing 80 manapoints, creating 15 potions) would allow Anton to prepare 5 potions instantly and the remaining 5 potions in 4 seconds each, resulting in a total time of \(4 \times 5 = 20\) seconds.
- However, the current implementation does not consider this combined effect, leading to a potentially incorrect result.

To fix this, the program should include a nested loop to check the combination of both types of spells and update `min_time` accordingly.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

