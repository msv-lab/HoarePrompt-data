
 Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Vivek initially has an empty array $a$ and some integer constant $m$.

He performs the following algorithm:  Select a random integer $x$ uniformly in range from $1$ to $m$ and append it to the end of $a$.  Compute the greatest common divisor of integers in $a$.  In case it equals to $1$, break  Otherwise, return to step $1$. 

Find the expected length of $a$. It can be shown that it can be represented as $\frac{P}{Q}$ where $P$ and $Q$ are coprime integers and $Q\neq 0 \pmod{10^9+7}$. Print the value of $P \cdot Q^{-1} \pmod{10^9+7}$.


-----Input-----

The first and only line contains a single integer $m$ ($1 \leq m \leq 100000$).


-----Output-----

Print a single integer — the expected length of the array $a$ written as $P \cdot Q^{-1} \pmod{10^9+7}$.


-----Examples-----
Input
1

Output
1

Input
2

Output
2

Input
4

Output
333333338



-----Note-----

In the first example, since Vivek can choose only integers from $1$ to $1$, he will have $a=[1]$ after the first append operation, and after that quit the algorithm. Hence the length of $a$ is always $1$, so its expected value is $1$ as well.

In the second example, Vivek each time will append either $1$ or $2$, so after finishing the algorithm he will end up having some number of $2$'s (possibly zero), and a single $1$ in the end. The expected length of the list is $1\cdot \frac{1}{2} + 2\cdot \frac{1}{2^2} + 3\cdot \frac{1}{2^3} + \ldots = 2$.

# Functions with Execution Summary:
MOD = 10 ** 9 + 7
m = int(input().strip())
print(func_2(m))

Function number 1 :
 Code:
 '''
def func_1(a, p):
    return pow(a, p - 2, p)
''' 

 Output hints for function1:  The function `func_1` accepts two parameters `a` and `p`, where `a` is a positive integer representing the modulus \(10^9 + 7\), and `p` is a positive integer such that \(1 < p\) and \(p\) is coprime with \(a\). It returns the modular multiplicative inverse of `a` modulo `p`, which is calculated as \(a^{p-2} \mod p\). The function leverages Python’s built-in `pow` function to compute this value efficiently. Potential edge cases include scenarios where `p` is not coprime with `a` (which would raise a `ValueError` due to the nature of the `pow` function when the third argument is specified and the base and modulus are not coprime), or when `p` is less than or equal to 1, in which case the function should not proceed as `p` must be greater than 1. If `a` is 0, the result would be undefined in modular arithmetic, but the function will still attempt to compute it, potentially leading to incorrect results.
Function number 2 :
 Code:
 '''
def func_2(m):
    if m == 1:
        return 1
    length_sum = 0
    for i in range(1, m + 1):
        length_sum += func_1(i, MOD)
        length_sum %= MOD
    result = m * length_sum % MOD
    return result
''' 

 Output hints for function2:  The function `func_2` accepts an integer `m` where \(1 \leq m \leq 100000\) and a constant `MOD` representing \(10^9 + 7\). If `m` equals 1, the function immediately returns 1. Otherwise, it calculates the sum of the results of calling `func_1(i, MOD)` for all integers `i` from 1 to `m`, taking the modulo `MOD` at each addition. It then multiplies this sum by `m` and takes the modulo `MOD` again before returning the result.


# Your response:
Reasoning:  
Correctness: **True** or **False**

