
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.

Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.

Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.


-----Input-----

The only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.


-----Output-----

Print the maximum number of games in which the winner of the tournament can take part.


-----Examples-----
Input
2

Output
1

Input
3

Output
2

Input
4

Output
2

Input
10

Output
4



-----Note-----

In all samples we consider that player number 1 is the winner.

In the first sample, there would be only one game so the answer is 1.

In the second sample, player 1 can consequently beat players 2 and 3. 

In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.

- Program: 
def func():
    n = int(input())
    max_games = n.bit_length() - 1
    print(max_games)



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^18, representing the number of players in the tournament.
def func():
    n = int(input())

max_games = n.bit_length() - 1

print(max_games)
#Overall this is what the function does:The function calculates the maximum number of games that can be played in a single-elimination tournament given the number of players \(n\), where \(2 \leq n \leq 10^{18}\). The function reads the value of \(n\) from the user, computes the maximum number of games using the bit length of \(n\) minus one, and prints the result. The function does not accept any parameters and does not return any value. The final state of the program after the function concludes is that it has printed the calculated maximum number of games.


Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The provided program does not correctly handle the constraints and requirements of the problem. Specifically, the program calculates `max_games` as `n.bit_length() - 1`, which is a simplification of the problem without considering the pairing rule described in the problem statement.

For example, consider the case when `n = 6`:
- According to the rule, the first round can have pairs (1, 2), (3, 4), and (5, 6).
- After the first round, the winners are (1, 3, 5), and the next possible pair is (1, 3) since the number of games played by each player differs by at most one.
- Therefore, the winner can participate in up to 3 games (the first round, the second round, and the final round).

However, the program would output `2` for `n = 6` because `6.bit_length() - 1 = 3 - 1 = 2`.

This example shows that the program does not correctly implement the pairing rule and thus does not always provide the correct result.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

