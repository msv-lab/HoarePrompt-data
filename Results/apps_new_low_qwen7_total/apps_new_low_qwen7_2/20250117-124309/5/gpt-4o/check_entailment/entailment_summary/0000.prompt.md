
 Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Jamie loves sleeping. One day, he decides that he needs to wake up at exactly hh: mm. However, he hates waking up, so he wants to make waking up less painful by setting the alarm at a lucky time. He will then press the snooze button every x minutes until hh: mm is reached, and only then he will wake up. He wants to know what is the smallest number of times he needs to press the snooze button.

A time is considered lucky if it contains a digit '7'. For example, 13: 07 and 17: 27 are lucky, while 00: 48 and 21: 34 are not lucky.

Note that it is not necessary that the time set for the alarm and the wake-up time are on the same day. It is guaranteed that there is a lucky time Jamie can set so that he can wake at hh: mm.

Formally, find the smallest possible non-negative integer y such that the time representation of the time x·y minutes before hh: mm contains the digit '7'.

Jamie uses 24-hours clock, so after 23: 59 comes 00: 00.


-----Input-----

The first line contains a single integer x (1 ≤ x ≤ 60).

The second line contains two two-digit integers, hh and mm (00 ≤ hh ≤ 23, 00 ≤ mm ≤ 59).


-----Output-----

Print the minimum number of times he needs to press the button.


-----Examples-----
Input
3
11 23

Output
2

Input
5
01 07

Output
0



-----Note-----

In the first sample, Jamie needs to wake up at 11:23. So, he can set his alarm at 11:17. He would press the snooze button when the alarm rings at 11:17 and at 11:20.

In the second sample, Jamie can set his alarm at exactly at 01:07 which is lucky.

# Functions with Execution Summary:
if __name__ == '__main__':
    func_2()

Function number 1 :
 Code:
 '''
def func_1(h, m):
    """Check if the time h:m contains a '7'."""
    return '7' in str(h) or '7' in str(m)
''' 

 Output hints for function1:  The function `func_1` accepts two integers `h` and `m`, which represent hours (00 to 23) and minutes (00 to 59) respectively. It checks whether either `h` or `m` contains the digit 7. If either `h` or `m` contains the digit 7, the function returns `True`; otherwise, it returns `False`. There are no edge cases or missing functionality in the provided code since it correctly implements the described behavior.
Function number 2 :
 Code:
 '''
def func_2():
    x = int(input())
    (hh, mm) = map(int, input().split())
    snooze_count = 0
    while not func_1(hh, mm):
        snooze_count += 1
        mm -= x
        if mm < 0:
            mm += 60
            hh -= 1
            if hh < 0:
                hh += 24
    print(snooze_count)
''' 

 Output hints for function2:  The function `func_2()` accepts two integer parameters `hh` and `mm`, representing hours and minutes respectively. It repeatedly decreases the minute value by `x` (an integer between 1 and 60) until the time `hh:mm` contains the digit '7'. For each iteration where the minute value decreases, the `snooze_count` is incremented. If the minute value becomes negative during the process, it wraps around to the next hour. Once the condition `func_1(hh, mm)` is met (i.e., the time contains the digit '7'), the function prints the total number of times the time was adjusted (`snooze_count`). The final state of the program includes updated values for `hh`, `mm`, and `snooze_count`. Potential edge cases include when `hh` or `mm` wrap around to the previous or next 24-hour cycle, respectively. The function does not return any value; instead, it outputs the `snooze_count` through the print statement.


# Your response:
Reasoning:  
Correctness: **True** or **False**

