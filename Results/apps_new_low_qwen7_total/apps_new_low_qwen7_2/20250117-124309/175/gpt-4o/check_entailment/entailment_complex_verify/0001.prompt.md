
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Implication is a function of two logical arguments, its value is false if and only if the value of the first argument is true and the value of the second argument is false. 

Implication is written by using character '$\rightarrow$', and the arguments and the result of the implication are written as '0' (false) and '1' (true). According to the definition of the implication: 

$0 \rightarrow 0 = 1$ 

$0 \rightarrow 1 = 1$

$1 \rightarrow 0 = 0$ 

$1 \rightarrow 1 = 1$

When a logical expression contains multiple implications, then when there are no brackets, it will be calculated from left to fight. For example,

$0 \rightarrow 0 \rightarrow 0 =(0 \rightarrow 0) \rightarrow 0 = 1 \rightarrow 0 = 0$. 

When there are brackets, we first calculate the expression in brackets. For example,

$0 \rightarrow(0 \rightarrow 0) = 0 \rightarrow 1 = 1$.

For the given logical expression $a_{1} \rightarrow a_{2} \rightarrow a_{3} \rightarrow \cdots \cdots a_{n}$ determine if it is possible to place there brackets so that the value of a logical expression is false. If it is possible, your task is to find such an arrangement of brackets.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 100 000) — the number of arguments in a logical expression.

The second line contains n numbers a_1, a_2, ..., a_{n} ($a_{i} \in \{0,1 \}$), which means the values of arguments in the expression in the order they occur.


-----Output-----

Print "NO" (without the quotes), if it is impossible to place brackets in the expression so that its value was equal to 0.

Otherwise, print "YES" in the first line and the logical expression with the required arrangement of brackets in the second line.

The expression should only contain characters '0', '1', '-' (character with ASCII code 45), '>' (character with ASCII code 62), '(' and ')'. Characters '-' and '>' can occur in an expression only paired like that: ("->") and represent implication. The total number of logical arguments (i.e. digits '0' and '1') in the expression must be equal to n. The order in which the digits follow in the expression from left to right must coincide with a_1, a_2, ..., a_{n}.

The expression should be correct. More formally, a correct expression is determined as follows:  Expressions "0", "1" (without the quotes) are correct.  If v_1, v_2 are correct, then v_1->v_2 is a correct expression.  If v is a correct expression, then (v) is a correct expression. 

The total number of characters in the resulting expression mustn't exceed 10^6.

If there are multiple possible answers, you are allowed to print any of them.


-----Examples-----
Input
4
0 1 1 0

Output
YES
(((0)->1)->(1->0))

Input
2
1 1

Output
NO

Input
1
0

Output
YES
0

- Program: 
def func():
    n = int(input())
    a = list(map(int, input().split()))
    if 0 in a and a[:a.index(0)].count(1) > 0:
        print('YES')
        result = []
        first_one_index = a.index(1)
        first_zero_index = a[first_one_index:].index(0) + first_one_index
        for i in range(first_one_index):
            result.append(str(a[i]) + '->')
        result.append('(')
        for i in range(first_one_index, first_zero_index):
            result.append(str(a[i]) + '->')
        result.append(str(a[first_zero_index]))
        result.append(')')
        for i in range(first_zero_index + 1, n):
            result.append('->' + str(a[i]))
        print(''.join(result))
    else:
        print('NO')



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100 000, and a is a list of n integers where each integer is either 0 or 1.
def func():
    n = int(input())

a = list(map(int, input().split()))
    if (0 in a and a[:a.index(0)].count(1) > 0) :
        print('YES')

result = []

first_one_index = a.index(1)

first_zero_index = a[first_one_index:].index(0) + first_one_index
        for i in range(first_one_index):
            result.append(str(a[i]) + '->')
            
        #State of the program after the  for loop has been executed: i = first_one_index, result = [str(a[0]) + '->', str(a[1]) + '->', ..., str(a[first_one_index-1]) + '->']
        result.append('(')
        for i in range(first_one_index, first_zero_index):
            result.append(str(a[i]) + '->')
            
        #State of the program after the  for loop has been executed: Output State: `i` is `first_zero_index`, `first_one_index` remains the same, `first_zero_index` remains the same, `result` is a list containing the strings `str(a[first_one_index]) + '->'`, `str(a[first_one_index + 1]) + '->'`, ..., `str(a[first_zero_index - 1]) + '->'`, and `str('(')`.
        #
        #Explanation:
        #1. **Analyze the Code and Initial State**: The loop iterates from `first_one_index` to `first_zero_index - 1`. Each iteration appends `str(a[i]) + '->'` to `result`.
        #2. **Track Variable Changes**: 
        #   - `i` starts at `first_one_index` and increments by 1 in each iteration until it reaches `first_zero_index - 1`.
        #   - `first_one_index` and `first_zero_index` remain constant as they are not updated within the loop.
        #   - `result` starts with the string `str(a[first_one_index]) + '->'` and continues to append new strings as the loop runs.
        #3. **Summarize the Loop Behavior**: The loop will execute `first_zero_index - first_one_index - 1` times. After all iterations, `i` will be equal to `first_zero_index`, and `result` will contain all the required strings.
        #4. **Verify Relationships**: The final state of `result` correctly reflects the appending of strings starting from `str(a[first_one_index]) + '->'` up to `str(a[first_zero_index - 1]) + '->'`, followed by `str('(')`. The variables `first_one_index` and `first_zero_index` remain unchanged, ensuring the relationships are consistent.
        result.append(str(a[first_zero_index]))

result.append(')')
        for i in range(first_zero_index + 1, n):
            result.append('->' + str(a[i]))
            
        #State of the program after the  for loop has been executed: i is `n`, `first_one_index` remains the same, `first_zero_index` remains the same, `result` is a list containing the strings `str(a[first_one_index]) + '->'`, `str(a[first_one_index + 1]) + '->'`, ..., `str(a[first_zero_index - 1]) + '->'`, `str('(') + str(a[first_zero_index]) + ')'`, and for each `i` in the range `first_zero_index + 1` to `n-1`, `'->' + str(a[i])`.
        print(''.join(result))
    else :
        print('NO')
    #State of the program after the if-else block has been executed: `n` is an integer, `a` is a list of `n` integers where each integer is either 0 or 1. If `0` is in the list `a` and there is at least one `1` before the first `0`, then `first_one_index` remains the same, `first_zero_index` remains the same, and `result` is a list containing specific strings as described in the if part. Otherwise, the conditions are as described in the else part: 0 is not in the list `a`, or the first occurrence of 0 in `a` does not have any 1s before it.
#Overall this is what the function does:The function processes a list `a` of `n` integers (where each integer is either 0 or 1 and 1 ≤ n ≤ 100,000). It checks if there is at least one 1 before the first 0 in the list. If such a condition is met, it constructs a string with specific formatting and prints 'YES'. Otherwise, it prints 'NO'. Specifically, the function performs the following steps:
1. Reads an integer `n` and a list `a` of `n` integers.
2. Checks if there is at least one 1 before the first 0 in the list.
3. If the condition is met, it constructs a string `result` with the format: `str(a[first_one_index]) + '->'`, `str(a[first_one_index + 1]) + '->'`, ..., `str(a[first_zero_index - 1]) + '->'`, `str('(') + str(a[first_zero_index]) + ')`, and `->str(a[i])` for each `i` in the range `first_zero_index + 1` to `n-1`.
4. Prints the constructed string.
5. If the condition is not met, it simply prints 'NO'.

Potential edge cases include:
- The list `a` consists entirely of 1s.
- The list `a` consists entirely of 0s.
- The list `a` contains no 1s.
- The list `a` contains only one element which is 0.
- The list `a` starts with 0 and does not contain any 1s after it.


Beggining of Original Assessment: 
### Reasoning:

1. **Problem Analysis**: 
   - We need to check if it's possible to add parentheses to the given sequence of implications (`0` and `1`) so that the final result is `0`.
   - A key point is that an implication chain will evaluate to `0` only if the first `1` is immediately followed by a `0` without any intervening `1`s before the `0`.

2. **Key Cases**:
   - If there is no `0` in the sequence, or if the first `0` does not have all preceding elements as `1`, then it is impossible to make the expression evaluate to `0`.
   - Otherwise, the solution involves creating groups of implications where each group ends with a `1` followed by a `0`.

3. **Algorithm Breakdown**:
   - First, identify the index of the first `0` in the list.
   - Check if there are any `1`s before this `0`. If there are, it’s impossible to form the desired expression.
   - Construct the expression by ensuring that every segment between `1`s and `0`s is enclosed in parentheses, and the entire expression maintains the correct syntax.

4. **Code Review**:
   - The provided code correctly identifies the first `0` and checks if there are any preceding `1`s.
   - It constructs the required expression by adding parentheses around segments from the first `1` to the first `0` and continues similarly for subsequent segments.
   - The code ensures that the constructed expression is syntactically correct.

### Correctness:
Given the above analysis and the structure of the provided code, the program appears to be correctly addressing the problem statement. It checks for invalid cases and constructs a valid expression if possible.

Therefore, the provided code meets the requirements specified in the problem description.

### Final Answer:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

