
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Implication is a function of two logical arguments, its value is false if and only if the value of the first argument is true and the value of the second argument is false. 

Implication is written by using character '$\rightarrow$', and the arguments and the result of the implication are written as '0' (false) and '1' (true). According to the definition of the implication: 

$0 \rightarrow 0 = 1$ 

$0 \rightarrow 1 = 1$

$1 \rightarrow 0 = 0$ 

$1 \rightarrow 1 = 1$

When a logical expression contains multiple implications, then when there are no brackets, it will be calculated from left to fight. For example,

$0 \rightarrow 0 \rightarrow 0 =(0 \rightarrow 0) \rightarrow 0 = 1 \rightarrow 0 = 0$. 

When there are brackets, we first calculate the expression in brackets. For example,

$0 \rightarrow(0 \rightarrow 0) = 0 \rightarrow 1 = 1$.

For the given logical expression $a_{1} \rightarrow a_{2} \rightarrow a_{3} \rightarrow \cdots \cdots a_{n}$ determine if it is possible to place there brackets so that the value of a logical expression is false. If it is possible, your task is to find such an arrangement of brackets.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 100 000) — the number of arguments in a logical expression.

The second line contains n numbers a_1, a_2, ..., a_{n} ($a_{i} \in \{0,1 \}$), which means the values of arguments in the expression in the order they occur.


-----Output-----

Print "NO" (without the quotes), if it is impossible to place brackets in the expression so that its value was equal to 0.

Otherwise, print "YES" in the first line and the logical expression with the required arrangement of brackets in the second line.

The expression should only contain characters '0', '1', '-' (character with ASCII code 45), '>' (character with ASCII code 62), '(' and ')'. Characters '-' and '>' can occur in an expression only paired like that: ("->") and represent implication. The total number of logical arguments (i.e. digits '0' and '1') in the expression must be equal to n. The order in which the digits follow in the expression from left to right must coincide with a_1, a_2, ..., a_{n}.

The expression should be correct. More formally, a correct expression is determined as follows:  Expressions "0", "1" (without the quotes) are correct.  If v_1, v_2 are correct, then v_1->v_2 is a correct expression.  If v is a correct expression, then (v) is a correct expression. 

The total number of characters in the resulting expression mustn't exceed 10^6.

If there are multiple possible answers, you are allowed to print any of them.


-----Examples-----
Input
4
0 1 1 0

Output
YES
(((0)->1)->(1->0))

Input
2
1 1

Output
NO

Input
1
0

Output
YES
0

- Program: 
def func():
    n = int(input())
    a = list(map(int, input().split()))
    if 0 in a and a[:a.index(0)].count(1) > 0:
        print('YES')
        result = []
        first_one_index = a.index(1)
        first_zero_index = a[first_one_index:].index(0) + first_one_index
        for i in range(first_one_index):
            result.append(str(a[i]) + '->')
        result.append('(')
        for i in range(first_one_index, first_zero_index):
            result.append(str(a[i]) + '->')
        result.append(str(a[first_zero_index]))
        result.append(')')
        for i in range(first_zero_index + 1, n):
            result.append('->' + str(a[i]))
        print(''.join(result))
    else:
        print('NO')



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100 000, and a is a list of n integers where each integer is either 0 or 1.
def func():
    n = int(input())

a = list(map(int, input().split()))
    if (0 in a and a[:a.index(0)].count(1) > 0) :
        print('YES')

result = []

first_one_index = a.index(1)

first_zero_index = a[first_one_index:].index(0) + first_one_index
        for i in range(first_one_index):
            result.append(str(a[i]) + '->')
            
        #State of the program after the  for loop has been executed: i = first_one_index, result = [str(a[0]) + '->', str(a[1]) + '->', ..., str(a[first_one_index-1]) + '->']
        result.append('(')
        for i in range(first_one_index, first_zero_index):
            result.append(str(a[i]) + '->')
            
        #State of the program after the  for loop has been executed: Output State: `i` is `first_zero_index`, `first_one_index` remains the same, `first_zero_index` remains the same, `result` is a list containing the strings `str(a[first_one_index]) + '->'`, `str(a[first_one_index + 1]) + '->'`, ..., `str(a[first_zero_index - 1]) + '->'`, and `str('(')`.
        #
        #Explanation:
        #1. **Analyze the Code and Initial State**: The loop iterates from `first_one_index` to `first_zero_index - 1`. Each iteration appends `str(a[i]) + '->'` to `result`.
        #2. **Track Variable Changes**: 
        #   - `i` starts at `first_one_index` and increments by 1 in each iteration until it reaches `first_zero_index - 1`.
        #   - `first_one_index` and `first_zero_index` remain constant as they are not updated within the loop.
        #   - `result` starts with the string `str(a[first_one_index]) + '->'` and continues to append new strings as the loop runs.
        #3. **Summarize the Loop Behavior**: The loop will execute `first_zero_index - first_one_index - 1` times. After all iterations, `i` will be equal to `first_zero_index`, and `result` will contain all the required strings.
        #4. **Verify Relationships**: The final state of `result` correctly reflects the appending of strings starting from `str(a[first_one_index]) + '->'` up to `str(a[first_zero_index - 1]) + '->'`, followed by `str('(')`. The variables `first_one_index` and `first_zero_index` remain unchanged, ensuring the relationships are consistent.
        result.append(str(a[first_zero_index]))

result.append(')')
        for i in range(first_zero_index + 1, n):
            result.append('->' + str(a[i]))
            
        #State of the program after the  for loop has been executed: i is `n`, `first_one_index` remains the same, `first_zero_index` remains the same, `result` is a list containing the strings `str(a[first_one_index]) + '->'`, `str(a[first_one_index + 1]) + '->'`, ..., `str(a[first_zero_index - 1]) + '->'`, `str('(') + str(a[first_zero_index]) + ')'`, and for each `i` in the range `first_zero_index + 1` to `n-1`, `'->' + str(a[i])`.
        print(''.join(result))
    else :
        print('NO')
    #State of the program after the if-else block has been executed: `n` is an integer, `a` is a list of `n` integers where each integer is either 0 or 1. If `0` is in the list `a` and there is at least one `1` before the first `0`, then `first_one_index` remains the same, `first_zero_index` remains the same, and `result` is a list containing specific strings as described in the if part. Otherwise, the conditions are as described in the else part: 0 is not in the list `a`, or the first occurrence of 0 in `a` does not have any 1s before it.
#Overall this is what the function does:The function processes a list `a` of `n` integers (where each integer is either 0 or 1 and 1 ≤ n ≤ 100,000). It checks if there is at least one 1 before the first 0 in the list. If such a condition is met, it constructs a string with specific formatting and prints 'YES'. Otherwise, it prints 'NO'. Specifically, the function performs the following steps:
1. Reads an integer `n` and a list `a` of `n` integers.
2. Checks if there is at least one 1 before the first 0 in the list.
3. If the condition is met, it constructs a string `result` with the format: `str(a[first_one_index]) + '->'`, `str(a[first_one_index + 1]) + '->'`, ..., `str(a[first_zero_index - 1]) + '->'`, `str('(') + str(a[first_zero_index]) + ')`, and `->str(a[i])` for each `i` in the range `first_zero_index + 1` to `n-1`.
4. Prints the constructed string.
5. If the condition is not met, it simply prints 'NO'.

Potential edge cases include:
- The list `a` consists entirely of 1s.
- The list `a` consists entirely of 0s.
- The list `a` contains no 1s.
- The list `a` contains only one element which is 0.
- The list `a` starts with 0 and does not contain any 1s after it.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly handle all potential cases according to the problem description. Specifically, the program does not generate valid bracketed expressions for all inputs where the value of the logical expression can be made false.

Consider the following test case:
```
Input
4
1 0 1 0
```

The expected output should be:
```
YES
(1->(0->1))->0
```

However, the current implementation fails to produce this or similar valid outputs for certain sequences. For instance, the program tries to find the first occurrence of `0` and then attempts to construct the expression around it, but it does not handle more complex cases where the placement of brackets needs to be adjusted to make the expression evaluate to `0`.

To illustrate, for the input `1 0 1 0`, the program would incorrectly try to place brackets without ensuring the correct logical structure is formed. This leads to an incomplete or incorrect solution.

Therefore, the program is not correct for all potential cases.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

