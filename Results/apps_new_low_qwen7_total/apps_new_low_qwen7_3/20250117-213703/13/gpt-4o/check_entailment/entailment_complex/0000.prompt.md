
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Vova has won $n$ trophies in different competitions. Each trophy is either golden or silver. The trophies are arranged in a row.

The beauty of the arrangement is the length of the longest subsegment consisting of golden trophies. Vova wants to swap two trophies (not necessarily adjacent ones) to make the arrangement as beautiful as possible — that means, to maximize the length of the longest such subsegment.

Help Vova! Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 10^5$) — the number of trophies.

The second line contains $n$ characters, each of them is either G or S. If the $i$-th character is G, then the $i$-th trophy is a golden one, otherwise it's a silver trophy. 


-----Output-----

Print the maximum possible length of a subsegment of golden trophies, if Vova is allowed to do at most one swap.


-----Examples-----
Input
10
GGGSGGGSGG

Output
7

Input
4
GGGG

Output
4

Input
3
SSS

Output
0



-----Note-----

In the first example Vova has to swap trophies with indices $4$ and $10$. Thus he will obtain the sequence "GGGGGGGSGS", the length of the longest subsegment of golden trophies is $7$. 

In the second example Vova can make no swaps at all. The length of the longest subsegment of golden trophies in the sequence is $4$. 

In the third example Vova cannot do anything to make the length of the longest subsegment of golden trophies in the sequence greater than $0$.

# Annotated Program:
import sys

input = sys.stdin.read
data = input().split()
n = int(data[0])
trophies = data[1]
print(func_1(n, trophies))

#State of the program right berfore the function call: n is an integer such that 2 <= n <= 10^5, and trophies is a string of length n consisting of the characters 'G' and 'S', where 'G' represents a golden trophy and 'S' represents a silver trophy.
def func_1(n, trophies):
    segments = []

i = 0
    while i < n:
        if trophies[i] == 'G':
            start = i
            while i < n and trophies[i] == 'G':
                i += 1
            segments.append((start, i - 1))
        else:
            i += 1
        
    #State of the program after the loop has been executed: Output State: `segments` is a list of tuples, each representing a segment of consecutive 'G' characters in the `trophies` string. Each tuple in `segments` has the form `(start, end)` where `start` is the index of the first 'G' in the segment and `end` is the index of the last 'G' in the segment, inclusive. The value of `i` is `n`, indicating that the loop has processed the entire string. The value of `n` remains an integer such that \(2 \leq n \leq 10^5\). The value of `trophies` remains unchanged as a string of length `n` consisting of 'G' and 'S' characters.
    #
    #The loop continues to execute until `i` reaches `n`. During each iteration, if `trophies[i]` is 'G', the loop identifies a segment of consecutive 'G' characters and appends the corresponding segment to `segments`. If `trophies[i]` is 'S', the loop simply increments `i` without modifying `segments`.
    #
    #Final Values:
    #- `segments`: A list of tuples representing segments of consecutive 'G' characters.
    #- `i`: `n`.
    #- `n`: An integer such that \(2 \leq n \leq 10^5\).
    #- `trophies`: A string of length `n` consisting of 'G' and 'S' characters.
    #
    #Conditions:
    #- The loop executes as long as `i` is less than `n`.
    #- The loop does not execute if `n` is 0, but this case is excluded by the problem statement since \(2 \leq n \leq 10^5\).
    if (not segments) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: `segments` is a list of tuples representing segments of consecutive 'G' characters, each tuple in `segments` has the form `(start, end)` where `start` is the index of the first 'G' in the segment and `end` is the index of the last 'G' in the segment, inclusive. `i` is `n`, indicating that the loop has processed the entire string. `n` remains an integer such that \(2 \leq n \leq 10^5\). `trophies` remains unchanged as a string of length `n` consisting of 'G' and 'S' characters. `segments` is not an empty list.
    max_length = max(end - start + 1 for start, end in segments)
    if (len(segments) == 1) :
        return max_length
        #The program returns max_length which is the maximum length of segments found, and the length of 'segments' is exactly 1
    #State of the program after the if block has been executed: Postcondition: `segments` is a list of tuples representing segments of consecutive 'G' characters, each tuple in `segments` has the form `(start, end)` where `start` is the index of the first 'G' in the segment and `end` is the index of the last 'G' in the segment, inclusive; `i` is `n`, indicating that the loop has processed the entire string; `n` remains an integer such that \(2 \leq n \leq 10^5\); `trophies` remains unchanged as a string of length `n` consisting of 'G' and 'S' characters; `max_length` is the maximum length of segments found; `len(segments)` is greater than 1.
    for i in range(1, len(segments)):
        prev_start, prev_end = segments[i - 1]
        
        curr_start, curr_end = segments[i]
        
        if curr_start - prev_end == 2:
            max_length = max(max_length, curr_end - curr_start + 1 + (prev_end -
                prev_start + 1) + 1)
        
    #State of the program after the  for loop has been executed: `segments` is a list of tuples representing segments of consecutive 'G' characters, `i` is `len(segments)`, `trophies` remains unchanged as a string of length `n` consisting of 'G' and 'S' characters, `max_length` is the maximum value among all segment lengths plus possible gaps of 2, `len(segments)` is unchanged, and `prev_start` and `prev_end` refer to the last segment's start and end indices. If any pair of segments had a gap of 2, `max_length` would be the maximum of its original value and the calculated new length. Otherwise, `max_length` remains unchanged.
    return min(max_length + 1, n)
    #`The program returns the minimum value between max_length + 1 and n`
#Overall this is what the function does:The function `func_1` accepts two parameters: `n` (an integer such that \(2 \leq n \leq 10^5\)) and `trophies` (a string of length `n` consisting of the characters 'G' and 'S', where 'G' represents a golden trophy and 'S' represents a silver trophy). The function processes the `trophies` string to identify segments of consecutive 'G' characters and calculates the maximum length of these segments. It then considers potential gaps of 2 between segments and updates the maximum length accordingly. Finally, the function returns the minimum value between the updated maximum length plus one and the total length `n`.

Potential edge cases and actions performed:
- If there are no segments of 'G' characters (`segments` is empty), the function returns 0.
- If there is exactly one segment of 'G' characters, the function returns the length of this segment.
- For multiple segments, the function calculates the maximum length considering potential gaps of 2 between segments and returns the minimum value between this maximum length plus one and the total length `n`.

The function effectively finds the longest sequence of golden trophies, considering possible gaps of 2 between sequences, and ensures the result is within the bounds of the total length of the `trophies` string.

# Your response:
Reasoning:  
Correctness: **True** or **False**

