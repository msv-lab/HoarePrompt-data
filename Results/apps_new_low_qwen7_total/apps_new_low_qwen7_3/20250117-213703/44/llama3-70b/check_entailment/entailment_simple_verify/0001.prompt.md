
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given the set of vectors on the plane, each of them starting at the origin. Your task is to find a pair of vectors with the minimal non-oriented angle between them.

Non-oriented angle is non-negative value, minimal between clockwise and counterclockwise direction angles. Non-oriented angle is always between 0 and π. For example, opposite directions vectors have angle equals to π.


-----Input-----

First line of the input contains a single integer n (2 ≤ n ≤ 100 000) — the number of vectors.

The i-th of the following n lines contains two integers x_{i} and y_{i} (|x|, |y| ≤ 10 000, x^2 + y^2 > 0) — the coordinates of the i-th vector. Vectors are numbered from 1 to n in order of appearing in the input. It is guaranteed that no two vectors in the input share the same direction (but they still can have opposite directions).


-----Output-----

Print two integer numbers a and b (a ≠ b) — a pair of indices of vectors with the minimal non-oriented angle. You can print the numbers in any order. If there are many possible answers, print any.


-----Examples-----
Input
4
-1 0
0 -1
1 0
1 1

Output
3 4

Input
6
-1 0
0 -1
1 0
1 1
-4 -5
-4 -6

Output
6 5

- Program: 
import math

def func():
    n = int(input())
    v = []
    for _ in range(n):
        (x, y) = map(int, input().split())
        v.append((x, y))
    ans = (0, 1)
    ans_angle = math.pi
    v.sort(key=lambda v: math.atan2(v[1], v[0]))
    for i in range(n):
        for j in range(i + 1, min(n, i + 100)):
            angle = math.acos((v[i][0] * v[j][0] + v[i][1] * v[j][1]) / math.sqrt(v[i][0] ** 2 + v[i][1] ** 2) / math.sqrt(v[j][0] ** 2 + v[j][1] ** 2))
            if angle < ans_angle:
                ans_angle = angle
                ans = (i, j)
    print(ans[0] + 1, ans[1] + 1)



- Annotated Code: 
import math

#State of the program right berfore the function call: The input is a list of vectors represented as (x, y) coordinates, where each vector starts at the origin. The length of the list is an integer n such that 2 ≤ n ≤ 100 000, and each vector is represented by a tuple (x_i, y_i) where |x_i|, |y_i| ≤ 10 000 and x_i^2 + y_i^2 > 0. No two vectors have the same direction, but they may have opposite directions.
def func():
    n = int(input())

v = []
    for _ in range(n):
        x, y = map(int, input().split())
        
        v.append((x, y))
        
    #State of the program after the  for loop has been executed: Output State: n is greater than 0, x is an integer, y is an integer, v is a list containing n tuples (x, y). The loop executes exactly n times, appending a new tuple (x, y) to the list v in each iteration.
    ans = 0, 1

ans_angle = math.pi

v.sort(key=lambda v: math.atan2(v[1], v[0]))
    for i in range(n):
        for j in range(i + 1, min(n, i + 100)):
            angle = math.acos((v[i][0] * v[j][0] + v[i][1] * v[j][1]) / math.sqrt(v
                [i][0] ** 2 + v[i][1] ** 2) / math.sqrt(v[j][0] ** 2 + v[j][1] ** 2))
            if angle < ans_angle:
                ans_angle = angle
                ans = i, j
        
    #State of the program after the  for loop has been executed: n is greater than 0, i is n-1, j is the index such that (i, j) gives the minimum angle, ans_angle is the minimum angle found, and ans is the tuple (i, j) with the smallest angle.
    print(ans[0] + 1, ans[1] + 1)



Beggining of Original Assessment: 
### Reasoning:

Let's break down the logic of the provided program step-by-step to ensure it meets the requirements of finding the pair of vectors with the minimal non-oriented angle.

1. **Input Handling**: The program correctly reads the number of vectors `n` and their respective coordinates.
2. **Sorting Vectors**: The vectors are sorted using `math.atan2`, which ensures the vectors are ordered by their angles relative to the positive x-axis. This is necessary to handle the circular nature of angles.
3. **Angle Calculation**: The program calculates the angle between each pair of consecutive vectors in the sorted list (with a maximum of 100 pairs due to the loop condition `for j in range(i + 1, min(n, i + 100))`). This approach is efficient because it leverages the sorted order to minimize the number of calculations needed.
4. **Finding Minimum Angle**: The smallest angle is tracked using the variable `ans_angle`. Whenever a smaller angle is found, the corresponding indices are updated.
5. **Output**: Finally, the indices of the vectors with the minimal angle are printed, adjusted by adding 1 to match 1-based indexing.

### Key Points:
- **Sorting by Angle**: Sorting by `math.atan2` is correct as it ensures the angles are in the right order.
- **Efficient Pair Calculation**: Limiting the number of pairs to be checked to `min(n, i + 100)` is a reasonable optimization, especially given the large constraints on `n`.
- **Correct Angle Calculation**: The angle calculation using `math.acos` is correct but could be simplified using the dot product formula directly, which avoids potential precision issues with `acos`.

Given the logic and implementation details, the program appears to correctly implement the solution to find the pair of vectors with the minimal non-oriented angle.

### Conclusion:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

