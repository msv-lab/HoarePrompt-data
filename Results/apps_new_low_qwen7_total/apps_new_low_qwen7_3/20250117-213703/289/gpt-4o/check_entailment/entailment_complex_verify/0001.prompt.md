
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.

Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.

Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.


-----Input-----

The only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.


-----Output-----

Print the maximum number of games in which the winner of the tournament can take part.


-----Examples-----
Input
2

Output
1

Input
3

Output
2

Input
4

Output
2

Input
10

Output
4



-----Note-----

In all samples we consider that player number 1 is the winner.

In the first sample, there would be only one game so the answer is 1.

In the second sample, player 1 can consequently beat players 2 and 3. 

In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.

- Program: 
def func():
    n = int(input())
    max_games = n.bit_length() - 1
    print(max_games)



- Annotated Code: 
#State of the program right berfore the function call: n is a positive integer such that 2 <= n <= 10^18.
def func():
    n = int(input())

max_games = n.bit_length() - 1

print(max_games)
#Overall this is what the function does:The function takes no explicit input parameters and reads an integer `n` from the user where \(2 \leq n \leq 10^{18}\). It then calculates the maximum number of games that can be played based on the bit length of `n`, subtracting 1 from it. Finally, it prints the result. There are no return values; the output is printed directly to the console. This function does not handle invalid inputs or edge cases beyond the specified range.


Beggining of Original Assessment: 
Reasoning:
1. The problem involves determining the maximum number of games a tournament winner can play under specific constraints.
2. The key constraint is that two players can only play if the difference in the number of games they have played is at most 1.
3. To maximize the number of games the winner can play, we need to consider how the tournament can be structured while adhering to the given constraint.
4. The provided solution uses `n.bit_length() - 1` to calculate the maximum number of games. This is derived from the fact that in a balanced binary tree (which models the tournament structure), the height (or depth) of the tree determines the maximum number of games a player can play.
5. For `n` players, the maximum depth of the tournament tree (and thus the maximum number of games the winner can play) is given by the highest power of 2 less than or equal to `n`, which can be found using `bit_length()`.

Let's verify the correctness:

- For `n = 2`: The tournament has 1 game, so the winner plays 1 game.
- For `n = 3`: The winner can play up to 2 games. Possible sequence: (1 vs 2), (1 vs 3).
- For `n = 4`: The winner can play up to 2 games. Possible sequence: (1 vs 2, 3 vs 4), (1 vs the winner of 3 vs 4).
- For `n = 10`: The winner can play up to 4 games. Possible sequence: (split into pairs to maintain the balance until the final).

Given these examples, the function correctly calculates the maximum number of games using `n.bit_length() - 1`.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

