
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.

Anton has a special kettle, that can prepare one potions in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.  Spells of this type speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs b_{i} manapoints and changes the preparation time of each potion to a_{i} instead of x.  Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs d_{i} manapoints and instantly create c_{i} potions. 

Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.

Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions.


-----Input-----

The first line of the input contains three integers n, m, k (1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5) — the number of potions, Anton has to make, the number of spells of the first type and the number of spells of the second type.

The second line of the input contains two integers x and s (2 ≤ x ≤ 2·10^9, 1 ≤ s ≤ 2·10^9) — the initial number of seconds required to prepare one potion and the number of manapoints Anton can use.

The third line contains m integers a_{i} (1 ≤ a_{i} < x) — the number of seconds it will take to prepare one potion if the i-th spell of the first type is used.

The fourth line contains m integers b_{i} (1 ≤ b_{i} ≤ 2·10^9) — the number of manapoints to use the i-th spell of the first type.

There are k integers c_{i} (1 ≤ c_{i} ≤ n) in the fifth line — the number of potions that will be immediately created if the i-th spell of the second type is used. It's guaranteed that c_{i} are not decreasing, i.e. c_{i} ≤ c_{j} if i < j.

The sixth line contains k integers d_{i} (1 ≤ d_{i} ≤ 2·10^9) — the number of manapoints required to use the i-th spell of the second type. It's guaranteed that d_{i} are not decreasing, i.e. d_{i} ≤ d_{j} if i < j.


-----Output-----

Print one integer — the minimum time one has to spent in order to prepare n potions.


-----Examples-----
Input
20 3 2
10 99
2 4 3
20 10 40
4 15
10 80

Output
20

Input
20 3 2
10 99
2 4 3
200 100 400
4 15
100 800

Output
200



-----Note-----

In the first sample, the optimum answer is to use the second spell of the first type that costs 10 manapoints. Thus, the preparation time of each potion changes to 4 seconds. Also, Anton should use the second spell of the second type to instantly prepare 15 potions spending 80 manapoints. The total number of manapoints used is 10 + 80 = 90, and the preparation time is 4·5 = 20 seconds (15 potions were prepared instantly, and the remaining 5 will take 4 seconds each).

In the second sample, Anton can't use any of the spells, so he just prepares 20 potions, spending 10 seconds on each of them and the answer is 20·10 = 200.

- Program: 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    x = int(data[3])
    s = int(data[4])
    a = list(map(int, data[5:5 + m]))
    b = list(map(int, data[5 + m:5 + 2 * m]))
    c = list(map(int, data[5 + 2 * m:5 + 2 * m + k]))
    d = list(map(int, data[5 + 2 * m + k:5 + 2 * m + 2 * k]))
    result = func_1(n, m, k, x, s, a, b, c, d)
    print(result)

def func_1(n, m, k, x, s, a, b, c, d):
    min_time = n * x
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time_with_spell = remaining_potions * x
            min_time = min(min_time, time_with_spell)
    for i in range(m):
        if b[i] <= s:
            time_with_spell = n * a[i]
            min_time = min(min_time, time_with_spell)
    for i in range(m):
        if b[i] <= s:
            remaining_manapoints = s - b[i]
            for j in range(k):
                if d[j] <= remaining_manapoints:
                    remaining_potions = max(0, n - c[j])
                    time_with_both_spells = remaining_potions * a[i]
                    min_time = min(min_time, time_with_both_spells)
                else:
                    break
    return min_time



- Annotated Code: 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    x = int(data[3])
    s = int(data[4])
    a = list(map(int, data[5:5 + m]))
    b = list(map(int, data[5 + m:5 + 2 * m]))
    c = list(map(int, data[5 + 2 * m:5 + 2 * m + k]))
    d = list(map(int, data[5 + 2 * m + k:5 + 2 * m + 2 * k]))
    result = func_1(n, m, k, x, s, a, b, c, d)
    print(result)

#State of the program right berfore the function call: n, m, k are non-negative integers such that 1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5. x, s are positive integers such that 2 ≤ x ≤ 2·10^9 and 1 ≤ s ≤ 2·10^9. a is a list of m positive integers such that 1 ≤ a_i < x. b is a list of m positive integers such that 1 ≤ b_i ≤ 2·10^9. c is a list of k positive integers such that 1 ≤ c_i ≤ n and c_i are non-decreasing. d is a list of k positive integers such that 1 ≤ d_i ≤ 2·10^9 and d_i are non-decreasing.
def func_1(n, m, k, x, s, a, b, c, d):
    min_time = n * x
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time_with_spell = remaining_potions * x
            min_time = min(min_time, time_with_spell)
        
    #State of the program after the  for loop has been executed: To determine the final output state after the loop has executed all its iterations, we need to analyze the behavior of the loop and how it updates the variable `min_time`.
    #
    #### Step-by-Step Analysis
    #
    #1. **Initial State**:
    #   - `min_time` is `n * x`.
    #   - `n` is a non-negative integer such that 1 ≤ n ≤ 2·10^9.
    #   - `x` is a positive integer such that 2 ≤ x ≤ 2·10^9.
    #   - `m` is a non-negative integer such that 1 ≤ m ≤ 2·10^5.
    #   - `k` is a non-negative integer such that 1 ≤ k ≤ 2·10^5.
    #   - `s` is a positive integer such that 1 ≤ s ≤ 2·10^9.
    #   - `a` is a list of m positive integers such that 1 ≤ a_i < x.
    #   - `b` is a list of m positive integers such that 1 ≤ b_i ≤ 2·10^9.
    #   - `c` is a list of k positive integers such that 1 ≤ c_i ≤ n and c_i are non-decreasing.
    #   - `d` is a list of k positive integers such that 1 ≤ d_i ≤ 2·10^9 and d_i are non-decreasing.
    #
    #2. **Loop Behavior**:
    #   - The loop runs from `i = 0` to `i = k-1`.
    #   - Inside the loop, there is a condition `if d[i] <= s:`.
    #     - If the condition is true, `remaining_potions = max(0, n - c[i])` is calculated.
    #     - Then, `time_with_spell = remaining_potions * x` is computed.
    #     - Finally, `min_time = min(min_time, time_with_spell)` updates `min_time` to the minimum value between its current value and `time_with_spell`.
    #
    #3. **Final Values**:
    #   - After all iterations, `min_time` will be the minimum value among `min_time` and `time_with_spell` for all `i` where `d[i] <= s`.
    #   - All other variables (`n`, `x`, `m`, `k`, `s`, `a`, `b`, `c`, `d`) remain unchanged as they are not updated inside the loop.
    #
    #4. **Conditions**:
    #   - The loop executes `k` times if `k > 0`.
    #   - If `k = 0`, the loop does not execute at all, and `min_time` remains as `n * x`.
    #
    #### Output State After the Loop Finishes
    #
    #- **Variables**:
    #  - `n`, `x`, `m`, `k`, `s`, `a`, `b`, `c`, `d` remain constant.
    #  - `min_time` is updated to the minimum value among `min_time` and `time_with_spell` for all `i` where `d[i] <= s`.
    #
    #- **Final Output State**:
    #  - **min_time**: The minimum value between the initial `n * x` and `time_with_spell` for all `i` where `d[i] <= s`.
    #
    #**Output State: min_time is the minimum value among `n * x` and `max(0, n - c[i]) * x` for all `i` where `d[i] <= s`.**
    for i in range(m):
        if b[i] <= s:
            time_with_spell = n * a[i]
            min_time = min(min_time, time_with_spell)
        
    #State of the program after the  for loop has been executed: Let's carefully analyze the given Python loop and its behavior to determine the final output state after all iterations.
    #
    #### Initial State
    #- `min_time` is initially set to `n * x`.
    #- `n` is a non-negative integer such that \(1 \leq n \leq 2 \times 10^9\).
    #- `x` is a positive integer such that \(2 \leq x \leq 2 \times 10^9\).
    #- `m` is a non-negative integer such that \(1 \leq m \leq 2 \times 10^5\).
    #- `s` is a positive integer such that \(1 \leq s \leq 2 \times 10^9\).
    #- `a` is a list of `m` positive integers such that \(1 \leq a_i < x\).
    #- `b` is a list of `m` positive integers such that \(1 \leq b_i \leq 2 \times 10^9\).
    #- `c` is a list of `k` positive integers such that \(1 \leq c_i \leq n\) and `c` is non-decreasing.
    #- `d` is a list of `k` positive integers such that \(1 \leq d_i \leq 2 \times 10^9\) and `d` is non-decreasing.
    #
    #### Loop Behavior
    #The loop runs from `i = 0` to `i = k-1` and updates `min_time` based on the condition `if d[i] <= s:`:
    #- If `d[i] <= s`, it calculates `remaining_potions = max(0, n - c[i])` and `time_with_spell = remaining_potions * x`.
    #- It then updates `min_time` to `min(min_time, time_with_spell)`.
    #
    #### Final Values
    #- **Variables that remain constant**: `n`, `x`, `m`, `s`, `a`, `b`, `c`, `d`.
    #- **Updated Variable**: `min_time`.
    #
    #### Final Output State
    #- **Final `min_time`**: After all iterations of the loop, `min_time` will be the minimum value between its initial value (`n * x`) and the calculated `time_with_spell` for each `i` where `d[i] <= s`.
    #
    #### Summary
    #- The loop iterates over the list `d` and updates `min_time` if the condition `d[i] <= s` is satisfied.
    #- The final value of `min_time` will be the minimum of the initial value `n * x` and the calculated `time_with_spell` for all `i` where `d[i] <= s`.
    #
    #### Output State
    #**Output State: min_time is the minimum value among `n * x` and `max(0, n - c[i]) * x` for all `i` where `d[i] <= s`.**
    #
    #This ensures that `min_time` reflects the smallest possible value that can be achieved under the given conditions.
    for i in range(m):
        if b[i] <= s:
            remaining_manapoints = s - b[i]
            for j in range(k):
                if d[j] <= remaining_manapoints:
                    remaining_potions = max(0, n - c[j])
                    time_with_both_spells = remaining_potions * a[i]
                    min_time = min(min_time, time_with_both_spells)
                else:
                    break
        
    #State of the program after the  for loop has been executed: `min_time` is the minimum value among `n * x` and `max(0, n - c[j]) * a[i]` for all `i` and `j` where `b[i] <= s` and `d[j] <= s - b[i]`.
    return min_time
    #The program returns min_time which is the minimum value among n * x and max(0, n - c[j]) * a[i] for all i and j where b[i] <= s and d[j] <= s - b[i]
#Overall this is what the function does:The function `func_1` accepts parameters `n`, `m`, `k`, `x`, `s`, `a`, `b`, `c`, and `d`. It returns the minimum value among `n * x` and `max(0, n - c[j]) * a[i]` for all `i` and `j` where `b[i] <= s` and `d[j] <= s - b[i]`.

The function performs the following steps:
1. Initializes `min_time` to `n * x`.
2. Iterates over the list `d` and updates `min_time` if `d[i] <= s`, calculating `time_with_spell = max(0, n - c[i]) * x`.
3. Iterates over the list `b` and updates `min_time` if `b[i] <= s`, calculating `time_with_spell = n * a[i]`.
4. Iterates over the list `d` again, considering the remaining manapoints `s - b[i]` and updates `min_time` if `d[j] <= s - b[i]`, calculating `time_with_both_spells = max(0, n - c[j]) * a[i]`.

Potential edge cases and missing functionality:
- If `k = 0`, the second loop will not execute, and `min_time` will remain as `n * x`.
- If `m = 0`, the third loop will not execute, and `min_time` will remain as the value updated in the first two loops.
- If no values of `d[i]` satisfy `d[i] <= s` or `d[j] <= s - b[i]`, `min_time` will still be the initial value `n * x`.

The final state of the program after the function concludes is that the variable `min_time` holds the minimum value among `n * x` and `max(0, n - c[j]) * a[i]` for all `i` and `j` where `b[i] <= s` and `d[j] <= s - b[i]`.


Beggining of Original Assessment: 
Reasoning:

The given program reads the input data correctly and calculates the minimum time required to prepare `n` potions using the available spells. Let's break down the program step-by-step to verify its correctness:

1. **Input Reading and Parsing:**
   - The program reads the entire input using `sys.stdin.read` and splits it into parts.
   - It correctly parses the values of `n`, `m`, `k`, `x`, and `s`.
   - It then extracts the lists `a`, `b`, `c`, and `d` from the input.

2. **Function Definition (`func_1`):**
   - The function initializes `min_time` to `n * x`, which represents the baseline time to prepare all potions without using any spells.
   - It iterates over the spells of the second type (`c` and `d`):
     - For each spell, if the manapoints required (`d[i]`) are within the limit (`s`), it calculates the remaining potions to be prepared (`max(0, n - c[i])`) and the time to prepare those potions (`remaining_potions * x`).
     - It updates `min_time` with the minimum value between the current `min_time` and the calculated time.
   - It iterates over the spells of the first type (`a` and `b`):
     - For each spell, if the manapoints required (`b[i]`) are within the limit (`s`), it calculates the time to prepare all `n` potions using the spell (`n * a[i]`).
     - It updates `min_time` with the minimum value between the current `min_time` and the calculated time.
   - It further iterates over the spells of the first type and the second type in combination:
     - For each spell of the first type, if the manapoints required (`b[i]`) are within the limit (`s`), it calculates the remaining manapoints after using the first spell (`remaining_manapoints = s - b[i]`).
     - It then checks each spell of the second type:
       - If the manapoints required for the second spell (`d[j]`) are within the remaining manapoints, it calculates the time to prepare the remaining potions (`remaining_potions * a[i]`).
       - It updates `min_time` with the minimum value between the current `min_time` and the calculated time.
       - If the manapoints required for the second spell exceed the remaining manapoints, it breaks out of the inner loop as no further combinations will be beneficial.

The logic appears to be sound, ensuring that the minimum time is calculated by considering all possible combinations of spells while adhering to the manapoint constraint.

Given the logical flow and the correct handling of constraints, the program should work as expected.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

