
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for a rubles, a pack of two copybooks for b rubles, and a pack of three copybooks for c rubles. Alyona already has n copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks k that n + k is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.


-----Input-----

The only line contains 4 integers n, a, b, c (1 ≤ n, a, b, c ≤ 10^9).


-----Output-----

Print the minimum amount of rubles she should pay to buy such number of copybooks k that n + k is divisible by 4.


-----Examples-----
Input
1 1 3 4

Output
3

Input
6 2 1 1

Output
1

Input
4 4 4 4

Output
0

Input
999999999 1000000000 1000000000 1000000000

Output
1000000000



-----Note-----

In the first example Alyona can buy 3 packs of 1 copybook for 3a = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for b = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.

- Program: 
def func():
    (n, a, b, c) = map(int, input().split())
    k = 4 - n % 4
    if k == 4:
        k = 0
    ans = float('inf')
    for i in range(k // 3 + 1):
        j = (k - 3 * i) // 2
        if 3 * i + 2 * j <= k:
            ans = min(ans, 3 * i * c + j * b + (k - 3 * i - 2 * j) * a)
    print(ans)



- Annotated Code: 
#State of the program right berfore the function call: n, a, b, c are non-negative integers such that 1 ≤ n, a, b, c ≤ 10^9.
def func():
    n, a, b, c = map(int, input().split())

k = 4 - n % 4
    if (k == 4) :
        k = 0
    #State of the program after the if block has been executed: *`n` is a non-negative integer such that 1 ≤ n ≤ 10^9, `a` is a non-negative integer such that 1 ≤ a ≤ 10^9, `b` is a non-negative integer such that 1 ≤ b ≤ 10^9, `c` is a non-negative integer such that 1 ≤ c ≤ 10^9, `k` equals 4 - n % 4. If `k` equals 4, then `k` is set to 0. Otherwise, `k` remains unchanged.
    ans = float('inf')
    for i in range(k // 3 + 1):
        j = (k - 3 * i) // 2
        
        if 3 * i + 2 * j <= k:
            ans = min(ans, 3 * i * c + j * b + (k - 3 * i - 2 * j) * a)
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer such that \(1 \leq n \leq 10^9\), `a` is a non-negative integer such that \(1 \leq a \leq 10^9\), `b` is a non-negative integer such that \(1 \leq b \leq 10^9\), `c` is a non-negative integer such that \(1 \leq c \leq 10^9\), `k = 4 - n \% 4` (with `k` being 0 if `n \% 4` equals 4), `ans` is the minimum value among all expressions `3 * i * c + j * b + (k - 3 * i - 2 * j) * a` where `i` and `j` are integers satisfying `3 * i + 2 * j <= k`, `i` starts from 0 and increases by 1 each iteration until it reaches the maximum possible value such that `3 * i + 2 * j <= k` holds.
    print(ans)



Beggining of Original Assessment: 
Correctness: **True**

Explanation: The provided program correctly calculates the minimum cost for Alyona to have a multiple of 4 copybooks. Here’s a detailed reasoning:

1. **Initial Calculation**: The program first determines how many additional copybooks `k` are needed to make the total number of copybooks `n + k` a multiple of 4. This is done by calculating `k = 4 - n % 4`. If `n % 4` is already 0, `k` is set to 0, meaning no additional copybooks are needed.

2. **Optimal Purchase Strategy**: The program iterates over possible combinations of buying packs of 1, 2, and 3 copybooks to minimize the cost. It considers buying up to `k // 3` packs of 3 copybooks, up to `k // 2` packs of 2 copybooks, and the remaining copybooks as single packs. The cost for each combination is calculated and the minimum cost is chosen.

3. **Cost Calculation**: For each combination, the cost is computed as `3 * i * c + j * b + (k - 3 * i - 2 * j) * a`, where `i` is the number of packs of 3 copybooks, `j` is the number of packs of 2 copybooks, and the remaining `k - 3 * i - 2 * j` are bought individually.

4. **Edge Cases**: The program handles various edge cases effectively:
   - When `n % 4 == 0`, no additional copybooks are needed.
   - When `n % 4 == 1`, buying one pack of 3 and one individual copybook is the cheapest option.
   - When `n % 4 == 2`, buying one pack of 2 is the cheapest option.
   - When `n % 4 == 3`, buying one pack of 3 is the cheapest option.

Given the comprehensive approach and the logical flow, the program correctly computes the minimum cost for any valid input within the specified constraints. Therefore, the program is correct.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

