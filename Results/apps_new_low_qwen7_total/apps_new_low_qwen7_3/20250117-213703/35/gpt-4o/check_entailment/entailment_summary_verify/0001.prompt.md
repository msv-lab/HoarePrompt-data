
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into a pieces, and the second one — into b pieces.

Ivan knows that there will be n people at the celebration (including himself), so Ivan has set n plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:  Each piece of each cake is put on some plate;  Each plate contains at least one piece of cake;  No plate contains pieces of both cakes. 

To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number x such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least x pieces of cake.

Help Ivan to calculate this number x!


-----Input-----

The first line contains three integers n, a and b (1 ≤ a, b ≤ 100, 2 ≤ n ≤ a + b) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.


-----Output-----

Print the maximum possible number x such that Ivan can distribute the cake in such a way that each plate will contain at least x pieces of cake.


-----Examples-----
Input
5 2 3

Output
1

Input
4 7 10

Output
3



-----Note-----

In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.

- Program:

#Function 1:
def func_1(n, a, b):
    (low, high) = (1, min(a, b) + 1)

    while low < high:
        mid = (low + high) // 2
        if can_distribute(mid):
            low = mid + 1
        else:
            high = mid
    return low - 1

#Function 2:
def can_distribute(x):
    return a // x + b // x >= n



- Function Summary: 
Output hints for function number 2 : The function `can_distribute` accepts an integer `x` and returns whether the sum of the integer divisions of `a` and `b` by `x` is greater than or equal to `n`. Here, `a` and `b` represent the number of pieces of the first and second cake respectively, and `n` represents the number of plates. The function checks if distributing the pieces of both cakes among `n` plates using increments of `x` pieces per plate would be possible. If the condition `a // x + b // x >= n` evaluates to true, the function returns `True`; otherwise, it returns `False`. Potential edge cases include when `x` is 1 (in which case, the function always returns `True` since every piece can go into its own plate), or when `x` is greater than `a + b` (in which case, the function also always returns `False` since no distribution is possible).+


Beggining of Original Assessment: 
Reasoning:
To determine the correctness of the given program, we need to verify if the logic implemented in the `func_1` function correctly calculates the maximum possible number \( x \) such that each plate will contain at least \( x \) pieces of cake. The binary search approach used in `func_1` is a good choice for finding the optimal \( x \).

1. **Binary Search Range**: 
   - The range for the binary search is correctly initialized as `(1, min(a, b) + 1)`. This is because \( x \) must be at least 1, and it cannot exceed the smaller number of pieces between the two cakes since each plate must contain at least one piece of each cake.

2. **Binary Search Logic**:
   - The loop continues until `low` equals `high`.
   - The midpoint `mid` is calculated as `(low + high) // 2`.
   - The `can_distribute(mid)` function is called to check if distributing the cakes with each plate containing at least `mid` pieces is possible.
   - If `can_distribute(mid)` returns `True`, it means the current `mid` value might be feasible, so `low` is updated to `mid + 1`.
   - Otherwise, if `can_distribute(mid)` returns `False`, it means the current `mid` value is too large, so `high` is updated to `mid`.

3. **Return Value**:
   - After the loop ends, `low - 1` is returned. This is the largest value for which `can_distribute(mid)` is true, which is the required \( x \).

4. **Helper Function `can_distribute`**:
   - This function checks if it is possible to distribute the cakes such that each plate contains at least \( x \) pieces of cake. It does this by verifying if the sum of the integer divisions of the total pieces of both cakes by \( x \) is greater than or equal to the number of plates \( n \).
   - This logic is correct as it ensures that if each plate gets at least \( x \) pieces, the total number of pieces distributed will meet or exceed the number of plates needed.

Given the above analysis, the implementation appears to be logically sound and should work correctly under the problem constraints.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

