
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into a pieces, and the second one — into b pieces.

Ivan knows that there will be n people at the celebration (including himself), so Ivan has set n plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:  Each piece of each cake is put on some plate;  Each plate contains at least one piece of cake;  No plate contains pieces of both cakes. 

To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number x such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least x pieces of cake.

Help Ivan to calculate this number x!


-----Input-----

The first line contains three integers n, a and b (1 ≤ a, b ≤ 100, 2 ≤ n ≤ a + b) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.


-----Output-----

Print the maximum possible number x such that Ivan can distribute the cake in such a way that each plate will contain at least x pieces of cake.


-----Examples-----
Input
5 2 3

Output
1

Input
4 7 10

Output
3



-----Note-----

In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.

# Annotated Functions:
(n, a, b) = map(int, input().split())
print(func_1(n, a, b))

#Function 1:
#State of the program right berfore the function call: n, a, and b are positive integers such that 1 ≤ a, b ≤ 100 and 2 ≤ n ≤ a + b.
def func_1(n, a, b):
    low, high = 1, min(a, b) + 1
    while low < high:
        mid = (low + high) // 2
        
        if can_distribute(mid):
            low = mid + 1
        else:
            high = mid
        
    #State of the program after the loop has been executed: `n` is a positive integer such that \(2 \leq n \leq a + b\), `a` is a positive integer such that \(1 \leq a \leq 100\), `b` is a positive integer such that \(1 \leq b \leq 100\), `low` is an integer greater than or equal to 1 and less than or equal to \(\min(a, b) + 1\), `high` is \(\min(a, b) + 1\), `mid` is \(\left(\frac{\text{low} + \text{high}}{2}\right)\), and the loop continues until `low` is no longer less than `high`. If `can_distribute(mid)` returns `True` at any point, `low` will eventually be updated to a value greater than \(\min(a, b) + 1\), otherwise, `high` will be updated to a value less than or equal to \(\min(a, b) + 1\) but still greater than or equal to `low`.
    return low - 1
    #`The program returns a value that is one less than the final value of 'low' when the binary search loop terminates
#Overall this is what the function does:The function `func_1` accepts three parameters: `n`, `a`, and `b`, which are positive integers with the constraints \(2 \leq n \leq a + b\), \(1 \leq a \leq 100\), and \(1 \leq b \leq 100\). It performs a binary search within the range from 1 to \(\min(a, b) + 1\) to find the largest integer \(x\) such that \(can_distribute(x)\) returns `True`. The function returns a value that is one less than the final value of `low` when the binary search loop terminates. 

The function ensures that `n` is within the valid range and that `a` and `b` are positive integers within their specified bounds. The binary search algorithm narrows down the possible values of `x` based on the result of `can_distribute(mid)`. If `can_distribute(mid)` returns `True`, `low` is incremented to search for a larger valid `x`; otherwise, `high` is decremented to search for a smaller valid `x`.

Potential edge cases include:
- If `can_distribute(mid)` never returns `True`, the function will return 0, as `low` would reach \(\min(a, b) + 1\).
- If `can_distribute(mid)` returns `True` at the start, `low` will be set to 2, and the function will return 1.

There is no missing functionality mentioned in the annotations or code; the provided code accurately describes the intended behavior of the function.

#Function 2:
#State of the program right berfore the function call: a and b are positive integers representing the number of pieces of the first and second cake respectively, and n is a positive integer representing the number of plates such that 1 <= a, b <= 100 and 2 <= n <= a + b.
def can_distribute(x):
    return a // x + b // x >= n
    #`a // x + b // x >= n` where `a // x` is the integer division of `a` by `x` and `b // x` is the integer division of `b` by `x`, and `x` is a variable that is not defined in the given information, so the expression cannot be fully evaluated. The program returns this expression.
#Overall this is what the function does:The function `can_distribute` accepts an integer `x` and returns whether the sum of the integer divisions of `a` and `b` by `x` is greater than or equal to `n`. Here, `a` and `b` represent the number of pieces of the first and second cake respectively, and `n` represents the number of plates. The function checks if distributing the pieces of both cakes among `n` plates using increments of `x` pieces per plate would be possible. If the condition `a // x + b // x >= n` evaluates to true, the function returns `True`; otherwise, it returns `False`. Potential edge cases include when `x` is 1 (in which case, the function always returns `True` since every piece can go into its own plate), or when `x` is greater than `a + b` (in which case, the function also always returns `False` since no distribution is possible).




# Your response:
Reasoning:  
Correctness: **True** or **False**

