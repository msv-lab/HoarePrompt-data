
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Ayrat is looking for the perfect code. He decided to start his search from an infinite field tiled by hexagons. For convenience the coordinate system is introduced, take a look at the picture to see how the coordinates of hexagon are defined: 

[Image] [Image] Ayrat is searching through the field. He started at point (0, 0) and is moving along the spiral (see second picture). Sometimes he forgets where he is now. Help Ayrat determine his location after n moves.


-----Input-----

The only line of the input contains integer n (0 ≤ n ≤ 10^18) — the number of Ayrat's moves.


-----Output-----

Print two integers x and y — current coordinates of Ayrat coordinates.


-----Examples-----
Input
3

Output
-2 0

Input
7

Output
3 2

- Program: 
n = int(input().strip())
(x, y) = func_1(n)
print(x, y)

def func_1(n):
    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]
    (x, y) = (0, 0)
    steps = 1
    direction_index = 0
    while n > 0:
        for _ in range(2):
            if n >= steps:
                (dx, dy) = directions[direction_index]
                x += dx * steps
                y += dy * steps
                n -= steps
                direction_index = (direction_index + 1) % 6
            else:
                (dx, dy) = directions[direction_index]
                x += dx * n
                y += dy * n
                return (x, y)
        steps += 1
    return (x, y)



- Annotated Code: 
n = int(input().strip())
(x, y) = func_1(n)
print(x, y)

#State of the program right berfore the function call: n is an integer such that 0 <= n <= 10^18.
def func_1(n):
    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]

x, y = 0, 0

steps = 1

direction_index = 0
    while n > 0:
        for _ in range(2):
            if n >= steps:
                dx, dy = directions[direction_index]
                x += dx * steps
                y += dy * steps
                n -= steps
                direction_index = (direction_index + 1) % 6
            else:
                dx, dy = directions[direction_index]
                x += dx * n
                y += dy * n
                return x, y
        
        steps += 1
        
    #State of the program after the loop has been executed: \( n = 0 \), \( x = \sum_{i=1}^{k} (dx_i \times i) + (dx_{k+1} \times (n \mod \text{steps})) \), \( y = \sum_{i=1}^{k} (dy_i \times i) + (dy_{k+1} \times (n \mod \text{steps})) \), \( \text{direction\_index} = (\text{direction\_index} + 2k) \% 6 \), \( \text{steps} = k + 1 \).
    return x, y
    #The program returns x and y, where x is the sum of dx_i * i for i from 1 to k, plus dx_{k+1} * (n mod steps), and y is the sum of dy_i * i for i from 1 to k, plus dy_{k+1} * (n mod steps)



Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The provided program does not correctly implement the movement pattern described. The program incorrectly calculates the coordinates after a certain number of moves. Specifically, the direction changes and the steps taken do not align with the spiral pattern as illustrated. For instance, when `n = 7`, the expected output is `(3, 2)`, but the program returns incorrect values. This indicates that the logic for determining the correct direction and step count is flawed, leading to incorrect results for some inputs.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

