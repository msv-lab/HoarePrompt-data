
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Ayrat is looking for the perfect code. He decided to start his search from an infinite field tiled by hexagons. For convenience the coordinate system is introduced, take a look at the picture to see how the coordinates of hexagon are defined: 

[Image] [Image] Ayrat is searching through the field. He started at point (0, 0) and is moving along the spiral (see second picture). Sometimes he forgets where he is now. Help Ayrat determine his location after n moves.


-----Input-----

The only line of the input contains integer n (0 ≤ n ≤ 10^18) — the number of Ayrat's moves.


-----Output-----

Print two integers x and y — current coordinates of Ayrat coordinates.


-----Examples-----
Input
3

Output
-2 0

Input
7

Output
3 2

- Program:
n = int(input().strip())
(x, y) = func_1(n)
print(x, y)

def func_1(n):
    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]
    (x, y) = (0, 0)
    steps = 1
    direction_index = 0
    while n > 0:
        for _ in range(2):
            if n >= steps:
                (dx, dy) = directions[direction_index]
                x += dx * steps
                y += dy * steps
                n -= steps
                direction_index = (direction_index + 1) % 6
            else:
                (dx, dy) = directions[direction_index]
                x += dx * n
                y += dy * n
                return (x, y)
        steps += 1
    return (x, y)



- Function Summary: 
The function `func_1` accepts an integer `n` such that \(0 \leq n \leq 10^{18}\). It updates the coordinates `x` and `y` based on a series of directions defined in the `directions` list. The function returns the updated coordinates `(x, y)` after processing `n` according to the following rules:

1. If `n` is greater than or equal to 2 and less than `steps`, `x` and `y` are updated by adding `dx * n` and `dy * n` respectively, and the function returns the updated coordinates.
2. If `n` is greater than or equal to `steps`, the function processes `n` in chunks of `steps`, updating `x` and `y` by adding `dx * steps` and `dy * steps` twice per iteration, then updating `x` and `y` again by adding `dx * (n mod steps)` and `dy * (n mod steps)`. The direction index is updated accordingly, and the function returns the final coordinates.
3. If `n` is less than 2, the function directly updates `x` and `y` by adding `dx * n` and `dy * n` and returns the updated coordinates.
4. After each full cycle of updating `x` and `y` for `steps`, the `direction_index` and `steps` are adjusted, and the process continues until `n` becomes zero.

The final state of the program after the function concludes is that it returns the coordinates `(x, y)` where `x` and `y` are updated based on the above rules.

Beggining of Original Assessment: 
Reasoning:
Let's analyze the given program step-by-step to determine its correctness:

1. **Input Handling**: The program correctly reads the input `n` and initializes the starting position `(x, y)` to `(0, 0)`.

2. **Direction Logic**: The program defines six directions for movement around the hexagonal grid. This logic appears to be correct and matches the pattern of movement described in the problem.

3. **Loop Structure**: 
   - The main loop runs until all `n` moves are made.
   - Inside this loop, there is an additional loop that handles the movement in each direction. The outer loop increments the number of steps taken in the current direction and changes direction every two steps.
   - The inner loop ensures that the exact number of moves specified by `n` are taken, updating the position `(x, y)` accordingly.

4. **Edge Cases**:
   - If `n` is exactly equal to the number of steps in a direction, the program correctly updates the position.
   - If `n` is less than the number of steps, it updates the position partially and returns the result.

5. **Boundary Checks**:
   - The program correctly handles the boundary conditions where the number of remaining moves (`n`) is less than the current step count, ensuring the exact number of moves is taken.

Given these points, the program appears to follow the correct logic for determining Ayrat's position after `n` moves on the hexagonal grid. It correctly accounts for the spiral movement pattern and updates the position accurately.

Therefore:
Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

