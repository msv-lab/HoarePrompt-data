Reasoning:

1. The program correctly reads two integers `n` and `k` from the standard input.
2. It then calculates all unique divisors of `n` by iterating from 1 to the square root of `n`. For each divisor `i`, it checks if `i` divides `n` without a remainder. If so, `i` is added to the `divisors` list. If `i * i` is not equal to `n`, `n // i` is also added to ensure all divisors are included.
3. After collecting all divisors, the list is sorted in ascending order.
4. The program then checks if `k` is greater than the number of divisors. If true, it prints `-1`, indicating there are fewer than `k` divisors.
5. If there are at least `k` divisors, it prints the `k-th` smallest divisor, which is `divisors[k - 1]`.
6. The program logic is sound and handles all specified cases, including when `n` is a prime number, which would result in only two divisors (1 and `n`).

Given this analysis, the program correctly implements the functionality described in the problem statement.

Correctness: **True**