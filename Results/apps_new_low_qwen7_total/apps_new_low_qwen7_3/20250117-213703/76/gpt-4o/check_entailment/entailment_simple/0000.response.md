### Reasoning:

1. **Input Parsing and Initialization**:
   - The code correctly reads the input dimensions `n` and `m` and initializes the necessary variables.
   - The grid is constructed from the input data, and the `row_walls` and `col_walls` arrays are initialized to zero.

2. **Counting Walls**:
   - The nested loop correctly counts the number of walls (`*`) in each row and each column, and updates the `total_walls` variable.

3. **Checking Conditions**:
   - The final nested loop checks if placing the bomb in any cell `(i, j)` would result in all walls being wiped out. Specifically, it checks if the sum of the walls in row `i` and column `j` minus the wall in the cell itself (if present) equals the total number of walls in the grid.
   - If such a cell is found, it prints "YES" followed by the coordinates of the cell and returns.

4. **Output Handling**:
   - If no suitable cell is found, it prints "NO".

### Detailed Analysis:

- **Input Parsing**: 
  - The code correctly reads the dimensions `n` and `m`.
  - It constructs the grid and initializes `row_walls` and `col_walls`.

- **Wall Counting**:
  - The nested loops iterate over each cell, counting walls in rows and columns correctly.

- **Condition Checking**:
  - The condition `row_walls[i] + col_walls[j] - (1 if grid[i][j] == '*' else 0) == total_walls` is used to determine if placing the bomb in cell `(i, j)` would clear all walls.
  - This condition ensures that if the bomb is placed in a cell with a wall, it removes the wall in the row and column, but not twice.

- **Output**:
  - If the condition is met, it prints "YES" and the coordinates, then exits.
  - If no such cell is found, it prints "NO".

### Conclusion:

The code logic is correct and follows the requirements specified in the problem statement. It accurately determines whether it's possible to wipe out all walls by placing the bomb in a single cell.

### Final Answer:
Correctness: **True**