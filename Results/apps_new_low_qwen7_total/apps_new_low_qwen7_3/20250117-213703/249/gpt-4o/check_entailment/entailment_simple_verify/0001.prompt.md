
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Memory and his friend Lexa are competing to get higher score in one popular computer game. Memory starts with score a and Lexa starts with score b. In a single turn, both Memory and Lexa get some integer in the range [ - k;k] (i.e. one integer among  - k,  - k + 1,  - k + 2, ...,  - 2,  - 1, 0, 1, 2, ..., k - 1, k) and add them to their current scores. The game has exactly t turns. Memory and Lexa, however, are not good at this game, so they both always get a random integer at their turn.

Memory wonders how many possible games exist such that he ends with a strictly higher score than Lexa. Two games are considered to be different if in at least one turn at least one player gets different score. There are (2k + 1)^2t games in total. Since the answer can be very large, you should print it modulo 10^9 + 7. Please solve this problem for Memory.


-----Input-----

The first and only line of input contains the four integers a, b, k, and t (1 ≤ a, b ≤ 100, 1 ≤ k ≤ 1000, 1 ≤ t ≤ 100) — the amount Memory and Lexa start with, the number k, and the number of turns respectively.


-----Output-----

Print the number of possible games satisfying the conditions modulo 1 000 000 007 (10^9 + 7) in one line.


-----Examples-----
Input
1 2 2 1

Output
6

Input
1 1 1 2

Output
31

Input
2 12 3 1

Output
0



-----Note-----

In the first sample test, Memory starts with 1 and Lexa starts with 2. If Lexa picks  - 2, Memory can pick 0, 1, or 2 to win. If Lexa picks  - 1, Memory can pick 1 or 2 to win. If Lexa picks 0, Memory can pick 2 to win. If Lexa picks 1 or 2, Memory cannot win. Thus, there are 3 + 2 + 1 = 6 possible games in which Memory wins.

- Program: 
MOD = 10 ** 9 + 7
(a, b, k, t) = map(int, input().split())
func_1(a, b, k, t)

def func_1(a, b, k, t):
    max_diff = 2 * k * t
    dp_prev = [0] * (2 * max_diff + 1)
    dp_curr = [0] * (2 * max_diff + 1)
    dp_prev[max_diff + (a - b)] = 1
    for _ in range(t):
        prefix_sum = [0] * (2 * max_diff + 3)
        for i in range(2 * max_diff + 1):
            prefix_sum[i + 1] = (prefix_sum[i] + dp_prev[i]) % MOD
        for i in range(2 * max_diff + 1):
            left = max(0, i - 2 * k)
            right = min(2 * max_diff, i + 2 * k) + 1
            dp_curr[i] = (prefix_sum[right] - prefix_sum[left]) % MOD
        (dp_prev, dp_curr) = (dp_curr, dp_prev)
    result = 0
    for i in range(max_diff + 1, 2 * max_diff + 1):
        result = (result + dp_prev[i]) % MOD
    print(result)



- Annotated Code: 
MOD = 10 ** 9 + 7
(a, b, k, t) = map(int, input().split())
func_1(a, b, k, t)

#State of the program right berfore the function call: a, b, and k are integers such that 1 ≤ a, b ≤ 100 and 1 ≤ k ≤ 1000, and t is an integer such that 1 ≤ t ≤ 100.
def func_1(a, b, k, t):
    max_diff = 2 * k * t

dp_prev = [0] * (2 * max_diff + 1)

dp_curr = [0] * (2 * max_diff + 1)

dp_prev[max_diff + (a - b)] = 1
    for _ in range(t):
        prefix_sum = [0] * (2 * max_diff + 3)
        
        for i in range(2 * max_diff + 1):
            prefix_sum[i + 1] = (prefix_sum[i] + dp_prev[i]) % MOD
        
        for i in range(2 * max_diff + 1):
            left = max(0, i - 2 * k)
            right = min(2 * max_diff, i + 2 * k) + 1
            dp_curr[i] = (prefix_sum[right] - prefix_sum[left]) % MOD
        
        dp_prev, dp_curr = dp_curr, dp_prev
        
    #State of the program after the  for loop has been executed: a is an integer such that 1 ≤ a ≤ 100, b is an integer such that 1 ≤ b ≤ 100, k is an integer such that 1 ≤ k ≤ 1000, t is an integer such that 1 ≤ t ≤ 100, max_diff is 2 * k * t, dp_prev is a list of integers with length 2 * max_diff + 1 where all elements are 0, dp_curr is a list of integers with length 2 * max_diff + 1 where all elements are 0, prefix_sum is a list of integers with length 2 * max_diff + 3 where all elements are 0, `i` is 2 * `max_diff`, `left` is max(0, 2 * `max_diff` - 2 * `k`), `right` is min(2 * `max_diff`, 2 * `max_diff`) + 1.
    result = 0
    for i in range(max_diff + 1, 2 * max_diff + 1):
        result = (result + dp_prev[i]) % MOD
        
    #State of the program after the  for loop has been executed: `i` is `max_diff + 1`, `result` is \((\sum_{j=max_diff+1}^{2*max_diff} dp_prev[j]) \% MOD\)
    print(result)



Beggining of Original Assessment: 
Reasoning:

To determine if the given program is correct, let's break down the logic and ensure it aligns with the problem statement.

### Problem Analysis:
- We need to calculate the number of games where Memory's final score is strictly higher than Lexa's final score.
- Both players start with scores `a` and `b` respectively and play `t` turns.
- Each turn, a player can add an integer from the range `[-k, k]` to their score.
- The game has `(2k + 1)^(2t)` possible outcomes, but we are only interested in those where Memory's score is greater than Lexa's.

### Key Steps in the Program:
1. **Initialization**: 
   - Set `MOD` to \(10^9 + 7\).
   - Read input values `a`, `b`, `k`, and `t`.
   - Call `func_1(a, b, k, t)`.

2. **Dynamic Programming Setup**:
   - `max_diff` is set to `2 * k * t`, representing the maximum possible difference between the two players' scores.
   - `dp_prev` and `dp_curr` are initialized arrays to store the probability distribution of score differences after each turn.

3. **DP Transition**:
   - `dp_prev` is initially set based on the initial difference between Memory's and Lexa's scores (`a - b`).
   - For each turn, `dp_curr` is updated using prefix sums to efficiently compute the transition probabilities.

4. **Result Calculation**:
   - After all turns, the result is computed as the sum of `dp_prev` entries corresponding to positive score differences (since Memory needs to have a strictly higher score).

### Detailed Verification:
1. **Modulo Operation**: The use of `MOD` ensures results do not overflow, which is crucial for large values of `t`.

2. **Dynamic Programming Implementation**:
   - The logic for updating `dp_curr` and `dp_prev` is correct. It correctly handles the range of score differences and transitions over turns.

3. **Boundary Conditions**:
   - The range checks (`left` and `right`) ensure that index bounds are handled properly, preventing out-of-range errors.

4. **Final Result Calculation**:
   - Summing up `dp_prev` values from `max_diff + 1` to `2 * max_diff` is the correct approach to count games where Memory's score is strictly higher.

Given that the program follows the dynamic programming approach accurately and correctly implements the solution, the program appears to be logically sound and should produce the correct output.

### Conclusion:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

