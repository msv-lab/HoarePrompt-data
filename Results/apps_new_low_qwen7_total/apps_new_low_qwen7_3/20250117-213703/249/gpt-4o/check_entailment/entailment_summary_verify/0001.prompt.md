
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Memory and his friend Lexa are competing to get higher score in one popular computer game. Memory starts with score a and Lexa starts with score b. In a single turn, both Memory and Lexa get some integer in the range [ - k;k] (i.e. one integer among  - k,  - k + 1,  - k + 2, ...,  - 2,  - 1, 0, 1, 2, ..., k - 1, k) and add them to their current scores. The game has exactly t turns. Memory and Lexa, however, are not good at this game, so they both always get a random integer at their turn.

Memory wonders how many possible games exist such that he ends with a strictly higher score than Lexa. Two games are considered to be different if in at least one turn at least one player gets different score. There are (2k + 1)^2t games in total. Since the answer can be very large, you should print it modulo 10^9 + 7. Please solve this problem for Memory.


-----Input-----

The first and only line of input contains the four integers a, b, k, and t (1 ≤ a, b ≤ 100, 1 ≤ k ≤ 1000, 1 ≤ t ≤ 100) — the amount Memory and Lexa start with, the number k, and the number of turns respectively.


-----Output-----

Print the number of possible games satisfying the conditions modulo 1 000 000 007 (10^9 + 7) in one line.


-----Examples-----
Input
1 2 2 1

Output
6

Input
1 1 1 2

Output
31

Input
2 12 3 1

Output
0



-----Note-----

In the first sample test, Memory starts with 1 and Lexa starts with 2. If Lexa picks  - 2, Memory can pick 0, 1, or 2 to win. If Lexa picks  - 1, Memory can pick 1 or 2 to win. If Lexa picks 0, Memory can pick 2 to win. If Lexa picks 1 or 2, Memory cannot win. Thus, there are 3 + 2 + 1 = 6 possible games in which Memory wins.

- Program:
MOD = 10 ** 9 + 7
(a, b, k, t) = map(int, input().split())
func_1(a, b, k, t)

def func_1(a, b, k, t):
    max_diff = 2 * k * t
    dp_prev = [0] * (2 * max_diff + 1)
    dp_curr = [0] * (2 * max_diff + 1)
    dp_prev[max_diff + (a - b)] = 1
    for _ in range(t):
        prefix_sum = [0] * (2 * max_diff + 3)
        for i in range(2 * max_diff + 1):
            prefix_sum[i + 1] = (prefix_sum[i] + dp_prev[i]) % MOD
        for i in range(2 * max_diff + 1):
            left = max(0, i - 2 * k)
            right = min(2 * max_diff, i + 2 * k) + 1
            dp_curr[i] = (prefix_sum[right] - prefix_sum[left]) % MOD
        (dp_prev, dp_curr) = (dp_curr, dp_prev)
    result = 0
    for i in range(max_diff + 1, 2 * max_diff + 1):
        result = (result + dp_prev[i]) % MOD
    print(result)



- Function Summary: 
The function `func_1` accepts four parameters \(a\), \(b\), \(k\), and \(t\), where \(1 \leq a, b, k \leq 100\) and \(1 \leq t \leq 100\). It calculates and returns a value based on dynamic programming principles. Specifically, it computes a result derived from a series of operations involving prefix sums and rolling window updates over a range defined by \(2 \cdot k \cdot t\).

Initially, a temporary array `dp_prev` is initialized with zeros. Then, for each iteration of the outer loop up to \(t\), a new array `dp_curr` is similarly initialized. Within each iteration, a prefix sum array `prefix_sum` is computed and used to update `dp_curr` based on the values in `dp_prev` within a specified sliding window of size \(4 \cdot k + 1\). After updating both arrays, they are swapped to prepare for the next iteration.

Finally, the function iterates over the range from `max_diff + 1` to `2 * max_diff` (where `max_diff = 2 \cdot k \cdot t`), accumulating the values from `dp_prev` into the variable `result`. The function then prints the computed result, which is the sum of certain elements in `dp_prev` modulo a constant `MOD`.

Potential edge cases include the initial setup of the arrays and the boundary conditions of the sliding window. The function assumes valid inputs for \(a\), \(b\), \(k\), and \(t\) within their specified ranges. If these conditions are not met, the function may behave unpredictably or raise errors.

Beggining of Original Assessment: 
Reasoning:

To determine if the given program is correct, let's break down the logic and ensure it aligns with the problem statement.

### Problem Analysis:
- We need to calculate the number of games where Memory's final score is strictly higher than Lexa's final score.
- Both players start with scores `a` and `b` respectively and play `t` turns.
- Each turn, a player can add an integer from the range `[-k, k]` to their score.
- The game has `(2k + 1)^(2t)` possible outcomes, but we are only interested in those where Memory's score is greater than Lexa's.

### Key Steps in the Program:
1. **Initialization**: 
   - Set `MOD` to \(10^9 + 7\).
   - Read input values `a`, `b`, `k`, and `t`.
   - Call `func_1(a, b, k, t)`.

2. **Dynamic Programming Setup**:
   - `max_diff` is set to `2 * k * t`, representing the maximum possible difference between the two players' scores.
   - `dp_prev` and `dp_curr` are initialized arrays to store the probability distribution of score differences after each turn.

3. **DP Transition**:
   - `dp_prev` is initially set based on the initial difference between Memory's and Lexa's scores (`a - b`).
   - For each turn, `dp_curr` is updated using prefix sums to efficiently compute the transition probabilities.

4. **Result Calculation**:
   - After all turns, the result is computed as the sum of `dp_prev` entries corresponding to positive score differences (since Memory needs to have a strictly higher score).

### Detailed Verification:
1. **Modulo Operation**: The use of `MOD` ensures results do not overflow, which is crucial for large values of `t`.

2. **Dynamic Programming Implementation**:
   - The logic for updating `dp_curr` and `dp_prev` is correct. It correctly handles the range of score differences and transitions over turns.

3. **Boundary Conditions**:
   - The range checks (`left` and `right`) ensure that index bounds are handled properly, preventing out-of-range errors.

4. **Final Result Calculation**:
   - Summing up `dp_prev` values from `max_diff + 1` to `2 * max_diff` is the correct approach to count games where Memory's score is strictly higher.

Given that the program follows the dynamic programming approach accurately and correctly implements the solution, the program appears to be logically sound and should produce the correct output.

### Conclusion:
Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

