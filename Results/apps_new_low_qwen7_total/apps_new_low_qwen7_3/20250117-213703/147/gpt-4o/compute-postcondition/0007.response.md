Output State: `n` must be greater than `b`, `k` is an integer such that `2 ≤ k < n ≤ 100`, `b` is an integer such that `1 ≤ b ≤ n`, `remaining_tabs` is a list of length `n` where `remaining_tabs[i]` is `0` for all indices `i` that satisfy `i = b + ik % n` (where `%` denotes the modulo operation), and all other elements in `remaining_tabs` remain equal to their initial values in `tab_types`. The loop continues until `i` exceeds `n-1`.

### Explanation:
1. **Analyze the Code and Initial State**: 
   - The loop iterates over indices starting from `b` up to `n-1` in steps of size `k`.
   - For each index `i` that satisfies `i = b + ik % n`, the corresponding element in `remaining_tabs` is set to `0`.

2. **Track Variable Changes**:
   - `n` and `k` remain constant throughout the loop.
   - `b` remains constant.
   - `remaining_tabs` changes based on the indices `i` computed in the loop.

3. **Summarize the Loop Behavior**:
   - The loop sets `remaining_tabs[i]` to `0` for each `i` calculated as `b + ik % n` until `i` no longer falls within the range `[b, n-1]`.
   - If `i` exceeds `n-1`, the loop terminates.

4. **Verify Relationships**:
   - The conditions for the loop to execute are met if `n > b` and `2 ≤ k < n ≤ 100` and `1 ≤ b ≤ n`.
   - After the loop completes, `remaining_tabs` will have `0` at indices that are congruent to `b` modulo `k`, i.e., `i = b + ik % n` for all valid `i`.

Thus, the final output state reflects that all specified elements in `remaining_tabs` have been set to `0` according to the loop's behavior.