
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:

Find k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. 

To be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \operatorname{max}_{1 \leq i \leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.

For definitions of powers and lexicographical order see notes.


-----Input-----

The first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.


-----Output-----

Output "No" (without quotes) in a single line if there does not exist such sequence. Otherwise, output "Yes" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.

It is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].


-----Examples-----
Input
23 5

Output
Yes
3 3 2 1 0 

Input
13 2

Output
No

Input
1 2

Output
Yes
-1 -1 



-----Note-----

Sample 1:

2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23

Answers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.

Answers like (4, 1, 1, 1, 0) do not have the minimum y value.

Sample 2:

It can be shown there does not exist a sequence with length 2.

Sample 3:

$2^{-1} + 2^{-1} = \frac{1}{2} + \frac{1}{2} = 1$

Powers of 2:

If x > 0, then 2^{x} = 2·2·2·...·2 (x times).

If x = 0, then 2^{x} = 1.

If x < 0, then $2^{x} = \frac{1}{2^{-x}}$.

Lexicographical order:

Given two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.

- Program: 
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

def func_1(n, k):
    if k > n:
        return 'No'
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
    if len(bits) > k:
        return 'No'
    while len(bits) < k:
        smallest = bits.pop()
        bits.append(smallest - 1)
        bits.append(smallest - 1)
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))



- Annotated Code: 
import sys

input = sys.stdin.read
data = input().strip().split()
n = int(data[0])
k = int(data[1])
print(func_1(n, k))

#State of the program right berfore the function call: n is a non-negative integer such that 1 ≤ n ≤ 10^18, and k is a positive integer such that 1 ≤ k ≤ 10^5.
def func_1(n, k):
    if (k > n) :
        return 'No'
        #The program returns 'No'
    #State of the program after the if block has been executed: n is a non-negative integer such that 1 ≤ n ≤ 10^18, k is a positive integer such that 1 ≤ k ≤ 10^5, and k is less than or equal to n
    bits = []
    for i in range(60, -1, -1):
        if n >> i & 1:
            bits.append(i)
        
    #State of the program after the  for loop has been executed: `total` is 10, `i` is -1, `n` is a non-negative integer such that \(1 \leq n \leq 10^{18}\), `k` is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), `bits` is a list containing all indices `i` from 60 down to the highest bit set in `n` (inclusive).
    if (len(bits) > k) :
        return 'No'
        #The program returns 'No'
    #State of the program after the if block has been executed: `total` is 10, `i` is -1, `n` is a non-negative integer such that \(1 \leq n \leq 10^{18}\), `k` is a positive integer such that \(1 \leq k \leq 10^5\) and \(k \leq n\), `bits` is a list containing all indices `i` from 60 down to the highest bit set in `n` (inclusive). The length of `bits` is less than or equal to `k`.
    while len(bits) < k:
        smallest = bits.pop()
        
        bits.append(smallest - 1)
        
        bits.append(smallest - 1)
        
    #State of the program after the loop has been executed: - Since the loop continues until `len(bits) == k`, the final state of `bits` will be a list with exactly `k` elements, where each element is the result of decrementing the smallest element of the previous list twice.
    #   - `total` and `i` remain unchanged.
    #   - `n` remains unchanged.
    #   - `k` remains unchanged.
    #   - `bits` will have `k` elements, with the last two being the smallest element of the final list minus one, and the rest of the elements will be derived from the previous iterations.
    #
    #### Conclusion
    #
    #The final output state after the loop has executed all necessary iterations to reach `len(bits) == k` is:
    #
    #Output State:
    bits.sort(reverse=True)
    return 'Yes\n' + ' '.join(map(str, bits))
    #'Yes\n' followed by the elements of list 'bits' joined into a single string separated by spaces



Beggining of Original Assessment: 
Reasoning:

The given program aims to solve the problem by finding \(k\) integers such that the sum of \(2^{a_i}\) equals \(n\), and the largest integer in the answer is minimized. Additionally, among all such sequences, it should return the lexicographically largest one.

Here's a breakdown of the program:

1. **Reading Input**: The program reads the input from standard input, which is handled correctly.
2. **Function `func_1`**:
   - It checks if \(k\) is greater than \(n\). If so, it immediately returns 'No', which is correct because it’s impossible to represent \(n\) using fewer terms than \(n\) itself.
   - It calculates the binary representation of \(n\) by iterating from 60 down to -1. This approach ensures that we capture the highest possible bit positions first.
   - If the number of set bits (bits that contribute to the sum) exceeds \(k\), it returns 'No'. This is also correct because having more than \(k\) bits means it’s not possible to form the desired sequence with \(k\) elements.
   - If there are enough bits to form the sequence, it starts filling the remaining slots by decrementing the smallest bit found so far to ensure the sequence remains minimal in maximum value and maximizes lexicographical order.
   - Finally, it sorts the resulting list in descending order to get the lexicographically largest sequence and outputs 'Yes' followed by the sequence.

The program handles the constraints and requirements correctly. It ensures the sum condition is met, minimizes the maximum value, and produces the lexicographically largest sequence.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

