### Reasoning:

1. **Initial Checks and Assumptions:**
   - The program correctly reads the inputs `n` and `k` using `map(int, input().split())`.
   - It calls the function `func_1(n, k)` and checks if the result is `-1`, indicating an impossible sequence.
   - If `func_1` returns `-1`, it prints `-1`. Otherwise, it prints the sequence in the required format.

2. **Function `func_1`:**
   - The function first calculates the minimum sum of the sequence using the formula \( \text{min\_sum} = \frac{k \times (k + 1)}{2} \).
   - If this minimum sum is greater than `n`, the function immediately returns `-1` because it's not possible to form a sequence with `k` elements that sums to `n`.
   - Otherwise, it computes the greatest common divisor `d` as `n // min_sum`.
   - It then calculates the remainder as `remainder = n - d * min_sum`.
   - The function constructs the sequence starting from `d * (i + 1)` for each element, ensuring the sequence is strictly increasing.
   - After constructing the initial sequence, it adjusts the last few elements to ensure the sequence sums to `n` exactly by incrementing the necessary elements.

3. **Verification of Sequence Construction:**
   - The sequence construction logic ensures that each element is a multiple of `d` and that the total sum equals `n`.
   - The adjustments made in the loop ensure that the sequence remains strictly increasing and sums to `n`.

4. **Edge Cases:**
   - The function handles the edge case where the minimum sum exceeds `n` by returning `-1`.
   - For valid cases, the constructed sequence meets the problem requirements.

Given the detailed steps and the logical flow of the program, it appears that the program correctly implements the solution to the problem.

### Correctness:
**True**