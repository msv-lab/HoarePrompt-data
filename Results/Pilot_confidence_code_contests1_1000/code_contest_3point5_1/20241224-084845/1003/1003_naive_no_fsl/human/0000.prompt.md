
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Little Petya likes permutations a lot. Recently his mom has presented him permutation q1, q2, ..., qn of length n.

A permutation a of length n is a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ n), all integers there are distinct. 

There is only one thing Petya likes more than permutations: playing with little Masha. As it turns out, Masha also has a permutation of length n. Petya decided to get the same permutation, whatever the cost may be. For that, he devised a game with the following rules:

  * Before the beginning of the game Petya writes permutation 1, 2, ..., n on the blackboard. After that Petya makes exactly k moves, which are described below. 
  * During a move Petya tosses a coin. If the coin shows heads, he performs point 1, if the coin shows tails, he performs point 2.
    1. Let's assume that the board contains permutation p1, p2, ..., pn at the given moment. Then Petya removes the written permutation p from the board and writes another one instead: pq1, pq2, ..., pqn. In other words, Petya applies permutation q (which he has got from his mother) to permutation p. 
    2. All actions are similar to point 1, except that Petya writes permutation t on the board, such that: tqi = pi for all i from 1 to n. In other words, Petya applies a permutation that is inverse to q to permutation p. 



We know that after the k-th move the board contained Masha's permutation s1, s2, ..., sn. Besides, we know that throughout the game process Masha's permutation never occurred on the board before the k-th move. Note that the game has exactly k moves, that is, throughout the game the coin was tossed exactly k times.

Your task is to determine whether the described situation is possible or else state that Petya was mistaken somewhere. See samples and notes to them for a better understanding.

Input

The first line contains two integers n and k (1 ≤ n, k ≤ 100). The second line contains n space-separated integers q1, q2, ..., qn (1 ≤ qi ≤ n) — the permutation that Petya's got as a present. The third line contains Masha's permutation s, in the similar format.

It is guaranteed that the given sequences q and s are correct permutations.

Output

If the situation that is described in the statement is possible, print "YES" (without the quotes), otherwise print "NO" (without the quotes).

Examples

Input

4 1
2 3 4 1
1 2 3 4


Output

NO


Input

4 1
4 3 1 2
3 4 2 1


Output

YES


Input

4 3
4 3 1 2
3 4 2 1


Output

YES


Input

4 2
4 3 1 2
2 1 4 3


Output

YES


Input

4 1
4 3 1 2
2 1 4 3


Output

NO

Note

In the first sample Masha's permutation coincides with the permutation that was written on the board before the beginning of the game. Consequently, that violates the condition that Masha's permutation never occurred on the board before k moves were performed.

In the second sample the described situation is possible, in case if after we toss a coin, we get tails.

In the third sample the possible coin tossing sequence is: heads-tails-tails.

In the fourth sample the possible coin tossing sequence is: heads-heads.
Program:
```
q = []
p = []
if __name__ == '__main__':
    (n, k) = map(int, raw_input().split())
    q = [0] + map(int, raw_input().split())
    p = [0] + map(int, raw_input().split())
    a = [0] * (n + 1)
    for i in xrange(1, n + 1):
        a[i] = i
    if a == p:
        print('NO')
        exit()
    x = [0] * (n + 1)
    for i in xrange(1, n + 1):
        x[i] = i
    func_3(x, n)
    for i in xrange(1, k + 1):
        func_2(a, n)
        if a == p:
            if i == k:
                print('YES')
            elif (k - i) % 2 == 0 and x != p:
                print('YES')
            else:
                print('NO')
                break
    for i in xrange(1, n + 1):
        a[i] = i
        x[i] = i
    func_2(x, n)
    for i in xrange(1, k + 1):
        func_3(a, n)
        if a == p:
            if i == k:
                print('YES')
            elif (k - i) % 2 == 0 and x != p:
                print('YES')
            else:
                print('NO')
            exit()
    print('NO')

def func_1():
    print('PrimeMusic')

def func_2(a, n):
    b = [0] * (n + 1)
    for i in xrange(1, n + 1):
        b[i] = a[q[i]]
    for i in xrange(1, n + 1):
        a[i] = b[i]

def func_3(a, n):
    b = [0] * (n + 1)
    for i in xrange(1, n + 1):
        b[q[i]] = a[i]
    for i in xrange(1, n + 1):
        a[i] = b[i]


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
