
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: A schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.

Applying the simplest variant of median smoothing to the sequence of numbers a1, a2, ..., an will result a new sequence b1, b2, ..., bn obtained by the following algorithm:

  * b1 = a1, bn = an, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence. 
  * For i = 2, ..., n - 1 value bi is equal to the median of three values ai - 1, ai and ai + 1. 



The median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.

In order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.

Having made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.

Now Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.

Input

The first input line of the input contains a single integer n (3 ≤ n ≤ 500 000) — the length of the initial sequence.

The next line contains n integers a1, a2, ..., an (ai = 0 or ai = 1), giving the initial sequence itself.

Output

If the sequence will never become stable, print a single number  - 1.

Otherwise, first print a single integer — the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space — the resulting sequence itself.

Examples

Input

4
0 0 1 1


Output

0
0 0 1 1


Input

5
0 1 0 1 0


Output

2
0 0 0 0 0

Note

In the second sample the stabilization occurs in two steps: <image>, and the sequence 00000 is obviously stable.
Program:
```
from math import *
from Queue import *
from sys import *

n = int(raw_input())
l = map(int, raw_input().split())
br = []
for i in range(n - 1):
    if l[i] == l[i + 1]:
        br.append(i + 1)
c = []
for i in range(len(br) - 1):
    if br[i + 1] == br[i] + 1:
        pass
    else:
        c.append((br[i + 1] - br[i] - 2) / 2)
if len(c) == 0:
    m = (n - 1) / 2
else:
    m = max(c)
for i in range(m):
    l = func_1(l)
print(m)
print(' '.join(map(str, l)))

def func_1(l):
    new = []
    new.append(l[0])
    for i in range(1, len(l) - 1):
        new.append((l[i - 1] + l[i] + l[i + 1]) / 2)
    new.append(l[-1])
    return new


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
