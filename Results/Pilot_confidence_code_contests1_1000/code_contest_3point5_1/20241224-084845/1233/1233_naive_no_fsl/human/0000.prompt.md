
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Let's call two strings s and t anagrams of each other if it is possible to rearrange symbols in the string s to get a string, equal to t.

Let's consider two strings s and t which are anagrams of each other. We say that t is a reducible anagram of s if there exists an integer k ≥ 2 and 2k non-empty strings s_1, t_1, s_2, t_2, ..., s_k, t_k that satisfy the following conditions:

  1. If we write the strings s_1, s_2, ..., s_k in order, the resulting string will be equal to s; 
  2. If we write the strings t_1, t_2, ..., t_k in order, the resulting string will be equal to t; 
  3. For all integers i between 1 and k inclusive, s_i and t_i are anagrams of each other. 



If such strings don't exist, then t is said to be an irreducible anagram of s. Note that these notions are only defined when s and t are anagrams of each other.

For example, consider the string s =  "gamegame". Then the string t =  "megamage" is a reducible anagram of s, we may choose for example s_1 =  "game", s_2 =  "gam", s_3 =  "e" and t_1 =  "mega", t_2 =  "mag", t_3 =  "e":

<image>

On the other hand, we can prove that t =  "memegaga" is an irreducible anagram of s.

You will be given a string s and q queries, represented by two integers 1 ≤ l ≤ r ≤ |s| (where |s| is equal to the length of the string s). For each query, you should find if the substring of s formed by characters from the l-th to the r-th has at least one irreducible anagram.

Input

The first line contains a string s, consisting of lowercase English characters (1 ≤ |s| ≤ 2 ⋅ 10^5).

The second line contains a single integer q (1 ≤ q ≤ 10^5) — the number of queries.

Each of the following q lines contain two integers l and r (1 ≤ l ≤ r ≤ |s|), representing a query for the substring of s formed by characters from the l-th to the r-th.

Output

For each query, print a single line containing "Yes" (without quotes) if the corresponding substring has at least one irreducible anagram, and a single line containing "No" (without quotes) otherwise.

Examples

Input


aaaaa
3
1 1
2 4
5 5


Output


Yes
No
Yes


Input


aabbbbbbc
6
1 2
2 4
2 2
1 9
5 7
3 5


Output


No
Yes
Yes
Yes
No
No

Note

In the first sample, in the first and third queries, the substring is "a", which has itself as an irreducible anagram since two or more non-empty strings cannot be put together to obtain "a". On the other hand, in the second query, the substring is "aaa", which has no irreducible anagrams: its only anagram is itself, and we may choose s_1 =  "a", s_2 =  "aa", t_1 =  "a", t_2 =  "aa" to show that it is a reducible anagram.

In the second query of the second sample, the substring is "abb", which has, for example, "bba" as an irreducible anagram.
Program:
```
from sys import stdin

def func():
    rstr = lambda : stdin.readline().strip()
    rint = lambda : int(stdin.readline())
    rints = lambda : [int(x) for x in stdin.readline().split()]
    rints_2d = lambda n: [rints() for _ in range(n)]
    out = []
    chrs = 'abcdefghijklmnopqrstuvwxyz'
    (s, n) = (rstr(), rint())
    (qur, mem) = (rints_2d(n), [])
    for i in chrs:
        tem = [0]
        for j in range(len(s)):
            tem.append(tem[-1] + (s[j] == i))
        mem.append(tem)
    for (l, r) in qur:
        all = []
        for i in range(26):
            tem = mem[i][r] - mem[i][l - 1]
            if tem:
                all.append((tem, chrs[i]))
        out.append('Yes' if l == r or s[l - 1] != s[r - 1] or len(all) > 2 else 'No')
    print('\n'.join(map(str, out)))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
