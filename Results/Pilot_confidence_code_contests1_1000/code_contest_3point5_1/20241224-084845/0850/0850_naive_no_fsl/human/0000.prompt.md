
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Palo Alto is an unusual city because it is an endless coordinate line. It is also known for the office of Lyft Level 5.

Lyft has become so popular so that it is now used by all m taxi drivers in the city, who every day transport the rest of the city residents — n riders.

Each resident (including taxi drivers) of Palo-Alto lives in its unique location (there is no such pair of residents that their coordinates are the same).

The Lyft system is very clever: when a rider calls a taxi, his call does not go to all taxi drivers, but only to the one that is the closest to that person. If there are multiple ones with the same distance, then to taxi driver with a smaller coordinate is selected.

But one morning the taxi drivers wondered: how many riders are there that would call the given taxi driver if they were the first to order a taxi on that day? In other words, you need to find for each taxi driver i the number a_{i} — the number of riders that would call the i-th taxi driver when all drivers and riders are at their home?

The taxi driver can neither transport himself nor other taxi drivers.

Input

The first line contains two integers n and m (1 ≤ n,m ≤ 10^5) — number of riders and taxi drivers.

The second line contains n + m integers x_1, x_2, …, x_{n+m} (1 ≤ x_1 < x_2 < … < x_{n+m} ≤ 10^9), where x_i is the coordinate where the i-th resident lives. 

The third line contains n + m integers t_1, t_2, …, t_{n+m} (0 ≤ t_i ≤ 1). If t_i = 1, then the i-th resident is a taxi driver, otherwise t_i = 0.

It is guaranteed that the number of i such that t_i = 1 is equal to m.

Output

Print m integers a_1, a_2, …, a_{m}, where a_i is the answer for the i-th taxi driver. The taxi driver has the number i if among all the taxi drivers he lives in the i-th smallest coordinate (see examples for better understanding).

Examples

Input

3 1
1 2 3 10
0 0 1 0


Output

3 

Input

3 2
2 3 4 5 6
1 0 0 0 1


Output

2 1 

Input

1 4
2 4 6 10 15
1 1 1 1 0


Output

0 0 0 1 

Note

In the first example, we have only one taxi driver, which means an order from any of n riders will go to him.

In the second example, the first taxi driver lives at the point with the coordinate 2, and the second one lives at the point with the coordinate 6. Obviously, the nearest taxi driver to the rider who lives on the 3 coordinate is the first one, and to the rider who lives on the coordinate 5 is the second one. The rider who lives on the 4 coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.

In the third example, we have one rider and the taxi driver nearest to him is the fourth one.
Program:
```
from __future__ import print_function
from sys import stdin

def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    (n, m) = rints()
    (a, t, mem, ans) = (rints(), rints(), [], [0] * m)
    for i in range(n + m - 1, -1, -1):
        if t[i]:
            mem.append(a[i])
    (cur, l) = (mem.pop(), 0)
    for i in range(n + m):
        if not t[i]:
            while mem:
                if abs(cur - a[i]) > abs(mem[-1] - a[i]):
                    cur = mem.pop()
                    l += 1
                else:
                    break
            ans[l] += 1
    print(' '.join(map(str, ans)))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
