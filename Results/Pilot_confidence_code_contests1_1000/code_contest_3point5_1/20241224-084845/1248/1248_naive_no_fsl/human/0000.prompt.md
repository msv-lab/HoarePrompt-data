
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: A and B are preparing themselves for programming contests.

To train their logical thinking and solve problems better, A and B decided to play chess. During the game A wondered whose position is now stronger.

For each chess piece we know its weight: 

  * the queen's weight is 9, 
  * the rook's weight is 5, 
  * the bishop's weight is 3, 
  * the knight's weight is 3, 
  * the pawn's weight is 1, 
  * the king's weight isn't considered in evaluating position. 



The player's weight equals to the sum of weights of all his pieces on the board.

As A doesn't like counting, he asked you to help him determine which player has the larger position weight.

Input

The input contains eight lines, eight characters each — the board's description.

The white pieces on the board are marked with uppercase letters, the black pieces are marked with lowercase letters.

The white pieces are denoted as follows: the queen is represented is 'Q', the rook — as 'R', the bishop — as'B', the knight — as 'N', the pawn — as 'P', the king — as 'K'.

The black pieces are denoted as 'q', 'r', 'b', 'n', 'p', 'k', respectively.

An empty square of the board is marked as '.' (a dot). 

It is not guaranteed that the given chess position can be achieved in a real game. Specifically, there can be an arbitrary (possibly zero) number pieces of each type, the king may be under attack and so on.

Output

Print "White" (without quotes) if the weight of the position of the white pieces is more than the weight of the position of the black pieces, print "Black" if the weight of the black pieces is more than the weight of the white pieces and print "Draw" if the weights of the white and black pieces are equal.

Examples

Input

...QK...
........
........
........
........
........
........
...rk...


Output

White


Input

rnbqkbnr
pppppppp
........
........
........
........
PPPPPPPP
RNBQKBNR


Output

Draw


Input

rppppppr
...k....
........
........
........
........
K...Q...
........


Output

Black

Note

In the first test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals 5.

In the second test sample the weights of the positions of the black and the white pieces are equal to 39.

In the third test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals to 16.
Program:
```
def func_1(data):
    item = []
    for i in range(len(data)):
        if data[i] != '.':
            item.append(data[i])
    p1 = 0
    p2 = 0
    (q, Q) = 9
    (r, R) = 5
    (b, B) = 3
    (p, P) = 1
    dictb = {'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1}
    dictw = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1}
    lb = [q, r, b, n, p]
    lw = [Q, R, B, N, P]
    for i in range(len(item)):
        for j in range(len(lb)):
            if data[i] == lb[j]:
                p1 = p1 + dictb[lb[j]]
            if data[i] == lw[j]:
                p1 = p1 + dictw[lw[j]]
    if p1 < p2:
        return Black
    elif p1 > p2:
        return White
    else:
        return Draw


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
