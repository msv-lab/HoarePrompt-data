
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You may know that Euclid was a mathematician. Well, as it turns out, Morpheus knew it too. So when he wanted to play a mean trick on Euclid, he sent him an appropriate nightmare. 

In his bad dream Euclid has a set S of n m-dimensional vectors over the Z_2 field and can perform vector addition on them. In other words he has vectors with m coordinates, each one equal either 0 or 1. Vector addition is defined as follows: let u+v = w, then w_i = (u_i + v_i) mod 2. 

Euclid can sum any subset of S and archive another m-dimensional vector over Z_2. In particular, he can sum together an empty subset; in such a case, the resulting vector has all coordinates equal 0.

Let T be the set of all the vectors that can be written as a sum of some vectors from S. Now Euclid wonders the size of T and whether he can use only a subset S' of S to obtain all the vectors from T. As it is usually the case in such scenarios, he will not wake up until he figures this out. So far, things are looking rather grim for the philosopher. But there is hope, as he noticed that all vectors in S have at most 2 coordinates equal 1. 

Help Euclid and calculate |T|, the number of m-dimensional vectors over Z_2 that can be written as a sum of some vectors from S. As it can be quite large, calculate it modulo 10^9+7. You should also find S', the smallest such subset of S, that all vectors in T can be written as a sum of vectors from S'. In case there are multiple such sets with a minimal number of elements, output the lexicographically smallest one with respect to the order in which their elements are given in the input. 

Consider sets A and B such that |A| = |B|. Let a_1, a_2, ... a_{|A|} and b_1, b_2, ... b_{|B|} be increasing arrays of indices elements of A and B correspondingly. A is lexicographically smaller than B iff there exists such i that a_j = b_j for all j < i and a_i < b_i.

Input

In the first line of input, there are two integers n, m (1 ≤ n, m ≤ 5 ⋅ 10^5) denoting the number of vectors in S and the number of dimensions. 

Next n lines contain the description of the vectors in S. In each of them there is an integer k (1 ≤ k ≤ 2) and then follow k distinct integers x_1, ... x_k (1 ≤ x_i ≤ m). This encodes an m-dimensional vector having 1s on coordinates x_1, ... x_k and 0s on the rest of them.

Among the n vectors, no two are the same.

Output

In the first line, output two integers: remainder modulo 10^9+7 of |T| and |S'|. In the second line, output |S'| numbers, indices of the elements of S' in ascending order. The elements of S are numbered from 1 in the order they are given in the input.

Examples

Input


3 2
1 1
1 2
2 2 1


Output


4 2
1 2 


Input


2 3
2 1 3
2 1 2


Output


4 2
1 2 


Input


3 5
2 1 2
1 3
1 4


Output


8 3
1 2 3 

Note

In the first example we are given three vectors: 

  * 10 
  * 01 
  * 11 



It turns out that we can represent all vectors from our 2-dimensional space using these vectors: 

  * 00 is a sum of the empty subset of above vectors; 
  * 01 = 11 + 10, is a sum of the first and third vector; 
  * 10 = 10, is just the first vector; 
  * 11 = 10 + 01, is a sum of the first and the second vector. 



Hence, T = \{00, 01, 10, 11\}. We can choose any two of the three vectors from S and still be able to obtain all the vectors in T. In such a case, we choose the two vectors which appear first in the input. Since we cannot obtain all vectors in T using only a single vector from S, |S'| = 2 and S' = \{10, 01\} (indices 1 and 2), as set \{1, 2 \} is lexicographically the smallest. We can represent all vectors from T, using only vectors from S', as shown below: 

  * 00 is a sum of the empty subset; 
  * 01 = 01 is just the second vector; 
  * 10 = 10 is just the first vector; 
  * 11 = 10 + 01 is a sum of the first and the second vector. 
Program:
```
import io
import os
from collections import Counter, defaultdict, deque

MOD = 10 ** 9 + 7
class UnionFind:

    def __init__(self, N):
        self.p = [-1 for i in range(N)]

    def find(self, i):
        if self.p[i] >= 0:
            self.p[i] = self.find(self.p[i])
            return self.p[i]
        else:
            return i

    def union(self, i, j):
        root1 = self.find(j)
        root2 = self.find(i)
        if root1 == root2:
            return
        size1 = -self.p[root1]
        size2 = -self.p[root2]
        if size1 < size2:
            self.p[root1] = root2
            self.p[root2] = -(size1 + size2)
        else:
            self.p[root2] = root1
            self.p[root1] = -(size1 + size2)

    def getComponentSize(self, i):
        return -self.p[self.find(i)]
if __name__ == '__main__':
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
    TC = 1
    for tc in range(1, TC + 1):
        (N, M) = [int(x) for x in input().split()]
        vectors = [[int(x) - 1 for x in input().split()][1:] for i in range(N)]
        ans = func_1(N, M, vectors)
        print(ans)

def func_1(N, M, vectors):
    uf = UnionFind(M)
    allCoords = set()
    single = set()
    for (i, v) in enumerate(vectors):
        allCoords.update(v)
        if len(v) == 1:
            (a,) = v
            single.add(a)
        else:
            (a, b) = v
            uf.union(a, b)
    trees = defaultdict(list)
    for x in allCoords:
        if uf.getComponentSize(x) > 1:
            trees[uf.find(x)].append(x)
    T = 1
    treeCoords = set()
    for coords in trees.values():
        for x in coords:
            if x in single:
                break
        else:
            treeCoords.update(coords)
            T *= pow(2, len(coords) - 1, MOD)
            T %= MOD
    T *= pow(2, len(allCoords) - len(treeCoords), MOD)
    T %= MOD
    uf = UnionFind(M)
    ans = []
    seen = set()
    for (i, v) in enumerate(vectors):
        if len(v) == 1:
            (a,) = v
            if a not in seen and a not in treeCoords:
                seen.add(a)
                ans.append(i)
        else:
            assert len(v) == 2
            (a, b) = v
            if a in treeCoords:
                assert b in treeCoords
                if uf.find(a) != uf.find(b):
                    uf.union(a, b)
                    ans.append(i)
            elif a not in seen or b not in seen:
                seen.add(a)
                seen.add(b)
                ans.append(i)
    return str(T) + ' ' + str(len(ans)) + '\n' + ' '.join((str(i + 1) for i in ans))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
