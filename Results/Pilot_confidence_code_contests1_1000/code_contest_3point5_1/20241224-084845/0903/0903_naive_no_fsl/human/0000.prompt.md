
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. 

As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.

A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node v is the last different from v vertex on the path from the root to the vertex v. Children of vertex v are all nodes for which v is the parent. A vertex is a leaf if it has no children.

The rooted tree Serval owns has n nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. 

Assume that there are k leaves in the tree. Serval wants to put integers 1, 2, …, k to the k leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?

Input

The first line contains an integer n (2 ≤ n ≤ 3⋅ 10^5), the size of the tree.

The second line contains n integers, the i-th of them represents the operation in the node i. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it.

The third line contains n-1 integers f_2, f_3, …, f_n (1 ≤ f_i ≤ i-1), where f_i represents the parent of the node i.

Output

Output one integer — the maximum possible number in the root of the tree.

Examples

Input


6
1 0 1 1 0 1
1 2 2 2 2


Output


1


Input


5
1 0 1 0 1
1 1 1 1


Output


4


Input


8
1 0 0 1 0 1 1 0
1 1 2 2 3 3 3


Output


4


Input


9
1 1 0 0 1 0 1 0 1
1 1 2 2 3 3 4 4


Output


5

Note

Pictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes.

In the first example, no matter how you arrange the numbers, the answer is 1.

<image>

In the second example, no matter how you arrange the numbers, the answer is 4.

<image>

In the third example, one of the best solution to achieve 4 is to arrange 4 and 5 to nodes 4 and 5.

<image>

In the fourth example, the best solution is to arrange 5 to node 5.

<image>
Program:
```
import math
import sys
import heapq
from collections import defaultdict
from collections import deque
from sys import stdin, stdout

sys.setrecursionlimit(1 << 29)
N = func_2()
op = [0] + func_1()
pa = [0, 0] + func_1()
G = defaultdict(list)
for i in range(2, N + 1):
    p = pa[i]
    G[p].append(i)
nleaf = [0] * (N + 1)
for i in range(N, 0, -1):
    if len(G[i]) == 0:
        nleaf[i] = 1
        continue
    for j in G[i]:
        nleaf[i] += nleaf[j]
memo = {}
for i in range(N, 0, -1):
    func_4(i)
res = func_4(1)
print(res)

def func_1():
    return [int(x) for x in stdin.readline().split()]

def func_2():
    return int(stdin.readline())

def func_3():
    return stdin.readline().strip()

def func_4(root):
    global memo
    if len(G[root]) == 0:
        return 1
    if root in memo:
        return memo[root]
    res = 0
    if op[root] == 0:
        for v in G[root]:
            res = max(res, func_4(v))
    else:
        nl = nleaf[root]
        for v in G[root]:
            nlv = nleaf[v]
            res = max(res, nl - (nlv - func_4(v)))
    memo[root] = res
    return memo[root]


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
