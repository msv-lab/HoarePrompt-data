
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Fox Ciel is playing a mobile puzzle game called "Two Dots". The basic levels are played on a board of size n × m cells, like this:

<image>

Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.

The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition:

  1. These k dots are different: if i ≠ j then di is different from dj. 
  2. k is at least 4. 
  3. All dots belong to the same color. 
  4. For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge. 



Determine if there exists a cycle on the field.

Input

The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.

Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.

Output

Output "Yes" if there exists a cycle, and "No" otherwise.

Examples

Input

3 4
AAAA
ABCA
AAAA


Output

Yes


Input

3 4
AAAA
ABCA
AADA


Output

No


Input

4 4
YYYR
BYBY
BBBY
BBBY


Output

Yes


Input

7 6
AAAAAB
ABBBAB
ABAAAB
ABABBB
ABAAAB
ABBBAB
AAAAAB


Output

Yes


Input

2 13
ABCDEFGHIJKLM
NOPQRSTUVWXYZ


Output

No

Note

In first sample test all 'A' form a cycle.

In second sample there is no such cycle.

The third sample is displayed on the picture above ('Y' = Yellow, 'B' = Blue, 'R' = Red).
Program:
```
(n, m) = map(int, raw_input().split())
l = [raw_input() for i in xrange(n)]
res = False
row = 0
while row < n and (not res):
    for column in xrange(m):
        conj = set()
        tmp = func_1(True, l[row][column], l, row, column, n, m, row, column, row, column, conj)
        if tmp:
            res = True
            break
    row += 1
if res:
    print('Yes')
else:
    print('No')

def func_1(first, let, l, x, y, n, m, xInit, yInit, xAnt, yAnt, conj):
    if not (x >= 0 and x < n and (y >= 0) and (y < m)) or (x, y) in conj:
        return False
    if x == xInit and y == yInit and (len(conj) > 3):
        return True
    if l[x][y] == let:
        if not first:
            conj.add((x, y))
        cima = False
        if y - 1 != yAnt:
            cima = func_1(False, let, l, x, y - 1, n, m, xInit, yInit, x, y, conj)
        direita = False
        if x + 1 != xAnt:
            direita = func_1(False, let, l, x + 1, y, n, m, xInit, yInit, x, y, conj)
        baixo = False
        if y + 1 != yAnt:
            baixo = func_1(False, let, l, x, y + 1, n, m, xInit, yInit, x, y, conj)
        esquerda = False
        if x - 1 != xAnt:
            esquerda = func_1(False, let, l, x - 1, y, n, m, xInit, yInit, x, y, conj)
        return cima or baixo or direita or esquerda
    else:
        return False


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
