
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.

You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 

It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.

Your task is to count what number of teams from the given list shared the k-th place. 

Input

The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 

Output

In the only line print the sought number of teams that got the k-th place in the final results' table.

Examples

Input

7 2
4 10
4 10
4 10
3 20
2 1
2 1
1 10


Output

3


Input

5 4
3 1
3 1
5 3
3 1
3 1


Output

4

Note

The final results' table for the first sample is: 

  * 1-3 places — 4 solved problems, the penalty time equals 10 
  * 4 place — 3 solved problems, the penalty time equals 20 
  * 5-6 places — 2 solved problems, the penalty time equals 1 
  * 7 place — 1 solved problem, the penalty time equals 10 



The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.

The final table for the second sample is:

  * 1 place — 5 solved problems, the penalty time equals 3 
  * 2-5 places — 3 solved problems, the penalty time equals 1 



The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
Program:
```
import sys
from math import *

def func():
    try:
        fi = open('input.txt', 'r')
        fo = open('output.txt', 'w')
    except:
        fi = sys.stdin
        fo = sys.stdout
    (n, k) = map(int, fi.readline().split())
    a = [0 for i in range(n)]
    b = [0 for i in range(n)]
    for i in range(n):
        (a[i], b[i]) = map(int, fi.readline().split())
    for i in range(n - 1):
        for j in range(n - i - 1):
            if (a[j] < a[j + 1]) | (a[j] == a[j + 1]) & (b[j] > b[j + 1]):
                x = a[j]
                a[j] = a[j + 1]
                a[j + 1] = x
                x = b[j]
                b[j] = b[j + 1]
                b[j + 1] = x
    ans = 0
    for i in range(n):
        ans += (a[i] == a[k - 1]) & (b[i] == b[k - 1])
    fo.write(str(ans))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
