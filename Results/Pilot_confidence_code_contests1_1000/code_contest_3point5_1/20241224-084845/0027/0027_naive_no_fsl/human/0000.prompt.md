
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet — the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations: 

  * alloc n — to allocate n bytes of the memory and return the allocated block's identifier x; 
  * erase x — to erase the block with the identifier x; 
  * defragment — to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; 



The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.

The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.

The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.

The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.

In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.

You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.

Input

The first line of the input data contains two positive integers t and m (1 ≤ t ≤ 100;1 ≤ m ≤ 100), where t — the amount of operations given to the memory manager for processing, and m — the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1 ≤ n ≤ 100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. 

Output

Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.

Examples

Input

6 10
alloc 5
alloc 3
erase 1
alloc 6
defragment
alloc 6


Output

1
2
NULL
3
Program:
```
from sys import stdin

(t, m) = func_1(stdin.readline())
mem = [0 for i in range(m + 2)]
next_id = 1
for i in range(t):
    xs = stdin.readline().split()
    if xs[0] == 'alloc':
        func_2(int(xs[1]))
    elif xs[0] == 'erase':
        func_3(int(xs[1]))
    elif xs[0] == 'defragment':
        func_4()
    else:
        while True:
            pass

def func_1(s):
    return [int(x) for x in s.split()]

def func_2(size):
    global mem
    global next_id
    i = 1
    while i <= m:
        if mem[i] == 0:
            j = i + 1
            while j < i + size and j <= m and (mem[j] == 0):
                j += 1
            if j - i == size:
                for k in range(i, j):
                    mem[k] = next_id
                print(next_id)
                next_id += 1
                return
            i = j + 1
        else:
            i += 1
    print('NULL')

def func_3(x):
    global mem
    mem[m + 1] = x
    i = mem.index(x)
    mem[m + 1] = 0
    if i == m + 1 or x == 0:
        print('ILLEGAL_ERASE_ARGUMENT')
        return
    while i <= m and mem[i] == x:
        mem[i] = 0
        i += 1

def func_4():
    global mem
    mem = [0] + [x for x in mem if x != 0]
    k = m + 2 - len(mem)
    mem = mem + [0 for x in range(k)]
    assert len(mem) == m + 2


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
