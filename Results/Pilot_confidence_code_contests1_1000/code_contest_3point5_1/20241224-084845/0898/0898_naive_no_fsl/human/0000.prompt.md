
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Notice: unusual memory limit!

After the war, destroyed cities in the neutral zone were restored. And children went back to school.

The war changed the world, as well as education. In those hard days, a new math concept was created.

As we all know, logarithm function can be described as: $$$ log(p_1^{a_1}p_2^{a_2}...p_k^{a_2}) = a_1 log p_1 + a_2 log p_2 + ... + a_k log p_k  Where p_1^{a_1}p_2^{a_2}...p_k^{a_2}$$$ is the prime factorization of a integer. A problem is that the function uses itself in the definition. That is why it is hard to calculate.

So, the mathematicians from the neutral zone invented this: $$$ exlog_f(p_1^{a_1}p_2^{a_2}...p_k^{a_2}) = a_1 f(p_1) + a_2 f(p_2) + ... + a_k f(p_k) $$$

Notice that exlog_f(1) is always equal to 0.

This concept for any function f was too hard for children. So teachers told them that f can only be a polynomial of degree no more than 3 in daily uses (i.e., f(x) = Ax^3+Bx^2+Cx+D).

"Class is over! Don't forget to do your homework!" Here it is: $$$ ∑_{i=1}^n exlog_f(i) $$$

Help children to do their homework. Since the value can be very big, you need to find the answer modulo 2^{32}.

Input

The only line contains five integers n, A, B, C, and D (1 ≤ n ≤ 3 ⋅ 10^8, 0 ≤ A,B,C,D ≤ 10^6).

Output

Print the answer modulo 2^{32}.

Examples

Input

12 0 0 1 0


Output

63


Input

4 1 2 3 4


Output

136

Note

In the first sample:

exlog_f(1) = 0

exlog_f(2) = 2

exlog_f(3) = 3

exlog_f(4) = 2 + 2 = 4

exlog_f(5) = 5

exlog_f(6) = 2 + 3 = 5

exlog_f(7) = 7

exlog_f(8) = 2 + 2 + 2 = 6

exlog_f(9) = 3 + 3 = 6

exlog_f(10) = 2 + 5 = 7

exlog_f(11) = 11

exlog_f(12) = 2 + 2 + 3 = 7

 ∑_{i=1}^{12} exlog_f(i)=63 

In the second sample:

exlog_f(1) = 0

exlog_f(2) = (1 × 2^3 + 2 × 2^2 + 3 × 2 + 4) = 26

exlog_f(3) = (1 × 3^3 + 2 × 3^2 + 3 × 3 + 4) = 58

exlog_f(4) = 2 × exlog_f(2) = 52

 ∑_{i=1}^4 exlog_f(i)=0+26+58+52=136 
Program:
```
from __future__ import division, print_function
from math import trunc
import _numpypy.multiarray as np

input = raw_input
MOD = 1 << 32
MODF = float(MOD)
MAGIC = 6755399441055744.0
SHRT = 65536.0
MODF_INV = 1.0 / MODF
SHRT_INV = 1.0 / SHRT
fround = lambda x: x + MAGIC - MAGIC
fmod = lambda a: a - MODF * fround(MODF_INV * a)
fmul = lambda a, b, c=0.0: fmod(fmod(a * SHRT) * fround(SHRT_INV * b) + a * (b - SHRT * fround(b * SHRT_INV)) + c)
if __name__ == '__main__':
    func_1()

def func_1():
    (n, a, b, c, d) = map(int, input().split())
    aa = 1.0 * a
    bb = 1.0 * b
    cc = 1.0 * c
    dd = 1.0 * d
    nn = 1.0 * n

    cnt = prime_contribution(2) + prime_contribution(3)
    sieve = bytearray(12500000)
    (i, t) = (5, 2)
    while i <= n:
        if not sieve[i // 3 >> 3] >> (i // 3 & 7) & 1:
            cnt = fmod(cnt + prime_contribution(i))
            if i > (n + i - 1) // i:
                i += t
                t = 6 - t
                continue
            j = i * i
            v = t
            while j <= n:
                sieve[j // 3 >> 3] |= 1 << (j // 3 & 7)
                j += v * i
                v = 6 - v
        i += t
        t = 6 - t
    print(int(cnt) if cnt >= 0.0 else 4294967296 + int(cnt))

def prime_contribution(i):
    ii = 1.0 * i
    f = fmul(ii, fmul(ii, fmul(ii, aa, bb), cc), dd)
    ii_inv = 1.0 / ii
    res = 0.0
    numb = trunc(nn * ii_inv)
    while numb:
        res += numb
        numb = trunc(numb * ii_inv)
    return fmul(f, fmod(res))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
