
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Valera came to Japan and bought many robots for his research. He's already at the airport, the plane will fly very soon and Valera urgently needs to bring all robots to the luggage compartment.

The robots are self-propelled (they can potentially move on their own), some of them even have compartments to carry other robots. More precisely, for the i-th robot we know value ci — the number of robots it can carry. In this case, each of ci transported robots can additionally carry other robots.

However, the robots need to be filled with fuel to go, so Valera spent all his last money and bought S liters of fuel. He learned that each robot has a restriction on travel distances. Thus, in addition to features ci, the i-th robot has two features fi and li — the amount of fuel (in liters) needed to move the i-th robot, and the maximum distance that the robot can go.

Due to the limited amount of time and fuel, Valera wants to move the maximum number of robots to the luggage compartment. He operates as follows. 

  * First Valera selects some robots that will travel to the luggage compartment on their own. In this case the total amount of fuel required to move all these robots must not exceed S. 
  * Then Valera seats the robots into the compartments, so as to transport as many robots as possible. Note that if a robot doesn't move by itself, you can put it in another not moving robot that is moved directly or indirectly by a moving robot. 
  * After that all selected and seated robots along with Valera go to the luggage compartment and the rest robots will be lost. 



There are d meters to the luggage compartment. Therefore, the robots that will carry the rest, must have feature li of not less than d. During the moving Valera cannot stop or change the location of the robots in any way.

Help Valera calculate the maximum number of robots that he will be able to take home, and the minimum amount of fuel he will have to spend, because the remaining fuel will come in handy in Valera's research.

Input

The first line contains three space-separated integers n, d, S (1 ≤ n ≤ 105, 1 ≤ d, S ≤ 109). The first number represents the number of robots, the second one — the distance to the luggage compartment and the third one — the amount of available fuel.

Next n lines specify the robots. The i-th line contains three space-separated integers ci, fi, li (0 ≤ ci, fi, li ≤ 109) — the i-th robot's features. The first number is the number of robots the i-th robot can carry, the second number is the amount of fuel needed for the i-th robot to move and the third one shows the maximum distance the i-th robot can go.

Output

Print two space-separated integers — the maximum number of robots Valera can transport to the luggage compartment and the minimum amount of fuel he will need for that. If Valera won't manage to get any robots to the luggage compartment, print two zeroes.

Examples

Input

3 10 10
0 12 10
1 6 10
0 1 1


Output

2 6


Input

2 7 10
3 12 10
5 16 8


Output

0 0


Input

4 8 10
0 12 3
1 1 0
0 3 11
1 6 9


Output

4 9
Program:
```
from __future__ import print_function

func_1()

def func_1():
    inp = raw_input().split(' ')
    N = int(inp[0])
    D = int(inp[1])
    S = int(inp[2])
    a = []
    au = []
    for i in range(N):
        inp = raw_input().split(' ')
        a.append([int(inp[0]), int(inp[1]), int(inp[2]), False])
        if int(inp[2]) >= D:
            au.append((float(inp[1]), float(inp[0]), i))

    au.sort(__less)
    m = 0
    s = S
    res = 0
    for i in au:
        if a[i[2]][1] <= s:
            s -= a[i[2]][1]
            a[i[2]][3] = True
            m += a[i[2]][0]
            res += 1
    b = [i[0] for i in a if not i[3]]
    b.sort(reverse=True)
    for i in b:
        if m <= 0:
            break
        else:
            m += i - 1
            res += 1
    if res == 0:
        print('0 0')
    else:
        print(res, S - s)

def __less(a, b):
    if a[0] == 0:
        return -1
    elif b[0] == 0:
        return 1
    else:
        return -cmp(a[1] / a[0], b[1] / b[0])


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
