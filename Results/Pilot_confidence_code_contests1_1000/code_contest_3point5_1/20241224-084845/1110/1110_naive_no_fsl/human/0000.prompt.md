
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given a sequence of n digits d_1d_2 ... d_{n}. You need to paint all the digits in two colors so that:

  * each digit is painted either in the color 1 or in the color 2; 
  * if you write in a row from left to right all the digits painted in the color 1, and then after them all the digits painted in the color 2, then the resulting sequence of n digits will be non-decreasing (that is, each next digit will be greater than or equal to the previous digit). 



For example, for the sequence d=914 the only valid coloring is 211 (paint in the color 1 two last digits, paint in the color 2 the first digit). But 122 is not a valid coloring (9 concatenated with 14 is not a non-decreasing sequence).

It is allowed that either of the two colors is not used at all. Digits painted in the same color are not required to have consecutive positions.

Find any of the valid ways to paint the given sequence of digits or determine that it is impossible to do.

Input

The first line contains a single integer t (1 ≤ t ≤ 10000) — the number of test cases in the input.

The first line of each test case contains an integer n (1 ≤ n ≤ 2⋅10^5) — the length of a given sequence of digits.

The next line contains a sequence of n digits d_1d_2 ... d_{n} (0 ≤ d_i ≤ 9). The digits are written in a row without spaces or any other separators. The sequence can start with 0.

It is guaranteed that the sum of the values ​​of n for all test cases in the input does not exceed 2⋅10^5.

Output

Print t lines — the answers to each of the test cases in the input.

If there is a solution for a test case, the corresponding output line should contain any of the valid colorings written as a string of n digits t_1t_2 ... t_n (1 ≤ t_i ≤ 2), where t_i is the color the i-th digit is painted in. If there are several feasible solutions, print any of them.

If there is no solution, then the corresponding output line should contain a single character '-' (the minus sign).

Example

Input


5
12
040425524644
1
0
9
123456789
2
98
3
987


Output


121212211211
1
222222222
21
-

Note

In the first test case, d=040425524644. The output t=121212211211 is correct because 0022444 (painted in 1) concatenated with 44556 (painted in 2) is 002244444556 which is a sorted sequence of n given digits.
Program:
```
from __future__ import print_function
from collections import Counter, OrderedDict
from itertools import permutations as perm
from collections import deque
from sys import stdin
from bisect import *
from heapq import *
import math

def func():
    g = lambda : stdin.readline().strip()
    gl = lambda : g().split()
    gil = lambda : [int(var) for var in gl()]
    gfl = lambda : [float(var) for var in gl()]
    gcl = lambda : list(g())
    gbs = lambda : [int(var) for var in g()]
    mod = int(1000000000.0) + 7
    inf = float('inf')
    (t,) = gil()
    for _ in range(t):
        (n,) = gil()
        val = gbs()
        idx = list(xrange(n))
        idx.sort(key=lambda x: [val[x], x])
        one = []
        to = []
        for ix in idx:
            if ix > (one[-1] if one else -1) and val[ix] <= (val[to[0]] if to else inf):
                one.append(ix)
            elif ix > (to[-1] if to else -1):
                to.append(ix)
            else:
                break
        if len(one) + len(to) == n:
            for ix in one:
                val[ix] = 1
            for ix in to:
                val[ix] = 2
            for v in val:
                print(v, end='')
            print()
        else:
            print('-')


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
