
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: In Arcady's garden there grows a peculiar apple-tree that fruits one time per year. Its peculiarity can be explained in following way: there are n inflorescences, numbered from 1 to n. Inflorescence number 1 is situated near base of tree and any other inflorescence with number i (i > 1) is situated at the top of branch, which bottom is pi-th inflorescence and pi < i.

Once tree starts fruiting, there appears exactly one apple in each inflorescence. The same moment as apples appear, they start to roll down along branches to the very base of tree. Each second all apples, except ones in first inflorescence simultaneously roll down one branch closer to tree base, e.g. apple in a-th inflorescence gets to pa-th inflorescence. Apples that end up in first inflorescence are gathered by Arcady in exactly the same moment. Second peculiarity of this tree is that once two apples are in same inflorescence they annihilate. This happens with each pair of apples, e.g. if there are 5 apples in same inflorescence in same time, only one will not be annihilated and if there are 8 apples, all apples will be annihilated. Thus, there can be no more than one apple in each inflorescence in each moment of time.

Help Arcady with counting number of apples he will be able to collect from first inflorescence during one harvest.

Input

First line of input contains single integer number n (2 ≤ n ≤ 100 000) — number of inflorescences.

Second line of input contains sequence of n - 1 integer numbers p2, p3, ..., pn (1 ≤ pi < i), where pi is number of inflorescence into which the apple from i-th inflorescence rolls down.

Output

Single line of output should contain one integer number: amount of apples that Arcady will be able to collect from first inflorescence during one harvest.

Examples

Input

3
1 1


Output

1


Input

5
1 2 2 2


Output

3


Input

18
1 1 1 4 4 3 2 2 2 10 8 9 9 9 10 10 4


Output

4

Note

In first example Arcady will be able to collect only one apple, initially situated in 1st inflorescence. In next second apples from 2nd and 3rd inflorescences will roll down and annihilate, and Arcady won't be able to collect them.

In the second example Arcady will be able to collect 3 apples. First one is one initially situated in first inflorescence. In a second apple from 2nd inflorescence will roll down to 1st (Arcady will collect it) and apples from 3rd, 4th, 5th inflorescences will roll down to 2nd. Two of them will annihilate and one not annihilated will roll down from 2-nd inflorescence to 1st one in the next second and Arcady will collect it.
Program:
```
from __future__ import print_function, division
from sys import stdin, stdout
from fractions import gcd
from collections import *
from operator import mul
from functools import reduce
from copy import copy

def func():
    rint = lambda : int(stdin.readline())
    rints = lambda : [int(x) for x in stdin.readline().split()]
    class graph:
    
        def __init__(self, gdict=None):
            if gdict is None:
                gdict = defaultdict(list)
            (self.gdict, self.edges, self.l) = (gdict, defaultdict(int), defaultdict(int))
    
        def addEdge(self, node1, node2, w=None):
            self.gdict[node1].append(node2)
            self.gdict[node2].append(node1)
    
        def subtree(self, v):
            (queue, visit) = (deque([[v, 0]]), [0] * (n + 1))
            (visit[v], level, self.nodes, ans) = (1, [0] * (n + 1), [0] * (n + 1), 0)
            while queue:
                (s, lev) = queue.popleft()
                level[lev] = (level[lev] + 1) % 2
                for i in self.gdict[s]:
                    if not visit[i]:
                        queue.append([i, lev + 1])
                        visit[i] = 1
            print(sum(level))
    (n, a) = (int(input()), rints())
    g = graph()
    for i in range(n - 1):
        g.addEdge(a[i], i + 2)
    g.subtree(1)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
