
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Let’s define a grid to be a set of tiles with 2 rows and 13 columns. Each tile has an English letter written in it. The letters don't have to be unique: there might be two or more tiles with the same letter written on them. Here is an example of a grid:
    
    
    ABCDEFGHIJKLM  
    NOPQRSTUVWXYZ

We say that two tiles are adjacent if they share a side or a corner. In the example grid above, the tile with the letter 'A' is adjacent only to the tiles with letters 'B', 'N', and 'O'. A tile is not adjacent to itself.

A sequence of tiles is called a path if each tile in the sequence is adjacent to the tile which follows it (except for the last tile in the sequence, which of course has no successor). In this example, "ABC" is a path, and so is "KXWIHIJK". "MAB" is not a path because 'M' is not adjacent to 'A'. A single tile can be used more than once by a path (though the tile cannot occupy two consecutive places in the path because no tile is adjacent to itself).

You’re given a string s which consists of 27 upper-case English letters. Each English letter occurs at least once in s. Find a grid that contains a path whose tiles, viewed in the order that the path visits them, form the string s. If there’s no solution, print "Impossible" (without the quotes).

Input

The only line of the input contains the string s, consisting of 27 upper-case English letters. Each English letter occurs at least once in s.

Output

Output two lines, each consisting of 13 upper-case English characters, representing the rows of the grid. If there are multiple solutions, print any of them. If there is no solution print "Impossible".

Examples

Input

ABCDEFGHIJKLMNOPQRSGTUVWXYZ


Output

YXWVUTGHIJKLM
ZABCDEFSRQPON


Input

BUVTYZFQSNRIWOXXGJLKACPEMDH


Output

Impossible
Program:
```
def func():
    s = raw_input()
    x = str()
    tmp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i in range(26):
        if s.count(tmp[i]) == 2:
            x = tmp[i]
            break
    a = s.split(x)
    if a[1] == '':
        print('Impossible')
    elif a[0] == '' and a[2] == '':
        print(x + a[1][:12])
        print(a[1][:-14:-1])
    elif a[0] == '':
        x1 = a[2][:12 - len(a[1]) // 2]
        x2 = a[1][:len(a[1]) // 2]
        x3 = a[2][12 - len(a[1]) // 2:]
        x4 = a[1][len(a[1]) // 2:]
        print(x1[::-1] + x + x2)
        print(x3 + x4[::-1])
    elif a[2] == '':
        a = s[::-1].split(x)
        x1 = a[2][:12 - len(a[1]) // 2]
        x2 = a[1][:len(a[1]) // 2]
        x3 = a[2][12 - len(a[1]) // 2:]
        x4 = a[1][len(a[1]) // 2:]
        print(x1[::-1] + x + x2)
        print(x3 + x4[::-1])
    else:
        a = ['', a[1], a[2] + a[0]]
        x1 = a[2][:12 - len(a[1]) // 2]
        x2 = a[1][:len(a[1]) // 2]
        x3 = a[2][12 - len(a[1]) // 2:]
        x4 = a[1][len(a[1]) // 2:]
        print(x1[::-1] + x + x2)
        print(x3 + x4[::-1])


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
