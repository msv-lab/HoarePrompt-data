
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are n cities and m bidirectional roads in Berland. The i-th road connects the cities x_i and y_i, and has the speed limit s_i. The road network allows everyone to get from any city to any other city. 

The Berland Transport Ministry is planning a road reform.

First of all, maintaining all m roads is too costly, so m - (n - 1) roads will be demolished in such a way that the remaining (n - 1) roads still allow to get to any city from any other city. Formally, the remaining roads should represent an undirected tree.

Secondly, the speed limits on the remaining roads might be changed. The changes will be done sequentially, each change is either increasing the speed limit on some road by 1, or decreasing it by 1. Since changing the speed limit requires a lot of work, the Ministry wants to minimize the number of changes.

The goal of the Ministry is to have a road network of (n - 1) roads with the maximum speed limit over all roads equal to exactly k. They assigned you the task of calculating the minimum number of speed limit changes they have to perform so the road network meets their requirements.

For example, suppose the initial map of Berland looks like that, and k = 7:

<image>

Then one of the optimal courses of action is to demolish the roads 1–4 and 3–4, and then decrease the speed limit on the road 2–3 by 1, so the resulting road network looks like that:

<image>

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first line of each test case contains three integers n, m and k (2 ≤ n ≤ 2 ⋅ 10^5; n - 1 ≤ m ≤ min(2 ⋅ 10^5, (n(n-1))/(2)); 1 ≤ k ≤ 10^9) — the number of cities, the number of roads and the required maximum speed limit, respectively.

Then m lines follow. The i-th line contains three integers x_i, y_i and s_i (1 ≤ x_i, y_i ≤ n; x_i ≠ y_i; 1 ≤ s_i ≤ 10^9) — the cities connected by the i-th road and the speed limit on it, respectively. All roads are bidirectional.

The road network in each test case is connected (that is, it is possible to reach any city from any other city by traveling along the road), and each pair of cities is connected by at most one road.

The sum of n over all test cases does not exceed 2 ⋅ 10^5. Similarly, the sum of m over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print one integer — the minimum number of changes the Ministry has to perform so that the maximum speed limit among the remaining (n - 1) roads is exactly k.

Example

Input


4
4 5 7
4 1 3
1 2 5
2 3 8
2 4 1
3 4 4
4 6 5
1 2 1
1 3 1
1 4 2
2 4 1
4 3 1
3 2 1
3 2 10
1 2 8
1 3 10
5 5 15
1 2 17
3 1 15
2 3 10
1 4 14
2 5 8


Output


1
3
0
0

Note

The explanation for the example test:

The first test case is described in the problem statement.

In the second test case, the road network initially looks like that:

<image>

The Ministry can demolish the roads 1–2, 3–2 and 3–4, and then increase the speed limit on the road 1–4 three times.

In the third test case, the road network already meets all the requirements.

In the fourth test case, it is enough to demolish the road 1–2 so the resulting road network meets the requirements.
Program:
```
from sys import stdin

def func():
    class disjointset:
    
        def __init__(self, n):
            (self.rank, self.parent, self.n, self.nsets) = ([0] * (n + 1), [i for i in range(n + 1)], n, [1] * (n + 1))
    
        def find(self, x):
            xcopy = x
            while x != self.parent[x]:
                x = self.parent[x]
            while xcopy != x:
                (self.parent[xcopy], xcopy) = (x, self.parent[xcopy])
            return x
    
        def union(self, x, y):
            (xpar, ypar) = (self.find(x), self.find(y))
            if xpar == ypar:
                return
            (par, child) = (xpar, ypar)
            if self.rank[xpar] < self.rank[ypar]:
                (par, child) = (ypar, xpar)
            elif self.rank[xpar] == self.rank[ypar]:
                self.rank[xpar] += 1
            self.parent[child] = par
            self.nsets[par] += self.nsets[child]
            self.n -= 1
    
        def kruskal(self, edges):
            (result, all, rem) = (0, [], [])
            for (u, v, w) in edges:
                (upar, vpar) = (self.find(u), self.find(v))
                if upar != vpar:
                    all.append(w)
                    self.union(upar, vpar)
                    result += max(0, w - k)
                else:
                    rem.append(w)
            if all and all[-1] < k:
                try:
                    result += min([abs(i - k) for i in rem])
                except:
                    result += k - all[-1]
            print(result)
    rints = lambda : tuple([int(x) for x in stdin.readline().split()])
    rints_2d = lambda n: [rints() for _ in range(n)]
    out = []
    for _ in range(int(input())):
        (n, m, k) = rints()
        dis = disjointset(n)
        a = sorted(rints_2d(m), key=lambda x: x[-1])
        dis.kruskal(a)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
