Correctness: **False**

Explanation: The program attempts to solve the problem by using a breadth-first search (BFS) to find the shortest path from each room to room 1. However, there is a logical issue in how the BFS is implemented. Specifically, the function `func_1` does not correctly compute the shortest paths or the signposts as required.

Here is a specific case where the program fails:

Consider the following input:
```
4 4
1 2
2 3
3 4
4 2
```

The correct output should be:
```
Yes
1
2
2
```

However, the program outputs:
```
No
```

This happens because the BFS implementation in `func_1` does not correctly handle the case where multiple paths of the same length exist between a room and room 1. In this specific case, both rooms 2 and 3 can reach room 1 in 1 step via room 4, but the program incorrectly sets the signpost for room 3 to point to room 2, which leads to an infinite loop or incorrect path traversal.

To fix this, the BFS should ensure that each room points to the closest (shortest distance) room that leads back to room 1. Here is a corrected version of the BFS part:

```python
from collections import deque

def func_1(graph, start=0):
    n = len(graph)
    dist = [float('inf')] * n
    dist[start] = 0
    q = deque([start])
    parent = [-1] * n
    
    while q:
        u = q.popleft()
        for v in graph[u]:
            if dist[v] > dist[u] + 1:
                dist[v] = dist[u] + 1
                parent[v] = u
                q.append(v)
    
    # Ensure that each room (except room 1) points to the closest room that leads to room 1
    for i in range(n):
        if parent[i] == -1:
            parent[i] = i  # If no valid parent found, set to itself (should not happen due to connectivity constraints)
    
    return parent[1:]

def func_2():
    (n, m) = map(int, input().split())
    graph = [[] for _ in range(n)]
    for _ in range(m):
        (a, b) = map(int, input().split())
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)
    
    post = func_1(graph)
    if -1 in post:
        print("No")
        return
    print("Yes")
    for i in post:
        print(i + 1)
```

With this corrected BFS implementation, the program should now correctly find and print the signposts for each room, ensuring that starting from any room (except room 1) and following the signposts leads to room 1 in the minimum number of steps.