
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters "-".

We'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format "dd-mm-yyyy". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy "0012-10-2012-10-2012" mentions date 12-10-2012 twice (first time as "0012-10-2012-10-2012", second time as "0012-10-2012-10-2012").

The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.

A date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format "dd-mm-yyyy", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date "1-1-2013" isn't recorded in the format "dd-mm-yyyy", and date "01-01-2013" is recorded in it.

Notice, that any year between 2013 and 2015 is not a leap year.

Input

The first line contains the Prophesy: a non-empty string that only consists of digits and characters "-". The length of the Prophesy doesn't exceed 105 characters.

Output

In a single line print the date of the Apocalypse. It is guaranteed that such date exists and is unique.

Examples

Input

777-444---21-12-2013-12-2013-12-2013---444-777


Output

13-12-2013
Program:
```
s = [a for a in raw_input().split('-') if a != '']
yp = ['2014', '2013', '2015']
dates = dict()
for i in range(2, len(s)):
    if s[i][:4] in yp:
        (d, m, y) = (s[i - 2][-2::1], s[i - 1], s[i][:4])
        if len(d) != 2 or len(m) != 2 or len(y) != 4:
            continue
        if func_1(int(m), int(d), int(y)):
            dates[d, m, y] = dates.get((d, m, y), 0) + 1
ma = 0
mb = None
for (a, b) in dates.items():
    if b > ma:
        mb = a
        ma = b
print('-'.join(mb))
a = 0

def func_1(m, d, y):
    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if 0 < m < 13 and 0 < d <= days[m - 1] and (2013 <= y <= 2015):
        return True
    return False


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
