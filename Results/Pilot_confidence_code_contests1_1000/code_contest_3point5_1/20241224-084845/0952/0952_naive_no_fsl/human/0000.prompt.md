
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Ashish has an array a of consisting of 2n positive integers. He wants to compress a into an array b of size n-1. To do this, he first discards exactly 2 (any two) elements from a. He then performs the following operation until there are no elements left in a: 

  * Remove any two elements from a and append their sum to b. 



The compressed array b has to have a special property. The greatest common divisor (gcd) of all its elements should be greater than 1.

Recall that the gcd of an array of positive integers is the biggest integer that is a divisor of all integers in the array.

It can be proven that it is always possible to compress array a into an array b of size n-1 such that gcd(b_1, b_2..., b_{n-1}) > 1. 

Help Ashish find a way to do so.

Input

The first line contains a single integer t (1 ≤ t ≤ 10) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (2 ≤ n ≤ 1000).

The second line of each test case contains 2n integers a_1, a_2, …, a_{2n} (1 ≤ a_i ≤ 1000) — the elements of the array a.

Output

For each test case, output n-1 lines — the operations performed to compress the array a to the array b. The initial discard of the two elements is not an operation, you don't need to output anything about it.

The i-th line should contain two integers, the indices (1 —based) of the two elements from the array a that are used in the i-th operation. All 2n-2 indices should be distinct integers from 1 to 2n.

You don't need to output two initially discarded elements from a.

If there are multiple answers, you can find any.

Example

Input


3
3
1 2 3 4 5 6
2
5 7 9 10
5
1 3 3 4 5 90 100 101 2 3


Output


3 6
4 5
3 4
1 9
2 3
4 5
6 10

Note

In the first test case, b = \{3+6, 4+5\} = \{9, 9\} and gcd(9, 9) = 9.

In the second test case, b = \{9+10\} = \{19\} and gcd(19) = 19.

In the third test case, b = \{1+2, 3+3, 4+5, 90+3\} = \{3, 6, 9, 93\} and gcd(3, 6, 9, 93) = 3.
Program:
```
import math as mt
from collections import Counter, defaultdict

FAST_IO = 1
if FAST_IO:
    import io, sys, atexit
    rr = iter(sys.stdin.read().splitlines()).next
    sys.stdout = _OUTPUT_BUFFER = io.BytesIO()

    @atexit.register
    def write():
        sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
else:
    rr = raw_input
rri = lambda : int(rr())
rrm = lambda : map(int, rr().split())
t = rri()
for _ in range(t):
    n = rri()
    arr = rrm()
    ans = func_1(n, arr)
    for i in range(n - 1):
        print(str(ans[2 * i] + 1) + ' ' + str(ans[2 * i + 1] + 1))

def func_1(N, arr):
    (num_even, num_odd) = (0, 0)
    (even, odd) = ([], [])
    for i in range(N * 2):
        if arr[i] % 2:
            num_odd += 1
            odd.append(i)
        else:
            num_even += 1
            even.append(i)
    if len(even) >= 2 * (N - 1):
        return even[:2 * N - 2]
    else:
        N -= 1
        N -= len(even) / 2
        return even[:len(even) - len(even) % 2] + odd[:2 * N]


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
