
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Student Vladislav came to his programming exam completely unprepared as usual. He got a question about some strange algorithm on a graph — something that will definitely never be useful in real life. He asked a girl sitting next to him to lend him some cheat papers for this questions and found there the following definition:

The minimum spanning tree T of graph G is such a tree that it contains all the vertices of the original graph G, and the sum of the weights of its edges is the minimum possible among all such trees.

Vladislav drew a graph with n vertices and m edges containing no loops and multiple edges. He found one of its minimum spanning trees and then wrote for each edge its weight and whether it is included in the found tree or not. Unfortunately, the piece of paper where the graph was painted is gone and the teacher is getting very angry and demands to see the original graph. Help Vladislav come up with a graph so that the information about the minimum spanning tree remains correct.

Input

The first line of the input contains two integers n and m (<image>) — the number of vertices and the number of edges in the graph.

Each of the next m lines describes an edge of the graph and consists of two integers aj and bj (1 ≤ aj ≤ 109, bj = {0, 1}). The first of these numbers is the weight of the edge and the second number is equal to 1 if this edge was included in the minimum spanning tree found by Vladislav, or 0 if it was not.

It is guaranteed that exactly n - 1 number {bj} are equal to one and exactly m - n + 1 of them are equal to zero.

Output

If Vladislav has made a mistake and such graph doesn't exist, print  - 1.

Otherwise print m lines. On the j-th line print a pair of vertices (uj, vj) (1 ≤ uj, vj ≤ n, uj ≠ vj), that should be connected by the j-th edge. The edges are numbered in the same order as in the input. The graph, determined by these edges, must be connected, contain no loops or multiple edges and its edges with bj = 1 must define the minimum spanning tree. In case there are multiple possible solutions, print any of them.

Examples

Input

4 5
2 1
3 1
4 0
1 1
5 0


Output

2 4
1 4
3 4
3 1
3 2


Input

3 3
1 0
2 1
3 1


Output

-1
Program:
```
from __future__ import division, print_function

if __name__ == '__main__':
    func_2()

def func_1(ifs):
    (n, m) = list(map(int, ifs.readline().split()))
    used = []
    unused = []
    for (i, _) in enumerate(range(m)):
        (a, b) = list(map(int, ifs.readline().split()))
        if b == 1:
            used.append((a, i))
        else:
            unused.append((a, i))
    used.sort()
    unused.sort()
    res = [None] * m
    for (i, (w, pos)) in enumerate(used):
        res[pos] = (i, i + 1)
    ref = 2
    counter = 0
    for (w, pos) in unused:
        if ref >= n:
            print(-1)
            return None
        if w >= used[ref - 1][1]:
            res[pos] = (counter, ref)
            counter += 1
        else:
            print(-1)
            return None
        if counter >= ref - 1:
            ref += 1
            counter = 0
    print('\n'.join(('%d %d' % (u + 1, v + 1) for (u, v) in res)))
    return None

def func_2():
    import sys
    if sys.version_info.major == 3:
        from io import StringIO as StreamIO
    else:
        from io import BytesIO as StreamIO
    with StreamIO(sys.stdin.read()) as ifs, StreamIO() as ofs:
        _stdout = sys.stdout
        sys.stdout = ofs
        func_1(ifs)
        sys.stdout = _stdout
        sys.stdout.write(ofs.getvalue())
    return 0


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
