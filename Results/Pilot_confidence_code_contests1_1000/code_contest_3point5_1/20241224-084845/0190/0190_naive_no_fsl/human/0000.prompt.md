
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Andrewid the Android is a galaxy-famous detective. He is now investigating the case of vandalism at the exhibition of contemporary art.

The main exhibit is a construction of n matryoshka dolls that can be nested one into another. The matryoshka dolls are numbered from 1 to n. A matryoshka with a smaller number can be nested in a matryoshka with a higher number, two matryoshkas can not be directly nested in the same doll, but there may be chain nestings, for example, 1 → 2 → 4 → 5. 

In one second, you can perform one of the two following operations:

  * Having a matryoshka a that isn't nested in any other matryoshka and a matryoshka b, such that b doesn't contain any other matryoshka and is not nested in any other matryoshka, you may put a in b; 
  * Having a matryoshka a directly contained in matryoshka b, such that b is not nested in any other matryoshka, you may get a out of b. 



According to the modern aesthetic norms the matryoshka dolls on display were assembled in a specific configuration, i.e. as several separate chains of nested matryoshkas, but the criminal, following the mysterious plan, took out all the dolls and assembled them into a single large chain (1 → 2 → ... → n). In order to continue the investigation Andrewid needs to know in what minimum time it is possible to perform this action.

Input

The first line contains integers n (1 ≤ n ≤ 105) and k (1 ≤ k ≤ 105) — the number of matryoshkas and matryoshka chains in the initial configuration.

The next k lines contain the descriptions of the chains: the i-th line first contains number mi (1 ≤ mi ≤ n), and then mi numbers ai1, ai2, ..., aimi — the numbers of matryoshkas in the chain (matryoshka ai1 is nested into matryoshka ai2, that is nested into matryoshka ai3, and so on till the matryoshka aimi that isn't nested into any other matryoshka).

It is guaranteed that m1 + m2 + ... + mk = n, the numbers of matryoshkas in all the chains are distinct, in each chain the numbers of matryoshkas follow in the ascending order.

Output

In the single line print the minimum number of seconds needed to assemble one large chain from the initial configuration.

Examples

Input

3 2
2 1 2
1 3


Output

1


Input

7 3
3 1 3 7
2 2 5
2 4 6


Output

10

Note

In the first sample test there are two chains: 1 → 2 and 3. In one second you can nest the first chain into the second one and get 1 → 2 → 3.

In the second sample test you need to disassemble all the three chains into individual matryoshkas in 2 + 1 + 1 = 4 seconds and then assemble one big chain in 6 seconds.
Program:
```
def func():
    """
    n, k = [int(s) for s in raw_input().split()]
    if k == 1:
        print(0)
    else:
        first = [int(s) for s in raw_input().split()]
        i = 2
        while (i < len(first)):
            if first[i] == first[i-1] + 1:
                i += 1
            else:
                break
        ans = len(first) - i
        for j in xrange(k-1):
            inp = [s for s in raw_input().split()]
            ans += int(inp[0]) - 1
        ans += n - 1
        ans -= i - 2
        print (ans)
    """
    (n, k) = [int(s) for s in raw_input().split()]
    ans = 0
    if k == 1:
        print(0)
    else:
        for j in xrange(k):
            inp = [s for s in raw_input().split()]
            if int(inp[1]) == 1:
                i = 2
                while i < int(inp[0]) + 1:
                    if int(inp[i]) == int(inp[i - 1]) + 1:
                        i += 1
                    else:
                        break
                ans += int(inp[0]) - i + 1
            else:
                ans += int(inp[0]) - 1
        ans += n - 1
        ans -= i - 2
        print(ans)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
