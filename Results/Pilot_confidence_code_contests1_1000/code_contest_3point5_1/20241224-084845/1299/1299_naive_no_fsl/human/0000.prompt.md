
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Vladik often travels by trains. He remembered some of his trips especially well and I would like to tell you about one of these trips:

Vladik is at initial train station, and now n people (including Vladik) want to get on the train. They are already lined up in some order, and for each of them the city code ai is known (the code of the city in which they are going to).

Train chief selects some number of disjoint segments of the original sequence of people (covering entire sequence by segments is not necessary). People who are in the same segment will be in the same train carriage. The segments are selected in such way that if at least one person travels to the city x, then all people who are going to city x should be in the same railway carriage. This means that they can’t belong to different segments. Note, that all people who travel to the city x, either go to it and in the same railway carriage, or do not go anywhere at all.

Comfort of a train trip with people on segment from position l to position r is equal to XOR of all distinct codes of cities for people on the segment from position l to position r. XOR operation also known as exclusive OR.

Total comfort of a train trip is equal to sum of comfort for each segment.

Help Vladik to know maximal possible total comfort.

Input

First line contains single integer n (1 ≤ n ≤ 5000) — number of people.

Second line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 5000), where ai denotes code of the city to which i-th person is going.

Output

The output should contain a single integer — maximal possible total comfort.

Examples

Input

6
4 4 2 5 2 3


Output

14


Input

9
5 1 3 1 5 2 4 2 5


Output

9

Note

In the first test case best partition into segments is: [4, 4] [2, 5, 2] [3], answer is calculated as follows: 4 + (2 xor 5) + 3 = 4 + 7 + 3 = 14

In the second test case best partition into segments is: 5 1 [3] 1 5 [2, 4, 2] 5, answer calculated as follows: 3 + (2 xor 4) = 3 + 6 = 9.
Program:
```
def func():
    n = int(raw_input())
    train = list(map(int, raw_input().split()))
    start = [9999] * 5001
    end = [0] * 5001
    for i in range(n):
        elm = train[i]
        start[elm] = min(start[elm], i)
        end[elm] = max(end[elm], i)
    segstart = [(-float('inf'), -1)] * n
    for i in range(n):
        elm = train[i]
        if start[elm] != i:
            continue
        if start[elm] == end[elm]:
            segstart[i] = (elm, i)
            continue
        j = i
        endpoint = end[elm]
        xorval = 0
        while j < endpoint:
            if j == start[train[j]]:
                endpoint = max(endpoint, end[train[j]])
                xorval ^= train[j]
            elif start[train[j]] < i:
                break
            j += 1
        else:
            segstart[i] = (xorval, j)
    dp = [0] * n
    for i in range(n):
        dp[i] = max(dp[i], dp[max(0, i - 1)])
        (xorval, j) = segstart[i]
        if j == -1:
            continue
        dp[j] = max(dp[j], dp[max(0, i - 1)] + xorval)
    print(dp[-1])


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
