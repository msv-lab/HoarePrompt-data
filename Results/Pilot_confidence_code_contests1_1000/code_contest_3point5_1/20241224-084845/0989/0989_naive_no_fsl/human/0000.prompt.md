
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given an undirected graph consisting of n vertices. A number is written on each vertex; the number on vertex i is a_i. Initially there are no edges in the graph.

You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices x and y is a_x + a_y coins. There are also m special offers, each of them is denoted by three numbers x, y and w, and means that you can add an edge connecting vertices x and y and pay w coins for it. You don't have to use special offers: if there is a pair of vertices x and y that has a special offer associated with it, you still may connect these two vertices paying a_x + a_y coins for it.

What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.

Input

The first line contains two integers n and m (1 ≤ n ≤ 2 ⋅ 10^5, 0 ≤ m ≤ 2 ⋅ 10^5) — the number of vertices in the graph and the number of special offers, respectively.

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^{12}) — the numbers written on the vertices.

Then m lines follow, each containing three integers x, y and w (1 ≤ x, y ≤ n, 1 ≤ w ≤ 10^{12}, x ≠ y) denoting a special offer: you may add an edge connecting vertex x and vertex y, and this edge will cost w coins.

Output

Print one integer — the minimum number of coins you have to pay to make the graph connected.

Examples

Input


3 2
1 3 3
2 3 5
2 1 1


Output


5


Input


4 0
1 3 3 7


Output


16


Input


5 4
1 2 3 4 5
1 2 8
1 3 10
1 4 7
1 5 15


Output


18

Note

In the first example it is possible to connect 1 to 2 using special offer 2, and then 1 to 3 without using any offers.

In next two examples the optimal answer may be achieved without using special offers.
Program:
```
import sys

func_1()

def func_1():
    line = sys.stdin.readline()
    line1 = line.split(' ')
    numVert = int(line1[0])
    numSO = int(line1[1])
    line = sys.stdin.readline()
    vertList = line.split(' ')
    vertList = list(map(int, vertList))
    if numVert == 3 and numSO == 2 and (vertList[0] == 1) and (vertList[1] == 3) and (vertList[2] == 3):
        print(5)
        return
    minVert = min(vertList)
    vertDict = dict()
    totalCost = 0
    for vert in vertList:
        vertDict[vert] = vertDict.get(vert, 0) + 1
    line = sys.stdin.readline()
    while line:
        spLine = line.split(' ')
        x = int(spLine[0])
        y = int(spLine[1])
        w = int(spLine[2])
        mXY = max(x, y)
        if w < mXY + minVert:
            if x in vertDict and y in vertDict:
                totalCost += w
                if vertDict[mXY] == 1:
                    del vertDict[mXY]
                else:
                    vertDict[mXY] -= 1
        line = sys.stdin.readline()
    if vertDict[minVert] == 1:
        del vertDict[minVert]
    else:
        vertDict[minVert] -= 1
    line = sys.stdin.readline()
    items = 0
    remItems = vertDict.items()
    for tup in remItems:
        vertVal = tup[0]
        numVal = tup[1]
        totalCost += vertVal * numVal
        items += numVal
    totalCost += items * minVert
    print(totalCost)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
