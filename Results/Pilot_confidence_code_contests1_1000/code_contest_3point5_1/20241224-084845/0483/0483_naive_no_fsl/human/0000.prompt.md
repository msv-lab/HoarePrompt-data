
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Having bought his own apartment, Boris decided to paper the walls in every room. Boris's flat has n rooms, each of which has the form of a rectangular parallelepiped. For every room we known its length, width and height of the walls in meters (different rooms can have different dimensions, including height).

Boris chose m types of wallpaper to paper the walls of the rooms with (but it is not necessary to use all the types). Each type of wallpaper is sold in rolls of a fixed length and width (the length, naturally, shows how long the unfolded roll will be). In addition, for each type we know the price of one roll of this type.

The wallpaper of each type contains strips running along the length of the roll. When gluing the strips must be located strictly vertically (so the roll cannot be rotated, even if the length is less than the width). Besides, a roll can be cut in an arbitrary manner, but the joints of glued pieces should also be vertical. In addition, each room should be papered by only one type of wallpaper. And pieces of the same roll cannot be used to paper different rooms. That is, for each room the rolls are purchased separately. Also, some rolls can be used not completely.

After buying an apartment Boris is short of cash, so he wants to spend the minimum money on wallpaper. Help him.

Input

The first line contains a positive integer n (1 ≤ n ≤ 500) — the number of rooms in Boris's apartment.

Each of the next n lines contains three space-separated positive integers — the length, width and height of the walls in a given room in meters, respectively.

The next line contains a positive integer m (1 ≤ m ≤ 500) — the number of available wallpaper types.

Each of the following m lines contains three space-separated positive integers — the length and width in meters of a given wallpaper and the price of one roll, respectively.

All numbers in the input data do not exceed 500. It is guaranteed that each room can be papered using these types of wallpaper.

Output

Print a single number — the minimum total cost of the rolls.

Examples

Input

1
5 5 3
3
10 1 100
15 2 320
3 19 500


Output

640

Note

Note to the sample:

The total length of the walls (the perimeter) of the room is 20 m.

One roll of the first type can be cut into pieces to get three vertical 1 meter wide strips, ergo you need 7 rolls of this type, the price equals 700.

A roll of the second type can be cut into pieces to get five 2 meter wide strips, we need 2 rolls, the price is 640.

One roll of the third type can immediately paper 19 meters out of 20, but we cannot use other types and we have to buy a second roll, the price is 1000.
Program:
```
import fractions
import sys
import math

P = 'perim'
L = 'length'
W = 'width'
H = 'height'
C = 'cost'
if __name__ == '__main__':
    nr = int(sys.stdin.readline().split()[0])
    rs = []
    for i in range(nr):
        toks = sys.stdin.readline().split()
        rs += [{P: 2 * (int(toks[0]) + int(toks[1])), H: int(toks[2])}]
    nw = int(sys.stdin.readline().split()[0])
    ws = []
    for i in range(nw):
        toks = sys.stdin.readline().split()
        ws += [{L: int(toks[0]), W: int(toks[1]), C: int(toks[2])}]
    print('%d' % func_1(rs, ws))

def func_1(rs, ws):
    rtn = 0
    for r in rs:
        mx = 1000000000
        for w in ws:
            if w[L] < r[P]:
                continue
            wpw = w[L] / r[H] * w[W]
            mx = min(mx, w[C] * ((r[P] + wpw - 1) / wpw))
        rtn += mx
    return mx


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
