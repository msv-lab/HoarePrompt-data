
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You want to perform the combo on your opponent in one popular fighting game. The combo is the string s consisting of n lowercase Latin letters. To perform the combo, you have to press all buttons in the order they appear in s. I.e. if s="abca" then you have to press 'a', then 'b', 'c' and 'a' again.

You know that you will spend m wrong tries to perform the combo and during the i-th try you will make a mistake right after p_i-th button (1 ≤ p_i < n) (i.e. you will press first p_i buttons right and start performing the combo from the beginning). It is guaranteed that during the m+1-th try you press all buttons right and finally perform the combo.

I.e. if s="abca", m=2 and p = [1, 3] then the sequence of pressed buttons will be 'a' (here you're making a mistake and start performing the combo from the beginning), 'a', 'b', 'c', (here you're making a mistake and start performing the combo from the beginning), 'a' (note that at this point you will not perform the combo because of the mistake), 'b', 'c', 'a'.

Your task is to calculate for each button (letter) the number of times you'll press it.

You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Then t test cases follow.

The first line of each test case contains two integers n and m (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ m ≤ 2 ⋅ 10^5) — the length of s and the number of tries correspondingly.

The second line of each test case contains the string s consisting of n lowercase Latin letters.

The third line of each test case contains m integers p_1, p_2, ..., p_m (1 ≤ p_i < n) — the number of characters pressed right during the i-th try.

It is guaranteed that the sum of n and the sum of m both does not exceed 2 ⋅ 10^5 (∑ n ≤ 2 ⋅ 10^5, ∑ m ≤ 2 ⋅ 10^5).

It is guaranteed that the answer for each letter does not exceed 2 ⋅ 10^9.

Output

For each test case, print the answer — 26 integers: the number of times you press the button 'a', the number of times you press the button 'b', ..., the number of times you press the button 'z'.

Example

Input


3
4 2
abca
1 3
10 5
codeforces
2 8 3 2 9
26 10
qwertyuioplkjhgfdsazxcvbnm
20 10 1 2 3 5 10 5 9 4


Output


4 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 9 4 5 3 0 0 0 0 0 0 0 0 9 0 0 3 1 0 0 0 0 0 0 0 
2 1 1 2 9 2 2 2 5 2 2 2 1 1 5 4 11 8 2 7 5 1 10 1 5 2 

Note

The first test case is described in the problem statement. Wrong tries are "a", "abc" and the final try is "abca". The number of times you press 'a' is 4, 'b' is 2 and 'c' is 2.

In the second test case, there are five wrong tries: "co", "codeforc", "cod", "co", "codeforce" and the final try is "codeforces". The number of times you press 'c' is 9, 'd' is 4, 'e' is 5, 'f' is 3, 'o' is 9, 'r' is 3 and 's' is 1.
Program:
```
from collections import defaultdict
import sys, math
from copy import deepcopy

f = None
try:
    f = open('q1.input', 'r')
except IOError:
    f = sys.stdin
if 'xrange' in dir(__builtins__):
    range = xrange
if 'xrange' in dir(__builtins__):
    import cStringIO
    output = cStringIO.StringIO()
if __name__ == '__main__':
    func_10()
"stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* BITS - THINK HOW TO MASK PROPERLY\n\t* PERMUTATIONS - PARITY AND CYCLES\n\t* Think simple, if it becomes over complicated, try to look at it from a different perspective.\n\t* Have fun!!!\n\t* TRY FIXING SOMETHING, and then maybe binary search around it.\n\t* Remember heaps. \n\t* Remember how to add a value to a segment when using prefix sum.\n\t\tsuppose you have an array[1,2,3,4,5] and you want to add 3 to array[1:4]. Then just \n\t\tadd 3 to A[1], and decrease 3 from A[4]. Let's look at what happens:\n\t\toriginal prefixsums is \t\t\t\t\t [1,3,6,10,15]\n\t\tarray -> [1,5,3,4,2] and prefix sums are [1,6,9,13,15] \n\t\tAs you see, exactly +3 in A[1:4]\n\t\t*** The previous method can help checking how many x,y you can choose to get s=x+y from two arrays.\n"
'\nbinary search \n\twhile(r - l > 1) {\n\t\tll mid = l + (r - l) / 2;\n\t\tsolve(mid);\n\t\tll sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += b[i];\n\t\tif (sum <= k)\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n'

def func_1(case_num, iterable):
    print('Case #{}: {}'.format(case_num, ' '.join(map(str, iterable))))

def func_2(case_num, iterable):
    print('Case #{}: {}'.format(case_num, iterable))

def func_3(A):
    print(' '.join(A))

def func_4():
    return int(f.readline().strip())

def func_5():
    return [int(x) for x in f.readline().strip().split(' ')]

def func_6():
    a = [x for x in f.readline().split(' ')]
    return (int(a[0]), a[1].strip())

def func_7():
    return list(f.readline().strip())

def func_8(x):
    return bin(x)[2:]

def func_9(s, n, p, m):
    s = [0] + s
    dp = [[0 for _ in range(26)] for _ in range(n + 1)]
    p.sort()
    for i in range(1, n + 1):
        for j in range(26):
            dp[i][j] = dp[i - 1][j] + int(j == ord(s[i]) - ord('a'))
    res = [x for x in dp[n]]
    for i in range(m):
        x = p[i]
        for j in range(26):
            res[j] += dp[x][j]
    return ' '.join(map(str, res))

def func_10():
    T = func_4()
    for i in range(T):
        (n, m) = func_5()
        s = func_7()
        p = func_5()
        x = func_9(s, n, p, m)
        if 'xrange' not in dir(__builtins__):
            print(x)
        else:
            (print >> output, str(x))
    if 'xrange' in dir(__builtins__):
        print(output.getvalue())
        output.close()


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
