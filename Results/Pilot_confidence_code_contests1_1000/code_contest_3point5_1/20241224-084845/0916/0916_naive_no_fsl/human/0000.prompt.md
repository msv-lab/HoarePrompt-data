
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Twilight Sparkle learnt that the evil Nightmare Moon would return during the upcoming Summer Sun Celebration after one thousand years of imprisonment on the moon. She tried to warn her mentor Princess Celestia, but the princess ignored her and sent her to Ponyville to check on the preparations for the celebration.

<image>

Twilight Sparkle wanted to track the path of Nightmare Moon. Unfortunately, she didn't know the exact path. What she knew is the parity of the number of times that each place Nightmare Moon visited. Can you help Twilight Sparkle to restore any path that is consistent with this information?

Ponyville can be represented as an undirected graph (vertices are places, edges are roads between places) without self-loops and multi-edges. The path can start and end at any place (also it can be empty). Each place can be visited multiple times. The path must not visit more than 4n places.

Input

The first line contains two integers n and m (2 ≤ n ≤ 105; 0 ≤ m ≤ 105) — the number of places and the number of roads in Ponyville. Each of the following m lines contains two integers ui, vi (1 ≤ ui, vi ≤ n; ui ≠ vi), these integers describe a road between places ui and vi.

The next line contains n integers: x1, x2, ..., xn (0 ≤ xi ≤ 1) — the parity of the number of times that each place must be visited. If xi = 0, then the i-th place must be visited even number of times, else it must be visited odd number of times.

Output

Output the number of visited places k in the first line (0 ≤ k ≤ 4n). Then output k integers — the numbers of places in the order of path. If xi = 0, then the i-th place must appear in the path even number of times, else i-th place must appear in the path odd number of times. Note, that given road system has no self-loops, therefore any two neighbouring places in the path must be distinct.

If there is no required path, output -1. If there multiple possible paths, you can output any of them.

Examples

Input

3 2
1 2
2 3
1 1 1


Output

3
1 2 3


Input

5 7
1 2
1 3
1 4
1 5
3 4
3 5
4 5
0 1 0 1 0


Output

10
2 1 3 4 5 4 5 4 3 1 

Input

2 0
0 0


Output

0
Program:
```
(n, m) = raw_input().split()
(n, m) = (int(n), int(m))
graph = {}
for i in range(n):
    graph[i] = []
visited = set()
path = []
for i in range(m):
    (u, v) = raw_input().split()
    (u, v) = (int(u) - 1, int(v) - 1)
    graph[u].append(v)
    graph[v].append(u)
parities = raw_input().split()
for i in range(n):
    parities[i] = int(parities[i])
for i in range(n):
    if parities[i] == 1:
        func_2(i, -1)
        break
for i in range(n):
    if parities[i] == 1:
        print(-1)
print(len(path))
string = ''
for u in path:
    string += str(u + 1) + ' '
print(string)

def func_1(u):
    path.append(u)
    parities[u] ^= 1

def func_2(u, previous):
    visited.add(u)
    func_1(u)
    for v in graph[u]:
        if (v in visited) == False:
            func_2(v, u)
            func_1(u)
    if parities[u] == 1:
        if previous == -1:
            path.pop()
            parities[u] ^= 1
        else:
            func_1(previous)
            func_1(u)
    return visited


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
