
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Vova promised himself that he would never play computer games... But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it.

Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it.

Vova knows that there are n characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; i-th character wants ci gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on.

The quest is finished when all n characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest?

Take a look at the notes if you think you haven't understood the problem completely.

Input

The first line contains two integer numbers n and m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105) — the number of characters in Overcity and the number of pairs of friends.

The second line contains n integer numbers ci (0 ≤ ci ≤ 109) — the amount of gold i-th character asks to start spreading the rumor.

Then m lines follow, each containing a pair of numbers (xi, yi) which represent that characters xi and yi are friends (1 ≤ xi, yi ≤ n, xi ≠ yi). It is guaranteed that each pair is listed at most once.

Output

Print one number — the minimum amount of gold Vova has to spend in order to finish the quest.

Examples

Input

5 2
2 5 3 4 8
1 4
4 5


Output

10


Input

10 0
1 2 3 4 5 6 7 8 9 10


Output

55


Input

10 5
1 6 2 7 3 8 4 9 5 10
1 2
3 4
5 6
7 8
9 10


Output

15

Note

In the first example the best decision is to bribe the first character (he will spread the rumor to fourth character, and the fourth one will spread it to fifth). Also Vova has to bribe the second and the third characters, so they know the rumor.

In the second example Vova has to bribe everyone.

In the third example the optimal decision is to bribe the first, the third, the fifth, the seventh and the ninth characters.
Program:
```
from sys import stdin
from collections import *

def func():
    class graph:
    
        def __init__(self):
            (self.gdict, self.edges, self.l) = (defaultdict(list), defaultdict(int), defaultdict(int))
    
        def addEdge(self, node1, node2, w=None):
            self.gdict[node1].append(node2)
            self.gdict[node2].append(node1)
    
        def dfsUtil(self, v):
            (stack, cost) = ([v], a[v])
            while stack:
                s = stack.pop()
                cost = min(cost, a[s])
                for i1 in self.gdict[s]:
                    if not self.visit[i1]:
                        stack.append(i1)
                        self.visit[i1] = True
            return cost
    
        def dfs(self):
            (self.visit, ans) = ([False] * (n + 1), 0)
            for i in range(n):
                if not self.visit[i]:
                    self.visit[i] = True
                    ans += self.dfsUtil(i)
            print(ans)
    rints = lambda : [int(x) for x in stdin.readline().split()]
    (n, m) = rints()
    (a, g) = (rints(), graph())
    for _ in range(m):
        (u, v) = rints()
        g.addEdge(u - 1, v - 1)
    g.dfs()


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
