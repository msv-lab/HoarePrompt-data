
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Vasya's house is situated in a forest, and there is a mushroom glade near it. The glade consists of two rows, each of which can be divided into n consecutive cells. For each cell Vasya knows how fast the mushrooms grow in this cell (more formally, how many grams of mushrooms grow in this cell each minute). Vasya spends exactly one minute to move to some adjacent cell. Vasya cannot leave the glade. Two cells are considered adjacent if they share a common side. When Vasya enters some cell, he instantly collects all the mushrooms growing there.

Vasya begins his journey in the left upper cell. Every minute Vasya must move to some adjacent cell, he cannot wait for the mushrooms to grow. He wants to visit all the cells exactly once and maximize the total weight of the collected mushrooms. Initially, all mushrooms have a weight of 0. Note that Vasya doesn't need to return to the starting cell.

Help Vasya! Calculate the maximum total weight of mushrooms he can collect.

Input

The first line contains the number n (1 ≤ n ≤ 3·105) — the length of the glade.

The second line contains n numbers a1, a2, ..., an (1 ≤ ai ≤ 106) — the growth rate of mushrooms in the first row of the glade.

The third line contains n numbers b1, b2, ..., bn (1 ≤ bi ≤ 106) is the growth rate of mushrooms in the second row of the glade.

Output

Output one number — the maximum total weight of mushrooms that Vasya can collect by choosing the optimal route. Pay attention that Vasya must visit every cell of the glade exactly once.

Examples

Input

3
1 2 3
6 5 4


Output

70


Input

3
1 1000 10000
10 100 100000


Output

543210

Note

In the first test case, the optimal route is as follows: 

<image> Thus, the collected weight of mushrooms will be 0·1 + 1·2 + 2·3 + 3·4 + 4·5 + 5·6 = 70.

In the second test case, the optimal route is as follows: 

<image> Thus, the collected weight of mushrooms will be 0·1 + 1·10 + 2·100 + 3·1000 + 4·10000 + 5·100000 = 543210.
Program:
```
from __future__ import print_function,division
import sys

def func():
    if sys.version_info < (3, 0):
        range = xrange
    input = sys.stdin.readline
    n = int(input())
    A = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    DP = [0] * 2 * (n + 1)
    roundwina = 0
    t = 1
    sa = 0
    for a in A[1:]:
        roundwina += t * a
        sa += a
        t += 1
    for b in reversed(B[1:]):
        roundwina += t * b
        sa += b
        t += 1
    roundwinb = 0
    sb = 0
    t = 1
    for b in B[1:]:
        roundwinb += t * b
        sb += b
        t += 1
    for a in reversed(A[1:]):
        roundwinb += t * a
        sb += a
        t += 1
    top = True
    best = 0
    win = 0
    i = 0
    for t in range(2 * n):
        if top:
            win += t * A[i]
            endnow = win + roundwina + t * sa
            if t % 2 == 0:
                endnow += (2 * n - 1) * B[i]
        else:
            win += t * B[i]
            endnow = win + roundwinb + t * sb
            if t % 2 == 0:
                endnow += (2 * n - 1) * A[i]
        if t % 2 == 1:
            i += 1
            if i != n:
                roundwina -= sa + (2 * (n - i) - 1) * B[i]
                roundwinb -= sb + (2 * (n - i) - 1) * A[i]
                sa -= A[i] + B[i]
                sb -= A[i] + B[i]
        else:
            top = not top
        best = max(best, endnow)
    best = max(win, best)
    print(best)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
