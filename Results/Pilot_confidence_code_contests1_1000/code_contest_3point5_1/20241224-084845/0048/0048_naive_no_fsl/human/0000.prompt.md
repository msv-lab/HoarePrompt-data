
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: At the big break Nastya came to the school dining room. There are n pupils in the school, numbered from 1 to n. Unfortunately, Nastya came pretty late, so that all pupils had already stood in the queue, i.e. Nastya took the last place in the queue. Of course, it's a little bit sad for Nastya, but she is not going to despond because some pupils in the queue can agree to change places with some other pupils.

Formally, there are some pairs u, v such that if the pupil with number u stands directly in front of the pupil with number v, Nastya can ask them and they will change places. 

Nastya asks you to find the maximal number of places in queue she can move forward. 

Input

The first line contains two integers n and m (1 ≤ n ≤ 3 ⋅ 10^{5}, 0 ≤ m ≤ 5 ⋅ 10^{5}) — the number of pupils in the queue and number of pairs of pupils such that the first one agrees to change places with the second one if the first is directly in front of the second.

The second line contains n integers p_1, p_2, ..., p_n — the initial arrangement of pupils in the queue, from the queue start to its end (1 ≤ p_i ≤ n, p is a permutation of integers from 1 to n). In other words, p_i is the number of the pupil who stands on the i-th position in the queue.

The i-th of the following m lines contains two integers u_i, v_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), denoting that the pupil with number u_i agrees to change places with the pupil with number v_i if u_i is directly in front of v_i. It is guaranteed that if i ≠ j, than v_i ≠ v_j or u_i ≠ u_j. Note that it is possible that in some pairs both pupils agree to change places with each other.

Nastya is the last person in the queue, i.e. the pupil with number p_n.

Output

Print a single integer — the number of places in queue she can move forward.

Examples

Input

2 1
1 2
1 2


Output

1

Input

3 3
3 1 2
1 2
3 1
3 2


Output

2

Input

5 2
3 1 5 4 2
5 2
5 4


Output

1

Note

In the first example Nastya can just change places with the first pupil in the queue.

Optimal sequence of changes in the second example is 

  * change places for pupils with numbers 1 and 3. 
  * change places for pupils with numbers 3 and 2. 
  * change places for pupils with numbers 1 and 2. 



The queue looks like [3, 1, 2], then [1, 3, 2], then [1, 2, 3], and finally [2, 1, 3] after these operations.
Program:
```
from sys import stdin

def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    (n, m) = rints()
    (a, b) = (rints(), [rints() for _ in range(m)])
    (adj, tem, ans) = ([set() for _ in range(n + 1)], [], 0)
    adj2 = set()
    for (u, v) in b:
        adj[u].add(v)
        if v == a[-1]:
            adj2.add(u)
    for i in range(n - 2, -1, -1):
        if a[i] in adj2:
            if len(adj[a[i]]) >= len(tem):
                ans += 1
                for j in tem:
                    if j not in adj[a[i]]:
                        ans -= 1
                        break
        else:
            tem.append(a[i])
    print(ans)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
