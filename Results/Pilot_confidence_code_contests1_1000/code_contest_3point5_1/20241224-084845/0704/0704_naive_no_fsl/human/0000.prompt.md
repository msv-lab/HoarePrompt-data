
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Denis was very sad after Nastya rejected him. So he decided to walk through the gateways to have some fun. And luck smiled at him! When he entered the first courtyard, he met a strange man who was selling something. 

Denis bought a mysterious item and it was... Random permutation generator! Denis could not believed his luck.

When he arrived home, he began to study how his generator works and learned the algorithm. The process of generating a permutation consists of n steps. At the i-th step, a place is chosen for the number i (1 ≤ i ≤ n). The position for the number i is defined as follows:

  * For all j from 1 to n, we calculate r_j — the minimum index such that j ≤ r_j ≤ n, and the position r_j is not yet occupied in the permutation. If there are no such positions, then we assume that the value of r_j is not defined. 
  * For all t from 1 to n, we calculate count_t — the number of positions 1 ≤ j ≤ n such that r_j is defined and r_j = t. 
  * Consider the positions that are still not occupied by permutation and among those we consider the positions for which the value in the count array is maximum. 
  * The generator selects one of these positions for the number i. The generator can choose any position. 



Let's have a look at the operation of the algorithm in the following example:

<image>

Let n = 5 and the algorithm has already arranged the numbers 1, 2, 3 in the permutation. Consider how the generator will choose a position for the number 4:

  * The values of r will be r = [3, 3, 3, 4, ×], where × means an indefinite value. 
  * Then the count values will be count = [0, 0, 3, 1, 0]. 
  * There are only two unoccupied positions in the permutation: 3 and 4. The value in the count array for position 3 is 3, for position 4 it is 1. 
  * The maximum value is reached only for position 3, so the algorithm will uniquely select this position for number 4. 



Satisfied with his purchase, Denis went home. For several days without a break, he generated permutations. He believes that he can come up with random permutations no worse than a generator. After that, he wrote out the first permutation that came to mind p_1, p_2, …, p_n and decided to find out if it could be obtained as a result of the generator.

Unfortunately, this task was too difficult for him, and he asked you for help. It is necessary to define whether the written permutation could be obtained using the described algorithm if the generator always selects the position Denis needs.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^5) — the number of test cases. Then the descriptions of the test cases follow.

The first line of the test case contains a single integer n (1 ≤ n ≤ 10^5) — the size of the permutation.

The second line of the test case contains n different integers p_1, p_2, …, p_n (1 ≤ p_i ≤ n) — the permutation written by Denis.

It is guaranteed that the sum of n over all test cases doesn't exceed 10^5.

Output

Print "Yes" if this permutation could be obtained as a result of the generator. Otherwise, print "No".

All letters can be displayed in any case.

Example

Input


5
5
2 3 4 5 1
1
1
3
1 3 2
4
4 2 3 1
5
1 5 2 4 3


Output


Yes
Yes
No
Yes
No

Note

Let's simulate the operation of the generator in the first test.

At the 1 step, r = [1, 2, 3, 4, 5], count = [1, 1, 1, 1, 1]. The maximum value is reached in any free position, so the generator can choose a random position from 1 to 5. In our example, it chose 5.

At the 2 step, r = [1, 2, 3, 4, ×], count = [1, 1, 1, 1, 0]. The maximum value is reached in positions from 1 to 4, so the generator can choose a random position among them. In our example, it chose 1.

At the 3 step, r = [2, 2, 3, 4, ×], count = [0, 2, 1, 1, 0]. The maximum value is 2 and is reached only at the 2 position, so the generator will choose this position.

At the 4 step, r = [3, 3, 3, 4, ×], count = [0, 0, 3, 1, 0]. The maximum value is 3 and is reached only at the 3 position, so the generator will choose this position.

At the 5 step, r = [4, 4, 4, 4, ×], count = [0, 0, 0, 4, 0]. The maximum value is 4 and is reached only at the 4 position, so the generator will choose this position.

In total, we got a permutation of 2, 3, 4, 5, 1, that is, a generator could generate it.
Program:
```
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_1()

def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        p = [int(pi) - 1 for pi in input().split()]
        idx = [0] * n
        for (i, j) in enumerate(p):
            idx[j] = i
        poss = True
        prev = idx[0]
        end = n - 1
        for (i, j) in enumerate(idx[1:]):
            if prev != end and j != prev + 1:
                poss = False
                break
            if prev == end:
                end = prev - 1
            prev = j
        func_2('Yes' if poss else 'No')

def func_2(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
