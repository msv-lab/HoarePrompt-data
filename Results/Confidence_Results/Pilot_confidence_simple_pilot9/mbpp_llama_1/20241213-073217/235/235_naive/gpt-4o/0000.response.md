Correctness: **True**

The program provided appears to correctly calculate the sum of the digits of a non-negative integer. The function `func_1(n: int) -> int` uses a while loop to continuously extract the last digit of the number `n` using the modulo operator (`n % 10`), add it to the total, and then remove the last digit from `n` by performing integer division by 10 (`n //= 10`). This process repeats until all digits have been processed, i.e., until `n` becomes 0.

The given assertions (`assert func_1(345) == 12`, `assert func_1(12) == 3`, `assert func_1(97) == 16`) also validate the correctness of the function for specific test cases. 

For instance, in the case of `func_1(345)`, the calculation would be: 
- `total = 0`
- First iteration: `n = 345`, `total += 345 % 10 = 5`, `n //= 10` becomes `n = 34`
- Second iteration: `n = 34`, `total += 34 % 10 = 4`, `n //= 10` becomes `n = 3`
- Third iteration: `n = 3`, `total += 3 % 10 = 3`, `n //= 10` becomes `n = 0`
- Since `n` is now 0, the loop ends, and the function returns `total = 5 + 4 + 3 = 12`, which is correct.

Given the straightforward and efficacious algorithm, along with the validating assertions, it appears that the program correctly fulfills the problem description for all potential non-negative integer inputs.