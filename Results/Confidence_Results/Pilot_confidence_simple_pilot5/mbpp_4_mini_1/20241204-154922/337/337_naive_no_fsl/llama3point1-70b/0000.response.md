To determine the correctness of the given program, we need to analyze the function `func_1(lst)` and see if it meets the requirements of the problem description which states that it should find the sum of non-repeated elements in a given list.

### Program Analysis:
The function `func_1(lst)` uses a generator expression to iterate through each element `i` in the list `lst`. It checks if the count of `i` in `lst` is equal to 1 (i.e., it is non-repeated). If so, it includes that element in the sum. 

### Potential Cases to Test:
1. **Basic Case with Non-repeated Elements:**
   - Input: `[1, 2, 3]`
   - Output: `1 + 2 + 3 = 6` (Expected: `6`)

2. **Case with Repeated Elements:**
   - Input: `[1, 2, 2, 3]`
   - Output: `1 + 3 = 4` (Expected: `4`)

3. **Case with No Non-repeated Elements:**
   - Input: `[1, 1, 2, 2]`
   - Output: `0` (Expected: `0`)

4. **Case with Mixed Repeated and Non-repeated:**
   - Input: `[4, 5, 4, 6, 7, 7]`
   - Output: `5 + 6 = 11` (Expected: `11`)

5. **Case with an Empty List:**
   - Input: `[]`
   - Output: `0` (Expected: `0`)

6. **Case with Single Element:**
   - Input: `[10]`
   - Output: `10` (Expected: `10`)

### Edge Cases:
- The function seems to correctly handle edge cases such as empty lists and lists with a single element. 

### Performance Consideration:
The approach used in the code is not efficient for large lists, as `lst.count(i)` is O(n) for each element, making the overall complexity O(n^2). However, since the problem description does not specify performance requirements, we will focus on correctness.

### Conclusion:
After testing various cases, I find that the function produces the correct output for all scenarios mentioned above, including edge cases.

Correctness: **True** 

### Explanation:
The function correctly identifies and sums non-repeated elements in the list as per the problem requirements. It handles empty lists, lists with all repeated elements, and lists with both repeated and non-repeated elements correctly.