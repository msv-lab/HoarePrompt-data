Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers lined up, each containing some amount of water. The goal is to make sure that all containers have the same amount of water, and I can only pour water from a container with a lower index to one with a higher index. Also, it's given that the total sum of water in all containers is divisible by n, which means it's possible in theory to distribute the water equally.

First, I need to understand the constraints and what operations are allowed. The key point here is that I can only pour water from a container with a lower index to a higher one, and I can do this any number of times, choosing any amounts each time, as long as the source container has more water than the target container.

Given that, I need to figure out if it's possible to make all containers have the same amount of water, given these pouring restrictions.

Let me think about what the target amount should be. Since the total sum is divisible by n, the target amount for each container is sum(a)/n. Let's call this target value 'avg'.

So, for each container, I need to adjust its water level to 'avg'. Some containers have more than 'avg', and some have less. The problem is to see if I can redistribute the water from those with more to those with less, only pouring from lower to higher indices.

Now, I need to consider the pouring operation: pouring from a lower index to a higher one. This means that water can only move in one direction, from left to right in the line of containers.

I need to think about whether this unidirectional pouring is sufficient to reach the equal distribution.

Let me consider a simple case. Suppose n=2, with containers having [1, 3]. The sum is 4, which is divisible by 2, so avg=2. I need to make both containers have 2 units of water. Since 1 < 2, I need to add 1 to the first container, and since 3 > 2, I need to remove 1 from the second container. But according to the operation, I can only pour from the first to the second. So, if I pour 1 unit from the first to the second, the first becomes 0 and the second becomes 4. That's not helpful. In fact, it makes the first container have less than avg, and the second have more than avg. It seems like in this case, it's impossible to reach the equal distribution.

Wait, but according to the example in the problem, the answer is "NO" for this case, which matches my conclusion.

Let me try another example. Suppose n=3, with containers [4, 5, 2]. Sum is 11, which is not divisible by 3. Wait, but the problem says that the sum is always divisible by n, so maybe I should pick another example where sum is divisible by n.

Let's take n=3, with [3, 3, 3]. Sum is 9, divisible by 3, avg=3. All containers already have 3, so no need to do anything. Answer should be "YES".

Another example: n=3, [1, 2, 3]. Sum is 6, divisible by 3, avg=2. Need to adjust to 2 in each container. So, first container needs +1, second is already 2, third needs -1. Can I pour from first to third? No, because first has lower index than third, but I can pour from first to second, and then from second to third.

Wait, pouring from first to second: pour x units from first to second.

Let's say I pour 1 unit from first to second, then first becomes 0, second becomes 3. Now, second has 3, which is more than avg, and third has 3. Can I pour from second to third? No, because second has a lower index than third. So, I can't pour from second to third. So, in this case, it's impossible to reach equal distribution. So, answer should be "NO", which matches the sample input.

Another example from the sample input: n=5, a=[4,5,2,1,3]. Sum is 15, avg=3.

Need to adjust:

- Container 1: 4 -> needs to give away 1

- Container 2: 5 -> needs to give away 2

- Container 3: 2 -> needs to receive 1

- Container 4: 1 -> needs to receive 2

- Container 5: 3 -> no change

Now, I need to see if I can pour from containers that need to give away to those that need to receive, respecting the direction (lower to higher indices).

So, starting from the left:

- Container 1 (4) can pour to container 2 (5), but container 2 needs to give away as well. Wait, but if I pour from 1 to 2, 1 becomes 3 and 2 becomes 6. Now, 2 has more to give away. Not helpful.

Alternatively, maybe pour from 1 to 3: 1 has 4, pour 1 to 3, 1 becomes 3, 3 becomes 3. Now, 1 and 3 are at avg, and I need to handle containers 2,4,5.

Container 2 has 5, needs to give away 2. Can pour to container 4 or 5.

Pour from 2 to 4: pour 1 unit, 2 becomes 4, 4 becomes 2.

Now, 2 has 4 (still above avg), 4 has 2 (still below avg).

Pour another 1 unit from 2 to 4: 2 becomes 3, 4 becomes 3. Now, 2 and 4 are at avg.

Container 5 is already at avg.

So, in this case, it's possible to reach equal distribution. So, answer is "YES".

From these examples, I need to find a general approach to determine if such a distribution is possible.

Let me think about the problem in terms of cumulative sums.

Since pouring is only allowed from lower to higher indices, the amount of water in each container can only be increased by pouring into it from lower-indexed containers.

Wait, but in the operation, it's pouring from lower to higher, meaning that higher-indexed containers can receive water from lower-indexed ones.

So, for each container, the final amount should be at least the initial amount, because you can only add water to it from lower containers.

But, in reality, to reach the average, some containers need to give away water, which means they need to pour to higher-indexed containers.

Wait, but the operation only allows pouring from lower to higher indices, which means that a container can only give away water to higher-indexed containers, not to lower ones.

So, for a container that needs to give away water, it can only pour to higher-indexed containers.

Similarly, a container that needs to receive water can only receive from lower-indexed containers.

Given that, I need to ensure that for each container, the cumulative amount of water from the left is sufficient to reach the target average, considering the pouring operations.

Let me think in terms of prefix sums.

Let's define the target amount for each container as avg.

Then, for the first container, to reach avg, it can only use its own water, since there are no lower-indexed containers.

So, if a[0] >= avg, it can pour some water to the right containers.

If a[0] < avg, it's impossible because there are no lower-indexed containers to receive water from.

Wait, but in the sample input 4, which is [1,2,3], the answer is "NO", which matches this condition because a[0]=1 < avg=2.

Similarly, in sample input 1, [43], it's "YES" because a[0]=43 >= avg=43.

In sample input 2, [1,3], a[0]=1 < avg=2, so "NO".

In sample input 3, [4,5,2,1,3], a[0]=4 >= avg=3, so possible.

In sample input 5, [4,5,5,0,6,4,4], a[0]=4 >= avg=4, possible.

In sample input 6, [6,5,5,1,3,4,4], a[0]=6 >= avg=4, possible.

Wait, but sample input 5 is "NO", even though a[0] >= avg.

Hmm, maybe there's more to it.

Wait, perhaps I need to ensure that the cumulative sum up to each position is at least the target sum up to that position.

Let me define prefix_sum[k] = a[0] + a[1] + ... + a[k-1]

And target_prefix[k] = k * avg

Then, for the distribution to be possible, prefix_sum[k] >= target_prefix[k] for all k from 1 to n.

This is similar to the concept in rearrangement inequalities or in greedy algorithms where you need to ensure that at each step, you have enough resources accumulated so far to meet the required distribution.

Let me test this idea with the sample inputs.

Sample input 3: n=5, a=[4,5,2,1,3], avg=3

Compute prefix sums and target prefixes:

- k=1: prefix_sum[1]=4, target_prefix[1]=3 → 4 >= 3 → OK

- k=2: prefix_sum[2]=4+5=9, target_prefix[2]=6 → 9 >= 6 → OK

- k=3: prefix_sum[3]=4+5+2=11, target_prefix[3]=9 → 11 >= 9 → OK

- k=4: prefix_sum[4]=4+5+2+1=12, target_prefix[4]=12 → 12 >= 12 → OK

- k=5: prefix_sum[5]=4+5+2+1+3=15, target_prefix[5]=15 → 15 >= 15 → OK

All conditions are satisfied, so answer is "YES", which matches the sample.

Sample input 2: n=2, a=[1,3], avg=2

- k=1: prefix_sum[1]=1, target_prefix[1]=2 → 1 < 2 → NOT OK

So, "NO", matches the sample.

Sample input 5: n=7, a=[4,5,5,0,6,4,4], avg=4

- k=1: 4 >= 4 → OK

- k=2: 4+5=9 >= 8 → OK

- k=3: 4+5+5=14 >= 12 → OK

- k=4: 4+5+5+0=14 >= 16 → 14 < 16 → NOT OK

So, "NO", matches the sample.

Sample input 6: n=7, a=[6,5,5,1,3,4,4], avg=4

- k=1: 6 >= 4 → OK

- k=2: 6+5=11 >= 8 → OK

- k=3: 6+5+5=16 >= 12 → OK

- k=4: 6+5+5+1=17 >= 16 → OK

- k=5: 6+5+5+1+3=20 >= 20 → OK

- k=6: 6+5+5+1+3+4=24 >= 24 → OK

- k=7: 6+5+5+1+3+4+4=28 >= 28 → OK

So, "YES", matches the sample.

Great, this seems to be a correct approach.

So, the algorithm is:

1. For each test case:

a. Read n and the list a.

b. Compute avg = sum(a) / n

c. Compute prefix_sum[k] for k from 1 to n

d. Compute target_prefix[k] = k * avg

e. Check if prefix_sum[k] >= target_prefix[k] for all k from 1 to n

f. If all conditions are satisfied, output "YES"; else, "NO"

Now, considering the constraints:

- t <= 10^4

- n <= 2*10^5

- sum of n over all test cases <= 2*10^5

- a_i <= 10^9

- sum(a) <= 2*10^9

- sum(a) is divisible by n

Given these constraints, I need to make sure that the solution is efficient.

Computing prefix sums can be done in O(n) time, which is acceptable given the constraints.

I need to handle large inputs efficiently, so I should read all input at once and process it accordingly.

Also, since a_i can be up to 10^9 and n up to 2*10^5, I need to make sure that there are no integer overflow issues. In Python, integers can be arbitrarily large, so that's not a problem.

Let me look at the provided program and see if it implements this correctly.

The provided program is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

nums = list(map(int, input().strip().split()))

last = nums[-1]

curr = 0

for i in nums:

if i != 0:

curr += i - last

if curr == 0:

print('YES')

else:

print('NO')

Wait, this seems different from what I thought.

It seems like the code is computing the sum of (i - last) for all i in nums that are not zero, and checking if this sum is zero.

This doesn't align with the prefix sum approach I was thinking about.

Let me analyze what this code is doing.

First, it reads t, the number of test cases.

For each test case:

- Read n

- Read the list of a_i

- Set last = nums[-1], which is the last element in the list

- Initialize curr = 0

- For each i in nums:

- If i != 0:

- curr += i - last

- If curr == 0:

- print('YES')

- Else:

- print('NO')

Wait, this seems flawed.

In the sample input 3, n=5, a=[4,5,2,1,3], last=3.

Then, curr = (4-3) + (5-3) + (2-3) + (1-3) + (3-3) = 1 + 2 -1 -2 + 0 = 0

So, it would output "YES", which matches the sample.

In sample input 2, n=2, a=[1,3], last=3.

curr = (1-3) + (3-3) = -2 + 0 = -2 != 0 → "NO"

In sample input 1, n=1, a=[43], last=43.

curr = (43-43) = 0 → "YES"

In sample input 4, n=3, a=[1,2,3], last=3.

curr = (1-3) + (2-3) + (3-3) = -2 -1 + 0 = -3 != 0 → "NO"

In sample input 5, n=7, a=[4,5,5,0,6,4,4], last=4.

curr = (4-4) + (5-4) + (5-4) + (0-4) + (6-4) + (4-4) + (4-4) = 0 +1 +1 -4 +2 +0 +0 = 0 → "YES"

But according to the sample, the answer should be "NO". So, this doesn't match.

Wait, in sample input 5, the answer is "NO", but according to this code, it would output "YES", which is incorrect.

Wait, perhaps I misread the sample input outputs.

Let me check the sample input again.

Sample Input:

6

1

43

2

1 3

5

4 5 2 1 3

3

1 2 3

7

4 5 5 0 6 4 4

7

6 5 5 1 3 4 4

Sample Output:

YES

NO

YES

NO

NO

YES

So, for the 5th test case, it's "NO", but the code would output "YES", which is wrong.

Therefore, this code is incorrect.

Wait, but according to my earlier calculation, for sample input 5, curr=0, so it would output "YES", which is incorrect.

Hence, the code is wrong.

So, the correctness is False.

But perhaps there's something I'm missing.

Let me see if there's another way to interpret this code.

Maybe the idea is to check if the sum of (a_i - last) for a_i != 0 is zero.

But, in the correct approach, I need to check the prefix sums.

So, the correct approach should be:

- Compute avg = sum(a) / n

- Compute prefix_sum[k] for k from 1 to n

- Check if prefix_sum[k] >= k * avg for all k from 1 to n

So, the provided code doesn't do this.

Hence, it's incorrect.

I need to implement the prefix sum check to determine if it's possible to equalize the water levels.

Therefore, the provided program is incorrect.

**Final Answer**

\[ \boxed{\text{False}} \]