Alright, I've got this problem to solve. Let's see what it's asking for. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (between 2 and n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to make all elements of the array zero using these operations.

First, I need to understand what this operation does. It seems like it's designed to reduce the values of three consecutive elements in a specific way. By choosing different i's and applying the operation multiple times, Rudolf can manipulate the array to try to reach all zeros.

I need to figure out if, for any given array, it's possible to apply these operations in such a way that all elements become zero.

Let me think about the constraints. The array has at least 3 elements, and the operations can only be applied to indices from 2 to n-1. Also, the operations involve subtracting values from three consecutive elements each time.

I recall that in similar problems, especially those involving operations that affect multiple elements at once, there might be some invariant or some condition that needs to be satisfied for the array to be reducible to all zeros.

Maybe I can model this problem using linear algebra or find some pattern in the operations.

Let's consider the operation as a vector subtraction. Each operation corresponds to subtracting a specific vector from the array. For example, if n=5, and I choose i=3, the operation subtracts [0,0,1,2,1] from the array.

So, in general, for an array of size n, the operation for each i corresponds to subtracting a vector that has:

- 1 at position i-1

- 2 at position i

- 1 at position i+1

- 0 elsewhere

I need to see if, by subtracting these vectors (possibly multiple times), I can reach the zero vector from the initial array.

This sounds like solving a system of linear equations. Each operation is like subtracting a specific vector, and I need to find coefficients for each operation such that the linear combination equals the initial array.

In linear algebra terms, I need to check if the initial array is in the span of the vectors corresponding to the allowed operations.

Given that, I can represent the operations as vectors and see if the initial array can be expressed as a linear combination of these operation vectors.

However, since the operations can be applied any number of times (including zero), and the coefficients are integers (since we're dealing with integer subtractions), I need to consider integer linear combinations.

Moreover, since the operations can be applied in any order, and subtraction is commutative in this context, the order shouldn't matter.

But this seems a bit too abstract. Maybe there's a smarter way to approach this.

Let me think about the effects of the operations. Each operation reduces the middle element by 2 and its neighbors by 1. It seems like this could be related to diffusing values or something similar.

Wait a minute, perhaps I can look at the differences between consecutive elements.

Let's consider the differences between consecutive elements in the array. For example, if the array is [a, b, c, d, e], then the differences are [b-a, c-b, d-c, e-d].

Maybe tracking these differences can help me understand how the operations affect the array.

Let's see what happens to the differences when I apply an operation at index i.

Suppose I have an array: [a, b, c, d, e]

Differences: [b-a, c-b, d-c, e-d]

Now, if I apply an operation at i=3, the array becomes:

[a - 0, b - 1, c - 2, d - 1, e - 0]

So new differences: [(b-1)-a, (c-2)-(b-1), (d-1)-(c-2), (e-0)-(d-1)]

Simplify:

[b -1 - a, c -2 - b +1, d -1 - c +2, e - d +1]

Which is:

[b - a -1, c - b -1, d - c +1, e - d +1]

Comparing this to the original differences:

Original: [b-a, c-b, d-c, e-d]

New: [b-a -1, c-b -1, d-c +1, e-d +1]

So, applying an operation at i=3 affects the differences at positions i-1 and i (which are the second and third differences in this case).

Specifically, it decreases the (i-1)-th difference by 1 and increases the i-th difference by 1.

Wait, in general, applying an operation at index i changes the (i-1)-th difference by -1 and the i-th difference by +1.

That's interesting. So, each operation affects two consecutive differences: it decreases the (i-1)-th difference by 1 and increases the i-th difference by 1.

So, if I look at the sequence of differences, the operations allow me to adjust these differences in a specific way.

Given that, maybe I can think of the differences as a separate array that I can manipulate by applying operations.

Wait, but my goal is to make all elements of the original array zero. What does that mean for the differences?

If all elements are zero, then all differences are also zero.

So, starting from some initial differences, I need to apply operations to adjust the differences until they are all zero.

But, since each operation adjusts two consecutive differences, I need to see if I can cancel out the initial differences by applying a series of such adjustments.

This seems similar to Gaussian elimination or solving a system of linear equations.

Alternatively, perhaps I can accumulate the necessary adjustments for each difference.

Let me consider the differences as a separate array: diff = [b-a, c-b, d-c, e-d]

And each operation allows me to add [-1, +1] to two consecutive differences.

So, for example, operation at i=3 adds [-1, +1] to diff[2] and diff[3].

Wait, in my earlier calculation, operation at i=3 adds [-1, +1] to diff[i-1] and diff[i], which are diff[2] and diff[3] for i=3.

So, in general, operation at i affects diff[i-1] and diff[i] by -1 and +1 respectively.

Given that, I need to find a sequence of operations that will adjust the differences to zero.

This sounds like solving a system where each equation corresponds to a difference needing to be zero.

But, since the operations affect two differences at a time, it's a system of linear equations with integer coefficients.

I need to check if the initial differences can be balanced to zero using these operations.

Alternatively, perhaps there's a simpler way to look at this.

Let me consider the cumulative sum of the differences. Since the differences are (b-a), (c-b), (d-c), (e-d), the cumulative sum of differences up to position k gives me the value at position k+1 minus a.

Wait, actually, the cumulative sum of differences from the first to the k-th position gives me the value at position k+1 minus the first element.

But, if I want all differences to be zero, that would imply that all elements are equal, but in this problem, I want all elements to be zero.

Wait, maybe I need to think differently.

Perhaps I should consider the original array and see how the operations affect it.

Each operation at index i reduces a[i-1] by 1, a[i] by 2, and a[i+1] by 1.

I need to find a sequence of operations such that the sum of all operations applied to each element makes it zero.

So, for each element, the total subtraction equals its initial value.

But, since operations affect three elements at a time, it's not straightforward to assign individual operations to target specific elements.

Maybe I can model this as a system of linear equations, where each equation corresponds to the total subtraction for each element equaling its initial value.

Let me try to set up the equations.

Letâ€™s denote the number of times operation is applied at index j as x_j.

Then, for each element i, the total subtraction is:

- For i=1: only affected by operation at j=2, which subtracts 1 from a[1]. So, total subtraction from a[1] is x_2.

- For i=2: affected by operation at j=2 (subtracts 2 from a[2]) and j=3 (subtracts 1 from a[2]). So, total subtraction is 2*x_2 + 1*x_3.

- For i=3: affected by operation at j=2 (subtracts 1 from a[3]), j=3 (subtracts 2 from a[3]), and j=4 (subtracts 1 from a[3]). So, total subtraction is 1*x_2 + 2*x_3 + 1*x_4.

- And so on, until the last elements.

Finally, for i=n-1: affected by operation at j=n-2 (subtracts 1 from a[n-1]) and j=n-1 (subtracts 2 from a[n-1]). So, total subtraction is 1*x_{n-2} + 2*x_{n-1}.

For i=n: only affected by operation at j=n-1, which subtracts 1 from a[n]. So, total subtraction is x_{n-1}.

Now, for each i from 1 to n, I have an equation:

- Subtraction equals initial value:

  - For i=1: x_2 = a[1]

  - For i=2: 2*x_2 + x_3 = a[2]

  - For i=3: x_2 + 2*x_3 + x_4 = a[3]

  - ...

  - For i=n-1: x_{n-2} + 2*x_{n-1} = a[n-1]

  - For i=n: x_{n-1} = a[n]

This gives me a system of n equations with n-2 variables (x_2 to x_{n-1}).

Wait, no. Actually, the operations are applied at indices from 2 to n-1, so x_j for j from 2 to n-1.

So, I have n equations and n-2 variables.

This seems overconstrained because n equations with n-2 variables.

In general, for such a system to have a solution, the equations must be consistent.

But, since n > n-2, it's likely that the system is inconsistent for some arrays.

However, perhaps there is a pattern or a way to simplify these equations.

Let me try to write down the equations more systematically.

For i from 1 to n:

- i=1: x_2 = a[1]

- i=2: 2*x_2 + x_3 = a[2]

- i=3: x_2 + 2*x_3 + x_4 = a[3]

- ...

- i=k: x_{k-1} + 2*x_k + x_{k+1} = a[k] for k from 2 to n-2

- i=n-1: x_{n-2} + 2*x_{n-1} = a[n-1]

- i=n: x_{n-1} = a[n]

Wait, but for i=1 and i=n, the equations are simpler.

Given that x_{n-1} = a[n], from the last equation, I can substitute back into the previous equations.

Let me try to solve the equations step by step.

Starting from the last equation:

x_{n-1} = a[n]

Then, from the second last equation:

x_{n-2} + 2*x_{n-1} = a[n-1]

Substituting x_{n-1}:

x_{n-2} + 2*a[n] = a[n-1]

Therefore, x_{n-2} = a[n-1] - 2*a[n]

Similarly, from the third last equation:

x_{n-3} + 2*x_{n-2} + x_{n-1} = a[n-2]

Substituting x_{n-2} and x_{n-1}:

x_{n-3} + 2*(a[n-1] - 2*a[n]) + a[n] = a[n-2]

Simplify:

x_{n-3} + 2*a[n-1] - 4*a[n] + a[n] = a[n-2]

x_{n-3} + 2*a[n-1] - 3*a[n] = a[n-2]

Therefore, x_{n-3} = a[n-2] - 2*a[n-1] + 3*a[n]

Continuing this pattern, it seems like each x_k can be expressed in terms of a[k+1], a[k+2], ..., a[n]

This seems recursive.

Similarly, from the first equation: x_2 = a[1]

Then, from the second equation: 2*x_2 + x_3 = a[2]

Substituting x_2:

2*a[1] + x_3 = a[2]

Therefore, x_3 = a[2] - 2*a[1]

Then, from the third equation: x_2 + 2*x_3 + x_4 = a[3]

Substituting x_2 and x_3:

a[1] + 2*(a[2] - 2*a[1}) + x_4 = a[3]

Simplify:

a[1] + 2*a[2] - 4*a[1} + x_4 = a[3]

-3*a[1] + 2*a[2] + x_4 = a[3]

Therefore, x_4 = a[3] + 3*a[1] - 2*a[2]

And so on, each x_k can be expressed in terms of a[1], a[2], ..., a[n]

This seems similar to solving a tridiagonal system.

Given that, for the system to have a solution, the equations must be consistent.

In particular, when I substitute back, there might be conditions that need to hold for the a[i]'s.

Let me see what happens when I substitute all the way.

For example, in the earlier step, x_{n-3} = a[n-2] - 2*a[n-1] + 3*a[n]

And x_{n-2} = a[n-1] - 2*a[n]

And x_{n-1} = a[n]

Now, plugging these back into earlier equations, I need to ensure that there are no contradictions.

This seems complicated. Maybe there's a smarter way.

Wait a minute, perhaps I can look at the sum of all a[i]'s.

Each operation subtracts a total of 1 + 2 + 1 = 4 from the sum of the array.

Therefore, the total sum of the array must be divisible by 4 for it to be possible to reduce it to all zeros.

But, hold on, that might not be sufficient.

Let me check with the first example:

n=5, a = [1,3,5,5,2]

Sum = 1+3+5+5+2 = 16, which is divisible by 4.

And according to the example, it's possible to make all elements zero.

Another example where it's not possible:

n=5, a=[2,4,4,5,1]

Sum=2+4+4+5+1=16, which is divisible by 4, but the output is "NO", meaning it's not possible.

So, sum being divisible by 4 is not sufficient.

Hence, there must be another condition.

Maybe I need to look for something else.

Let me consider the differences again.

From earlier, each operation affects the differences by subtracting 1 from diff[i-1] and adding 1 to diff[i].

So, the operations allow me to adjust the differences in a specific way.

To make all differences zero, I need to be able to adjust the differences using these operations.

This seems similar to being able to balance the differences by applying these adjustments.

Perhaps, if I look at the cumulative sum of the differences, I can find a pattern.

Wait, the cumulative sum of the differences should give me back the original array (up to the first element).

But, I'm not sure if that helps directly.

Let me try to think differently.

Suppose I have the array [a1, a2, a3, a4, a5]

I can represent the operations in terms of their effects on the array.

Each operation at index i can be represented as a vector:

[0, 0, ..., 0, -1 (at i-1), -2 (at i), -1 (at i+1), 0, ..., 0]

I need to find a combination of these vectors such that their sum equals the negative of the initial array.

This is equivalent to solving a system of linear equations.

Given that, perhaps I can find the rank of the matrix formed by these operation vectors and see if the initial array is in their span.

But, this seems too time-consuming for practical purposes, especially since n can be up to 2e5.

I need a more efficient way to check if the array can be reduced to zero.

Maybe there's an invariant or some property that the array must satisfy for it to be possible.

Looking back at the operations, each operation reduces the middle element by 2 and its neighbors by 1.

Perhaps I can consider the array in terms of its "peaks" and "valleys".

But, I'm not sure.

Wait, perhaps I can look at the array in reverse.

Suppose I start from the end and work my way backwards, applying operations to make the last elements zero, and so on.

Let me try that with the first example.

n=5, a=[1,3,5,5,2]

I need to make a[5]=0.

Currently, a[5]=2.

Looking at the operations, I can only affect a[5] by operations at i=4.

Each operation at i=4 subtracts 1 from a[5].

So, to make a[5]=0, I need to apply the operation at i=4, 2 times.

After 2 operations at i=4:

a[3] = 5 - 1*2 = 3

a[4] = 5 - 2*2 = 1

a[5] = 2 - 1*2 = 0

Now, the array is [1,3,3,1,0]

Next, I need to make a[4]=0.

Currently, a[4]=1.

I can affect a[4] by operations at i=3 and i=4.

Wait, but since i=4 is already considered, and a[5] is zero, I should focus on i=3.

Each operation at i=3 subtracts 1 from a[2], 2 from a[3], and 1 from a[4].

So, applying operation at i=3:

a[2] = 3 -1 =2

a[3] = 3 -2 =1

a[4] = 1 -1 =0

Now, a=[1,2,1,0,0]

Next, make a[3]=0.

Currently, a[3]=1.

I can affect a[3] by operations at i=2 and i=3.

Operation at i=3 subtracts 1 from a[2], 2 from a[3], and 1 from a[4].

But a[4] is already zero, so I need to be careful.

If I apply operation at i=3 once:

a[2] = 2 -1 =1

a[3] =1 -2 =-1

a[4] =0 -1 =-1

Wait, but the array elements are supposed to be non-negative, and we're subtracting, so I need to ensure that the subtractions don't make any element negative.

In this case, a[3]=1, and I need to subtract 2, which would make it -1, which is invalid.

So, I can't apply the operation at i=3 because a[3] is only 1, but the operation requires a[i] >=2.

Wait, in the problem statement, it says "a_i - 2", so a_i must be at least 2 to apply the operation.

In this case, a[3]=1 < 2, so I can't apply the operation at i=3.

But in the earlier steps, I had a[3]=5, which is >=2, so I could apply the operation.

But now, a[3]=1, so I can't apply the operation there.

This suggests that perhaps the initial array doesn't satisfy the conditions to be reduced to zero, or I made a mistake in the sequence of operations.

Wait, but according to the example, it's possible to make all elements zero.

Hmm, maybe I need to choose a different sequence of operations.

Let me try a different approach.

Looking back at the first example:

Original array: [1,3,5,5,2]

First, apply operation at i=4:

a[3]=5-1=4

a[4]=5-2=3

a[5]=2-1=1

Now, array is [1,3,4,3,1]

Then, apply operation at i=3:

a[2]=3-1=2

a[3]=4-2=2

a[4]=3-1=2

Array is [1,2,2,2,1]

Then, apply operation at i=2:

a[1]=1-1=0

a[2]=2-2=0

a[3]=2-1=1

Array is [0,0,1,2,1]

Then, apply operation at i=4:

a[3]=1-1=0

a[4]=2-2=0

a[5]=1-1=