Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends such that at least two friends actually come to the party. The condition for a friend to come is that both the friend and their best friend receive an invitation. Each friend's best friend is unique and not themselves, and all best friends are distinct, meaning no two friends have the same best friend.

So, I need to find the minimum number of invitations to send so that at least two friends come to the party.

First, I need to understand the relationship between friends and their best friends. Since each friend's best friend is unique and no one is their own best friend, it forms a kind of matching or pairing among the friends. But the problem states that all p_i are distinct and p_i ≠ i, so it's a permutation of the friends where no one maps to themselves.

Wait, but in the example, p = [3,1,2,5,4], which corresponds to friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

So, it's a permutation without fixed points, and all p_i are distinct.

Now, I need to model this in a way that helps me find the minimal number of invitations to send, such that at least two friends come to the party.

Each friend comes if both they and their best friend receive an invitation. So, for friend i to come, both i and p_i must receive invitations.

But, sending invitations to i and p_i might cause both to come, but I need to ensure that at least two friends come.

Wait, no. Only the friends who have both them and their best friend invited will come. So, if I invite i and p_i, then i will come because i and p_i are invited, and p_i will come because p_i and p_{p_i} are invited, but p_{p_i} might not be the same as i.

Wait, in the example, p = [3,1,2,5,4]:

- Friend 1's best friend is 3

- Friend 2's best friend is 1

- Friend 3's best friend is 2

- Friend 4's best friend is 5

- Friend 5's best friend is 4

So, if I invite friends 1 and 3, then friend 1 will come because 1 and 3 are invited, and friend 3 will come because 3 and 2 are invited. So, both friend 1 and friend 3 will come.

Alternatively, if I invite friends 4 and 5, then friend 4 will come because 4 and 5 are invited, and friend 5 will come because 5 and 4 are invited.

So, in this case, inviting two friends can make two friends come, which satisfies the condition.

In the second test case, n=4, p=[2,3,4,1]

- Friend 1's best friend is 2

- Friend 2's best friend is 3

- Friend 3's best friend is 4

- Friend 4's best friend is 1

So, this forms a cycle: 1 -> 2 -> 3 -> 4 -> 1

If I invite friends 1, 2, and 3:

- Friend 1 will come because 1 and 2 are invited

- Friend 2 will come because 2 and 3 are invited

- Friend 3 will come because 3 and 4 are invited

- Friend 4 will not come because although 4 and 1 are invited, 1 is invited but 2 is also invited, but it's not necessary for friend 4 to come since only 4 and 1 are needed, but 1 is invited and 2 is also invited, which might be confusing.

Wait, according to the problem, friend i comes if both i and p_i are invited.

So, friend 4 comes if both 4 and p_4=1 are invited. So, if 4 and 1 are invited, friend 4 will come.

But in this case, if Monocarp invites 1,2,3:

- Friend 1: invited and p_1=2 is invited → comes

- Friend 2: invited and p_2=3 is invited → comes

- Friend 3: invited and p_3=4 is invited → comes

- Friend 4: not invited, but p_4=1 is invited → does not come

Wait, no. Friend 4 comes only if both 4 and 1 are invited. In this case, 4 is not invited, so friend 4 does not come.

Wait, but according to the problem, friend i comes if both i and p_i are invited. So, for friend 4 to come, both 4 and 1 must be invited. In the invitation set {1,2,3}, 4 is not invited, so friend 4 does not come.

So, with invitations to 1,2,3:

- Friend 1 comes (1 and 2 invited)

- Friend 2 comes (2 and 3 invited)

- Friend 3 comes (3 and 4 invited, but 4 is not invited, so friend 3 does not come)

Wait, no. According to the problem, friend 3 comes if both 3 and p_3=4 are invited. Since 4 is not invited, friend 3 does not come.

Wait, but in the problem's second test case explanation, they say that friends 1 and 2 will attend if invitations are sent to 1,2,3. Wait, let's check the problem again.

In the second test case, p = [2,3,4,1], and Monocarp sends invitations to friends [1,2,3]. Then:

- Friend 1 comes if both 1 and p_1=2 are invited. Both are invited, so friend 1 comes.

- Friend 2 comes if both 2 and p_2=3 are invited. Both are invited, so friend 2 comes.

- Friend 3 comes if both 3 and p_3=4 are invited. 3 is invited, but 4 is not invited, so friend 3 does not come.

- Friend 4 comes if both 4 and p_4=1 are invited. 4 is not invited, so friend 4 does not come.

So, friends 1 and 2 come. But according to the problem, it's impossible to have at least two friends come with fewer than three invitations.

Wait, but is there a better way? Let's see.

If Monocarp invites friends 1,2,4:

- Friend 1: 1 and 2 invited → comes

- Friend 2: 2 and 3 invited, but 3 is not invited → does not come

- Friend 3: 3 and 4 invited, but 3 is not invited → does not come

- Friend 4: 4 and 1 invited → comes

So, friends 1 and 4 come. That also satisfies the condition with three invitations.

Is there a way to have at least two friends come with only two invitations?

Suppose Monocarp invites friends 1 and 2:

- Friend 1: 1 and 2 invited → comes

- Friend 2: 2 and 3 invited, but 3 is not invited → does not come

- Friend 3: 3 and 4 invited, but 3 is not invited → does not come

- Friend 4: 4 and 1 invited, but 4 is not invited → does not come

So, only friend 1 comes, which is not enough.

Inviting friends 1 and 3:

- Friend 1: 1 and 2 invited → comes

- Friend 2: 2 and 3 invited, but 2 is not invited (since only 1 and 3 are invited) → does not come

- Friend 3: 3 and 4 invited, but 4 is not invited → does not come

- Friend 4: 4 and 1 invited, but 4 is not invited → does not come

So, only friend 1 comes.

Inviting friends 1 and 4:

- Friend 1: 1 and 2 invited → comes

- Friend 2: 2 and 3 invited, but 2 is not invited → does not come

- Friend 3: 3 and 4 invited, but 3 is not invited → does not come

- Friend 4: 4 and 1 invited → comes

So, friends 1 and 4 come. That works with two invitations.

Wait, but in the problem's explanation, they say it's impossible to send invitations to fewer than three friends in such a way that at least two come. But according to this, inviting friends 1 and 4 makes friends 1 and 4 come.

Is there a mistake in the problem's explanation?

Wait, in the problem's second test case, p = [2,3,4,1], which forms a cycle: 1 -> 2 -> 3 -> 4 -> 1.

If Monocarp invites friends 1 and 4:

- Friend 1: 1 and 2 invited → comes

- Friend 2: 2 and 3 invited, but 2 is not invited → does not come

- Friend 3: 3 and 4 invited, but 3 is not invited → does not come

- Friend 4: 4 and 1 invited → comes

So, friends 1 and 4 come. That seems to work with only two invitations.

But according to the problem's sample output, it's 3. So, maybe there's a constraint I'm missing.

Wait, perhaps there's a constraint that the invitation must be such that the friends who come are those who have both them and their best friend invited, but not necessarily that their best friend comes.

Wait, re-reading the problem:

"The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, friend i comes if both i and p_i are invited. It doesn't matter whether p_i comes or not, as long as p_i is invited.

In the previous example, inviting friends 1 and 4:

- Friend 1 comes because 1 and 2 are invited.

- Friend 4 comes because 4 and 1 are invited.

So, friends 1 and 4 come.

Then, why does the problem say it's impossible to have at least two friends come with fewer than three invitations? Maybe I misread.

Wait, in the problem's explanation for the second test case, they say:

"In the second testcase, Monocarp can send invitations to friends 1,2 and 3 , for example. Then friends 1 and 2 will attend: friend 1 and his best friend 2 have invitations, friend 2 and his best friend 3 have invitations. Friend 3 won't come since his friend 4 doesn't have an invitation. It's impossible to send invitations to fewer than 3 friends in such a way that at least 2 come."

But according to my earlier reasoning, inviting friends 1 and 4 makes friends 1 and 4 come. So, perhaps the problem's explanation is incorrect, or I'm misunderstanding something.

Wait, perhaps there's a misunderstanding in the problem statement.

Let me read the problem statement again carefully.

"the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, for friend i to come, both i and p_i must receive invitations. It doesn't matter whether p_i comes or not, just that p_i is invited.

In the second test case, p = [2,3,4,1], which is a cycle: 1 -> 2 -> 3 -> 4 -> 1.

If Monocarp invites friends 1 and 4:

- Friend 1 comes because 1 and 2 are invited.

- Friend 4 comes because 4 and 1 are invited.

- Friend 2 does not come because, although 2 is invited, p_2=3 is invited only if 3 is invited.

Wait, no. For friend 2 to come, both 2 and p_2=3 must be invited. But in this case, 2 is invited (since 1 and 4 are invited, but 2 is not directly invited unless 1's invitation counts for 2, which it doesn't.

Wait, no. Each invitation is sent to exactly one friend. So, if Monocarp invites friends 1 and 4, then only friends 1 and 4 receive invitations.

Wait, but in the problem's logic, friend 1 comes if both 1 and 2 are invited. But in this case, only 1 and 4 are invited. So, friend 1 requires that both 1 and 2 are invited. Friend 4 requires that both 4 and 1 are invited.

If Monocarp invites friends 1 and 4, then:

- Friend 1: 1 is invited, but p_1=2 is not invited → friend 1 does not come.

- Friend 4: 4 is invited, and p_4=1 is invited → friend 4 comes.

So, only friend 4 comes.

Wait, that's different from what I thought earlier. So, in this case, inviting friends 1 and 4 would only make friend 4 come, because friend 1 requires that both 1 and 2 are invited, but 2 is not invited.

Therefore, friend 1 does not come.

So, in this case, only friend 4 comes.

Hence, inviting friends 1 and 4 is not sufficient to make at least two friends come.

Wait, but in my earlier reasoning, I thought friend 1 would come because 1 and 2 are invited, but 2 is not invited in this scenario. So, friend 1 does not come.

Therefore, only friend 4 comes.

Hence, it's indeed impossible to have at least two friends come with only two invitations in this case.

So, the minimal number is three invitations, as per the problem's explanation.

I must have misremembered the condition earlier.

Therefore, in the second test case, it's impossible to have at least two friends come with only two invitations.

Now, I need to generalize this to find the minimal number of invitations for any given n and p.

Looking back at the problem, p is a permutation without fixed points, and all p_i are distinct.

Given that, p represents a permutation where no one is their own best friend.

I need to find the minimal number of invitations such that at least two friends come, where a friend comes if both they and their best friend are invited.

Given that, I need to select a subset S of friends to invite such that:

- For at least two friends i, both i and p_i are in S.

I need to minimize the size of S.

This sounds like a set cover problem, where I need to cover at least two friends' requirements.

Alternatively, since p is a permutation without fixed points, it can be decomposed into disjoint cycles.

In the second test case, p = [2,3,4,1], which is a single 4-cycle: 1 -> 2 -> 3 -> 4 -> 1.

In this case, to have at least two friends come, I need to select a subset S such that at least two friends i have both i and p_i in S.

In a cycle of length 4, selecting any two adjacent friends will only satisfy one friend's requirement, as seen earlier.

Selecting three consecutive friends will satisfy two friends' requirements.

Hence, in a cycle of length 4, the minimal number of invitations to make at least two friends come is three.

In the first test case, p = [3,1,2,5,4], which has two cycles: 1 -> 3 -> 2 -> 1 (cycle length 3) and 4 -> 5 -> 4 (cycle length 2).

In this case, selecting friends 4 and 5 will make both friends 4 and 5 come, since 4 and 5 are invited, and their best friends are 5 and 4, respectively, who are also invited.

Hence, with two invitations, two friends come.

In the third test case, n=2, p=[2,1], which is a cycle of length 2.

Selecting both friends 1 and 2 will make both come, since each requires the other to be invited.

Hence, with two invitations, two friends come.

So, in general, for cycles of even length, selecting half the cycle makes at least half the friends come.

But in the second test case, with a cycle of length 4, selecting two friends doesn't necessarily make two friends come, as seen earlier.

Hence, I need a general approach to find the minimal number of invitations to make at least two friends come.

Let me consider the graph representation.

Since p is a permutation without fixed points and all p_i are distinct, it forms a directed graph where each node has out-degree 1 and in-degree 1, forming disjoint cycles.

In this graph, each cycle is a sequence of friends where each points to their best friend.

To have a friend come, both the friend and their best friend must be invited.

In other words, in the cycle, to have a friend come, we need to select both the friend and their best friend.

But since the cycle is circular, selecting pairs might overlap.

Wait, perhaps I should think in terms of selecting edges in the cycle.

Each friend coming corresponds to selecting the edge from the friend to their best friend, and requiring that both endpoints are invited.

But I need to minimize the number of invitations, which is the number of friends invited, such that at least two specific friends (who have both them and their best friend invited) come.

This seems tricky.

An alternative approach is to consider that for any friend to come, their best friend must also be invited.

Hence, if I invite friend i, I must also invite p_i for friend i to come.

But, if I invite p_i, friend i does not necessarily come, unless I also invite i.

Hence, to make friend i come, I need to invite both i and p_i.

Similarly, to make friend p_i come, I need to invite both p_i and p_{p_i}.

This seems interdependent.

Wait, perhaps I can model this as selecting subsets where certain pairs must be selected together.

This sounds like selecting edges in the cycle such that at least two friends have both endpoints selected.

But I need to minimize the total number of invitations, which is the number of unique friends invited.

This seems similar to a dominating set problem, but not quite.

Let me consider small cycle sizes.

For a cycle of length 2: friends A and B, where A's best friend is B and B's best friend is A.

To have at least two friends come, I need to invite both A and B, which makes both come.

Hence, minimal invitations are two.

For a cycle of length 3: A -> B -> C -> A.

To have at least two friends come, I need to invite A, B, and C.

Wait, no.

Wait, in a cycle of length 3, inviting any two adjacent friends will make one friend come.

For example, invite A and B:

- Friend A: A and B are invited → comes

- Friend B: B and C are invited → comes

- Friend C: C and A are invited, but C is not invited → does not come

So, with two invitations, two friends come.

Wait, but in the first test case, which has a cycle of length 3 (1 -> 3 -> 2 -> 1), inviting friends 1 and 3 makes friend 1 come, and friend 3 does not come because although 3 is invited, p_3=2 is not invited.

Wait, p = [3,1,2,5,4]:

- Friend 1: p_1=3

- Friend 2: p_2=1

- Friend 3: p_3=2

- Friend 4: p_4=5

- Friend 5: p_5=4

So, in the cycle 1 -> 3 -> 2 -> 1:

If I invite friends 1 and 3:

- Friend 1: 1 and 3 are invited → comes

- Friend 3: 3 and 2 are invited, but 2 is not invited → does not come

- Friend 2: 2 and 1 are invited, but 2 is not invited → does not come

- Friend 4: 4 and 5 are invited, but 4 is not invited → does not come

- Friend 5: 5 and 4 are invited, but 5 is not invited → does not come

So, only friend 1 comes.

Wait, but in the problem's first test case, they say inviting friends 4 and 5 makes friends 4 and 5 come.

Wait, in that case:

- Friend 4: 4 and 5 are invited → comes

- Friend 5: 5 and 4 are invited → comes

Hence, with two invitations, two friends come.

But in the cycle of length 3, inviting two friends does not make two friends come, as per my earlier calculation.

Wait, perhaps I need to invite friends such that their best friends are also invited.

In the cycle of length 3, to have at least two friends come, I need to invite all three friends.

Wait, let's see.

If I invite friends 1, 2, and 3:

- Friend 1: 1 and 3 are invited → comes

- Friend 2: 2 and 1 are invited → comes

- Friend 3: 3 and 2 are invited → comes

Hence, all three friends come.

But that's more than needed.

Wait, but earlier when I invited only two friends in the cycle of three, only one friend came.

Hence, to have at least two friends come in a cycle of three, I need to invite all three friends.

Wait, but in the first test case, there are two cycles: one of length 3 and one of length 2.

In that case, inviting two friends from the cycle of length 2 makes two friends come.

But in the cycle of length 3, inviting two friends only makes one friend come.

Hence, in the first test case, inviting friends 4 and 5 from the cycle of length 2 makes two friends come.

In the second test case, with a single cycle of length 4, inviting three friends makes two friends come.

In the third test case, a cycle of length 2, inviting two friends makes two friends come.

Hence, perhaps in cycles of even length, inviting half the cycle makes at least half the friends come, and in cycles of odd length, inviting all friends is needed to make all friends come.

But in the first test case, with a cycle of length 3 and a cycle of length 2, inviting two friends from the cycle of length 2 is sufficient.

Hence, perhaps the minimal number of invitations is the sum of the minimal invitations needed for each cycle, considering how to make at least two friends come across all cycles.

But in the first test case, with cycles of length 3 and 2, inviting two friends from the cycle of length 2 is sufficient.

In the second test case, a single cycle of length 4, inviting three friends is needed to make two friends come.

In the third test case, a single cycle of length 2, inviting two friends makes two friends come.

Hence, perhaps for cycles of length 2, inviting two friends makes two friends come.

For cycles of length 3, inviting three friends makes three friends come.

For cycles of length 4, inviting three friends makes two friends come.

Generalizing, for even-length cycles, inviting k friends can make k/2 friends come, where k is the number of invitations.

Wait, in the cycle of length 4, inviting three friends makes two friends come.

Similarly, in a cycle of length 6, perhaps inviting four friends makes three friends come.

But I need to make at least two friends come.

Hence, perhaps for cycles of even length 2k, the minimal number of invitations to make at least two friends come is k+1.

In the cycle of length 4, it's 3 invitations to make two friends come.

In a cycle of length 2, it's 2 invitations to make two friends come.

In a cycle of length 6, it would be 4 invitations to make three friends come.

But I need to confirm this.

Alternatively, perhaps it's related to the number of edges that need to be selected in the cycle graph to ensure that at least two specific edges have both endpoints invited.

This seems complicated.

An alternative approach is to model this as a graph where each friend is a node, and an edge exists between i and p_i.

Since p is a permutation without fixed points and all p_i are distinct, it's a perfect matching or a collection of cycles.

Given that, I can consider each cycle separately and determine the minimal number of invitations to make at least a certain number of friends come.

But since the cycles are disjoint, the total minimal number of invitations is the sum of the minimal invitations for each cycle.

However, in the first test case, there are two cycles: one of length 3 and one of length 2.

Inviting two friends from the cycle of length 2 is sufficient to make two friends come.

In the cycle of length 3, inviting all three friends is needed to make all three come.

But since we already have two friends coming from the cycle of length 2, we don't need to invite anyone from the cycle of length 3.

Hence, in that case, inviting two friends is sufficient.

In the second test case, a single cycle of length 4, inviting three friends makes two friends come.

In the third test case, a single cycle of length 2, inviting two friends makes two friends come.

Hence, perhaps for a single cycle of even length 2k, the minimal number of invitations to make at least two friends come is k+1.

Wait, in the cycle of length 2, inviting two friends makes two friends come, which is k+1=2 invitations.

In the cycle of length 4, inviting three friends makes two friends come, which is k+1=3 invitations.

Similarly, in a cycle of length 6, it would be four invitations to make three friends come.

But in the first test case, with a cycle of length 3, inviting all three friends makes three friends come, which is ceil(3/2)=2 invitations to make two friends come, but in reality, inviting two friends only makes one friend come, so perhaps it's floor(n/2)+1.

Wait, in cycle of length 3, floor(3/2)+1=2+1=3 invitations to make at least two friends come.

In cycle of length 4, floor(4/2)+1=2+1=3 invitations to make at least two friends come.

In cycle of length 2, floor(2/2)+1=1+1=2 invitations to make at least two friends come.

This seems consistent with the earlier observations.

Hence, for a cycle of length n, the minimal number of invitations to make at least two friends come is floor(n/2)+1.

But in the first test case, with cycles of length 3 and 2, inviting two friends from the cycle of length 2 makes two friends come, which is less than floor(3/2)+1=2 for the cycle of length 3, but since the cycle of length 2 already provides two friends coming, we don't need to consider the other cycle.

Hence, perhaps for multiple cycles, the minimal invitations is the minimal over all cycles of floor(n/2)+1, but considering that friends from different cycles are independent.

Wait, no. Since cycles are disjoint, the total minimal invitations is the sum of the minimal invitations for each cycle, but only to the extent needed to make at least two friends come.

Hence, if one cycle can provide at least two friends coming, we can focus on that cycle.

Otherwise, we need to combine invitations from multiple cycles.

In the first test case, the cycle of length 2 can provide two friends coming with two invitations, which is sufficient.

Hence, the minimal invitations are two.

In the second test case, a single cycle of length 4 requires three invitations to make two friends come.

In the third test case, a single cycle of length 2 requires two invitations to make two friends come.

Hence, the general approach is:

- Decompose the permutation into disjoint cycles.

- For each cycle, determine the minimal number of invitations needed to make at least two friends come.

- Since cycles are independent, the total minimal invitations is the minimal sum across all cycles to make at least two friends come.

But this seems too general. Perhaps there's a simpler way.

An alternative approach is to consider that to make a friend come, both the friend and their best friend must be invited.

Hence, for any friend to come, their best friend must also be invited.

Hence, the minimal number of invitations is the minimal number of friends to invite such that at least two friends have their best friends also invited.

This can be modeled as selecting a subset S of friends to invite, such that there are at least two friends i in S where p_i is also in S.

This is similar to selecting a dominating set in a graph.

But perhaps there's a better way.

Let me consider that each pair (i, p_i) forms an edge in a graph.

Since p is a permutation without fixed points and all p_i are distinct, it forms a perfect matching or a collection of cycles.

Given that, I can think in terms of matching.

But I need to minimize the number of invitations such that at least two friends have both them and their best friend invited.

An alternative way is to consider that each friend coming requires that both i and p_i are invited.

Hence, to have at least two friends come, I need at least two such pairs (i, p_i) to be fully invited.

This can be seen as selecting at least two edges from the permutation graph such that these edges are fully included in the invited set.

But I need to minimize the total number of unique friends invited.

Hence, it's similar to covering at least two edges with minimal number of vertices.

In graph theory, this is related to edge cover, but with a twist that I need to cover at least two specific edges.

But this seems complicated.

An alternative approach is to consider that for each friend to come, both i and p_i must be invited.

Hence, to have at least two friends come, I need to select at least two such pairs.

The minimal number of invitations would be the minimal number of unique friends needed to cover at least two such pairs.

In other words, select a subset S of friends such that there are at least two friends i in S where p_i is also in S.

This seems similar to selecting a subset S where the number of edges (i, p_i) fully contained in S is at least two.

This is a classic problem in graph theory, and it can be solved by finding a minimal subset S such that the number of edges fully contained in S is at least two.

But finding such a minimal subset is non-trivial.

An alternative approach is to consider the complement: select a subset S such that the number of edges not fully contained in S is at most |E| - 2, where |E| is the number of edges.

But this seems too vague.

Perhaps I can consider the following:

- For each possible subset S of friends, check if at least two friends i in S have p_i also in S.

- Find the minimal |S| such that this condition holds.

But this is exponential in n, which is not feasible for n up to 50.

Hence, I need a better approach.

Looking back at the test cases:

- First test case: n=5, p=[3,1,2,5,4], which has cycles of length 3 and 2.

- Minimal invitations: 2

- Second test case: n=4, p=[2,3,4,1], cycle of length 4.

- Minimal invitations: 3

- Third test case: n=2, p=[2,1], cycle of length 2.

- Minimal invitations: 2

Hence, perhaps for cycles of even length, the minimal invitations are ceil(n/2) + 1.

Wait, in the cycle of length 4, ceil(4/2)+1=3, which matches the second test case.

In the cycle of length 2, ceil(2/2)+1=2, which matches the third test case.

In the cycle of length 3, ceil(3/2)+1=3, which would require inviting all three friends to make all three come, but in the first test case, since there is also a cycle of length 2, inviting two friends from the cycle of length 2 is sufficient.

Hence, perhaps for multiple cycles, the minimal invitations are the minimal over the cycles of ceil(n/2)+1, but considering that friends from different cycles are independent.

But in the first test case, with cycles of length 3 and 2, inviting two friends from the cycle of length 2 is sufficient, which is less than ceil(3/2)+1=3 for the cycle of length 3.

Hence, perhaps the minimal invitations are the minimal ceil(n/2)+1 over all cycles, but considering that if one cycle can provide the required number of friends coming, we can focus on that cycle.

Wait, perhaps it's better to think in terms of selecting friends such that the number of friends who have both them and their best friend invited is at least two.

Hence, the goal is to maximize the number of such friends for a given number of invitations.

But I need to minimize the number of invitations such that at least two friends come.

An alternative approach is to iterate over the possible subsets of friends to invite, and find the minimal subset where at least two friends have both them and their best friend invited.

But this is exponential and not feasible for n=50.

Hence, I need a smarter approach.

Let me consider that to make friend i come, both i and p_i must be invited.

Hence, to have at least two friends come, I need at least two such pairs (i, p_i) to be fully invited.

These pairs are disjoint since p is a permutation without fixed points.

Hence, the friends in these pairs are distinct.

Hence, the minimal number of invitations is at least twice the number of such pairs.

But I need at least two friends to come, which requires at least two such pairs.

Hence, the minimal number of invitations is at least 4.

But in the first test case, inviting only two friends makes two friends come.

Wait, perhaps I'm missing something.

Wait, in the first test case, p = [3,1,2,5,4], which has two cycles: 1 -> 3 -> 2 -> 1 and 4 -> 5 -> 4.

If I invite friends 4 and 5, then both 4 and 5 are invited, and their best friends 5 and 4 are also invited, so both friends 4 and 5 come.

Hence, with two invitations, two friends come.

Similarly, in the third test case, inviting friends 1 and 2 makes both come.

In the second test case, with a single cycle of length 4, inviting three friends makes two friends come.

Hence, perhaps for cycles of even length, the minimal invitations are two, but in the second test case, it's three.

Wait, perhaps I need to consider the structure of the cycles.

Wait, in the first test case, there are two cycles: one of length 3 and one of length 2.

By inviting two friends from the cycle of length 2, I can make two friends come.

In the second test case, a single cycle of length 4 requires three invitations to make two friends come.

In the third test case, a single cycle of length 2 requires two invitations to make two friends come.

Hence, perhaps for a cycle of length k, the minimal invitations to make at least two friends come is min(k, 2) + some adjustment.

But in the second test case, with k=4, it's 3 invitations.

Hence, perhaps it's ceil(k/2) +1 for k >=3.

Wait, for k=3, ceil(3/2)+1=3, which matches the first test case's cycle of length 3.

For k=4, ceil(4/2)+1=3, which matches the second test case.

For k=2, ceil(2/2)+1=2, which matches the third test case.

Hence, perhaps for each cycle of length k, the minimal invitations to make at least two friends come is ceil(k/2)+1.

But in the first test case, with cycles of length 3 and 2, inviting two friends from the cycle of length 2 is sufficient, which is less than ceil(3/2)+1=3 for the cycle of length 3.

Hence, perhaps the overall minimal invitations is the minimal over all cycles of ceil(k/2)+1, but considering that friends from different cycles can be combined.

Hence, in the first test case, since there is a cycle of length 2 where ceil(2/2)+1=2, and a cycle of length 3 where ceil(3/2)+1=3, the overall minimal invitations is 2.

In the second test case, a single cycle of length 4 requires ceil(4/2)+1=3 invitations.

In the third test case, a single cycle of length 2 requires ceil(2/2)+1=2 invitations.

Hence, the general approach is:

- Decompose the permutation into disjoint cycles.

- For each cycle, calculate the minimal invitations needed to make at least two friends come, which is ceil(k/2)+1, where k is the