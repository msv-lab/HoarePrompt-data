Alright, I've got this problem to solve. Let's see what it's asking for. So, Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The important points are:

1. All p_i are distinct and p_i ≠ i. So, no one is their own best friend, and everyone has a unique best friend.

2. For a friend to come to the party, both the friend and their best friend must receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

My task is to determine the minimum number of invitations needed for each test case.

First, I need to understand the relationship between the friends and their best friends. Since p_i is the best friend of friend i, and all p_i are distinct, this means that the best friend relationships form a permutation of the friends. In other words, it's like matching each friend to another unique friend as their best friend.

Given that, I can think of these relationships as pairs or cycles. For example, if friend 1's best friend is 2, and friend 2's best friend is 1, that's a cycle of length 2. If friend 1's best friend is 2, friend 2's best friend is 3, and friend 3's best friend is 1, that's a cycle of length 3, and so on.

Now, the condition for a friend to come to the party is that both the friend and their best friend receive an invitation. So, in terms of cycles, if I have a cycle of length 2, like friends 1 and 2 are each other's best friends, then to get both to come, I need to invite both 1 and 2. That means I need to send 2 invitations to get 2 friends to come.

But wait, the problem says "at least 2 friends come to the party." So, perhaps there are ways to get more friends to come with fewer invitations, depending on the structure of the cycles.

Let me consider some examples.

Example 1:

n = 5

p = [3, 1, 2, 5, 4]

So, friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

Looking at this, we have two cycles: one of length 3 (1-3-2) and one of length 2 (4-5).

In the solution, it says that sending invitations to friends 4 and 5 is enough, because both will come since they and their best friends are invited. So, that's 2 invitations, and 2 friends come.

Example 2:

n = 4

p = [2, 3, 4, 1]

So, friend 1's best friend is 2, friend 2's best friend is 3, friend 3's best friend is 4, and friend 4's best friend is 1. This is a single cycle of length 4.

The solution says that you need to send invitations to 3 friends, like 1, 2, and 3. Then, friends 1 and 2 will come because both and their best friends are invited. Friend 3 won't come because his best friend 4 isn't invited. So, only friends 1 and 2 come, which satisfies the condition of at least 2 friends coming.

It also mentions that it's impossible to do it with fewer than 3 invitations.

Example 3:

n = 2

p = [2, 1]

This is a cycle of length 2. Sending invitations to both friends 1 and 2 will make both come. So, 2 invitations.

From these examples, it seems that:

- In a cycle of length 2, sending 2 invitations makes both friends come.

- In a cycle of length 3 or more, sending invitations to all but one friend in the cycle makes at least two friends come.

Wait, in the second example, with a cycle of 4, sending invitations to 3 friends makes 2 friends come. Is there a general formula here?

Let's think about cycles separately and then combine the results.

Suppose we have a cycle of length k.

To get at least one friend to come from this cycle, how many invitations do we need to send?

Well, to get one friend to come, we need to invite both that friend and their best friend. But in a cycle, the best friends are connected, so inviting a subset of friends affects others.

Actually, in a cycle of length k, the minimum number of invitations to get at least two friends to come is Ceiling(k / 2). Wait, is that right?

Wait, in the first example, cycle of length 3 needs 2 invitations to get 2 friends to come. Cycle of length 2 needs 2 invitations to get 2 friends to come. Cycle of length 4 needs 3 invitations to get 2 friends to come.

Wait, Ceiling(3/2) = 2, which matches the first case. Ceiling(4/2) = 2, but in the second example, it says you need 3 invitations. So maybe that's not the right approach.

Wait, perhaps it's more nuanced.

Let me think differently.

Suppose I have a cycle of length k.

To get at least two friends to come, I need to select a set of friends to invite such that at least two friends have both themselves and their best friends invited.

In a cycle, each friend's best friend is uniquely determined.

Maybe I can model this as a graph where friends are nodes, and best friend relationships are edges.

Then, inviting a friend corresponds to selecting a node, and for a node to "come," both it and its neighbor (best friend) are selected.

So, in graph terms, I need to select a subset S of nodes such that at least two nodes in S have their neighbors also in S.

This seems a bit tricky.

Alternatively, perhaps I can think in terms of matching.

Wait, perhaps it's better to consider that each invited friend who comes requires their best friend to also be invited.

But in this problem, it's slightly different because the condition is that a friend comes only if both they and their best friend are invited.

So, if I invite friend i and their best friend p_i, then friend i comes.

Similarly, if I invite friend p_i and their best friend p_{p_i}, then friend p_i comes, and so on.

But the goal is to have at least two friends come to the party.

I need to minimize the number of invitations sent.

Let me consider that each "coming" friend requires both themselves and their best friend to be invited.

So, to have friend i come, I need to invite both i and p_i.

But p_i is someone else's best friend, so inviting p_i might be necessary for someone else to come.

Wait, perhaps I can think in terms of selecting pairs of friends who are each other's best friends.

In the first example, friends 1, 2, and 3 form a cycle of length 3, where 1's best friend is 3, 3's best friend is 2, and 2's best friend is 1.

In this case, to get friend 1 to come, I need to invite both 1 and 3.

Similarly, to get friend 2 to come, I need to invite both 2 and 1.

But since p_i are distinct and p_i ≠ i, and all p_i are distinct, there are no two friends who are each other's best friends, unless n is even and it's a perfect matching.

Wait, no, in the first example, n=5, p=[3,1,2,5,4], so friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

So, there is a cycle of length 3 (1-3-2) and a cycle of length 2 (4-5).

In this case, to get friends 4 and 5 to come, I need to invite both 4 and 5.

Similarly, to get friends 1, 2, and 3 to come, I need to invite at least two pairs.

Wait, but in the first example, the solution says that inviting 4 and 5 is enough to get two friends to come.

Wait, but in that case, both 4 and 5 are invited, and since 4's best friend is 5 and 5's best friend is 4, both have their best friends invited, so both will come.

Wait, but in the first example, it says that friends 4 and 5 will come if I invite both.

But in the provided program, it seems to suggest that in some cases, you can have cycles where inviting two friends is enough, and in other cases, you need to invite three.

Looking back at the program:

def func():

for _ in range(int(input())):

n = int(input())

l = list(map(int, input().split()))

i = 0

j = 0

while i <= n - 1:

if l[i] == i + 2 and l[i + 1] == i + 1:

print(2)

j = 1

break

i += 1

if j == 0:

print(3)

This seems too simplistic. It's checking if there exists a pair of friends where friend i's best friend is i+2 and friend i+1's best friend is i+1, which doesn't make much sense because according to the problem, p_i ≠ i, and p_i is 1-based index.

Wait, p_i is the best friend's index, starting from 1.

So, l[i] is the best friend of friend i+1.

Wait, in Python, list indices start from 0, but the friends are labeled from 1 to n.

So, l[i] is p_{i+1}, which is the best friend of friend i+1.

The condition in the program is checking if l[i] == i + 2 and l[i + 1] == i + 1.

So, for friend i+1, best friend is i + 2, and for friend i + 2, best friend is i + 1.

This seems like it's checking for a cycle of length 2 between friends i+1 and i+2.

But in the problem, cycles of length 2 would be friend a's best friend is b, and friend b's best friend is a.

However, in the first example, friends 4 and 5 form such a cycle, and the program seems to detect that and print 2.

Similarly, in the third example, n=2, p=[2,1], which is a cycle of length 2, and the program would print 2.

In the second example, n=4, p=[2,3,4,1], which is a cycle of length 4, and the program wouldn't find a pair where l[i] == i + 2 and l[i + 1] == i + 1, so it would print 3.

But according to the problem, in the second example, you need to send 3 invitations to get at least 2 friends to come.

So, perhaps the program is correct.

But is this general?

Let me think about other cases.

Case 1: n=2, p=[2,1] → cycle of length 2 → need 2 invitations.

Case 2: n=3, p=[2,3,1] → cycle of length 3.

In this case, to get at least 2 friends to come, do I need to invite 2 or 3 friends?

If I invite friend 1 and friend 2, then friend 1 has best friend 2, who is invited, so friend 1 comes.

Friend 2 has best friend 3, who is not invited, so friend 2 does not come.

Similarly, friend 3 has best friend 1, who is invited, but friend 3 is not invited, so friend 3 does not come.

So, only friend 1 comes, which is less than 2.

If I invite friend 1 and friend 3, then friend 1 has best friend 2, who is not invited, so friend 1 does not come.

Friend 3 has best friend 1, who is invited, so friend 3 comes.

So, only friend 3 comes, which is less than 2.

If I invite friend 2 and friend 3, then friend 2 has best friend 3, who is invited, so friend 2 comes.

Friend 3 has best friend 1, who is not invited, so friend 3 does not come.

So, only friend 2 comes.

If I invite all three, friend 1 has best friend 2, who is invited, so friend 1 comes.

Friend 2 has best friend 3, who is invited, so friend 2 comes.

Friend 3 has best friend 1, who is invited, so friend 3 comes.

So, all three come, which is more than 2, but I had to invite all three.

So, in this case, to get at least 2 friends to come, I need to invite all three.

Wait, but in the first example, with a cycle of 3 and a cycle of 2, inviting 2 friends from the cycle of 2 was enough.

In the second example, with a cycle of 4, inviting 3 friends was enough.

So, perhaps the rule is:

- For cycles of even length, inviting half of the friends is enough to get at least two to come.

- For cycles of odd length, inviting (ceiling of n/2)) is needed.

But in the cycle of 3, inviting 2 friends isn't enough, as shown in the earlier example.

Wait, in the cycle of 3, inviting 2 friends only makes one friend come.

So, to get at least 2 friends to come in a cycle of 3, I need to invite all 3.

Similarly, in a cycle of 4, inviting 3 friends makes 2 friends come, as in the second example.

In a cycle of 2, inviting 2 friends makes both come.

So, perhaps the general rule is:

- For cycles of length 2, inviting 2 friends makes 2 come.

- For cycles of length k > 2, inviting k - 1 friends makes k - 1 friends come, but to ensure at least 2 come, if k >= 3, inviting k - 1 friends makes k - 1 friends come, which is at least 2 when k >= 3.

Wait, but in the cycle of 3, inviting 2 friends only makes 1 come.

Wait, maybe that's not correct.

Wait, perhaps I need to think differently.

Let me consider that in any cycle, to have at least two friends come, I need to invite enough friends such that at least two of them have their best friends also invited.

In a cycle of length 2: friends A and B, A's best friend is B, B's best friend is A.

If I invite both A and B, then both come.

If I invite only one, say A, then A has best friend B, who is not invited, so A doesn't come.

Similarly for B.

So, for a cycle of 2, inviting both is necessary to get both to come.

In a cycle of 3: friends A, B, C; A's best friend is B, B's best friend is C, C's best friend is A.

If I invite A and B, then:

- A has best friend B, who is invited, so A comes.

- B has best friend C, who is not invited, so B does not come.

- C has best friend A, who is invited, but C is not invited, so C does not come.

So, only A comes.

If I invite A and C:

- A has best friend B, who is not invited, so A does not come.

- C has best friend A, who is invited, so C comes.

- B has best friend C, who is invited, but B is not invited, so B does not come.

So, only C comes.

If I invite B and C:

- B has best friend C, who is invited, so B comes.

- C has best friend A, who is not invited, so C does not come.

- A has best friend B, who is invited, but A is not invited, so A does not come.

So, only B comes.

If I invite all three:

- A has best friend B, who is invited, so A comes.

- B has best friend C, who is invited, so B comes.

- C has best friend A, who is invited, so C comes.

So, all come.

Therefore, in a cycle of 3, to have at least two friends come, I need to invite all three.

Similarly, in a cycle of 4: friends A, B, C, D; A's best friend is B, B's best friend is C, C's best friend is D, D's best friend is A.

If I invite A, B, and C:

- A has best friend B, who is invited, so A comes.

- B has best friend C, who is invited, so B comes.

- C has best friend D, who is not invited, so C does not come.

- D has best friend A, who is invited, but D is not invited, so D does not come.

So, A and B come.

If I invite A, B, and D:

- A has best friend B, who is invited, so A comes.

- B has best friend C, who is not invited, so B does not come.

- D has best friend A, who is invited, so D comes.

So, A and D come.

If I invite A, C, and D:

- A has best friend B, who is not invited, so A does not come.

- C has best friend D, who is invited, so C comes.

- D has best friend A, who is invited, so D comes.

So, C and D come.

If I invite B, C, and D:

- B has best friend C, who is invited, so B comes.

- C has best friend D, who is invited, so C comes.

- D has best friend A, who is not invited, so D does not come.

So, B and C come.

If I invite only A, B, and one more, say C, then A and B come, as shown above.

So, in a cycle of 4, inviting 3 friends makes 2 come.

Similarly, in a cycle of 5, inviting 3 friends might make 2 come.

Wait, let's consider n=5, with two cycles: one of length 3 and one of length 2, as in the first example.

In that case, inviting 2 friends from the cycle of 2 makes 2 come.

In the second example, a cycle of 4, inviting 3 makes 2 come.

In the third example, a cycle of 2, inviting 2 makes 2 come.

So, perhaps the general rule is:

- For each cycle, determine the minimum invitations needed to get at least 2 friends to come from that cycle.

- Sum the minimum invitations across all cycles.

But in the first example, there are two cycles: one of length 3 and one of length 2.

According to the earlier analysis:

- For the cycle of 3, inviting 3 makes all 3 come.

- For the cycle of 2, inviting 2 makes both come.

But in the solution, inviting only the cycle of 2 (2 invitations) is enough to get 2 friends to come, which satisfies the condition.

So, in that case, I don't need to invite anyone from the cycle of 3.

Similarly, in the second example, a single cycle of 4, inviting 3 makes 2 come.

In the third example, a cycle of 2, inviting 2 makes 2 come.

So, perhaps the rule is:

- If there is a cycle of length 2, then inviting 2 from that cycle is enough.

- If there are only cycles of length >=3, then inviting k-1 from the largest cycle is enough.

But I need to generalize this.

Wait, perhaps it's simpler: in any graph formed by these best friend relationships, which is a disjoint union of cycles, the minimal number of invitations is equal to the minimal number of friends to invite such that at least two have their best friends also invited.

Given that, perhaps in each cycle, the minimal number of invitations needed to get at least two friends to come is equal to the cycle length minus one, for cycles of length >=3, and equal to the cycle length for cycles of length 2.

But in the first example, with a cycle of 3 and a cycle of 2, inviting only the cycle of 2 (2 invitations) is enough, which is less than 3-1=2 for the cycle of 3.

Wait, no, 3-1=2, which is equal to the cycle of 2.

But in that case, inviting the cycle of 2 is enough to satisfy the condition of having at least 2 friends come.

So, perhaps the minimal number of invitations is the minimal over all cycles of the minimal invitations needed to get at least two friends to come from that cycle.

Wait, perhaps it's the minimal number of invitations such that at least one cycle has at least two friends coming.

In that case, for the first example, inviting 2 from the cycle of 2 is enough.

For the second example, with a single cycle of 4, inviting 3 is enough to get 2 to come.

For the third example, inviting 2 from the cycle of 2 is enough.

So, perhaps the formula is:

- If there exists a cycle of length 2, then the minimal number of invitations is 2.

- Otherwise, for cycles of length >=3, the minimal number of invitations is the length of the smallest cycle.

But in the second example, there is no cycle of length 2, and the minimal number of invitations is 3.

Which matches the length of the cycle minus one, which is 4-1=3.

Wait, but in a cycle of length 3, to get at least two friends to come, I need to invite all three.

But according to this, it's cycle length minus one.

Wait, but in the cycle of 3, inviting 2 only makes one come, as earlier.

Wait, maybe it's cycle length minus one for cycles of length >=3.

But in the cycle of 4, inviting 3 makes 2 come.

In the cycle of 3, inviting 2 makes only one come, so need to invite all three to get all three to come.

But to get at least two to come, maybe there's a better way.

Wait, perhaps in cycles of length >=3, the minimal number of invitations to get at least two friends to come is ceiling of (k / 2).

Wait, for k=3, ceiling(3/2)=2, but earlier we saw that inviting 2 in a cycle of 3 only makes one come.

So, that doesn't hold.

Alternatively, maybe it's floor((k+1)/2).

For k=3, floor((3+1)/2)=2, but again, inviting 2 only makes one come.

Wait, perhaps it's different.

Let me think about it differently.

Suppose I have a cycle of length k.

I need to select a subset S of friends to invite such that at least two friends have both themselves and their best friends in S.

This seems similar to selecting a dominating set in a graph, where each node represents a friend, and edges represent best friend relationships.

In a cycle graph, a dominating set is a set of vertices such that every vertex is either in the set or adjacent to a vertex in the set.

But in this problem, the condition is stronger: for a friend to come, both the friend and their best friend must be invited.

So, it's not just a dominating set, but a set where each coming friend has both themselves and their best friend in the set