Alright, I have this problem to solve. Let's read it carefully.

There are n children in a class, and m pairs among them are friends with a friendship value f_i. The teacher goes on k excursions, and for each excursion, she chooses a pair of children randomly and equiprobably. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0 that doesn't change.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, at the time of being chosen. The answer should be in the form of p/q where p and q are coprime, and I need to compute p * q^{-1} mod (10^9 + 7).

First, I need to understand the problem clearly.

There are n children, and m pairs of friends with given friendship values. The teacher chooses k pairs randomly, one for each excursion.

Each time a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

I need to find the expected sum of the friendship values at the time each pair is chosen.

Let's think about how to approach this.

First, let's consider the total number of possible pairs. Since the pairs are chosen without any restriction, the total number of possible pairs is C(n,2) = n*(n-1)/2.

Out of these, m pairs are friends with initial friendship values f_i.

Non-friend pairs have friendship value 0, which never changes.

For friend pairs, each time they are chosen, their friendship value increases by 1 for all subsequent choices.

I need to calculate the expected sum of the friendship values at the time of each choice over k excursions.

Let me think about the process step by step.

Let's denote the friendship value of pair (a,b) at time t as f_{a,b}^(t).

Initially, f_{a,b}^(0) = f_i if (a,b) is a friend pair, else 0.

Each time a friend pair (a,b) is chosen at time t, f_{a,b}^(t) = f_{a,b}^(t-1) + 1, and this increased value is used in all subsequent choices.

Non-friend pairs have f_{a,b}^(t) = 0 for all t.

I need to find the expected value of the sum of f_{a,b}^(t) for each chosen pair at each time t from 1 to k.

This seems a bit complicated. Maybe there's a better way to model this.

Let me consider the contribution of each pair to the total sum.

For each pair, whether friend or not, each time it is chosen, its friendship value at that time is added to the sum.

For non-friend pairs, their contribution is always 0.

For friend pairs, their friendship value increases by 1 each time they are chosen.

So, for a friend pair, if it is chosen c times, its total contribution is f_i + (f_i +1) + (f_i +2) + ... + (f_i +c-1) = c*f_i + c*(c-1)/2.

Wait, but this seems not quite right because the increases are for subsequent choices, not for the same pair being chosen multiple times in a row.

Wait, no. Each time a friend pair is chosen, its friendship value increases by 1 for all subsequent choices.

So, the friendship value at the time of choice t is f_i plus the number of times it has been chosen before t.

Wait, perhaps it's better to think in terms of the number of times a friend pair is chosen in the k excursions.

Let me denote X_{a,b} as the number of times pair (a,b) is chosen in the k excursions.

For a friend pair (a,b), its total contribution to the sum is sum from t=1 to k of f_{a,b}^(t), where f_{a,b}^(t) = f_i + X_{a,b}^{t-1}, with X_{a,b}^{t-1} being the number of times (a,b) has been chosen before time t.

Wait, this seems messy.

Maybe there's a better way.

Let me think about the expectation.

Since the choices are independent and random, perhaps I can compute the expected contribution of each friend pair and sum them up.

For each friend pair (a,b), with initial friendship value f_i, each time it is chosen, its friendship value increases by 1 for all subsequent choices.

So, if it is chosen at times t1, t2, ..., tk, then its contribution is f_i at time t1, f_i +1 at time t2, and so on.

But since the choices are random and independent, perhaps I can model this using linearity of expectation.

Wait, but the choices are independent, but the friendship value increases based on previous choices, which introduces some dependency.

Hmm.

Wait, maybe I can think of the total sum as the sum over all k choices of the friendship value at the time of choice.

So, sum_{t=1 to k} f_{chosen_pair_at_t}^(t)

And I need the expected value of this sum.

Given that the choices are independent and uniform, perhaps I can compute for each choice t, the expected friendship value of the chosen pair at time t, and then sum these expectations over t from 1 to k.

This seems promising.

So, E[sum_{t=1 to k} f_{chosen_pair_at_t}^(t)] = sum_{t=1 to k} E[f_{chosen_pair_at_t}^(t)]

Because of linearity of expectation.

Now, I need to compute E[f_{chosen_pair_at_t}^(t)] for each t.

But f_{chosen_pair_at_t}^(t) depends on the history of choices before t.

Wait, but since the choices are independent and uniform, maybe the expectation at each t is the same.

Wait, but chosen pairs can be chosen multiple times, and their friendship values increase over time.

So, it's not straightforward.

Perhaps I need to model this recursively.

Let me try to model the process.

Letâ€™s denote p = 1 / C(n,2), the probability of choosing any specific pair in one excursion.

For friend pairs, each time they are chosen, their friendship value increases by 1 for all subsequent choices.

So, for a friend pair, if it is chosen c times at times t1 < t2 < ... < tc, then its contribution to the total sum is f_i + (f_i +1) + (f_i +2) + ... + (f_i +c-1) = c*f_i + c*(c-1)/2.

And for non-friend pairs, their contribution is always 0.

So, the total sum is sum over all friend pairs of [c*f_i + c*(c-1)/2], where c is the number of times the pair is chosen.

Wait, but c is random, so I need to take expectation over c.

But c follows a binomial distribution with parameters k and p, where p = 2 / (n*(n-1)).

Wait, no, p = 1 / C(n,2), since C(n,2) is the total number of possible pairs.

So, for each friend pair, the number of times it is chosen, c, follows a binomial distribution with parameters k and p = 1 / C(n,2).

Similarly, for different friend pairs, their c's are independent, since the choices are independent.

Wait, but actually, the choices are without replacement within each excursion, but since n can be large, and k can be up to 2e5, but n can be up to 1e5, so C(n,2) can be up to about 5e9, which is manageable.

But actually, since in each excursion, the pair is chosen uniformly at random from all possible pairs, and choices are independent across excursions, then for any specific pair, the number of times it is chosen in k excursions follows a binomial distribution with parameters k and p = 1 / C(n,2).

Now, for each friend pair, its total contribution to the sum is c * f_i + c * (c - 1) / 2.

So, the total sum S = sum over all friend pairs of [c * f_i + c * (c - 1) / 2].

Now, I need to compute E[S] = sum over all friend pairs of [E[c] * f_i + E[c*(c - 1)/2]].

Wait, but c is binomial with parameters k and p = 1 / C(n,2).

So, E[c] = k * p = k / C(n,2).

Similarly, E[c*(c - 1)] = k*(k - 1)*p^2 + k*p*(1 - p).

Wait, more precisely, for a binomial random variable c ~ Bin(k, p), E[c*(c - 1)] = k*(k - 1)*p^2.

And E[c] = k*p.

So, E[c*(c - 1)/2] = [k*(k - 1)*p^2]/2.

Therefore, for each friend pair, E[contribution] = E[c]*f_i + E[c*(c - 1)/2] = (k*p)*f_i + [k*(k - 1)*p^2]/2.

So, the total expected sum E[S] = sum over all friend pairs of [(k*p)*f_i + [k*(k - 1)*p^2]/2].

Now, since p = 1 / C(n,2), and C(n,2) = n*(n - 1)/2, so p = 2 / (n*(n - 1)).

Therefore, E[S] = sum over all friend pairs of [(k * 2)/(n*(n - 1)) * f_i] + [k*(k - 1)*4/(n*(n - 1))^2]/2.

Wait, let's compute p^2 = [2 / (n*(n - 1))]^2 = 4 / [n^2 * (n - 1)^2].

So, E[S] = sum over all friend pairs of [ (2*k)/(n*(n - 1)) * f_i + (k*(k - 1)*4)/(2*n^2*(n - 1)^2) ].

Simplify the second term: (k*(k - 1)*4)/(2*n^2*(n - 1)^2) = (k*(k - 1)*2)/(n^2*(n - 1)^2).

So, E[S] = sum over all friend pairs of [ (2*k)/(n*(n - 1)) * f_i + (k*(k - 1)*2)/(n^2*(n - 1)^2) ].

Now, there are m friend pairs, so the total E[S] = m * [ (2*k)/(n*(n - 1)) * average f_i + (k*(k - 1)*2)/(n^2*(n - 1)^2) ].

Wait, no, it's sum over all friend pairs, so it's sum over all friend pairs of the first term plus the second term.

Wait, but the second term doesn't depend on f_i, so it's sum over all friend pairs of the first term plus sum over all friend pairs of the second term.

But the second term is the same for all friend pairs, so it's m times that term.

So, E[S] = sum over all friend pairs of (2*k)/(n*(n - 1)) * f_i + m * (k*(k - 1)*2)/(n^2*(n - 1)^2).

Let me denote s = sum of f_i over all friend pairs.

Then, E[S] = (2*k*s)/(n*(n - 1)) + (m * k*(k - 1)*2)/(n^2*(n - 1)^2).

This seems manageable.

Now, I need to compute this expression and output it modulo 1e9+7, after reducing it to p/q with p and q coprime and computing p * q^{-1} mod 1e9+7.

So, first, I need to compute E[S] = (2*k*s)/(n*(n - 1)) + (m * k*(k - 1)*2)/(n^2*(n - 1)^2).

Let me see if I can write this as a single fraction.

Let me find a common denominator.

The first term has denominator n*(n - 1), and the second term has denominator n^2*(n - 1)^2.

So, the common denominator is n^2*(n - 1)^2.

So, E[S] = [ (2*k*s) * n*(n - 1) + (m * k*(k - 1)*2) ] / [n^2*(n - 1)^2].

Wait, no, wait.

Wait, for the first term: (2*k*s)/(n*(n - 1)) = (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2].

Wait, no, to get a common denominator, I need to multiply numerator and denominator of the first term by n*(n - 1).

Wait, no, the first term is (2*k*s)/(n*(n - 1)), and the second term is (m*k*(k - 1)*2)/(n^2*(n - 1)^2).

So, to add them, I need to express the first term over the common denominator n^2*(n - 1)^2.

So, (2*k*s)/(n*(n - 1)) = (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2].

Wait, no, wait. To get the common denominator, I need to multiply numerator and denominator of the first term by n*(n - 1).

So, (2*k*s)/(n*(n - 1)) = (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2].

Wait, no, that would be (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2], but actually, multiplying by n*(n - 1)/n*(n - 1) would give (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2].

But actually, it's better to think of it as:

(2*k*s)/(n*(n - 1)) = (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2].

Wait, no, that's incorrect.

Wait, to express a fraction a/b with denominator d, you multiply numerator and denominator by d/b.

So, to express (2*k*s)/(n*(n - 1)) with denominator n^2*(n - 1)^2, I need to multiply numerator and denominator by n*(n - 1).

So, (2*k*s)/(n*(n - 1)) = (2*k*s * n*(n - 1)) / [n^2*(n - 1)^2].

Similarly, the second term is already over the common denominator.

So, E[S] = [2*k*s * n*(n - 1) + m*k*(k - 1)*2] / [n^2*(n - 1)^2].

Wait, no, let's double-check.

Wait, the second term is (m * k*(k - 1)*2)/(n^2*(n - 1)^2), which is already over the common denominator.

The first term is (2*k*s)/(n*(n - 1)), which becomes (2*k*s * n*(n - 1))/(n^2*(n - 1)^2).

So, E[S] = [2*k*s * n*(n - 1) + m*k*(k - 1)*2] / [n^2*(n - 1)^2].

Yes, that seems correct.

Now, I need to compute this fraction p/q, where p = 2*k*s*n*(n - 1) + m*k*(k - 1)*2, and q = n^2*(n - 1)^2.

Then, reduce p and q to coprime and compute p * q^{-1} mod 1e9+7.

But since n and m can be up to 1e5, and k up to 2e5, and s can be up to m*1e9, which is up to 1e14, and n^2*(n - 1)^2 can be up to around 1e10^10, which is way beyond standard integer types.

So, I need to handle large numbers carefully.

Also, since I need to compute p * q^{-1} mod 1e9+7, I need to compute p modulo 1e9+7, and q^{-1} modulo 1e9+7.

But q must be invertible modulo 1e9+7, which it is if q and 1e9+7 are coprime.

Since 1e9+7 is prime, and q = n^2*(n - 1)^2, which is probably not divisible by 1e9+7 unless n is a multiple of 1e9+7, which it's not, since n <= 1e5.

Wait, n <= 1e5, and 1e9+7 is larger, so n^2*(n - 1)^2 is not divisible by 1e9+7, so q and 1e9+7 are coprime, and q^{-1} exists modulo 1e9+7.

So, I can proceed.

Now, to compute p = 2*k*s*n*(n - 1) + m*k*(k - 1)*2, and q = n^2*(n - 1)^2.

But p can be very large, up to around 2e5 * 1e5 * 1e9 * 1e5 * 1e5 + 1e5 * 2e5 * 2e5, which is way beyond standard integer types.

So, I need to compute p modulo 1e9+7.

But to compute p modulo 1e9+7, I need to compute each term modulo 1e9+7 and then sum them up modulo 1e9+7.

Wait, but actually, p is the numerator, and q is the denominator, and I need to compute (p * q^{-1}) mod 1e9+7.

So, I need to compute p modulo 1e9+7, and q^{-1} modulo 1e9+7, then multiply them modulo 1e9+7.

But p is very large, so I need to compute it step by step, taking modulo at each step to avoid overflow.

So, I need to compute p = 2*k*s*n*(n - 1) + m*k*(k - 1)*2 modulo 1e9+7.

Similarly, q = n^2*(n - 1)^2, and q^{-1} modulo 1e9+7.

But n and m can be up to 1e5, and s up to m*1e9, which is up to 1e14.

So, I need to handle large multiplications carefully.

Let me think about how to compute p modulo 1e9+7.

First, compute s = sum of f_i for all m friend pairs.

Then, compute 2*k*s*n*(n - 1) modulo 1e9+7.

Similarly, compute m*k*(k - 1)*2 modulo 1e9+7.

Then, sum them up modulo 1e9+7.

But n and n - 1 can be up to 1e5, so n*(n - 1) can be up to 1e10, which is manageable if I compute it step by step.

Similarly, n^2*(n - 1)^2 can be up to 1e20, but since I'm computing q modulo 1e9+7, it's manageable.

So, let's outline the steps:

1. Read t, the number of test cases.

2. For each test case:

a. Read n, m, k.

b. Read m lines, each containing a_i, b_i, f_i, and sum f_i to get s.

c. Compute s modulo 1e9+7.

d. Compute n*(n - 1) modulo 1e9+7.

e. Compute n^2 modulo 1e9+7.

f. Compute (n*(n - 1))Â² modulo 1e9+7.

g. Compute q = n^2 * (n - 1)^2 modulo 1e9+7.

h. Compute q^{-1} modulo 1e9+7.

i. Compute 2*k*s*n*(n - 1) modulo 1e9+7.

j. Compute m*k*(k - 1)*2 modulo 1e9+7.

k. Compute p = [2*k*s*n*(n - 1) + m*k*(k - 1)*2] modulo 1e9+7.

l. Compute (p * q^{-1}) modulo 1e9+7.

m. Output the result.

Wait, but in step f, I need to compute (n*(n - 1))Â² modulo 1e9+7, but I already have n*(n - 1) from step d, so I can square it modulo 1e9+7.

Similarly, n^2 can be computed as n*n modulo 1e9+7.

Then, q = n^2 * (n - 1)^2 modulo 1e9+7.

Wait, but (n*(n - 1))Â² = nÂ² * (n - 1)Â², which is q.

So, q = (n*(n - 1))Â² modulo 1e9+7.

So, I can compute q = (n*(n - 1))Â² % M.

Then, q^{-1} modulo M can be computed using pow(q, M-2, M).

Then, p = (2*k*s*n*(n - 1) + m*k*(k - 1)*2) % M.

Finally, answer = (p * q^{-1}) % M.

This seems efficient.

Now, let's verify this approach with the sample input.

Sample Input:

4

100 0 24

2 1 10

1 2 1

3 1 2

2 1 1

5 2 4

1 2 25

3 2 24

Sample Output:

0

55

777777784

40000020

Let's take the first test case:

n=100, m=0