Alright, I have this problem to solve. Let's see what it's asking for.

So, there are n problems in a contest, each with a difficulty a_i, and each expected difficulty is at most b_i. Both arrays a and b are sorted in non-decreasing order.

The task is to make sure that for every problem, its actual difficulty a_i is less than or equal to its expected difficulty b_i. If not, I need to add new problems with certain difficulties, sort the array again, and remove the most difficult problem each time.

I need to find the minimum number of new problems I have to add to achieve this.

First, I need to understand the process clearly.

I start with two sorted arrays: a and b.

I need to ensure that after possibly adding and removing some problems, a_i <= b_i for all i.

Each time I add a new problem with difficulty w, I insert w into a, sort a, and then remove the largest element.

I need to do this in such a way that the number of additions is minimized.

Let me look at the first example to get a better understanding.

In the first test case:

n = 6

a = [1000, 1400, 2000, 2000, 2200, 2700]

b = [800, 1200, 1500, 1800, 2200, 3000]

The goal is to have a_i <= b_i for each i.

Let's compare them directly:

i=0: 1000 > 800 → need to add a problem to replace the largest a.

Add w=800, insert into a: [1000,1400,2000,2000,2200,2700,800], sort: [800,1000,1400,2000,2000,2200,2700], remove the largest: 2700 → a becomes [800,1000,1400,2000,2000,2200]

Now, compare again:

i=0: 800 <= 800 → good

i=1: 1000 > 1200 → still not good.

So, need to add another problem.

Add w=1800, insert into a: [800,1000,1400,2000,2000,2200,1800], sort: [800,1000,1400,1800,2000,2000,2200], remove the largest: 2200 → a becomes [800,1000,1400,1800,2000,2000]

Now, compare:

i=0: 800 <= 800 → good

i=1: 1000 <= 1200 → good

i=2: 1400 <= 1500 → good

i=3: 1800 <= 1800 → good

i=4: 2000 <= 2200 → good

i=5: 2000 <= 3000 → good

So, with 2 additions, we achieve the goal.

The problem is to find the minimal number of such additions.

Now, I need a general strategy.

Since both arrays are sorted, I can use two pointers, one for a and one for b.

I'll iterate through the arrays and whenever a[i] > b[j], I need to add a new problem.

But I need to be careful about where to add the new problem and how it affects the array a.

Wait, in the process, every time I add a problem with difficulty w, I insert it into a, sort a, and remove the largest element.

So, effectively, the array a always remains sorted after each operation.

I need to find a way to minimize the number of such operations.

Let me think differently.

Since a is always sorted, and I'm adding w and removing the largest element, it's similar to replacing the largest element in a with w, but ensuring that w is less than or equal to the element it's replacing in some sense.

But it's not exactly replacement; it's insertion and then removal of the largest.

Wait, when I insert w into a and sort, then remove the largest, it's like setting the largest element in a to be w, but only if w is less than the current largest.

But it's not exactly that.

Wait, let's think in terms of priority queues or heaps.

Since a is sorted, and I'm removing the largest element each time I add a new problem, it's similar to a min-heap where I remove the maximum element.

But heaps are max-heaps by default in some implementations.

Wait, in Python, heapq is a min-heap, so to have a max-heap, I can use negative values.

But I'm not sure if that helps directly here.

Maybe I need a different approach.

Let me consider the following:

I need to ensure that for each i, a_i <= b_i.

Given that a and b are sorted in non-decreasing order.

I can use a two-pointer approach.

Initialize two pointers, i and j, starting from the beginning of a and b.

Iterate through the arrays:

- If a[i] <= b[j], then it's fine, move both pointers forward.

- If a[i] > b[j], then I need to add a new problem.

- When adding a new problem, I need to choose w such that it's <= b[j], and replace the largest element in a with w.

- But since a is sorted, the largest element is at the end.

- So, I can pop the last element from a and insert w, then sort a again.

- But sorting a each time would be inefficient, especially for larger n.

- But since n <= 100, it's manageable.

Wait, but in the code provided, it's using pop(-1) to remove the last element, which is the largest since a is sorted.

Then, inserting w at the correct position using a[:i] + [w] + a[i+1:] and sorting again.

But I need to see if this is the most efficient way.

Let me look at the code provided.

The code is:

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

b = list(map(int, input().split()))

cnt = 0

i = 0

j = 0

while i < n and j < n:

if b[j] < a[i]:

a.pop(-1)

a = a[:i] + [b[j]] + a[i+1:]

cnt += 1

j += 1

else:

i += 1

j += 1

print(cnt)

So, it's using two pointers i and j.

If b[j] < a[i], it removes the last element from a, inserts b[j] at position i, and increments cnt, j.

Else, it moves both pointers forward.

I need to verify if this logic is correct.

In the first example:

a = [1000,1400,2000,2000,2200,2700]

b = [800,1200,1500,1800,2200,3000]

Initially, i=0, j=0

Compare a[0]=1000 and b[0]=800

1000 > 800 → b[j] < a[i], so pop last from a: a becomes [1000,1400,2000,2000,2200]

Insert b[j]=800 at position i=0: a becomes [800,1000,1400,2000,2000,2200]

cnt=1, j=1

Now, i=0, j=1

a[0]=800, b[1]=1200

800 <= 1200 → move both pointers: i=1, j=2

a[1]=1000, b[2]=1500

1000 <= 1500 → move both: i=2, j=3

a[2]=1400, b[3]=1800

1400 <= 1800 → move both: i=3, j=4

a[3]=2000, b[4]=2200

2000 <= 2200 → move both: i=4, j=5

a[4]=2000, b[5]=3000

2000 <= 3000 → move both: i=5, j=6

End of loop, cnt=1

But in the example, it says cnt=2.

Wait, perhaps I missed something.

Wait, in the example explanation, they added two problems: w=800 and w=1800.

But according to this code, it only counts one addition.

Hmm, maybe the code is incorrect.

Wait, let's simulate again carefully.

Initial a: [1000,1400,2000,2000,2200,2700]

b: [800,1200,1500,1800,2200,3000]

i=0, j=0

a[0]=1000 > b[0]=800 → pop last from a: a=[1000,1400,2000,2000,2200]

Insert 800 at position i=0: a=[800,1000,1400,2000,2000,2200]

cnt=1, j=1

Now, i=0, j=1

a[0]=800 <= b[1]=1200 → move both: i=1, j=2

a[1]=1000 <= b[2]=1500 → move both: i=2, j=3

a[2]=1400 <= b[3]=1800 → move both: i=3, j=4

a[3]=2000 <= b[4]=2200 → move both: i=4, j=5

a[4]=2000 <= b[5]=3000 → move both: i=5, j=6

End of loop, cnt=1

But in the example, it's saying cnt=2.

So, perhaps the code is incorrect.

Wait, maybe I need to check if a[i] > b[j] instead of b[j] < a[i].

Let me check the condition again.

In the code, it's if b[j] < a[i]:

But in the problem, I need a[i] <= b[i].

So, the condition should be if a[i] > b[j]:

Wait, in the code, it's checking if b[j] < a[i], which is equivalent to a[i] > b[j].

But in the simulation, it only added one problem, while the example adds two.

So, perhaps the code is missing something.

Let me check the second addition in the example.

After first addition:

a=[800,1000,1400,2000,2000,2200]

b=[800,1200,1500,1800,2200,3000]

Now, compare:

i=0: 800 <= 800 → good

i=1: 1000 > 1200 → need to add another problem

Add w=1800, insert into a: [800,1000,1400,2000,2000,2200,1800], sort: [800,1000,1400,1800,2000,2000,2200], remove the largest: 2200 → a=[800,1000,1400,1800,2000,2000]

Now, compare:

i=0: 800 <= 800 → good

i=1: 1000 <= 1200 → good

i=2: 1400 <= 1500 → good

i=3: 1800 <= 1800 → good

i=4: 2000 <= 2200 → good

i=5: 2000 <= 3000 → good

So, two additions are needed.

But according to the code, it only counts one addition.

Hence, the code must be incorrect.

I need to find out why.

Looking back at the code:

while i < n and j < n:

if b[j] < a[i]:

a.pop(-1)

a = a[:i] + [b[j]] + a[i+1:]

cnt += 1

j += 1

else:

i += 1

j += 1

In the first iteration:

a=[1000,1400,2000,2000,2200,2700], b=[800,1200,1500,1800,2200,3000]

i=0, j=0

a[0]=1000 > b[0]=800 → pop last from a: a=[1000,1400,2000,2000,2200]

Insert b[j]=800 at position i=0: a=[800,1000,1400,2000,2000,2200]

cnt=1, j=1

Now, i=0, j=1

a[0]=800 <= b[1]=1200 → move both: i=1, j=2

a[1]=1000 <= b[2]=1500 → move both: i=2, j=3

a[2]=1400 <= b[3]=1800 → move both: i=3, j=4

a[3]=2000 <= b[4]=2200 → move both: i=4, j=5

a[4]=2000 <= b[5]=3000 → move both: i=5, j=6

End of loop, cnt=1

But in the example, two additions are needed.

So, the code is missing the second addition.

I need to adjust the code to account for all necessary additions.

Perhaps the condition should be checked again after insertion.

Wait, maybe after inserting a new problem, I need to recheck the current position.

In the first iteration, after inserting 800, a becomes [800,1000,1400,2000,2000,2200]

Now, at i=0, j=0:

a[0]=800 <= b[0]=800 → move both: i=1, j=1

a[1]=1000 > b[1]=1200 → need to add another problem

Add w=1800, a becomes [800,1000,1400,2000,2000,2200,1800], sort: [800,1000,1400,1800,2000,2000,2200], remove the largest: 2200 → a=[800,1000,1400,1800,2000,2000]

Now, reset i and j to 0 and repeat the process?

Wait, but in the code, after adding one problem, it moves j forward.

But in the example, they added two problems.

So, perhaps after adding the first problem, I need to reset i and j and check again.

But that would be inefficient.

Is there a better way?

Alternatively, I can use a loop that continues until all a[i] <= b[i].

But that might be too slow for n=100.

Wait, n is up to 100, which is manageable.

Another approach is to use a priority queue to keep track of the largest elements in a.

But perhaps it's overkill.

Let me think differently.

Since a and b are sorted, I can use a sliding window or two-pointer approach.

I need to ensure that for each position i, a[i] <= b[i].

If not, I need to add a problem to reduce the largest element in a.

Each addition allows me to replace the largest element in a with a new problem of difficulty w, where w <= b[j].

I need to choose w optimally to minimize the number of additions.

Perhaps I should prioritize adding the smallest possible w to minimize the impact on a.

But I'm not sure.

Let me consider the following algorithm:

Initialize cnt = 0

While there exists an i where a[i] > b[i]:

Find the largest element in a (since a is sorted, it's the last element)

Find the smallest b[j] where j >= i and b[j] < a[i]

Add a new problem with w = b[j]

Insert w into a, sort a, and remove the largest element

Increment cnt

This seems similar to the initial approach but needs to be implemented carefully.

However, this might not be efficient enough for n=100, but since n is small, it should be fine.

But implementing this directly might be too slow, so I need a smarter way.

Looking back at the provided code, it seems to miss some steps.

Perhaps I need to iterate through a and b, and every time a[i] > b[j], add a new problem with w = b[j], and adjust a accordingly.

But I need to make sure that after adding the problem, the condition a[i] <= b[j] holds for all i.

Maybe I need to keep track of the positions where a[i] > b[i] and add problems accordingly.

Wait, perhaps I can use binary search to find the position where to insert w.

But I'm not sure.

Let me consider the following approach:

- Initialize cnt = 0

- While a and b are not yet satisfying a[i] <= b[i] for all i:

- Find the first i where a[i] > b[i]

- Add a new problem with w = b[i]

- Insert w into a, sort a, and remove the largest element

- Increment cnt

- Repeat until all a[i] <= b[i]

This seems correct, but may not be optimal in terms of the number of additions.

But since the problem guarantees that it's possible, I can proceed with this approach.

However, implementing this directly might be inefficient.

Given that n is small (n <= 100), it should be acceptable.

But I need to implement it efficiently.

Now, looking back at the provided code:

while i < n and j < n:

if b[j] < a[i]:

a.pop(-1)

a = a[:i] + [b[j]] + a[i+1:]

cnt += 1

j += 1

else:

i += 1

j += 1

print(cnt)

This code only adds one problem per mismatch, but in the example, two additions are needed.

So, it's missing something.

Perhaps I need to adjust the pointers after insertion.

Wait, maybe after inserting a new problem, I need to reset the pointers and start checking from the beginning.

But that would be inefficient.

Alternatively, I can use a different approach.

Let me consider that after each addition, the array a is sorted again, so I can maintain a sorted list.

In Python, I can use the 'bisect' module to insert elements while maintaining the sorted order.

But in the provided code, it's manually inserting into a list and sorting.

Which is fine for n=100.

But perhaps I can optimize it.

Wait, maybe I can find the number of times a[i] > b[i], and add that many problems.

But it's not that straightforward, because adding a problem affects multiple elements in a.

Wait, perhaps I need to count the number of elements in a that are greater than their corresponding b[i].

But again, it's not that simple, because adding a problem affects the entire array.

Let me think about the difference between the number of elements in a that are too large and the number of elements in b that can be used to replace them.

But I'm getting confused.

Let me look at the second example:

n=6

a=[4,5,6,7,8,9]

b=[1,2,3,4,5,6]

Goal: make a_i <= b_i for all i.

Compare:

i=0: 4 > 1 → need to add a problem

Add w=1, a becomes [1,4,5,6,7,8]

i=0:1 <=1 → good

i=1:4 >2 → need to add again

Add w=2, a becomes [1,2,4,5,6,7]

i=1:2 <=2 → good

i=2:4 >3 → need to add again

Add w=3, a becomes [1,2,3,4,5,6]

Now, a_i <= b_i for all i.

Total additions: 3, which matches the example.

In this case, the provided code would work as follows:

a=[4,5,6,7,8,9], b=[1,2,3,4,5,6]

i=0, j=0

a[0]=4 > b[0]=1 → pop last from a: a=[4,5,6,7,8]

Insert b[j]=1 at position i=0: a=[1,4,5,6,7,8]

cnt=1, j=1

Now, i=0, j=1

a[0]=1 <= b[1]=2 → move both: i=1, j=2

a[1]=4 > b[2]=3 → pop last from