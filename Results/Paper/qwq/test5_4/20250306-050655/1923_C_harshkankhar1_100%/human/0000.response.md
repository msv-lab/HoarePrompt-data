Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this concept of a "good" array, and I need to determine for various subarrays whether they meet this "good" criteria based on the conditions provided.

First, let's understand what makes an array "good." According to the problem, an array \( a \) of length \( m \) is considered good if there exists another integer array \( b \) of the same length such that:

1. The sum of elements in \( a \) is equal to the sum of elements in \( b \): \( \sum_{i=1}^{m} a_i = \sum_{i=1}^{m} b_i \).

2. For every index \( i \), \( a_i \neq b_i \).

3. Every element in \( b \) is positive: \( b_i > 0 \) for all \( i \).

So, my task is to check for each query, which specifies a subarray from \( l_i \) to \( r_i \), whether this subarray is good based on the above conditions.

Given that there can be up to \( 3 \times 10^5 \) queries and the array can be up to length \( 3 \times 10^5 \), I need an efficient way to handle these queries, probably in logarithmic time or better.

Let me try to rephrase the conditions to understand them better.

Condition 1: The sums of \( a \) and \( b \) are equal.

Condition 2: No element in \( b \) is equal to the corresponding element in \( a \).

Condition 3: All elements in \( b \) are positive integers.

I need to find out if such a \( b \) exists for a given subarray.

Let me think about how to construct such a \( b \). Since \( b_i \) has to be positive and different from \( a_i \), one approach is to adjust \( a_i \) in some way to create \( b_i \).

Let's consider that \( b_i \) can be either \( a_i + d \) or \( a_i - d \), but with the constraints that \( b_i \neq a_i \) and \( b_i > 0 \).

Wait, but the problem doesn't specify how \( b_i \) relates to \( a_i \), other than being different and positive.

So, perhaps a better way is to think about the minimal possible sum for \( b \), given the constraints.

Since \( b_i > 0 \) and \( b_i \neq a_i \), the smallest \( b_i \) can be is 1 if \( a_i \neq 1 \), or 2 if \( a_i = 1 \).

Wait, let's think about that.

If \( a_i = 1 \), then \( b_i \) cannot be 1 (since \( b_i \neq a_i \)), so the smallest \( b_i \) can be is 2.

If \( a_i > 1 \), then \( b_i \) can be 1, since \( b_i \neq a_i \) and \( b_i > 0 \).

Wait, no, if \( a_i > 1 \), then \( b_i \) can be any positive integer except \( a_i \). So, the smallest possible \( b_i \) is 1.

But, if \( a_i = 1 \), then \( b_i \) has to be at least 2.

Wait, but in the problem statement, it's given that all elements of array \( c \) are greater than 0, and we're dealing with subarrays of \( c \), which are just parts of \( c \).

So, in the context of the queries, the subarray \( c_{l_i} \) to \( c_{r_i} \) is what constitutes array \( a \) for that query.

So, for each query, \( a \) is the subarray from \( l_i \) to \( r_i \), and I need to check if there exists a \( b \) satisfying the three conditions.

So, to rephrase, for each query, I need to check if the sum of the subarray from \( l_i \) to \( r_i \) is at least the minimal possible sum of \( b \), which is defined by the constraints that \( b_i > 0 \) and \( b_i \neq a_i \).

Wait, actually, it's the other way around. The sum of \( a \) must equal the sum of \( b \), and \( b \) has to satisfy \( b_i > 0 \) and \( b_i \neq a_i \) for all \( i \).

So, to have such a \( b \), the sum of \( b \) must equal the sum of \( a \), and \( b_i \) must be positive and different from \( a_i \).

So, for each \( a_i \), \( b_i \) can be any positive integer except \( a_i \).

So, the minimal possible sum of \( b \) would be achieved by choosing the smallest possible \( b_i \) that is not equal to \( a_i \).

So, for each \( a_i \):

- If \( a_i = 1 \), then \( b_i \) must be at least 2.

- If \( a_i > 1 \), then \( b_i \) can be 1.

Therefore, the minimal possible sum of \( b \) is the sum over all \( i \) of the minimal possible \( b_i \), which is:

- 2 if \( a_i = 1 \)

- 1 if \( a_i > 1 \)

So, for the subarray from \( l_i \) to \( r_i \), compute the sum of \( a \), and compute the minimal possible sum of \( b \), which is the sum of 2 for each \( a_i = 1 \) and 1 for each \( a_i > 1 \) in the subarray.

If the sum of \( a \) is equal to this minimal sum of \( b \), then it's possible to choose \( b \) such that \( b_i \neq a_i \) and \( b_i > 0 \), and the sums are equal.

Wait, but the problem says that \( a_i \neq b_i \) for every \( i \), and \( b_i > 0 \) for every \( i \).

So, in this case, if the sum of \( a \) is equal to the minimal sum of \( b \), then it's possible to choose \( b_i \) as the minimal possible value for each \( i \), ensuring \( b_i \neq a_i \) and \( b_i > 0 \), and the sums match.

However, there's a catch. If there are multiple \( a_i = 1 \), then \( b_i \) must be at least 2 for those positions, and for \( a_i > 1 \), \( b_i \) can be 1.

So, the minimal sum of \( b \) is the sum over the subarray where each \( a_i \) is replaced by 1 if \( a_i > 1 \), and 2 if \( a_i = 1 \).

Therefore, to check if the subarray is good, we need to check if the sum of \( a \) is greater than or equal to this minimal sum of \( b \), and also ensure that there is at least one position where \( a_i \neq b_i \), but since \( b_i \neq a_i \) for all \( i \), this is already satisfied.

Wait, no. The sum of \( a \) must equal the sum of \( b \), and \( b_i \neq a_i \) for all \( i \), and \( b_i > 0 \) for all \( i \).

So, the sum of \( a \) must equal the sum of \( b \), and \( b_i \) is at least 1 if \( a_i > 1 \), or 2 if \( a_i = 1 \).

Therefore, the minimal sum of \( b \) is the sum over the subarray with each \( a_i \) replaced by 1 if \( a_i > 1 \), else 2.

If the sum of \( a \) is greater than or equal to this minimal sum, then it's possible to choose \( b \) such that the sums are equal, \( b_i \neq a_i \), and \( b_i > 0 \).

However, there's one more thing to consider: if the sum of \( a \) is equal to the minimal sum of \( b \), then \( b_i \) must be exactly the minimal possible for each \( i \), which is 1 if \( a_i > 1 \), or 2 if \( a_i = 1 \).

But in this case, since \( b_i \neq a_i \), and \( b_i \) is set to the minimal possible value that is not equal to \( a_i \), this should work.

Therefore, for the subarray to be good, the sum of \( a \) must be at least the minimal sum of \( b \), and the sums must be equal.

Wait, no, the sum of \( b \) must equal the sum of \( a \), as per condition 1.

So, to have \( \sum a_i = \sum b_i \), and \( b_i \) is at least the minimal possible value for each \( i \), then the sum of \( a \) must be at least the sum of these minimal values.

If the sum of \( a \) is less than the sum of these minimal \( b_i \), then it's impossible to find such a \( b \).

Moreover, since \( b_i \) must be different from \( a_i \), and \( b_i \) must be positive, we need to ensure that for each \( i \), \( b_i \neq a_i \), and \( b_i > 0 \).

Given that, the minimal sum of \( b \) is the sum where each \( b_i \) is set to the smallest possible value that is not equal to \( a_i \) and is positive.

So, for each \( a_i \):

- If \( a_i = 1 \), then \( b_i \) must be at least 2.

- If \( a_i > 1 \), then \( b_i \) can be 1.

Therefore, the minimal sum of \( b \) is the sum over the subarray with each \( a_i \) replaced by 1 if \( a_i > 1 \), else 2.

If the sum of \( a \) is equal to this minimal sum, then it's possible to set \( b_i \) to the minimal possible value for each \( i \), ensuring \( b_i \neq a_i \) and \( b_i > 0 \), and the sums are equal.

If the sum of \( a \) is greater than this minimal sum, then it might still be possible to adjust \( b_i \)'s to make the sums equal, but we need to ensure that we don't set any \( b_i \) equal to \( a_i \), and that all \( b_i > 0 \).

Wait, but the problem is to have the sums equal, and \( b_i \neq a_i \) for all \( i \), and \( b_i > 0 \) for all \( i \).

So, if the sum of \( a \) is equal to the minimal sum of \( b \), then set \( b_i \) to the minimal possible value for each \( i \), which satisfies \( b_i \neq a_i \) and \( b_i > 0 \).

If the sum of \( a \) is greater than the minimal sum of \( b \), then we need to adjust some \( b_i \)'s to be larger than their minimal values, while still ensuring \( b_i \neq a_i \) and \( b_i > 0 \).

This seems feasible as long as the sum of \( a \) is at least the minimal sum of \( b \).

Wait, but the problem is to have the sums equal, so if the sum of \( a \) is greater than the minimal sum of \( b \), but we need to make the sums equal by choosing \( b_i \)'s appropriately.

However, since \( b_i \) can be any value greater than 0 and not equal to \( a_i \), we can adjust \( b_i \)'s to make the sums equal, as long as the sum of \( a \) is at least the minimal sum of \( b \).

Wait, but to make the sums equal, we need to adjust \( b_i \)'s that are already at their minimal values.

For example, suppose \( a = [1, 3] \), then minimal \( b = [2, 1] \), sum is 3.

If sum of \( a \) is 4, which is greater than 3, then we can increase \( b_i \)'s that are not yet equal to \( a_i \), to make the sum match.

In this case, we can set \( b = [2, 2] \), sum is 4, which matches sum of \( a \), and \( b_i \neq a_i \) for all \( i \).

Similarly, for \( a = [1, 1, 1] \), minimal \( b = [2, 2, 2] \), sum is 6.

If sum of \( a \) is 3, which is less than 6, it's impossible to have \( b \) with sum 3 while \( b \) must have sum at least 6.

Hence, for the subarray to be good, the sum of \( a \) must be at least the minimal sum of \( b \), and equal to it.

Wait, no, the sum of \( a \) must equal the sum of \( b \), and sum of \( b \) must be at least the minimal sum as defined.

Therefore, to have sum\( a \) equal to sum\( b \), it must be at least the minimal sum.

Moreover, in the example provided:

Input:

1

5 4

1 2 1 4 5

1 5

4 4

3 4

1 3

Output:

YES

NO

YES

NO

Let's verify this with our understanding.

For the entire array [1,2,1,4,5], sum is 13.

Minimal sum of \( b \) would be 2 (for 1) + 1 (for 2) + 2 (for 1) + 1 (for 4) + 1 (for 5) = 7.

But the sum of \( a \) is 13, which is greater than 7.

But according to our earlier thought, as long as sum\( a \) >= minimal sum of \( b \), it's possible.

But in the example, it's YES for the entire array.

Wait, but in the explanation above, I thought that sum\( a \) must be equal to sum\( b \), which must be at least the minimal sum of \( b \).

But actually, sum\( b \) must equal sum\( a \), and sum\( b \) >= minimal sum of \( b \).

So, sum\( a \) must be >= minimal sum of \( b \), and sum\( b \) = sum\( a \).

Hence, sum\( a \) must be >= minimal sum of \( b \).

In the first query, sum\( a \) = 13, minimal sum of \( b \) = 7, which is less than 13, but the answer is YES.

Wait, perhaps I'm missing something.

Let me think differently.

Suppose sum\( a \) < minimal sum of \( b \), then it's impossible to have sum\( b \) = sum\( a \), since sum\( b \) >= minimal sum of \( b \).

Hence, in this case, it's impossible, so answer is NO.

But in the example, for the second query, which is position 4 to 4, which is [4], sum is 4.

Minimal sum of \( b \) is 1 (since 4 > 1), so minimal sum is 1.

Sum of \( a \) is 4, which is greater than 1, but the answer is NO.

Wait, that contradicts my earlier assumption.

So, perhaps there's more to it.

Let me think again.

Given that sum\( b \) must equal sum\( a \), and sum\( b \) >= minimal sum of \( b \), it's necessary that sum\( a \) >= minimal sum of \( b \).

But in the second query, sum\( a \) = 4, minimal sum of \( b \) = 1, but the answer is NO.

So, there must be another condition that I'm missing.

Looking back at the problem, the second condition is that \( a_i \neq b_i \) for every index \( i \).

So, perhaps there's a case where even if sum\( a \) >= minimal sum of \( b \), but it's impossible to adjust \( b_i \)'s to make sum\( b \) = sum\( a \) while keeping \( b_i \neq a_i \) for all \( i \).

In the second query, subarray [4], sum\( a \) = 4.

Minimal sum of \( b \) is 1 (since 4 > 1).

To make sum\( b \) = 4, with \( b_i \neq 4 \) and \( b_i > 0 \), the only possible \( b_i \) is 1, 2, 3, etc., but not 4.

So, if \( b_i = 1 \), sum is 1, which is less than 4.

If \( b_i = 2 \), sum is 2, still less.

If \( b_i = 3 \), sum is 3, still less.

If \( b_i = 5 \), sum is 5, which is greater than 4.

But sum\( b \) must equal sum\( a \), which is 4, but 5 != 4.

Hence, it's impossible to choose a \( b_i \) that is not 4 and positive such that \( b_i \) = 4.

Hence, the answer is NO.

Wait, but if I choose \( b_i = 3 \), sum is 3, which is less than 4.

Or \( b_i = 5 \), sum is 5, which is greater than 4.

But I need sum\( b \) = 4, which is not possible with a single element, since no integer \( b_i \) can satisfy \( b_i = 4 \) (because \( b_i \neq a_i \)), and no other integer equals 4.

Hence, it's impossible, so answer is NO.

In contrast, for the entire array [1,2,1,4,5], sum\( a \) = 13, minimal sum of \( b \) = 7.

To make sum\( b \) = 13, starting from minimal \( b \) = [2,1,2,1,1], sum = 7.

I need to increase the sum by 6, while ensuring \( b_i \neq a_i \) for all \( i \).

So, I can increment some \( b_i \)'s that are not equal to \( a_i \).

For example, increment \( b_1 \) from 2 to 2 + x, but \( b_1 \) cannot equal \( a_1 = 1 \), which it already doesn't.

Similarly, \( b_2 \) from 1 to 1 + y, not equal to \( a_2 = 2 \), so as long as 1 + y != 2, i.e., y != 1.

Similarly for other \( b_i \)'s.

This seems manageable to adjust the \( b_i \)'s to make sum\( b \) = 13.

Hence, YES.

Similarly, for subarray [1,4], sum\( a \) = 5, minimal sum of \( b \) = 2 + 1 = 3.

To make sum\( b \) = 5, starting from [2,1], need to increase by 2.

Can set \( b = [3,2] \), which sums to 5, and \( b_i \neq a_i \) for both elements.

Hence, YES.

For subarray [1,2,1], sum\( a \) = 4, minimal sum of \( b \) = 2 + 1 + 2 = 5.

Sum\( a \) < minimal sum of \( b \), so impossible, NO.

For subarray [4], sum\( a \) = 4, minimal sum of \( b \) = 1.

Sum\( a \) > minimal sum of \( b \), but as we saw earlier, it's impossible to make sum\( b \) = 4 with \( b_i \neq 4 \), so NO.

Hence, the general rule seems to be:

- Compute the minimal sum of \( b \) for the subarray.

- If sum\( a \) < minimal sum of \( b \), then it's impossible, NO.

- If sum\( a \) >= minimal sum of \( b \), then check if it's possible to adjust \( b_i \)'s to make sum\( b \) = sum\( a \), while keeping \( b_i \neq a_i \) for all \( i \).

- In the single-element case, if sum\( a \) != minimal sum of \( b \), and it's impossible to adjust \( b_i \) to match sum\( a \), then NO.

- In multi-element subarrays, it seems possible to adjust \( b_i \)'s as long as sum\( a \) >= minimal sum of \( b \), but in the single-element case, it's only possible if sum\( a \) == minimal sum of \( b \), and \( a_i \neq \) minimal \( b_i \).

Wait, in the single-element case, it's only possible if sum\( a \) == minimal sum of \( b \), because you can't adjust the sum beyond that with just one element.

Hence, a special case for subarrays of length 1.

Hence, perhaps the general rule is:

- If the subarray has length 1, then it's YES only if sum\( a \) == minimal sum of \( b \), which is 2 if \( a_i = 1