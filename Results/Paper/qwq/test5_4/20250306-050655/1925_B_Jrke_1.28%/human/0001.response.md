Alright, I've got this problem to solve. Let's see what it's asking for. So, Jay created a problem of difficulty x and wants to make it the second problem for Codeforces Round #921. But Yash is worried that this might make the contest unbalanced, so he decides to break this problem into n sub-problems, each with a positive integer difficulty, and the sum of these sub-problems should be equal to x.

Now, the coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems. Yash wants to maximize this balance.

So, given x and n, I need to find the maximum GCD possible when x is divided into n sub-problems with positive integer difficulties summing up to x.

First, I need to understand what GCD is. GCD of a set of numbers is the largest number that divides all of them without leaving a remainder.

So, if I have n sub-problems with difficulties a1, a2, ..., an, and their sum is x, then GCD(a1, a2, ..., an) should be as large as possible.

I need to choose a1, a2, ..., an such that:

1. a1 + a2 + ... + an = x

2. Each ai is a positive integer (ai >= 1)

3. GCD(a1, a2, ..., an) is maximized.

I need to find the maximum possible GCD for given x and n.

Let me think about this.

First, I know that GCD of numbers divides their sum. That is, GCD(a1, a2, ..., an) divides x because x is the sum of a1 to an.

So, the GCD must be a divisor of x.

Also, since we have n sub-problems, and each ai >=1, then x must be at least n (because the smallest sum is when each ai=1, which sums to n).

So, if x < n, it's impossible to divide x into n positive integers, but according to the constraints, 1 <= n <= x, so x >= n, so it's always possible.

Now, to maximize the GCD, I need to find the largest possible d such that d divides x and it's possible to divide x into n positive integers, each being a multiple of d.

Wait, because if d is the GCD, then each ai must be a multiple of d.

So, ai = d * bi, where bi are positive integers.

Then, sum ai = d * sum bi = x.

So, sum bi = x / d.

And since sum bi = x / d, and bi are positive integers, the number of bi is n, so sum bi >= n.

But sum bi = x / d, so x / d >= n.

Which implies d <= x / n.

So, d must be a divisor of x, and d <= floor(x / n).

So, to maximize d, I need to find the largest divisor of x that is less than or equal to floor(x / n).

So, the problem reduces to finding the largest divisor of x that is <= floor(x / n).

So, the algorithm should be:

1. For given x and n, compute floor(x / n).

2. Find all divisors of x that are <= floor(x / n).

3. Choose the largest among them.

That should be the maximum possible GCD.

Let me see if this makes sense.

Take the first example:

x = 10, n = 3

floor(10 / 3) = 3

Divisors of 10 are 1, 2, 5, 10

Divisors <= 3 are 1, 2

The largest is 2, which matches the sample output.

Second example:

x = 5, n = 5

floor(5 / 5) = 1

Divisors of 5 are 1, 5

Divisors <=1 are only 1

So, the GCD is 1, matches the sample output.

Third example:

x = 420, n = 69

floor(420 / 69) = 6

Divisors of 420 <=6 are 1,2,3,4,5,6

The largest is 6, which matches the sample output.

So, this seems correct.

Now, how to implement this efficiently, especially since x can be up to 10^8 and t can be up to 10^3.

So, we need an efficient way to find all divisors of x that are <= floor(x / n), and then pick the largest one.

An efficient way to find all divisors of a number is to iterate from 1 to sqrt(x), and for each i that divides x, add both i and x/i to the list of divisors, unless i == x/i.

But in this case, since we need only divisors <= floor(x / n), we can iterate i from 1 to sqrt(x), and for each i that divides x:

- if i <= floor(x / n), add i to the list

- if x / i <= floor(x / n), add x / i to the list

Then, among these, pick the largest one.

But we need to optimize this because t is up to 10^3 and x is up to 10^8.

Computing divisors up to 10^8 is manageable, but we need to make sure it's efficient.

Let's think about the implementation.

First, read t, the number of test cases.

Then, for each test case:

- Read x and n.

- Compute floor(x / n)

- Find all divisors of x that are <= floor(x / n)

- Choose the largest among them.

- Print it.

Now, to find divisors efficiently, I can write a function that returns all divisors of x that are <= a given limit.

I can do this by iterating from 1 to sqrt(x), checking if i divides x, and if so, adding i and x/i to the list if they are <= floor(x / n).

Then, among these, find the maximum.

But since we're only interested in the maximum, I don't need to store all divisors, just keep track of the maximum divisor <= floor(x / n).

So, I can iterate i from 1 to sqrt(x), check if i divides x:

- If i <= floor(x / n), then candidate = i

- If x / i <= floor(x / n), then candidate = x / i

- Keep the maximum candidate.

Wait, but I need to make sure that x / i is an integer, which it is, since i divides x.

But I need to handle the case when i == x / i, to avoid duplicates.

But since I'm keeping track of the maximum, duplicates don't matter.

Wait, but in the code provided, it seems to handle this differently.

Let's look at the given code:

def func():

for _ in range(int(input())):

(x, n) = map(int, input().split())

k = x // n

if k == 1:

print(1)

continue

ans = 1

for i in range(1 + (1 if x % 2 == 0 else 0), int(x ** 0.5) + 1, 2):

if x % i == 0:

l = [ans]

if i <= k:

l.append(i)

if x // i <= k:

l.append(x // i)

ans = max(l)

print(ans)

So, it's trying to do something similar, but there are some parts that seem off.

First, it computes k = x // n

Then, if k == 1, it prints 1 immediately.

Otherwise, it initializes ans = 1

Then, it loops i from 1 + (1 if x % 2 == 0 else 0) to int(x ** 0.5) + 1, stepping by 2.

Wait, that seems odd.

It's starting from 1, and adding 1 if x is even, otherwise 0, and stepping by 2.

So, if x is even, it starts from 2, else from 1, and steps by 2.

This seems like an attempt to only check odd numbers, starting from 2 if x is even.

But this might skip some divisors.

Wait, if x is even, it starts from 2, and steps by 2, so it checks 2, 4, 6, etc.

If x is odd, it starts from 1, and steps by 2, so 1, 3, 5, etc.

But this might miss some divisors.

For example, take x=10, n=3

k = 10 // 3 = 3

Loop i from 2 (since x is even) to sqrt(10)+1=4

So i=2, then i=4

Check if 2 divides 10: yes, so l=[1,2,5], ans=5

Then i=4, 4 does not divide 10, so no change.

So ans=5, but floor(x/n)=3, and 5 >3, but 5 is greater than k=3, so should it be considering 5?

Wait, but in the code, it appends i and x/i if they are <=k.

Wait, looking back at the code:

if x % i == 0:

l = [ans]

if i <= k:

l.append(i)

if x // i <= k:

l.append(x // i)

ans = max(l)

So, for x=10, n=3, k=3

i=2, x%i==0, l=[1,2,5], ans=5

But x/i =5, which is >k=3, so should not be considered.

Wait, but in the code, it appends x/i only if x/i <=k.

Wait, looking again:

if i <= k:

l.append(i)

if x // i <= k:

l.append(x // i)

So, for i=2, i=2 <=3, so append 2

x/i=5, 5>3, so not append 5

So l=[1,2], ans=2

Then i=4, 4>sqrt(10), so loop ends

So, ans=2, which is correct.

Wait, but in my earlier thought, I thought it would append 5, but actually, x/i=5 >k=3, so it doesn't append 5.

So, it's correct in this case.

Another example: x=5, n=5, k=1

But in this case, k=1, so print 1 immediately.

Another example: x=420, n=69, k=6

Loop i from 2 (since x is even) to sqrt(420)+1=21

i=2, x%2==0, l=[1,2,210], but 210>6, so only append 2

ans=2

i=4, x%4==0, l=[2,4,105], but 105>6, so only append 4, ans=4

i=6, x%6==0, l=[4,6,70], but 70>6, so append 6, ans=6

i=8, x%8!=0

i=10, x%10==0, l=[6,10,42], but 10>6, and 42>6, so no append, ans=6

i=12, x%12==0, l=[6,12,35], but 12>6, and 35>6, so no append, ans=6

i=14, x%14==0, l=[6,14,30], but 14>6, 30>6, so no append, ans=6

i=16, x%16!=0

i=18, x%18==0, l=[6,18,23], but 18>6, 23>6, so no append, ans=6

i=20, x%20==0, l=[6,20,21], but 20>6, 21>6, so no append, ans=6

i=21, x%21==0, l=[6,21,20], but 21>6, 20>6, so no append, ans=6

So, ans=6, which is correct.

Seems like the code is working correctly for these cases.

But is this the most efficient way?

Well, for x up to 10^8 and t up to 10^3, iterating up to sqrt(x) for each test case should be fine, since sqrt(10^8)=10^4, so 10^4 operations per test case, with 10^3 test cases, total operations around 10^7, which is acceptable.

But I need to make sure that the implementation is correct.

Looking back at the code:

def func():

for _ in range(int(input())):

(x, n) = map(int, input().split())

k = x // n

if k == 1:

print(1)

continue

ans = 1

for i in range(1 + (1 if x % 2 == 0 else 0), int(x ** 0.5) + 1, 2):

if x % i == 0:

l = [ans]

if i <= k:

l.append(i)

if x // i <= k:

l.append(x // i)

ans = max(l)

print(ans)

So, a few things:

1. It handles k==1 as a special case, which is fine.

2. It starts the loop from 1 + (1 if x % 2 == 0 else 0), which is 2 if x is even, 1 if x is odd, and steps by 2.

This is an attempt to skip even numbers when x is odd, which is optimization.

But, it might miss some divisors if not handled carefully.

Wait, in the earlier example with x=10, n=3, it worked correctly.

Another test case: x=9, n=3, k=3

Loop i from 1 (since x is odd) to sqrt(9)+1=4, steps by 2

i=1, x%1==0, l=[1,1,9], but 9>3, so append 1, ans=1

i=3, x%3==0, l=[1,3,3], both 3<=3, so append 3, ans=3

So, ans=3, which is correct.

Another test case: x=12, n=4, k=3

Loop i from 2 (since x is even) to sqrt(12)+1=4, steps by 2

i=2, x%2==0, l=[1,2,6], but 6>3, so append 2, ans=2

i=4, x%4==0, l=[2,4,3], both 4>3 and 3<=3, so append 3, ans=3

So, ans=3, which is correct.

Seems like it's working.

But, is there a better way?

Well, perhaps, but this seems correct and efficient enough.

So, I would say that the given program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]