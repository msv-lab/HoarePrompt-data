Alright, I have this problem to solve. Let's see what it's about. So, there's a Quidditch game going on between Gryffindor and Ravenclaw. Each team has P players, and the field is a grid of N rows and M columns. There are goals for each team, a Quaffle, and possibly a Bludger. The game consists of T steps, and I need to keep track of the score and handle events like scoring goals and players being eliminated by the Bludger.

First, I need to understand the input format. The first line gives me N and M, the dimensions of the field. Then, there are N lines, each containing M pairs of characters that describe the field. These pairs can represent empty cells, players, goals, the Quaffle, or the Bludger.

After that, there's an integer T representing the number of steps in the game, followed by T lines, each describing an action performed by an entity on the field. The actions can be moving (U, D, L, R), catching a ball (C), or throwing the Quaffle (T).

My task is to process these actions step by step and output the main events: when a team scores a goal or when a player is eliminated by the Bludger. At the end, I need to print the final score.

Okay, let's think about how to approach this.

First, I need to parse the initial field layout. I'll need to keep track of the positions of players, goals, the Quaffle, and the Bludger. I can use a dictionary to store player positions, lists for the goals, and variables for the Quaffle and Bludger positions.

I need to make sure that I correctly identify which team owns which goals. Red team tries to score in blue goals, and blue team tries to score in red goals.

Next, I need to process each action in sequence. For each action, I need to update the positions accordingly and check for any events like scoring or elimination.

Let's consider the possible actions:

1. **Movement (U, D, L, R):**

- Players, the Quaffle, and the Bludger can move in these directions.

- I need to update their positions accordingly, ensuring they stay within the field boundaries.

2. **Catching a ball (C):**

- A player can catch a ball if they are on the same cell as it.

- The action specifies which ball is being caught.

- If a player catches the Quaffle, they start carrying it.

3. **Throwing the Quaffle (T):**

- A player who is carrying the Quaffle can throw it, placing it on their current cell.

- After throwing, the player no longer carries the Quaffle.

- If the Quaffle is thrown into a goal, the opposing team scores a point.

- The Quaffle should then be moved to the center of the field.

I also need to handle the Bludger's effect:

- If a player lands on the same cell as the Bludger, they are eliminated.

- Similarly, if the Bludger moves to a cell occupied by a player, that player is eliminated.

- If a player is eliminated while carrying the Quaffle, the Quaffle remains on that cell.

- It's guaranteed that elimination doesn't happen while a player is in a goal cell.

I need to make sure that the Quaffle's position is updated correctly when it's being carried by a player or thrown.

Let me think about how to structure the code.

I'll need to represent the field as a grid, but since entities can overlap, I don't need to enforce unique entities per cell.

I'll use a dictionary to store player positions, with the player's identifier (e.g., "R0", "B1") as keys and their [row, column] positions as values.

Similarly, I'll have lists for the goals of each team.

I'll have variables to store the positions of the Quaffle and the Bludger.

I'll also need a variable to track who is carrying the Quaffle, if anyone.

As I process each action, I'll update these positions and check for scoring or elimination events.

Let me outline the steps:

1. Read N and M.

2. Read the N lines describing the field and parse the positions of players, goals, Quaffle, and Bludger.

3. Read T, the number of steps.

4. For each of the T steps:

a. Read the action.

b. Determine which entity is performing the action.

c. Perform the specified action:

- Movement: Update the entity's position.

- Catching: Update which player is carrying the Quaffle.

- Throwing: Place the Quaffle at the player's position and check for scoring.

d. Check for elimination: If the entity's new position is the same as the Bludger's position, eliminate the entity (if it's a player).

e. If a player is eliminated, remove them from the game.

f. If the Quaffle is on a goal cell, check if it's the opponent's goal and update the score accordingly.

5. After all actions are processed, print the final score.

I need to handle the center of the field correctly when a goal is scored. The center is at row (N+1)/2 and column (M+1)/2, considering 1-based indexing, but in Python, lists are 0-based, so I need to adjust for that.

Also, I need to ensure that the Quaffle's position is updated correctly when it's being carried by a player. If a player moves while carrying the Quaffle, the Quaffle should move with them.

When a player throws the Quaffle, it's placed at the player's current position, and the player no longer carries it.

If the Quaffle is on a goal cell when thrown, the corresponding team scores a point, and the Quaffle is moved to the center.

I need to make sure that scoring is attributed to the correct team. If a red player scores in a blue goal, red team gets a point. If a blue player scores in a red goal, blue team gets a point. If a player scores in their own goal, the opposite team gets the point.

Wait, no. According to the problem statement:

"To win a point, a player must leave the Quaffle at a goal of the other team. When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field."

"If a player puts the ball in its own goal, the other team wins the point."

So, if a red player puts the Quaffle in a red goal (their own goal), the blue team gets a point.

Similarly, if a blue player puts the Quaffle in a blue goal, the red team gets a point.

I need to implement this logic correctly.

Also, I need to handle the case where the Quaffle is thrown into a goal. In that case, the team of the player who threw it gets the point.

I need to make sure that the Quaffle is moved to the center of the field immediately after scoring.

Now, about the Bludger and eliminations:

- If a player moves to the same cell as the Bludger, they are eliminated.

- If the Bludger moves to the same cell as a player, that player is eliminated.

- If a player is eliminated while carrying the Quaffle, the Quaffle remains on that cell.

- It's guaranteed that elimination doesn't occur while a player is in a goal cell.

I need to handle multiple eliminations at the same time step and print them in alphabetical order.

Alright, let's think about how to implement this.

First, parse the initial field:

- Read N and M.

- Read N lines, each containing M pairs of characters.

- For each cell, determine what it contains: empty, player, goal, Quaffle, or Bludger.

- Store player positions in a dictionary with player IDs as keys.

- Store goal positions in separate lists for red and blue.

- Store Quaffle and Bludger positions.

Then, read T and process T actions:

- For each action, identify the entity performing it.

- Depending on the action type, perform the corresponding operation.

- After each action, check for elimination and scoring events.

Let's think about how to handle movements.

I'll define a function to move an entity in a specified direction.

The function will take the entity's position and the direction, and update the position accordingly.

I need to ensure that entities don't move outside the field boundaries.

Wait, but the problem says "All entities can move. A player can also catch a ball or throw the Quaffle that it is carrying. To catch a ball, a player must be located on the same cell as it. The Quaffle does not perform any action while it is being carried; it only follows the movements of the player."

So, when a player carries the Quaffle, the Quaffle moves with the player.

When the player throws the Quaffle, it's placed at the player's current position.

I need to keep track of which player is carrying the Quaffle, if any.

I'll have a variable, say, "carry", which is set to the player's ID if a player is carrying the Quaffle, or None otherwise.

When a player catches the Quaffle, set "carry" to that player's ID.

When a player throws the Quaffle, set "carry" to None and place the Quaffle at the player's position.

If the Quaffle is not being carried, it can be caught by players.

Wait, but according to the problem, "The Quaffle does not perform any action while it is being carried; it only follows the movements of the player."

So, when carried, the Quaffle moves with the player.

When thrown, it's placed at the player's position and is no longer carried.

I need to handle the Quaffle's position accordingly.

Also, multiple entities can be on the same cell.

So, when a player moves to a cell containing the Bludger, they are eliminated.

Similarly, if the Bludger moves to a cell containing a player, that player is eliminated.

I need to handle these elimination events correctly.

Now, about scoring:

- If a player throws the Quaffle and it ends up on a goal cell, the corresponding team scores a point.

- If a player puts the Quaffle in their own goal, the opposite team scores a point.

- After scoring, the Quaffle is moved to the center of the field.

I need to make sure that I correctly identify which goal is which and attribute points accordingly.

Also, the center of the field is at row (N+1)/2 and column (M+1)/2, 1-based indexing.

In Python, list indices start at 0, so the center would be at row (N-1)//2 and column (M-1)//2.

I need to make sure to calculate this correctly.

Let me think about data structures.

- Players: dictionary with player ID as key and position as value.

- Goals: lists for red and blue goals, each containing their positions.

- Quaffle and Bludger: variables holding their positions.

- Carry: variable indicating which player is carrying the Quaffle, or None.

Now, for each action:

- Identify the entity performing the action.

- Perform the action:

- Movement: update the entity's position.

- Catching: set "carry" to the player's ID.

- Throwing: set "carry" to None and place the Quaffle at the player's position.

- After the action, check for elimination and scoring.

For elimination:

- If the entity's position matches the Bludger's position, eliminate the entity if it's a player.

- If the Bludger moves to a player's position, eliminate that player.

- If a player is eliminated while carrying the Quaffle, the Quaffle remains on that cell.

- Print elimination messages in alphabetical order.

For scoring:

- If the Quaffle is on a goal cell:

- Determine which team's goal it is.

- Determine which team scores based on who threw it.

- Print the scoring event.

- Move the Quaffle to the center of the field.

I need to handle these events in the correct order.

Let me think about edge cases.

- Multiple players on the same cell.

- Quaffle being caught or thrown while multiple players are on the same cell.

- Bludger eliminating multiple players at once.

- Players scoring in their own goals.

- Players being eliminated while carrying the Quaffle.

I need to make sure that the code handles these scenarios correctly.

Also, ensure that the field dimensions are odd, as per the problem statement, so the center is well-defined.

I need to make sure that the code doesn't have off-by-one errors in indexing.

Let me think about how to implement the movement function.

I'll define a function, say, move(entity, direction), which updates the entity's position based on the direction.

For example:

- U: row decreases by 1

- D: row increases by 1

- L: column decreases by 1

- R: column increases by 1

I need to ensure that the new position is within the field boundaries.

Wait, but the problem says "Each entity moves by only one cell at a time.", and "All the actions performed by the entities are guaranteed to be valid: the players stay in the field, don't catch a ball if they are not in the same cell, don't release the Quaffle if they are not carrying it, ..."

So, I don't need to worry about invalid moves; all actions are guaranteed to be valid.

Therefore, I can assume that movements won't take entities out of the field.

But I should still handle positions correctly.

Now, about catching the Quaffle.

When a player catches the Quaffle, they start carrying it.

Only one player can carry it at a time.

When a player throws it, they stop carrying it, and the Quaffle is placed at their position.

If a player throws the Quaffle into a goal, the team scores.

I need to make sure that only the team of the player who threw it scores, unless they threw it into their own goal, in which case the opposite team scores.

Wait, no. According to the problem:

"To win a point, a player must leave the Quaffle at a goal of the other team. When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field. There is no goal in the middle of the field. If a player puts the ball in its own goal, the other team wins the point."

So, if a player throws the Quaffle into the opponent's goal, their team scores.

If they throw it into their own goal, the opponent's team scores.

I need to implement this logic.

Now, about the Bludger and eliminations.

When a player moves to the same cell as the Bludger, or vice versa, the player is eliminated.

If multiple players are on the same cell as the Bludger, all are eliminated.

I need to handle this correctly and print the elimination messages in alphabetical order.

Also, if a player is eliminated while carrying the Quaffle, the Quaffle remains on that cell.

I need to make sure that "carry" is set to None in such cases.

Now, let's think about how to structure the code.

I'll need to read N and M, read the grid, parse the positions.

Then, read T, and for each of T actions, process the action, update positions, check for events, and output accordingly.

Finally, print the final score.

I need to make sure that the Quaffle's position is updated correctly when it's being carried by a player.

So, whenever a player moves while carrying the Quaffle, the Quaffle's position should be updated to the player's new position.

Wait, but according to the problem, "The Quaffle does not perform any action while it is being carried; it only follows the movements of the player."

So, yes, when a player carries the Quaffle and moves, the Quaffle moves with them.

When the player throws the Quaffle, it's placed at the player's position, and the player stops carrying it.

I need to handle this properly.

Let me think about the variables I need.

- player: dictionary mapping player ID to their position.

- rg: list of red goal positions.

- bg: list of blue goal positions.

- ball: position of the Quaffle.

- blud: position of the Bludger.

- carry: player ID carrying the Quaffle, or None.

- rs: red team's score.

- bs: blue team's score.

I need to initialize these based on the input.

Now, for each action:

- Determine the entity performing the action.

- Perform the action:

- If it's a movement (U, D, L, R), move the entity.

- If it's catching the Quaffle (C), set carry to the player's ID.

- If it's throwing the Quaffle (T), set carry to None and place the Quaffle at the player's position.

- After the action, check for elimination and scoring.

For elimination:

- If the entity's position matches the Bludger's position, and the entity is a player, eliminate the player.

- Collect all eliminated players and print their elimination messages in alphabetical order.

For scoring:

- If the Quaffle is on a goal cell:

- Determine which team's goal it is.

- Determine which team scores:

- If the player who threw it is from the team that corresponds to the opponent's goal, their team scores.

- If the player threw it into their own goal, the opponent's team scores.

- Print the scoring event.

- Move the Quaffle to the center of the field.

I need to make sure that I correctly identify which goal belongs to which team.

From the problem, RG is a red goal, BG is a blue goal.

Red team tries to score in blue goals, and blue team tries to score in red goals.

So, if a red player throws the Quaffle into a blue goal, red team scores.

If a blue player throws the Quaffle into a red goal, blue team scores.

If a red player throws the Quaffle into a red goal, blue team scores.

Similarly, if a blue player throws the Quaffle into a blue goal, red team scores.

I need to implement this logic.

Now, about the center of the field.

Given that N and M are odd, the center is at row (N+1)/2 and column (M+1)/2, 1-based indexing.

In 0-based indexing, it's at row (N-1)//2 and column (M-1)//2.

I need to calculate this correctly.

Let me think about the reference solution provided.

Wait, the reference solution seems to have some functions defined at the end, but they are not defined in the code snippet. It says "def func_1(obj, d):" and "def func_2(t):", but their implementations are not shown.

Assuming that func_1 is for moving an object in a direction, and func_2 is for checking eliminations, I need to implement these functions accordingly.

But since the reference solution is incomplete, I need to write the full code.

Let me outline the steps again:

1. Read N and M.

2. Read N lines of M pairs of characters to parse the initial field.

3. Initialize player positions, goals, Quaffle and Bludger positions, and carry.

4. Read T.

5. For each of T steps:

a. Read the action.

b. Determine the entity performing the action.

c. Perform the action:

- Movement: update the entity's position.

- Catching: set carry to the player's ID.

- Throwing: set carry to None and place the Quaffle at the player's position.

d. Check for elimination:

- If the entity's position matches the Bludger's position and the entity is a player, eliminate the player.

- If the Bludger's position matches a player's position, eliminate that player.

- Collect eliminated players and print their elimination messages in alphabetical order.

e. Check for scoring:

- If the Quaffle is on a goal cell:

- Determine which team's goal it is.

- Determine which team scores based on who threw it.

- Print the scoring event.

- Move the Quaffle to the center of the field.

6. After all actions, print the final score.

I need to make sure that the Quaffle's position is updated correctly when it's being carried by a player.

So, whenever a player moves while carrying the Quaffle, the Quaffle should move with them.

Similarly, when a player throws the Quaffle, it's placed at the player's position.

I need to handle these updates carefully.

Also, ensure that the center of the field is correctly calculated.

Now, let's think about how to implement the elimination checks.

I need to check if any player is on the same cell as the Bludger after movements.

Since movements can be performed by players, the Quaffle, or the Bludger, I need to check for overlaps after each movement.

Wait, but according to the problem, "All entities can move. A player can also catch a ball or throw the Quaffle that it is carrying."

And "if a player is eliminated while it is carrying the Quaffle, the Quaffle remains on the cell containing both the player and the Bludger after the move."

So, if a player is eliminated while carrying the Quaffle, the Quaffle stays at that position.

I need to make sure that in such cases, "carry" is set to None.

Also, ensure that elimination doesn't occur while a player is in a goal cell.

Given that, I need to handle eliminations after movements and catch/thrown actions.

Let me think about the sequence of operations for each action:

1. Identify the entity performing the action.

2. Perform the action:

- Movement: update the entity's position.

- Catching: set carry to the player's ID.

- Throwing: set carry to None and place the Quaffle at the player's position.

3. Check for eliminations:

- If the entity's new position matches the Bludger's position and the entity is a player, eliminate the player.

- If the Bludger's new position matches any player's position, eliminate those players.

4. Check for scoring:

- If the Quaffle is on a goal cell, determine which team scores and print the event.

- Move the Quaffle to the center of the field.

I need to ensure that these checks are performed in this order after each action.

Now, about the output.

For each scoring event or elimination, I need to print the event with the correct timing (the step number, starting from 0).

If multiple players are eliminated at the same time, print their elimination messages in alphabetical order.

At the end, print the final score in the format "FINAL SCORE: r b", where r and b are the scores of the red and blue teams, respectively.

I need to make sure that the scores are correctly updated and printed.

Now, let's consider an example to verify my logic.

Take the first sample input:

3 5

.. .. R0 .. ..

RG .. .Q .. BG

.. .. B0 .. ..

12

R0 D

R0 C .Q

R0 R

R0 T

R0 D

B0 R

B0 U

B0 C .Q

B0 L

B0 L

B0 L

B0 T

According to the sample output:

11 BLUE GOAL

FINAL SCORE: 0 1

Let's simulate this:

Initial positions:

Row 0:

.. .. R0 .. ..

Row 1:

RG .. .Q .. BG

Row 2:

.. .. B0 .. ..

So, row 0:

Positions: (0,0).., (0,1).., (0,2)R0, (0,3).., (0,4)..

Row 1:

(1,0)RG, (1,1).., (1,2).Q, (1,3).., (1,4)BG

Row 2:

(2,0).., (2,1).., (2,2)B0, (2,3).., (2,4)..

carry = None

Step 0: R0 D

R0 moves down from (0,2) to (1,2)

Now, R0 is at (1,2), where the Quaffle is.

carry remains None.

Check for elimination: R0 is not on the Bludger.

Check for scoring: Quaffle is not on a goal cell.

Step 1: R0 C .Q

R0 catches the Quaffle.

carry = "R0"

Quaffle is now carried by R0, so its position is updated to R0's position: (1,2)

Step 2: R0 R

R0 moves right from (1,2) to (1,3)

Quaffle moves with R0 to (1,3)

Check for elimination: R0 is not on the Bludger.

Check for scoring: Quaffle is not on a goal cell.

Step 3: R0 T

R0 throws the Quaffle.

carry = None

Quaffle is placed at R0's position: (1,3)

Check for scoring: Is (1,3) a goal cell? It's empty, so no scoring.

Move Quaffle to (1,3)

Step 4: R0 D

R0 moves down from (1,3) to (2,3)

carry remains None

Check for elimination: R0 is not on the Bludger.

Check for scoring: Quaffle is at (1,3), which is not a goal cell.

Step 5: B0 R

B0 moves right from (2,2) to (2,3)

carry remains None

Check for elimination: B0 is not on the Bludger.

Check for scoring: Quaffle is at (1,3), no scoring.

Step 6: B0 U

B0 moves up from (2,3) to (1,3)

carry remains None

Check for elimination: B0 is not on the Bludger.

Check for scoring: Quaffle is at (1,3), no scoring.

Step 7: B0 C .Q

B0 catches the Quaffle.

carry = "B0"

Quaffle moves to B0's position: (1,3)

Step 8: B0 L

B0 moves left from (1,3) to (1,2)

Quaffle moves with B0 to (1,2)

Check for elimination: B0 is not on the Bludger.

Check for scoring: (1,2) is RG, which is a red goal.

Since B0 is from blue team, throwing into red goal, blue team scores.

Print "7 BLUE GOAL"

Move Quaffle to center: (N-1)//2, (M-1)//2 = (1,2)

Step 9: B0 L

B0 moves left from (1,2) to (1,1)

Quaffle is not being carried, so it remains at the center (1,2)

carry remains None

Check for elimination: B0 is not on the Bludger.

Check for scoring: Quaffle is at (1,2), which is RG, a goal cell.

But since it was already scored in step 7, probably Quaffle is moved to center after scoring, so it's now at (1,2), which is RG again.

Wait, but according to the problem, after scoring, the Quaffle is moved to the center.

So, after step 7, Quaffle should be at (1,2), which is the center in this case.

But (1,2) is RG, which is a goal cell.

Wait, in this 3x5 grid, center is (1,2), which is RG.

But according to the problem, "There is no goal in the middle of the field."

Wait, in this sample input, the center is (1,2), which is RG.

Is this allowed? The problem says "There is no goal in the middle of the field."

But in this sample input, the center is a goal.

Is this a mistake?

Wait, perhaps the problem allows goals to be in the center, but says that when a goal is scored, the Quaffle is moved to the center, and "There is no goal in the middle of the field."

Wait, re-reading the problem:

"When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field. There is no goal in the middle of the field."

So, the center cell does not have a goal.

But in this sample input, the center cell is RG.

Is this an error in the sample input?

Wait, looking back at the sample input:

Row 0: .. .. R0 .. ..

Row 1: RG .. .Q .. BG

Row 2: .. .. B0 .. ..

So, row 1, column 2 is .Q, which is the Quaffle.

But according to the grid, (1,2) is .Q, not RG.

Wait, no, in the sample input, it's:

RG .. .Q .. BG

So, row 1: positions 0 to 4:

(1,0): RG

(1,1): ..

(1,2): .Q

(1,3): ..

(1,4): BG

So, center is (1,2), which is .Q, not RG.

Wait, perhaps I misread.

In the grid, positions are row first, then column.

So, row 1, column 0 is RG.

Row 1, column 2 is .Q.

Center is row 1, column 2, which is .Q.

So, no goal is in the center.

Therefore, after scoring, the Quaffle is moved to the center, which is (1,2), and there is no goal there.

In step 7, B0 throws the Quaffle into RG at (1,2), scores a point, and Quaffle is moved to the center (1,2), which is empty.

Then, in step 9, B0 moves left to (1,1), and Quaffle is at (1,2), which is empty.

No further scoring.

Then, in step 11, B0 throws the Quaffle.

But according to the sample output, the blue goal is scored at step 11.

Wait, sample output says:

11 BLUE GOAL

FINAL SCORE: 0 1

Wait, perhaps I miscounted the steps.

Looking back, the sample input has 12 steps, but the output shows step 11 for the blue goal.

Wait, perhaps I need to recount the steps carefully.

Let me list the steps again:

Step 0: R0 D

Step 1: R0 C .Q

Step 2: R0 R

Step 3: R0 T

Step 4: R0 D

Step 5: B0 R

Step 6: B0 U

Step 7: B0 C .Q

Step 8: B0 L

Step 9: B0 L

Step 10: B0 L

Step 11: B0 T