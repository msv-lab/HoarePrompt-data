Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers i, j, and x, where 1 ≤ i ≤ j ≤ n, and then setting all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is essentially the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I have to spend to achieve this. It's guaranteed that I can always make all elements equal, so I don't need to worry about cases where it's impossible.

First, I need to understand what operations I can perform. I can choose any contiguous subarray and set all its elements to any value x, and I can do this at most once. After this operation, the array should have all elements equal.

Wait, actually, the problem says "no more than once," which means I can choose to perform the operation zero or one time. So, I might not need to perform any operation if the array is already uniform.

Looking at the examples:

In the first test case:

6

1 2 3 4 5 1

If I set indices 2 to 4 to 8, I get [1,8,8,8,5,1]. Then, I need to make all elements equal. Maybe set the entire array to 8, but that would cost 6 burles. But the output is 4, so there must be a better way.

Wait, perhaps setting indices 2 to 5 to 1, making the array [1,1,1,1,1,1], which costs 4 burles.

Okay, so the minimal cost is 4.

In the second test case:

7

1 1 1 1 1 1 1

The array is already uniform, so no operation is needed, and the cost is 0.

Third test case:

8

8 8 8 1 2 8 8 8

Here, if I set indices 4 to 5 to 8, making the array [8,8,8,8,8,8,8,8], which costs 2 burles.

And so on.

So, I need a general approach to find the minimal cost to make the array uniform with at most one operation.

Let me think about this.

First, if the array is already uniform, the cost is 0.

If not, I need to choose a subarray to set to a certain value, such that the entire array becomes uniform, and minimize the cost, which is the length of the subarray being set.

Wait, but I can set the subarray to any value x, which may or may not be present in the array.

Wait, actually, x can be any integer, not necessarily present in the array.

But in the operation, I'm setting a subarray to x, and the rest of the array remains as is, except that I need the entire array to be equal after at most one operation.

Wait, hold on. If I perform the operation, I set a subarray to x, and then the rest of the array remains as is, but I need the entire array to have all elements equal.

So, after the operation, the entire array should have all elements equal to some value, say y.

Now, I need to choose x and the subarray in such a way that after setting the subarray to x, the entire array becomes y.

Wait, but y could be x, meaning I set the subarray to x, and the rest of the array must already be x, or I set them to x as well.

Wait, but I can only perform the operation once, so I can only set one subarray to x.

Wait, perhaps I need to choose x to be the value that is already present in most of the array, and set the subarray that doesn't match to x.

Wait, maybe I should think differently.

Let's consider that after the operation, all elements in the array should be equal to some value y.

I need to choose y, and then decide which subarray to set to y, so that the entire array becomes y.

But I can only perform one operation, which allows me to set one subarray to y.

So, I need to find the minimal cost to make the array all y, with at most one operation.

Wait, perhaps it's better to iterate over possible y values, and for each y, find the minimal cost to make the array all y with at most one operation.

But since n can be up to 2e5, and t up to 1e4, with total n across all test cases up to 2e5, I need an efficient solution, preferably linear per test case.

Wait, but the provided program seems to have a function func_1 that takes the array and returns some value.

Looking at func_1:

def func_1(arr):

i = 0

n = len(arr)

j = len(arr) - 1

while i < len(arr) - 1 and arr[i] == arr[i + 1]:

i += 1

while j > 0 and arr[j] == arr[j - 1]:

j -= 1

if arr[0] == arr[-1]:

return max(j - i - 1, 0)

return max(min(n - i - 1, j), 0)

So, it seems to be finding some indices i and j based on some conditions.

Let me try to understand what this function is doing.

First, it initializes i to 0 and j to n-1.

Then, it has a while loop that increments i as long as arr[i] == arr[i+1], so it's finding the largest i such that arr[0] == arr[1] == ... == arr[i]

Similarly, it has another while loop that decrements j as long as arr[j] == arr[j-1], so it's finding the smallest j such that arr[j] == arr[j+1] == ... == arr[n-1]

Then, it checks if arr[0] == arr[-1]:

If yes, it returns max(j - i - 1, 0)

Else, it returns max(min(n - i - 1, j), 0)

Hmm, I need to understand what this is calculating.

Let me take an example.

Take the first test case:

6

1 2 3 4 5 1

So, arr = [1,2,3,4,5,1]

Initialize i=0, j=5

First while: arr[0]==1, arr[1]==2, so i stays 0

Second while: arr[5]==1, arr[4]==5, so j becomes 4

arr[0] == arr[-1] (both 1), so return max(4 - 0 -1, 0) = 3

But according to the sample output, it should be 4.

Wait, maybe I misread the array.

Wait, in the first test case, n=6, arr=[1,2,3,4,5,1]

So, arr[0]=1, arr[1]=2, so i=0

arr[5]=1, arr[4]=5, so j=4

arr[0]==arr[5], so return max(4 - 0 -1, 0) = 3

But sample output is 4.

Hmm, discrepancy here.

Wait, perhaps the function is incorrect.

Another test case:

7

1 1 1 1 1 1 1

arr = [1,1,1,1,1,1,1]

i=6 (since arr[6]==1, and arr[5]==1, etc.)

j=0 (since arr[0]==1 and arr[1]==1, etc.)

arr[0]==arr[-1], so max(0 - 6 -1, 0) = max(-7,0)=0

Which matches the sample output.

Another test case:

8

8 8 8 1 2 8 8 8

arr = [8,8,8,1,2,8,8,8]

i=2 (since arr[0]=8, arr[1]=8, arr[2]=8, arr[3]=1)

j=4 (arr[4]=2, arr[5]=8, arr[6]=8, arr[7]=8)

arr[0] != arr[-1] (both are 8, wait, no, arr[-1]=8, arr[0]=8, so arr[0]==arr[-1]

So, max(4 - 2 -1, 0) = max(1,0)=1

But sample output is 2.

Another test case:

1

1

n=1, arr=[1]

i=0, j=0

arr[0]==arr[-1], max(0-0-1,0)=max(-1,0)=0

Which matches sample output.

Another test case:

2

1 2

i=0 (arr[0]=1, arr[1]=2)

j=1 (arr[1]=2, arr[0]=1)

arr[0]!=arr[-1], so max(min(2-0-1,4)=min(1,1)=1

Wait, n=2, so n - i -1 =1, j=1

So, max(min(1,1),0)=1

Which matches sample output.

Another test case:

3

1 2 3

i=0 (arr[0]=1, arr[1]=2)

j=2 (arr[2]=3, arr[1]=2)

arr[0]!=arr[-1], so max(min(3-0-1,2),0)=max(min(2,2),0)=2

Which matches sample output.

Another test case:

7

4 3 2 7 1 1 3

i=0 (arr[0]=4, arr[1]=3)

j=6 (arr[6]=3, arr[5]=1)

arr[0]!=arr[-1], so max(min(7-0-1,6),0)=max(min(6,6),0)=6

Which matches sample output.

Another test case:

9

9 9 2 9 2 5 5 5 3

i=1 (arr[0]=9, arr[1]=9, arr[2]=2)

j=8 (arr[8]=3, arr[7]=5)

arr[0]!=arr[-1], so max(min(9-1-1,8),0)=max(min(7,8),0)=7

Which matches sample output.

Wait, but in the first test case, it returned 3, but sample output is 4.

Wait, perhaps there's a mistake in understanding the indices.

Let's re-examine the first test case.

n=6, arr=[1,2,3,4,5,1]

i=0 (since arr[0]=1, arr[1]=2)

j=4 (since arr[4]=5, arr[5]=1)

arr[0]==arr[5], so arr[0]==arr[-1]

So, max(j - i -1, 0) = max(4 - 0 -1, 0) = 3

But sample output is 4.

Hmm, seems inconsistent.

Wait, maybe the function is incorrect.

Alternatively, perhaps I miscounted the indices.

Let me see:

arr = [1,2,3,4,5,1]

Indices: 0,1,2,3,4,5

i=0 (arr[0]=1, arr[1]=2)

j=4 (arr[4]=5, arr[5]=1)

So, j - i -1 = 4 - 0 -1 = 3

But in reality, to make all elements equal to 1, I need to set indices 1 to 5 to 1, which costs 5, but in the sample output, it's 4.

Wait, maybe set indices 2 to 5 to 1, making arr=[1,2,1,1,1,1], then set indices 1 to 1 to 1, but operations are limited to one.

Wait, but the operation can only be performed once.

Wait, perhaps setting indices 2 to 5 to 1, costing 4, resulting in [1,2,1,1,1,1], then the entire array is not equal.

Wait, no, I can only perform one operation.

Wait, perhaps I need to choose a subarray and set it to a value such that the entire array becomes equal to that value.

So, if I set indices 1 to 5 to 1, costing 5, then the array becomes [1,1,1,1,1,1].

But the sample output is 4, so there must be a better way.

Wait, maybe setting indices 2 to 5 to 1 costs 4, and since the first and last elements are already 1, the entire array becomes [1,2,1,1,1,1], which is not uniform.

Wait, no, if I set indices 2 to 5 to 1, the array becomes [1,2,1,1,1,1], which is not uniform.

I need to set a subarray such that after setting, all elements are equal.

Wait, maybe setting indices 1 to 4 to 1, making [1,1,1,1,5,1], then set indices 4 to 4 to 1, but I can only perform one operation.

Wait, hold on, I can only perform one operation.

So, I need to choose one subarray to set to x, and after that, the entire array should be equal to x.

So, in this case, setting indices 1 to 5 to 1, costing 5, makes the array [1,1,1,1,1,1].

But the sample output is 4, so there must be a better way.

Wait, maybe setting indices 2 to 5 to 1, costing 4, makes [1,2,1,1,1,1], which is not uniform.

So, that doesn't work.

Wait, maybe setting indices 1 to 4 to 1, costing 4, makes [1,1,1,1,5,1], which is still not uniform.

So, I need to set indices 1 to 5 to 1, costing 5.

But sample output is 4.

Hmm, confusion.

Wait, perhaps there's a different approach.

Let me think differently.

Suppose I choose to make all elements equal to a particular value y.

Then, I need to cover all positions that are not y with one subarray operation.

So, find the minimal length of subarray to cover all non-y elements.

Then, the cost is the length of that subarray.

So, for each y, find the minimal subarray that covers all non-y elements.

Then, choose y such that this minimal subarray length is minimized.

That would be the minimal cost.

In the first test case, arr=[1,2,3,4,5,1]

If I choose y=1, then non-1 elements are at positions 1,2,3,4.

So, the minimal subarray covering positions 1 to 4 is of length 4.

Hence, cost is 4.

If I choose y=2, non-2 elements are at positions 0,2,3,4,5.

The minimal subarray covering these is positions 0 to 5, length 6.

Similarly, for y=3, non-3 elements are at positions 0,1,3,4,5, length 5.

Similarly for y=4 and y=5.

So, choosing y=1 gives the minimal cost of 4.

Hence, the minimal cost is 4.

Similarly, in the second test case, all elements are 1, so cost is 0.

In the third test case, arr=[8,8,8,1,2,8,8,8]

If I choose y=8, non-8 elements are at positions 3 and 4.

The minimal subarray covering positions 3 and 4 is of length 2.

Hence, cost is 2.

Which matches the sample output.

So, this seems to be a correct approach.

So, for each y, find the minimal subarray that covers all non-y elements.

Then, choose the y that minimizes this subarray length.

That would be the minimal cost.

Now, to implement this efficiently, since n can be up to 2e5 and t up to 1e4, with total n across all test cases up to 2e5, I need an efficient solution per test case, preferably O(n).

So, for each test case, I need to find the minimal subarray length over all possible y.

An efficient way to do this is to find the minimal subarray that covers all positions where a_i != y, for each y.

But doing this for each y separately would be inefficient.

Instead, I can find the minimal subarray that covers all positions where a_i != mode, where mode is the most frequent element in the array.

Wait, perhaps not.

Wait, actually, the optimal y should be the most frequent element in the array, because then the number of positions that need to be covered is minimized.

So, find the mode of the array, then find the minimal subarray that covers all positions where a_i != mode.

Then, the cost is the length of this subarray.

This should be the minimal cost.

Wait, but is this always true?

Let's consider a counterexample.

Suppose arr=[1,2,1,2,1], n=5.

The mode is 1, appearing 3 times.

Non-1 elements are at positions 1 and 3.

The minimal subarray covering positions 1 and 3 is from 1 to 3, length 3.

So, cost is 3.

But if I choose y=2, which appears 2 times, non-2 elements are at positions 0,2,4.

The minimal subarray covering these is from 0 to 4, length 5.

So, choosing y=1 gives cost 3, which is better than choosing y=2.

So, in this case, choosing the mode is better.

Another example: arr=[1,1,2,2,3], n=5.

Mode is 1 and 2, both appearing twice.

If I choose y=1, non-1 elements are at positions 2,3,4.

Minimal subarray from 2 to 4, length 3.

If I choose y=2, non-2 elements are at positions 0,1,4.

Minimal subarray from 0 to 4, length 5.

So, choosing y=1 is better.

If I choose y=3, non-3 elements are at positions 0,1,2,3.

Minimal subarray from 0 to 3, length 4.

So, choosing y=1 gives the minimal cost of 3.

Hence, choosing the mode seems to be the way to go.

So, in general, choose y to be the mode, and find the minimal subarray that covers all non-mode elements.

The cost is the length of this subarray.

Now, to implement this efficiently, I need to find the mode, and then find the minimal subarray that covers all non-mode elements.

Finding the mode can be done in O(n) time.

Then, to find the minimal subarray that covers all non-mode elements, I can find the minimal window that includes all positions where a_i != mode.

This can also be done in O(n) time using a sliding window approach.

Hence, per test case, this can be done in O(n) time, which is acceptable given the constraints.

Now, looking back at the provided program, it seems to be attempting something similar, but it's not clear exactly what it's doing.

In the function func_1, it seems to be finding the minimal subarray to cover some part of the array, but it's not clear.

Looking at the code:

def func_1(arr):

i = 0

n = len(arr)

j = len(arr) - 1

while i < len(arr) - 1 and arr[i] == arr[i + 1]:

i += 1

while j > 0 and arr[j] == arr[j - 1]:

j -= 1

if arr[0] == arr[-1]:

return max(j - i - 1, 0)

return max(min(n - i - 1, j), 0)

So, it's finding the largest i such that arr[0] == arr[1] == ... == arr[i]

And the smallest j such that arr[j] == arr[j+1] == ... == arr[n-1]

Then, if arr[0] == arr[-1], it returns max(j - i -1, 0), else max(min(n - i -1, j), 0)

In the first test case, arr=[1,2,3,4,5,1], arr[0]==arr[-1]==1, i=0, j=4, so j - i -1 =3, but sample output is 4.

Wait, discrepancy here.

In the third test case, arr=[8,8,8,1,2,8,8,8], arr[0]==arr[-1]==8, i=2, j=4, so j - i -1 =1, but sample output is 2.

So, seems incorrect.

Wait, perhaps the function is calculating something else.

Alternatively, perhaps it's calculating the minimal subarray length differently.

But in the second test case, arr=[1,1,1,1,1,1,1], i=6, j=0, arr[0]==arr[-1], so max(0-6-1,0)=0, which is correct.

In the fourth test case, n=1, arr=[1], i=0, j=0, arr[0]==arr[-1], max(0-0-1,0)=0, correct.

Fifth test case, n=2, arr=[1,2], i=0, j=1, arr[0]!=arr[-1], so max(min(1,1),0)=1, correct.

Sixth test case, n=3, arr=[1,2,3], i=0, j=2, arr[0]!=arr[-1], so max(min(2,2),0)=2, correct.

Seventh test case, n=7, arr=[4,3,2,7,1,1,3], i=0, j=6, arr[0]!=arr[-1], so max(min(6,6),0)=6, correct.

Eighth test case, n=9, arr=[9,9,2,9,2,5,5,5,3], i=1, j=8, arr[0]!=arr[-1], so max(min(8,8),0)=8, but sample output is 7.

Wait, sample output for the eighth test case is 7, but according to this function, it would return 8.

So, discrepancy again.

Hence, it seems that this function is not correctly implementing the minimal subarray approach.

Perhaps there's a mistake in the implementation.

Alternatively, maybe there's a different optimal strategy.

Wait, perhaps the function is trying to find the minimal subarray that needs to be set to make the array uniform.

But based on the sample inputs and outputs, it seems to be miscalculating in some cases.

So, perhaps the provided program is incorrect.

But I need to determine if the given program is correct or not based on the problem description.

Given that in some test cases, it seems to produce incorrect outputs, I would say that the program is incorrect.

Hence, Correctness: False

