Alright, I have this problem to solve. Let's see what it's about. So, Polycarp lost his string, which is made up of lowercase Latin letters, but he has something called a "trace" of the string. The trace is an array of integers that correspond to the original string in a specific way. Specifically, for each position i in the string (starting from 1), a_i is the number of indices j (where j < i) such that the character at position i is the same as the character at position j.

For example, in the string "abracadabra", the trace is [0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 4]. Looking at this, it seems that for each character, a_i tells us how many times that character has appeared before position i.

My task is, given this trace, to reconstruct any string that could have produced this trace. The problem guarantees that a valid string exists for the given trace.

First, I need to understand the trace fully. Let's take the example provided:

String: a b r a c a d a b r a

Positions: 1 2 3 4 5 6 7 8 9 10 11

Trace: 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 4

Let's verify this:

- Position 1: 'a', no previous 'a's, so a_1 = 0

- Position 2: 'b', no previous 'b's, so a_2 = 0

- Position 3: 'r', no previous 'r's, so a_3 = 0

- Position 4: 'a', one previous 'a' at position 1, so a_4 = 1

- Position 5: 'c', no previous 'c's, so a_5 = 0

- Position 6: 'a', two previous 'a's at positions 1 and 4, so a_6 = 2

- Position 7: 'd', no previous 'd's, so a_7 = 0

- Position 8: 'a', three previous 'a's at positions 1, 4, and 6, so a_8 = 3

- Position 9: 'b', one previous 'b' at position 2, so a_9 = 1

- Position 10: 'r', one previous 'r' at position 3, so a_10 = 1

- Position 11: 'a', four previous 'a's at positions 1, 4, 6, and 8, so a_11 = 4

This makes sense. So, for each position, a_i counts how many times the same character has appeared before.

Now, I need to reverse-engineer this. Given the array a, I need to construct a string s such that the trace of s is exactly a.

Constraints:

- t (number of test cases) is up to 10^4, but the sum of n over all test cases is up to 2*10^5, so individual test cases can have n up to 2*10^5, but on average, it should be manageable.

Given that, I need an efficient solution, probably O(n) per test case.

Let's think about how to approach this.

I need to assign characters to positions based on the a_i values.

One way to think about it is to keep track of how many times each character has been used so far.

For each position i from 1 to n:

- I look at a_i, which is the number of times the character at position i has appeared before.

- I need to choose a character that has appeared exactly a_i times so far.

- If no such character exists, I need to choose a new character (one that has appeared 0 times so far).

- If multiple characters have appeared a_i times, I can choose any of them.

But wait, the problem guarantees that a valid string exists for the given trace, so I don't have to worry about impossible cases.

Let's consider an example.

Take n=5, a=[0,0,0,1,2]

Let's try to build s:

- Position 1: a_1=0 → this is the first occurrence of its character.

Possible choices: any character, say 'a'

s='a'

Counts: a=1

- Position 2: a_2=0 → first occurrence of its character.

Choose a different character, say 'b'

s='ab'

Counts: a=1, b=1

- Position 3: a_3=0 → first occurrence of its character.

Choose another new character, say 'c'

s='abc'

Counts: a=1, b=1, c=1

- Position 4: a_4=1 → the character has appeared once before.

Possible choices: 'a', 'b', or 'c', since each has appeared once so far.

Choose 'a'

s='abca'

Counts: a=2, b=1, c=1

- Position 5: a_5=2 → the character has appeared twice before.

Only 'a' has appeared twice so far.

Choose 'a'

s='abcaa'

Counts: a=3, b=1, c=1

Let's check the trace:

- a: positions 1,4,5 → counts: 0,1,2

- b: positions 2 → count: 0

- c: positions 3 → count: 0

Which matches a=[0,0,0,1,2]

Another possible string could be 'abcbc' with a=[0,0,0,1,2]

- Position 1: 'a' → 0

- Position 2: 'b' → 0

- Position 3: 'c' → 0

- Position 4: 'b' →1 (appeared once before)

- Position 5: 'c' →1 (appeared once before)

Wait, but a_5=2 in this case, but 'c' has only appeared once before. So that's incorrect.

Wait, maybe 'abcbc' doesn't correspond to a=[0,0,0,1,2]. Let's check:

- Position 1: 'a' →0

- Position 2: 'b' →0

- Position 3: 'c' →0

- Position 4: 'b' →1

- Position 5: 'c' →1

So, a=[0,0,0,1,1], but in my earlier example, a=[0,0,0,1,2], so it's different.

So, for a=[0,0,0,1,2], 'abcaa' is correct.

Another example from the problem:

n=11, a=[0,0,0,1,0,2,0,3,1,1,4] → "abracadabra"

Let's see:

- Position 1: 'a' →0

- Position 2: 'b' →0

- Position 3: 'r' →0

- Position 4: 'a' →1

- Position 5: 'c' →0

- Position 6: 'a' →2

- Position 7: 'd' →0

- Position 8: 'a' →3

- Position 9: 'b' →1

- Position 10: 'r' →1

- Position 11: 'a' →4

Which matches the trace.

So, the approach seems valid.

Now, to implement this efficiently, I need a way to assign characters based on their frequency so far.

I can keep track of the frequency of each character.

I can use an array of size 26, one for each lowercase letter, and initialize them to 0.

For each position i from 1 to n:

- I look at a_i.

- I need to find a character whose current frequency is equal to a_i.

- If such a character exists, assign that character to position i and increment its frequency.

- If no such character exists, it means I need to assign a new character with frequency 0, but since a_i is not 0, this shouldn't happen, as the problem guarantees a valid string exists.

But wait, if a_i is 0, I need to assign a new character that hasn't appeared before.

If a_i is k > 0, I need to assign a character that has appeared exactly k times so far.

To do this efficiently, I can iterate through the 26 letters and for each letter, check if its current frequency matches a_i.

If it does, assign that letter to position i and increment its frequency.

Since n can be up to 2e5 and t up to 1e4, but sum of n over all test cases is up to 2e5, it should be efficient enough.

Let's try implementing this logic.

Define a function, say, reconstruct_string(n, a):

s = ''  # Initialize the string

char_count = [0] * 26  # Frequency of each character, a to z

for ai in a:

for j in range(26):

if char_count[j] == ai:

s += chr(j + ord('a'))  # Append the character

char_count[j] += 1  # Increment its frequency

break

return s

Then, for each test case, read n, read a, call reconstruct_string(n, a), and print it.

This seems straightforward.

Let's test it with the first example:

n=11, a=[0,0,0,1,0,2,0,3,1,1,4]

Initialize char_count = [0,0,0,...,0]

First ai=0:

Find j where char_count[j]==0, say j=0 ('a'), assign 'a', char_count[0]=1

s='a'

Next ai=0:

Find j where char_count[j]==0, j=1 ('b'), assign 'b', char_count[1]=1

s='ab'

Next ai=0:

Find j=2 ('c'), assign 'c', char_count[2]=1

s='abc'

Next ai=1:

Find j where char_count[j]==1, j=0 ('a'), assign 'a', char_count[0]=2

s='aba'

Wait, but in the example, it's "abracadabra".

Wait, maybe my choice of characters matters.

In the first step, when ai=0, I can choose any j where char_count[j]==0.

In the first three steps, I chose 'a', 'b', 'c', but in "abracadabra", the third character is 'r'.

So, in the third step, when ai=0, I should choose 'r' instead of 'c'.

Wait, but 'c' is also fine, as long as it's a new character.

Wait, no, in the example, the trace is [0,0,0,1,0,2,0,3,1,1,4], which corresponds to "abracadabra".

But in my earlier attempt, I had 'abc', then 'a', then 'd', etc., which might not match the example string, but it should still be a valid string as long as the trace matches.

Wait, but in the problem statement, it says "find any string s from which it could have been obtained."

So, multiple strings might correspond to the same trace, as long as the frequency counts match.

In my earlier attempt, 'abcaa' for a=[0,0,0,1,2] is valid, but 'abcbc' is not valid for that trace because it would have a different trace.

Wait, in 'abcbc', a=[0,0,0,1,1], which is different from a=[0,0,0,1,2].

So, in my earlier step, when I tried to assign 'abcaa', it matched a=[0,0,0,1,2].

If I choose 'abcbc', it would correspond to a different trace.

So, in reconstructing the string, as long as the trace matches, it's acceptable.

Hence, in my implementation, choosing any available character for each ai is fine.

Now, looking back at my earlier implementation:

def reconstruct_string(n, a):

s = ''

char_count = [0] * 26

for ai in a:

for j in range(26):

if char_count[j] == ai:

s += chr(j + ord('a'))

char_count[j] += 1

break

return s

This should work.

Let's test it with n=5, a=[0,0,0,1,2]

- Initialize char_count = [0,0,0,...,0]

- ai=0: find j=0, char='a', s='a', char_count[0]=1

- ai=0: find j=1, char='b', s='ab', char_count[1]=1

- ai=0: find j=2, char='c', s='abc', char_count[2]=1

- ai=1: find j=0, char='a', s='aba', char_count[0]=2

- ai=2: find j=0, char='a', s='abaa', char_count[0]=3

Wait, but in my earlier manual construction, I had 'abcaa', which is different from 'abaa'.

Wait, no, 'abaa' is s='abaa', but I think I made a mistake.

Wait, in the fourth step, ai=1, I choose 'a', so s='aba', then ai=2, choose 'a' again, s='abaa'.

But in my manual construction, I had 'abcaa', which is 'aba' plus 'c' and 'a'.

Wait, perhaps I confused myself.

Wait, no, in the fourth step, ai=1, choose 'a', s='aba', then ai=2, choose 'a', s='abaa'.

But in the manual construction earlier, I had 'abcaa', which is different.

Wait, perhaps I made a mistake earlier.

Wait, no, in the manual construction, I had:

- Position 1: 'a' →0

- Position 2: 'b' →0

- Position 3: 'c' →0

- Position 4: 'a' →1

- Position 5: 'a' →2

Which is 'abcaa', which corresponds to a=[0,0,0,1,2]

But in the code, it produces 'abaa', which also corresponds to a=[0,0,0,1,2]

Wait, no:

In 'abaa':

- Position 1: 'a' →0

- Position 2: 'b' →0

- Position 3: 'a' →1

- Position 4: 'a' →2

Which corresponds to a=[0,0,1,2], but the test case has a=[0,0,0,1,2]

So, there's a discrepancy.

Hence, the code is incorrect in this case.

Wait, in the code, for n=5, a=[0,0,0,1,2], it produces 'abaa', but the trace for 'abaa' is [0,0,1,2], which is different from [0,0,0,1,2].

Wait, no, 'abaa' has n=4, but in my test case, n=5.

Wait, perhaps I made a mistake in simulating the code.

Let's simulate the code step by step for n=5, a=[0,0,0,1,2]

Initialize char_count = [0,0,0,...,0]

- ai=0:

Find j=0, char='a', s='a', char_count[0]=1

- ai=0:

Find j=1, char='b', s='ab', char_count[1]=1

- ai=0:

Find j=2, char='c', s='abc', char_count[2]=1

- ai=1:

Find j=0, char='a', s='abca', char_count[0]=2

- ai=2:

Find j=0, char='a', s='abcaa', char_count[0]=3

So, s='abcaa', which matches the manual construction.

Wait, earlier I thought s='abaa', but that was a mistake.

So, the code actually produces 'abcaa' for a=[0,0,0,1,2], which is correct.

Earlier, I mistakenly thought it produced 'abaa', but that's not the case.

Hence, the code is correct for this test case.

Another test case: n=5, a=[0,0,0,1,1]

- Initialize char_count = [0,0,0,...,0]

- ai=0: j=0, 'a', s='a', char_count[0]=1

- ai=0: j=1, 'b', s='ab', char_count[1]=1

- ai=0: j=2, 'c', s='abc', char_count[2]=1

- ai=1: j=0, 'a', s='abca', char_count[0]=2

- ai=1: j=1, 'b', s='abcab', char_count[1]=2

So, s='abcab', and the trace is [0,0,0,1,1], which matches.

Another test case: n=8, a=[0,1,2,3,4,5,6,7]

- Initialize char_count = [0,0,0,...,0]

- ai=0: j=0, 'a', s='a', char_count[0]=1

- ai=1: j=0, 'a', s='aa', char_count[0]=2

- ai=2: j=0, 'a', s='aaa', char_count[0]=3

- ai=3: j=0, 'a', s='aaaa', char_count[0]=4

- ai=4: j=0, 'a', s='aaaaa', char_count[0]=5

- ai=5: j=0, 'a', s='aaaaaa', char_count[0]=6

- ai=6: j=0, 'a', s='aaaaaaa', char_count[0]=7

- ai=7: j=0, 'a', s='aaaaaaaa', char_count[0]=8

So, s='aaaaaaaa', which matches the trace [0,1,2,3,4,5,6,7]

Another test case: n=8, a=[0,0,0,0,0,1,0,1,1,0]

Wait, in the example input, it's n=10, a=[0,0,0,0,0,1,0,1,1,0], and the output is "codeforces"

Let's see:

- Position 1: 'c' →0

- Position 2: 'o' →0

- Position 3: 'd' →0

- Position 4: 'e' →0

- Position 5: 'f' →0

- Position 6: 'o' →1

- Position 7: 'r' →0

- Position 8: 'c' →1

- Position 9: 'e' →1

- Position 10: 's' →0

Trace:

- 'c': positions 1,8 → counts 0,1

- 'o': positions 2,6 → counts 0,1

- 'd': position 3 →0

- 'e': positions 4,9 →0,1

- 'f': position 5 →0

- 'r': position 7 →0

- 's': position 10 →0

Which matches a=[0,0,0,0,0,1,0,1,1,0]

So, the code should produce some string, not necessarily "codeforces", but any string that matches the trace.

Using the code:

- ai=0: j=0, 'a', s='a', char_count[0]=1

- ai=0: j=1, 'b', s='ab', char_count[1]=1

- ai=0: j=2, 'c', s='abc', char_count[2]=1

- ai=0: j=3, 'd', s='abcd', char_count[3]=1

- ai=0: j=4, 'e', s='abcde', char_count[4]=1

- ai=1: j=0, 'a', s='abcdea', char_count[0]=2

- ai=0: j=5, 'f', s='abcdeaf', char_count[5]=1

- ai=1: j=1, 'b', s='abcdeafb', char_count[1]=2

- ai=1: j=3, 'd', s='abcdeafbd', char_count[3]=2

- ai=0: j=6, 'g', s='abcdeafbdg', char_count[6]=1

So, s='abcdeafbdg', which also corresponds to a=[0,0,0,0,0,1,0,1,1,0]

Hence, it's a valid string, though different from "codeforces".

Therefore, the code is correct.

Edge cases to consider:

- n=1, a=[0] → any single character, say 'a'

- n=2, a=[0,0] → two different characters, e.g., 'ab'

- n=2, a=[0,1] → same character repeated, 'aa'

- All a_i=0 → all characters are distinct, e.g., 'abcde...'

- All a_i=i-1 → all characters are the same, e.g., 'aaaa...'

- a_i values are in increasing order

- a_i values are in decreasing order (not possible, since a_i can't be greater than the number of previous occurrences)

- a_i values are random but consistent with some string

Given that the problem guarantees a valid string exists, I don't need to handle invalid cases.

Performance considerations:

- n can be up to 2e5, and t up to 1e4, but sum of n over all test cases is up to 2e5, so it's acceptable.

- For each position i, I iterate through 26 characters to find one with char_count[j]==a_i.

- In the worst case, for each position, I might iterate through all 26 characters.

- So, total time per test case is O(26*n) = O(n), which is acceptable for n up to 2e5.

Possible optimizations:

- Instead of iterating through all 26 characters each time, I can maintain a list of available characters for each frequency.

- That is, have a list for frequency 0, frequency 1, etc.

- But since a_i can be up to n-1, and n can be up to 2e5, maintaining a list for each frequency up to n-1 is not practical due to memory and time constraints.

- Hence, the current approach is acceptable.

Hence, the given program is correct.

**Final Solution**

To solve this problem, we need to reconstruct the original string from its trace. The trace is an array where each element represents the count of previous occurrences of the corresponding character in the string.

### Approach

1. **Understanding the Trace:**
   - The