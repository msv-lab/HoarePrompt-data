Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly equal to a given number X. X can be as large as 10^18, which is a really big number, so I need to think carefully about how to approach this.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence where elements are strictly increasing, and they maintain their relative order in the original array. Also, even empty subsequences are considered increasing. That's important to note.

So, for a given array, how do I calculate the number of increasing subsequences? Well, for each possible subsequence, I need to check if it's strictly increasing. But that sounds computationally expensive, especially since X can be up to 10^18. I need a smarter way to approach this.

Maybe I can think about the properties of the array that would lead to exactly X increasing subsequences. Perhaps there's a pattern or a formula that relates the structure of the array to the number of increasing subsequences.

I recall that for any array, the number of increasing subsequences can be calculated using dynamic programming. Specifically, for each position in the array, I can keep track of the number of increasing subsequences ending at that position. Then, the total number would be the sum of all these plus one for the empty subsequence.

But again, implementing that directly isn't feasible for large X. I need to find a way to construct an array that achieves exactly X increasing subsequences, and do it efficiently, since T can be up to 1000, meaning I have to handle up to 1000 test cases.

Let me think about smaller cases first. For example, if X=2, what would the array look like? Well, an array with a single element has two increasing subsequences: the empty one and the one containing that element. So, for X=2, an array with one element is sufficient.

Similarly, for X=3, I might need an array with two elements, where the second element is greater than the first, so that there are three increasing subsequences: empty, first element, and both elements.

Wait, but if the second element is smaller than the first, then the increasing subsequences would only be the empty one and each individual element, totaling two, which is less than X=3. So, to maximize the number of increasing subsequences, I need the array to be strictly increasing.

Wait a minute, if the array is strictly increasing, then every subset of it is an increasing subsequence. So, the total number of increasing subsequences would be 2^N - 1, where N is the length of the array, minus the empty one, but according to the problem, the empty subsequence is also considered, so total would be 2^N.

But hold on, the problem says that the empty subsequence is also increasing, so for a array of size N, the number of increasing subsequences would be 2^N.

Wait, but that can't be right because in the example, for X=5, the output is an array of length 3, which would have 2^3 = 8 increasing subsequences, but X=5 is not equal to 8. So, maybe my assumption is incorrect.

Let me check the example provided:

Input:

4

2

5

13

37

Output:

1

0

3

0 1 0

5

2 2 3 4 2

7

-1 -1 0 0 2 3 -1

So, for X=2, array of length 1: [0], which has 2 increasing subsequences: empty and [0].

For X=5, array of length 3: [0,1,0], which has increasing subsequences:

- empty

- [0] (first element)

- [1]

- [0] (second element)

- [0,1] (first and second elements)

That's 5 increasing subsequences. Wait, but according to my earlier thought, a strictly increasing array of length 3 should have 2^3=8 increasing subsequences, but in this case, it's not strictly increasing, so some subsequences are not increasing.

So, the number of increasing subsequences is less than 2^N for non-strictly increasing arrays.

Therefore, to maximize the number of increasing subsequences, I should aim for a strictly increasing array, which gives me 2^N increasing subsequences.

But in the example, for X=5, they have used a non-strictly increasing array to achieve exactly 5 increasing subsequences.

So, my initial approach of using a strictly increasing array might not be flexible enough to achieve any X. I need a way to adjust the number of increasing subsequences to match exactly X.

Let me think differently. Maybe I can construct the array in such a way that the number of increasing subsequences is a sum of powers of 2 or something similar.

Wait, another idea: binary representation. Since X can be up to 10^18, which is within 60 bits, maybe I can represent X in binary and construct the array based on the binary digits.

Let me consider that. If I can represent X as a sum of distinct powers of 2, then maybe I can construct corresponding segments of the array that contribute those powers of 2 to the total count of increasing subsequences.

But I need to ensure that these contributions are additive, meaning that the total number of increasing subsequences is the sum of the increasing subsequences from each segment.

Is that possible? Let's see.

Suppose I divide the array into disjoint segments, and each segment contributes a certain number of increasing subsequences. If the segments are arranged in such a way that no subsequence can span across multiple segments, then the total number of increasing subsequences would be the product of the number of increasing subsequences in each segment, not the sum.

Wait, that's not correct. If segments are disjoint and no subsequence can span across them, then the total number of increasing subsequences would be the product of the number of increasing subsequences in each segment, because for each subsequence in one segment, I can choose to include or not include subsequences from other segments.

But I need the sum to be X, not the product.

Hmm, maybe I need to think differently.

Let me consider that the empty subsequence is always present, and it's counted once. Then, the total number of non-empty increasing subsequences is X - 1.

So, perhaps I can think in terms of building up the array to have exactly X - 1 non-empty increasing subsequences.

But I'm not sure if that helps directly.

Let me try to find a recursive structure or a way to build the array incrementally, adding elements in a way that controls the number of increasing subsequences.

I recall that in dynamic programming for counting increasing subsequences, we can keep track of the number of increasing subsequences ending at each position.

Maybe I can try to construct the array such that the contributions add up to X.

But this seems too vague.

Let me look back at the example for X=5.

Array: [0,1,0]

Increasing subsequences:

- empty

- [0] (first element)

- [1]

- [0] (second element)

- [0,1] (first and second elements)

Total: 5.

So, in this case, the subsequence [0,0] is not increasing because it's not strictly increasing. So, only certain subsequences are counted.

Another example: X=13, array: [2,2,3,4,2]

I need to list out all the increasing subsequences to see how it sums up to 13.

Possible increasing subsequences:

- empty

- [2] (first)

- [2] (second)

- [3]

- [4]

- [2,3]

- [2,4] (first 2 and 4)

- [3,4]

- [2,3,4] (first 2, 3, 4)

- [2,4] (second 2 and 4)

- [2,3] (second 2, 3)

Wait, but [2,3] involving the second 2 and 3 is not strictly increasing because 2 is equal to 2. So, only the ones involving the first 2 and 3, and 4 are valid.

So, total increasing subsequences:

- empty: 1

- single elements: 2 (first 2), 2 (second 2), 3, 4: total 4

- pairs: [2,3], [2,4] (first 2 and 4), [3,4]: 3

- triplets: [2,3,4] (first 2, 3, 4): 1

Total: 1 + 4 + 3 + 1 = 9, but the problem says X=13. Maybe I'm missing some.

Wait, perhaps I'm misunderstanding the problem.

Wait, the problem says that if two subsequences consist of the same elements but correspond to different positions, they are considered different.

So, [2,3] using the first 2 and 3 is different from [2,3] using the second 2 and 3, but in this case, the second 2 and 3 do not form a strictly increasing subsequence because 2 <= 3, which is allowed, but in the problem, it's strictly increasing, so maybe not.

Wait, the problem says strictly increasing, so [2,3] is allowed only if the 2 is strictly less than 3, which it is, but in the array [2,2,3,4,2], the second 2 and 3 would also form a strictly increasing subsequence because 2 < 3.

So, in that case, [2,3] can be formed in two ways: using the first 2 and 3, and using the second 2 and 3.

Similarly, [2,4] can be formed using the first 2 and 4, and using the second 2 and 4.

So, total increasing subsequences:

- empty: 1

- single elements: 2 (first 2), 2 (second 2), 3, 4: total 4

- pairs: [2,3] (two ways), [2,4] (two ways), [3,4]: total 5

- triplets: [2,3,4] (two ways, depending on which 2 is chosen): 2

Total: 1 + 4 + 5 + 2 = 12.

But the problem says X=13, so maybe I'm missing one.

Perhaps the empty subsequence is not being counted, but the problem says it is included.

Wait, maybe I miscounted.

Let me list all possible increasing subsequences:

- empty

- [2] (first)

- [2] (second)

- [3]

- [4]

- [2,3] (first 2 and 3)

- [2,3] (second 2 and 3)

- [2,4] (first 2 and 4)

- [2,4] (second 2 and 4)

- [3,4]

- [2,3,4] (first 2, 3, 4)

- [2,3,4] (second 2, 3, 4)

Total: 12, but the problem says 13. Maybe there's a mistake in the problem's example or in my counting.

Wait, perhaps [2] (first and second are considered different), and [3], [4], and the multi-element subsequences as above.

Alternatively, maybe the problem counts unique subsequences, but no, it says that even if they consist of the same elements but different positions, they are considered different.

Wait, perhaps there's a typo in the problem's example output.

But for now, I'll proceed with the understanding that for X=13, the array provided might have 13 increasing subsequences, and I might have miscounted.

Given that, I need a way to construct an array where the number of increasing subsequences is exactly X.

I need to find a way to represent X as a sum of certain values that correspond to the contributions of different parts of the array.

Let me consider building the array in segments where each segment contributes a certain number of increasing subsequences, and the total is X.

I need to find a way to decompose X into such segments.

Looking back at the function provided in the code, it seems to be trying to build such a sequence recursively.

Let's look at the function func_1, which takes number and sequence as arguments.

It seems to be building the sequence based on the binary representation of number.

Wait, it's using bit shifts, which suggests a binary approach.

Let me try to understand what func_1 is doing.

It starts with size = 1, and increases size until (1 << (size + 1)) - 1 > number.

Wait, (1 << k) is 2^k, so (1 << (size + 1)) - 1 is 2^(size + 1) - 1.

So, it's finding the largest size such that 2^(size + 1) - 1 <= number.

Then, it appends size elements to the sequence: 0, 1, ..., size-1.

Then, it calls func_1 recursively with number - (1 << size) + 1, and appends the result to the sequence.

Finally, it adjusts some elements in the sequence based on the recursive result.

This seems like it's trying to represent number in terms of sums involving powers of 2, but adjusted in some way.

I need to understand how this relates to the number of increasing subsequences.

Perhaps each segment of the sequence corresponds to a group of elements that contribute a certain number of increasing subsequences based on their values and ordering.

Given that the function builds the sequence by appending increasing integers and then adjusting them based on recursive calls, it might be constructing a sequence where groups of elements contribute specific amounts to the total count of increasing subsequences.

But I'm not entirely sure. Maybe I need to think about the number of increasing subsequences in terms of binary decisions for each element.

Wait, in a strictly increasing sequence, each element can either be included or not, leading to 2^N total subsequences, including the empty one.

But in sequences with equal elements, the number of increasing subsequences is less than 2^N.

In the example with X=5 and array [0,1,0], the number of increasing subsequences is 5, which is less than 2^3=8.

So, perhaps by introducing equal elements, I can control the number of increasing subsequences to be any value between 1 and 2^N.

Wait, but in the array [0,1,0], the number is 5, which is 2^2 + 1, but I'm not sure if that helps.

Alternatively, maybe I can think of the array as consisting of groups of equal elements, and calculate the number of increasing subsequences based on choosing elements from these groups.

For example, if I have K copies of a certain value, and then a higher value, the ways to choose increasing subsequences would depend on how many times I choose the lower value before moving to the higher one.

This seems complicated.

Let me look for a different approach.

I recall that the number of increasing subsequences in an array can be calculated using inclusion-exclusion or some combinatorial methods based on the structure of the array.

But again, that doesn't directly help me in constructing an array for a given X.

Maybe I should consider the minimal and maximal lengths of the array needed to achieve X.

Given that N is at most 200, and X can be up to 10^18, which is way larger than 2^200, but wait, 2^60 is already over 10^17, so 2^200 is way beyond 10^18.

Wait, but actually, 2^60 is approximately 1.1529215e+18, which is larger than 10^18, so for N=60, 2^60 is already over 10^18.

But the problem allows N up to 200, but X is up to 10^18, so I need N at most around 60 to reach 10^18 with a strictly increasing sequence.

But the problem allows up to 200 elements, but for larger X, I might not need that many.

Wait, but in the example for X=13, they use N=5, which is sufficient.

So, perhaps with N=60, I can reach up to X=2^60, which is over 10^18, which covers the required range.

But again, I need a way to construct the array for any given X in that range.

Let me consider representing X in binary.

Suppose X is represented as the sum of distinct powers of 2.

For example, X=13 is 1101 in binary, which is 8 + 4 + 1.

Similarly, X=5 is 101 in binary, which is 4 + 1.

If I can construct segments of the array that contribute 1, 2, 4, 8, etc., increasing subsequences, then by choosing which segments to include, I can sum up to X.

But I need to ensure that these segments are independent, meaning that their contributions multiply, but earlier I thought that might not be directly applicable.

Wait, perhaps I can arrange the array in such a way that each segment contributes a certain number of increasing subsequences, and the total is the product of these contributions.

But then, to get a product equal to X, I'd need to factorize X, which is complicated, especially for large X.

That doesn't seem promising.

Alternatively, maybe I can arrange the array so that the number of increasing subsequences is a sum of contributions from different parts.

But how?

Let me consider that each element in the array can either be included in an increasing subsequence or not, but with constraints based on previous elements.

This seems too vague.

Let me look back at the function provided.

It seems to be building the sequence recursively, appending elements in a specific pattern based on the binary representation of X-1.

Wait, in the function, it's calling func_1(number - (1 << size) + 1, sequence).

So, it's subtracting 2^size - 1 from number.

Wait, 1 << size is 2^size, so (1 << size) -1 is 2^size -1.

So, it's subtracting 2^size -1 from number in each recursive step.

This suggests that it's representing number as a sum of (2^k -1) for various k.

But I thought representing X as a sum of powers of 2, but here it's using 2^k -1.

Wait, maybe it's related to the number of increasing subsequences in a strictly increasing sequence.

For a strictly increasing sequence of length K, the number of increasing subsequences is 2^K -1 (excluding the empty one), but the problem includes the empty subsequence, so it would be 2^K.

Wait, no, the problem includes the empty subsequence as increasing, so for a strictly increasing sequence of length K, there are 2^K increasing subsequences, including the empty one.

But in the code, it's subtracting 2^size -1, which is 2^size -1.

Wait, maybe the author is considering something different.

Let me try to see with an example.

Take X=5.

5 -1 =4.

Find size such that 2^(size+1)-1 <=4.

2^(size+1)-1 for size=1: 3 <=4, okay.

For size=2: 2^(3)-1=7 >4, so size=1.

Then, append [0] to sequence.

Then, recursive call with number - (2^size -1) =4-3=1.

So, recursive call with number=1.

In the recursive call, for number=1, which is 2^1 -1=1, so size=1, append [0], then recursive call with 1-3= -2, which is invalid, but perhaps there's a base case for number=0.

Wait, the function has a base case for number=0, returning 0.

So, in this case, it would append [0], then in the recursive call with number=1-3= -2, which should trigger the base case, but number is negative.

Wait, perhaps there's an error in this approach.

Alternatively, maybe the function is intended to build the sequence such that the number of increasing subsequences is number +1, since it's calling with number-1.

Wait, in the main code, it's calling func_1(n-1, result), where n is X.

So, it's building a sequence where the number of increasing subsequences is n, since func_1 is building for n-1.

Wait, no, it's calling func_1(n-1, result), and func_1 seems to be building a sequence for number +1, since it appends elements and adjusts based on the recursive call.

This is getting confusing.

Let me try to see with X=2.

X=2, so number=1.

func_1(1, result):

size=1 (since 2^(1+1)-1=3 >1, so size=1)

append [0]

recursive call with 1 - (2^1 -1)=1-1=0, which returns 0.

Then, adjust sequence[-result -i -1] +=result, but result=0, so no adjustment.

So, sequence is [0], which matches the first example.

For X=5, number=4.

func_1(4, result):

Find size where 2^(size+1)-1 <=4.

size=1: 3<=4, okay.

size=2: 7>4, so size=1.

Append [0]

Recursive call with 4 - (2^1 -1)=4-1=3.

Now, func_1(3, sequence):

Find size where 2^(size+1)-1 <=3.

size=1: 3<=3

Append [0]

Recursive call with 3 -1=2.

func_1(2, sequence):

Find size where 2^(size+1)-1 <=2.

size=1: 3>2, so size=0? Wait, size starts at 1, but 2^(1+1)-1=3>2, so size=0 is not allowed.

Wait, the while loop condition is while (1 << size +1)-1 <=number, so initially size=1, 3>2, so don't increment size.

So, size=1.

Append [0]

Recursive call with 2 -1=1.

func_1(1, sequence):

size=1

Append [0]

Recursive call with 1-1=0, which returns 0.

So, sequence is [0,0,0]

Then, adjustments:

for i in range(size):

sequence[-result -i -1] +=result

But result from recursive call is 0.

So, sequence remains [0,0,0]

But in the example for X=5, the output is [0,1,0]

So, perhaps there's a mistake in my understanding.

Wait, perhaps I misread the code.

Looking back at the code:

def func_1(number: int, sequence: List[int]) -> int:

...

size = 1

while (1 << size +1) -1 <= number:

size +=1

Then, append i for i in range(size)

Then, result = func_1(number - (1 << size) +1, sequence)

Then, for i in range(size):

sequence[-result -i -1] += result

return size + result

Wait, (1 << size +1) is 2^(size +1), not 2^(size+1) -1.

Wait, no, it's (1 << size +1) -1, because it's written as (1 << size +1) -1.

But in Python, bitshift has higher precedence than addition, so it's (1 << size) +1 -1, which is (1 << size).

Wait, no, actually, it's (1 << (size +1)) -1.

Because in Python, << has higher precedence than + or -.

So, (1 << size +1) -1 is (1 << (size +1)) -1.

Which is 2^(size +1) -1.

So, the while loop is increasing size until 2^(size +1) -1 > number.

Then, it appends range(size) to sequence.

Then, calls result = func_1(number - (1 << size) +1, sequence)

Wait, 1 << size is 2^size.

So, it's subtracting 2^size -1 from number.

Wait, no, it's subtracting (1 << size) -1, which is 2^size -1.

Wait, but in the code, it's number - (1 << size) +1, which is number - (2^size -1) = number - 2^size +1.

Wait, that seems off.

Wait, perhaps it's a typo in my earlier understanding.

Looking back at the code:

number - (1 << size) +1

Which is number - (2^size) +1.

But earlier, in the while loop, it's increasing size until 2^(size +1) -1 > number.

So, it's finding the largest size where 2^(size +1) -1 <= number