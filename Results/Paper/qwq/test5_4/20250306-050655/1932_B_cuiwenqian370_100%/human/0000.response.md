Alright, I have this problem to solve. Let's understand what's being asked here. There are n signs of the apocalypse, each occurring every a_i years. The signs must occur sequentially, meaning each sign must happen strictly after the previous one. I need to find out in which year the nth sign will occur, which will mark the apocalypse.

First, I need to parse the input. The input consists of multiple test cases. The first line is t, the number of test cases. For each test case, there's an integer n, the number of signs, followed by n integers representing the periodicity of each sign.

My goal is to, for each test case, determine the year in which the nth sign occurs, given that each sign must occur strictly after the previous one.

Let me try to understand this with the first example provided:

Input:

4

6

3 2 4 5 9 18

...

Output:

36

So, for n=6 and a=[3,2,4,5,9,18], the answer is 36.

Let's see why.

- The first sign occurs every 3 years: 3,6,9,12,...

- The second sign occurs every 2 years: 2,4,6,8,10,...

- The third sign occurs every 4 years: 4,8,12,16,...

- Fourth: every 5 years: 5,10,15,20,...

- Fifth: every 9 years: 9,18,27,...

- Sixth: every 18 years: 18,36,54,...

Now, the tribe waits for the first sign to occur, which is in year 3.

Then, they start waiting for the second sign starting from year 4.

The second sign occurs in year 4 (since 4 is a multiple of 2), so they wait for the third sign starting from year 5.

The third sign occurs in year 8 (since 8 is a multiple of 4), so they wait for the fourth sign starting from year 9.

The fourth sign occurs in year 10 (multiple of 5), so they wait for the fifth sign starting from year 11.

The fifth sign occurs in year 18 (multiple of 9), so they wait for the sixth sign starting from year 19.

The sixth sign occurs in year 36 (multiple of 18).

Hence, the apocalypse happens in year 36.

Okay, that makes sense.

Now, generalizing this:

- Start with the first sign: find the smallest year that is a multiple of a[0].

- For each subsequent sign, find the smallest year that is a multiple of a[i] and greater than the year of the previous sign.

- Continue this process until the nth sign.

So, in code, I need to:

- Read t, the number of test cases.

- For each test case:

- Read n.

- Read the array a of n integers.

- Initialize the year of the first sign as a[0].

- For each subsequent sign from 1 to n-1:

- Find the smallest year that is a multiple of a[i] and greater than the previous year.

- Update the year to this value.

- Output the year for the nth sign for each test case.

Looking at the code provided:

if __name__ == '__main__':

func_1()

def func_1():

import sys

input = sys.stdin.read

data = input().split()

index = 0

T = int(data[index])

index += 1

results = []

for _ in range(T):

n = int(data[index])

index += 1

a = list(map(int, data[index:index + n]))

index += n

last_year = a[0]

for i in range(1, n):

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

last_year = next_year

results.append(str(last_year))

sys.stdout.write('\n'.join(results) + '\n')

Let's see what this code is doing.

- It reads all input at once using sys.stdin.read.

- Splits the input into tokens.

- Reads t, the number of test cases.

- For each test case:

- Reads n.

- Reads the array a of n integers.

- Initializes last_year to a[0].

- For each sign from the second to the nth:

- Computes the next_year as ceil((last_year + 1) / a[i]) * a[i]

- Updates last_year to next_year.

- Collects the results and prints them all at once.

This seems correct.

Let's verify with the first example:

a = [3,2,4,5,9,18]

last_year = 3

For i=1:

next_year = ceil((3+1)/2)*2 = ceil(4/2)*2 = 2*2=4

last_year =4

For i=2:

next_year = ceil((4+1)/4)*4 = ceil(5/4)*4 = 2*4=8

last_year=8

For i=3:

next_year = ceil((8+1)/5)*5 = ceil(9/5)*5 = 2*5=10

last_year=10

For i=4:

next_year = ceil((10+1)/9)*9 = ceil(11/9)*9 = 2*9=18

last_year=18

For i=5:

next_year = ceil((18+1)/18)*18 = ceil(19/18)*18 = 2*18=36

last_year=36

Which matches the example.

Let's check another example:

Input:

5

1 2 3 4 5

Output:

5

Let's see:

a=[1,2,3,4,5]

last_year=1

i=1:

next_year=ceil((1+1)/2)*2=ceil(2/2)*2=1*2=2

last_year=2

i=2:

next_year=ceil((2+1)/3)*3=ceil(3/3)*3=1*3=3

last_year=3

i=3:

next_year=ceil((3+1)/4)*4=ceil(4/4)*4=1*4=4

last_year=4

i=4:

next_year=ceil((4+1)/5)*5=ceil(5/5)*5=1*5=5

last_year=5

Which matches the output.

Another example:

a=[1,1,1,1,1]

last_year=1

For each i from 1 to 4:

next_year=ceil((1+1)/1)*1=ceil(2)*1=2*1=2

last_year=2

So, final year is 2, but the output is 5.

Wait, that doesn't match. According to the code, it should be 2, but the output is 5.

Wait, maybe I'm misunderstanding.

Wait, no. Let's recast.

a=[1,1,1,1,1]

last_year=1

i=1:

next_year=ceil((1+1)/1)*1=ceil(2)*1=2*1=2

last_year=2

i=2:

next_year=ceil((2+1)/1)*1=ceil(3)*1=3*1=3

last_year=3

i=3:

next_year=ceil((3+1)/1)*1=ceil(4)*1=4*1=4

last_year=4

i=4:

next_year=ceil((4+1)/1)*1=ceil(5)*1=5*1=5

last_year=5

Okay, so it does output 5, which matches the sample output.

Good.

Another test case:

a=[50,30,711,200,503,1006]

last_year=50

i=1:

next_year=ceil((50+1)/30)*30=ceil(51/30)*30=2*30=60

last_year=60

i=2:

next_year=ceil((60+1)/711)*711=ceil(61/711)*711=1*711=711

last_year=711

i=3:

next_year=ceil((711+1)/200)*200=ceil(712/200)*200=4*200=800

last_year=800

i=4:

next_year=ceil((800+1)/503)*503=ceil(801/503)*503=2*503=1006

last_year=1006

i=5:

next_year=ceil((1006+1)/1006)*1006=ceil(1007/1006)*1006=2*1006=2012

last_year=2012

Which matches the sample output.

Seems correct.

Now, let's think about edge cases.

Edge Case 1: n=1, a=[1]

last_year=1

Output:1

Edge Case 2: n=2, a=[2,3]

last_year=2

next_year=ceil((2+1)/3)*3=ceil(3/3)*3=1*3=3

Output:3

Edge Case 3: n=3, a=[7,1,5]

last_year=7

i=1:

next_year=ceil((7+1)/1)*1=ceil(8)*1=8*1=8

last_year=8

i=2:

next_year=ceil((8+1)/5)*5=ceil(9/5)*5=2*5=10

last_year=10

Output:10

Seems correct.

Another edge case: All a_i=1

a=[1,1,1,1,1]

As above, output is 5.

Another edge case: a_i=1 and n=1

Output:1

Seems consistent.

Now, thinking about implementation.

The code reads all input at once, which is efficient for competitive programming.

It processes each test case one by one.

For each test case, it reads n and then the array a.

It initializes last_year to a[0].

Then, for each sign from the second to the nth, it calculates the next_year as ceil((last_year +1)/a[i])*a[i]

This is equivalent to finding the smallest multiple of a[i] that is greater than last_year.

Which is correct, as per the problem statement.

Using ceil function to find the next multiple is a good approach.

In code, it's implemented as:

next_year = (last_year + 1 + a[i] -1) // a[i] * a[i]

Which is equivalent to ceil((last_year +1)/a[i])*a[i], since (last_year +1 + a[i]-1) // a[i] is equivalent to ceil((last_year +1)/a[i])

This is a correct implementation.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{36} \]