Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and I can perform a specific operation on any element that is at least 10. The operation is to delete that element and insert its digits in the same position, maintaining their order. For example, if I have [12, 3, 45, 67] and I apply the operation to the third element (45), it becomes [12, 3, 4, 5, 67]. Another example is [2, 10], and applying the operation to the second element makes it [2, 1, 0].

My task is to determine whether, after performing this operation any number of times (possibly zero), the array can be sorted in non-decreasing order. So, I need to check if there's a sequence of operations that leads to a sorted array.

First, I need to understand the operation clearly. When I choose an element that is at least 10, I remove it and insert its digits in the same position, keeping the order. So, for a number like 10, it becomes 1 and 0; for 12, it's 1 and 2; for 45, it's 4 and 5, and so on.

I need to think about how this operation affects the array. Essentially, it allows me to split numbers greater than or equal to 10 into their individual digits. Numbers less than 10 remain as they are unless they are part of a number that was split before them.

I should consider that this operation can be applied multiple times, but I need to find out if, after some sequence of splits, the array becomes sorted in non-decreasing order.

Let me look at the examples provided:

1. Input: [12, 3, 45, 67]

   - If I split 12: [1, 2, 3, 45, 67]

   - Then, if I split 45: [1, 2, 3, 4, 5, 67]

   - Finally, if I split 67: [1, 2, 3, 4, 5, 6, 7]

   - This is sorted in non-decreasing order.

   - So, the answer is YES.

2. Input: [12, 28, 5]

   - If I split 12: [1, 2, 28, 5]

   - Then, if I split 28: [1, 2, 2, 8, 5]

   - Now, the array is [1, 2, 2, 8, 5], which is not sorted.

   - If I split 8: it's less than 10, so can't split.

   - If I split 5: it's less than 10, so can't split.

   - So, no further operations can make it sorted.

   - Therefore, the answer is NO.

3. Input: [0, 0]

   - Already sorted.

   - So, the answer is YES.

From these examples, it seems that splitting numbers can help in sorting the array, but not always.

Now, I need to think about a general approach to solve this problem.

First, I need to consider all possible sequences of operations, but that could be exponential in the number of elements greater than or equal to 10. Since n can be up to 50, this might not be efficient.

Is there a smarter way to approach this?

Let me think differently. Instead of thinking about operations, maybe I can think about the possible final arrays that can be obtained after any number of operations.

When I split a number, I replace it with its digits. So, for example, 12 becomes 1 and 2, 45 becomes 4 and 5, and so on.

I need to consider that splitting a number affects the positions of the elements that come after it.

Wait, perhaps I can model this problem as trying to build a sorted array by choosing, for each element, whether to split it or keep it as is, and see if there's a combination that results in a sorted array.

But how do I handle the positions correctly when splitting a number inserts multiple digits in place of that number?

This seems a bit tricky.

Let me consider that each number can either be kept as is (if it's less than 10) or split into its digits (if it's 10 or greater). I need to interleave these choices in such a way that the resulting array is sorted.

But checking all possible combinations is not feasible because n can be up to 50, and for each element that is >=10, I have at least two choices: keep it or split it.

Wait, but splitting a number that is >=10 doesn't just give me one alternative; it gives me the digits to be inserted in place of the number.

So, perhaps I can think of it as building a sequence where for each element, if it's >=10, I can choose to include it as is or include its digits in order.

Then, I need to check if there's a way to choose for each element its representation (original number or its digits) such that the resulting sequence is sorted.

This sounds similar to constructing a path where at each step, I have choices, and I need to see if any of those paths lead to a sorted sequence.

But again, with n up to 50, and each element possibly having multiple choices, this could be computationally expensive.

Is there a better way?

Let me consider the constraints:

- n is between 2 and 50.

- Each a_i is between 0 and 99.

- I can only split numbers that are >=10.

- I can perform the operation any number of times, including zero.

- I need to check if it's possible to make the array sorted in non-decreasing order.

I need an efficient way to determine if there's a sequence of splits that leads to a sorted array.

Maybe I can think of the array as a sequence of digits, where some digits are grouped together as numbers >=10.

For example, [12, 3, 45, 67] can be thought of as [1,2,3,4,5,6,7], which is sorted.

But in [12, 28, 5], it would be [1,2,2,8,5], which is not sorted.

Wait, perhaps I can flatten the array by splitting all numbers >=10 into their digits and then check if the resulting array is sorted.

But in the first example, [12, 3, 45, 67] -> [1,2,3,4,5,6,7], which is sorted.

In the second example, [12, 28, 5] -> [1,2,2,8,5], which is not sorted.

In the third example, [0,0] is already sorted.

So, it seems that if I fully split all possible numbers, I can check if the resulting array is sorted.

But is this always the case?

Wait, in the first example, splitting all numbers leads to a sorted array.

But in the second example, splitting all numbers does not lead to a sorted array.

Is there a way in the second example to choose not to split some numbers to get a sorted array?

Let's see: [12, 28, 5]

- If I don't split 12 and 28, it's [12,28,5], which is not sorted.

- If I split 12 and not 28: [1,2,28,5], which is not sorted.

- If I split 28 and not 12: [12,2,8,5], which is not sorted.

- If I split both: [1,2,2,8,5], which is not sorted.

- So, no matter what, I can't get a sorted array for this case.

So, in this case, splitting all numbers is the worst case, but it's still not sorted.

In the first example, splitting all numbers leads to a sorted array.

So, perhaps the approach is to fully split all possible numbers and see if the resulting array is sorted.

But wait, is this always correct?

Let me think of another example.

Suppose the array is [15, 2, 3].

- If I split 15: [1,5,2,3], which is not sorted.

- If I don't split 15: [15,2,3], which is not sorted.

- So, in this case, splitting leads to [1,5,2,3], which is not sorted.

- But maybe there's a way to split only part of the numbers.

- But in this case, no matter what, it's not sorted.

So, in this case, the answer should be NO.

Another example: [10, 1, 2]

- If I split 10: [1,0,1,2], which is [1,0,1,2], not sorted.

- If I don't split 10: [10,1,2], not sorted.

- So, again, NO.

Another example: [11,11,11]

- If I split all: [1,1,1,1,1,1], which is sorted.

- So, YES.

Another example: [13,4,5]

- Split 13: [1,3,4,5], which is sorted.

- So, YES.

- Alternatively, without splitting, [13,4,5], not sorted.

- So, splitting helps.

So, it seems that splitting all possible numbers and checking if the resulting array is sorted is a viable approach.

But in the second example, splitting all numbers doesn't lead to a sorted array, and neither does any other combination.

So, perhaps this is a correct approach.

But is there a case where splitting all numbers doesn't lead to a sorted array, but splitting some of them does?

Let me think about [25, 3, 4].

- Split 25: [2,5,3,4], which is not sorted.

- Split 25 and don't split others: [2,5,3,4], not sorted.

- Don't split 25: [25,3,4], not sorted.

- So, in this case, no matter what, it's not sorted.

Another example: [21,1,11]

- Split all: [2,1,1,1,1,1], which is sorted.

- So, YES.

Wait, but 21 splits into 2 and 1, then 11 splits into 1 and 1.

So, [2,1,1,1,1,1], which is not sorted in non-decreasing order? Wait, 2 then 1 is not non-decreasing.

Wait, that's not sorted.

Wait, 2 is greater than 1, so it's not non-decreasing.

So, in this case, splitting all leads to [2,1,1,1,1,1], which is not sorted.

Is there another way?

- Split only 21: [2,1,1,11]

- Is [2,1,1,11] sorted? 1 comes after 2, which is not >=2, so no.

- Split only 11: [21,1,1,1]

- Is [21,1,1,1] sorted? 1 comes after 21, which is not >=21, so no.

- Split 21 and 11: [2,1,1,1,1]

- Is [2,1,1,1,1] sorted? No, because 1 comes after 2.

- Don't split any: [21,1,11], not sorted.

So, in this case, no matter what, it's not possible to get a sorted array.

So, my approach of splitting all possible numbers and checking if the resulting array is sorted seems correct.

Because if splitting all numbers doesn't lead to a sorted array, then there's no way to get a sorted array by splitting some of them, since splitting more can only make it worse in terms of sorting.

Wait, but in the previous case, splitting all leads to [2,1,1,1,1], which is not sorted, and splitting fewer also doesn't lead to a sorted array.

So, in that case, it's consistent.

Another example: [19,2,2]

- Split 19: [1,9,2,2]

- Is [1,9,2,2] sorted? 1 <=9, but 9 >2, which is not <=9, so no.

- Don't split 19: [19,2,2], not sorted.

- So, NO.

Another example: [10,1,2]

- Split 10: [1,0,1,2]

- Is [1,0,1,2] sorted? 0 comes after 1, which is not >=1, so no.

- Don't split 10: [10,1,2], not sorted.

- So, NO.

Seems consistent.

Another example: [0,10]

- Split 10: [0,1,0]

- Is [0,1,0] sorted? 0 <=1, but 1 >0, which is not <=1, so no.

- Don't split 10: [0,10], which is sorted.

- Wait, 0 <=10, so it's sorted.

- So, YES.

Wait, in this case, not splitting leads to a sorted array, while splitting doesn't.

So, in this case, it's possible to have a sorted array without splitting.

So, my previous assumption that splitting all numbers and checking if the resulting array is sorted might not be entirely correct.

Because in this case, splitting all numbers doesn't lead to a sorted array, but not splitting some numbers does lead to a sorted array.

So, in this case, the answer should be YES, but according to my previous approach, it would be NO, which is incorrect.

So, my previous approach is flawed.

I need to think differently.

Perhaps I need to consider all possible combinations of splitting or not splitting for each number >=10 and check if any of those results in a sorted array.

But with n up to 50, and each such number providing at least two choices, this could be computationally infeasible.

Is there a smarter way to approach this?

Let me consider that splitting a number >=10 increases the length of the array, and the order of elements is preserved.

So, if I choose to split a number, I'm inserting its digits in place of the number, maintaining their order.

I need to ensure that after all such operations, the array is sorted in non-decreasing order.

Perhaps I can model this as a single sequence where for each number >=10, I have the option to either keep it as is or split it into digits, and then check if there's a way to choose for each such number its representation such that the entire sequence is sorted.

But how can I efficiently check this without enumerating all possibilities?

Maybe I can iterate through the array and keep track of the possible ranges for each position.

Wait, perhaps dynamic programming could be a solution here.

Let me think about a DP approach.

Define dp[i][j], where i is the current position in the original array, and j is the current state or value.

But I need to define the state more carefully.

Alternatively, perhaps I can keep track of the maximum value seen so far as I process the array, considering the choices for each element.

But this seems tricky.

Let me consider processing the array from left to right, and at each step, decide whether to split the current number or keep it, based on the maximum value so far.

Wait, but I need to consider that splitting a number can insert multiple digits, which may have different values.

This is getting complicated.

Is there another way to look at this problem?

Let me consider that splitting a number >=10 into its digits can only help in making the array sorted if the digits are smaller than or equal to the previous element or the next elements, depending on the position.

Wait, perhaps I can think in terms of the maximum possible value before and after splitting.

But I'm still stuck.

Let me look back at the problem description.

I need to determine if it's possible to make the array sorted in non-decreasing order by performing the operation any number of times.

The operation is to take any element that is >=10, delete it, and insert its digits in the same position, in order.

I need to find out if, after any sequence of such operations, the array can be sorted.

Wait, maybe I can consider the minimal possible representation of the array after performing all possible operations.

That is, splitting all possible numbers >=10 into their digits, and then checking if the resulting array is sorted.

In the earlier example where [10,1,2] becomes [1,0,1,2], which is not sorted, but not splitting 10 gives [10,1,2], which is sorted.

So, in this case, not splitting 10 leads to a sorted array, even though splitting it doesn't.

So, my previous approach of always splitting all possible numbers is not correct, because there are cases where not splitting some numbers leads to a sorted array, while splitting them does not.

So, what's the correct way to approach this?

I need to check if there exists a sequence of operations (choices of which numbers to split) that results in a sorted array.

This sounds like a decision problem, and it might be NP-complete, given the constraints, but with n up to 50, perhaps there's an efficient way to solve it.

Wait, maybe I can think of it as building a sequence where each position can be either the original number (if it's <10) or its digits (if it's >=10), and I need to choose which representation for each position such that the entire sequence is sorted.

In this case, for each position, if the number is <10, there's only one choice: keep it as is.

If the number is >=10, I have two choices: keep it as is or split it into its digits.

Then, I need to ensure that the sequence is sorted after making these choices.

This sounds like a tree where each node has choices, and I need to see if there's a path that leads to a sorted sequence.

But with n up to 50, this could be too slow.

Is there a way to optimize this?

Let me consider that splitting a number >=10 can only help in making the array sorted if the digits are smaller than or equal to the previous element.

Wait, perhaps I can iterate through the array and keep track of the maximum value seen so far.

At each position, if the element is >=10, I have to consider both options: keeping it as is or splitting it into digits.

Then, for each choice, I have to ensure that the current value is >= the previous value.

This seems like a recursive approach with memoization.

Define a function that takes the current position and the previous value, and tries both options for each number >=10.

But with n up to 50, and each position having up to two choices, the time complexity would be O(2^n), which is too slow for n=50.

So, I need a better approach.

Let me think differently.

Suppose I split all possible numbers into their digits.

Then, I have a sequence of digits.

If this sequence is sorted, then the answer is YES.

Otherwise, if it's not sorted, but there exists a way to not split some numbers to make it sorted, then it's YES; else, it's NO.

But checking all possible combinations is not feasible.

Is there a way to greedily decide whether to split a number or not?

Perhaps, but I'm not sure.

Let me consider that splitting a number can only help if its digits are smaller than or equal to the previous element.

Wait, in the example [10,1,2], splitting 10 gives [1,0,1,2].

Here, 0 <1, which breaks the sorting.

But without splitting, [10,1,2] is sorted because 10 <=1 <=2.

Wait, no, 10 <=1 is false, so it's not sorted.

Wait, 10 >=1, but for non-decreasing order, it should be 10 <=1, which is false.

Wait, no: non-decreasing order means each element is <= the next one.

So, in [10,1,2], 10 <=1 is false, so it's not sorted.

But in [10,1,2], if I don't split 10, it's not sorted.

If I split 10, I get [1,0,1,2].

Is [1,0,1,2] sorted?

1 <=0 is false, so it's not sorted.

So, in this case, the answer should be NO, but according to the previous incorrect approach, it would be YES, which is wrong.

Wait, no, in [10,1,2], not splitting leads to [10,1,2], which is not sorted.

Splitting leads to [1,0,1,2], which is not sorted.

So, in this case, the answer should be NO.

Wait, but earlier I thought not splitting could lead to a sorted array, but in this case, it doesn't.

Wait, perhaps I made a mistake.

Let me check [10,1,2]:

- Not splitting: [10,1,2]; is 10 <=1? No.

- Splitting 10: [1,0,1,2]; is 1 <=0? No.

- So, NO.

Another example: [0,10]

- Not splitting: [0,10]; is 0 <=10? Yes, it's sorted.

- So, YES.

Wait, but according to my earlier flawed approach, if I split all numbers, I get [0,1,0], which is not sorted, but not splitting leads to a sorted array.

So, in this case, the answer should be YES, because there exists a way (not splitting) to have a sorted array.

Therefore, my initial approach of always splitting all numbers is incorrect, because there are cases where not splitting some numbers leads to a sorted array, even if splitting all doesn't.

So, what's the correct way?

I need to find a way to decide for each number >=10 whether to split it or not, such that the resulting array is sorted.

This sounds like a graph where each node represents a position, and edges represent the choice of splitting or not splitting.

But I need a more efficient way.

Let me consider that for each number >=10, I have two choices: split or not split.

Then, I can model this as a decision tree, where each path represents a sequence of choices.

At each step, I choose whether to split the current number or not, and proceed to the next position, ensuring that the current choice doesn't violate the sorting order.

I can implement this recursively with memoization, keeping track of the previous value and the current position.

Given that n is up to 50, and each position has up to two choices, it might be feasible with memoization.

But I need to optimize it further.

Let me try to think of a greedy approach.

Start from the beginning of the array and decide for each element whether to split it or not, based on the previous element.

If the current element is <10, there's only one choice: keep it as is.

If it's >=10, I have to choose between keeping it as is or splitting it into digits.

I need to choose the option that allows the sequence to remain sorted.

Wait, perhaps I can iterate through the array and keep track of the maximum value so far.

At each position, if the element is <10, ensure that it's >= the previous value.

If the element is >=10, choose whether to keep it as is or split it into digits, and ensure that the chosen representation is >= the previous value.

This seems promising.

Let me try to formalize this.

Initialize previous = -1

Iterate through the array:

- If the current element is <10:

- If previous <= current element, set previous = current element

- Else, if the current element is >=10:

- Option 1: Keep it as is

- If previous <= current element, set previous = current element

- Option 2: Split it into digits

- For each digit, ensure that previous <= digit, and set previous = digit

- If either option leads to a valid sequence, proceed; else, it's NO.

Wait, but splitting can insert multiple digits, which may have different values.

This seems a bit messy.

Let me try to implement this idea step by step.

Initialize previous = -1

For each element in the array:

- If element <10:

- If previous <= element, set previous = element

- Else, return NO

- Else (element >=10):

- Option 1: Keep it as is

- If previous <= element, set previous = element

- Option 2: Split it into digits

- Get digits from left to right

- For each digit, ensure previous <= digit, and set previous = digit

- If either option leads to a valid sequence, proceed; else, return NO

Wait, but I need to choose one option that leads to a valid sequence.

This sounds like a recursive decision-making process.

I can implement this recursively with memoization, where the state is the current position and the previous value.

But with n up to 50, and previous value up to 99, it might be feasible.

Let me think about the implementation.

Define a recursive function that takes the current position and the previous value.

At each step, if the current position is beyond the array, check if the sequence is complete and sorted.

If the current element is <10:

- If previous <= current element, proceed to the next position with previous = current element

- Else, return False

If the current element is >=10:

-