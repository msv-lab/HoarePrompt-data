Alright, I've got this problem to solve. Let's see what it's asking for. So, Nikita has some cubes and he wants to build a tower using these cubes. He can either add one cube on top of the tower or remove one cube from the top in each move. The question is, after a certain number of moves, can he end up with exactly m cubes in the tower?

First, I need to understand the inputs and what they represent. The input consists of multiple test cases, and for each test case, there are two integers: n and m. Here, n is the number of moves Nikita makes, and m is the desired number of cubes in the tower at the end of these moves.

My task is to determine, for each test case, whether it's possible to have exactly m cubes in the tower after n moves.

Let me think about how the moves affect the tower.

Each move can be either:

1. Adding one cube to the top of the tower.

2. Removing one cube from the top of the tower.

Importantly, removing a cube can only be done if there is at least one cube in the tower. But since the problem assumes valid inputs, I don't need to worry about cases where he tries to remove a cube from an empty tower.

I need to find out if, after n such moves, the tower has exactly m cubes.

Let me consider some examples to get a better understanding.

Example 1:

n = 3, m = 3

Possible sequence of moves:

- Add a cube: tower has 1 cube.

- Add a cube: tower has 2 cubes.

- Add a cube: tower has 3 cubes.

So, yes, it's possible to have 3 cubes after 3 moves.

Example 2:

n = 2, m = 4

Possible sequences:

- Add a cube: 1

- Add a cube: 2

- But we only have 2 moves, so the tower has 2 cubes, not 4.

Another sequence:

- Add a cube: 1

- Remove a cube: 0

- Again, only 2 moves, ending with 0 cubes.

No sequence of 2 moves can result in 4 cubes. So, it's impossible.

Example 3:

n = 5, m = 3

Possible sequence:

- Add: 1

- Add: 2

- Add: 3

- Remove: 2

- Add: 3

So, after 5 moves, the tower has 3 cubes. Possible.

From these examples, I can see that the number of cubes in the tower after n moves depends on the net effect of adding and removing cubes.

Let me define:

- Let a be the number of add moves.

- Let r be the number of remove moves.

Then, n = a + r (total moves)

And the final number of cubes in the tower is:

m = a - r

Because each add increases the cube count by 1, and each remove decreases it by 1.

So, I have two equations:

1. a + r = n

2. a - r = m

I can solve these equations for a and r.

Adding both equations:

2a = n + m => a = (n + m)/2

Subtracting the second equation from the first:

2r = n - m => r = (n - m)/2

For a and r to be valid, they must be non-negative integers because you can't have a fraction of a move or negative moves.

Therefore, for the solution to be valid:

1. (n + m)/2 must be an integer (since a must be integer)

2. (n - m)/2 must be an integer (since r must be integer)

3. a >= 0 and r >= 0

But since a and r are counts of moves, they must be non-negative.

Wait, but in the problem, it's mentioned that n and m are positive integers, so n >=1 and m >=1.

But in the moves, m can be zero or even negative if more removes than adds are performed.

Wait, but according to the problem, m is at least 1, since m >=1.

But actually, in the problem statement, it says m >=1, but in reality, m could be zero or negative if more removes are done than adds.

But according to the problem, m >=1, so m is at least 1.

But in reality, m can be less than 1 if more removes are done.

But the problem says m >=1, so I don't need to worry about m <1.

Wait, in the problem statement, it says 1 <= n, m <=100, so m is at least 1.

But in practice, m could be zero or negative, but since the problem says m >=1, I can assume m is at least 1.

But in the earlier example, I saw that m could be zero, but according to the constraints, m >=1.

Wait, let's check the problem statement again.

"Each test case contains two integers n and m (1 <= n, m <=100)."

So, m is at least 1.

But in reality, m could be zero or negative, but according to the problem, m is at least 1.

So, in this problem, m is at least 1, so I don't need to handle cases where m is zero or negative.

Now, going back to the equations:

a = (n + m)/2

r = (n - m)/2

For a and r to be integers, (n + m) must be even, and (n - m) must be even.

Because if n + m is odd, a won't be an integer, and similarly for r.

Also, a and r must be non-negative.

So, the conditions for m to be achievable are:

1. (n + m) is even.

2. (n - m) is even.

3. a >=0 and r >=0.

But since a = (n + m)/2 >=0, and r = (n - m)/2 >=0.

Given that n and m are positive integers, and n >= m (since r >=0 implies n - m >=0), so n >= m.

Wait, n - m >=0 implies n >= m.

So, n >= m is a necessary condition.

Also, since a = (n + m)/2, and n >= m, and both are positive integers, a will be non-negative.

Similarly, r = (n - m)/2 >=0.

So, the conditions simplify to:

- n >= m

- (n + m) is even

- (n - m) is even

But actually, if (n + m) is even, then (n - m) is also even, because:

(n + m) - (n - m) = 2m, which is even.

So, if (n + m) is even, then (n - m) is also even.

Therefore, the condition boils down to:

- n >= m

- (n + m) is even

So, in the code, if n >= m and (n + m) % 2 == 0, then it's possible to have m cubes after n moves.

Looking back at the provided program:

def func():

for _ in range(int(input())):

(n, m) = map(int, input().split())

if n >= m and (n - m) % 2 == 0:

print('YES')

else:

print('NO')

Wait a minute, in my reasoning, the condition is n >= m and (n + m) % 2 == 0.

But in the provided code, it's n >= m and (n - m) % 2 == 0.

Is this a mistake?

Let me verify.

From earlier:

a = (n + m)/2

r = (n - m)/2

For a and r to be integers, (n + m) % 2 == 0 and (n - m) % 2 == 0.

But as I thought earlier, if (n + m) is even, then (n - m) is also even.

So, it's sufficient to check only one of them.

But in the code, it's checking n >= m and (n - m) % 2 == 0.

Wait, in my reasoning, it's n >= m and (n + m) % 2 == 0.

But according to the equations, both (n + m) and (n - m) must be even.

But as I thought, if one is even, the other is also even.

So, it's sufficient to check either (n + m) % 2 == 0 or (n - m) % 2 == 0.

But to confirm, let's look at the example cases.

Example 1:

n = 3, m = 3

n >= m: 3 >= 3

(n + m) = 6, which is even

(n - m) = 0, which is even

So, condition satisfies, output "YES"

Example 2:

n = 2, m = 4

n >= m: 2 >= 4? No

So, condition fails, output "NO"

Example 3:

n = 5, m = 3

n >= m: 5 >= 3

(n + m) = 8, which is even

(n - m) = 2, which is even

So, condition satisfies, output "YES"

Seems correct.

But in the code, it's checking (n - m) % 2 == 0, which in these cases is correct.

But is this always true?

Wait, let's consider another case where n < m.

For example:

n = 1, m = 2

n >= m? 1 >= 2? No, so output "NO"

But let's check (n + m) = 3, which is odd, and (n - m) = -1, which is odd.

But in the code, (n - m) = -1, and -1 % 2 == 1, so it would be "NO", which is correct.

Another case:

n = 4, m = 2

n >= m: 4 >= 2

(n + m) = 6, even

(n - m) = 2, even

So, "YES"

Another case:

n = 4, m = 0

But m >=1, so m cannot be zero in this problem.

But for completeness, if m=0, n=4.

n >= m: 4 >= 0

(n + m) = 4, even

(n - m) = 4, even

So, "YES", but since m >=1, m=0 is not allowed.

Another case:

n=1, m=1

n >= m: 1 >=1

(n + m) = 2, even

(n - m) =0, even

So, "YES"

Another case:

n=2, m=1

n >= m: 2 >=1

(n + m) =3, odd

(n - m)=1, odd

So, "NO"

Wait, according to the code, it checks (n - m) % 2 ==0, which is 1 % 2 ==1, so "NO", which is correct.

Seems consistent.

Therefore, the condition in the code is correct.

But to be thorough, let's see if there's any case where (n - m) % 2 ==0 but (n + m) %2 !=0.

Wait, but as established earlier, if (n - m) is even, then (n + m) is also even, and vice versa.

Because (n + m) - (n - m) = 2m, which is even.

So, if one is even, the other must be even.

Therefore, checking either (n + m) % 2 ==0 or (n - m) % 2 ==0 is sufficient.

Hence, the code is correct.

Therefore, the program is correct.

**Final Answer**

\[\boxed{\text{Yes}}\]

**Correctness: True**