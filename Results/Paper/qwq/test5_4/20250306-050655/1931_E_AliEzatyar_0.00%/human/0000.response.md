Alright, I have this problem to solve. It's about determining who wins in a game between Anna and Sasha based on a list of integers and some rules. Let's try to understand the problem step by step.

First, the problem describes the game:

- There are two players: Anna and Sasha.

- The game starts with Anna making the first move.

- The game involves a list of integers.

- Players take turns according to specific rules.

Let's look at the moves each player can make:

Anna's move:

- She chooses one element from the list and reverses its digits, removing any leading zeros.

- For example, 42 becomes 24, and 1580 becomes 851.

Sasha's move:

- He chooses two different elements from the list, concatenates them in any order, and inserts the result back into the list.

- For example, choosing 2007 and 19 can result in either 200719 or 192007.

- After this move, the number of elements in the list decreases by one.

The game ends when there's only one element left in the list, and Sasha can't make a move anymore. At that point, if the remaining integer is not less than \(10^m\), Sasha wins; otherwise, Anna wins.

It's also mentioned that the game will always end, so we don't have to worry about infinite loops.

Our task is to determine, for each test case, who will win if both players play optimally.

Given the input format:

- First line: number of test cases \( t \) (\(1 \leq t \leq 10^4\))

- For each test case:

- First line: two integers \( n \) and \( m \) (\(1 \leq n \leq 2 \cdot 10^5\), \(0 \leq m \leq 2 \cdot 10^6\))

- Second line: \( n \) integers \( a_1, a_2, \ldots, a_n \) (\(1 \leq a_i \leq 10^9\))

And the output should be "Sasha" or "Anna" for each test case, indicating who wins with optimal play.

Constraints also mention that the sum of \( n \) across all test cases does not exceed \( 2 \cdot 10^5 \), which is important for considering time complexity.

Looking at the example provided:

Input:

9

2 2

14 2

3 5

9 56 1

4 10

1 2007 800 1580

4 5

5000 123 30 4

10 10

6 4 6 2 3 1 10 9 10 7

1 1

6

1 1

10

8 9

1 2 9 10 10 2 10 2

4 5

10 10 10 10

Output:

Sasha

Anna

Anna

Sasha

Sasha

Anna

Anna

Anna

Sasha

I need to understand the logic behind the given program and verify if it correctly determines the winner for each test case.

First, let's try to understand the strategy or the logic that decides the winner.

Observations:

1. The game alternates between Anna and Sasha.

2. Anna starts the game.

3. The game ends when there's only one element left in the list.

4. The winner is determined by whether the final number is greater than or equal to \(10^m\).

5. Both players play optimally, meaning they make the best possible move to ensure their victory.

Let's think about how the game progresses.

Each turn:

- Anna reverses one number.

- Sasha concatenates two numbers into one.

The game continues until only one number remains.

The total number of moves:

- Each of Sasha's moves reduces the list size by one.

- Anna's moves don't change the list size.

Let's denote the initial number of elements as \( n \).

Each Sasha's move reduces \( n \) by one, so the number of Sasha's moves is \( n - 1 \).

Anna makes a move before each of Sasha's moves and possibly one more at the end if \( n \) is such that it's her turn.

Wait, no. Since Anna starts first, and players alternate turns.

Let's think about the total number of moves.

Each Sasha's move requires two numbers and produces one, reducing the list size by one.

So, to go from \( n \) elements to 1 element, Sasha needs to make \( n - 1 \) moves.

Since Anna moves first, and then they alternate, the total number of moves:

- Anna: if \( n \) is even, she makes \( n - 1 \) moves; if \( n \) is odd, she makes \( n \) moves.

Wait, let's think differently.

Total moves:

- Sasha makes \( n - 1 \) moves.

- Anna makes her move before each of Sasha's moves, plus possibly one more if \( n \) is odd.

Wait, no. Since Anna moves first, then Sasha, then Anna, and so on.

So, the sequence of moves:

- If \( n = 2 \): Anna moves first (reverses one number), then Sasha concatenates the two numbers into one. Game ends.

- If \( n = 3 \): Anna moves first (reverses one number), then Sasha concatenates two numbers into one (now list has 2 numbers), then Anna reverses one number, then Sasha concatenates the two numbers into one. Game ends.

Wait, no. For \( n = 3 \):

- Anna's first move: reverses one number (list still has 3 numbers).

- Sasha's first move: concatenates two numbers into one (list now has 2 numbers).

- Anna's second move: reverses one number (list still has 2 numbers).

- Sasha's second move: concatenates the two numbers into one. Game ends.

So, in total, Anna makes 2 moves, and Sasha makes 2 - 1 = 1 move.

Wait, that doesn't seem right.

Wait, perhaps it's better to think in terms of the number of Sasha's moves being \( n - 1 \), and Anna makes her move before each of Sasha's moves, plus possibly one more.

But in the above example for \( n = 3 \), Anna makes two moves: one before the first Sasha's move and one before the second Sasha's move.

Wait, but in reality, after Anna's first move, Sasha makes his first move, reducing the list to 2 elements. Then Anna makes her second move, reversing one of the two numbers, and then Sasha makes his second move, concatenating the two numbers into one.

So, Anna makes two moves, and Sasha makes two moves, but according to the earlier logic, Sasha should make \( n - 1 = 2 \) moves.

Wait, perhaps I need to think differently.

Let's consider that the game consists of \( n - 1 \) Sasha's moves, each preceded by an Anna's move, plus possibly an additional Anna's move if \( n \) is odd.

Wait, perhaps it's better to consider the total number of moves.

Total moves:

- The game starts with \( n \) numbers and ends with 1 number.

- Each Sasha's move reduces the number of elements by 1.

- Therefore, Sasha makes \( n - 1 \) moves.

- Anna makes her move before each of Sasha's moves, plus one more move at the end if \( n \) is odd.

Wait, no. Since Anna moves first, and then they alternate.

So, total Anna's moves:

- If \( n \) is even: \( n - 1 \) moves by Anna.

- If \( n \) is odd: \( n \) moves by Anna.

Wait, that doesn't seem right.

Wait, total moves:

- Anna makes a move, then Sasha, then Anna, then Sasha, and so on, until there's only one element left.

- Each Sasha's move reduces the number of elements by 1.

- So, Sasha needs to make \( n - 1 \) moves to reduce the list from \( n \) to 1.

- Since Anna moves first, and then they alternate, Anna makes \( n \) moves if \( n \) is odd, or \( n - 1 \) moves if \( n \) is even.

Wait, perhaps it's better to think in terms of total moves.

Total Sasha's moves: \( n - 1 \)

Total Anna's moves: \( n - 1 \) if \( n \) is even, \( n \) if \( n \) is odd.

Because Anna moves first, and then they alternate.

So, for \( n = 2 \):

- Anna moves first (reverses one number)

- Sasha moves (concatenates two numbers into one)

Total Anna moves: 1, Sasha moves: 1

For \( n = 3 \):

- Anna moves first (reverses one number)

- Sasha moves (concatenates two numbers into one, now list has 2 numbers)

- Anna moves (reverses one number)

- Sasha moves (concatenates two numbers into one)

Total Anna moves: 2, Sasha moves: 2 - 1 = 1

Wait, but in this case, Sasha makes 2 - 1 = 1 move, which matches the earlier count.

Wait, generalizing:

- Total Sasha's moves: \( n - 1 \)

- Total Anna's moves: \( n \) if \( n \) is odd, \( n - 1 \) if \( n \) is even.

Wait, but in \( n = 2 \):

- Anna makes 1 move, Sasha makes 1 move.

- Here, \( n \) is even, so Anna makes \( n - 1 = 1 \) move.

- In \( n = 3 \):

- Anna makes 3 moves, which is \( n \) moves, since \( n \) is odd.

Wait, but earlier sequence for \( n = 3 \) showed Anna making 2 moves.

Wait, perhaps I need to rethink this.

Let's think in terms of the number of turns.

Each turn consists of Anna's move followed by Sasha's move, except possibly the last one if \( n \) is odd.

Wait, perhaps it's better to think in terms of the total number of Anna's moves and Sasha's moves.

Let's try to find a general formula for the number of moves each player makes.

For \( n \) elements:

- To reduce to 1 element, Sasha needs to make \( n - 1 \) moves.

- Anna makes her move before each of Sasha's moves, plus one more if \( n \) is odd.

Wait, let's see:

- For \( n = 1 \): Anna makes one move (reverses the only number), then Sasha can't move. Total Anna moves: 1

- For \( n = 2 \): Anna moves first (reverses one number), then Sasha concatenates the two numbers into one. Total Anna moves: 1, Sasha moves: 1

- For \( n = 3 \): Anna moves first (reverses one number), then Sasha concatenates two numbers into one (now list has 2 numbers), then Anna reverses one number, then Sasha concatenates the two numbers into one. Total Anna moves: 2, Sasha moves: 2

Wait, but according to earlier logic, Sasha should make \( n - 1 = 2 \) moves, which matches.

But in this case, Anna makes 2 moves for \( n = 3 \), which is more than \( n - 1 \).

Wait, perhaps my earlier assumption is incorrect.

Let's try to find a pattern.

For \( n = 1 \):

- Anna makes one move, game ends.

- Anna's moves: 1, Sasha's moves: 0

For \( n = 2 \):

- Anna's move: reverse one number

- Sasha's move: concatenate the two numbers into one

- Anna's moves: 1, Sasha's moves: 1

For \( n = 3 \):

- Anna's first move: reverse one number (list has 3 numbers)

- Sasha's first move: concatenate two numbers into one (list now has 2 numbers)

- Anna's second move: reverse one number (list still has 2 numbers)

- Sasha's second move: concatenate the two numbers into one (list now has 1 number)

- Anna's moves: 2, Sasha's moves: 2

For \( n = 4 \):

- Anna's first move: reverse one number (list has 4 numbers)

- Sasha's first move: concatenate two numbers into one (list now has 3 numbers)

- Anna's second move: reverse one number (list has 3 numbers)

- Sasha's second move: concatenate two numbers into one (list now has 2 numbers)

- Anna's third move: reverse one number (list has 2 numbers)

- Sasha's third move: concatenate the two numbers into one (list now has 1 number)

- Anna's moves: 3, Sasha's moves: 3

Wait, but according to earlier logic, Sasha makes \( n - 1 = 3 \) moves, and Anna makes \( n = 4 \) moves.

But in this sequence, Anna makes 3 moves, not 4.

Wait, perhaps my counting is off.

Wait, maybe it's better to think recursively.

Think about the game as a tree where each node represents the state of the list.

But given the time constraints, I need a more efficient way to think about this.

Perhaps I can consider the total number of digits in the list and how they change with each move.

Wait, the problem mentions something about the total number of digits and some subtraction based on trailing zeros.

Looking back at the provided program:

- It reads \( n \) and \( m \)

- Reads the list of numbers as strings

- Computes the total number of digits in all numbers

- Counts the number of trailing zeros in each number and stores them in a list called zeros

- Sorts the zeros list in descending order

- Subtracts every other element in the sorted zeros list from the total digits

- Checks if the resulting total digits minus the subtracted zeros is greater than or equal to \( m + 1 \)

- If yes, prints "Sasha"; else, prints "Anna"

Wait, this seems to be a way to calculate some kind of effective digit length after considering the possible reversals and concatenations.

But I need to verify if this logic is correct.

First, let's consider what Anna can do.

Anna can reverse any number, which might change its digit count if there are leading zeros, but since leading zeros are removed, the digit count might decrease only if the number ends with zeros.

Wait, but in the problem statement, it says "leading zeros are removed," but in reality, when reversing a number, if it ends with zeros, they are removed because leading zeros are not allowed in integer representations.

So, reversing a number can reduce its digit count only if it had trailing zeros.

For example:

- 100 reversed is 001, which becomes 1 (digit count reduces from 3 to 1)

- 123 reversed is 321 (digit count remains 3)

So, Anna can choose to reverse numbers with trailing zeros to reduce their digit count.

Sasha, on the other hand, concatenates two numbers, which adds their digit counts together.

The final number's digit count will be the sum of the digit counts of all numbers, considering Anna's possible reductions.

The condition for Sasha to win is that the final number is not less than \(10^m\), which is equivalent to having at least \( m + 1 \) digits.

So, the problem reduces to determining if the final digit count is at least \( m + 1 \).

Given that Anna can reduce the digit count of numbers with trailing zeros by reversing them, and Sasha increases the digit count by concatenating numbers, we need to see how these operations affect the total digit count.

The provided program seems to calculate the total digit count and subtract some value based on the trailing zeros to account for Anna's possible reductions.

Let me try to understand the program's logic in detail.

Program's logic:

1. Read the number of test cases, \( t \).

2. For each test case:

a. Read \( n \) and \( m \).

b. Read the list of numbers as strings.

c. Calculate the total number of digits in all numbers.

d. For each number, count the number of trailing zeros and store them in a list called zeros.

e. Sort the zeros list in descending order.

f. Subtract every other element in the sorted zeros list from the total digits.

g. If the resulting total digits minus the subtracted zeros is greater than or equal to \( m + 1 \), print "Sasha"; else, print "Anna".

Wait, but in the code, it's checking if \( \text{abs}( \text{total\_digits} - \text{subtract\_zero} ) \geq m + 1 \), which is not exactly the same as what I thought.

Wait, perhaps I need to look into this more carefully.

Let's take an example from the input:

Test case 1:

2 2

14 2

Total digits: 2 (for 14) + 1 (for 2) = 3

Trailing zeros:

- 14 has 0 trailing zeros

- 2 has 0 trailing zeros

So, zeros list is [0, 0]

Sorted in descending order: [0, 0]

Subtract every other element: subtract_zeros = 0 + 0 = 0

Then, total_digits - subtract_zeros = 3 - 0 = 3

Check if 3 >= 2 + 1 = 3 → yes, so Sasha wins.

Which matches the first output "Sasha".

Another test case:

3 5

9 56 1

Total digits: 1 + 2 + 1 = 4

Trailing zeros:

- 9 has 0

- 56 has 0

- 1 has 0

zeros list: [0, 0, 0]

sorted: [0, 0, 0]

subtract every other: 0 + 0 = 0

total_digits - subtract_zeros = 4 - 0 = 4

Check if 4 >= 5 + 1 = 6 → no, so Anna wins.

But according to the sample output, it's "Anna", which matches.

Another test case:

4 10

1 2007 800 1580

Total digits: 1 + 4 + 3 + 4 = 12

Trailing zeros:

- 1 has 0

- 2007 has 0

- 800 has 2

- 1580 has 1

zeros list: [2, 1]

sorted descending: [2, 1]

subtract every other: 2 + 0 = 2

total_digits - subtract_zeros = 12 - 2 = 10

Check if 10 >= 10 + 1 = 11 → no, so Anna wins.

But according to the sample output, it's "Anna", which matches.

Wait, but according to the sample output, it's "Anna", but according to the program, it should be "Anna".

Wait, but in the explanation, it says "Anna" for this test case.

Wait, but in the sample input, it's "Anna" for this case, which matches the program's output.

Wait, but in the sample explanation, it says "Anna" for the first test case, but according to the program, it's "Sasha". Wait, no, in the first test case, the output is "Sasha", and according to the program, it's "Sasha".

Wait, perhaps I need to look back at the sample input and output.

Sample Input:

9

2 2

14 2

3 5

9 56 1

4 10

1 2007 800 1580

4 5

5000 123 30 4

10 10

6 4 6 2 3 1 10 9 10 7

1 1

6

1 1

10

8 9

1 2 9 10 10 2 10 2

4 5

10 10 10 10

Sample Output:

Sasha

Anna

Anna

Sasha

Sasha

Anna

Anna

Anna

Sasha

Wait, but in the problem statement, it says "Sasha" for the first test case, which matches the program's output.

Wait, but in my earlier manual calculation for the first test case, it seemed like it should be "Anna", but according to the sample output, it's "Sasha".

Wait, perhaps I need to understand the game better.

Looking back at the problem statement:

"It can be shown that the game will always end. Determine who will win if both players play optimally."

Given that, I need to find a general strategy or formula to determine the winner based on \( n \), \( m \), and the list of numbers.

Looking back at the program, it seems to be calculating the total digit length and subtracting some value based on the trailing zeros in the numbers.

I need to verify if this approach is correct.

Let me consider that Anna can reduce the digit count of numbers with trailing zeros by reversing them, effectively removing those zeros.

So, for each number with trailing zeros, Anna can reduce its digit count by the number of trailing zeros.

Sasha, by concatenating numbers, increases the total digit count.

The game alternates between Anna and Sasha, with Anna starting first.

The game ends when there's only one number left.

The winner is determined by whether the final number has at least \( m + 1 \) digits.

So, the program seems to be calculating the total digit count after Anna optimally reduces the digit counts of some numbers.

But I'm not entirely sure about the subtraction logic.

Let me consider that Anna can choose to reverse any number with trailing zeros, reducing its digit count by the number of trailing zeros.

Since Anna goes first and they alternate, Anna can choose which numbers to reverse to minimize the final digit count, while Sasha tries to maximize it.

The program seems to sort the trailing zeros in descending order and subtract every other one.

This might be related to the game's turn structure, where Anna can choose to reduce the digit count by the largest possible amounts on her turns.

But I'm not completely sure if this is the right approach.

Perhaps it's better to think in terms of the total digit count and the maximum reduction Anna can make.

Wait, maybe it's about the parity of the number of moves.

Given that Anna starts and they alternate, the number of Anna's moves depends on \( n \).

But this seems too vague.

Alternatively, perhaps it's about the total digit count and how Anna can reduce it by reversing numbers with trailing zeros.

Given that, perhaps the program is trying to calculate the minimum possible digit count Anna can achieve at the end of the game.

If that's the case, then the program's logic might be to subtract the maximum possible trailing zeros that Anna can eliminate.

But I'm still not entirely sure.

Let me consider a simple case.

Test case:

n = 1, m = 0

List: [1]

Total digits: 1

Trailing zeros: 0

subtract_zero: 0

Check if 1 - 0 >= 0 + 1 → 1 >= 1 → yes, Sasha wins.

But according to the problem, if n = 1, Anna makes the first move, reverses the number, and the game ends.

Since the number is 1, which is less than 10^0 = 1, Anna wins.

Wait, but according to the program's logic, it would check if the digit count is >= m + 1 = 1, which it is, so Sasha wins.

But according to the problem, Anna wins in this case because the final number is less than 10^m = 1.

So, there's a discrepancy here.

Wait, no, 1 is not less than 10^0 = 1; it's equal to it.

So, according to the problem, if the final number is not less than 10^m, Sasha wins; else, Anna wins.

So, 1 is not less than 1, so Sasha wins.

So, the program's output is correct in this case.

Another test case:

n = 1, m = 1

List: [1]

Total digits: 1

Trailing zeros: 0

subtract_zero: 0

Check if 1 - 0 >= 1 + 1 → 1 >= 2 → no, so Anna wins.

Indeed, 1 < 10^1 = 10, so Anna wins.

So, the program's logic seems to hold here.

Another test case:

n = 2, m = 2

List: [14, 2]

Total digits: 2 + 1 = 3

Trailing zeros: 0, 0

subtract_zero: 0

Check if 3 - 0 >= 2 + 1 → 3 >= 3 → yes, Sasha wins.

Which matches the sample output.

Another test case:

n = 3, m = 5

List: [9, 56, 1]

Total digits: 1 + 2 + 1 = 4

Trailing zeros: 0, 0, 0

subtract_zero: 0

Check if 4 - 0 >= 5 + 1 → 4 >= 6 → no, Anna wins.

Which matches the sample output.

Another test case:

n = 4, m = 10

List: [1, 2007, 800, 1580]

Total digits: 1 + 4 + 3 + 4 = 12

Trailing zeros: 0, 0, 2, 1

sorted descending: [2, 1]

subtract_zero: 2 + 0 = 2

Check if 12 - 2 >= 10 + 1 → 10 >= 11 → no, Anna wins.

Which matches the sample output.

Wait, but according to the sample output, it's "Anna" for this case.

Wait, but in my earlier manual calculation, it was "Anna", which matches.

So, perhaps the program's logic is correct.

But earlier, I thought there was a discrepancy with n=1, m=0, but actually, it was correct.

Wait, perhaps the program's logic is to calculate the total digits minus the sum of every other sorted trailing zeros, and check if it's >= m + 1.

If yes, Sasha wins;