Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given two integers, n and k, and I need to find a sequence of non-negative integers of size at most 25 that satisfies two conditions:

1. There should be no subsequence of the sequence that sums up to k.

2. For every integer v from 1 to n, except k, there should be a subsequence that sums up to v.

Also, it's guaranteed that a solution always exists under the given constraints.

First, I need to understand what a subsequence is. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. So, for example, if I have the sequence [1, 2, 3], some subsequences are [1], [2], [3], [1,2], [1,3], [2,3], and [1,2,3].

Now, the problem is to create a sequence such that no subsequence sums to k, but for every other v between 1 and n (excluding k), there is a subsequence that sums to v.

I need to think about how to construct such a sequence. The sequence should be able to generate all sums from 1 to n except for k.

One approach that comes to mind is to use a combination of powers of 2, because powers of 2 can be used to represent any number uniquely in binary. For example, with [1, 2, 4, 8], I can make any sum up to 15 (which is 1+2+4+8=15).

But in this problem, I need to exclude one particular sum, k, while being able to make all other sums from 1 to n.

So, maybe I can modify the set of powers of 2 to exclude the sum k.

Wait, but if I remove one power of 2, I can't make some sums. So, perhaps I need to adjust the sequence in a different way.

Another idea is to include numbers that allow me to make all sums except k. Maybe I can include numbers that cover all sums except k.

Let me consider the example in the problem:

Input:

5

2 2

6 1

8 8

9 3

10 7

Output:

1

1

5

2 3 4 5 6

7

1 1 1 1 1 1 1

4

7 1 4 1

4

1 2 8 3

Looking at the first test case:

n=2, k=2

Sequence: [1]

Subsequences:

- [] with sum 0

- [1] with sum 1

So, no subsequence sums to 2, which is k, and there is a subsequence that sums to 1, which is v=1.

Second test case:

n=6, k=1

Sequence: [2,3,4,5,6]

Subsequences:

- [2] sums to 2

- [2,3] sums to 5

- [2,4] sums to 6

- [3] sums to 3

- [3,4] sums to 7 (which is greater than n, so it's okay)

- etc.

But wait, n=6, so v can be from 1 to 6 except k=1.

But in this sequence, there's no subsequence that sums to 1. Wait, but k=1 is the one we shouldn't have, but v can be from 1 to 6 except k=1, but in this case, v=1 is excluded, which seems contradictory.

Wait, in the problem statement, it says "for all 1 ≤ v ≤ n where v ≠ k, there is a subsequence of a with a sum of v".

So, in this case, n=6, k=1, so v can be 2,3,4,5,6.

The sequence [2,3,4,5,6] can make sums 2,3,4,5,6 directly with single elements.

Sum 7 can be made by 2+5, but v=7 is not required since n=6.

Similarly, sum 8 can be made by 2+6, but again, v=8 is beyond n=6.

So, this seems correct for this test case.

Another test case:

n=8, k=8

Sequence: [1,1,1,1,1,1,1]

Subsequences can make sums from 0 to 7, so no sum reaches 8, which is k.

And for v from 1 to 7, you can select the appropriate number of 1's.

So, this works.

Next test case:

n=9, k=3

Sequence: [7,1,4,1]

Possible subsequences:

- [1] sums to 1

- [4] sums to 4

- [7] sums to 7

- [1,1] sums to 2

- [1,4] sums to 5

- [1,7] sums to 8

- [4,7] sums to 11

- [1,1,4] sums to 6

- [1,1,7] sums to 9

- [1,4,7] sums to 12

- [1,1,4,7] sums to 13

So, sums are 0,1,2,4,5,6,7,8,9,11,12,13.

Missing sum is 3, which is k.

And for v from 1 to 9 except 3, all are present.

Good.

Last test case:

n=10, k=7

Sequence: [1,2,8,3]

Subsequences:

- [1] sums to 1

- [2] sums to 2

- [8] sums to 8

- [3] sums to 3

- [1,2] sums to 3

- [1,8] sums to 9

- [1,3] sums to 4

- [2,8] sums to 10

- [2,3] sums to 5

- [8,3] sums to 11

- [1,2,8] sums to 11

- [1,2,3] sums to 6

- [1,8,3] sums to 12

- [2,8,3] sums to 13

- [1,2,8,3] sums to 14

So, sums are 0,1,2,3,4,5,6,8,9,10,11,12,13,14.

Missing sum is 7, which is k.

And for v from 1 to 10 except 7, all are present.

Good.

So, from these examples, I can see that it's possible to construct such sequences.

Now, I need to generalize this for any n and k.

Let me think about the properties such a sequence should have.

First, the sequence should be able to generate all sums from 1 to n except for k.

One way to ensure that all sums except one specific sum are achievable is to carefully choose the elements of the sequence so that their combinations cover all the required sums.

I need to ensure that no combination sums to k, while being able to sum to any other v in [1,n] except k.

This seems tricky.

Let me consider the idea of using a standard set of numbers that can generate all sums up to a certain value, and then modify it to exclude the sum k.

For example, using powers of 2, as they can generate any sum uniquely.

But in this problem, I need to exclude one particular sum.

So, maybe I can remove the element that corresponds to the binary representation of k.

Wait, but that might not work, because k could be a sum of multiple elements, not just a single element.

Wait, in binary representation, any number can be represented uniquely as a sum of powers of 2.

So, if I have the sequence [1,2,4,8,...], I can make any sum uniquely.

But I need to exclude one particular sum, k.

So, perhaps I can remove the element that corresponds to the highest set bit in k, or something like that.

Wait, but removing one element might affect multiple sums.

Alternatively, maybe I can keep all powers of 2 up to n, and then adjust by adding or removing elements to exclude k.

Wait, but the sequence size should be at most 25, which is manageable.

Let me consider the standard binary approach.

If I have the sequence [1,2,4,8,16,32,...], up to the largest power of 2 less than or equal to n.

With these, I can make any sum from 0 to the sum of the sequence, which is 2^{m+1}-1, where m is the largest exponent.

But I need to exclude one sum, k.

One way to exclude k is to remove the element that corresponds to the highest set bit in k.

But, this might not be sufficient, because other combinations could still sum to k.

Wait, for example, if k=3, which is 1+2, and if I remove 2, then I can't make 3 anymore.

But, I need to ensure that no combination sums to k.

Wait, but in this case, if I remove 2, then I can't make 2 or 3, because 3 requires both 1 and 2.

But I need to be able to make all other sums except k.

This seems tricky.

Maybe there's a better way.

Let me think differently.

Suppose I have a sequence that can generate all sums from 0 to n except k.

This is similar to having the entire set {1,2,3,...,n} minus the subsets that sum to k.

But that's too broad.

Alternatively, maybe I can choose a sequence where the possible sums cover everything except k.

Wait, perhaps I can choose a sequence where the only missing sum is k.

That seems like the requirement.

But how to construct such a sequence efficiently, with at most 25 elements.

Given that n can be up to 10^6, and t up to 1000, with the sum of n over all test cases up to 10^7, I need an efficient way to construct the sequence.

I need a general method that works for any n and k within the constraints.

Let me consider the fact that 25 is the maximum size of the sequence, and 10^9 is the upper limit for the elements.

25 elements can theoretically sum up to a very large number, since each can be up to 10^9.

But I need to make sure that with these 25 elements, I can cover all sums from 1 to n except k.

I need to minimize the number of elements, but it's allowed to be up to 25.

I need a strategy to select these elements.

One approach could be to use the minimal number of elements to cover all sums except k.

But minimal might not be necessary, as long as it's at most 25.

Wait, perhaps I can use a greedy approach.

Start with an empty sequence.

Iteratively add the smallest number that allows me to cover new sums without creating a sum equal to k.

But this might be too slow for large n.

I need a smarter way.

Let me consider the properties of the sequence.

Suppose I have a sequence where the sums cover everything except k.

This means that the set of all possible sums of subsequences is equal to {0,1,2,...,n} minus {k}.

Wait, but sums can be larger than n, but I only care about sums from 1 to n except k.

So, I need to make sure that for every v in {1,2,...,n} except k, there exists a subsequence that sums to v, and no subsequence sums to k.

One way to ensure this is to have a sequence where the possible sums are exactly {0,1,2,...,n} minus {k}.

But constructing such a sequence directly might be difficult.

Alternatively, perhaps I can use the inclusion-exclusion principle to select elements that cover the desired sums.

But that seems complicated.

Let me think about the problem differently.

Suppose I have a sequence that can generate all sums from 0 to s, where s >= n, except k.

I need to choose the sequence such that the only missing sum is k.

This seems similar to covering all integers in [0,n] except k with the sums of subsequences.

This sounds like a covering code problem, but I'm not sure.

Alternatively, perhaps I can look at the binary representations and manipulate the sequence accordingly.

Wait, maybe inclusion of certain elements allows me to cover the required sums.

Let me consider that in more detail.

Suppose I have a set of elements a1, a2, ..., am.

The possible sums are all possible combinations of these elements.

I need to ensure that for each v in [1,n] and v != k, there exists a subset of a1,...,am that sums to v.

Also, there should be no subset that sums to k.

This is equivalent to saying that the subset sum problem for this sequence should cover all numbers from 1 to n except k.

This is a classic subset sum problem with a twist.

I need to find a set of numbers that can generate all sums except one specific sum, k.

This seems tricky.

I need a systematic way to construct such a sequence.

Let me consider the standard binary representation again.

If I take the sequence [1,2,4,8,...], I can generate any sum uniquely.

But I need to exclude one particular sum, k.

So, perhaps I can modify this sequence to exclude k.

One idea is to remove the element that corresponds to the highest set bit in k.

For example, if k=3, which is 11 in binary, the highest set bit is 2.

So, if I remove 2 from [1,2,4,...], then I can't make 3 anymore, because 3 requires both 1 and 2.

But in this case, I might not be able to make other sums that require 2.

Wait, for example, with [1,4], I can make 1,4,5, but I can't make 2 or 3.

So, this approach doesn't work because it excludes more sums than just k.

I need a way to exclude only k and include all others.

Maybe I need to add extra elements to compensate for the removal.

Alternatively, perhaps I can include elements that allow alternative ways to reach the sums except k.

This is getting complicated.

Let me think about the problem in terms of linear algebra.

Each element in the sequence can be seen as a vector in a high-dimensional space, and the subsets correspond to linear combinations with coefficients 0 or 1.

But that might not help directly.

Wait, perhaps I can look at the problem in terms of generating functions.

The generating function for the sequence is the product of (1 + x^{a_i}) for each a_i in the sequence.

I need this generating function to have coefficients 1 for all v from 1 to n except v=k, where the coefficient should be 0.

So, the generating function should be:

f(x) = prod_{i=1}^m (1 + x^{a_i}) = sum_{v=0}^s c_v x^v,

where c_v = 1 for v in [1,n] and v != k, and c_v = 0 for v=k.

But constructing such a sequence directly is not straightforward.

I need a simpler approach.

Let me consider that the sequence should be able to generate all sums from 1 to n except k.

One way to ensure that is to have the sequence cover all sums except k.

But how?

Wait, maybe I can split the range [1,n] into parts and handle k separately.

Alternatively, perhaps I can use the fact that the sequence can have up to 25 elements, and try to choose elements that cover the required sums.

But I need a systematic way.

Let me look back at the examples.

In the second test case:

n=6, k=1

Sequence: [2,3,4,5,6]

This sequence can make sums 2,3,4,5,6 directly, and combinations can make other sums, but no subsequence sums to 1.

This works because k=1 is less than any element in the sequence, so no subsequence can sum to 1.

Similarly, in the third test case:

n=8, k=8

Sequence: [1,1,1,1,1,1,1]

Sums: 0,1,2,3,4,5,6,7 but no 8.

This works because the sum of all elements is 7, which is less than k=8.

So, no subsequence can sum to 8.

In the fourth test case:

n=9, k=3

Sequence: [7,1,4,1]

Sums: 0,1,2,4,5,6,7,8,9, but no 3.

Here, they used elements that allow sums except 3.

Similarly, in the fifth test case:

n=10, k=7

Sequence: [1,2,8,3]

Sums: 0,1,2,3,4,5,6,8,9,10, but no 7.

So, in some cases, they used multiple 1's, in others, specific combinations.

I need to find a general method to construct such sequences.

Let me consider that if I have elements that are all greater than k, then no subsequence can sum to k because k is less than any element.

But in that case, I can't make any sum less than the smallest element.

But in the second test case, they did that for k=1, since all elements are greater than 1.

But in other cases, like n=9, k=3, they used elements including 1 and 3, but arranged in a way that no subsequence sums to 3.

This seems inconsistent.

Wait, in the fourth test case, they have two 1's and 4 and 7.

Wait, in that test case, it's [7,1,4,1], which sums to sums like 1,4,7,1+1=2,1+4=5,1+7=8,1+1+4=6,1+1+7=9,1+4+7=12,1+1+4+7=13, etc., and no sum is 3.

But 1+2=3, but there is only one 1 in the sequence, so it's [7,1,4,1], so two 1's.

Wait, 1+2=3, but there is no 2 in the sequence, only 1,4,7,1.

Wait, 1+2 is not possible because there is no 2.

Wait, but there is a 1 and a 1 and a 4 and a 7.

So, 1+1+4=6, 1+1+7=9, etc., but no sum is 3.

So, in this case, they managed to avoid sum 3 by carefully choosing the elements.

Similarly, in the fifth test case, [1,2,8,3], sums are 1,2,3,8,1+2=3 (but 3 is already present), 1+8=9, 2+8=10, 1+2+8=11, etc., but no sum is 7.

Wait, but 1+2+3+1=7, but in this sequence, there is only one 1, so 1+2+3+1 would require two 1's, which might not be allowed.

Wait, in the sequence [1,2,8,3], the possible subsets are:

- [1]

- [2]

- [8]

- [3]

- [1,2] sums to 3

- [1,8] sums to 9

- [1,3] sums to 4

- [2,8] sums to 10

- [2,3] sums to 5

- [8,3] sums to 11

- [1,2,8] sums to 11

- [1,2,3] sums to 6

- [1,8,3] sums to 12

- [2,8,3] sums to 13

- [1,2,8,3] sums to 14

So, sums are 0,1,2,3,4,5,6,8,9,10,11,12,13,14.

Missing is 7, which is k=7.

So, in this case, they managed to avoid sum 7.

But how?

It seems like they chose elements such that no combination sums to 7.

I need to find a general method to do this.

Let me consider that if I have a set of elements that can generate all sums except k, I need to ensure that the subset sum equation sum a_i x_i = k has no solution, where x_i are 0 or 1.

But solving the subset sum problem is NP-complete, so I need a smarter way.

Given the constraints, n can be up to 10^6, and t up to 1000, with sum of n over test cases up to 10^7, I need an efficient algorithm.

I need to find a way to construct the sequence in a way that avoids k but includes all other sums.

Let me think about the fact that the sequence can have at most 25 elements.

25 elements can generate up to 2^25-1=33554431 different sums, which is way more than n=10^6.

So, it's feasible.

But how to choose those elements?

Wait, maybe I can use the fact that with 25 elements, I can cover a large range of sums.

I need to maximize the coverage while excluding k.

But how?

Let me consider that if I have elements that are powers of 2, I can cover all sums uniquely.

But I need to exclude one particular sum, k.

So, perhaps I can modify the set of powers of 2 by removing or adding elements to exclude k.

Wait, but removing an element excludes multiple sums.

Alternatively, maybe I can include additional elements to cover the sums that would be missing due to excluding k.

This seems complicated.

Let me think differently.

Suppose I have a sequence that can generate all sums from 0 to s, where s >= n, except k.

I need to choose the sequence such that the only missing sum is k.

This seems tricky.

Wait, perhaps I can use the fact that the sequence can have elements up to 10^9, which is much larger than n.

So, maybe I can include large elements that don't interfere with the sums up to n.

But I need to ensure that no combination sums to k.

Wait, perhaps I can include elements that are larger than n, except for those needed to cover sums up to n except k.

But I need to think carefully.

Let me consider that if I include elements that are larger than n, they won't affect the sums up to n.

So, I can include large elements without worrying about the sums up to n.

But I still need to cover all sums from 1 to n except k using combinations of elements, some of which may be large.

This seems confusing.

Let me try another approach.

Suppose I fix a set of small elements that can cover sums up to some value, and then add large elements to cover higher sums without interfering with the lower sums.

But again, ensuring that k is not achievable is tricky.

Let me consider that if I have a set of elements that can generate all sums from 1 to n except k, then the subset sum problem for this sequence should cover all v in [1,n] except v=k.

This is equivalent to saying that the subset sum problem should have solutions for all v != k, and no solution for v = k.

This is similar to having a complete coverage except for one point.

This seems challenging.

I need to find a way to construct such a sequence efficiently.

Let me consider that for each test case, I can output a fixed sequence that always works.

But that's unlikely, as different test cases have different n and k.

So, I need a way to adjust the sequence based on n and k.

Looking back at the provided code, let's see what it does.

The code is:

def func():

for _ in range(int(input())):

(n, k) = map(int, input().split())

nums = [1 << i for i in range(24)]

idx = 0

while k >= 1 << idx:

idx += 1

idx -= 1

nums.append(k - nums[idx])

nums.append(k + 1)

nums.append(k + nums[idx] + 1)

nums.remove(1 << idx)

print(len(nums))

print(*nums)

So, it does the following:

- It initializes nums as the first 24 powers of 2: [1,2,4,8,...,8388608]

- It finds the largest idx such that 1<<idx <= k

- It appends k - nums[idx], k + 1, and k + nums[idx] + 1 to nums

- It removes 1<<idx from nums

- It prints the length of nums and the nums themselves

So, for example, if k=3 and idx=1 (since 1<<1=2 <=3, and 1<<2=4 >3), so idx=1.

Then, it appends k - nums[idx] = 3 - 2 =1, k +1=4, and k + nums[idx]+1=3+2+1=6.

So, nums becomes [1,2,4