Alright, I've got this problem to solve. It's about a game between Alice and Bob where they have some coins in their wallets and they take turns making moves according to certain rules. The goal is to determine who will win if both play optimally.

First, I need to understand the problem completely. Alice and Bob have a certain number of coins in their wallets, specified by a and b respectively. They take turns, with Alice going first. In each turn, the player can choose to either exchange wallets with the opponent or keep their current wallet, and then remove one coin from their current wallet. The player who can't make a valid move loses.

So, the key points are:

1. Players take turns, Alice starts first.

2. In each turn, a player can choose to swap wallets or keep their current wallet.

3. After choosing, they must remove one coin from their current wallet, and the wallet can't have zero coins before removal.

4. The player who can't make a valid move loses.

I need to determine, for given a and b, who will win the game if both play optimally.

First, I should think about the base cases.

Consider when a = 1 and b = 1.

- Alice's turn: She can choose not to swap, then remove 1 coin from her wallet. Now, a = 0, b = 1.

- Bob's turn: He can't swap because if he swaps, he'd have a wallet with 0 coins, and he can't remove a coin from it. So, he chooses not to swap and removes 1 coin from his wallet. Now, a = 0, b = 0.

- Alice's turn: Both wallets have 0 coins, so she can't make a move. Hence, Bob wins.

So, in this case, Bob wins.

Another base case: a = 1, b = 2.

- Alice's turn: She can choose to swap or not.

- If she chooses not to swap: a = 0, b = 2.

- Bob's turn: He can choose to swap or not.

- If he chooses not to swap: a = 0, b = 1.

- Alice's turn: She must swap because her wallet has 0 coins. So, a = 0, b = 0.

- Bob's turn: Both wallets are empty, so Alice can't make a move. Bob wins.

- Alternatively, if Alice chooses to swap in the first place: a = 1, b = 2.

- Then Bob chooses not to swap: a = 0, b = 2.

- Alice chooses to swap: a = 0, b = 1.

- Bob chooses to swap: a = 0, b = 0.

- Alice can't make a move. Bob wins.

Wait, in both scenarios, Bob wins. But according to the sample input, when a=1 and b=4, Alice wins.

Wait, in the sample input, for a=1, b=1, Bob wins, and for a=1, b=4, Alice wins.

So, I need to find a general strategy.

Let me think in terms of game theory, specifically impartial games where the Sprague-Grundy theorem might apply.

But first, I need to see if this game can be modeled as a Nim game or something similar.

Alternatively, perhaps there's a pattern based on the parity of a and b.

Looking back at the sample input and output:

1 1 → Bob

1 4 → Alice

5 3 → Bob

4 5 → Alice

11 9 → Bob

83 91 → Bob

1032 9307 → Alice

839204 7281 → Alice

1000000000 1000000000 → Bob

53110 2024 → Bob

Looking at these, it's not immediately clear what the pattern is based on the sums or differences of a and b.

Wait, in the program provided, it seems to check if (a + b) % 2 == 0, then Bob wins, else Alice wins.

But looking back at the sample inputs:

a=1, b=1: sum=2, which is even → Bob wins.

a=1, b=4: sum=5, which is odd → Alice wins.

a=5, b=3: sum=8, even → Bob wins.

a=4, b=5: sum=9, odd → Alice wins.

And so on.

This seems to match the sample outputs.

So, is the winning condition simply based on the parity of the sum of a and b?

Wait, but in the first test case, a=1, b=1: sum=2, even → Bob wins.

In the second test case, a=1, b=4: sum=5, odd → Alice wins.

And so on.

It seems to hold for the sample inputs.

But is this generally true?

I need to verify this with some more test cases.

Let me consider a=2, b=2.

Sum=4, even → Bob wins.

Game play:

Alice's turn: chooses not to swap, a=1, b=2.

Bob's turn: chooses not to swap, a=0, b=2.

Alice's turn: must swap, a=0, b=1.

Bob's turn: chooses to swap, a=0, b=0.

Alice can't make a move. Bob wins.

So, consistent with the program.

Another test case: a=2, b=3.

Sum=5, odd → Alice wins.

Game play:

Alice's turn: chooses to swap, a=3, b=2.

Bob's turn: chooses not to swap, a=2, b=2.

Alice's turn: chooses not to swap, a=1, b=2.

Bob's turn: chooses not to swap, a=0, b=2.

Alice's turn: chooses to swap, a=0, b=1.

Bob's turn: chooses to swap, a=0, b=0.

Alice can't make a move. Bob wins.

Wait, but according to the program, sum=5 is odd, so Alice should win, but in this simulation, Bob wins.

Hmm, contradiction.

Wait, maybe I made a mistake in the simulation.

Let me try again.

Alice's turn: a=2, b=3.

Option 1: swap → a=3, b=2.

Then Bob's turn: a=3, b=2.

He can choose to swap or not.

If he chooses not to swap: a=2, b=2.

Then Alice's turn: a=2, b=2.

She chooses not to swap: a=1, b=2.

Bob's turn: a=1, b=2.

He chooses not to swap: a=0, b=2.

Alice's turn: a=0, b=2.

She must swap: a=0, b=1.

Bob's turn: a=0, b=1.

He chooses to swap: a=0, b=0.

Alice can't make a move. Bob wins.

But according to the program, since a+b=5, which is odd, Alice should win, but in this simulation, Bob wins.

So, the program seems incorrect here.

Wait, maybe I made a mistake in the simulation.

Let me try another approach.

Alice's turn: a=2, b=3.

Option 2: do not swap → a=1, b=3.

Then Bob's turn: a=1, b=3.

He can choose to swap or not.

If he chooses not to swap: a=0, b=3.

Alice's turn: a=0, b=3.

She must swap: a=0, b=2.

Bob's turn: a=0, b=2.

He chooses to swap: a=0, b=1.

Alice's turn: a=0, b=1.

She must swap: a=0, b=0.

Bob wins again.

So, in both scenarios, Bob wins, but according to the program, since a+b=5 is odd, Alice should win.

This suggests that the program is incorrect.

Wait, but in the sample input, for a=1, b=4, which sums to 5, Alice wins.

But in this case, a=2, b=3, sum=5, but Bob wins.

So, perhaps the program is incorrect.

Maybe the winning condition is not simply based on the parity of a+b.

Let me think differently.

Perhaps it's based on the difference between a and b.

But a=1, b=1: difference=0, Alice loses.

a=1, b=4: difference=3, Alice wins.

a=2, b=2: difference=0, Bob wins.

a=2, b=3: difference=1, Bob wins.

a=1, b=1: difference=0, Bob wins.

Wait, no clear pattern here either.

Alternatively, maybe it's about the parity of a and b individually.

If both a and b are even, or both are odd, then Bob wins; else, Alice wins.

But in a=1, b=1: both odd, Bob wins.

a=1, b=4: one odd, one even, Alice wins.

a=2, b=2: both even, Bob wins.

a=2, b=3: one even, one odd, Bob wins.

Wait, this seems inconsistent.

Wait, in a=2, b=3, according to this, one even, one odd, Alice should win according to the program, but in simulation, Bob wins.

Wait, perhaps the program is incorrect.

Alternatively, maybe it's about the XOR of a and b.

But that seems too vague without further analysis.

Let me consider the game in terms of game theory.

This game seems similar to the game of Nim, where players reduce the number of objects in heaps.

In this case, there are two "heaps" a and b, and players can either swap them or reduce one of them.

But the swap adds a twist.

I need to find the Grundy numbers for the game states.

But given the large constraints (a and b up to 10^9), calculating Grundy numbers directly is impractical.

Is there a way to find a simple formula based on a and b?

Looking back at the program, it's simply checking if a + b is even or odd.

Given the discrepancy in my earlier simulation, this seems too simplistic.

Perhaps the correct condition is based on the parity of a and b individually.

Let me check:

- If both a and b are even: Bob wins.

- If both a and b are odd: Bob wins.

- If one is even and the other is odd: Alice wins.

Looking back at the sample inputs:

a=1, b=1: both odd → Bob wins.

a=1, b=4: one odd, one even → Alice wins.

a=5, b=3: both odd → Bob wins.

a=4, b=5: one even, one odd → Alice wins.

a=11, b=9: both odd → Bob wins.

a=83, b=91: both odd → Bob wins.

a=1032, b=9307: one even, one odd → Alice wins.

a=839204, b=7281: one even, one odd → Alice wins.

a=1000000000, b=1000000000: both even → Bob wins.

a=53110, b=2024: both even → Bob wins.

This seems to match the sample outputs.

So, perhaps the correct condition is:

- If both a and b have the same parity (both even or both odd), Bob wins.

- If a and b have different parities, Alice wins.

This seems consistent with the sample inputs.

In my earlier simulation with a=2, b=3: different parities → Alice wins, but in my simulation, Bob won.

Wait, perhaps I made a mistake in the simulation.

Let me try again.

a=2, b=3.

Alice's turn:

Option 1: swap → a=3, b=2.

Then Bob's turn: a=3, b=2.

He can choose to swap or not.

If he chooses not to swap: a=2, b=2.

Alice's turn: a=2, b=2.

She chooses not to swap: a=1, b=2.

Bob's turn: a=1, b=2.

He chooses not to swap: a=0, b=2.

Alice's turn: a=0, b=2.

She must swap: a=0, b=1.

Bob's turn: a=0, b=1.

He chooses to swap: a=0, b=0.

Alice can't make a move. Bob wins.

Wait, but according to the parity condition, since a and b have different parities, Alice should win, but in this simulation, Bob wins.

This suggests that the parity condition might be incorrect.

Alternatively, maybe there's a misunderstanding in the simulation.

Let me try another approach.

a=2, b=3.

Alice's turn:

Option 2: do not swap → a=1, b=3.

Bob's turn: a=1, b=3.

He chooses not to swap: a=0, b=3.

Alice's turn: a=0, b=3.

She must swap: a=0, b=2.

Bob's turn: a=0, b=2.

He chooses to swap: a=0, b=1.

Alice's turn: a=0, b=1.

She must swap: a=0, b=0.

Bob wins again.

Hmm.

Wait, maybe Alice can choose differently.

In the first step, when a=2, b=3, Alice chooses to swap.

Then a=3, b=2.

Bob's turn: a=3, b=2.

He chooses to swap: a=2, b=3.

Alice's turn: a=2, b=3.

She chooses not to swap: a=1, b=3.

Bob's turn: a=1, b=3.

He chooses not to swap: a=0, b=3.

Alice's turn: a=0, b=3.

She must swap: a=0, b=2.

Bob's turn: a=0, b=2.

He chooses to swap: a=0, b=1.

Alice's turn: a=0, b=1.

She must swap: a=0, b=0.

Bob wins.

Alternatively, in Alice's first turn, when a=2, b=3, she chooses not to swap.

Then a=1, b=3.

Bob's turn: a=1, b=3.

He chooses not to swap: a=0, b=3.

Alice's turn: a=0, b=3.

She must swap: a=0, b=2.

Bob's turn: a=0, b=2.

He chooses to swap: a=0, b=1.

Alice's turn: a=0, b=1.

She must swap: a=0, b=0.

Bob wins.

In both cases, Bob wins, which contradicts the parity condition.

Wait, but according to the parity condition, since a and b have different parities, Alice should win, but in simulation, Bob wins.

This suggests that the parity condition might be incorrect.

Alternatively, perhaps there's a mistake in the simulation.

Let me try another test case.

a=3, b=3.

Both odd.

Sum=6, even → Bob wins.

Game play:

Alice's turn: chooses not to swap, a=2, b=3.

Bob's turn: chooses not to swap, a=1, b=3.

Alice's turn: chooses not to swap, a=0, b=3.

Bob's turn: must swap, a=0, b=2.

Alice's turn: must swap, a=0, b=1.

Bob's turn: must swap, a=0, b=0.

Alice can't make a move. Bob wins.

Consistent with the parity condition.

Another test case: a=2, b=4.

Both even.

Sum=6, even → Bob wins.

Game play:

Alice's turn: chooses not to swap, a=1, b=4.

Bob's turn: chooses not to swap, a=0, b=4.

Alice's turn: must swap, a=0, b=3.

Bob's turn: chooses to swap, a=0, b=2.

Alice's turn: chooses to swap, a=0, b=1.

Bob's turn: chooses to swap, a=0, b=0.

Alice can't make a move. Bob wins.

Again, consistent.

Another test case: a=3, b=4.

One odd, one even.

Sum=7, odd → Alice wins.

Game play:

Alice's turn: chooses to swap, a=4, b=3.

Bob's turn: chooses not to swap, a=3, b=3.

Alice's turn: chooses not to swap, a=2, b=3.

Bob's turn: chooses not to swap, a=1, b=3.

Alice's turn: chooses not to swap, a=0, b=3.

Bob's turn: must swap, a=0, b=2.

Alice's turn: must swap, a=0, b=1.

Bob's turn: must swap, a=0, b=0.

Alice can't make a move. Bob wins.

Wait, but according to the parity condition, since a and b have different parities, Alice should win, but in simulation, Bob wins.

This is confusing.

Wait, perhaps the parity condition is incorrect, and the program is wrong.

Alternatively, maybe there's a different pattern.

Let me consider the binary representations or something, but that might be too complicated.

Alternatively, perhaps it's about the difference between a and b being even or odd.

In the test case a=2, b=3, difference=1, which is odd, and Bob wins.

In a=3, b=4, difference=1, odd, Bob wins.

In a=1, b=1, difference=0, even, Bob wins.

In a=1, b=4, difference=3, odd, Alice wins.

Wait, no clear pattern.

Wait, in a=1, b=1, difference=0, even, Bob wins.

a=1, b=4, difference=3, odd, Alice wins.

a=2, b=2, difference=0, even, Bob wins.

a=2, b=3, difference=1, odd, Bob wins.

a=3, b=3, difference=0, even, Bob wins.

a=3, b=4, difference=1, odd, Bob wins.

Hmm, seems inconsistent.

Wait, perhaps it's about the minimum of a and b being even or odd.

In a=1, b=1, min=1, odd, Bob wins.

a=1, b=4, min=1, odd, Alice wins.

a=2, b=2, min=2, even, Bob wins.

a=2, b=3, min=2, even, Bob wins.

a=3, b=3, min=3, odd, Bob wins.

a=3, b=4, min=3, odd, Bob wins.

Hmm, seems like when min(a,b) is odd, Bob wins unless a and b are both odd, but in that case, Bob wins too.

Wait, this is still unclear.

Maybe I need to look for a different approach.

Let me consider the number of moves possible.

Each move reduces one coin from the current wallet.

The game ends when a player can't make a move, which is when both wallets are empty.

So, the total number of moves possible is a + b.

If a + b is even, Bob wins; else, Alice wins.

Wait, but in the test case a=2, b=3, a + b = 5, which is odd, but in simulation, Bob wins.

But according to this, Alice should win.

Contradiction.

Alternatively, maybe it's about who makes the last move.

In a + b moves, the last move would be made by the player who starts if a + b is odd, which is Alice.

But in the simulation, Bob wins, so this doesn't hold.

Wait, perhaps I need to consider that swapping can change the number of possible moves.

But swapping doesn't change the total number of coins; it just switches them.

So, perhaps the total number of moves is a + b, and since Alice starts, if a + b is odd, Alice makes the last move, but in the simulation, Bob wins.

This is confusing.

Alternatively, maybe the ability to swap allows players to manipulate the game in a way that changes who makes the last move.

This seems complicated.

Let me consider the game without the swap option.

If there's no swap option, then each player just removes one coin from their wallet every turn.

The game ends when a player can't make a move because their wallet is empty.

This is similar to the standard game of Nim with two heaps where players can only remove from one heap.

In that case, the player who faces two empty heaps loses.

But with the swap option, it's more complex.

Wait, perhaps I can model the game as two separate games: one where a is the heap and one where b is the heap, and swapping allows switching between the two games.

This might be similar to the game of Nim where players can choose which heap to remove from.

But in this game, the swap option allows switching the heaps in a way.

This is getting too abstract.

Let me try to think recursively.

Define the game state as (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

The player whose turn it is can choose to swap or not, and then remove one coin from their current wallet.

The player who can't make a move loses.

I need to find the winning strategy for Alice and Bob.

This seems like a standard impartial game, and I can assign a Grundy number to each game state.

But with a and b up to 1e9, calculating Grundy numbers isn't feasible.

I need a smarter way.

Let me consider the game in terms of positions.

Define a position as (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

Each move consists of two steps: choose to swap or not, then remove one coin from the current wallet.

So, from position (a, b), the possible moves are:

1. Do not swap: remove one coin from a → (a-1, b)

2. Swap: remove one coin from b → (a, b-1)

Wait, no.

Actually, when swapping, the wallets are exchanged, so a and b are swapped, and then one coin is removed from the current wallet, which is now b.

Wait, no.

Let's be precise.

Initial state: (a, b)

Player chooses to swap or not.

If swap:

- a and b are exchanged: new wallets are b and a.

- Then, remove one coin from the current wallet, which is now b (player's current wallet).

- So, new state: (a, b-1)

If not swap:

- Keep the current wallets: a and b.

- Remove one coin from a: new state (a-1, b)

So, from (a, b), the possible moves are:

- (a-1, b)

- (a, b-1)

Assuming a >=1 and b >=1.

Wait, but in the problem, after choosing to swap or not, the player removes one coin from their current wallet, provided that the wallet has at least one coin.

So, indeed, the possible moves are:

- If not swapping: (a-1, b)

- If swapping: (a, b-1)

So, effectively, the player can choose to decrease either a or b by one, each turn.

This simplifies the game to a standard subtraction game where players can decrease one of the two piles by one.

In this case, the game is similar to the game of Nim with two piles, where each move consists of removing one object from a single pile.

In such a game, the winning strategy depends on the XOR of the pile sizes.

Specifically, in normal play Nim, the first player wins if the XOR of the pile sizes is non-zero.

But in this game, the ending condition is when a player can't make a move, which is when both piles are zero.

This is similar to the standard Nim game.

So, in standard Nim, the first player wins if the XOR of the pile sizes is non-zero.

But in this problem, the ending condition is when both a and b are zero, which is different from standard Nim where the last player to remove the last object wins.

Wait, standard Nim is a normal play game where the last player to make a move wins.

In this problem, the player who can't make a move loses, which is the same as normal play.

So, in standard Nim, the first player wins if the XOR of the pile sizes is non-zero.

In this problem, it seems similar.

But in the sample input, when a=1, b=1, XOR=0, Bob wins.

When a=1, b=4, XOR=5, Alice wins.

When a=5, b=3, XOR=6, Alice wins.

Wait, but in the sample output, for a=5, b=3, Bob wins.

Contradiction.

Wait, perhaps I need to adjust my understanding.

Wait, in standard Nim, with two piles of sizes a and b, the first player wins if a XOR b != 0.

In this problem:

- a=1, b=1: XOR=0 → Bob wins.

- a=1, b=4: XOR=5 → Alice wins.

- a=5, b=3: XOR=6 → Alice wins.

But in the sample output, for a=5, b=3, Bob wins.

So, inconsistency.

Hence, perhaps the swap option changes the game in a way that standard Nim doesn't apply directly.

Alternatively, perhaps the game is equivalent to a single pile game.

Wait, perhaps I need to consider the sum a + b.

If a + b is even, Bob wins; else, Alice wins.

But as seen in the a=2, b=3 case, a + b =5, odd, but Bob wins, which contradicts the program's condition.

Alternatively, perhaps it's about the parity of a and b individually.

Looking back at the program, it checks if a + b is even.

If a + b is even, Bob wins; else, Alice wins.

But in the a=2, b=3 case, a + b =5, odd, but Bob wins.

Hence, the program seems incorrect.

Alternatively, perhaps the program is correct, and my simulation was wrong.

Wait, in the sample input, for a=1, b=4, a + b =5, odd, Alice wins.

For a=5, b=3, a + b=8, even, Bob wins.

For a=4, b=5, a + b=9, odd, Alice wins.

For a=2, b=3, a + b=5, odd, Alice should win according to the program, but in my simulation, Bob wins.

This suggests that the program might be incorrect.

Alternatively, perhaps there's a misunderstanding in the simulation.

Let me try another simulation for a=2, b=3.

Alice's turn:

Option 1: swap → (a=3, b=2)

Then, Bob's turn:

Option 1: swap → (a=2, b=3)

Alice's turn:

Option 1: swap → (a=3, b=2)

Bob's turn:

Option 1: swap → (a=2, b=3)

Alice's turn:

Option 1: swap → (a=3, b=2)

Bob's turn:

Option 1: swap → (a=2, b=3)

Alice's turn:

Option 1: swap → (a=3, b=2)

And so on.

This can continue indefinitely, but in reality, players must decrease the number of coins.

Wait, no, they must remove one coin from their current wallet after choosing to swap or not.

So, in the a=2, b=3 case:

Alice's turn:

Option 1: swap → (a=3, b=2), then remove 1 from b: (a=3, b=1)

Bob's turn:

Option 1: swap → (a=1, b=3), then remove 1 from a: (0, b=3)

Alice's turn:

Must swap because a=0: (a=3, b=0), then remove 1 from b: (3, -1)

Wait, but negative coins don't make sense.

I think I'm getting confused.

Wait, perhaps the game ends when a player can't make a move, which is when both a and b are zero.

But in practice, a player can't remove a coin from an empty wallet.

So, in the simulation above, when a=0 and b=3, Alice must swap: (a=3, b=0), then remove 1 from b: (3, -1), which is invalid.

Wait, perhaps I need to ensure that the wallet has at least one coin before removing.

So, in the state (0,3), Alice must swap: (0,3), but she can't remove a coin because her wallet has 0 coins.

Hence, she loses.

Wait, but according to the rules:

- After choosing to swap or not, the player must remove one coin from their current wallet, provided that the wallet has at least one coin.

- If the player's wallet has zero coins, they can't remove a coin and thus can't make a move, losing the game.

So, in the state (0,3), Alice can't make a move, so she loses.

Hence, Bob wins.

But according to the program, since a + b =5 is odd, Alice should win, but in simulation, Bob wins.

This suggests that the program is incorrect.

Alternatively, perhaps I made a mistake in the simulation.

Let me try again.

a=2, b=3.

Alice's turn:

Option 1: swap → (a=3, b=2), then remove 1 from b: (a=3, b=1)

Bob's turn:

Option 1: swap → (a=1, b=3), then remove 1 from a: (0, b=3)

Alice's turn:

Must swap: (a=3, b=0), then remove 1 from b: can't, because b=0.

Hence, Alice loses.

So, Bob wins.

But according to the program, since a + b =5 is odd, Alice should win, but in simulation, Bob wins.

Hence, the program is incorrect.

Alternatively, perhaps there's a different way Alice can play to win.

Let me try another approach.

a=2, b=3.

Alice's turn:

Option 2: do not swap → (a=1, b=3)

Bob's turn:

Option 1: swap → (a=3, b=2), then remove 1 from b: (3,1)

Alice's turn:

Option 1: swap → (1,3), then remove 1 from a: (0,3)

Bob's turn:

Must swap: (3,0), then remove 1 from b: can't, so Bob loses.

Wait, in this path, Alice wins.

But earlier, in another path, Bob wins.

Wait, in the first simulation, Bob wins, in the second, Alice wins.

Does this mean that Alice can force a win in some scenarios?

Wait, but in the first simulation, Bob wins, and in the second, Alice wins.

So, perhaps Alice can force a win by choosing the right path.

Hence, in this case, Alice can win if she chooses wisely.

Therefore, the program might be correct, and in a=2, b=3, Alice can win by choosing not to swap initially.

Wait, but in the first simulation, when Alice chooses to swap initially, Bob wins.

But if Alice chooses not to swap initially, she can force a win.

Hence, Alice can choose the path that leads to her victory.

Therefore, in this case, Alice can win, which aligns with the program's output based on a + b being odd.

Hence, the program seems correct.

Wait, but in the simulation where Alice chooses to swap initially, Bob wins.

But since Alice can choose not to swap initially and force a win, she can win the game.

Hence, the program is correct in this case.

I must ensure that Alice can indeed force a win when a + b is odd.

Let me check another case.

a=3, b=4.

a + b =7, odd → Alice wins.

Simulation:

Alice's turn:

Option 1: swap → (a=4, b=3), then remove 1 from b: (4,2)

Bob's turn:

Option 1: swap → (2,4), then remove 1 from a: (1,4)

Alice's turn:

Option 1: swap → (4,1), then remove 1 from b: (4,0)

Bob's turn:

Must swap: (0,4), then remove 1 from b: (0,3)

Alice's turn:

Must swap: (3,0), then remove 1 from a: (2,0)

Bob's turn:

Swap: (0,2), remove 1 from b: (0,1)

Alice's turn:

Swap: (1,0), remove 1 from a: (0,0)

Bob's turn:

Can't make a move, so Bob loses. Alice wins.

Hence, consistent with the program.

Another test case: a=3, b=3.

a + b =6, even → Bob wins.

Simulation:

Alice's turn:

Option 1: swap → (3,3), then remove 1 from b: (3,2)

Bob's turn:

Option 1: swap → (2,3), then remove 1 from a: (1,3)

Alice's turn:

Option 1: swap → (3,1), then remove 1 from b: (3,0)

Bob's turn:

Must swap: (0,3), then remove 1 from b: (0,2)

Alice's turn:

Must swap: (2,0), then remove 1 from a: (1,0)

Bob's turn