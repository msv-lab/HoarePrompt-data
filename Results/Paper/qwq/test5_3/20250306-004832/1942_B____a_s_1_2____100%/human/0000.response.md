Alright, I have this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in the given array. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the array. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that at least one valid p exists for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation of 0 to n-1, each number appears exactly once. Also, MEX of the first i elements of p will be a number between 0 and n, because the MEX can be from 0 up to n, since p contains numbers from 0 to n-1.

I need to find p such that for each i, a_i = MEX(p_1 to p_i) - p_i.

Let me consider the first element p_1. The MEX of just p_1 is the smallest non-negative integer not equal to p_1. Since p_1 is from 0 to n-1, MEX(p_1) would be 0 if p_1 is not 0, or 1 if p_1 is 0. Wait, no. If p_1 is 0, then MEX is 1, because 0 is present. If p_1 is 1, MEX is 0, since 0 is missing. If p_1 is 2, MEX is 0, and so on. So, MEX(p_1) is 0 if p_1 is not 0, else 1.

Wait, no. Let's think again. MEX of a single element x is the smallest non-negative integer not equal to x. So, if x is 0, MEX is 1. If x is 1, MEX is 0. If x is 2, MEX is 0. If x is 3, MEX is 0, and so on.

So, for p_1:

- If p_1 = 0, MEX(p_1) = 1

- If p_1 = 1, MEX(p_1) = 0

- If p_1 = 2, MEX(p_1) = 0

- ...

So, a_1 = MEX(p_1) - p_1

- If p_1 = 0, a_1 = 1 - 0 = 1

- If p_1 = 1, a_1 = 0 - 1 = -1

- If p_1 = 2, a_1 = 0 - 2 = -2

- ...

Interesting. So, for p_1, a_1 can be 1 or negative, depending on p_1.

Now, for p_2, a_2 = MEX(p_1, p_2) - p_2

I need to consider the MEX of p_1 and p_2.

Let's think about possible values of MEX(p_1, p_2):

- If p_1 and p_2 include 0 and 1, then MEX is the smallest missing non-negative integer.

- For example, if p_1 = 0 and p_2 = 1, MEX is 2.

- If p_1 = 0 and p_2 = 2, MEX is 1.

- If p_1 = 1 and p_2 = 0, MEX is 2.

- If p_1 = 1 and p_2 = 2, MEX is 0.

Wait, let's calculate MEX for different pairs:

- p_1 = 0, p_2 = 1: MEX(0,1) = 2

- p_1 = 0, p_2 = 2: MEX(0,2) = 1

- p_1 = 1, p_2 = 0: MEX(1,0) = 2

- p_1 = 1, p_2 = 2: MEX(1,2) = 0

- p_1 = 2, p_2 = 0: MEX(2,0) = 1

- p_1 = 2, p_2 = 1: MEX(2,1) = 0

So, a_2 = MEX(p_1, p_2) - p_2

For example:

- If p_1 = 0, p_2 = 1, a_2 = 2 - 1 = 1

- If p_1 = 0, p_2 = 2, a_2 = 1 - 2 = -1

- If p_1 = 1, p_2 = 0, a_2 = 2 - 0 = 2

- If p_1 = 1, p_2 = 2, a_2 = 0 - 2 = -2

- If p_1 = 2, p_2 = 0, a_2 = 1 - 0 = 1

- If p_1 = 2, p_2 = 1, a_2 = 0 - 1 = -1

So, a_2 can be positive or negative depending on p_1 and p_2.

This seems a bit tricky. I need a general way to find p from a.

Given that p is a permutation, each number from 0 to n-1 appears exactly once in p.

I need to find p such that for each i, a_i = MEX(p_1 to p_i) - p_i.

Let me think about the properties of MEX here.

For a sequence p_1 to p_i, MEX is the smallest non-negative integer not in that sequence.

So, MEX(p_1 to p_i) is some number, say m.

Then, a_i = m - p_i, so p_i = m - a_i.

So, if I can find m for each i, then p_i is m - a_i.

But m is the MEX of p_1 to p_i, which depends on the previous p_j's.

This seems recursive.

Maybe I can iterate from i=1 to n, and keep track of the MEX at each step.

Let me try to think of an algorithm:

Initialize an empty set S to keep track of the numbers seen so far.

For each i from 1 to n:

- Find the MEX of p_1 to p_i, which is the smallest non-negative integer not in S.

- Given that a_i = MEX - p_i, so p_i = MEX - a_i.

- Add p_i to S.

But to find MEX, I need to know which numbers are in S.

Wait, but S is the set of p_1 to p_i, so MEX is the smallest non-negative integer not in S.

But I don't know S yet, since p is unknown.

This seems circular.

Let me think differently.

Since p is a permutation, each number from 0 to n-1 appears exactly once in p.

So, in the entire p, all numbers from 0 to n-1 are present.

Now, for the entire p, MEX(p_1 to p_n) would be n, because all numbers from 0 to n-1 are present.

But for partial sequences, MEX can be less than n.

Wait, perhaps I can think about the MEX at each step.

Let me consider the last element, p_n.

At i=n, MEX(p_1 to p_n) is n, since all numbers from 0 to n-1 are present.

So, a_n = n - p_n.

Therefore, p_n = n - a_n.

So, I can directly compute p_n from a_n.

Once I have p_n, I can proceed to i=n-1.

At i=n-1, MEX(p_1 to p_{n-1}) is the smallest number not in p_1 to p_{n-1}.

Since p_n is already known, and p is a permutation, I can determine which numbers are in p_1 to p_{n-1}.

Wait, maybe it's better to iterate from the end to the beginning.

Let me try that.

Start from i=n.

At i=n:

- MEX(p_1 to p_n) = n

- a_n = n - p_n

- So, p_n = n - a_n

Then, for i=n-1:

- MEX(p_1 to p_{n-1}) is the smallest number not in p_1 to p_{n-1}

- Since p_n is already known, and p is a permutation, the numbers in p_1 to p_{n-1} are all numbers from 0 to n-1 except p_n.

- So, MEX(p_1 to p_{n-1}) is either n or the smallest number missing in p_1 to p_{n-1}.

Wait, but I know p_n, and p_1 to p_{n-1} are all numbers except p_n.

So, MEX(p_1 to p_{n-1}) is the smallest number not in p_1 to p_{n-1}, which is either p_n or n, depending on p_n.

Wait, p_n is already known, and p_1 to p_{n-1} are all other numbers.

So, MEX(p_1 to p_{n-1}) is the smallest number not in p_1 to p_{n-1}, which is p_n if p_n < n, or n if p_n = n.

But p_n can't be n, since p is a permutation of 0 to n-1.

Wait, p_n is between 0 to n-1, since p is a permutation of 0 to n-1.

So, MEX(p_1 to p_{n-1}) is p_n, because p_n is the number missing in p_1 to p_{n-1}.

Therefore, a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1} = p_n - p_{n-1}

So, p_{n-1} = p_n - a_{n-1}

Similarly, for i=n-2:

MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}.

Given that p_1 to p_{n-1} are all numbers except one, p_1 to p_{n-2} are missing two numbers: p_{n-1} and p_n.

Wait, no. p_1 to p_{n-1} are all numbers except p_n.

Wait, p_1 to p_{n-1} are all numbers except p_n.

So, p_1 to p_{n-2} are all numbers except p_{n-1} and p_n.

But p_{n-1} and p_n are both known by now.

Wait, p_n is known from earlier, and p_{n-1} can be computed from p_n and a_{n-1}.

So, MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}, which is the smaller of p_{n-1} and p_n.

Wait, p_{n-1} and p_n are both missing in p_1 to p_{n-2}.

So, MEX(p_1 to p_{n-2}) is the minimum of p_{n-1} and p_n.

Therefore, a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2} = min(p_{n-1}, p_n) - p_{n-2}

So, p_{n-2} = min(p_{n-1}, p_n) - a_{n-2}

Similarly, for i=n-3:

MEX(p_1 to p_{n-3}) is the smallest number not in p_1 to p_{n-3}, which is the smallest number among p_{n-1}, p_n, and p_{n-2}.

Wait, p_1 to p_{n-3} are missing p_{n-2}, p_{n-1}, and p_n.

So, MEX(p_1 to p_{n-3}) is the smallest of p_{n-2}, p_{n-1}, p_n.

Therefore, a_{n-3} = MEX(p_1 to p_{n-3}) - p_{n-3} = min(p_{n-2}, p_{n-1}, p_n) - p_{n-3}

So, p_{n-3} = min(p_{n-2}, p_{n-1}, p_n) - a_{n-3}

And so on.

So, in general, for each i from n-1 down to 1:

p_i = min(p_{i+1}, p_{i+2}, ..., p_n) - a_i

Wait, no.

Wait, for i=n:

p_n = n - a_n

For i=n-1:

p_{n-1} = p_n - a_{n-1}

For i=n-2:

p_{n-2} = min(p_{n-1}, p_n) - a_{n-2}

For i=n-3:

p_{n-3} = min(p_{n-2}, p_{n-1}, p_n) - a_{n-3}

...

For i=1:

p_1 = min(p_2, p_3, ..., p_n) - a_1

This seems to be a pattern.

So, in code, I can start from i=n, compute p_n = n - a_n, then proceed backwards, computing p_i as min(p_{i+1}, ..., p_n) - a_i for each i from n-1 down to 1.

But wait, in the example:

n=5, a=[1,1,-2,1,2]

Computing p:

p[4] = 5 - 2 = 3

p[3] = min(p[4]) - 1 = min(3) -1 = 2

p[2] = min(p[3], p[4]) - (-2) = min(2,3) +2 = 0

p[1] = min(p[2], p[3], p[4]) -1 = min(0,2,3) -1 = -1

Wait, but p[1] can't be -1, since p is a permutation of 0 to 4.

Hmm, seems like there's a mistake in my reasoning.

Wait, perhaps I need to keep track of the minimum MEX up to each point.

Let me look at the example again.

In the example:

n=5, a=[1,1,-2,1,2]

p=[0,1,4,2,3]

Let's verify:

a1 = MEX(0) - 0 = 1 - 0 =1

a2 = MEX(0,1) -1 =1 -1=0? Wait, but in the example, a2=1.

Wait, MEX(0,1)=2, so a2=2-1=1.

Yes, that matches.

a3 = MEX(0,1,4)=2, a3=2-4=-2

a4 = MEX(0,1,4,2)=3, a4=3-2=1

a5 = MEX(0,1,4,2,3)=5-3=2

So, it's correct.

Now, in my earlier approach, for n=5, a=[1,1,-2,1,2]

Compute p[4]=5-2=3

p[3]=min(p[4])-1=3-1=2

p[2]=min(p[3],p[4])-(-2)=2+2=4

p[1]=min(p[2],p[3],p[4])-1=min(4,2,3)-1=2-1=1

p[0]=min(p[1],p[2],p[3],p[4])-1=min(1,4,2,3)-1=1-1=0

So, p=[0,1,4,2,3], which matches the example.

Wait, earlier I had p[1]=-1, but that was a miscalculation.

Let me see:

p[4]=5-2=3

p[3]=min(3)-1=2

p[2]=min(2,3)-(-2)=2+2=4

p[1]=min(4,2,3)-1=2-1=1

p[0]=min(1,4,2,3)-1=1-1=0

Yes, that works.

So, the approach seems correct.

Let me see another example:

n=5, a=[1,1,1,1,1]

p=[0,1,2,3,4]

Check:

a1=MEX(0)-0=1-0=1

a2=MEX(0,1)-1=2-1=1

a3=MEX(0,1,2)-2=3-2=1

a4=MEX(0,1,2,3)-3=4-3=1

a5=MEX(0,1,2,3,4)-4=5-4=1

Yes, matches the second example.

Another example:

n=3, a=[-2,1,2]

p=[2,0,1]

Check:

a1=MEX(2)-2=0-2=-2

a2=MEX(2,0)-0=1-0=1

a3=MEX(2,0,1)-1=3-1=2

Which matches the third example.

So, the approach works.

Therefore, the code provided is correct.

So, the answer is Correctness: **True**

