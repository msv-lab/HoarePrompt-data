Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome. The goal is to distribute my bets in such a way that no matter which outcome wins, the total coins I get back are more than the total coins I bet.

First, I need to understand the constraints. For each test case, I'm given n (the number of outcomes), and then a list of k_i values, which are the multipliers for each outcome. The k_i values are at least 2, which makes sense because if it were 1, betting on that outcome wouldn't give me any profit.

The problem says that exactly one of the n outcomes will be winning, and I need to ensure that regardless of which one wins, the coins I get back are strictly more than the total coins I bet.

Let me think about how to approach this. I need to assign bets x_i to each outcome such that the sum of all x_i is less than k_j * x_j for each j from 1 to n.

In other words, for each j:

sum_{i=1 to n} x_i < k_j * x_j

This needs to hold for all j from 1 to n.

Let me rearrange this inequality:

sum_{i=1 to n} x_i < k_j * x_j

which can be written as:

sum_{i ≠ j} x_i < (k_j - 1) * x_j

This seems tricky. I need to find integer values for x_i that satisfy this condition for all j.

Hmm, maybe there's a way to express x_i in terms of the other variables.

Let me consider the idea of setting x_j in terms of the other x_i's.

From the inequality:

sum_{i ≠ j} x_i < (k_j - 1) * x_j

I can solve for x_j:

x_j > sum_{i ≠ j} x_i / (k_j - 1)

This suggests that x_j needs to be larger than the sum of the other bets divided by (k_j - 1).

This seems a bit circular, as x_j depends on the other x_i's, and vice versa.

Maybe there's a better way to approach this.

Let me think about the least common multiple or something related to the multipliers.

Wait, perhaps I can consider the product of all k_i's and use that to find a solution.

Let's try that.

Suppose I set x_j = P / k_j, where P is the product of all k_i's.

Wait, that might not work directly, because k_j could divide P, but I need to ensure that the sum of x_i's is less than k_j * x_j for each j.

Let me try to calculate this.

Let P = product of all k_i from i=1 to n.

Then, set x_j = P / k_j.

Then, sum of all x_i = sum_{i=1 to n} (P / k_i)

Now, for each j, k_j * x_j = k_j * (P / k_j) = P

So, I need sum_{i=1 to n} (P / k_i) < P

This simplifies to sum_{i=1 to n} (1 / k_i) < 1

So, this approach would work only if the sum of 1/k_i for all i is less than 1.

But in the problem, k_i are at least 2, and n can be up to 50, so it's possible that sum_{i=1 to n} (1/k_i) >= 1, especially when n is large and k_i are small.

For example, if n=3 and k_i=2 for all i, then sum_{i=1 to 3} (1/2) = 3/2 >=1, so this approach wouldn't work.

Hence, this method isn't always applicable.

I need a different approach.

Let me consider the denominators.

If I set x_j = P / k_j, and sum_{i=1 to n} (P / k_i) < P, which is equivalent to sum_{i=1 to n} (1 / k_i) < 1.

If this condition holds, then this x_j works.

But if sum_{i=1 to n} (1 / k_i) >=1, then this approach fails.

I need to find a way that works regardless of the sum of 1/k_i.

Wait, maybe I can scale the x_j's by some factor to make the sum less than P.

But I'm not sure.

Let me think differently.

Suppose I set x_j = c * (P / k_j), where c is some constant.

Then, sum_{i=1 to n} x_i = c * sum_{i=1 to n} (P / k_i) = c * P * sum_{i=1 to n} (1 / k_i)

And k_j * x_j = c * P

So, I need c * P * sum_{i=1 to n} (1 / k_i) < c * P

Which simplifies to sum_{i=1 to n} (1 / k_i) < 1

Again, same condition.

So, scaling by a constant doesn't help if the sum of 1/k_i >=1.

I need another strategy.

Let me consider the problem in terms of inequalities.

For each j, sum_{i ≠ j} x_i < (k_j -1) * x_j

I can write this as sum_{i ≠ j} x_i + x_j < k_j * x_j

Which simplifies to sum_{i=1 to n} x_i < k_j * x_j

So, sum_{i=1 to n} x_i < k_j * x_j for all j.

I need to find x_i's that satisfy this for all j.

This seems like a system of inequalities.

Maybe I can use the method of solving inequalities to find a feasible solution.

Alternatively, perhaps there's a formula or a known algorithm for this.

Let me think about the case when n=1.

If n=1, then sum of x_i is just x_1, and k_1 * x_1 should be greater than x_1.

Since k_1 >=2, this is always true for any x_1 >=1.

So, for n=1, it's always possible.

For n=2, let's see.

sum_{i=1 to 2} x_i < k_1 * x_1 (for j=1)

and sum_{i=1 to 2} x_i < k_2 * x_2 (for j=2)

Let me denote s = x_1 + x_2

Then, s < k_1 * x_1 and s < k_2 * x_2

So, s < k_1 * x_1 and s < k_2 * (s - x_1)

Because x_2 = s - x_1

So, s < k_1 * x_1 and s < k_2 * (s - x_1)

This seems a bit messy.

Maybe I can solve for x_1 in terms of s.

From s < k_1 * x_1, we have x_1 > s / k_1

From s < k_2 * (s - x_1), we have s < k_2 * (s - x_1)

Which implies s < k_2 * (s - s / k_1)

Wait, since x_1 > s / k_1, let's substitute that.

s < k_2 * (s - s / k_1) = k_2 * s * (1 - 1/k_1) = k_2 * s * ((k_1 -1)/k_1)

So, s < k_2 * s * (k_1 -1)/k_1

Assuming s >0, we can divide both sides by s:

1 < k_2 * (k_1 -1)/k_1

Which simplifies to k_1 < k_2 * (k_1 -1)

Let me rearrange:

k_1 < k_2 * k_1 - k_2

Then, k_2 < k_2 * k_1 - k_1

Wait, this seems off.

Let me start over.

From s < k_2 * (s - x_1), and x_1 > s / k_1

So, s < k_2 * (s - s / k_1) = k_2 * s * (1 - 1/k_1) = k_2 * s * ((k_1 -1)/k_1)

Then, 1 < k_2 * (k_1 -1)/k_1

Which simplifies to k_1 / (k_1 -1) < k_2

Similarly, by symmetry, we'd have k_2 / (k_2 -1) < k_1

This seems like a condition that must be satisfied for n=2.

But for n >=3, it's probably more complex.

This seems too involved for my current approach.

Maybe there's a different way to look at this.

Let me consider the minimal k_j.

Let’s say k_min is the smallest k_j among all k_j.

Then, for the j where k_j = k_min, the condition sum_{i=1 to n} x_i < k_j * x_j

Since k_j is the smallest, this is the most restrictive condition.

So, if I can satisfy this for the minimal k_j, it should satisfy for the others.

But I'm not sure if that helps directly.

Wait, perhaps I can set x_j proportional to some function of k_j.

Let me consider setting x_j = c / (k_j -1), where c is a constant.

Then, sum_{i=1 to n} x_i = c * sum_{i=1 to n} 1/(k_i -1)

And for each j, k_j * x_j = c * k_j / (k_j -1) = c * (1 + 1/(k_j -1))

So, I need sum_{i=1 to n} x_i < k_j * x_j for all j.

Which is:

c * sum_{i=1 to n} 1/(k_i -1) < c * (1 + 1/(k_j -1)) for all j.

Dividing both sides by c (assuming c>0), we get:

sum_{i=1 to n} 1/(k_i -1) < 1 + 1/(k_j -1) for all j.

Which simplifies to sum_{i=1 to n} 1/(k_i -1) - 1/(k_j -1) < 1 for all j.

Which is sum_{i ≠ j} 1/(k_i -1) < 1 for all j.

This needs to hold for all j.

So, for each j, sum_{i ≠ j} 1/(k_i -1) <1.

This seems like a necessary condition.

But I'm not sure if it's sufficient, or how to use it to find x_j.

This is getting too complicated.

Maybe I should look for an algorithmic approach rather than trying to find a mathematical formula.

Let me consider that.

Given that n can be up to 50 and t can be up to 10^4, but the total sum of n over all test cases is up to 2*10^5, I need an efficient solution, probably O(n) per test case.

So, something like O(n) time per test case.

I need to find a way to compute x_j efficiently.

Perhaps I can use the concept of solving linear inequalities or something similar, but that seems too slow or complicated for this problem.

Let me look back at the initial approach.

In the initial approach, I considered x_j = P / k_j, where P is the product of all k_i.

And sum_{i=1 to n} x_i = P * sum_{i=1 to n} 1/k_i

And k_j * x_j = P

So, the condition is P * sum_{i=1 to n} 1/k_i < P, which simplifies to sum_{i=1 to n} 1/k_i <1.

If this holds, then this choice of x_j works.

But if sum_{i=1 to n} 1/k_i >=1, then this approach fails.

So, in the example where n=3 and k_i=2 for all, sum_{i=1 to 3} 1/2 = 3/2 >=1, so this approach doesn't work.

But in the first test case of the sample input:

n=3, k=[3,2,7]

sum_{i=1 to 3} 1/k_i = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 <1

So, in this case, sum_{i=1 to 3} 1/k_i <1, and the sample output is possible with x_j = P / k_j, where P=3*2*7=42.

So, x_j = [14,21,6]

Sum = 14+21+6=41 <42

And k_j * x_j for each j are [42,42,42], which are all greater than 41.

But in the sample output, it's [27,41,12], which sums to 80 <81,82,84.

So, it's a different solution, but still valid.

So, perhaps there are multiple solutions, and this is one of them.

But for n=5, k=[5,5,5,5,5], sum_{i=1 to 5} 1/5 =1, which is not less than 1, so sum=1 >=1, hence no solution, and the sample output is -1.

This seems consistent.

In the fourth test case, n=6, k=[7,9,3,17,9,13], sum_{i=1 to 6} 1/k_i = 1/7 +1/9 +1/3 +1/17 +1/9 +1/13.

Let's calculate this:

1/7 ≈0.1429

1/9≈0.1111

1/3≈0.3333

1/17≈0.0588

1/9≈0.1111

1/13≈0.0769

Sum ≈0.1429+0.1111+0.3333+0.0588+0.1111+0.0769≈0.8341 <1

So, sum <1, hence a solution exists, and the sample output is [1989,1547,4641,819,1547,1071], which sums to 10574.

And k_j * x_j are:

7*1989=13923

9*1547=13923

3*4641=13923

17*819=13923

9*1547=13923

13*1071=13923

All of which are greater than 10574.

So, it works.

In the fifth test case, n=3, k=[6,3,2], sum_{i=1 to 3} 1/6 +1/3 +1/2 =1/6 +2/6 +3/6 =6/6=1, which is not less than 1, so no solution, hence -1.

In the sixth test case, n=5, k=[9,4,6,8,3], sum_{i=1 to 5} 1/9 +1/4 +1/6 +1/8 +1/3 = (8+18+12+9+24)/72 =71/72 <1, so a solution exists, and the sample output is [8,18,12,9,24], which sums to 71 <72,8,72,72,72 for respective k_j * x_j.

Wait, let's check:

k_j * x_j:

9*8=72

4*18=72

6*12=72

8*9=72

3*24=72

All are 72, which is greater than 71.

So, it works.

Hence, the initial approach seems to work when sum_{i=1 to n} 1/k_i <1.

But in cases where sum_{i=1 to n} 1/k_i >=1, there is no solution, as per the sample inputs.

So, perhaps the program is implementing this approach.

Let me look at the given program.

The program reads t, the number of test cases.

Then, for each test case, it reads n, then reads the list of k_i.

Then, it computes prod = product of all k_i.

Then, vprod = [prod // r for r in vals], which is x_j = P / k_j for each j.

Then, den = prod - sum(vprod)

If den <=0, it prints -1.

Else, it prints vprod.

Wait, let's see.

In the first test case:

n=3, k=[3,2,7]

prod=3*2*7=42

vprod=[42//3=14, 42//2=21, 42//7=6]

sum(vprod)=14+21+6=41

den=42-41=1, which is >0, so it prints [14,21,6]

But in the sample output, it's [27,41,12], which sums to 80.

So, different solution, but both are valid.

So, the program's solution is also correct.

In the second test case:

n=2, k=[3,3]

prod=3*3=9

vprod=[9//3=3, 9//3=3]

sum(vprod)=3+3=6

den=9-6=3>0, so prints [3,3]

But in the sample output, it's [1,1], which sums to 2 <3,9 for k_j * x_j.

Both are valid.

In the third test case:

n=5, k=[5,5,5,5,5]

prod=5^5=3125

vprod=[3125//5=625, 625, 625, 625, 625]

sum(vprod)=625*5=3125

den=3125-3125=0 <=0, so prints -1

Which matches the sample output.

In the fourth test case:

n=6, k=[7,9,3,17,9,13]

prod=7*9*3*17*9*13= unknown, but the program computes vprod as prod//k_j for each j.

Then den=prod - sum(vprod)

If den>0, prints vprod.

In the sample output, it's [1989,1547,4641,819,1547,1071], which sums to 10574 < P.

So, it works.

In the fifth test case:

n=3, k=[6,3,2]

prod=6*3*2=36

vprod=[36//6=6, 36//3=12, 36//2=18]

sum(vprod)=6+12+18=36

den=36-36=0 <=0, so prints -1

Which matches the sample output.

In the sixth test case:

n=5, k=[9,4,6,8,3]

prod=9*4*6*8*3= unknown, but sum(vprod)=prod - den

If den>0, prints vprod.

In the sample output, it's [8,18,12,9,24], which sums to 71 < P.

So, it works.

Hence, the program seems to be implementing the approach where x_j = P / k_j, and checks if sum(x_j) < P.

Which is equivalent to sum(1/k_j) <1.

If sum(1/k_j) >=1, then sum(x_j) >=P, and den<=0, so it prints -1.

Otherwise, it prints x_j = P / k_j.

This seems correct, and matches the sample outputs.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]