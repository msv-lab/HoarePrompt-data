Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The sum of all the water in these containers is divisible by n, which means if I divide the total water by n, there's no remainder. The goal is to determine whether it's possible to make the amount of water in all containers the same by performing a specific operation any number of times.

The operation allowed is pouring any amount of water from container i to container j, but only if i is less than j. So, I can only pour water from a left container to a right container. I can't pour water from a right container to a left one. Also, any container can be chosen as i or j multiple times, as long as i < j.

First, since the sum of a_i is divisible by n, the target amount of water in each container should be sum(a_i) / n. Let's call this target value 'mean'. So, my goal is to make each a_i equal to mean.

Given that I can only pour water from a left container to a right one, I need to find a way to balance the water levels in all containers by only moving water from left to right.

Let me think about this. If I imagine the containers in order from 1 to n, and I can only pour water from left to right, it seems like the water can only move in one direction.

So, for each container, the amount of water it has can only increase by receiving water from the containers to its left, but it can't receive water from containers to its right.

Wait, actually, no. Because the operation is only to pour from i to j where i < j. So, a container j can receive water from any container i to its left (i < j), but it cannot pour water back to any container on its left. So, once water passes a container, it can't go back.

Given that, perhaps I can think of the process as accumulating deficits or surpluses as I move from left to right.

Let me consider the cumulative sum of water deficits or surpluses as I go from left to right.

Let's define the deficit or surplus of a container as a_i - mean. If a_i > mean, it has a surplus; if a_i < mean, it has a deficit.

Now, starting from the leftmost container, if it has a surplus, I can pour that surplus to the right containers. If it has a deficit, I need to have enough surplus from the left to fill it, but since there's no container to the left of the first one, it must have at least mean water or more to cover its deficit from nowhere, which isn't possible. Wait, but the first container can't have a deficit because there's no container to its left to pour water into it. So, perhaps the first container must have at least mean water.

Wait, no. Actually, the first container can have less than mean, but then I would need to pour water from the containers to its right back to it, but that's not allowed because the operation only allows pouring from left to right.

Wait, but if I can only pour from left to right, then the first container can't receive water from any other container. So, if the first container has less than mean, it's impossible to make it have mean water because I can't pour water into it from elsewhere.

Similarly, the second container can only receive water from the first container, and so on.

So, perhaps the condition is that each prefix of containers from 1 to k (for each k from 1 to n) must have a sum of water at least k * mean.

Wait, let's think about it.

Suppose I look at the first container. To have at least mean water, the first container must have at least mean water, because it can't receive water from anywhere.

Wait, but in the example given, in the third test case, n=5, a=[4,5,2,1,3], sum is 15, mean is 3.

Looking at the first container: 4 >= 3, which is fine.

Looking at the first two containers: 4+5=9 >= 6 (which is 2*3), which is fine.

First three containers: 4+5+2=11 >= 9, which is fine.

First four containers: 4+5+2+1=12 >= 12, which is fine.

First five containers: 15 >= 15, which is fine.

In this case, it's possible to balance the water as shown in the example.

In the second test case, n=2, a=[1,3], sum=4, mean=2.

First container: 1 < 2, which is a problem because it can't receive water from anywhere.

Wait, but according to the output, it's "NO", which matches our earlier thought.

In the first test case, n=1, a=[43], which is trivially "YES" since there's only one container.

In the fourth test case, n=3, a=[1,2,3], sum=6, mean=2.

First container: 1 < 2, which is a problem, so "NO", which matches the output.

In the fifth test case, n=7, a=[4,5,5,0,6,4,4], sum=28, mean=4.

Looking at prefixes:

- a1=4 >=4

- a1+a2=9 >=8

- a1+a2+a3=14 >=12

- a1+a2+a3+a4=14 >=16 â†’ 14 < 16, which is not satisfied, so "NO"

In the sixth test case, n=7, a=[6,5,5,1,3,4,4], sum=28, mean=4.

Checking prefixes:

- a1=6 >=4

- a1+a2=11 >=8

- a1+a2+a3=16 >=12

- a1+a2+a3+a4=17 >=16

- a1+a2+a3+a4+a5=20 >=20

- a1+a2+a3+a4+a5+a6=24 >=24

- a1+a2+a3+a4+a5+a6+a7=28 >=28

All prefixes satisfy the condition, so it's "YES".

This seems to be a consistent way to determine if it's possible to balance the water levels: for every prefix from 1 to k, the sum of the first k containers should be at least k*mean.

This makes sense because, to distribute the water evenly up to any point k, the total water in the first k containers must be at least what's needed to make each of them have mean amount of water.

If at any point the sum of the first k containers is less than k*mean, it means there's not enough water in the left containers to fill up to mean, even if we pour all the surplus from the left to the right.

Moreover, since we can only pour from left to right, we can't compensate for a deficit in the left containers by using surplus from the right containers because pouring is only allowed from left to right.

Therefore, the condition is that for all k from 1 to n, sum(a[1..k]) >= k*mean.

If this condition holds for all k, then it's possible to make all containers have the mean amount of water.

Otherwise, it's not possible.

Now, looking at the given program:

t = int(input())

for _ in range(t):

n = int(input())

nums = list(map(int, input().strip().split()))

print(func_1(nums))

def func_1(nums):

n = len(nums)

total = sum(nums)

if total % n != 0:

return 'NO'

mean = total // n

curr = 0

for i in range(n):

curr += nums[i] - mean

if curr < 0:

return 'NO'

return 'YES'

First, it reads the number of test cases t.

For each test case, it reads n and then the list of a_i.

Then it calls func_1(nums) and prints the result.

In func_1:

- It calculates the total sum and checks if it's divisible by n. If not, it returns 'NO', which matches the problem statement since the sum is guaranteed to be divisible by n.

- It calculates the mean as total // n.

- It initializes curr to 0.

- It iterates through each container, adding nums[i] - mean to curr.

- If curr ever becomes negative, it returns 'NO'.

- If it goes through all containers without curr becoming negative, it returns 'YES'.

Now, let's see if this implementation correctly checks the prefix sums condition we discussed.

Recall that we need to check for each k from 1 to n: sum(a[1..k]) >= k*mean.

Let's see what curr represents.

curr starts at 0.

For each i from 0 to n-1:

curr += nums[i] - mean

So, after processing the first k containers, curr equals sum(nums[0..k-1]) - k*mean.

We need sum(nums[0..k-1]) >= k*mean, which is equivalent to sum(nums[0..k-1]) - k*mean >= 0, meaning curr >= 0.

Therefore, the condition curr >= 0 after each addition corresponds to sum(a[1..k]) >= k*mean.

If curr ever becomes negative, it means sum(a[1..k]) < k*mean for some k, which violates the condition, so it should return 'NO'.

If curr remains non-negative for all k, it means sum(a[1..k]) >= k*mean for all k, so it's possible, and it returns 'YES'.

This matches exactly with the condition we derived.

Therefore, this implementation is correct.

Hence, Correctness: **True**