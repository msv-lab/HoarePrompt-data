Alright, I have this problem to solve. It involves a game between Alice and Bob where they take turns making moves on an array, and the goal is to determine the final MEX of a subset created by Alice, assuming both play optimally.

First, I need to understand what MEX is. MEX stands for Minimum EXcludant, which is the smallest non-negative integer not present in a given set. For example, for the set [0, 1, 3], the MEX is 2 because 0, 1 are present, but 2 is missing.

Now, the game setup:

- There's an array 'a' of size n.

- Alice starts with an empty array 'c'.

- Players take turns: Alice goes first.

- On Alice's turn: She picks an element from 'a', appends it to 'c', and deletes it from 'a'.

- On Bob's turn: He picks an element from 'a', and deletes it from 'a'.

- The game ends when 'a' is empty.

- The score is the MEX of 'c', and Alice wants to maximize it, while Bob wants to minimize it.

I need to find the final score when both play optimally.

Alright, so this seems like a game theory problem where both players are trying to optimize the MEX in opposite directions.

First, I should think about how Alice can maximize the MEX and how Bob can minimize it.

Let me consider some examples to get a better understanding.

Example 1:

Input:

3

4

0 0 1 1

Output:

2

Explanation:

A possible game:

- Alice picks 1 → a=[0,0,1], c=[1]

- Bob picks 0 → a=[0,1], c=[1]

- Alice picks 0 → a=[1], c=[1,0]

- Bob picks 1 → a=[], c=[1,0]

MEX of [1,0] is 2.

But is this the optimal outcome?

Wait, Alice wants to maximize MEX, which means she wants to have as many small integers in 'c' as possible, up to the point where some integer is missing.

Bob, on the other hand, wants to minimize MEX, meaning he wants to prevent Alice from having small integers in 'c'.

So, in this game, Alice is trying to collect numbers to cover as many small integers as possible, and Bob is trying to disrupt that.

Let me think differently.

Since Alice can choose any element to add to 'c', and Bob can choose any element to remove from 'a', Bob can interfere with Alice's strategy by removing elements that Alice might need.

But, since Alice goes first, she has the initial advantage of selecting elements.

I need to find a way to determine the highest possible MEX that Alice can achieve, considering Bob's opposition.

Maybe I should consider the frequency of each number in the array.

Let's think about the frequency of each number.

Suppose we have counts of each number from 0 to n-1.

Alice wants to have as many numbers as possible in 'c', starting from 0, to maximize MEX.

Bob wants to prevent that by possibly removing numbers that Alice needs.

But Bob can only remove one number per turn, and Alice can choose which number to add to 'c'.

Wait, Alice not only picks a number to add to 'c' but also removes it from 'a', and Bob just removes a number from 'a'.

So, the sequence of moves affects which numbers are available at each step.

This seems complicated to track manually for larger n.

I need a better approach.

Let me consider the total number of moves.

There are n moves in total, alternating between Alice and Bob, with Alice starting.

So, if n is even, Alice makes n/2 moves, and Bob makes n/2 moves.

If n is odd, Alice makes (n+1)/2 moves, and Bob makes (n-1)/2 moves.

Wait, no. Since Alice starts and they alternate, if n is even, Alice and Bob each make n/2 moves.

If n is odd, Alice makes (n+1)/2 moves, Bob makes (n-1)/2 moves.

Wait, no. In total, there are n moves.

If n is even, Alice and Bob each make n/2 moves.

If n is odd, Alice makes ceil(n/2) moves, Bob makes floor(n/2) moves.

Yes.

Now, the goal is to determine the MEX of the set 'c' that Alice builds.

Alice wants to maximize MEX, which means she wants 'c' to have as many small integers as possible.

Bob wants to minimize MEX, meaning he wants to disrupt Alice's ability to collect small integers.

So, in essence, it's a game where Alice tries to collect numbers to cover as many small integers as possible, and Bob tries to prevent that.

I need to find the MEX of 'c' when both play optimally.

Let me consider that MEX is the smallest missing integer in 'c'.

So, to maximize MEX, Alice wants to have as many consecutive integers starting from 0 in 'c' as possible.

Bob wants to minimize MEX, meaning he wants to ensure that some small integer is missing in 'c'.

Given that, perhaps I can model this as a game where Alice and Bob are competing over which numbers to include or exclude from 'c'.

But it's tricky because Alice can choose which numbers to add to 'c', and Bob can remove any number from 'a'.

I need to find a way to determine which numbers Alice can secure in 'c' despite Bob's attempts to interfere.

Let me consider the frequency of each number.

Suppose I have counts of each number from 0 to n-1.

For each number k, if Alice needs to include k in 'c' to achieve a certain MEX, Bob might try to prevent that by removing k from 'a' before Alice can pick it.

But Alice goes first, and she can strategicly choose which numbers to pick.

Wait, perhaps I can think in terms of the number of times each number appears and how many times Alice can pick them before Bob can interfere.

Wait, maybe I should think in terms of the minimal excludant based on the frequencies.

Let me try to think of a strategy.

Suppose I sort the array in non-decreasing order.

Then, I can iterate through the sorted array and keep track of how many times each number is available, and decide whether Alice can secure it.

But I need to consider the turns and who picks what.

This seems too vague.

Let me consider a simpler case.

Suppose the array contains only 0s and 1s.

For example:

n = 3

a = [0, 0, 1]

Possible game:

- Alice picks 1 → a=[0,0], c=[1]

- Bob picks 0 → a=[0], c=[1]

- Alice picks 0 → a=[], c=[1,0]

MEX is 2.

Alternatively:

- Alice picks 0 → a=[0,1], c=[0]

- Bob picks 1 → a=[0], c=[0]

- Alice picks 0 → a=[], c=[0,0]

MEX is 1.

So, in this case, Alice can achieve a MEX of 2 in one scenario and 1 in another.

Since Alice wants to maximize MEX, she would choose the first scenario, achieving MEX 2.

But Bob can try to force a lower MEX.

Wait, in the second scenario, Bob picked 1, which might have been better for him because it prevents Alice from having 1 in 'c'.

But Alice still ends up with [0,0], which has MEX 1.

In the first scenario, Alice gets [1,0], which has MEX 2.

So, Bob prefers the second outcome.

Thus, in this case, the optimal play leads to MEX 2.

Another example:

n = 2

a = [1,1]

Possible game:

- Alice picks 1 → a=[1], c=[1]

- Bob picks 1 → a=[], c=[1]

MEX is 0, since 0 is missing in 'c'.

Alternatively:

- Alice picks 1 → a=[1], c=[1]

- Bob picks 1 → a=[], c=[1]

Same result.

So, MEX is 0.

Another example:

n = 4

a = [0,1,2,3]

Possible game:

- Alice picks 0 → a=[1,2,3], c=[0]

- Bob picks 1 → a=[2,3], c=[0]

- Alice picks 2 → a=[3], c=[0,2]

- Bob picks 3 → a=[], c=[0,2]

MEX is 1, since 1 is missing.

Alternatively:

- Alice picks 1 → a=[0,2,3], c=[1]

- Bob picks 0 → a=[2,3], c=[1]

- Alice picks 2 → a=[3], c=[1,2]

- Bob picks 3 → a=[], c=[1,2]

MEX is 0.

Alice wants to maximize MEX, so she would choose the first scenario where MEX is 1.

Bob wants to minimize MEX, so he would prefer the second scenario where MEX is 0.

But in the first scenario, Alice achieves MEX 1, and in the second, MEX 0.

So, the optimal play would lead to MEX 1.

Wait, but in the first scenario, Alice picks 0, and in the second, she picks 1.

So, perhaps by picking 0, Alice can achieve a higher MEX.

But in the first scenario, after picking 0, Bob picks 1, and then Alice picks 2, and Bob picks 3, leading to c=[0,2], MEX=1.

In the second scenario, Alice picks 1, Bob picks 0, Alice picks 2, Bob picks 3, leading to c=[1,2], MEX=0.

So, Alice prefers the first scenario.

Therefore, the optimal play leads to MEX 1.

But according to the problem's example, for n=4 and a=[0,0,1,1], the output is 2.

Wait, in that case, as shown in the note, Alice can achieve MEX 2.

But is that the optimal outcome?

In that example, Alice picks 1, Bob picks 0, Alice picks 0, Bob picks 1, leading to c=[1,0], MEX=2.

Alternatively, if Alice picks 0 first, Bob picks 1, Alice picks 1, Bob picks 0, leading to c=[0,1], MEX=2.

So, in both cases, MEX is 2.

Wait, but in the previous example with n=4 and a=[0,1,2,3], MEX is 1.

So, it seems that the MEX depends on the composition of the array.

I need a general strategy.

Let me think in terms of the frequency of each number.

Suppose I count how many times each number appears in the array.

Let's define count[k] as the number of times k appears in a.

Alice wants to include as many small k as possible in 'c', and Bob wants to prevent that.

Each time Alice picks a number, she adds it to 'c' and removes it from a.

Each time Bob picks a number, he removes it from a.

So, Bob can remove numbers that Alice needs.

I need to model this interaction.

Perhaps I can think in terms of the number of times Alice can pick a number before Bob can remove it.

Wait, maybe in terms of the number of available picks for Alice for each number.

Let me try to formalize this.

Let’s denote the number of times Alice can pick a particular number k as A[k], and the number of times Bob can remove it as B[k].

But it's not that straightforward because Bob can remove any number, not necessarily the one Alice wants.

Wait, perhaps I should think in terms of the total number of moves Alice can make and how she can allocate those moves to different numbers.

Given that, perhaps I can calculate for each k, the minimum number of times Alice needs to pick k to include it in 'c' enough times to consider it present.

But it's confusing.

Let me look for a different approach.

I recall that in some game theory problems, especially those involving optimization by two players, we can model it as a minimax or maximin problem.

In this case, Alice tries to maximize the MEX, and Bob tries to minimize it.

So, the final MEX would be the result of both playing optimally.

Perhaps I can think of it as finding the smallest k such that Alice cannot guarantee that k is in 'c'.

Wait, that might be a way.

Let me consider that.

For each k, starting from 0 upwards, I need to determine if Alice can ensure that k is in 'c' enough times.

If Alice can ensure that k is in 'c', then MEX cannot be k.

If there exists some k that Alice cannot ensure is in 'c', then that k is the MEX.

So, I need to find the smallest k for which Alice cannot guarantee that k is in 'c'.

To do that, I need to analyze for each k, given the number of times k appears in a, and the total moves available to Alice and Bob, whether Alice can secure at least one instance of k in 'c'.

Wait, but MEX is about the smallest missing integer, so even if k appears multiple times, as long as at least one is in 'c', k is considered present.

Wait, no, MEX is about the smallest integer not present in 'c', regardless of multiples.

So, for MEX to be greater than k, k must be present in 'c' at least once.

If k is not present in 'c', then MEX is at most k.

So, to maximize MEX, Alice needs to include as many k's in 'c' as possible, starting from k=0.

Bob, on the other hand, wants to prevent Alice from including certain k's.

So, for each k, starting from 0, Alice needs to secure at least one instance of k in 'c'.

Bob will try to prevent that.

I need to determine up to which k Alice can secure having at least one in 'c'.

Beyond that, Bob can ensure that Alice doesn't have that k in 'c', making that k the MEX.

So, for each k, from 0 upwards, I need to check if Alice can guarantee that at least one k is in 'c'.

If she can, then MEX is greater than k.

If she cannot, then MEX is k.

Now, how do I determine if Alice can guarantee that at least one k is in 'c'?

I need to consider the number of times k appears in a, and the number of moves Alice and Bob can make.

Let’s denote:

- count[k]: number of times k appears in a.

- total moves: n.

- Alice's moves: ceil(n/2).

- Bob's moves: floor(n/2).

Wait, more precisely:

- If n is even: Alice makes n/2 moves, Bob makes n/2 moves.

- If n is odd: Alice makes (n+1)/2 moves, Bob makes (n-1)/2 moves.

But it's getting complicated.

Let me think differently.

Suppose I sort the array in non-decreasing order.

Then, I can iterate through the sorted array and keep track of the smallest k that Alice can include in 'c'.

Wait, perhaps I can iterate through k from 0 upwards and check if Alice can secure k in 'c'.

For each k, the number of times k appears in a is count[k].

Alice needs to pick at least one k to include in 'c'.

But Bob can try to remove k's before Alice can pick them.

So, for Alice to secure at least one k in 'c', she needs to pick it before Bob can remove all instances of k.

Given that, if count[k] > 0, and Alice can pick it before Bob removes all count[k] instances, then she can include k in 'c'.

But Bob can remove k's as well.

Wait, perhaps I can think in terms of the number of times Alice can pick k before Bob removes all of them.

If count[k] > floor((number of moves)/2), then Alice can pick at least one k.

Wait, perhaps more precisely, if count[k] > floor((total moves)/2), then Alice can pick at least one k.

But I need to think more carefully.

Let’s consider that for each k, the number of times it appears is count[k].

Alice and Bob will make moves alternately, with Alice starting.

Each time Alice picks a k, she includes it in 'c' and removes it from a.

Each time Bob picks a k, he removes it from a.

So, for a particular k, the number of times it can be picked by Alice is ceil(count[k]/2), because for every two instances, Alice can pick one, and Bob can pick one, given that Alice starts.

Wait, but it's not exactly that because the picking is interleaved with other numbers as well.

Wait, perhaps I need to think in terms of the total number of moves available to Alice and Bob.

This is getting too vague.

Let me look for a different approach.

I recall that in some game theory problems, especially those involving selecting elements from a set with two players having opposing goals, we can model it using the concept of "necessary and sufficient" moves.

In this case, for Alice to include a particular k in 'c', she needs to pick at least one k before all k's are removed by Bob.

So, for each k, the number of times k appears is count[k].

Alice and Bob will make moves alternately, with Alice starting.

Each time a player picks a k, it's removed from a.

Alice wants to pick k and include it in 'c', while Bob wants to prevent that by removing k.

So, for a particular k, the number of times Alice can pick k is ceil(count[k]/2), because she starts first.

Wait, if count[k] is odd, Alice can pick one more than Bob.

If count[k] is even, they can pick equally.

But Alice starts, so for count[k] = 1, Alice can pick it.

For count[k] = 2, Alice picks one, Bob picks one.

For count[k] = 3, Alice picks two, Bob picks one.

Wait, no.

Actually, for count[k] = 1, Alice can pick it on her first move.

For count[k] = 2, Alice picks one, Bob picks one.

For count[k] = 3, Alice picks one, Bob picks one, Alice picks the last one.

So, Alice can pick ceil(count[k]/2) instances of k.

Wait, yes.

In general, Alice can pick ceil(count[k]/2) instances of k.

Because she starts first.

So, for each k, Alice can secure ceil(count[k]/2) instances in 'c'.

Now, since MEX is about whether k is present at least once in 'c', we can say that for each k, if ceil(count[k]/2) >=1, then k is in 'c', else not.

Wait, but ceil(count[k]/2) >=1 means count[k] >=1.

But that can't be right because Bob can interfere.

Wait, no.

Wait, ceil(count[k]/2) is the number of times Alice can pick k.

But MEX only cares about whether k is in 'c' at least once.

So, for k to be in 'c', Alice needs to pick at least one instance of k.

Given that, if count[k] is odd, Alice can pick the last one.

If count[k] is even, Alice can pick half of them (rounded up).

Wait, no.

Wait, for count[k] = even, Alice can pick half of them.

For count[k] = odd, she can pick half +1 of them.

Wait, more precisely, Alice can pick ceil(count[k]/2) instances of k.

But since MEX only requires at least one instance of k in 'c', Alice can pick one instance of k if count[k] >=1, unless Bob can prevent it.

But in reality, since Alice starts, and she can choose to pick k, she can ensure that she picks k before Bob can remove all instances of k.

Wait, but if count[k] =1, Alice can pick it on her first move.

If count[k] =2, Alice picks one, Bob picks one.

So, k is in 'c' once.

If count[k] >=1, Alice can ensure that at least one k is in 'c', because she can pick it before Bob can remove all instances.

Wait, but in count[k]=2, Alice picks one, Bob picks one, so 'c' has one k.

In count[k]=3, Alice picks one, Bob picks one, Alice picks the last one, 'c' has two k's.

So, in all cases where count[k]>=1, Alice can ensure that at least one k is in 'c'.

Therefore, the MEX should be the smallest k where count[k]=0.

Wait, but that can't be right because in the example given, n=4, a=[0,0,1,1], the output is 2, but according to this, count[0]=2, count[1]=2, count[2]=0, so MEX should be 2, which matches.

In the second example, n=4, a=[0,1,2,3], output is 1.

count[0]=1, count[1]=1, count[2]=1, count[3]=1.

According to this, Alice can pick one of each, so MEX should be 4, but the output is 1.

Wait, that doesn't match.

So, my previous assumption is incorrect.

There must be something wrong with this approach.

Let me think again.

In the second example, n=4, a=[0,1,2,3].

According to my previous logic, count[0]=1, count[1]=1, count[2]=1, count[3]=1.

Alice can pick one of each, so 'c' would have [0,1,2,3], MEX=4.

But the output is 1, which contradicts this.

Wait, perhaps I'm misunderstanding the game dynamics.

Let me look back at the game description.

Alice starts, picks an element, appends it to 'c', and deletes it from 'a'.

Bob then picks an element from 'a' and deletes it.

They alternate until 'a' is empty.

The MEX is of 'c' at the end.

Alice wants to maximize MEX, Bob wants to minimize it.

In the second example, n=4, a=[0,1,2,3].

Possible game:

- Alice picks 0 → a=[1,2,3], c=[0]

- Bob picks 1 → a=[2,3], c=[0]

- Alice picks 2 → a=[3], c=[0,2]

- Bob picks 3 → a=[], c=[0,2]

MEX is 1, since 1 is missing in 'c'.

Another possible game:

- Alice picks 1 → a=[0,2,3], c=[1]

- Bob picks 0 → a=[2,3], c=[1]

- Alice picks 2 → a=[3], c=[1,2]

- Bob picks 3 → a=[], c=[1,2]

MEX is 0, since 0 is missing in 'c'.

Alice wants to maximize MEX, so she would choose the first scenario where MEX is 1.

Bob wants to minimize MEX, so he would prefer the second scenario where MEX is 0.

But according to the problem, the output is 1, which is the MEX from the first scenario.

Wait, but according to the problem, both play optimally.

So, perhaps the optimal play leads to MEX=1.

But according to my earlier assumption, if count[k]>=1, Alice can ensure k is in 'c', so MEX should be the smallest k where count[k]=0.

But in this case, count[k]=1 for k=0,1,2,3, so MEX should be 4, but the output is 1.

So, my assumption is wrong.

There must be something wrong with assuming that Alice can always include k in 'c' if count[k]>=1.

Wait, perhaps Bob can prevent Alice from including certain k's by removing them strategically.

In the second example, Bob can choose to remove k's that Alice needs to achieve a higher MEX.

So, perhaps in some cases, even if count[k]>=1, Bob can prevent Alice from including k in 'c'.

How?

Let me consider the second example again.

n=4, a=[0,1,2,3].

Possible game:

- Alice picks 0 → a=[1,2,3], c=[0]

- Bob picks 1 → a=[2,3], c=[0]

- Alice picks 2 → a=[3], c=[0,2]

- Bob picks 3 → a=[], c=[0,2]

MEX is 1.

Another possible game:

- Alice picks 1 → a=[0,2,3], c=[1]

- Bob picks 0 → a=[2,3], c=[1]

- Alice picks 2 → a=[3], c=[1,2]

- Bob picks 3 → a=[], c=[1,2]

MEX is 0.

So, in both scenarios, MEX is either 1 or 0.

Alice prefers 1, Bob prefers 0.

So, in this case, it seems that Alice can achieve MEX=1, which is the output.

But according to my earlier assumption, since all k from 0 to 3 appear at least once, Alice should be able to include all of them in 'c', leading to MEX=4.

But that's not happening.

So, what's wrong with that assumption?

Wait, perhaps Alice cannot include all k's in 'c' because Bob can remove some of them.

In the first scenario, Alice includes 0 and 2, but not 1 and 3.

In the second scenario, she includes 1 and 2, but not 0 and 3.

So, it's not guaranteed that Alice can include all k's, even if they appear at least once.

Wait, but in the first example, n=4, a=[0,0,1,1], output is 2.

count[0]=2, count[1]=2, count[2]=0, count[3]=0.

According to my earlier assumption, Alice can include 0 and 1 in 'c', but not 2 and 3, leading to MEX=2, which matches the output.

So, perhaps the assumption holds when there are multiple instances of some k's.

But in the second example, with only one of each, Alice cannot include all of them.

So, perhaps Alice can include k in 'c' only if count[k] > floor((number of moves)/2).

Wait, let's see.

In the second example, n=4, count[k]=1 for k=0,1,2,3.

Alice makes 2 moves (ceil(4/2)=2), Bob makes 2 moves.

Alice can pick 2 different k's, and Bob can remove 2 different k's.

So, in total, 4 different k's are removed or included.

But since Alice includes the ones she picks, 'c' will have 2 elements.

So, MEX would be the smallest k not in 'c'.

In this case, since 'c' has any 2 out of