Alright, I have this problem to solve. Let's see what it's asking for. So, Petya has an array of n integers, and Vasya wants to create his own array of n integers from a given list of m integers, where m is at least n. Vasya wants to choose and arrange m integers to maximize the total difference D, which is the sum of the absolute differences between corresponding elements of his array c and Petya's array a.

So, the goal is to maximize D = sum of |a_i - c_i| for i from 1 to n.

First, I need to understand the inputs and what constraints there are. Each test case starts with two integers n and m, where n is the size of array a and m is the size of array b from which we choose n integers to form c. Then, there's array a of n integers and array b of m integers.

I need to select n integers from b and arrange them in some order to form c, such that the sum of absolute differences with a is maximized.

Hmm, so to maximize the difference, for each a_i, I want to choose a c_i that is as far away from a_i as possible. Since I can arrange c in any order, I need to pair each a_i with a c_j in a way that maximizes the sum of differences.

This sounds like a problem where I need to pair each a_i with a c_j such that the sum of |a_i - c_j| is maximized.

First thoughts: If I sort a in one order and c in the opposite order and pair them accordingly, that might maximize the sum of differences.

Wait, actually, in assignment problems, to maximize the sum of differences, you pair the largest a with the smallest c, and so on.

Let me think about that. If I have a sorted in ascending order and c sorted in descending order, then |a_i - c_i| would be maximized for each i.

Is that correct? Let's take an example.

Suppose a = [1, 2, 3], c = [6, 5, 4]. If I pair 1 with 4, 2 with 5, and 3 with 6, then the differences are |1-4|=3, |2-5|=3, |3-6|=3, sum is 9.

If I pair 1 with 6, 2 with 4, and 3 with 5, then differences are |1-6|=5, |2-4|=2, |3-5|=2, sum is 9.

So, in this case, both pairings give the same sum.

Another example: a = [1, 2, 3], c = [3, 2, 1]. Pairing ascending a with descending c: 1 with 3, 2 with 2, 3 with 1, differences are 2, 0, 2, sum 4.

Alternatively, pairing ascending a with ascending c: 1 with 1, 2 with 2, 3 with 3, differences are 0, 0, 0, sum 0.

So, in this case, pairing ascending with descending gives a higher sum.

Wait, but in the first example, both pairings gave the same sum.

Hmm, maybe pairing ascending a with descending c is the way to go.

Let me think about why this works.

The idea is that for each a_i, you want to pair it with the c_j that is as far away as possible.

If a is sorted ascending and c is sorted descending, then each a_i is paired with a c_j that is farthest possible from it.

In the first example, a = [1,2,3], c descending = [3,2,1], pairing 1 with 3, 2 with 2, 3 with 1, differences are |1-3|=2, |2-2|=0, |3-1|=2, sum is 4.

But in another pairing, like 1 with 1, 2 with 3, 3 with 2, differences are |1-1|=0, |2-3|=1, |3-2|=1, sum is 2, which is less than 4.

So, pairing ascending a with descending c seems better.

Wait, but in the first example, pairing ascending a with descending c gave sum 4, while another pairing gave sum 2, so 4 is better.

But in the earlier example, both pairings gave sum 9.

Wait, perhaps pairing ascending a with descending c maximizes the sum.

Let me check another example.

a = [1,3], c = [2,4].

Pairing ascending a with descending c: 1 with 4, 3 with 2, differences |1-4|=3, |3-2|=1, sum 4.

Alternative pairing: 1 with 2, 3 with 4, differences |1-2|=1, |3-4|=1, sum 2.

So, pairing ascending a with descending c gives a higher sum.

Another example: a = [1,2,3,4], c = [1,2,3,4].

Pairing ascending a with descending c: 1 with 4, 2 with 3, 3 with 2, 4 with 1, differences |1-4|=3, |2-3|=1, |3-2|=1, |4-1|=3, sum 8.

Alternative pairing: 1 with 1, 2 with 2, 3 with 3, 4 with 4, differences all 0, sum 0.

So, clearly pairing ascending a with descending c is better.

Another example: a = [1,3], c = [1,3].

Pairing ascending a with descending c: 1 with 3, 3 with 1, differences |1-3|=2, |3-1|=2, sum 4.

Alternative pairing: 1 with 1, 3 with 3, differences 0 + 0 = 0.

So, again, pairing ascending a with descending c is better.

One more example: a = [1,2,3], c = [1,2,3].

Pairing ascending a with descending c: 1 with 3, 2 with 2, 3 with 1, differences |1-3|=2, |2-2|=0, |3-1|=2, sum 4.

Alternative pairing: 1 with 1, 2 with 3, 3 with 2, differences |1-1|=0, |2-3|=1, |3-2|=1, sum 2.

Again, pairing ascending a with descending c is better.

So, it seems that sorting a in ascending order and c in descending order and pairing them accordingly maximizes the sum of differences.

Therefore, to solve the problem, I should:

1. Sort array a in ascending order.

2. Sort array c in descending order.

3. Pair each a_i with c_i and calculate |a_i - c_i|.

4. Sum up all these differences to get the maximum D.

Wait, but in the problem, m can be greater than n, and I need to choose only n integers from m to form c.

So, I need to select n integers from b (which is c in the problem statement) and arrange them in a certain order to maximize D.

So, I need to choose n integers from b, sort a in ascending order, sort the chosen c in descending order, and pair them to maximize D.

But how do I choose which n integers from b to use?

Intuitively, to maximize the differences, I should choose the integers from b that are as far away as possible from the corresponding a_i.

Given that I can arrange c in any order, perhaps I should select the n largest and smallest values from b to maximize the spread.

Wait, but I need to pair them with a in a way that maximizes the differences.

Let me think differently.

Suppose I sort a in ascending order.

Then, to maximize the differences, for each a_i, I should choose a c_j that is as far away from a_i as possible.

Given that I can arrange c in any order, I should choose c_j's that are either much larger or much smaller than a_i.

But since I can arrange c in any order, perhaps I should sort c in descending order and pair the smallest a with the largest c, the largest a with the smallest c, and so on.

Wait, that's what I did in the earlier examples, and it seemed to work.

But let's think about it more formally.

Suppose a is sorted in ascending order: a1 <= a2 <= ... <= an.

And c is sorted in descending order: c1 >= c2 >= ... >= cn.

Then, pairing a1 with c1, a2 with c2, ..., an with cn.

The difference for each pair is |ai - ci|.

Since a1 is the smallest a and ci is the largest c, |a1 - c1| will be large.

Similarly, an is the largest a and cn is the smallest c, so |an - cn| will also be large.

This seems to make sense.

But to confirm, let's think about the total sum.

Is there a way to choose c such that the sum is larger than this?

Suppose I have a = [1,2,3], b = [1,2,3,4,5].

I need to choose n=3 elements from b, which are [3,4,5], sorted descending as [5,4,3].

Pair with a=[1,2,3], differences are |1-5|=4, |2-4|=2, |3-3|=0, sum=6.

Alternatively, choose [1,2,3], sorted descending as [3,2,1], pair with a=[1,2,3], differences are |1-3|=2, |2-2|=0, |3-1|=2, sum=4.

Or choose [2,3,4], sorted descending as [4,3,2], pair with a=[1,2,3], differences are |1-4|=3, |2-3|=1, |3-2|=1, sum=5.

So, choosing [3,4,5] gives sum=6, which is larger than choosing [1,2,3] or [2,3,4].

Another choice: [1,3,5], sorted descending as [5,3,1], pair with a=[1,2,3], differences are |1-5|=4, |2-3|=1, |3-1|=2, sum=7.

Wait, that's higher than 6.

So, in this case, choosing [1,3,5] gives a higher sum than choosing [3,4,5].

Wait, but according to my earlier strategy, I should choose the largest and smallest elements to maximize the differences.

So, perhaps selecting both large and small elements from b is better than just selecting the largest n or the smallest n.

In this case, choosing [1,3,5], sorting descending to [5,3,1], pairing with a=[1,2,3], gives differences 4,1,2, sum=7, which is higher than choosing [3,4,5], which gave sum=6.

So, my earlier assumption that choosing the largest n elements is not always optimal.

Therefore, perhaps I should select the elements from b such that for each a_i, I choose the c_j that is as far away from a_i as possible.

But since I can arrange c in any order, maybe I should select the m elements from b that allow me to maximize the sum of |a_i - c_i| when c is sorted descending.

Wait, but I need to choose n elements from m, not m elements.

Wait, in the problem, m is >= n, and I need to choose n elements from m.

So, I need to select n elements from b, arrange them in descending order, and pair them with a in ascending order to maximize the sum of differences.

But how to choose which n elements from b to select?

I think the optimal strategy is to select the n elements from b that are furthest from a in some way.

Wait, perhaps for each a_i, I should choose the c_j that is either the largest or smallest in b that hasn't been chosen yet.

But that might not be efficient.

Let me think differently.

Suppose I sort a in ascending order and sort b in descending order.

Then, I can choose the first n elements from sorted b to form c.

But as the earlier example showed, that might not be optimal.

Alternatively, maybe I should sort b in such a way that the differences are maximized.

Wait, perhaps I should consider the maximum possible difference for each a_i and select c_j's accordingly.

But this seems complicated.

Let me consider the following approach:

- Sort a in ascending order.

- Sort b in descending order.

- Select the top n elements from sorted b to form c.

- Compute the sum of |a_i - c_i|.

But as the earlier example showed, this might not be optimal.

Alternatively, sort b in ascending order, and select the elements that are either smallest or largest to maximize the differences.

Wait, perhaps a better approach is to sort b in ascending order, and then select the n elements that are furthest from the corresponding a_i.

But I need to pair them in a way that maximizes the sum.

Another idea: For each a_i, find the c_j that maximizes |a_i - c_j|, and sum them up.

But since I have to choose n distinct c_j's, this becomes a matching problem.

This sounds like an assignment problem, where I need to pair each a_i with a c_j to maximize the sum of |a_i - c_j|.

In assignment problems, the Hungarian algorithm can be used, but that's too slow for the constraints (n can be up to 2e5).

So, I need a faster approach.

Given the time constraints, I need an O(n log n) or O(n) solution.

Let me think about sorting.

If I sort a in ascending order and sort b in descending order, and pair a_i with b_i, that might give me the maximum sum.

But as the earlier example showed, sometimes selecting some smaller elements from b along with larger ones gives a higher sum.

Wait, in the earlier example, selecting [1,3,5] from b=[1,2,3,4,5] and sorting descending to [5,3,1], pairing with a=[1,2,3], gives differences 4,1,2, sum=7, which is better than selecting [3,4,5], sorted descending to [5,4,3], pairing with a=[1,2,3], differences 4,2,0, sum=6.

So, selecting both small and large elements from b can give a higher sum.

But how to generalize this?

Perhaps I should select the n elements from b that are furthest from a in some way.

Wait, but a is a list of n elements.

Wait, maybe I should consider for each a_i, choosing the c_j that is furthest from a_i, either the smallest or largest in b.

But I need to choose n distinct c_j's.

This seems tricky.

Let me consider another approach.

Suppose I fix a, sorted in ascending order.

Then, for c, to maximize the sum of |a_i - c_i|, I should arrange c in descending order.

But I need to choose which n elements from b to use.

So, perhaps I should select the n elements from b that maximize the sum of |a_i - c_i| when c is sorted descending.

But I need a way to select those n elements efficiently.

Wait, maybe I can consider the following:

For each a_i, find the c_j that maximizes |a_i - c_j|, but I have to choose n distinct c_j's.

This seems like choosing c_j's that are as far as possible from a_i's.

Perhaps I can select the n elements from b that are either the smallest or largest in b.

Wait, in the earlier example, selecting [1,3,5] gave a better sum than selecting [3,4,5].

So, including both small and large elements from b can give a better sum.

How can I formalize this?

Let me consider that for each a_i, the maximum possible |a_i - c_j| is max(|a_i - min(b)|, |a_i - max(b)|).

So, for each a_i, the best possible c_j would be either the smallest or largest in b.

But since I need to choose n distinct c_j's, I need to select a combination of the smallest and largest elements from b to pair with a_i's.

This seems complicated.

Is there a better way?

Let me think about the overall sum.

I need to maximize sum of |a_i - c_i| for i from 1 to n.

If I sort a in ascending order and sort c in descending order, then pair a_i with c_i, the sum would be sum(|a_i - c_i|).

Is there a way to compute this efficiently?

Wait, but I need to choose which n elements from b to use for c.

So, perhaps I should sort b in descending order and select the top n elements to pair with a.

But as earlier example shows, sometimes selecting some smaller elements gives a better sum.

Wait, maybe I need to select the c_j's such that the sum is maximized.

Let me consider another approach.

Suppose I sort a in ascending order.

Then, sort b in descending order.

Then, for each a_i, I can pair it with c_i.

But as we've seen, sometimes pairing a_i with a c_j that is not c_i gives a better sum.

Wait, but in assignment problems, to maximize the sum of |a_i - c_j|, it's optimal to pair the largest a with the smallest c, and the smallest a with the largest c, assuming a and c are sorted.

Wait, perhaps I need to sort a in ascending order and c in descending order, and pair them accordingly.

Let me check another example.

Take a = [1,2,3], b = [1,2,3,4,5].

Sort a: [1,2,3]

Sort b descending: [5,4,3,2,1]

Select the top n=3: [5,4,3]

Pair with a: 1 with 5, 2 with 4, 3 with 3, differences: 4,2,0, sum=6.

Alternatively, select [5,3,1], pair with a: 1 with 5, 2 with 3, 3 with 1, differences:4,1,2, sum=7.

So, selecting [5,3,1] is better than [5,4,3].

Similarly, selecting [5,2,1], pair with a:1 with 5,2 with 2,3 with 1, differences:4,0,2, sum=6.

So, [5,3,1] gives the highest sum.

Another selection: [4,3,2], pair with a:1 with 4,2 with 3,3 with 2, differences:3,1,1, sum=5.

So, indeed, selecting [5,3,1] gives the highest sum.

So, how to generalize this?

It seems that selecting both the largest and smallest elements from b gives a higher sum than just selecting the largest elements.

So, perhaps I should select the largest elements and the smallest elements from b, whichever gives the highest differences when paired with a.

But how to decide how many to take from each end?

This seems tricky.

Let me consider that I can select k smallest elements and (n - k) largest elements from b.

Then, sort the selected c in descending order and pair with a in ascending order.

I need to choose k that maximizes the sum.

But this seems too slow for the constraints.

I need a better way.

Wait, perhaps I can sort b in descending order, and then select a subsequence of n elements from b in that order.

But I'm not sure.

Let me think differently.

Suppose I fix a in ascending order.

Then, for c, I need to choose n elements from b and arrange them in some order to maximize sum of |a_i - c_i|.

This sounds like I need to maximize the assignment sum.

In assignment problems, to maximize the sum, I should pair the largest available c with the smallest a, and the smallest available c with the largest a.

Wait, but in the earlier examples, pairing a_i with c_j where c_j is either the largest or smallest available, depending on a_i.

But implementing this seems complicated.

Let me consider another approach.

Suppose I consider for each a_i, the potential c_j's that can be paired with it to maximize the difference.

But again, I need to choose n distinct c_j's.

This seems too involved.

Let me look for a simpler approach.

Perhaps I can compute for each a_i, the maximum possible |a_i - c_j|, where c_j is in b, and then select c_j's such that these maximum differences are achieved without reusing c_j's.

But this still seems like an assignment problem.

Is there a way to simplify this?

Let me consider that to maximize the sum of |a_i - c_i|, I should select c_j's that are as far away as possible from a_i's.

So, I should select c_j's from the extremes of b's range.

Therefore, I should select the largest and smallest elements from b.

But how many from each end?

I need to choose n elements in total.

So, I can choose k smallest and (n - k) largest elements from b, for some k between 0 and n.

Then, sort these selected c_j's in descending order and pair them with a in ascending order.

Then, compute the sum of |a_i - c_i|.

I need to choose k that maximizes this sum.

But with n up to 2e5, I need this to be efficient.

So, perhaps I can precompute prefix sums or something similar.

Wait, maybe I can iterate over k from 0 to n, select k smallest and (n - k) largest elements from b, sort the selected c in descending order, pair with a in ascending order, and compute the sum.

Then, choose the k that gives the maximum sum.

But this seems too slow because n can be up to 2e5.

I need a smarter way.

Let me think about the overall sum.

If I select k smallest and (n - k) largest elements from b, then sorting c in descending order would arrange these selected elements from largest to smallest.

Then, pairing with a in ascending order, a_i with c_i.

So, for a_1 (smallest a), paired with c_1 (largest c), the difference is large.

For a_n (largest a), paired with c_n (smallest among selected c's), the difference could be large if c_n is small.

So, perhaps I can compute the sum for different k and find the maximum sum.

But I need to do this efficiently.

Let me try to find a way to compute the sum for any k in O(1) time after some preprocessing.

First, sort b in ascending order.

Then, for each k from 0 to n, select the last k elements (largest) and the first (n - k) elements (smallest).

Combine these and sort in descending order to form c.

Then, pair with a in ascending order and compute the sum.

But sorting c each time would be too slow.

Is there a way to compute the sum without sorting c each time?

Wait, since c is sorted descending, the first element is the largest among the selected, the second is the next largest, and so on.

So, if I have the selected elements, I can sort them descending and pair with a ascending.

But I need to find a way to compute this sum efficiently for all k.

This seems tricky.

Let me consider that the optimal k is either 0 or some value where adding another smallest element increases the sum.

But I'm not sure.

Maybe I can consider the differences and find a way to maximize the sum.

Wait, perhaps another approach: since I need to select n elements from b, arrange them in descending order, and pair them with a in ascending order, to maximize the sum of |a_i - c_i|.

Given that, maybe I can iterate over all possible selections of n elements from b, sort them descending, pair with a ascending, and find the maximum sum.

But that's not practical due to the large n.

I need a better way.

Let me consider that the sum of |a_i - c_i| is equal to sum of (c_i - a_i) if c_i >= a_i, else sum of (a_i - c_i).

But since c is sorted descending and a is sorted ascending, c_i >= a_i for some i and c_i < a_i for others.

But perhaps I can find a way to compute the sum efficiently.

Wait, maybe I can use prefix sums or something similar.

Let me think differently.

Suppose I fix c in descending order.

Then, pair it with a in ascending order.

So, c is sorted descending, a is sorted ascending.

Then, the sum is sum of |a_i - c_i|.

I need to maximize this sum.

To maximize sum of |a_i - c_i|, I need to maximize each |a_i - c_i|.

Given that, I need to choose c_i's such that they are as far as possible from a_i's.

Given that c is sorted descending and a is sorted ascending, this seems like a good strategy.

But as earlier examples show, sometimes selecting both small and large elements from b gives a better sum.

So, how to choose which elements to select from b?

Wait, perhaps I can select the n elements from b that are either the largest or smallest, depending on a_i's.

But I need to pair them in a way that maximizes the sum.

This seems too vague.

Let me consider that to maximize sum of |a_i - c_i|, I need to maximize each |a_i - c_i| individually, but subject to the constraint that c_j's are distinct and selected from b.

But this is an optimization problem with constraints.

Is there a way to model this efficiently?

Wait, perhaps I can consider that for a given a, the optimal c is composed of the largest and smallest elements from b, arranged in a specific order.

But I need to formalize this.

Let me consider that I should select floor(n/2) smallest elements and ceil(n/2) largest elements from b, or something like that.

But in the earlier example, selecting [1,3,5] worked better than selecting [3,4,5].

So, perhaps selecting elements from both ends is better.

But how to decide how many to take from each end?

I need a systematic way.

Let me consider that I sort b in ascending order, and then select elements from both ends to maximize the sum.

So, I can have a sliding window that selects k from the left and n - k from the right.

Then, for each k from 0 to n, select k smallest and n - k largest, sort the selected elements descending, and compute the sum with a sorted ascending.

Then, choose the k that gives the maximum sum.

But with n up to 2e5, and t up to 100, this could be too slow because it would be O(t * n), which is acceptable since total m over all test cases is up to 2e5.

Wait, but sorting for each test case could be time-consuming.

But let's see.

In code, I can do the following:

- For each test case:

- Read n, m

- Read a and b

- Sort a in ascending order

- Sort b in ascending order

- Then, for k from 0 to n:

- Select k smallest from b and n - k largest from b

- Combine and sort descending

- Compute sum of |a_i - c_i|

- Keep track of the maximum sum

- Output the maximum sum

But this seems inefficient because for each k, I have to select and sort again.

Is there a way to optimize this?

Wait, perhaps I can precompute the possible c arrays for different k and compute the sums efficiently.

But it's getting complicated.

Let me think about it differently.

Suppose I sort a in ascending order and sort b in descending order.

Then, select the first n elements from b to form c.

Pair a_i with c_i and compute the sum of |a_i - c_i|.

But as earlier examples show, sometimes selecting some smaller elements from b gives a higher sum.

So, perhaps I need to consider selecting some smaller elements from b and include them in c.

Wait, maybe I can consider that for some a_i, pairing with a smaller c_j gives a larger difference than pairing with a larger c_j.

But this seems too vague.

Let me consider that for each a_i, the maximum possible |a_i - c_j| is max(|a_i - min_b|, |a_i - max_b|).

So, for each a_i, the best c_j to pair with is either min_b or max_b.

But since I have to pair all a_i's with distinct c_j's, I need to choose c_j's accordingly.

This seems like a matching problem where each a_i is matched to either min_b or max_b, but with the constraint that c_j's are distinct.

This is getting too complicated.

Let me look for a different approach.

Suppose I fix c in descending order.

Then, pair it with a in ascending order.

I need to select n elements from b to form c, sorted descending, to maximize sum of |a_i - c_i|.

Perhaps I can iterate through possible c arrays by selecting different combinations of n elements from b, sort them descending, and compute the sum.

But this is not practical due to time constraints.

I need a better way.

Let me consider that the sum of |a_i - c_i| is equal to sum of (c_i - a_i) if c_i >= a_i, else sum of (a_i - c_i).

So, I can write it as sum of max(c_i - a_i, a_i - c_i).

But this doesn't directly help.

Wait, perhaps I can consider that for each a_i, to maximize |a_i - c_i|, I need to choose c_i that is as far as possible from a_i.

But since I have to choose n distinct c_j's, I need to select c_j's that maximize the sum.

This seems like I need to solve an assignment problem.

But assignment problems are typically solved using the Hungarian algorithm, which is too slow for n=2e5.

So, I need a different approach.

Let me think about the overall sum.

Sum of |a_i - c_i| is equal to sum of (c_i - a_i) if c_i >= a_i, else sum of (a_i - c_i).

But since c is sorted descending and a is sorted ascending, c_i >= a_i for all i.

Wait, no, that's not necessarily true.

Wait, in the earlier example, a=[1,2,3], c=[5,3,1], then c_i >= a_i for all i.

But in another example, a=[1,2,3], c=[5,2,1], then c_2=2 >= a_2=2.

So, generally, c_i >= a_i.

But |a_i - c_i| = c_i - a_i if c_i >= a_i, else a_i - c_i.

But since c is sorted descending and a is sorted ascending, c_i >= a_i for all i only if c is greater than or equal to a in each corresponding position.

But this may not always hold.

So, perhaps I need to consider both possibilities.

Wait, perhaps I can compute the sum as sum of (c_i - a_i) for c_i >= a_i, and sum of (a_i - c_i) for c_i < a_i.

But this still doesn't directly help.

Let me consider that to maximize the sum, I should maximize each |a_i - c_i|.

Given that, for each a_i, I should choose c_i that is as far as possible from a_i.

But since I have to choose n distinct c_i's, I need to choose c_i's that maximize the sum.

This seems too vague.

Let me consider that the maximum sum is achieved when c is sorted descending and a is sorted ascending.

Wait, but earlier examples show that selecting both small and large elements from b can give a higher sum.

So, perhaps sorting b in ascending order, selecting k smallest and (n - k) largest, sorting the selected c in descending order, and pairing with a ascending gives the maximum sum.

Then, I can iterate over k from 0 to n, select the corresponding c, compute the sum, and take the maximum over all k.

Given the constraints, with t up to 100 and total m up to 2e5, and n up to 2e5, this should be acceptable.

So, in code, for each test case:

- Read n, m

- Read a and b

- Sort a in ascending order

- Sort b in ascending order

- Then, for k from 0 to n:

- Select k smallest from b: b[0 to k-1]

- Select n - k largest from b: b[m - (n - k) to m - 1]

- Combine these selected elements and sort them in descending order to form c

- Pair with a in ascending order and compute sum of |a_i - c_i|

- Keep track of the maximum sum

- Output the maximum sum

This seems feasible.

In code, to optimize, I can precompute the possible c arrays for different k and compute the sums efficiently.

But sorting for each k would be time-consuming.

Is there a way to optimize this?

Wait, perhaps I can observe that as k increases, the selected c changes slightly.

But I'm not sure.

Alternatively, perhaps I can compute the sum for k=0, then incrementally add the next smallest element and remove the largest element that is no longer selected, and update the sum accordingly.

But this seems error-prone.

Let me think about it.

Suppose I start with k=0, selecting the n largest elements from b.

Sort them descending and pair with a ascending.

Compute the sum.

Then, for k=1, select the smallest element and the n-1 largest elements from b.

Sort them descending and pair with a ascending.

Compute the sum.

And so on, up to k=n, selecting the n smallest elements from b, sort descending, pair with a ascending, compute the sum.

Then, choose the maximum sum among all these possibilities.

In code, I can implement this by precomputing the sorted b ascending, then for each k, selecting the appropriate elements, sorting them descending, and computing the sum.

But sorting for each k would be too slow for n=2e5.

So, I need a smarter way to compute the sum for each k without sorting c each time.

Wait, perhaps I can maintain the selected c elements in a list and sort them once, then for each k, adjust the list by adding and removing elements accordingly.

But this seems too involved.

Let me consider that since c needs to be sorted descending, and I'm selecting k smallest and n - k largest from b, I can precompute the k smallest and n - k largest for each k.

Then, for each k, the c array would be the union of k smallest and n - k largest, sorted descending.

Then, pairing with a ascending, compute the sum.

But with n up to 2e5, and t up to 100, this could be too slow.

Is there a way to compute this more efficiently?

Wait, perhaps I can precompute the possible c arrays for different k and store them, but that would require too much memory.

Alternatively, maybe I can compute the sum directly without sorting c each time.

Let me think about how the sum is computed.

Given that c is sorted descending, the first element is the largest among the selected, the second is the next largest, and so on.

So, for a_i paired with c_i, where a is sorted ascending and c is sorted descending.

So, for a_1 (smallest a) paired with c_1 (largest c), a_2 with c_2, and so on.

Then, the sum is sum of |a_i - c_i|.

Given that, perhaps I can find a way to compute this sum based on the selected elements without sorting them each time.

But I'm not sure.

Let me consider that the sum is sum of max(c_i - a_i, a_i - c_i).

But this doesn't directly help.

Wait, perhaps I can consider that c_i is the j-th largest among the selected elements.

But that seems too vague.

Let me consider that for the selected c, the sum is sum of |a_i - c_i| when c is sorted descending and a is sorted ascending.

Given that, perhaps I can compute the sum as sum of (c_i - a_i) for c_i >= a_i, and sum of (a_i - c_i) for c_i < a_i.

But I still need to know which c_i are greater than or equal to a_i.

This seems too involved.

Let me consider that since c is sorted descending and a is sorted ascending, c_i >= a_i for all i only if c is greater than or equal to a in each position.

But this may not hold for all selections.

So, perhaps I need to consider both cases.

Wait, perhaps I can compute the sum as sum of (c_i - a_i) for all i where c_i >= a_i, and sum of (a_i - c_i) for all i where c_i < a_i.

But to compute this efficiently, I need a way to determine which c_i's are greater than or equal to a_i for each k.

This seems too complicated.

Let me consider that for a given k, the c array is composed of the k smallest and n - k largest elements from b, sorted descending.

So, the c array would be the n - k largest elements first, followed by the k smallest elements, all sorted descending.

So, c = sorted desc (top n - k from b) + sorted desc (top k smallest from b)

But since I'm sorting them descending, I can think of c as the n elements consisting of the n - k largest and k smallest, sorted descending.

Then, pairing with a sorted ascending, compute the sum.

So, perhaps I can precompute the prefix and suffix sums from b.

For example, precompute the largest n elements from b, sort them descending, and compute the sum with a ascending.

Then, for k=1 to n, replace the smallest c_i with the next smallest from b, and compute the new sum.

But this seems too involved.

Let me think differently.

Suppose I fix a sorted ascending.

Then, to maximize sum of |a_i - c_i|, I need to choose c sorted descending such that the sum is maximized.

Given that, perhaps I can consider that for each a_i, I should choose the c_i that is as far as possible from a_i.

But since c is sorted descending, and a is sorted ascending, this seems like a good strategy.

So, perhaps the initial approach of sorting a ascending, sorting b descending, selecting the top n elements from b to form c, and computing the sum is sufficient.

But earlier examples showed that sometimes selecting some smaller elements from b gives a higher sum.

So, perhaps this approach is not always optimal.

Wait, but in the earlier example, selecting [5,3,1] gave a higher sum than selecting [5,4,3].

So, maybe selecting both small and large elements is better.

But in terms of implementation, iterating over k from 0 to n and selecting k smallest and n - k largest, sorting them descending, and computing the sum seems necessary.

Given the time constraints, perhaps this is acceptable, as t is up to 100 and total m over all test cases is up to 2e5.

So, in code, I can implement this approach.

Now, let's look at the given code and see if it implements this approach correctly.

Looking at the given code:

def func():

for _ in range(int(input())):

(n, m) = map(int, input().split())

a = list(map(int, input().split()))

c = list(map(int, input().split()))

if len(set(a)) == 1 and len(set(c)) == 1 and (a[0] == c[0]):

print(0)

continue

a.sort()

c.sort(reverse=True)

if len(a) == 1:

print(max(abs(a[0] - max(c)), abs(a[0] - min(c))))

continue

(i, j, ans) = (0, 1, 0)

for k in range(len(a)):

t1 = abs(a[i] - c[i])

t2 = abs(a[len(a) - j] - c[len(c) - j])

if t2 > t1:

j += 1

else:

i += 1

ans += max(t1, t2)

print(ans)

So, the code does the following:

- Reads t, n, m, a, c for each test case.

- If a has all elements equal and c has all elements equal and equal to a, output 0.

- Sorts a ascending and c descending.

- If n == 1, output the max of |a[0] - max(c)| and |a[0] - min(c)|.

- Else, initialize i=0, j=1, ans=0.

- For each k from 0 to n-1:

- Compute t1 = |a[i] - c[i]|

- Compute t2 = |a[len(a)-j] - c[len(c)-j]|

- If t2 > t1, increment j else increment i

- Add max(t1, t2) to ans

- Output ans

Wait, this seems confusing.

In the loop, for each k, it computes t1 and t2, chooses the max, and adds it to ans.

But it's not clear what this is doing.

Wait, perhaps it's trying to select elements from both ends of c (which is sorted descending) and a (sorted ascending).

But I'm not sure.

This seems like an attempt to implement the approach I was considering earlier, but it's not clear.

In particular, the logic with i and j seems off.

Wait, perhaps it's trying to select elements from both ends of c and pair them with a.

But I'm not sure.

Let me try with an example.

Take a = [1,2,3], c = [5,4,3,2,1], sorted descending c = [5,4,3,2,1]

a sorted ascending: [1,2,3]

Initialize i=0, j=1, ans=0

For k=0:

t1 = |a[0] - c[0]| = |1 - 5| = 4

t2 = |a[3-1] - c[5-1]| = |3 - 1| = 2

Since t2 < t1, increment i to 1

ans += 4 => ans=4

For k=1:

t1 = |a[1] - c[1]| = |2 - 4| = 2

t2 = |a[3-2] - c[5-2]| = |2 - 2| = 0

Since t2 < t1, increment i to 2

ans += 2 => ans=6

For k=2:

t1 = |a[2] - c[2]| = |3 - 3| = 0

t2 = |a[3-3] - c