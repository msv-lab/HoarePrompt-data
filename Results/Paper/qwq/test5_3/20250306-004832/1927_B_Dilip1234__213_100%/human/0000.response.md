Alright, I have this problem to solve. Let's see what it's about. So, Polycarp lost a string, but he has its "trace." The trace is an array of integers that represent, for each position in the string, how many previous indices have the same character as that position. For example, for the string "abracadabra," the trace is [0,0,0,1,0,2,0,3,1,1,4]. That makes sense because, for each position, it's counting how many times the same character has appeared before.

My task is, given this trace array, to reconstruct any possible string that could have produced this trace. The string should only consist of lowercase Latin letters, a-z.

First, I need to understand the input and output formats. The input starts with an integer t, representing the number of test cases. For each test case, there's an integer n, which is the length of the lost string, followed by an array of n integers, which is the trace a.

The output should be t strings, each corresponding to a test case, where each string s is such that its trace matches the given array a.

Constraints:

- t is between 1 and 10^4

- n is between 1 and 2*10^5

- a_i is between 0 and n-1

And it's guaranteed that a valid string s exists for each test case.

Example:

Input:

5

11

0 0 0 1 0 2 0 3 1 1 4

10

0 0 0 0 0 1 0 1 1 0

1

0

8

0 1 2 3 4 5 6 7

8

0 0 0 0 0 0 0 0

Output:

abracadabra

codeforces

a

aaaaaaa

dijkstra

Looking at the first test case:

n=11, a=[0,0,0,1,0,2,0,3,1,1,4]

The string is "abracadabra"

Let's verify the trace:

- a[0]=0: 'a' has no previous 'a's.

- a[1]=0: 'b' has no previous 'b's.

- a[2]=0: 'r' has no previous 'r's.

- a[3]=1: 'a' has one previous 'a'.

- a[4]=0: 'c' has no previous 'c's.

- a[5]=2: 'a' has two previous 'a's.

- a[6]=0: 'd' has no previous 'd's.

- a[7]=3: 'a' has three previous 'a's.

- a[8]=1: 'b' has one previous 'b'.

- a[9]=1: 'r' has one previous 'r'.

- a[10]=4: 'a' has four previous 'a's.

Yes, that matches.

Another test case:

n=10, a=[0,0,0,0,0,1,0,1,1,0]

String: "codeforces"

Let's verify:

- a[0]=0: 'c' has no previous 'c's.

- a[1]=0: 'o' has no previous 'o's.

- a[2]=0: 'd' has no previous 'd's.

- a[3]=0: 'e' has no previous 'e's.

- a[4]=0: 'f' has no previous 'f's.

- a[5]=1: 'o' has one previous 'o'.

- a[6]=0: 'r' has no previous 'r's.

- a[7]=1: 'c' has one previous 'c'.

- a[8]=1: 'e' has one previous 'e'.

- a[9]=0: 's' has no previous 's's.

Yes, that matches too.

So, the problem is to, for each position in the string, choose a character such that the number of times this character has appeared before is equal to a_i.

Given that, I need to find a way to reconstruct the string based on the trace array.

Let's think about how to approach this.

I need to build the string step by step. For each position i from 0 to n-1, I need to choose a character c such that the number of times c has appeared before position i is exactly a_i.

I need to ensure that the choices I make for previous positions don't conflict with the a_i for current and future positions.

One way to do this is to keep track of how many times each character has been used so far. For each position, I look for a character whose count matches a_i.

But I need to make sure that such a character exists and that choosing it doesn't make it impossible to satisfy future a_i's.

Wait, the problem says that it's guaranteed that a valid string exists for the given trace, so I don't need to worry about the trace not being valid.

So, I can proceed under the assumption that such a string exists.

Let me consider the frequency counts of each character up to each position.

I can maintain an array of counts for each character ('a' to 'z'), initialized to zero.

Then, for each position i from 0 to n-1:

- I need to choose a character c such that the current count of c is equal to a_i.

- Once I choose c, I increment the count of c.

I need to make sure that for each i, there exists at least one character c whose count is currently equal to a_i.

Since it's guaranteed that a valid string exists, I can assume that such a c exists.

So, for each position, I can iterate through all possible characters ('a' to 'z') and choose the first one whose count matches a_i.

Then, I append that character to the string and increment its count.

Let me try this approach with the first test case.

Test case 1:

n=11

a=[0,0,0,1,0,2,0,3,1,1,4]

Initialize counts: [0,0,0,...] for 'a' to 'z'

Position 0: a_i=0

Look for a character with count 0. 'a' has count 0. Choose 'a'.

s = "a"

counts['a'] = 1

Position 1: a_i=0

Look for a character with count 0. 'b' has count 0. Choose 'b'.

s = "ab"

counts['b'] = 1

Position 2: a_i=0

Look for a character with count 0. 'c' has count 0. Choose 'c'.

s = "abc"

counts['c'] = 1

Position 3: a_i=1

Look for a character with count 1. 'a' has count 1. Choose 'a'.

s = "abca"

counts['a'] = 2

Position 4: a_i=0

Look for a character with count 0. 'd' has count 0. Choose 'd'.

s = "abcad"

counts['d'] = 1

Position 5: a_i=2

Look for a character with count 2. 'a' has count 2. Choose 'a'.

s = "abcaad"

counts['a'] = 3

Position 6: a_i=0

Look for a character with count 0. 'e' has count 0. Choose 'e'.

s = "abcaade"

counts['e'] = 1

Position 7: a_i=3

Look for a character with count 3. 'a' has count 3. Choose 'a'.

s = "abcaaade"

counts['a'] = 4

Position 8: a_i=1

Look for a character with count 1. 'b' has count 1. Choose 'b'.

s = "abcaaadeb"

counts['b'] = 2

Position 9: a_i=1

Look for a character with count 1. 'c' has count 1. Choose 'c'.

s = "abcaaadebc"

counts['c'] = 2

Position 10: a_i=4

Look for a character with count 4. 'a' has count 4. Choose 'a'.

s = "abcaaadebca"

counts['a'] = 5

Wait, but in the example, the string is "abracadabra", which is "a b r a c a d a b r a". Let's see:

Positions:

0: 'a' count=0

1: 'b' count=0

2: 'r' count=0

3: 'a' count=1

4: 'c' count=0

5: 'a' count=2

6: 'd' count=0

7: 'a' count=3

8: 'b' count=1

9: 'r' count=1

10: 'a' count=4

In my reconstruction, I got "abcaaadebca", which also matches the trace, but it's different from the example string. But the problem allows any valid string, so that's fine.

Another test case:

n=10

a=[0,0,0,0,0,1,0,1,1,0]

Example output: "codeforces"

Let's try my approach:

Initialize counts: [0,0,0,...]

Position 0: a_i=0. Choose 'c' (counts['c']=1)

s = "c"

Position 1: a_i=0. Choose 'o' (counts['o']=1)

s = "co"

Position 2: a_i=0. Choose 'd' (counts['d']=1)

s = "cod"

Position 3: a_i=0. Choose 'e' (counts['e']=1)

s = "code"

Position 4: a_i=0. Choose 'f' (counts['f']=1)

s = "codef"

Position 5: a_i=1. Choose 'o' (counts['o']=2)

s = "codefo"

Position 6: a_i=0. Choose 'r' (counts['r']=1)

s = "codefor"

Position 7: a_i=1. Choose 'c' (counts['c']=2)

s = "codeforc"

Position 8: a_i=1. Choose 'e' (counts['e']=2)

s = "codefore"

Position 9: a_i=0. Choose 's' (counts['s']=1)

s = "codefore s"

Which is "codeforces", matching the example.

Another test case:

n=1

a=[0]

Output: "a"

Simple enough.

Another test case:

n=8

a=[0,1,2,3,4,5,6,7]

Output: "aaaaaaa"

Wait, no. The output is "aaaaaaa", which makes sense.

Wait, but in the example, it's "aaaaaaa", but according to the trace:

a=[0,1,2,3,4,5,6,7]

So, for each position i from 1 to 7, a_i=i-1, meaning that the character at position i has appeared i-1 times before.

So, if all a_i are sequential like that, repeating the same character makes sense.

Last test case:

n=8

a=[0,0,0,0,0,0,0,0]

Output: "dijkstra"

Which makes sense because all a_i=0, meaning that each character is unique up to that point.

So, in this case, choosing any 8 distinct characters would work, but since the alphabet has 26 letters, it's possible.

Now, thinking about implementation.

I need to process t test cases, each with n and a array.

I need to output t strings, each corresponding to a test case.

Given that n can be up to 2*10^5 and t up to 10^4, but the sum of n over all test cases does not exceed 2*10^5, I need an efficient solution.

Time complexity should be acceptable, as 2*10^5 operations are feasible.

Space-wise, storing counts for 26 characters is fine.

Implementing the approach I described:

- For each test case:

- Read n

- Read the array a of n integers

- Initialize a list of counts for 'a' to 'z', all set to 0

- Initialize an empty string s

- For each position i from 0 to n-1:

- Find a character c such that counts[c] == a[i]

- Append c to s

- Increment counts[c]

- Output s

Since it's guaranteed that a valid string exists, I don't need to handle cases where no such c exists.

I need to implement this efficiently.

Implementing the counts as a list of 26 integers, indexed by ord(c) - ord('a').

To choose the character c, I can iterate through 'a' to 'z' and pick the first one whose count matches a[i].

That should be fine.

Let me think about potential edge cases.

Edge cases:

1. n=1, a=[0]: output any character, say 'a'

2. n=2, a=[0,0]: two different characters, e.g., 'ab'

3. n=2, a=[0,1]: same character twice, 'aa'

4. All a_i=0: all characters are unique, like 'abcde...'

5. All a_i=i-1: all characters are the same, like 'aaaaa...'

6. a_i in some random order, but consistent.

I need to ensure that the choice of characters doesn't lead to conflicts in future positions.

But since it's guaranteed that a valid string exists, I can proceed with choosing the first available character that matches a[i].

Now, about the implementation.

The given program has a function func_1(n, a) that seems to implement this logic.

Let me look at the given program.

Given program:

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

print(func_1(n, a))

def func_1(n, a):

s = ''

char_count = [0] * 26

for i in range(n):

for j in range(26):

if char_count[j] == a[i]:

s += chr(j + ord('a'))

char_count[j] += 1

break

return s

This seems to match the approach I described.

It initializes char_count as a list of 26 zeros.

For each position i from 0 to n-1:

- It iterates through j from 0 to 25 (corresponding to 'a' to 'z')

- If char_count[j] == a[i], it chooses that character, adds it to s, increments char_count[j], and breaks the inner loop.

- Finally, it returns the string s.

This should work correctly, based on my earlier reasoning.

Let me verify with the first test case.

Test case 1:

n=11

a=[0,0,0,1,0,2,0,3,1,1,4]

Processing:

char_count initial: [0,0,0,...]

i=0, a[0]=0: choose 'a' (j=0, char_count[0]=0), s='a', char_count[0]=1

i=1, a[1]=0: choose 'b' (j=1, char_count[1]=0), s='ab', char_count[1]=1

i=2, a[2]=0: choose 'c' (j=2, char_count[2]=0), s='abc', char_count[2]=1

i=3, a[3]=1: choose 'a' (j=0, char_count[0]=1), s='abca', char_count[0]=2

i=4, a[4]=0: choose 'd' (j=3, char_count[3]=0), s='abcad', char_count[3]=1

i=5, a[5]=2: choose 'a' (j=0, char_count[0]=2), s='abcaad', char_count[0]=3

i=6, a[6]=0: choose 'e' (j=4, char_count[4]=0), s='abcaade', char_count[4]=1

i=7, a[7]=3: choose 'a' (j=0, char_count[0]=3), s='abcaaade', char_count[0]=4

i=8, a[8]=1: choose 'b' (j=1, char_count[1]=1), s='abcaaadeb', char_count[1]=2

i=9, a[9]=1: choose 'c' (j=2, char_count[2]=1), s='abcaaadebc', char_count[2]=2

i=10, a[10]=4: choose 'a' (j=0, char_count[0]=4), s='abcaaadebca', char_count[0]=5

Which matches the earlier reconstruction.

Another test case:

n=10

a=[0,0,0,0,0,1,0,1,1,0]

Processing:

char_count initial: [0,0,0,...]

i=0, a[0]=0: choose 'a' (j=0, char_count[0]=0), s='a', char_count[0]=1

i=1, a[1]=0: choose 'b' (j=1, char_count[1]=0), s='ab', char_count[1]=1

i=2, a[2]=0: choose 'c' (j=2, char_count[2]=0), s='abc', char_count[2]=1

i=3, a[3]=0: choose 'd' (j=3, char_count[3]=0), s='abcd', char_count[3]=1

i=4, a[4]=0: choose 'e' (j=4, char_count[4]=0), s='abcde', char_count[4]=1

i=5, a[5]=1: choose 'a' (j=0, char_count[0]=1), s='abcdea', char_count[0]=2

i=6, a[6]=0: choose 'f' (j=5, char_count[5]=0), s='abcdeaf', char_count[5]=1

i=7, a[7]=1: choose 'b' (j=1, char_count[1]=1), s='abcdeafb', char_count[1]=2

i=8, a[8]=1: choose 'c' (j=2, char_count[2]=1), s='abcdeafbc', char_count[2]=2

i=9, a[9]=0: choose 'g' (j=6, char_count[6]=0), s='abcdeafbcg', char_count[6]=1

Which is different from the example output "codeforces", but it's still a valid string that matches the trace.

Hence, the program seems correct.

Is there any way this could be incorrect?

Let me think about possible issues.

- Choosing the first available character with the matching count might not always lead to a valid string.

But, given that the problem guarantees that a valid string exists, and that we're choosing characters in order, it should be fine.

- What if multiple characters have the same count equal to a[i]? Which one to choose?

The program chooses the first one encountered, which should be fine, as any of them would work, given the existence of a valid string.

- Are there any off-by-one errors or indexing issues?

Seems okay.

- Is there any issue with the way counts are incremented?

Looks correct.

- What about edge cases, like n=1 or all a_i=0?

Should handle those correctly.

- Time constraints: with t up to 10^4 and n up to 2*10^5 in total, the time should be acceptable.

- Space constraints: char_count is a list of 26 integers, which is fine.

Hence, I conclude that the given program is correct.

**Final Solution**

To solve this problem, we need to reconstruct the original string from its trace array. The trace array provides the count of previous occurrences of each character up to that point in the string.

### Approach

1. **Initialization**:
   - Read the number of test cases.
   - For each test case, read the length of the string and the trace array.

2. **Reconstruct the String**:
   - Maintain a count of each character 'a' to 'z' using a list of 26 elements, initialized to 0.
   - Iterate through the trace array:
     - For each position in the trace array, find the first character whose current count matches the value in the trace array.
     - Append this character to the result string.
     - Increment the count of this character.
   
3. **Output the Result**:
   - Print the reconstructed string for each test case.

### Solution Code

```python
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    print(func_1(n, a))

def func_1(n, a):
    s = ''
    char_count = [0] * 26
    for i in range(n):
        for j in range(26):
            if char_count[j] == a[i]:
                s += chr(j + ord('a'))
                char_count[j] += 1
                break
    return s
```

### Explanation

- **Initialization**:
  - We read the input values for the number of test cases, the length of the string, and the trace array.
  
- **Reconstructing the String**:
  - We use a list `char_count` to keep track of how many times each character from 'a' to 'z' has been used.
  - For each position in the trace array, we look for the first character that has been used exactly `a[i]` times.
  - We append this character to the result string and increment its count.
  
- **Output**:
  - The function `func_1` returns the reconstructed string for each test case, which is then printed.

This approach ensures that the string is reconstructed correctly based on the given trace array, and it runs efficiently given the constraints.