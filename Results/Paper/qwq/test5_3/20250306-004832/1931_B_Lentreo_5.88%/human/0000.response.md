Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The sum of all the water in these containers is divisible by n, which means that theoretically, we can distribute the water equally among all containers. The goal is to determine whether it's possible to make the amount of water in all containers the same using a specific operation: pouring any amount of water from container i to container j, where i must be less than j.

First, I need to understand the constraints and what operation I can perform. The operation allows me to pour water from a container with a lower index to a higher index, but not the other way around. This is important because it imposes a direction on the flow of water, from left to right in the sequence of containers.

Given that, I need to figure out if it's possible to equalize the water in all containers by only moving water from left to right.

Let's consider the target amount of water each container should have. Since the total sum is divisible by n, the target amount is sum(a)/n. Let's call this target value 'avg'.

My task is to check if it's possible to adjust the water in each container so that each one has exactly 'avg' amount of water, using only the allowed operations.

I need to think about how the operations affect the distribution of water. Starting from the leftmost container, I can pour water to the right, but I can't bring water back from the right to the left. So, the leftmost container can only lose water, not gain any.

Similarly, the second container can receive water from the first but can only pour to the containers on its right, and so on.

This seems like a cumulative process, where each container can receive water from the containers to its left but can only send water to the containers to its right.

Wait a minute, maybe I can think of it in terms of cumulative sums. Let's consider the cumulative sum of water from left to right. If at any point the cumulative sum falls below the expected sum to reach the target, it means that not enough water has been accumulated to reach the target for the containers up to that point.

Let's formalize this idea.

Let's define the target amount 'avg' as the total sum divided by n.

Then, for each position i from 1 to n, the cumulative sum of the first i containers should be at least i * avg. Because if the cumulative sum is less than i * avg, it means that even if we distribute all the water we have so far equally among the first i containers, at least one of them will have less than avg.

But wait, since we can only pour water from left to right, we need to ensure that at each step, we have enough water in the previous containers to compensate for any deficit in the current container.

Actually, perhaps a better way is to consider that each container can only receive water from the containers to its left, and it can send water to the containers to its right.

But this seems a bit complicated. Maybe I should look for a different approach.

Let me think about the example given.

In the third test case:

n = 5

a = [4, 5, 2, 1, 3]

sum(a) = 4 + 5 + 2 + 1 + 3 = 15

avg = 15 / 5 = 3

So, the target is for each container to have 3 units of water.

Looking at the steps provided:

1. Pour 1 unit from container 1 to container 4:

   a becomes [3, 5, 2, 2, 3]

2. Pour 1 unit from container 2 to container 3:

   a becomes [3, 4, 3, 2, 3]

3. Pour 1 unit from container 2 to container 4:

   a becomes [3, 3, 3, 3, 3]

So, it's possible in this case.

Now, let's consider the second test case:

n = 2

a = [1, 3]

sum(a) = 4

avg = 2

We need to make both containers have 2 units.

Possible operations:

- Pour from container 1 to container 2: but container 1 has only 1, so pouring 1 to container 2 would make a = [0, 4]. Now, I can't pour from container 2 back to container 1 because i < j is required. So, it's impossible to make both equal in this case.

So, the answer is "NO".

From these examples, it seems that the key is to ensure that the cumulative sum up to each point is at least the sum required to reach the target for those containers.

Wait, perhaps I need to check that for every prefix of the array, the sum of that prefix is at least the target sum for that prefix.

In other words, for every k from 1 to n, sum(a[1..k]) >= k * avg.

And since the total sum is divisible by n, if this condition holds for all k, then it's possible to reach the target distribution.

Wait, but in the second test case, for k=1:

sum(a[1]) = 1 >= 1 * 2? 1 >= 2? No, 1 < 2.

So, the condition fails for k=1, hence "NO".

In the third test case:

For k=1: 4 >= 3? Yes.

For k=2: 4+5=9 >= 6? Yes.

For k=3: 4+5+2=11 >= 9? Yes.

For k=4: 4+5+2+1=12 >= 12? Yes.

For k=5: 15 >= 15? Yes.

So, the condition holds for all k, and it's possible.

This seems to be a pattern.

So, generalizing, for the array a of length n, with target avg = sum(a)/n, it's possible to equalize the water if and only if for every k from 1 to n, sum(a[1..k]) >= k * avg.

This seems to make sense because, at each step, the cumulative sum should be enough to distribute the target amount to all previous containers.

If at any point the cumulative sum falls short, it means we don't have enough water accumulated to reach the target for those containers, and since we can't bring water from the right, it's impossible to compensate later.

Now, I need to verify this condition in the code.

Given that, let's look at the provided program and see if it implements this logic correctly.

The program is:

def func():

    t = int(input())

    for _ in range(t):

        n = int(input())

        nums = list(map(int, input().strip().split()))

        last = nums[-1]

        curr = 0

        for i in nums:

            if i != 0:

                curr += i - last

        if curr == 0:

            print('YES')

        else:

            print('NO')

First, it reads the number of test cases t.

Then, for each test case, it reads n and the array nums.

It sets last to be the last element of nums.

Then, it initializes curr to 0.

It loops through each element in nums, and if the element is not zero, it adds (i - last) to curr.

Finally, if curr == 0, it prints "YES", else "NO".

Wait, this seems suspicious.

What is this program doing exactly?

It's computing curr as the sum of (i - last) for all non-zero i in nums.

Wait, but what is "last"? It's the last element of the array.

So, curr is sum(i - last for i in nums if i != 0)

But, in the condition, it's checking if curr == 0.

This seems unrelated to the condition I derived earlier, which is checking that for every prefix sum, sum(a[1..k]) >= k * avg.

This program seems to be checking if the sum of (i - last) for non-zero i is zero.

This doesn't align with the logic I came up with.

Let me check with the example where the answer is "YES".

Take the third test case:

n = 5

a = [4, 5, 2, 1, 3]

last = 3

curr = (4-3) + (5-3) + (2-3) + (1-3) + (3-3) = 1 + 2 -1 -2 + 0 = 0

So, curr == 0, hence "YES"

In the second test case:

n = 2

a = [1, 3]

last = 3

curr = (1-3) + (3-3) = -2 + 0 = -2

curr != 0, hence "NO"

This seems to work for these cases, but is this a general solution?

Let me try another example.

Suppose n = 3

a = [3, 3, 3]

last = 3

curr = (3-3) + (3-3) + (3-3) = 0 + 0 + 0 = 0 => "YES"

Another example where it should be "NO":

n = 3

a = [1, 2, 3]

last = 3

curr = (1-3) + (2-3) + (3-3) = -2 -1 + 0 = -3 != 0 => "NO"

This matches the sample output.

Wait, but according to my earlier logic, in this case, sum(a) = 6, avg = 2

Check prefix sums:

k=1: 1 >= 2? No => "NO"

So, it's consistent.

But is this always true?

Let me think of another test case.

n = 4

a = [4, 0, 0, 4]

sum(a) = 8, avg = 2

Check prefix sums:

k=1: 4 >= 2? Yes

k=2: 4 + 0 = 4 >= 4? Yes

k=3: 4 + 0 + 0 = 4 >= 6? No => "NO"

According to my logic, it should be "NO"

Now, according to the program:

last = 4

curr = (4-4) + (0-4) + (0-4) + (4-4) = 0 -4 -4 + 0 = -8 != 0 => "NO"

Consistent again.

Another test case:

n = 4

a = [2, 2, 2, 2]

sum(a) = 8, avg = 2

All prefix sums meet the condition sum(a[1..k]) >= k*2

So, "YES"

Program:

last = 2

curr = (2-2) + (2-2) + (2-2) + (2-2) = 0 + 0 + 0 + 0 = 0 => "YES"

Consistent.

Wait, but is this just a coincidence, or is there a mathematical relationship that makes this work?

Let's try to understand mathematically.

Define avg = sum(a)/n

The condition is that for all k from 1 to n, sum(a[1..k]) >= k * avg

Now, the program is checking if sum(i - last for i in nums if i != 0) == 0

Wait, but why subtract last? And why consider only non-zero i?

This seems arbitrary.

Wait, perhaps there's another way to look at it.

Let me compute sum(i - avg for all i in nums)

This would be sum(i) - n*avg = sum(i) - sum(i) = 0

So, sum(i - avg) over all i is zero.

But the program is subtracting the last element, not the average.

Wait, last is nums[-1], which is a specific element, not the average.

This seems different.

Alternatively, maybe the program is checking if the sum of adjustments needed is zero.

But why only for non-zero i?

Wait, perhaps it's a mistake to consider only non-zero i.

Let me try a test case where some i are zero.

n = 3

a = [0, 0, 6]

sum(a) = 6, avg = 2

Prefix sums:

k=1: 0 >= 2? No => "NO"

Program:

last = 6

curr = (0-6) + (0-6) + (6-6) = -6 -6 + 0 = -12 != 0 => "NO"

Consistent.

Another test case:

n = 3

a = [2, 2, 2]

sum(a) = 6, avg = 2

All prefix sums meet the condition.

Program:

last = 2

curr = (2-2) + (2-2) + (2-2) = 0 + 0 + 0 = 0 => "YES"

Consistent.

Wait, but why does this work? Subtracting the last element instead of the average.

Let me see.

Wait, perhaps it's because the last element is being used as a reference.

But in the earlier examples, it seems to work, but is this general?

Let me try another test case.

n = 4

a = [3, 1, 1, 3]

sum(a) = 8, avg = 2

Check prefix sums:

k=1: 3 >= 2? Yes

k=2: 3+1=4 >= 4? Yes

k=3: 3+1+1=5 >= 6? No => "NO"

Program:

last = 3

curr = (3-3) + (1-3) + (1-3) + (3-3) = 0 -2 -2 + 0 = -4 != 0 => "NO"

Again, consistent.

Another test case:

n = 4

a = [2, 3, 1, 2]

sum(a) = 8, avg = 2

Check prefix sums:

k=1: 2 >= 2? Yes

k=2: 2+3=5 >= 4? Yes

k=3: 2+3+1=6 >= 6? Yes

k=4: 2+3+1+2=8 >= 8? Yes => "YES"

Program:

last = 2

curr = (2-2) + (3-2) + (1-2) + (2-2) = 0 +1 -1 + 0 = 0 => "YES"

Still consistent.

Wait, but why is this working? It seems to be correct, but I don't understand why subtracting the last element works.

Let me think differently.

Suppose I compute sum(i - avg) for all i in nums.

This sum should be zero, since sum(i) - n*avg = 0.

But the program is computing sum(i - last) for i != 0.

Wait, but sum(i - last) = sum(i) - n*last

But sum(i) - n*last = sum(a) - n*a[-1]

This is equal to n*avg - n*a[-1] = n*(avg - a[-1])

This would be zero only if avg == a[-1].

But avg is sum(a)/n, and a[-1] is the last element.

So, sum(a)/n = a[-1] implies sum(a) = n*a[-1], meaning all a[i] are equal to a[-1].

But this is only true if all elements are equal to the last one, which is a special case.

In general, sum(i - last) != 0.

Yet, in the program, it's checking if sum(i - last for i in nums if i != 0) == 0.

Wait, but in the examples, it's working correctly.

This suggests that there might be a different reason why this works.

Let me consider that the program is effectively checking if the sum of adjustments needed, excluding zero containers, is zero.

But I'm still not sure.

Alternatively, perhaps the program is incorrect, but coincidentally giving the right answers for the sample inputs.

But in that case, I should find a test case where it fails.

Let me try to find such a test case.

Consider n = 3

a = [1, 2, 3]

sum(a) = 6, avg = 2

According to my earlier logic, it's "NO" because k=1: 1 < 2

Program:

last = 3

curr = (1-3) + (2-3) + (3-3) = -2 -1 + 0 = -3 != 0 => "NO"

Consistent.

Another test case:

n = 4

a = [4, 0, 0, 4]

sum(a) = 8, avg = 2

My logic: "NO"

Program: "NO"

Still consistent.

Wait, perhaps I need a more tricky test case.

Consider n = 3

a = [3, 1, 2]

sum(a) = 6, avg = 2

Check prefix sums:

k=1: 3 >= 2? Yes

k=2: 3+1=4 >= 4? Yes

k=3: 3+1+2=6 >= 6? Yes => "YES"

Program:

last = 2

curr = (3-2) + (1-2) + (2-2) = 1 -1 + 0 = 0 => "YES"

Consistent.

Another test case:

n = 3

a = [2, 1, 3]

sum(a) = 6, avg = 2

Check prefix sums:

k=1: 2 >= 2? Yes

k=2: 2+1=3 >= 4? No => "NO"

Program:

last = 3

curr = (2-3) + (1-3) + (3-3) = -1 -2 + 0 = -3 != 0 => "NO"

Again, consistent.

Hmm.

It seems that the program is correctly identifying the cases where it's possible or not, at least for these test cases.

But I still don't understand why subtracting the last element works.

Let me consider the general case.

Suppose we have n containers with amounts a1, a2, ..., an.

We need to check if for all k from 1 to n, sum(a1 to ak) >= k * avg.

Now, the program is checking if sum(a1 to an) - n * a_n >= 0.

Wait, sum(a1 to an) - n * a_n = sum(a1 to an-1) - (n-1) * a_n

But I don't see a direct connection to the prefix sum conditions.

Alternatively, perhaps there's a different way to look at it.

Wait, maybe the program is checking if the sum of adjustments needed, with respect to the last element, is zero.

But again, I'm not sure.

Alternatively, perhaps the program has a mistake, but it's passing the sample inputs.

But in that case, I need to find a test case where it fails.

Let me try n = 4

a = [3, 1, 2, 2]

sum(a) = 8, avg = 2

Check prefix sums:

k=1: 3 >= 2? Yes

k=2: 3+1=4 >= 4? Yes

k=3: 3+1+2=6 >= 6? Yes

k=4: 8 >= 8? Yes => "YES"

Program:

last = 2

curr = (3-2) + (1-2) + (2-2) + (2-2) = 1 -1 + 0 + 0 = 0 => "YES"

Consistent.

Another test case:

n = 4

a = [2, 3, 1, 2]

sum(a) = 8, avg = 2

Check prefix sums:

k=1: 2 >= 2? Yes

k=2: 2+3=5 >= 4? Yes

k=3: 2+3+1=6 >= 6? Yes

k=4: 8 >= 8? Yes => "YES"

Program:

last = 2

curr = (2-2) + (3-2) + (1-2) + (2-2) = 0 +1 -1 + 0 = 0 => "YES"

Consistent.

Wait, perhaps the condition sum(i - last) == 0 is equivalent to sum(a) - n*last == 0, which implies sum(a) = n*last, meaning all a[i] == last.

But in the earlier test case, [3,1,2,2], sum(a) = 8, n=4, last=2, sum(a) = n*last, which is 8 = 8, so sum(i - last) = 0.

But in this case, not all a[i] are equal to last; only the last one is.

Yet, according to my earlier logic, since all prefix sums meet the condition, it should be "YES", and the program correctly identifies it as "YES".

But according to my initial thought, sum(a) = n*last implies all a[i] == last, which is not the case here.

Wait, in this test case, sum(a) = n*last, but not all a[i] are equal to last.

Does this mean the program is incorrect?

Wait, in this test case, it's "YES", and the program says "YES", but according to my initial thought, sum(a) = n*last implies all a[i] == last, which is not true here.

Wait, no, sum(a) = n*last does not imply all a[i] == last, because in this case, sum(a) = 8, n=4, last=2, and a = [3,1,2,2], which sums to 8, but not all a[i] are 2.

So, my initial thought was wrong.

So, sum(a) = n*last does not imply that all a[i] == last.

Hence, the program is checking if sum(a) - n*last == 0, which is sum(a) = n*last.

In this test case, it is true, and the answer is "YES".

But is this a general rule?

Wait, in another test case, n=3, a=[3,1,2], sum(a)=6, last=2, sum(a)=3*2=6, which is true, and according to my logic, it's "YES".

Another test case: n=3, a=[2,2,2], sum(a)=6, last=2, sum(a)=6=3*2 => "YES"

Test case where sum(a)=n*last and it's "YES".

What about a case where sum(a)=n*last but it should be "NO"?

Let me see.

n=3, a=[4,2,0], sum(a)=6, last=0, sum(a)=3*0=0? No, sum(a)=6 != 3*0=0.

Wait, sum(a)=6, n=3, last=0, sum(a)=6 != 3*0=0.

Wait, this is not possible.

Wait, sum(a)=n*last must be sum(a)=n*last, which is 3*0=0, but sum(a)=6, which is not equal to 0.

Wait, in this case, sum(a)=6 != n*last=0, so the program would have curr = sum(i - last for i in nums if i != 0) = (4-0) + (2-0) + (0-0) = 4 + 2 + 0 = 6 != 0 => "NO"

But according to my logic, for n=3, a=[4,2,0]:

sum(a)=6, avg=2

Check prefix sums:

k=1: 4 >= 2? Yes

k=2: 4+2=6 >= 4? Yes

k=3: 4+2+0=6 >= 6? Yes => "YES"

But the program says "NO" in this case.

Wait, this is a problem.

So, according to my logic, it should be "YES", but the program outputs "NO".

Hence, the program is incorrect in this case.

Therefore, the program is not correct.

So, the answer is Correctness: **False**

**Final Solution**

To solve this problem, we need to determine if it is possible to make the amount of water in each of the n containers equal by only pouring water from a container with a lower index to one with a higher index.

### Approach

1. **Calculate the Target Amount:**
   - The target amount of water each container should have is the total sum of water divided by the number of containers, `avg = sum(a) / n`.

2. **Check Prefix Sums:**
   - For the operation of pouring water only from a lower-indexed container to a higher-indexed one, we need to ensure that the cumulative sum of water in the first k containers is at least `k * avg` for all k from 1 to n.
   - This ensures that at each step, there is enough water accumulated to distribute the target amount to those k containers.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        nums = list(map(int, input().strip().split()))
        total_sum = sum(nums)
        avg = total_sum // n  # Since sum is divisible by n, this is integer division
        cumulative = 0
        possible = True
        for k in range(1, n+1):
            cumulative += nums[k-1]
            if cumulative < k * avg:
                possible = False
                break
        print('YES' if possible else 'NO')

func()
```

### Explanation

1. **Reading Input:**
   - Read the number of test cases `t`.
   - For each test case, read the number of containers `n` and the list of water amounts `nums`.

2. **Calculate the Target Average:**
   - Compute the target amount `avg` each container should have, which is `sum(a) /