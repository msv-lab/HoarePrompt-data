Alright, I've got this problem to solve. Let's see what it's about. There are two players, Alice and Bob, playing a game on an array of integers. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from the original array a, appends it to c, and deletes it from a. On Bob's turn, he picks an element from a, and just deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c. Alice wants to maximize the MEX, and Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, the goal is to have the highest possible MEX in c, which is the array that only includes the elements chosen by Alice.

Now, let's think about how the game progresses. Alice and Bob alternate turns, with Alice going first. Alice picks an element to add to c and removes it from a, while Bob just removes an element from a without adding it to c.

Since both are playing optimally, Alice will try to maximize the MEX, and Bob will try to minimize it.

I need to find out what the MEX of c will be at the end of the game when both play optimally.

Let me consider some examples to get a better understanding.

Example 1:

Input:

4

0 0 1 1

Output:

2

Explanation:

A possible game is:

- Alice picks 1, a becomes [0,0,1], c = [1]

- Bob picks 0, a becomes [0,1], c = [1]

- Alice picks 0, a becomes [1], c = [1,0]

- Bob picks 1, a becomes empty, c = [1,0]

MEX of c = [1,0] is 2.

But is this the optimal play? Let's see.

Another possible game:

- Alice picks 0, a becomes [0,1,1], c = [0]

- Bob picks 1, a becomes [0,1], c = [0]

- Alice picks 1, a becomes [0], c = [0,1]

- Bob picks 0, a becomes empty, c = [0,1]

MEX of c = [0,1] is 2.

Another possible game:

- Alice picks 1, a becomes [0,0,1], c = [1]

- Bob picks 1, a becomes [0,0], c = [1]

- Alice picks 0, a becomes [0], c = [1,0]

- Bob picks 0, a becomes empty, c = [1,0]

MEX is still 2.

It seems like regardless of how they play, c ends up with [0,1], giving MEX 2.

Wait, but in the explanation, it shows c = [1,0], which is the same as [0,1].

So, in this case, MEX is 2.

Example 2:

Input:

4

0 1 2 3

Output:

1

Explanation:

Let's simulate:

- Alice picks 0, a becomes [1,2,3], c = [0]

- Bob picks 1, a becomes [2,3], c = [0]

- Alice picks 2, a becomes [3], c = [0,2]

- Bob picks 3, a becomes empty, c = [0,2]

MEX of c = [0,2] is 1, since 1 is missing.

Alternatively:

- Alice picks 1, a becomes [0,2,3], c = [1]

- Bob picks 0, a becomes [2,3], c = [1]

- Alice picks 2, a becomes [3], c = [1,2]

- Bob picks 3, a becomes empty, c = [1,2]

MEX is 0, but wait, 0 is not in c, so MEX should be 0. But the output is 1.

Wait, maybe I'm missing something.

Wait, in this test case, n=4, arr=[0,1,2,3].

But the output is 1, not 0.

Wait, in my simulation above, c=[1,2], MEX is 0, but output is 1. So maybe that's not the optimal play.

Wait, perhaps Alice can choose differently.

Another simulation:

- Alice picks 0, a becomes [1,2,3], c = [0]

- Bob picks 1, a becomes [2,3], c = [0]

- Alice picks 2, a becomes [3], c = [0,2]

- Bob picks 3, a becomes empty, c = [0,2]

MEX is 1.

Alternatively:

- Alice picks 3, a becomes [0,1,2], c = [3]

- Bob picks 0, a becomes [1,2], c = [3]

- Alice picks 1, a becomes [2], c = [3,1]

- Bob picks 2, a becomes empty, c = [3,1]

MEX is 0.

So, in this case, depending on the choices, MEX can be 0 or 1.

But the output is 1, which is the higher value, so perhaps 1 is the optimal MEX that can be achieved.

Wait, but how?

Wait, maybe Alice can ensure that c contains 0 and 1, but in this case, n=4, arr=[0,1,2,3].

If Alice picks 0, then Bob picks 1, then Alice picks 2, Bob picks 3, c=[0,2], MEX=1.

Alternatively, Alice picks 1, Bob picks 0, Alice picks 2, Bob picks 3, c=[1,2], MEX=0.

So, in this case, depending on the choices, MEX can be 1 or 0.

But the output is 1, which is the higher value.

So, perhaps the optimal play leads to MEX=1.

Wait, but in one scenario, MEX=0.

So, perhaps Alice can force MEX=1 by choosing certain elements.

Wait, perhaps I need to think differently.

Let me consider the frequency of each number in the array.

In the first test case, arr=[0,0,1,1], frequencies: 0:2, 1:2.

In the second test case, arr=[0,1,2,3], frequencies: 0:1,1:1,2:1,3:1.

In the third test case, arr=[1,1], frequencies:1:2.

Now, looking at the code provided:

def func_1(arr):

freq = [0] * (n + 1)

for i in arr:

freq[i] += 1

cou = 0

for i in range(n + 1):

if freq[i] >= 2:

continue

if freq[i] == 1:

cou += 1

if cou == 2 or freq[i] == 0:

print(i)

break

So, it's iterating from 0 to n inclusive, and checking the frequency of each number.

If a number has frequency >=2, it's skipped.

If frequency ==1, cou is incremented.

If cou reaches 2 or frequency ==0, it prints that i and breaks.

So, in the first test case, freq=[2,2], so freq[0]>=2, skip; freq[1]>=2, skip; then i=2, freq[2]=0, so print 2.

In the second test case, freq=[1,1,1,1], so freq[0]==1, cou=1; freq[1]==1, cou=2, since cou==2, print 0.

Wait, but the output is 1, not 0.

Wait, maybe I'm misunderstanding.

Wait, let's see:

for i in range(n + 1):

if freq[i] >= 2:

continue

if freq[i] == 1:

cou += 1

if cou == 2 or freq[i] == 0:

print(i)

break

So, for second test case, n=4, arr=[0,1,2,3], freq=[1,1,1,1,0]

i=0: freq[0]==1, cou=1, cou !=2 and freq[0]!=0, so continue

i=1: freq[1]==1, cou=2, cou==2, print 1 and break

Hence, output is 1, which matches the sample output.

In the third test case, n=2, arr=[1,1], freq=[0,2], so:

i=0: freq[0]==0, cou not considered, since freq[i]==0, print 0 and break.

Hence, output is 0, which matches the sample output.

So, this seems to be correct for the sample inputs.

But is this logic generally correct?

Let me think about what this code is doing.

It's finding the smallest i such that either freq[i]==0 or it's the second time it's encountering freq[i]==1.

Wait, cou keeps track of how many numbers have freq==1.

Once cou reaches 2, it prints i, regardless of what i is.

Wait, in the second test case, i=1, freq[1]==1, cou=2, so print 1.

But in the first test case, i=2, freq[2]==0, print 2.

In the third test case, i=0, freq[0]==0, print 0.

So, it's essentially finding the minimum i where freq[i]==0, but considering the count of freq[i]==1.

But why?

Let's think about the game.

Alice wants to maximize MEX of c, Bob wants to minimize it.

Alice picks elements to include in c, Bob picks elements to exclude from c.

The MEX of c is the smallest non-negative integer not in c.

To maximize MEX, Alice wants c to contain as many small integers as possible.

To minimize MEX, Bob wants to prevent Alice from including small integers in c.

So, in the game, Alice is trying to include the smallest possible integers in c, while Bob is trying to exclude them.

Given that Alice picks and includes, and Bob picks and excludes, we need to see what the final c will look like when both play optimally.

Let me consider the frequency of each number.

If a number appears twice, then even if Bob tries to delete one occurrence, Alice can still pick the other one to include in c.

If a number appears only once, then Alice can pick it and include it in c, but Bob can also pick it and delete it.

So, for numbers that appear twice, Alice can ensure they are in c.

For numbers that appear once, it's a contest between Alice and Bob whether that number goes into c or not.

Wait, but the turns alternate, with Alice starting first.

The total number of turns is n, with Alice playing floor(n/2)+1 times (since she starts first), and Bob playing floor(n/2) times.

Wait, no. In total, there are n turns, alternating between Alice and Bob, starting with Alice.

So, Alice plays ceil(n/2) times, and Bob plays floor(n/2) times.

Wait, in the first test case, n=4, Alice plays 2 times, Bob plays 2 times.

In the second test case, n=4, same.

In the third test case, n=2, Alice plays 1 time, Bob plays 1 time.

Wait, generalizing, Alice plays ceil(n/2) times, Bob plays floor(n/2) times.

Now, Alice wants to include as many small integers as possible in c, to maximize MEX.

Bob wants to minimize MEX by preventing Alice from including small integers in c.

So, for numbers that appear twice, Alice can ensure they are in c, because even if Bob deletes one, Alice can pick the other.

For numbers that appear once, it's a contest between Alice and Bob.

Given that Alice has ceil(n/2) picks, and Bob has floor(n/2) picks, for numbers that appear once, Alice can include some of them in c, depending on the number of such numbers and the number of picks each has.

Wait, perhaps I need to think in terms of the available choices.

Let me sort the unique numbers in the array in ascending order.

Then, for the smallest numbers, Alice would want to include them in c.

But Bob would want to exclude them.

So, for each number, if it appears once, it's a contest between Alice and Bob to decide whether it goes into c or not.

If it appears twice, Alice can ensure it's in c.

So, the MEX will be the smallest number that is either not present in the array or, if present only once, decided by the parity of the number of available picks.

Wait, maybe I need to think in terms of the number of times Alice can pick elements compared to the number of unique numbers with frequency 1.

Let me define:

- Let S be the set of unique numbers in the array.

- For each number in S, if frequency >=2, Alice can ensure it's in c.

- If frequency ==1, it's a contest between Alice and Bob.

Let me count how many numbers have frequency ==1.

Let’s denote:

- Let d be the number of unique numbers with frequency >=2.

- Let s be the number of unique numbers with frequency ==1.

Then, Alice can include d numbers for sure.

Additionally, she can include floor((ceil(n/2) - d)/1) numbers from those with frequency ==1.

Wait, perhaps I need to think in terms of available picks.

Total picks Alice has: ceil(n/2).

Picks needed to include all numbers with frequency >=2: d.

Then, remaining picks Alice has: ceil(n/2) - d.

Number of numbers with frequency ==1: s.

Bob can exclude floor(n/2) numbers.

So, the numbers with frequency ==1 are contested between Alice and Bob.

Alice can include min(s, ceil(n/2) - d) of them.

Bob can exclude min(s, floor(n/2)) of them.

Wait, perhaps I need to think in terms of who gets to pick which numbers.

Let me try to formalize.

For each number with frequency >=2, Alice can include it in c.

For each number with frequency ==1, it's a contest between Alice and Bob.

If Alice picks it, it goes to c; if Bob picks it, it doesn't go to c.

Given that Alice has ceil(n/2) picks and Bob has floor(n/2) picks.

So, for the numbers with frequency ==1, Alice can include up to ceil(n/2) picks, but she has to include the ones she picks.

Bob can exclude up to floor(n/2) picks.

So, the question is, for the numbers with frequency ==1, how many can Alice include in c.

Let’s denote:

- Let s be the number of unique numbers with frequency ==1.

- Alice has ceil(n/2) picks to include them.

- Bob has floor(n/2) picks to exclude them.

The maximum number Alice can include is ceil(n/2) - the number of picks Bob can use to exclude them.

Wait, perhaps it's better to think in terms of the difference in picks.

If ceil(n/2) - floor(n/2) >= s, then Alice can include all s numbers.

Else, she can include ceil(n/2) - floor(n/2) numbers.

Wait, ceil(n/2) + floor(n/2) = n.

But ceil(n/2) - floor(n/2) is either 0 or 1, depending on whether n is even or odd.

So, if n is even, ceil(n/2) - floor(n/2) = 0.

If n is odd, ceil(n/2) - floor(n/2) = 1.

So, if n is even, Alice and Bob have the same number of picks.

If n is odd, Alice has one more pick than Bob.

So, for numbers with frequency ==1, Alice can include:

- If n is even: min(s, 0 + k), where k is some value.

Wait, perhaps it's better to think in terms of the difference in picks.

Let’s consider that Alice can include up to ceil(n/2) numbers with frequency ==1, but Bob can exclude up to floor(n/2) numbers with frequency ==1.

So, the net number Alice can include is max(0, ceil(n/2) - floor(n/2)).

Which is 0 if n is even, and 1 if n is odd.

Wait, yes, ceil(n/2) - floor(n/2) is 1 if n is odd, else 0.

Hence, if n is even, Alice can include 0 numbers with frequency ==1.

If n is odd, Alice can include 1 number with frequency ==1.

Wait, is that accurate?

Wait, no.

Wait, if n is even, ceil(n/2)=n/2, floor(n/2)=n/2.

So, ceil(n/2) - floor(n/2)=0.

If n is odd, ceil(n/2)=floor(n/2)+1.

So, ceil(n/2) - floor(n/2)=1.

Hence, Alice has one more pick than Bob when n is odd.

So, for numbers with frequency ==1, Alice can include:

- If n is even: 0, because Bob can match her picks.

- If n is odd: 1, because she has one extra pick.

Hence, for numbers with frequency ==1, Alice can include:

- 0 if n is even.

- 1 if n is odd.

Therefore, in c, the numbers included will be:

- All numbers with frequency >=2.

- Plus, if n is odd, one number with frequency ==1.

Now, the MEX is the smallest non-negative integer not in c.

So, to maximize MEX, Alice wants c to contain as many small integers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from including small integers in c.

Given the above, let's see how to compute the MEX.

Let's sort the unique numbers in ascending order.

Let's separate them into two groups:

- Those with frequency >=2.

- Those with frequency ==1.

Alice can include all from the first group and, if n is odd, one from the second group.

So, in c, we'll have all numbers from the first group and possibly one from the second group.

Now, to find the MEX, we look for the smallest integer not in c.

So, we need to see the sequence of integers in c.

Let's consider the sorted unique numbers.

Start from 0 upwards, check if each number is in c.

The first number missing from c is the MEX.

Given that, we can iterate from 0 to n+1, check the frequency of each number:

- If freq[i] >=2, it's in c.

- If freq[i] ==1, it's in c only if n is odd.

- If freq[i] ==0, it's not in c.

Hence, the MEX is the smallest i where either freq[i]==0 or (freq[i]==1 and (n is even or (n is odd and Alice didn't pick this particular freq[i]==1 number))).

Wait, but since Alice can pick only one freq[i]==1 number when n is odd, she will pick the smallest possible to maximize MEX.

Wait, but MEX is the smallest missing number, so to maximize it, Alice wants to have as many small numbers as possible in c.

Hence, for freq[i]==1, if n is odd, Alice will pick the smallest such i to include in c.

Hence, in the iteration from 0 to n+1, we can decide:

- If freq[i] >=2, it's in c.

- If freq[i]==1 and n is odd, it's in c (since Alice can pick one).

- If freq[i]==1 and n is even, it's not in c.

- If freq[i]==0, it's not in c.

Hence, the MEX is the smallest i where either freq[i]==0 or (freq[i]==1 and n is even).

Wait, but if n is odd, Alice can pick one freq[i]==1, so it's in c.

Hence, MEX is the smallest i where freq[i]==0 or (freq[i]==1 and n is even).

Wait, but if n is odd, and freq[i]==1, it's in c, so it shouldn't contribute to MEX.

Wait, perhaps I need to refine this.

Let me think again.

If freq[i] >=2, it's in c.

If freq[i]==1 and n is odd, it's in c.

If freq[i]==1 and n is even, it's not in c.

If freq[i]==0, it's not in c.

Hence, MEX is the smallest i where freq[i]==0 or (freq[i]==1 and n is even).

Wait, but in the second test case, n=4 (even), arr=[0,1,2,3], freq=[1,1,1,1,0].

So, for i=0: freq=1, n even -> not in c.

Hence, MEX=0.

But the sample output is 1.

Wait, that's inconsistent.

Hence, perhaps my earlier assumption is wrong.

Wait, perhaps I need to consider that when n is even, and freq[i]==1, it's not in c, but if there are multiple such i, Alice and Bob are competing to pick them.

Wait, perhaps my earlier conclusion that when n is even, Alice can't pick any freq[i]==1 is incorrect.

Wait, perhaps I need to think in terms of the number of freq[i]==1.

Let’s denote s = number of unique numbers with freq[i]==1.

If s <= floor(n/2), then Bob can exclude all of them.

Hence, none of them are in c.

Hence, MEX is the smallest i where freq[i]==0.

If s > floor(n/2), then Alice can include s - floor(n/2) of them.

Hence, in c, we have all freq[i]>=2 and s - floor(n/2) of freq[i]==1.

But this seems complicated.

Perhaps a better way is to iterate through i from 0 to n+1, and decide whether i is in c or not.

For each i:

- If freq[i] >=2, it's in c.

- If freq[i]==1, it's in c if s - floor(n/2) > 0, where s is the number of unique numbers with freq[j]==1 and j <= i.

Wait, this might be a way.

Let me try to formalize it.

For each i from 0 to n+1:

- If freq[i] >=2, it's in c.

- If freq[i]==1, it's in c if the number of freq[j]==1 for j <= i is greater than floor(n/2).

- If freq[i]==0, it's not in c.

Wait, perhaps not exactly.

Let me think differently.

Let’s precompute:

- d = number of unique numbers with freq[i] >=2.

- s = number of unique numbers with freq[i]==1.

Then, Alice can include d + min(s, ceil(n/2) - d) numbers in c.

But this seems too vague.

Wait, perhaps I should look back at the provided code.

The provided code is:

def func_1(arr):

freq = [0] * (n + 1)

for i in arr:

freq[i] += 1

cou = 0

for i in range(n + 1):

if freq[i] >= 2:

continue

if freq[i] == 1:

cou += 1

if cou == 2 or freq[i] == 0:

print(i)

break

So, it's iterating from 0 to n+1, and looking for the smallest i where either freq[i]==0 or cou==2.

Wait, cou is the count of numbers with freq[i]==1.

Wait, no, cou is incremented when freq[i]==1.

Hence, it's looking for the smallest i where:

- freq[i]==0, or

- freq[i]==1 and cou==2.

Wait, that doesn't seem right.

Wait, in the code:

for i in range(n + 1):

if freq[i] >= 2:

continue

if freq[i] == 1:

cou += 1

if cou == 2 or freq[i] == 0:

print(i)

break

So, for each i in order:

- If freq[i] >=2, skip.

- If freq[i]==1, increment cou.

- If cou==2 or freq[i]==0, print i and break.

Hence, it's finding the smallest i where either freq[i]==0 or it's the second time freq[i]==1.

Wait, in the second test case, n=4, arr=[0,1,2,3], freq=[1,1,1,1,0]

So, i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, so continue.

i=1: freq[1]==1, cou=2, cou==2, so print 1.

Hence, output is 1.

In the first test case, n=4, arr=[0,0,1,1], freq=[2,2], so i=0: freq[0]>=2, skip; i=1: freq[1]>=2, skip; i=2: freq[2]==0, print 2.

In the third test case, n=2, arr=[1,1], freq=[0,2], so i=0: freq[0]==0, print 0.

So, it seems to work for the sample inputs.

But is this logic correct in general?

Let me consider another test case.

Test case:

n=3, arr=[0,1,1]

freq=[1,2]

So, freq[0]==1, freq[1]==2

Iterate:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]>=2, skip.

i=2: freq[2]==0, print 2.

But in this case, let's simulate the game.

Alice starts.

- Alice picks 0, a becomes [1,1], c=[0]

- Bob picks 1, a becomes [1], c=[0]

- Alice picks 1, a becomes empty, c=[0,1]

Hence, c=[0,1], MEX=2.

Which matches the output of the code.

Another test case:

n=5, arr=[0,1,2,3,4]

freq=[1,1,1,1,1,0]

Iterate:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]==1, cou=2, cou==2, print 1.

Hence, output is 1.

Simulate the game:

- Alice picks 0, a=[1,2,3,4], c=[0]

- Bob picks 1, a=[2,3,4], c=[0]

- Alice picks 2, a=[3,4], c=[0,2]

- Bob picks 3, a=[4], c=[0,2]

- Alice picks 4, a=[], c=[0,2,4]

Hence, c=[0,2,4], MEX=1.

Which matches the output of the code.

Another test case:

n=1, arr=[0]

freq=[1], n=1, ceil(n/2)=1, floor(n/2)=0.

Alice picks 0, a becomes empty, c=[0]

MEX is 1.

But according to the code:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]==0, print 1.

Which matches.

Another test case:

n=2, arr=[0,0]

freq=[2], n=2, ceil(n/2)=1, floor(n/2)=1.

- Alice picks 0, a=[0], c=[0]

- Bob picks 0, a=[], c=[0]

MEX is 1.

According to the code:

i=0: freq[0]>=2, skip.

i=1: freq[1]==0, print 1.

Which matches.

Another test case:

n=2, arr=[0,1]

freq=[1,1], n=2, ceil(n/2)=1, floor(n/2)=1.

- Alice picks 0, a=[1], c=[0]

- Bob picks 1, a=[], c=[0]

MEX is 1.

According to the code:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]==1, cou=2, cou==2, print 1.

Which matches.

Another test case:

n=3, arr=[0,1,1]

freq=[1,2], n=3, ceil(n/2)=2, floor(n/2)=1.

- Alice picks 0, a=[1,1], c=[0]

- Bob picks 1, a=[1], c=[0]

- Alice picks 1, a=[], c=[0,1]

MEX is 2.

According to the code:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]>=2, skip.

i=2: freq[2]==0, print 2.

Which matches.

Another test case:

n=6, arr=[0,0,1,1,2,2]

freq=[2,2,2], n=6, ceil(n/2)=3, floor(n/2)=3.

- Alice picks 0, a=[0,1,1,2,2], c=[0]

- Bob picks 0, a=[1,1,2,2], c=[0]

- Alice picks 1, a=[1,2,2], c=[0,1]

- Bob picks 1, a=[2,2], c=[0,1]

- Alice picks 2, a=[2], c=[0,1,2]

- Bob picks 2, a=[], c=[0,1,2]

MEX is 3.

According to the code:

i=0: freq[0]>=2, skip.

i=1: freq[1]>=2, skip.

i=2: freq[2]>=2, skip.

i=3: freq[3]==0, print 3.

Which matches.

Seems consistent.

Another test case:

n=5, arr=[0,1,2,3,3]

freq=[1,1,1,2], n=5, ceil(n/2)=3, floor(n/2)=2.

- Alice picks 0, a=[1,2,3,3], c=[0]

- Bob picks 1, a=[2,3,3], c=[0]

- Alice picks 2, a=[3,3], c=[0,2]

- Bob picks 3, a=[3], c=[0,2]

- Alice picks 3, a=[], c=[0,2,3]

MEX is 1.

According to the code:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]==1, cou=2, cou==2, print 1.

Which matches.

Another test case:

n=4, arr=[0,1,1,1]

freq=[1,3], n=4, ceil(n/2)=2, floor(n/2)=2.

- Alice picks 0, a=[1,1,1], c=[0]

- Bob picks 1, a=[1,1], c=[0]

- Alice picks 1, a=[1], c=[0,1]

- Bob picks 1, a=[], c=[0,1]

MEX is 2.

According to the code:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]>=2, skip.

i=2: freq[2]==0, print 2.

Which matches.

Seems like the code is correct.

But to be thorough, let's consider a case where there are multiple numbers with freq==1.

Test case:

n=4, arr=[0,1,2,2]

freq=[1,1,2], n=4, ceil(n/2)=2, floor(n/2)=2.

- Alice picks 0, a=[1,2,2], c=[0]

- Bob picks 1, a=[2,2], c=[0]

- Alice picks 2, a=[2], c=[0,2]

- Bob picks 2, a=[], c=[0,2]

MEX is 1.

According to the code:

i=0: freq[0]==1, cou=1, cou !=2, freq[i]!=0, continue.

i=1: freq[1]==1, cou=2, cou==2, print 1.

Which matches.

Another test case:

n=5, arr=[0,1,1,2,2]

freq=[1,2,2], n=5, ceil(n/2)=3, floor(n/2)=2.

- Alice picks 0, a