Alright, I've got this problem to solve. Let's see what it's about. So, there's this game between Alice and Bob where they're playing with an array of integers. Alice starts with an empty array 'c', and they take turns making moves. Alice's move is to pick an element from 'a', append it to 'c', and delete it from 'a'. Bob, on the other hand, just picks an element from 'a' and deletes it. The game ends when 'a' is empty, and the score is the MEX of 'c', which is the smallest non-negative integer not present in 'c'. Alice wants to maximize this MEX, while Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand what MEX is. From the description, MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. For [3,1,0,1], it's 2, and for [0,3,1,2], it's 4. So, essentially, it's the smallest missing number in the array, starting from 0.

Now, Alice and Bob are playing this game, with Alice going first, and they have different objectives. Alice wants to maximize the MEX, meaning she wants the smallest missing number in 'c' to be as large as possible. Bob, however, wants to minimize it. They both play optimally, which means they make the best possible moves to achieve their goals.

I need to figure out what strategies Alice and Bob would use to achieve their objectives. Let's think about how the game progresses.

The game alternates between Alice and Bob, with Alice starting. In each turn:

- Alice picks an element from 'a', appends it to 'c', and deletes it from 'a'.

- Bob picks an element from 'a', deletes it, and does not add it to 'c'.

The game ends when 'a' is empty, and the score is the MEX of 'c'.

Since Alice wants to maximize the MEX of 'c', she would want 'c' to contain as many small non-negative integers as possible, in order, starting from 0. Bob, wanting to minimize the MEX, would try to prevent Alice from achieving this by removing elements that Alice might need.

Let's consider the frequency of each number in 'a'. If a number appears only once in 'a', then if Alice picks it, it goes into 'c', and if Bob picks it, it's removed from the game altogether. If a number appears multiple times, then some instances can be picked by Alice to put into 'c', while others can be removed by Bob.

I think it would be helpful to count the frequency of each number in 'a'. Let's denote the frequency of each number from 0 to n (since a_i < n) as freq[0], freq[1], ..., freq[n].

Now, Alice and Bob are playing optimally. Alice wants to include as many small numbers in 'c' as possible, while Bob wants to disrupt this as much as he can.

Let's consider the smallest numbers first. For example, let's start with 0.

- If freq[0] >= 2, then Alice can ensure that at least one 0 makes it into 'c', because she can pick one 0, and Bob can remove another 0. So, Alice can always include 0 in 'c'.

- If freq[0] == 1, then Alice can pick the 0 and put it into 'c', or Bob can pick it and remove it from the game. So, Alice can choose to include 0 in 'c', but Bob can choose to remove it.

- If freq[0] == 0, then 0 is not present in 'a', so it won't be in 'c', and MEX would be 0.

Wait, but MEX is the smallest non-negative integer not in 'c'. So, if 0 is not in 'c', then MEX is 0, regardless of other numbers.

But the problem says that a_i >= 0, so 0 is a possible value in 'a'.

I need to think carefully about how to approach this.

Maybe I should think in terms of available moves and who can control the inclusion or exclusion of certain numbers.

Let's consider that the total number of moves is n, with Alice making ceil(n/2) moves (since she starts and they alternate).

Wait, no. Let's think again.

Total moves are n, with Alice making the first move, then Bob, then Alice, and so on.

So, if n is even, Alice makes n/2 moves, and Bob makes n/2 moves.

If n is odd, Alice makes (n+1)/2 moves, and Bob makes (n-1)/2 moves.

But in terms of inclusion in 'c', only Alice's moves add elements to 'c'.

So, the size of 'c' at the end of the game is equal to the number of times Alice has played, which is ceil(n/2).

But I need to maximize the MEX in 'c', considering that Bob is trying to minimize it.

Let me consider a simple example to get some intuition.

Example 1:

n = 4

a = [0,0,1,1]

Possible game:

- Alice picks 1 and adds to c, so c = [1], a = [0,0,1]

- Bob picks 0 and removes it, a = [0,1]

- Alice picks 0 and adds to c, c = [1,0], a = [1]

- Bob picks 1 and removes it, a = []

Final c = [1,0], MEX = 2

Another possible game:

- Alice picks 0 and adds to c, c = [0], a = [0,1,1]

- Bob picks 1 and removes it, a = [0,1]

- Alice picks 1 and adds to c, c = [0,1], a = [0]

- Bob picks 0 and removes it, a = []

Final c = [0,1], MEX = 2

Alternatively:

- Alice picks 1 and adds to c, c = [1], a = [0,0,1]

- Bob picks 1 and removes it, a = [0,0]

- Alice picks 0 and adds to c, c = [1,0], a = [0]

- Bob picks 0 and removes it, a = []

Final c = [1,0], MEX = 2

In all these scenarios, MEX is 2.

So, apparently, Alice can ensure that c contains at least 0 and 1, making MEX = 2.

Now, let's look at example 2:

n = 4

a = [0,1,2,3]

Possible game:

- Alice picks 0 and adds to c, c = [0], a = [1,2,3]

- Bob picks 1 and removes it, a = [2,3]

- Alice picks 2 and adds to c, c = [0,2], a = [3]

- Bob picks 3 and removes it, a = []

Final c = [0,2], MEX = 1

Another possible game:

- Alice picks 1 and adds to c, c = [1], a = [0,2,3]

- Bob picks 0 and removes it, a = [2,3]

- Alice picks 2 and adds to c, c = [1,2], a = [3]

- Bob picks 3 and removes it, a = []

Final c = [1,2], MEX = 0

But in this case, MEX is 0 because 0 is not in c.

But Alice could have chosen differently to include 0.

So, perhaps Alice can choose to pick 0 in her first move, ensuring 0 is in c, and then pick another number.

- Alice picks 0 and adds to c, c = [0], a = [1,2,3]

- Bob picks 1 and removes it, a = [2,3]

- Alice picks 2 and adds to c, c = [0,2], a = [3]

- Bob picks 3 and removes it, a = []

Final c = [0,2], MEX = 1

Alternatively:

- Alice picks 0 and adds to c, c = [0], a = [1,2,3]

- Bob picks 2 and removes it, a = [1,3]

- Alice picks 1 and adds to c, c = [0,1], a = [3]

- Bob picks 3 and removes it, a = []

Final c = [0,1], MEX = 2

So, depending on Bob's moves, MEX can be 1 or 2. But Bob wants to minimize MEX, so he would choose the move that leads to MEX = 1.

Hence, the minimal MEX Alice can achieve, with Bob trying to minimize it, is 1.

Wait, but in one scenario, MEX is 2. How does that work?

I think I need to think more carefully about Bob's strategy.

Bob wants to minimize the MEX, so he would try to prevent Alice from including certain numbers in 'c'.

In the first scenario, Bob removes 1, leading to c = [0,2], MEX = 1.

In the second scenario, Bob removes 2, leading to c = [0,1], MEX = 2.

So, Bob can choose to minimize MEX by removing 1, ensuring that c doesn't have 1, hence MEX = 1.

Therefore, the minimal MEX Alice can achieve, with Bob playing optimally to minimize it, is 1.

Hence, the answer should be 1 for this test case.

Now, looking at the third example:

n = 2

a = [1,1]

Possible game:

- Alice picks 1 and adds to c, c = [1], a = [1]

- Bob picks 1 and removes it, a = []

Final c = [1], MEX = 0

Alternatively:

- Alice picks 1 and adds to c, c = [1], a = [1]

- Bob picks 1 and removes it, a = []

Final c = [1], MEX = 0

So, MEX is 0 in both cases.

Hence, the answer is 0.

From these examples, it seems that the MEX depends on whether Alice can include certain numbers in 'c', despite Bob's attempts to remove them.

I need to find a general strategy for Alice and Bob.

Let's consider the frequency of each number.

For each number i from 0 to n:

- If freq[i] >= 2, then Alice can ensure that at least one i is in 'c', because even if Bob removes one, Alice can pick the other.

- If freq[i] == 1, then Alice can pick it and add it to 'c', but Bob can also pick it and remove it.

- If freq[i] == 0, then i cannot be in 'c'.

So, for numbers with freq >= 2, Alice can ensure their inclusion in 'c'.

For numbers with freq == 1, it's a battle between Alice and Bob: Alice wants to include it in 'c', Bob wants to remove it.

Given that, I need to determine which numbers from the ones with freq == 1 will be included in 'c'.

Since Alice starts, and they alternate turns, the player who has the turn gets to choose which element to pick.

But Bob can only remove elements, while Alice can choose to add specific elements to 'c'.

This seems a bit tricky.

Maybe I need to think in terms of the number of elements with freq == 1.

Let's denote:

- Let S be the set of numbers with freq >= 2.

- Let T be the set of numbers with freq == 1.

For S, Alice can ensure that all elements in S are in 'c'.

For T, it's more complicated.

The game is that Alice and Bob take turns, with Alice starting, and Alice can choose to add elements from T to 'c', while Bob can choose to remove elements from T.

I need to find out how many elements from T Alice can include in 'c', given that Bob is trying to minimize that.

Let's think about the number of elements in T.

Let's say |T| = k.

Alice and Bob will have ceil(k/2) and floor(k/2) moves respectively in T.

Wait, no.

Actually, the total number of moves in the game is n, with Alice making ceil(n/2) moves and Bob making floor(n/2) moves.

But in T, the number of moves related to T is equal to |T|.

Out of these |T| moves, Alice can make ceil(|T| / 2) moves to include elements in 'c', and Bob can make floor(|T| / 2) moves to remove elements from 'c'.

Wait, but Bob can only remove elements, not add them.

Wait, no.

Actually, Bob picks an element from 'a' and deletes it, regardless of whether it's in T or not.

But in terms of T, for elements in T, if Alice picks them, they go to 'c'; if Bob picks them, they are removed.

So, for each element in T, it can either be in 'c' (if Alice picks it) or removed (if Bob picks it).

Given that, the number of elements from T that end up in 'c' is equal to the number of times Alice picks elements from T.

Since Alice has ceil(|T| / 2) picks in T, she can choose to pick the elements she wants to include in 'c'.

But Bob can choose to pick the elements he wants to remove.

Wait, perhaps it's better to think in terms of available picks.

Total elements in T: k.

Alice can choose ceil(k / 2) elements from T to include in 'c', and Bob can choose floor(k / 2) elements from T to remove.

Hence, the number of elements from T that are in 'c' is ceil(k / 2).

Wait, but Bob can choose which elements to remove.

Wait, no.

Actually, since Bob can only remove elements, and Alice can choose which elements to include in 'c', but Bob can choose which elements to remove.

So, Bob can choose to remove elements that Alice wants to include in 'c'.

Wait, perhaps I need to think differently.

Let's consider that for each element in T, there is a chance it gets included in 'c' if Alice picks it before Bob does.

Since Alice starts, she can pick an element from T, include it in 'c', unless Bob picks it first.

Wait, but Bob can only remove elements, not add them.

Wait, no.

Actually, both pick elements from 'a', but Alice adds the picked element to 'c' and removes it from 'a', while Bob just removes it from 'a'.

So, for elements in T, which have only one copy:

- If Alice picks it, it goes to 'c'.

- If Bob picks it, it is removed.

Since Alice starts, she can pick an element from T and add it to 'c'.

Then, Bob can pick another element from T and remove it.

Then Alice can pick another element from T and add it to 'c', and so on.

So, effectively, Alice can include ceil(|T| / 2) elements from T in 'c'.

Because she gets to make ceil(|T| / 2) moves in T.

Hence, the total number of elements in 'c' from S is equal to |S| (since freq[s] >= 2), and from T is ceil(|T| / 2).

Wait, but freq[s] >= 2, but Alice might not pick all of S, but since she can pick multiple times, she can pick all elements from S to include in 'c'.

But actually, since freq[s] >= 2, and Alice can pick one, and Bob can pick another, but Alice can pick again.

Wait, no.

Wait, for elements with freq >= 2, Alice can ensure that at least one is in 'c', because even if Bob removes one, there's another one left.

But actually, for freq >= 2, Alice can include one in 'c', and Bob can remove another, but Alice can pick again.

Wait, but if freq[s] >= 2, Alice can include one in 'c', and Bob can remove another, but then Alice can pick another one and include it in 'c' again.

Wait, no.

Wait, if freq[s] >= 2, then Alice can include one in 'c', and Bob can remove another, but then Alice can pick another one and include it in 'c' again, but Bob can remove another one, and so on.

Actually, for freq[s] >= 2, Alice can include one in 'c', and Bob can remove another, but Alice can pick again and include another one in 'c', and so on.

But in reality, for each freq[s] >= 2, Alice can include floor(freq[s] / 2) elements in 'c', because for every two, she can include one, and Bob can remove one.

Wait, perhaps I need to think differently.

Let me try to think in terms of available moves.

Total moves: n, with Alice making ceil(n / 2) moves and Bob making floor(n / 2) moves.

Alice wants to include as many small numbers in 'c' as possible, while Bob wants to prevent that.

So, perhaps I need to iterate through the numbers from 0 to n and decide whether Alice can include them in 'c' or not.

Let's consider the numbers in order from 0 to n.

For each number i:

- If freq[i] >= 2, Alice can include it in 'c', regardless of Bob's actions.

- If freq[i] == 1, Alice can include it in 'c' if she picks it before Bob does.

Given that Alice starts, she can pick a element in her first move.

Then Bob picks, and so on.

So, for elements with freq == 1, Alice can include ceil(freq[i] / 2) in 'c', which is 1 if freq[i] is odd, and 0 if even.

Wait, but freq[i] is either 0, 1, or more.

Wait, no, in this case, freq[i] is either 0, 1, or >=2.

So, for freq[i] >=2, Alice can include floor(freq[i]/2) in 'c'.

Wait, perhaps I need to think in terms of the number of times Alice can pick an element from a group with freq[i].

But this seems to get complicated.

Maybe there's a better way.

Let me look back at the examples.

In the first example:

n=4

a=[0,0,1,1]

freq[0]=2, freq[1]=2

So, for both 0 and 1, freq >=2, so Alice can include one of each in 'c'.

Hence, c can have [0,1], MEX=2.

In the second example:

n=4

a=[0,1,2,3]

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

So, for each number from 0 to 3, freq=1.

Alice can include ceil(4 / 2) = 2 elements in 'c'.

So, she can include 2 out of these 4 elements.

To maximize MEX, she would want to include the smallest possible numbers.

So, include 0 and 1, making c=[0,1], MEX=2.

But in the explanation, it says the answer is 1.

Wait, but in the example output, it's 1 for this case.

Wait, perhaps I misread.

Wait, in the second test case, n=4, a=[0,1,2,3], output=1.

Wait, but according to my previous logic, if Alice includes 0 and 1, MEX=2.

But the output is 1, so perhaps I'm missing something.

Wait, maybe Bob can interfere and force a lower MEX.

Let me think again.

If Alice picks 0 and includes it in 'c', then Bob can pick 1 and remove it.

Then Alice picks 2 and includes it in 'c', and Bob picks 3 and removes it.

So, c=[0,2], MEX=1.

Alternatively, if Alice picks 1 and includes it in 'c', Bob picks 0 and removes it.

Alice picks 2 and includes it in 'c', Bob picks 3 and removes it.

So, c=[1,2], MEX=0.

Bob can choose the moves to minimize MEX.

Hence, the minimal MEX Alice can achieve, with Bob playing optimally, is 1.

Hence, the answer is 1.

So, perhaps the general strategy is that Alice can include ceil(|T| / 2) elements from T in 'c', where T is the set of elements with freq==1.

Then, the MEX would be the smallest number not included in 'c'.

Wait, but in the second example, |T|=4, ceil(4/2)=2, so Alice can include 2 elements in 'c'.

Hence, c would have 2 elements: 0 and 1, assuming she picks them.

But in reality, Bob can force c to be [0,2] or [1,2], leading to MEX=1 or 0.

But according to the output, it's 1.

Wait, perhaps I need to consider that Bob can force the MEX to be 1 by removing a critical element.

Wait, perhaps I need to think differently.

Let me consider that Alice can include ceil(|T| / 2) elements from T in 'c'.

But Bob can choose which elements to remove to minimize the MEX.

Hence, Bob would try to remove elements that Alice wants to include to maximize MEX.

Wait, no.

Bob wants to minimize MEX, so he would want to prevent Alice from including small numbers in 'c'.

So, in the second example, if Alice picks 0, Bob picks 1, Alice picks 