Alright, I have this problem to solve. Let's see what it's about. So, Sasha wants to earn a lot of money by going to a casino. The casino has some specific rules for betting, and there's also a promotion where Sasha can't lose more than a certain number of times in a row. I need to determine whether, given these rules, Sasha can always reach any target amount of money by making bets in a certain way.

First, I need to understand the betting rules:

1. If Sasha bets y coins and wins, he gets y * k coins in return. So, his coins increase by y * (k - 1).

2. If he loses, he loses the entire bet amount y.

Also, the bet amount y must be a positive integer and cannot exceed his current number of coins.

Additionally, there's a promotion: Sasha can't lose more than x times in a row.

Sasha starts with a coins, and I need to determine if he can make bets in such a way that he can reach any target amount n, no matter what the outcomes of his bets are, as long as they don't violate the rules.

Okay, so for each test case, I'm given k (the multiplier for winning bets), x (the maximum number of consecutive losses), and a (the initial number of coins). I need to output "YES" if Sasha can reach any n with some betting strategy, and "NO" otherwise.

Looking at the example:

Input:

9

2 1 7

2 1 1

2 3 15

3 3 6

4 4 5

5 4 7

4 88 1000000000

25 69 231

13 97 18806

Output:

YES

NO

YES

NO

NO

YES

NO

NO

NO

So, for the first test case, k=2, x=1, a=7 → YES

Second: k=2, x=1, a=1 → NO

Third: k=2, x=3, a=15 → YES

And so on.

I need to find a pattern or a condition that determines when the answer is YES and when it's NO.

Let me try to understand what it means to "be guaranteed to win any number of coins." It means that no matter how the wins and losses occur (as long as they don't exceed x consecutive losses), Sasha can always make bets in a way that he can reach any target n.

I think this is related to the concept of "gambler's ruin" or some sort of stochastic process, but maybe there's a simpler way to look at it.

Perhaps I can think in terms of the maximum possible loss sequence and see if Sasha can recover from it.

Given that Sasha can't lose more than x times in a row, any sequence of losses longer than x is invalid. So, in the worst case, Sasha can have up to x consecutive losses.

I need to ensure that even after x losses, Sasha can still make bets in a way that allows him to grow his capital to any desired amount.

Let me consider the maximum amount Sasha can lose in x consecutive losses.

If Sasha bets y1, y2, ..., yx and loses all of them, his total loss is y1 + y2 + ... + yx.

After x losses, the next bet must be a win because he can't have more than x consecutive losses.

So, after x losses, the next bet y_{x+1} must be a win, giving him y_{x+1} * k coins.

I need to choose the bet amounts y1, y2, ..., yx+1 in such a way that after x losses and one win, Sasha can continue betting to reach any n.

This seems complicated. Maybe there's a better way.

Wait, perhaps I can think in terms of the total potential loss and see if Sasha's initial amount covers that.

Let me consider the maximum possible loss Sasha can incur without violating the rules.

If Sasha can lose up to x times in a row, the maximum loss would be the sum of the bet amounts for x losses.

But the bet amounts can be chosen strategically; maybe Sasha can choose bet amounts that are increasing or decreasing in some way to manage his capital.

This is getting tricky. Maybe I should look for a condition that relates k, x, and a.

Looking back at the example:

First test case: k=2, x=1, a=7 → YES

So, if x=1, meaning Sasha can't lose more than once in a row, and k=2, and a=7.

What does this mean? If Sasha loses once, he can't lose again; his next bet must be a win.

So, if he bets y1 and loses, he has a - y1 left, then he must win the next bet.

But the next bet can't exceed his current coins, which is a - y1.

If he wins that bet, he gets y2 * k = y2 * 2.

So, his total coins become (a - y1) + y2 * 2.

But I need to choose y1 and y2 in such a way that he can reach any n.

This seems too vague. Maybe there's a mathematical formula or a known strategy for this.

Wait, perhaps this is similar to the Martingale betting system, where you double your bet after every loss to recoup the losses when you finally win.

But in this problem, the multiplier is k, which may not be 2, and Sasha can't lose more than x times in a row.

So, maybe a generalized version of the Martingale system.

In the Martingale system, if you can have infinite wealth and no betting limits, you can always recover losses with one win.

But here, Sasha has a finite initial amount a, and there are limits on consecutive losses.

So, perhaps I need to calculate the maximum potential loss Sasha can incur with x consecutive losses and ensure that his initial amount a is sufficient to cover those losses and still allow him to make a winning bet to grow his capital.

Wait, maybe I need to calculate the sum of a geometric series or something similar.

Let me try to model this.

Let's assume Sasha bets y coins each time.

If he loses x times in a row, he loses x * y coins.

Then, on the next bet, he must win, and he bets y coins again, winning y * k coins.

So, his total coins after x losses and one win would be:

a - x * y + y * k = a + y * (k - x)

But I'm not sure if this is helpful.

Maybe I need to consider that after x losses, the next bet must be a win, and I need to choose y such that a - x * y >= y, because he needs to have enough coins left to make the next bet.

Wait, more generally, after x losses, he must have at least y coins left to make the next bet.

So, a - x * y >= y, which implies a >= y * (x + 1)

But y can be chosen strategically; maybe it's not fixed.

Perhaps y should be as small as possible to minimize the loss, but then the win might not be sufficient to grow the capital.

This seems complicated.

Let me think differently.

Suppose Sasha wants to reach a very large n.

He needs to make a series of bets where the wins are significant enough to grow his capital exponentially, but he has to manage the risks of losing up to x times in a row.

Given that k >= 2, each win multiplies his bet by k, which is at least doubling.

But with the constraint of not losing more than x times consecutively, he needs a strategy to recover from x losses and keep growing.

I recall that in betting systems, the idea is to adjust the bet size based on previous outcomes to manage risk and reward.

Perhaps Sasha should choose his bet amounts in such a way that after x losses, the next win can cover all previous losses and still make progress.

Let me try to formalize this.

Let’s denote the bet amounts as y1, y2, ..., ym.

If he loses x times in a row, his losses are y1 + y2 + ... + yx.

Then, the next bet y_{x+1} must be a win, giving him y_{x+1} * k coins.

To recover the losses and make progress, he needs:

y_{x+1} * k >= y1 + y2 + ... + yx + y_{x+1}

Simplifying:

y_{x+1} * (k - 1) >= y1 + y2 + ... + yx

So, y_{x+1} >= (y1 + y2 + ... + yx) / (k - 1)

This suggests that the next bet after x losses should be at least the total previous losses divided by (k - 1).

But this seems too vague. Maybe there's a better way to approach this.

Let me consider the maximum possible loss Sasha can incur.

If he can lose up to x times in a row, and each loss is a certain bet amount, the total maximum loss is the sum of the bet amounts for x losses.

But again, the bet amounts can be chosen strategically.

Perhaps I can think in terms of the total potential loss being covered by the initial amount a.

So, a needs to be at least the maximum possible loss plus the bet required to make progress.

But I need a more concrete approach.

Let me consider the binary tree of possible outcomes.

Each bet has two possibilities: win or lose.

But with the constraint that losing more than x times in a row is impossible, some paths are invalid.

I need to ensure that, no matter the sequence of wins and losses (as long as there are no more than x consecutive losses), Sasha can always reach n.

This seems too broad. Maybe I need to find a condition on a, k, and x that guarantees this.

Looking at the sample input and output:

First test case: k=2, x=1, a=7 → YES

Second: k=2, x=1, a=1 → NO

Third: k=2, x=3, a=15 → YES

Fourth: k=3, x=3, a=6 → NO

Fifth: k=4, x=4, a=5 → NO

Sixth: k=5, x=4, a=7 → YES

Seventh: k=4, x=88, a=1000000000 → NO

Eighth: k=25, x=69, a=231 → NO

Ninth: k=13, x=97, a=18806 → NO

From this, it seems that for some values of k and x, there is a threshold on a below which it's impossible to guarantee reaching any n.

I need to find that threshold.

Perhaps there's a formula that relates a, k, and x.

Let me try to derive such a formula.

Suppose Sasha can lose up to x times in a row.

After x losses, the next bet must be a win.

So, the maximum loss is the sum of x bets.

But the bets can be chosen in a way to minimize the required a.

Perhaps Sasha should choose the bet amounts in increasing order, so that the potential loss is minimized.

Wait, actually, to minimize the required a, maybe Sasha should choose the bet amounts in such a way that each bet is as small as possible, but still allows progress.

Let’s consider that after x losses, the next win should cover all previous losses and allow for further betting.

Let me try to calculate the minimum a required for given k and x.

Let’s denote s as the sum of all possible losses in a sequence of x losses.

Then, a needs to be at least s.

But s depends on the bet amounts.

Let’s assume that after each win, Sasha resets his bet to a certain value.

This seems too vague.

Maybe I should consider that the maximum possible loss is the sum of a geometric series.

Wait, perhaps I can model this using the concept of a martingale system.

In a martingale system, you double your bet after each loss, so that when you win, you recover all previous losses plus a profit equal to the original bet.

But here, the multiplier is k, not necessarily 2.

So, if Sasha bets y1, y2, ..., yx and loses all of them, then bets y_{x+1} and wins, he should have:

y_{x+1} * k >= y1 + y2 + ... + yx + y_{x+1}

Which simplifies to:

y_{x+1} >= (y1 + y2 + ... + yx) / (k - 1)

To minimize a, perhaps Sasha should choose y1, y2, ..., yx in such a way that y_{x+1} is minimized.

But this is getting too complicated.

Let me try to find a pattern in the sample inputs.

Looking at the first test case: k=2, x=1, a=7 → YES

So, x=1 means Sasha can't lose more than once in a row.

If he loses once, the next bet must be a win.

So, if he bets y1 and loses, he has a - y1 left, then bets y2 and wins, getting y2 * 2.

So, his total becomes a - y1 + y2 * 2.

To make progress, a - y1 + y2 * 2 > a, which implies y2 * 2 > y1.

If he chooses y2 = y1, then 2 * y1 > y1, which is true.

But he needs to choose y2 such that y2 <= a - y1.

Also, from earlier, y2 >= y1 / (k - 1) = y1 / 1 = y1.

So, y2 >= y1.

But he also has a - y1 >= y2.

So, a - y1 >= y1, which implies a >= 2 * y1.

To maximize y1, set y1 = floor(a / 2).

For a=7, y1=3, then y2=3, and after losing y1 and winning y2*2, he has 7 - 3 + 6 = 10, which is greater than 7.

So, he can grow his capital.

Similarly, for a=1, if he bets y1=1 and loses, he has 0 left, and can't make any more bets.

Hence, NO.

Okay, that makes sense.

Now, for k=2 and x=1, the minimum a required seems to be 2 * y1, where y1 is the initial bet.

But I need to generalize this for any k and x.

Let me try to find a general formula.

Suppose Sasha can lose up to x times in a row.

After x losses, the next bet must be a win.

Let’s denote the bet amounts as y1, y2, ..., yx, y_{x+1}.

Total loss from x losses: y1 + y2 + ... + yx.

After x losses, he bets y_{x+1} and wins, getting y_{x+1} * k.

So, his total coins after x losses and one win is:

a - (y1 + y2 + ... + yx) + y_{x+1} * k

To make progress, this should be greater than a.

So:

- (y1 + y2 + ... + yx) + y_{x+1} * k > 0

But since y1 to yx are positive, and y_{x+1} * k is positive, this will always be true if a is large enough.

But I need to ensure that a is at least the sum of y1 to yx plus the required y_{x+1}.

Wait, perhaps I need to consider the total amount needed to cover all possible loss sequences.

This seems similar to the concept of a "bankroll" in betting systems.

Let me try to think recursively.

Define s as the minimum initial amount a required to guarantee reaching any n.

Then, s should be at least the sum of the bet amounts for x losses plus the required bet for the next win.

But this seems circular.

Wait, maybe I can model s as the sum of a series.

Let’s consider that after x losses, the next win must cover all previous losses.

So, y_{x+1} >= (y1 + y2 + ... + yx) / (k - 1)

If I set y1 = 1, y2 = 1 + ceil(y1 / (k - 1)), and so on, it becomes complicated.

Perhaps there's a better mathematical approach.

I recall that in some betting systems, the required bankroll is exponential in the number of allowed consecutive losses.

Maybe in this case, s = sum from i=0 to x of (k / (k - 1))^i

Wait, not sure.

Let me try to compute s iteratively.

Start with s = 1 (the smallest possible bet).

Then, for each possible loss sequence of length up to x, compute the required bet to cover the losses.

Wait, perhaps I can model it as follows:

Let s0 = 1 (initial bet)

s1 = s0 + ceil(s0 / (k - 1))

s2 = s1 + ceil(s1 / (k - 1))

...

s_x = s_{x-1} + ceil(s_{x-1} / (k - 1))

Then, a needs to be at least s_x.

Wait, this seems similar to the code provided.

Looking back at the code:

def func():

for _ in range(int(input())):

(k, x, a) = map(int, input().split())

s = 1

for i in range(x):

s += s // (k - 1) + 1

print('Yes' if a >= s else 'No')

So, it initializes s = 1, then iteratively adds s // (k - 1) + 1, x times, and checks if a >= s.

This seems to match my earlier thought process.

Let me verify this with the first test case: k=2, x=1, a=7

s = 1

After first iteration (i=0):

s += s // 1 + 1 = 1 // 1 + 1 = 1 + 1 = 2

So, s = 1 + 2 = 3

But in my earlier calculation, I had a >= 2 * y1 = 2 * 3 = 6, but here s=3.

Wait, maybe I'm misunderstanding.

Wait, no, in the code, s ends up being 3, and a=7 >= 3, so YES.

But in my earlier thought, I had a >= 2 * y1 = 6 for a=7, which also gives YES.

But according to the code, s=3, which is different from my calculation.

Hmm, maybe my earlier assumption was wrong.

Let me recast my reasoning.

Perhaps s represents the total sum needed to cover x losses and still be able to make a winning bet.

In the code, s starts at 1.

Then, for each of x iterations, it adds s // (k - 1) + 1.

Wait, let's see for k=2, x=1, a=7:

s = 1

After first iteration:

s += 1 // 1 + 1 = 1 + 1 = 2

So, s = 1 + 2 = 3

But in my earlier manual simulation, with y1=3, y2=3, a=7 - 3 + 6 = 10.

But according to the code, a=7 >= s=3, which is true, so YES.

But in my manual calculation, a needs to be at least 2 * y1 = 6, which is less than s=3 from the code.

Wait, maybe my manual calculation is incorrect.

Let me try to understand the code's logic.

s starts at 1, which perhaps represents the initial bet.

Then, for each possible loss, we add s // (k - 1) + 1, which seems to account for the required bet to cover the previous losses.

But I need to verify if this correctly captures the minimum a required.

Let me try another test case: k=2, x=1, a=1

s = 1

After first iteration:

s += 1 // 1 + 1 = 1 + 1 = 2

s = 1 + 2 = 3

a=1 < s=3, so NO.

Which matches the sample output.

Another test case: k=2, x=3, a=15

s = 1

After first iteration: s += 1//1 + 1 = 1 + 1 = 2 → s=3

After second iteration: s += 3//1 + 1 = 3 + 1 = 4 → s=7

After third iteration: s += 7//1 + 1 = 7 + 1 = 8 → s=15

a=15 >= s=15, so YES.

Which matches the sample output.

Another test case: k=3, x=3, a=6

s = 1

After first iteration: s += 1//2 + 1 = 0 + 1 = 1 → s=2

After second iteration: s += 2//2 + 1 = 1 + 1 = 2 → s=4

After third iteration: s += 4//2 + 1 = 2 + 1 = 3 → s=7

a=6 < s=7, so NO.

Which matches the sample output.

Another test case: k=5, x=4, a=7

s = 1

After first iteration: s += 1//4 + 1 = 0 + 1 = 1 → s=2

After second iteration: s += 2//4 + 1 = 0 + 1 = 1 → s=3

After third iteration: s += 3//4 + 1 = 0 + 1 = 1 → s=4

After fourth iteration: s += 4//4 + 1 = 1 + 1 = 2 → s=6

a=7 >= s=6, so YES.

Which matches the sample output.

Another test case: k=4, x=88, a=1000000000

s = 1

Then, for each of 88 iterations, s += s//3 + 1

I need to see what s becomes after 88 iterations.

Let's see the pattern:

Iteration 0: s=1

Iteration 1: s += 1//3 + 1 = 0 + 1 = 1 → s=2

Iteration 2: s += 2//3 + 1 = 0 + 1 = 1 → s=3

Iteration 3: s += 3//3 + 1 = 1 + 1 = 2 → s=5

Iteration 4: s += 5//3 + 1 = 1 + 1 = 2 → s=7

Iteration 5: s += 7//3 + 1 = 2 + 1 = 3 → s=10

Iteration 6: s += 10//3 + 1 = 3 + 1 = 4 → s=14

Iteration 7: s += 14//3 + 1 = 4 + 1 = 5 → s=19

And so on.

This seems to be growing linearly.

After 88 iterations, s would be quite large, but for a=1000000000, it's possible that a < s.

But according to the sample output, it's NO.

So, the code seems to be correctly calculating s and comparing it to a.

Therefore, I conclude that the given program is correct.

**Final Answer**

\[\boxed{\text{Correct}}\]

