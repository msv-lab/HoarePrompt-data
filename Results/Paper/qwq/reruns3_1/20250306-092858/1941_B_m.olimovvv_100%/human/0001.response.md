Alright, I've got this problem to solve. Let's see what it's asking for. So, Rudolf has an array of n integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (between 2 and n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to determine whether it's possible to make all elements of the array zero after applying this operation any number of times.

First, I need to understand the operation clearly. When Rudolf chooses an index i, he subtracts 1 from a[i-1], subtracts 2 from a[i], and subtracts 1 from a[i+1]. This operation can be applied multiple times, and any index between 2 and n-1 can be chosen zero or more times.

I need to figure out if, by applying this operation strategically, I can reduce all elements of the array to zero.

Let me think about the implications of this operation. It seems like a way to propagate changes through the array, affecting three consecutive elements each time.

I recall that in some array manipulation problems, especially those involving operations on subsequences or neighboring elements, there are mathematical properties or invariants that can help determine the possibility of reaching a desired state.

One approach that comes to mind is to model this as a system of linear equations. Each operation corresponds to subtracting specific values from certain positions, and I need to see if I can reach an array of all zeros from the given initial state.

However, given the constraints (up to 2*10^5 elements per test case and up to 10^4 test cases), solving a system of linear equations for each test case isn't feasible due to time constraints.

I need a more efficient way to check if it's possible to make all elements zero.

Let's consider the operation again: subtract 1 from a[i-1], 2 from a[i], and 1 from a[i+1]. This can be seen as applying a specific "mask" or "kernel" of [-1, -2, -1] to the array at position i.

To counteract this, to make the elements zero, I need to add back these values in some manner.

Wait, perhaps I can think in terms of adding the operation instead of subtracting. If I consider the operation as subtracting [-1, -2, -1], then to reach zero, I need to determine how many times to apply this operation.

But I'm not sure if that's the right path.

Let me consider the cumulative sum of the array. Sometimes, in array problems where operations affect ranges of elements, looking at prefix sums or cumulative sums can reveal useful patterns.

Let's compute the prefix sums of the array and see if that helps.

Define s[0] = b[0]

s[1] = b[0] + b[1]

s[2] = b[0] + b[1] + b[2]

...

s[n-1] = b[0] + b[1] + ... + b[n-1]

Not sure if that directly helps.

Alternatively, maybe look at differences between consecutive elements.

Let's consider the differences between consecutive elements:

d[0] = b[0]

d[1] = b[1] - b[0]

d[2] = b[2] - b[1]

...

d[n-1] = b[n-1] - b[n-2]

This is similar to first differences in sequences.

Now, let's see how the operation affects these differences.

When I perform the operation on index i:

- b[i-1] -= 1

- b[i] -= 2

- b[i+1] -= 1

So, the differences change as follows:

d[i] = (b[i] - b[i-1]) -> ((b[i] - 2) - (b[i-1] - 1)) = (b[i] - b[i-1]) - 1

Similarly,

d[i+1] = (b[i+1] - b[i]) -> ((b[i+1] - 1) - (b[i] - 2)) = (b[i+1] - b[i]) + 1

So, the operation on index i affects d[i] by subtracting 1 and d[i+1] by adding 1.

Interesting. So, the operation transforms d[i] to d[i] - 1 and d[i+1] to d[i+1] + 1.

This seems similar to shifting water from one bucket to another, where each operation reduces one bucket by 1 and increases the next by 1.

If I look at the sequence of differences d[], each operation allows me to subtract 1 from d[i] and add 1 to d[i+1].

My goal is to make all b[j] zero, which would imply that all d[j] are zero after a series of operations.

Wait, does that make sense? Let's see.

If I can make all b[j] zero, then certainly all d[j] would be zero. But can I achieve that by performing operations that adjust d[j] in the specified way?

Given that each operation allows me to subtract 1 from d[i] and add 1 to d[i+1], it's similar to moving "deficits" or "surpluses" along the d[] array.

In other words, I can shift values from one position to the next, but the total sum remains the same.

Wait, but the sum of d[j] is actually b[n-1], since d[0] + d[1] + ... + d[n-1] = b[0] + (b[1] - b[0]) + ... + (b[n-1] - b[n-2]) = b[n-1].

So, the sum of d[j] is equal to the last element of b.

But in the operation, I'm subtracting 1 from d[i] and adding 1 to d[i+1], which doesn't change the total sum.

Therefore, if the sum of d[j] is not zero, I cannot make all d[j] zero, because the operations preserve the sum.

But in this problem, since b is given and I need to make all b[j] zero, which would imply that b[n-1] is zero, meaning the sum of d[j] must be zero.

So, one necessary condition is that b[n-1] is zero.

Wait, but that can't be right because b[n-1] is part of the initial array, and I need to make it zero through operations.

Wait, perhaps I need to think differently.

Let me consider the sum of the entire array.

Each operation subtracts a total of 4 from the sum of the array (since -1 -2 -1 = -4).

So, the sum of the array decreases by 4 with each operation.

Therefore, the sum of the array must be divisible by 4 for it to be possible to reduce it to zero.

Wait, but that doesn't seem right either, because in the example provided:

5

1 3 5 5 2

Sum is 1 + 3 + 5 + 5 + 2 = 16, which is divisible by 4, and the answer is "YES".

Another test case:

5

2 4 4 5 1

Sum is 2 + 4 + 4 + 5 + 1 = 16, again divisible by 4, but the answer is "NO".

So, divisibility by 4 is not sufficient.

Hmm.

Wait, perhaps I need to consider more properties.

Let me look back at the operations.

Each operation subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, the net effect is subtracting 4 from the sum, but as I saw, that's not enough.

Maybe I need to consider the cumulative sums or prefix sums.

Let me define prefix sums:

p[0] = b[0]

p[1] = b[0] + b[1]

p[2] = b[0] + b[1] + b[2]

...

p[n-1] = b[0] + b[1] + ... + b[n-1]

Now, how do the operations affect the prefix sums?

When I perform an operation on index i:

- b[i-1] -= 1 → p[j] for j >= i-1 are reduced by 1

- b[i] -= 2 → p[j] for j >= i are reduced by 2

- b[i+1] -= 1 → p[j] for j >= i+1 are reduced by 1

So, the prefix sums are adjusted accordingly.

But I'm not sure if that helps directly.

Let me consider the differences between prefix sums.

Wait, p[i] - p[i-1] = b[i] (for i >= 1), and p[0] = b[0].

So, perhaps looking at how operations affect these differences.

But that seems similar to what I did earlier with the differences d[j].

Another approach: since the operations can be applied any number of times, perhaps there is a way to model this as Gaussian elimination or solving a system of equations.

But with n up to 2e5, that's not feasible.

I need a smarter way.

Let me consider small values of n.

For n=3:

Array: [a, b, c]

Operation on i=2: a -=1, b-=2, c-=1

I need to make a, b, c all zero.

So, I can set up equations:

a - x = 0

b - 2x = 0

c - x = 0

Where x is the number of operations performed at i=2.

Then, a - x = 0 => x = a

b - 2x = 0 => b - 2a = 0 => b = 2a

c - x = 0 => c = x = a

So, for n=3, it's possible only if b = 2a and c = a.

Otherwise, it's not possible.

But in this case, the sum is a + b + c = a + 2a + a = 4a, which is divisible by 4, but as per the earlier example, divisibility by 4 isn't sufficient.

Wait, in this n=3 case, sum is 4a, which is divisible by 4, but there are additional constraints: b must be 2a and c must be a.

So, perhaps for larger n, there are similar constraints.

Let me try n=4.

Array: [d, e, f, g]

Possible operations on i=2 and i=3.

Operation on i=2: d-=1, e-=2, f-=1

Operation on i=3: e-=1, f-=2, g-=1

I need to make d, e, f, g all zero.

Set up equations:

d - x = 0 => x = d

e - 2x - y = 0 => e - 2d - y = 0 => y = e - 2d

f - x - 2y = 0 => f - d - 2(e - 2d) = 0 => f - d - 2e + 4d = 0 => f + 3d - 2e = 0

g - y = 0 => g - (e - 2d) = 0 => g = e - 2d

So, for n=4, in addition to g = e - 2d, we have f + 3d - 2e = 0.

These are the constraints that must be satisfied for it to be possible.

This is getting complicated.

Maybe there's a better way to look at this.

Let me consider the operation as a vector subtraction: [-1, -2, -1] at positions i-1, i, i+1.

I need to find a combination of such operations to reach the zero vector.

This is similar to solving a system of linear equations, but again, not feasible for large n.

Another idea: since the operation affects three consecutive elements, perhaps I can process the array from left to right, handling each element in sequence.

Starting from the first element, if a[0] is not zero, I need to apply operations that reduce a[0]. However, the only operation that affects a[0] is when i=1, but i starts from 2, so I can't directly apply operations to reduce a[0].

Wait, operations can only be applied for i from 2 to n-1, meaning a[0] can only be reduced indirectly through operations on i=2.

When I apply an operation on i=2, a[1] -=1, a[2] -=2, a[3] -=1.

So, a[0] remains unchanged unless operations affect it indirectly through other elements.

Wait, actually, a[0] is a[1-1], so when i=2, a[1] -=1, which affects a[0]'s neighbor.

This is getting confusing.

Let me think differently.

Suppose I want to make a[0] zero. Since no operation directly affects a[0], I need to make sure that a[0] is already zero, or find a way to reduce it.

But operations only affect from i=2 to n-1, which correspond to a[1] to a[n-2].

Wait, operations can be applied on i from 2 to n-1, which means:

- For i=2: a[1] -=1, a[2] -=2, a[3] -=1

- For i=3: a[2] -=1, a[3] -=2, a[4] -=1

- ...

- For i=n-1: a[n-2] -=1, a[n-1] -=2, a[n] -=1

Wait, but a[n] doesn't exist, since a is from 0 to n-1.

Wait, in the problem, a is indexed from 1 to n, but in the program, it's from 0 to n-1.

I need to be careful with indexing.

In the program, a is from 0 to n-1, but in the problem, it's from 1 to n.

I need to make sure that my indexing matches.

Assuming that a[0] corresponds to the first element in the problem.

Given that, operations are on i from 2 to n-1 (in 1-based indexing), which corresponds to i from 1 to n-2 in 0-based indexing.

So, operations can be applied on positions i from 1 to n-2.

Each operation on i:

a[i-1] -=1

a[i] -=2

a[i+1] -=1

I need to make all a[j] from 0 to n-1 equal to zero.

Now, in the program provided, it seems to iterate from i=0 to a-2 (where a is n), and for each i, it modifies a[i+1] and a[i+2] based on a[i].

Wait, let's look at the code:

for i in range(0, a - 2):

if b[i] < 0:

print('NO')

break

b[i + 1] -= b[i] * 2

b[i + 2] -= b[i]

b[i] -= b[i]

else:

if b[-1] != 0 or b[-2] != 0:

print('NO')

else:

print('YES')

So, it's processing the array from left to right, and for each position i from 0 to n-3, it subtracts b[i]*2 from b[i+1] and b[i] from b[i+2], and sets b[i] to zero.

Then, it checks if the last two elements are zero; if they are, it prints "YES"; otherwise, "NO".

I need to verify if this approach is correct.

Let me see what this code is doing.

It's iterating from the start of the array up to the third-to-last element.

For each element at position i, if it's negative, it immediately concludes "NO", as negative values can't be achieved through the operations, which only subtract positive values.

Then, it adjusts the next two elements based on the current element's value.

Specifically, it subtracts b[i]*2 from b[i+1] and b[i] from b[i+2], and sets b[i] to zero.

After processing all such i, it checks if the last two elements are zero.

If they are, it prints "YES"; otherwise, "NO".

Wait, but in the operation defined in the problem, we can only subtract from a[i-1], a[i], and a[i+1] in a specific way, and we can do it any number of times on any i from 2 to n-1.

The program seems to be trying to simulate a way to zero out the array by processing elements one by one, but I need to verify if this simulation correctly captures the possibilities allowed by the operations.

Let me try to apply this logic to the first example:

n=5, a=[1,3,5,5,2]

Initial array: [1,3,5,5,2]

Iteration 1: i=0

b[0]=1 >=0

b[1] -= 1*2 => b[1]=3-2=1

b[2] -= 1 => b[2]=5-1=4

b[0]-=b[0] => b[0]=0

Array now: [0,1,4,5,2]

Iteration 2: i=1

b[1]=1 >=0

b[2] -=1*2 => b[2]=4-2=2

b[3] -=1 => b[3]=5-1=4

b[1]-=b[1] => b[1]=0

Array now: [0,0,2,4,2]

Iteration 3: i=2

b[2]=2 >=0

b[3] -=2*2 => b[3]=4-4=0

b[4] -=2 => b[4]=2-2=0

b[2]-=b[2] => b[2]=0

Array now: [0,0,0,0,0]

Last check: b[-1]=0 and b[-2]=0, so print "YES"

This matches the first example.

Let's try the second example:

n=5, a=[2,4,4,5,1]

Initial array: [2,4,4,5,1]

Iteration 1: i=0

b[0]=2 >=0

b[1] -=2*2 => b[1]=4-4=0

b[2] -=2 => b[2]=4-2=2

b[0]-=b[0] => b[0]=0

Array now: [0,0,2,5,1]

Iteration 2: i=1

b[1]=0 >=0

b[2] -=0*2 => b[2]=2-0=2

b[3] -=0 => b[3]=5-0=5

b[1]-=b[1] => b[1]=0

Array now: [0,0,2,5,1]

Iteration 3: i=2

b[2]=2 >=0

b[3] -=2*2 => b[3]=5-4=1

b[4] -=2 => b[4]=1-2=-1

b[2]-=b[2] => b[2]=0

Array now: [0,0,0,1,-1]

Now, b[-1]=-1 <0, but the program only checks b[-1] and b[-2] after the loop, and in this case, b[-1]=-1 and b[-2]=1, so it prints "NO"

Which matches the second example.

Another example:

n=5, a=[0,1,3,3,1]

Initial array: [0,1,3,3,1]

Iteration 1: i=0

b[0]=0 >=0

b[1] -=0*2 => b[1]=1-0=1

b[2] -=0 => b[2]=3-0=3

b[0]-=b[0] => b[0]=0

Array now: [0,1,3,3,1]

Iteration 2: i=1

b[1]=1 >=0

b[2] -=1*2 => b[2]=3-2=1

b[3] -=1 => b[3]=3-1=2

b[1]-=b[1] => b[1]=0

Array now: [0,0,1,2,1]

Iteration 3: i=2

b[2]=1 >=0

b[3] -=1*2 => b[3]=2-2=0

b[4] -=1 => b[4]=1-1=0

b[2]-=b[2] => b[2]=0

Array now: [0,0,0,0,0]

Last check: b[-1]=0 and b[-2]=0, so print "YES"

Which matches the third example.

Another example:

n=6, a=[5,6,0,2,3,0]

Initial array: [5,6,0,2,3,0]

Iteration 1: i=0

b[0]=5 >=0

b[1] -=5*2 => b[1]=6-10=-4

b[2] -=5 => b[2]=0-5=-5

b[0]-=b[0] => b[0]=0

Array now: [0,-4,-5,2,3,0]

Iteration 2: i=1

b[1]=-4 <0, so print 'NO'

Which matches the fourth example.

Seems correct so far.

Another example:

n=4, a=[1,2,7,2]

Initial array: [1,2,7,2]

Iteration 1: i=0

b[0]=1 >=0

b[1] -=1*2 => b[1]=2-2=0

b[2] -=1 => b[2]=7-1=6

b[0]-=b[0] => b[0]=0

Array now: [0,0,6,2]

Iteration 2: i=1

b[1]=0 >=0

b[2] -=0*2 => b[2]=6-0=6

b[3] -=0 => b[3]=2-0=2

b[1]-=b[1] => b[1]=0

Array now: [0,0,6,2]

Iteration 3: i=2

b[2]=6 >=0

b[3] -=6*2 => b[3]=2-12=-10

b[4] -=6 => but b[4] doesn't exist, so maybe index out of range?

Wait, n=4, so b has indices 0 to 3.

In the loop, i goes from 0 to n-3=1.

Wait, in the code, it's for i in range(0, a - 2):

with a being n, so for n=4, i=0 and i=1.

So, i=0:

b[1] -= b[0]*2 => b[1]=2-0*2=2

b[2] -= b[0] => b[2]=7-0=7

b[0]-=b[0] => b[0]=0

Array: [0,2,7,2]

i=1:

b[2] -= b[1]*2 => b[2]=7-2*2=3

b[3] -= b[1] => b[3]=2-2=0

b[1]-=b[1] => b[1]=0

Array: [0,0,3,0]

After the loop, check b[-1]=0 and b[-2]=3.

Since b[-2]!=0, print 'NO'

Which matches the fifth example.

Another example:

n=3, a=[7,1,0]

