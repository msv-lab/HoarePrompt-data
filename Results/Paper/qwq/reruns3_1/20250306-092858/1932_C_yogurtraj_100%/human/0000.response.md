Alright, I've got this problem to solve. Let's see what it's asking for.

So, I'm given an array `a` of length `n`, a positive integer `m`, and a string `s` of commands consisting of 'L's and 'R's. For each command in the string `s`, I need to:

1. Output the remainder of the product of all elements in the array `a` when divided by `m`.

2. Then, remove the leftmost element if the command is 'L', or the rightmost element if it's 'R'.

And I have to do this for each command in order, and after all commands, the array should be empty.

First, I need to understand what's being asked. For each step, I need to compute the product of the current array modulo `m` and then remove either the first or last element based on the command.

Naively, I could iterate through each command, compute the product each time, take modulo `m`, print it, and then remove the appropriate element. But given that `n` can be up to 2*10^5 and there are up to 10^4 test cases, this approach would be too slow because computing the product from scratch each time would be O(n^2), which is not efficient.

I need a smarter way to handle this.

Let's think about how the product changes as I remove elements from the array. If I remove an element, the new product is the old product divided by that element. But there's a catch: division in modular arithmetic isn't straightforward because we're dealing with integers and modulo operations.

I recall that in modular arithmetic, if `m` is prime, I can use modular inverses to perform division. But `m` isn't necessarily prime here, so that might not work directly. I need to find a way to efficiently update the product modulo `m` as I remove elements.

Wait, maybe I can compute the product of the entire array modulo `m` first, and then, as I remove elements, I can keep dividing the current product by the removed element, again using modular arithmetic.

But how do I handle division under modulo? I need to multiply by the modular inverse of the removed element. However, modular inverses exist only if the element and `m` are coprime, which isn't guaranteed here.

Hmm, maybe I need to handle cases where the element and `m` share a common divisor separately.

This seems complicated. Is there a better way?

Let me consider another approach. Since the sequence of operations is determined by the string `s`, I can simulate the process by keeping track of which elements are removed at each step.

But simulating the removal step by step for large `n` would still be inefficient.

Wait, perhaps I can precompute the product of the array and then, based on the sequence of 'L's and 'R's, keep dividing by the removed elements in reverse order.

But again, the issue is how to handle division under modulo.

Maybe I can compute the product modulo `m` at each step by keeping track of the cumulative product and updating it as I remove elements.

Let me try to think differently. Maybe I can compute the product of the array modulo `m`, and then, for each command, remove the appropriate element and update the product accordingly.

But I still need an efficient way to update the product.

Another idea: since the array is being reduced by one element at each step, and the sequence of removals is given by `s`, perhaps I can determine the order in which elements are removed and compute the product accordingly.

Let's consider that the first command corresponds to the first character of `s`, and so on, up to the nth command.

Since the array is being reduced by removing either the leftmost or rightmost element at each step, the order in which elements are removed is determined by the string `s`.

In other words, the string `s` dictates which element is removed at each step.

So, if I can determine, for each step, which elements are still present in the array, I can compute their product modulo `m`.

But this seems too slow for large `n`.

I need a way to efficiently compute the product of the current array modulo `m` at each step.

Wait, maybe I can compute the product of all remaining elements using prefix products.

Let me think about this.

If I compute the prefix products of the array, that is, `prefix[i] = a[0] * a[1] * ... * a[i]`, and suffix products, `suffix[j] = a[j] * a[j+1] * ... * a[n-1]`, then at any step, the product of the current array would be `prefix[left] * suffix[right]`, where `left` and `right` are the current boundaries of the array.

But I need to handle the modulo operation carefully.

Actually, since I'm dealing with products, I can compute the product of the entire array modulo `m`, and then, as I remove elements, I can divide by the removed element using its modular inverse, provided that the element and `m` are coprime.

But again, elements and `m` may not be coprime, so this might not work directly.

Wait, maybe I can factor `m` and handle each prime factor separately, but that seems too complicated.

Let me look at the constraints again. `n` can be up to 2*10^5, and `m` can be up to 10^4. Also, the sum of `n` over all test cases is up to 2*10^5, so efficiency is key.

I need an O(n) solution per test case.

Let's consider that the product of the array modulo `m` can be computed efficiently if I can manage to handle the removal of elements properly.

Wait, maybe I can compute the product of the entire array modulo `m`, and then, for each removal, divide the current product by the removed element, again modulo `m`.

But division modulo `m` requires the modular inverse, which exists only if the element and `m` are coprime.

So, I need a way to handle division even when the element and `m` are not coprime.

I recall that I can divide by a number modulo `m` if I handle the common factors between the number and `m` appropriately.

Specifically, if I want to compute `(a / b) mod m`, I can write it as `a * inv(b) mod m`, but only if `b` and `m` are coprime.

If they are not coprime, I need to remove the common factors from `m` and adjust accordingly.

This seems too involved for this problem, given the time constraints.

Is there another way to approach this?

Let me consider the sequence of removals. Since the removals are either from the left or the right, the remaining array at each step is a subarray that is contiguous.

Wait, no. Actually, it's not necessarily contiguous because we're removing from either end.

Wait, actually, it is contiguous. Because we start with the full array and remove either the first or last element at each step.

So, the remaining array is always a subarray of the original array.

Wait, but it's not necessarily the case. For example, if we have 'LRR', starting with [a,b,c,d]:

- Step 1: 'L' -> remove 'a', remaining [b,c,d]

- Step 2: 'R' -> remove 'd', remaining [b,c]

- Step 3: 'R' -> remove 'c', remaining [b]

So, yes, it's always contiguous.

Therefore, the remaining array is always a subarray of the original array, specifically, it's the array from some left index to some right index.

So, at each step, I can keep track of the current left and right indices of the remaining array, and compute the product of the elements from left to right modulo `m`.

But computing the product of a subarray efficiently requires precomputing prefix products.

But again, the issue is handling the modulo operation, especially since `m` can be up to 10^4 and elements can be up to 10^4, so products can be up to (10^4)^2 = 10^8, which is manageable for 32-bit integers.

But wait, no, the product of subarrays can be much larger, up to (10^4)^n, which for n=2*10^5 is enormous. So, I need a way to compute the product modulo `m` efficiently.

Let me consider precomputing prefix products modulo `m`.

Let me define `prefix[i] = (a[0] * a[1] * ... * a[i]) mod m`

Similarly, `suffix[j] = (a[j] * a[j+1] * ... * a[n-1]) mod m`

Then, at any step, if the current array is from left index `l` to right index `r`, the product modulo `m` would be `(prefix[r] * inv(prefix[l-1])) mod m`, assuming `l >= 1`.

But again, this assumes that `prefix[l-1]` and `m` are coprime, which may not be the case.

This seems problematic.

Is there another way to compute the product of a subarray modulo `m` without division?

Alternatively, maybe I can keep track of the product of the current array and update it as I remove elements, but without actually dividing.

Wait, if I remove an element, say `a[k]`, then the new product is the old product divided by `a[k]`. But again, division modulo `m` is tricky.

Another idea: perhaps I can compute the product of the current array modulo `m` by multiplying the remaining elements one by one, but starting from the end.

Wait, but that would still be O(n^2) in the worst case.

I need a better approach.

Let me consider the sequence of removals in reverse. That is, start from the end, when the array is empty, and add elements according to the reverse of `s`.

Wait, that might not help directly.

Wait, perhaps I can process the commands in reverse order and keep track of the product accordingly.

Let's think about it.

If I process the commands in reverse, starting from the last command and moving to the first, I can build up the array step by step and compute the product at each step.

Then, to get the output in the correct order, I can reverse the list of products at the end.

So, starting from an empty array, for each command in reverse order:

- If the command is 'L', it means that in the forward process, we removed an element from the left. So, in reverse, we're adding an element to the left.

- Similarly, if the command is 'R', in reverse, it's adding an element to the right.

And at each step, I need to compute the product of the current array modulo `m`.

This seems promising because I can maintain the current product as I add elements one by one.

Let me try to formalize this.

Initialize an empty array.

Initialize the current product as 1.

Then, starting from the end of `s`, for each command in reverse order:

- If the command is 'L', add a new element to the left of the array, say `a[new_left]`, and multiply the current product by `a[new_left]` modulo `m`.

- If the command is 'R', add a new element to the right of the array, `a[new_right]`, and multiply the current product by `a[new_right]` modulo `m`.

Keep track of the current product at each step.

Then, the list of products in reverse order would be the answer, which I can reverse to get the correct order.

Wait, but in the forward process, we're removing elements from either end, so in the reverse process, we're adding elements to either end.

This seems correct.

Let me try this with the first example:

n=4, m=6

a = [3,1,4,2]

s = "LRRL"

Processing in reverse:

Start with an empty array, product = 1.

Last command is 'L' (forward 'R'), so add '2' to the right, product = 1 * 2 % 6 = 2

Second last is 'R' (forward 'R'), add '4' to the right, product = 2 * 4 % 6 = 8 % 6 = 2

Then 'L' (forward 'L'), add '1' to the left, product = 2 * 1 % 6 = 2 % 6 = 2

Then 'L' (forward 'L'), add '3' to the left, product = 2 * 3 % 6 = 6 % 6 = 0

So, in reverse order, the products are: 0,2,2,2

Reversing, we get: 2,2,2,0

But in the sample output, it's: 0,2,4,1

Hmm, that doesn't match.

Wait, maybe I have a mistake in understanding.

Let me check the forward process for the first example:

Initial array: [3,1,4,2]

First command 'L': product = 3*1*4*2 % 6 = 24 % 6 = 0, then remove 3, array becomes [1,4,2]

Second command 'R': product = 1*4*2 % 6 = 8 % 6 = 2, remove 2, array becomes [1,4]

Third command 'R': product = 1*4 % 6 = 4 % 6 = 4, remove 4, array becomes [1]

Fourth command 'L': product = 1 % 6 = 1, remove 1, array empty

So the output should be: 0,2,4,1

In my reverse approach, I got 2,2,2,0, which is incorrect.

So, perhaps my reverse approach is missing something.

Let me think again.

Maybe I need to keep track of which elements are already in the array when adding a new element.

Wait, perhaps I need to consider the positions more carefully.

Let me try to simulate the reverse process more carefully.

Start with an empty array.

Last command is 'L' (forward 'R'), which means in forward process, we remove the rightmost element. So, in reverse, we're adding to the right.

Add '2' to the right, array becomes [2], product = 2 % 6 = 2

Second last command is 'R' (forward 'R'), remove rightmost, so in reverse, add '4' to the right, array becomes [2,4], product = 2*4 % 6 = 8 % 6 = 2

Third last command is 'L' (forward 'L'), remove leftmost, so in reverse, add '1' to the left, array becomes [1,2,4], product = 1*2*4 % 6 = 8 % 6 = 2

Fourth last command is 'L' (forward 'L'), remove leftmost, so in reverse, add '3' to the left, array becomes [3,1,2,4], product = 3*1*2*4 % 6 = 24 % 6 = 0

So, in reverse order, the products are: 0,2,2,2

Reversing, we get: 2,2,2,0, which doesn't match the sample output: 0,2,4,1

So, clearly, my reverse approach is flawed.

I need to think differently.

Let me consider that the product of the array modulo `m` can be computed by keeping track of the cumulative product as I remove elements.

Wait, but that seems similar to what I did earlier.

Alternatively, maybe I can compute the product of the entire array modulo `m`, and then, for each removal, adjust the product accordingly.

But again, adjusting the product when removing an element requires division, which is tricky under modulo.

Wait, maybe I can compute the product of the array modulo `m`, and keep track of the elements that have been removed, and somehow adjust the product accordingly.

But that seems messy.

Let me consider that since we're removing elements from either end, perhaps I can model the remaining array as a subarray defined by left and right pointers.

At each step, I can determine the current left and right boundaries of the remaining array based on the sequence of 'L's and 'R's.

Then, at each step, compute the product of the subarray from left to right modulo `m`.

To compute the product of a subarray efficiently, I can precompute prefix products modulo `m`.

Let `prefix[i] = (a[0] * a[1] * ... * a[i]) % m`

Then, the product of a subarray from `l` to `r` would be `(prefix[r] * inv(prefix[l-1])) % m`, provided that `l >= 1` and that `prefix[l-1]` and `m` are coprime.

But again, this assumes that `prefix[l-1]` and `m` are coprime, which may not hold.

So, this approach has limitations.

I need a way to handle the division without relying on modular inverses.

Wait, perhaps I can compute the product of the subarray by dividing the prefix product up to `r` by the prefix product up to `l-1`, but without actually dividing, by multiplying by the modular inverse.

But as I said, that requires that the element and `m` are coprime.

This seems like a dead end.

Let me consider another angle.

Since the array is being reduced by removing elements from either end, perhaps I can determine the sequence in which elements are removed and thus know which elements are still present in the array at each step.

For example, for the first example:

s = "LRRL"

- Step 1: 'L' -> remove '3', remaining [1,4,2]

- Step 2: 'R' -> remove '2', remaining [1,4]

- Step 3: 'R' -> remove '4', remaining [1]

- Step 4: 'L' -> remove '1', array empty

So, at each step, the remaining array is:

- Step 1: [1,4,2]

- Step 2: [1,4]

- Step 3: [1]

- Step 4: []

Therefore, the products are:

- Step 1: 1*4*2 % 6 = 8 % 6 = 2

- Step 2: 1*4 % 6 = 4 % 6 = 4

- Step 3: 1 % 6 = 1

- Step 4: empty product is 1 % 6 = 1

Wait, but in the sample output, it's 0,2,4,1.

Wait, the empty product should be 1, but in the sample, it's 0.

Wait, no, in the first output line, it's 0 2 4 1, which corresponds to the products as per the sample explanation.

Wait, perhaps I misread the sample output.

Wait, in the sample input, there are 4 test cases, and the first output line is "0 2 4 1", which corresponds to the first test case.

So, in the first test case, the products are 0,2,4,1, which matches the forward process I described earlier.

But in my previous attempt with the reverse approach, I got 2,2,2,0, which is different.

So, perhaps the reverse approach isn't correct.

Let me think differently.

Maybe I can precompute the prefix and suffix products modulo `m`, and then, for each step, determine the current left and right boundaries and compute the product as `(prefix[r] * suffix[l]) % m`, where `l` and `r` are the current left and right indices.

But again, this assumes that the subarray product can be computed directly, which might not account for the modulo correctly, especially if there are zeros or elements not coprime with `m`.

This seems too simplistic.

Wait, perhaps I can iterate through the commands from left to right, keeping track of the current product modulo `m`, and updating it based on the removal.

But how?

If I remove an element, I need to divide the current product by that element, but again, division under modulo is tricky.

Wait, maybe I can compute the product of the remaining array by keeping track of the product divided by the removed element.

But without proper division, this seems difficult.

Let me consider that since `m` is up to 10^4, which is manageable, perhaps I can compute the product modulo `m` by iteratively removing elements and adjusting the product accordingly.

But I need to find a way to handle the division efficiently.

Alternatively, perhaps I can factor `m` into its prime factors and compute the product modulo each prime power, then use the Chinese Remainder Theorem to combine them.

But this seems overly complicated and time-consuming, especially given the time constraints.

I need a simpler approach.

Let me consider that for each step, I can compute the product of the remaining array directly.

Given that `n` is up to 2*10^5 and there are up to 10^4 test cases, I need an O(n) solution per test case.

Wait, perhaps I can precompute the order in which elements are removed and then compute the product of the remaining elements accordingly.

But determining the order of removal seems necessary.

Let me try to simulate the process for the first test case manually.

n=4, m=6

a = [3,1,4,2]

s = "LRRL"

- Step 1: 'L' -> remove '3', product of remaining [1,4,2] is 1*4*2=8 %6=2

- Step 2: 'R' -> remove '2', product of remaining [1,4]=4 %6=4

- Step 3: 'R' -> remove '4', product of remaining [1]=1 %6=1

- Step 4: 'L' -> remove '1', empty array, product is 1 %6=1

But in the sample output, it's 0,2,4,1.

Wait, in the note, it says the first output is 0 2 4 1, which corresponds to the products before any removal:

- Initial product: 3*1*4*2=24 %6=0

- After 'L': product of [1,4,2]=1*4*2=8 %6=2

- After 'R': product of [1,4]=1*4=4 %6=4

- After 'R': product of [1]=1 %6=1

- After 'L': empty array, product is 1 %6=1

Wait, but in the sample output, it's 0,2,4,1, which matches the above.

So, perhaps the empty product is considered as 1.

But in the note, it says the empty product is 1.

So, perhaps the output should be 0,2,4,1, as in the sample.

But in my earlier reverse approach, I got 2,2,2,0, which is incorrect.

So, perhaps the reverse approach isn't accurate.

I need to find another way.

Let me consider that the sequence of removals defines a specific order in which elements are removed.

I can determine, for each step, which elements are still present in the array.

Then, for those elements, compute their product modulo `m`.

But this seems too slow for large `n`.

I need a smarter way.

Wait, perhaps I can compute the product of all elements, and then, for each removal, divide by the removed element, handling the division under modulo properly.

But as I thought earlier, this requires handling cases where the element and `m` are not coprime, which is complicated.

Let me consider that since `m` can be up to 10^4, and `a[i]` up to 10^4, their products can be up to 10^8, which fits in a 32-bit integer.

But I still need to handle the modulo operation carefully.

Wait, maybe I can compute the product of the array modulo `m` at each step, and keep track of the elements that have been removed.

But this would require me to store the product and update it efficiently.

Another idea: perhaps I can compute the product of the array, and then, for each removal, divide by the removed element using the formula:

`(product / a[k]) % m = (product * a[k]^(-1)) % m`

But again, this requires that `a[k]` and `m` are coprime, which may not be the case.

Wait, maybe I can compute the greatest common divisor (gcd) of `a[k]` and `m`, and adjust the product accordingly.

Specifically, if I remove an element `a[k]`, I can divide both the product and `m` by gcd(a[k], m), and keep track of the adjustments.

This way, I can handle the division even when `a[k]` and `m` are not coprime.

This seems promising.

Let me try to formalize this.

Let `p` be the current product modulo `m`.

When removing an element `a[k]`, I need to compute `p_new = (p / a[k]) % m_new`, where `m_new = m / gcd(a[k], m)`.

Wait, I need to adjust `m` and `p` accordingly to handle the division.

This is getting complicated.

Maybe I should look for an alternative approach.

Let me consider that since the array is being reduced by removing elements from either end, perhaps I can model the remaining array as a combination of prefix and suffix products.

Wait, but I already thought about that and ran into the division problem.

Another idea: perhaps I can compute the product of the array modulo `m`, and keep track of the product of the removed elements, and use that to adjust the current product.

But I'm not sure how that would help.

Wait, perhaps I can compute the product of all removed elements and divide the total product by that, but again, division under modulo is tricky.

This seems like a dead end.

Let me consider precomputing the prefix and suffix products modulo `m`, and then, for each step, determining which prefix and suffix products to multiply to get the current product.

But I'm back to the same issue.

I need to find a different way.

Let me look at the constraints again: `n` up to 2*10^5, `m` up to 10^4, and sum of `n` over all test cases up to 2*10^5.

I need an O(n) per test case solution.

Wait, perhaps I can compute the product of the array modulo `m`, and then, for each removal, update the product by dividing by the removed element, but only if the element divides the current product.

Otherwise, set the product to 0.

But this might not be correct in all cases.

Wait, perhaps I can compute the product of the remaining array by keeping track of the product of the removed elements and adjusting accordingly.

But I'm going in circles here.

Let me consider that for each step, I can compute the product of the remaining array directly.

Given that `n` is large, I need a way to compute the product of any subarray efficiently.

Perhaps I can precompute the prefix products modulo `m`, and then, for each subarray, compute the product as `(prefix[r] * inv(prefix[l-1])) % m`, but again, this requires that `prefix[l-1]` and `m` are coprime.

This seems too restrictive.

Wait, maybe I can factor `m` into its prime factors and compute the product modulo each prime power separately, then combine them using the Chinese Remainder Theorem.

But this would be too slow for the given constraints.

I need a better way.

Let me consider that since `m` is small (up to 10^4), I can iterate through each test case efficiently if I find a way to handle the division properly.

But time is limited, and I need to find a solution.

Wait, perhaps I can consider that for each step, the product of the remaining array is equal to the product of the entire array divided by the product of the removed elements up to that step.

So, if I keep track of the product of removed elements, I can compute the current product as `(total_product / removed_product) % m`.

But again, division under modulo is problematic.

Wait, perhaps I can compute the product of the remaining array by multiplying the elements that haven't been removed yet, modulo `m`.

But this would require me to keep track of which elements are removed, which would be O(n^2) time in the worst case.

This is not feasible.

I need to think differently.

Let me consider that the sequence of removals defines a specific order in which elements are removed, and thus, I can determine which elements are still present at each step.

Then, for each step, I can compute the product of the remaining elements modulo `m`.

But this seems too slow for large `n`.

I need a way to compute this efficiently.

Wait, perhaps I can compute the product of the array modulo `m`, and then, for each removal, update the product by dividing by the removed element, using the formula:

`p_new = (p_old * inv(a[k])) % m`

But only when `a[k]` and `m` are coprime.

When they are not coprime, I need to adjust the product accordingly.

This seems too involved.

Let me consider that in the worst case, where `m` has multiple prime factors, and elements can be multiples of those prime factors, I need to handle each prime power separately.

But this would require factoring `m` and handling each prime power, which is time-consuming.

Given the time constraints, I need a simpler approach.

Perhaps I can accept that my initial approach is correct and try to optimize it.

Wait, perhaps I can precompute the order in which elements are removed and then compute the product of the remaining elements for each step.

To do this, I can simulate the removal process and keep track of which elements are still present.

But with `n` up to 2*10^5, I need this to be efficient.

Wait, maybe I can use two pointers to keep track of the current left and right boundaries of the remaining array.

Initialize left=0 and right=n-1.

Then, for each command in `s`:

- Output the product of a