Alright, I have this problem to check if a given password is strong based on specific conditions. Let's understand the problem first.

So, the conditions for a strong password are:

1. It should consist only of lowercase Latin letters and digits.

2. There should be no digit that comes after a letter (so, after each letter, there should be either another letter or the string ends).

3. All digits should be sorted in non-decreasing order.

4. All letters should be sorted in non-decreasing order.

Also, it's allowed for the password to have only letters or only digits.

The input consists of multiple test cases, each with a password of length n, where n is between 1 and 20, and t is up to 1000.

The output should be "YES" if the password meets all the conditions, and "NO" otherwise.

Looking at the provided program, it seems to handle multiple test cases correctly by reading all input at once and splitting it into a list. It then iterates through each test case, extracts the length n and the password, and calls a function func_1 to check if the password is strong.

In func_1, it separates the digits and letters into two lists and checks:

- That digits are in non-decreasing order.

- That letters are in non-decreasing order.

- That no digit comes after a letter in the password.

To verify if the program is correct, I need to ensure that it correctly implements all the conditions for a strong password.

First, it separates the digits and letters into two lists. Then, it checks if the digits are sorted in non-decreasing order and if the letters are sorted in non-decreasing order.

Additionally, it maintains a variable last_digit_index to track the position of the last digit in the password. If a letter comes after a digit (i.e., if last_digit_index is not -1 when a letter is found), it returns 'NO'.

This seems to cover all the conditions:

1. The password consists only of lowercase letters and digits because the loop separates them into digits and letters lists, implying that only these characters are present.

2. There should be no digit after a letter: It checks this by keeping track of the last digit's index and ensuring no letter comes after any digit.

3. Digits should be sorted in non-decreasing order: It checks if the digits list is sorted.

4. Letters should be sorted in non-decreasing order: It checks if the letters list is sorted.

Looking at the example in the problem:

Input:

5

4

12ac

5

123wa

9

allllmost

5

ac123

6

011679

Output:

YES

NO

YES

NO

YES

Let's verify why:

1. "12ac": digits '1' and '2' are sorted, letters 'a' and 'c' are sorted, and no digit comes after a letter. So, YES.

2. "123wa": digits '1','2','3' are sorted, letters 'w','a' are not sorted ('a' should come before 'w'), and 'a' comes after digits. So, NO.

3. "allllmost": only letters, sorted ('a','l','l','l','m','o','s','t'), so YES.

4. "ac123": letters 'a','c' are sorted, digits '1','2','3' are sorted, but digits come after letters, which is not allowed, so NO.

5. "011679": only digits, sorted, so YES.

The program seems to handle these cases correctly.

I should also consider edge cases:

- Password with only digits: should be YES if sorted.

- Password with only letters: should be YES if sorted.

- Password with alternating letters and digits: should be NO if a digit comes after a letter.

- Password with letters followed by digits: should be NO.

- Password with unsorted digits or letters: should be NO.

- Password with invalid characters: but according to the problem, inputs are always valid, consisting only of lowercase letters and digits.

Let's think about a password with letters followed by digits, like "abc123". According to the conditions, this should be NO because digits come after letters.

But according to the program:

- Digits are '1','2','3' sorted.

- Letters 'a','b','c' sorted.

- But since there are letters followed by digits, it should return NO.

Wait, in the program, it checks that if a letter comes after a digit, return NO. But in "abc123", digits come after letters, which should still be invalid.

Wait, maybe I need to see how last_digit_index is used.

In the loop:

for (i, char) in enumerate(password):

if char.isdigit():

last_digit_index = i

elif last_digit_index != -1:

return 'NO'

So, for "abc123":

- i=0, char='a', not digit, last_digit_index=-1, so no action.

- i=1, char='b', not digit, last_digit_index still -1.

- i=2, char='c', not digit, last_digit_index still -1.

- i=3, char='1', digit, set last_digit_index=3.

- i=4, char='2', digit, set last_digit_index=4.

- i=5, char='3', digit, set last_digit_index=5.

Since no letter comes after a digit, it doesn't return 'NO' in this loop.

Then, it checks if digits are sorted and letters are sorted.

In this case, digits ['1','2','3'] are sorted, letters ['a','b','c'] are sorted.

So, it would return 'YES', but according to the problem conditions, it should be 'NO' because digits come after letters.

Wait, this is a mistake in the program.

The condition should ensure that no digit comes after any letter, meaning that all digits should appear before any letter in the password.

But in the current implementation, it only checks that no letter comes after any digit, which is not the same.

Wait, actually, if no letter comes after any digit, it means that all letters are before any digits, which is what we want.

Wait, maybe I'm misunderstanding.

Let me think again.

If last_digit_index is the index of the last digit encountered.

Then, if a letter is found after that index, it would mean a letter comes after a digit, which is invalid.

But in "abc123", letters are before digits, so last_digit_index is set to 3,4,5, and no letter comes after that, so it's fine.

But according to the problem, digits should not come after letters, meaning that all digits should be before any letters.

Wait, no, the problem says: there should be no digit that comes after a letter.

Which means, after any letter, only letters or end of string should follow.

In other words, all digits must come before any letters in the password.

Wait, but in "abc123", letters come before digits, which should be invalid, but according to the program, it would be valid, which is incorrect.

Wait, perhaps I misread the condition.

The problem says: there should be no digit that comes after a letter.

In other words, after each letter, there should be either another letter or the string ends.

Which implies that no digit can follow a letter.

Which means that all digits must come before any letters in the password.

So, in "abc123", digits come after letters, which should be invalid.

But according to the program, it would consider it valid, because no letter comes after a digit.

So, the program has a flaw here.

Wait, let's see:

In the loop:

for (i, char) in enumerate(password):

if char.isdigit():

last_digit_index = i

elif last_digit_index != -1:

return 'NO'

So, in "abc123":

- last_digit_index is set to 3,4,5.

- No letter comes after a digit because letters are before digits.

- So, it doesn't return 'NO'.

- Then, it checks if digits are sorted and letters are sorted.

- Which they are.

- So, it returns 'YES'.

But according to the problem, "abc123" should be 'NO' because digits come after letters.

So, the program is incorrect here.

It seems that the condition implemented checks that no letter comes after any digit, which is not the same as ensuring that no digit comes after a letter.

Wait, actually, the problem says: there should be no digit that comes after a letter.

Which means, after any letter, there should be no digit.

In other words, all digits must come before any letters in the password.

So, the correct implementation should ensure that all digits are before any letters in the password.

The current implementation only ensures that no letter comes after any digit, which is equivalent to all digits being after all letters, which is the opposite.

So, the program is incorrect.

To fix this, the program should ensure that all digits are before any letters in the password.

One way to do this is to find the first letter and ensure that no digit appears after that letter.

Alternatively, find the last digit and ensure that no letter appears before it.

Wait, actually, to ensure that all digits are before any letters, we can:

- Find the first letter's index.

- Ensure that all digits are before that index.

- Or, find the last digit's index.

- Ensure that all letters are after that index.

The current implementation sets last_digit_index to the index of each digit, and then checks if any letter comes after any digit.

But in "abc123", no letter comes after a digit, which is correct, but according to the problem, digits should not come after letters, meaning all digits must be before any letters.

Wait, I'm getting confused.

Let me think differently.

Let me consider the password as divided into two parts:

- All digits first.

- Then all letters.

And both parts are sorted individually.

But according to the problem, it's allowed to have only letters or only digits.

Also, digits should be sorted in non-decreasing order, and letters should be sorted in non-decreasing order.

And no digit should come after a letter, which implies that all digits must come before any letters.

So, the correct approach is:

- If the password has both digits and letters, all digits must come before any letters.

- Both digits and letters must be sorted in non-decreasing order.

- If the password has only digits or only letters, they must be sorted.

So, in "abc123", letters come before digits, which is invalid because digits must come before letters.

Wait, no, according to the condition, no digit should come after a letter, which means all digits must come before any letters.

So, in "abc123", letters come before digits, which is invalid.

But according to the program, it would consider "abc123" as valid, which is incorrect.

Hence, the program is incorrect.

To fix this, the program should ensure that all digits appear before any letters in the password.

One way to do this is:

- Find the first letter's index.

- Ensure that all digits are before that index.

- Or, find the last digit's index.

- Ensure that all letters are after that index.

Alternatively, scan the string from left to right:

- If you encounter a digit, remember that digits have started.

- If you encounter a letter after digits have started, it's invalid.

But in the current program, it's checking that no letter comes after any digit, which is the opposite of what is needed.

Wait, actually, the current implementation is correct.

Let me think again.

In the loop:

for (i, char) in enumerate(password):

if char.isdigit():

last_digit_index = i

elif last_digit_index != -1:

return 'NO'

This ensures that no letter comes after any digit, meaning that all letters must come before any digit.

Which aligns with the condition that no digit should come after a letter.

Wait, no, the condition is: there should be no digit that comes after a letter.

Which means, after any letter, there should be no digit.

In other words, all digits must come before any letters.

So, the current implementation seems correct.

In "abc123", letters come before digits, and no digit comes after any letter, so it's invalid because digits should not come after letters.

Wait, but according to the problem, "abc123" should be invalid, and the program correctly identifies it as invalid because digits come after letters.

Wait, no, in "abc123", letters are before digits, meaning that digits are after letters, which should be invalid.

But according to the program:

- last_digit_index is set to 3,4,5.

- No letter comes after a digit because letters are before digits.

- So, it doesn't return 'NO'.

- Then, it checks if digits are sorted and letters are sorted.

- Which they are.

- So, it returns 'YES'.

But "abc123" should be 'NO' because digits come after letters.

So, the program is incorrect.

Wait, perhaps I need to look closer.

In the func_1 function:

def func_1(password):

digits = []

letters = []

for char in password:

if char.isdigit():

digits.append(char)

else:

letters.append(char)

last_digit_index = -1

for (i, char) in enumerate(password):

if char.isdigit():

last_digit_index = i

elif last_digit_index != -1:

return 'NO'

if digits != sorted(digits):

return 'NO'

if letters != sorted(letters):

return 'NO'

return 'YES'

So, in "abc123":

- digits = ['1','2','3']

- letters = ['a','b','c']

- last_digit_index is set to 3,4,5.

- No letter comes after a digit.

- digits are sorted.

- letters are sorted.

- So, it returns 'YES'.

But according to the problem, digits should not come after letters, which they do in "abc123", so it should be 'NO'.

Hence, the program is incorrect.

Wait, perhaps I'm misinterpreting the condition.

Let me read the problem again carefully.

"there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends)"

So, in "abc123", 'c' is a letter, and '1' comes after it, which violates the condition.

Hence, it should be 'NO'.

But the program returns 'YES', so it's incorrect.

I think the issue is in this part of the code:

last_digit_index = -1

for (i, char) in enumerate(password):

if char.isdigit():

last_digit_index = i

elif last_digit_index != -1:

return 'NO'

This checks that no letter comes after any digit, which is the opposite of what is needed.

To ensure no digit comes after a letter, we need to make sure that all digits come before any letters.

So, we should track if we have seen a letter before seeing a digit.

Let me try to re-implement this part.

We can set a flag that indicates whether we have seen a letter.

If we see a digit after seeing a letter, return 'NO'.

Otherwise, check if digits and letters are sorted.

So, something like:

seen_letter = False

for char in password:

if char.isalpha():

if seen_letter:

seen_letter = True

elif char.isdigit():

if seen_letter:

return 'NO'

else:

# It's a digit, before any letter

pass

Then, check if digits and letters are sorted.

This way, if any digit comes after a letter, it returns 'NO'.

In "abc123", seen_letter is set to True after 'a', and digits come after letters, so it should return 'NO'.

In "123abc", seen_letter is False when digits are seen, and once letters start, digits have already been seen, but since no digit comes after a letter, it's fine.

Wait, no.

Wait, in "123abc":

- seen_letter is False.

- '1' is digit, no issue.

- '2' is digit.

- '3' is digit.

- 'a' is letter, set seen_letter to True.

- 'b' is letter.

- 'c' is letter.

- Since no digit comes after seeing a letter, it's OK.

- Then, check if digits are sorted ('1','2','3') and letters are sorted ('a','b','c').

- So, it should return 'YES'.

But according to the problem, "123abc" should be 'NO' because digits come before letters, but the condition is that no digit comes after a letter, which is satisfied here.

Wait, no, according to the condition, it's allowed to have only digits followed by letters if digits are before letters.

But according to the problem, "123abc" should be 'NO' because digits are before letters, but the condition is that no digit comes after a letter.

Wait, no, the condition is that there should be no digit that comes after a letter.

So, in "123abc", all digits are before letters, so it's OK.

Hence, it should be 'YES'.

But in "abc123", digits come after letters, which violates the condition, so 'NO'.

Wait, but according to the problem, "123abc" should be 'YES', and "abc123" should be 'NO'.

So, the program seems to be incorrect in handling "abc123".

I think the correct implementation should be:

- Iterate through the password.

- If we find a letter, set a flag that letters have been seen.

- If we find a digit after letters have been seen, return 'NO'.

- Additionally, check that digits are sorted and letters are sorted.

So, in "abc123":

- See 'a', set seen_letter = True.

- See 'b', no issue.

- See 'c', no issue.

- See '1', digit after letters, return 'NO'.

In "123abc":

- See '1', digits are sorted.

- See '2', digits are sorted.

- See '3', digits are sorted.

- See 'a', letters not yet seen, set seen_letter = True.

- See 'b', letters sorted.

- See 'c', letters sorted.

- Return 'YES'.

In "abc":

- Only letters, sorted, return 'YES'.

In "123":

- Only digits, sorted, return 'YES'.

In "a1b2c3":

- 'a' seen, seen_letter = True.

- '1' is digit after letter, return 'NO'.

So, the program needs to be modified to correctly implement this logic.

Hence, the given program is incorrect.

Therefore, Correctness: **False**

**Final Solution**

To solve this problem, we need to verify if given passwords meet specific criteria for strength. The conditions are:

1. The password should consist only of lowercase Latin letters and digits.
2. There should be no digit that comes after a letter.
3. All digits should be sorted in non-decreasing order.
4. All letters should be sorted in non-decreasing order.

## Approach

1. **Validation of Characters**: Ensure all characters are lowercase letters or digits.
2. **Ordering of Digits and Letters**: Ensure no digit appears after a letter.
3. **Sorting of Digits and Letters**: Ensure digits and letters are sorted in non-decreasing order.

### Solution Code

```python
import sys

def main():
    input_data = sys.stdin.read()
    data = input_data.split()
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n = int(data[index])
        password = data[index + 1]
        index += 2
        results.append(check_password(password))
    print('\n'.join(results))

def check_password(password):
    seen_letter = False
    for i in range(len(password)):
        if password[i].isalpha():
            if seen_letter:
                if password[i] < password[i-1]:
                    return 'NO'
            else:
                seen_letter = True
        else:  # It's a digit
            if seen_letter:
                return 'NO'  # Digit after letter
            else:
                if i > 0 and password[i] < password[i-1]:
                    return 'NO'  # Digits are not in non-decreasing order
    return 'YES'

if __name__ == "__main__":
    main()
```

## Explanation

1. **Reading Input**: Read all input data at once and split it into a list for easier access.
2. **Processing Each Test Case**:
   - Extract the length `n` and the password string.
3. **Checking Password Strength**:
   - Use a flag `seen_letter` to track if any letter has been encountered.
   - Iterate through each character in the password:
     - If a letter is encountered:
       - Check if it is in non-decreasing order relative to the previous letter.
       - Set `seen_letter` to True.
     - If a digit is encountered:
       - If `seen_letter` is True, return 'NO' (digit after letter).
       - Ensure digits are in non-decreasing order.
4. **Output Results**: Collect results for all test cases and print them.

This approach ensures that all conditions for a strong password are met by checking the order and sorting of characters appropriately.