Alright, I have this problem to solve. It's about a game between Alice and Bob on an array of integers. Alice wants to maximize the MEX of her collection, and Bob wants to minimize it. They take turns, with Alice going first, and in each turn, Alice picks an element from the array, adds it to her collection, and deletes it from the array, while Bob just picks and deletes an element without adding it to any collection. The game ends when the array is empty, and the score is the MEX of Alice's collection.

First, I need to understand what MEX is. MEX stands for Minimum EXcludant, which is the smallest non-negative integer not present in the collection. For example, for [2,2,1], MEX is 0; for [3,1,0,1], it's 2; and for [0,3,1,2], it's 4.

So, the goal is to find out what the MEX will be if both players play optimally.

Let's think about how the game progresses. Alice and Bob alternate turns, with Alice going first. Each turn, Alice picks an element for her collection and removes it from the array, while Bob just removes an element.

Since Alice wants to maximize the MEX, she would want to collect as many small non-negative integers as possible, especially the ones that are needed to keep the MEX high. Bob, on the other hand, wants to minimize the MEX, so he would try to prevent Alice from collecting certain elements that are crucial for a higher MEX.

To find the optimal outcome, I need to consider the possible moves and strategies of both players.

Let's consider that the array has n elements, and the elements are in the range [0, n-1]. This is important because MEX can be at most n, since there are n elements, and if all elements from 0 to n-1 are present, the MEX would be n.

But the array can have duplicates, so some numbers might appear multiple times, while others might not appear at all.

I need to find out which numbers Alice can collect in her collection such that the MEX is maximized, considering that Bob is trying to minimize it.

Let me think about the frequency of each number in the array. If a number appears only once, then if Alice picks it, it's gone, and if Bob picks it, it's also gone. If a number appears multiple times, then even if Bob picks some instances, some instances remain for Alice to pick.

Wait, but Bob can only pick and delete elements; he can't choose where to pick from in terms of helping or hindering Alice's collection directly, except that by deleting elements, he might be removing elements that Alice could have picked.

But actually, Bob can choose which elements to delete, so he can strategically remove elements that are important for Alice to achieve a higher MEX.

Wait, no. Bob can pick any element he wants to delete. So, he can choose to delete elements that Alice might need to keep the MEX high.

But Alice picks first, and then they alternate.

I need to find a way to determine, for each possible MEX value, whether Alice can ensure that the MEX is at least that value, assuming Bob is trying to prevent it.

This sounds like a game where we have to find the optimal outcome given both players play perfectly.

Let me try to model this.

Let's consider that the game ends when all elements are deleted, and we need to see what Alice's collection looks like.

But simulating the entire game move by move would be too slow, especially since n can be up to 2*10^5 per test case, and t can be up to 2*10^4, with the total sum of n over all test cases being up to 2*10^5.

So, I need a smarter way to compute the outcome without simulating each move.

Let me think about the frequencies of the numbers.

Suppose I count how many times each number appears in the array.

Let's say I have a frequency count cnt[i] for each i from 0 to n-1.

Now, Alice and Bob will take turns deleting elements, with Alice also collecting one element per turn.

I need to see, for each number i, whether Alice can collect it enough times to ensure that it's in her collection at the end.

But since Bob can delete elements, he might delete elements that Alice needs.

Wait, but Alice gets to choose which element to collect, so she can pick the elements she needs.

But Bob can delete elements that Alice needs before she gets a chance to pick them.

This seems complicated.

Maybe I need to think differently.

Let's consider that the total number of turns is equal to n, since there are n elements.

Alice moves first, so she has floor(n/2) + n%2 moves, and Bob has floor(n/2) moves.

Wait, no. In total, there are n moves, alternating between Alice and Bob, starting with Alice.

So, if n is even, Alice has n/2 moves, and Bob has n/2 moves.

If n is odd, Alice has n/2 + 1 moves, and Bob has n/2 moves.

Wait, no. Wait, if n is even, Alice has n/2 moves, Bob has n/2 moves.

If n is odd, Alice has ceil(n/2) moves, Bob has floor(n/2) moves.

Yes.

Now, in each of Alice's moves, she picks one element for her collection and deletes it.

In each of Bob's moves, he picks one element and deletes it.

So, in total, Alice collects ceil(n/2) elements, and Bob deletes floor(n/2) elements, but Bob's deletions can be strategic to minimize the MEX.

Wait, actually, Bob deletes elements in his turns, and Alice collects elements in her turns.

But all deleted elements are removed from the array, so the array shrinks as the game progresses.

This seems too involved to simulate directly.

Maybe I can think in terms of which elements Alice can guarantee to have in her collection.

Let me consider that for each number i from 0 to n-1, I need to see if Alice can ensure that she collects at least one instance of i, assuming Bob is trying to prevent it.

If Alice can ensure that she collects all instances of 0 to k-1, then the MEX would be k.

I need to find the largest k such that Alice can collect all instances of 0 to k-1.

But Bob will try to prevent this by deleting elements that Alice needs.

Wait, but Bob can only delete elements; he can't choose which elements Alice picks.

But Bob can delete elements that Alice might need.

Wait, this is getting confusing.

Let me look at the reference solution to understand how it works.

The reference solution seems to iterate through the numbers from 0 to n-1 and checks the frequency of each number.

It maintains a counter t that seems to track something, and if t >= 2 or cnt[i] == 0, it prints i.

I need to understand what this is doing.

Wait, maybe it's trying to find the smallest i such that the number of times i appears in the array is less than twice the number of times previous numbers have frequencies of 1.

This is not clear to me.

Wait, perhaps it's based on the idea that if a number i has only one occurrence, it's critical, and if there are multiple such numbers, it affects the MEX.

I need to think differently.

Let me consider that Alice wants to collect as many unique small numbers as possible.

Bob wants to prevent this by deleting elements that Alice needs.

So, for each number i, if Alice needs to collect it to keep the MEX high, Bob might delete it.

But Alice gets to choose which element to collect, so she can prioritize collecting the necessary elements.

Wait, but Bob can delete elements that Alice needs before she gets a chance to pick them.

This seems like a pursuit-evasion game, but it's probably simpler.

Maybe I can think in terms of the number of times each number appears and how many times Alice can collect them.

Let me consider that for a number i, if it appears cnt[i] times, and Alice needs at least one copy of it in her collection to keep the MEX higher than i.

Bob can try to delete some of these copies to prevent Alice from collecting at least one.

But since Alice moves first and can choose which element to collect, she can prioritize collecting the elements she needs.

Wait, but Bob can also choose to delete elements that Alice needs.

This seems like it requires some kind of game theory analysis.

Perhaps I can think in terms of the minimal requirements for Alice to achieve a certain MEX.

For example, to have MEX = k, Alice needs to have all numbers from 0 to k-1 in her collection at least once.

Bob will try to prevent this by deleting some of these numbers.

So, for each k, I need to check if Alice can collect all numbers from 0 to k-1 at least once, despite Bob's attempts to delete them.

This sounds like checking if, for each number from 0 to k-1, the frequency cnt[i] is sufficient such that even if Bob deletes some copies, Alice can still collect at least one.

Given that Alice has ceil(n/2) moves and Bob has floor(n/2) moves, I need to see if for each i from 0 to k-1, cnt[i] - the number of times Bob can delete it is still >=1.

Wait, perhaps I can model it as: for each i from 0 to k-1, if cnt[i] > number of times Bob can delete it, then Alice can collect at least one.

Otherwise, she cannot.

So, I need to find the largest k such that for all i from 0 to k-1, cnt[i] > number of times Bob can delete it.

Now, the number of times Bob can delete elements is floor(n/2).

But I need to see how many times Bob can delete a specific element.

Wait, Bob can delete any element in his turn, so he can choose to delete elements that Alice needs.

So, for a specific i, the number of times Bob can delete it is up to cnt[i], but he will prioritize deleting elements that Alice needs if he wants to minimize the MEX.

So, for each i from 0 to k-1, if cnt[i] > floor(n/2), then Alice can collect at least one, because even if Bob deletes floor(n/2) instances, at least one remains.

Wait, but Bob can choose to delete other elements as well.

Wait, perhaps I need to think in terms of the total number of deletions Bob can perform on the elements that Alice needs.

Wait, this is getting too complicated.

Let me look back at the reference solution.

It seems to iterate through i from 0 to n-1, keeping a counter t that increments when cnt[i] ==1, and if t >=2 or cnt[i]==0, it prints i.

So, it's looking at numbers that appear exactly once, and when there are at least two such numbers or a number doesn't appear at all, it outputs that i as the MEX.

I'm not sure if this is correct, but maybe I can reason about it.

Suppose we have numbers from 0 to n-1, and some of them might not appear in the array.

If a number doesn't appear at all, then Alice can't collect it, so the MEX would be that number.

But wait, Alice can only collect elements that are in the array.

So, if a number doesn't appear in the array, Alice can't collect it, and thus, if that number is the smallest missing one, it would be the MEX.

But the game is more complex because Bob can delete elements, affecting what Alice can collect.

Wait, but if a number doesn't appear in the array at all, neither Alice nor Bob can do anything about it.

So, the MEX could be that number.

But the reference solution seems to consider numbers that appear exactly once, and when there are two such numbers or a number doesn't appear at all, it outputs that i.

This seems to suggest that having numbers appearing only once affects the MEX in some way.

Maybe I need to consider that if a number appears only once, and Alice doesn't pick it, Bob can delete it, making it unavailable for Alice.

Wait, but if a number appears only once, and Alice picks it, then it's in her collection.

If Alice doesn't pick it, Bob can delete it, removing it from the array.

So, for numbers that appear only once, Alice needs to pick them if she wants to have them in her collection, because otherwise, Bob can delete them.

Similarly, for numbers that appear multiple times, even if Bob deletes some instances, some remain for Alice to pick.

So, for each number i from 0 to k-1, to ensure that Alice can collect at least one instance of i, if cnt[i] ==1, Alice must pick it in one of her moves before Bob can delete it.

If cnt[i] >=2, then even if Bob deletes one instance, Alice can pick another.

So, for each i from 0 to k-1, if cnt[i] >=2, Alice can collect at least one.

If cnt[i] ==1, Alice needs to pick it before Bob deletes it.

Given that Alice and Bob alternate turns, with Alice starting first, Alice has ceil(n/2) moves, and Bob has floor(n/2) moves.

So, for each i from 0 to k-1, if cnt[i] ==1, Alice needs to pick it in one of her moves.

If the number of such i's (with cnt[i]==1) is less than or equal to ceil(n/2), then Alice can pick all of them in her moves, ensuring she has at least one of each.

If the number of such i's is greater than ceil(n/2), then there are some i's with cnt[i]==1 that Alice cannot pick, because Bob can delete them in his moves.

Wait, more precisely, if the number of i's with cnt[i]==1 is greater than the number of Alice's moves, then there are some i's that Alice cannot pick, because Bob can delete them in his moves.

Wait, but Alice has ceil(n/2) moves, and Bob has floor(n/2) moves.

So, if the number of i's with cnt[i]==1 is <= ceil(n/2), then Alice can pick all of them, ensuring she has at least one of each.

If the number of i's with cnt[i]==1 is > ceil(n/2), then Bob can delete some of them before Alice can pick them.

Wait, but Alice goes first, so she can prioritize picking the necessary ones.

But Bob can also choose to delete them.

This seems like it requires a more detailed analysis.

Perhaps I can think in terms of the number of critical elements (those with cnt[i]==1) and see if Alice can collect them all.

Let me formalize this.

Define S as the set of numbers from 0 to k-1 that Alice needs to collect to have MEX=k.

For MEX to be k, Alice must have collected all numbers from 0 to k-1.

So, S = {0,1,2,...,k-1}

For each s in S, if cnt[s] >=2, Alice can collect at least one, regardless of Bob's actions.

If cnt[s] ==1, Alice needs to pick it before Bob deletes it.

So, the number of s in S with cnt[s]==1 must be <= the number of Alice's moves.

But Alice's moves are ceil(n/2).

But we need to consider that Alice has to collect elements from S with cnt[s]==1, and also that Bob can delete elements.

Wait, perhaps more accurately, the number of s in S with cnt[s]==1 must be <= the number of Alice's moves minus the number of s in S with cnt[s]>=2.

Wait, I'm getting confused.

Let me try to think differently.

Suppose we want to find the smallest k such that Alice cannot collect all numbers from 0 to k-1.

That would be the MEX.

To collect all numbers from 0 to k-1, for each i in 0 to k-1:

- if cnt[i] >=2, Alice can collect one.

- if cnt[i] ==1, Alice needs to pick it before Bob deletes it.

So, the number of i in 0 to k-1 with cnt[i]==1 must be <= ceil(n/2) - the number of i in 0 to k-1 with cnt[i]>=2.

Wait, no.

Actually, for i with cnt[i]>=2, Alice can collect one even if Bob deletes one.

For i with cnt[i]==1, Alice needs to pick it before Bob deletes it.

So, the number of i with cnt[i]==1 in 0 to k-1 must be <= the number of Alice's moves.

Since Alice has ceil(n/2) moves, and she needs to use some of them to collect i with cnt[i]>=2 as well.

Wait, no, for i with cnt[i]>=2, Alice can collect one without needing to worry about Bob deleting it, because even if Bob deletes one, Alice can pick another.

So, for i with cnt[i]>=2, Alice can collect one without using up one of her moves specifically for that i.

Wait, that's not quite right.

Actually, for i with cnt[i]>=2, Alice can collect one, and Bob can delete one, but since there are two or more, Alice can still collect one.

So, for i with cnt[i]>=2, Alice can collect one without any issue.

For i with cnt[i]==1, Alice needs to pick it before Bob deletes it.

So, the number of i with cnt[i]==1 in 0 to k-1 must be <= the number of Alice's moves.

Since Alice has ceil(n/2) moves, she can protect that many i with cnt[i]==1.

If the number of i with cnt[i]==1 in 0 to k-1 is > ceil(n/2), then Bob can delete some of them before Alice can pick them, so Alice cannot collect all of them.

Therefore, the smallest k where the number of i in 0 to k-1 with cnt[i]==1 > ceil(n/2) would be the MEX.

Wait, no.

Actually, Alice has ceil(n/2) moves to pick elements, and she needs to use some of those moves to pick the i with cnt[i]==1 to prevent Bob from deleting them.

For i with cnt[i]>=2, Alice can collect one without worrying about Bob deleting it, because even if Bob deletes one, there's still at least one left for Alice to pick.

So, for i with cnt[i]>=2, Alice can collect one without using up one of her moves specifically for that i.

Wait, but she still needs to pick it at some point.

I'm getting tangled here.

Let me try to formalize it.

Letâ€™s define:

- Let S_k = {0,1,2,...,k-1}

- Let C = number of i in S_k with cnt[i] >=1

- Let U = number of i in S_k with cnt[i] >=2

Then, the number of i in S_k with cnt[i]==1 is C - U.

Alice needs to collect all i in S_k, which means collecting at least one of each i in S_k.

For i with cnt[i]>=2, Alice can collect one even if Bob deletes one.

For i with cnt[i]==1, Alice needs to pick it before Bob deletes it.

So, the number of i with cnt[i]==1 in S_k must be <= the number of Alice's moves.

Since Alice has ceil(n/2) moves, she can pick that many elements.

But she needs to use some of her moves to collect the i with cnt[i]==1.

For i with cnt[i]>=2, she can collect one without needing to worry about Bob deleting it.

Wait, no. For i with cnt[i]>=2, even if Bob deletes one, there's still at least one left for Alice to pick in her moves.

So, for i with cnt[i]>=2, Alice can collect one, but she needs to pick it in one of her moves.

But she has ceil(n/2) moves to pick elements.

Wait, perhaps I need to think in terms of the total number of critical elements that Alice needs to protect.

Let me try to think in terms of the number of elements that Alice needs to specifically pick to prevent Bob from deleting them.

For i with cnt[i]==1, Alice needs to pick it to prevent Bob from deleting it.

For i with cnt[i]>=2, Alice can collect one even after Bob deletes one.

So, the number of i with cnt[i]==1 in S_k must be <= the number of Alice's moves.

Since Alice has ceil(n/2) moves, she can protect up to ceil(n/2) elements from being deleted by Bob.

Therefore, if the number of i in S_k with cnt[i]==1 <= ceil(n/2), then Alice can collect all i in S_k, and the MEX can be at least k.

Otherwise, if the number of i in S_k with cnt[i]==1 > ceil(n/2), then Alice cannot collect all of them, and the MEX would be k.

So, to find the smallest k where the number of i in S_k with cnt[i]==1 > ceil(n/2), that k is the MEX.

Therefore, I can iterate k from 0 to n, and keep track of the number of i in S_k with cnt[i]==1.

When this count exceeds ceil(n/2), then k is the MEX.

Wait, but ceil(n/2) is the number of Alice's moves.

Yes, that makes sense.

Let me try to implement this logic.

First, count the frequency of each a_i.

Then, sort the numbers from 0 to n-1.

For each k from 0 to n, consider S_k = {0,1,2,...,k-1}

Let count_one = number of i in S_k with cnt[i]==1

If count_one > ceil(n/2), then MEX = k

Otherwise, continue.

So, I need to find the smallest k where count_one > ceil(n/2)

This seems correct.

Now, looking back at the reference solution, it seems to be doing something different.

It's iterating through i from 0 to n-1, keeping a counter t that increments when cnt[i]==1, and if t >=2 or cnt[i]==0, it prints i.

This doesn't seem to match my reasoning.

Perhaps the reference solution has a mistake.

Let me test it with the sample input.

Sample Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Sample Output:

2

1

0

Let's see.

First test case: n=4, a=[0,0,1,1]

Frequency: cnt[0]=2, cnt[1]=2, cnt[2]=0, cnt[3]=0

According to my reasoning:

For k=0: S_k is empty, count_one=0 <= ceil(4/2)=2, so MEX !=0

For k=1: S_k={0}, count_one=0 (cnt[0]=2) <=2, so MEX !=1

For k=2: S_k={0,1}, count_one=0 <=2, so MEX !=2

For k=3: S_k={0,1,2}, count_one=0 <=2, so MEX !=3

For k=4: S_k={0,1,2,3}, count_one=0 <=2, so MEX !=4

Wait, but according to the sample output, MEX=2.

Wait, perhaps I made a mistake.

Wait, MEX is the smallest k where Alice cannot collect all numbers from 0 to k-1.

In this case, for k=2, S_k={0,1}, count_one=0 <=2, so Alice can collect both 0 and 1.

But according to the sample output, MEX=2, meaning that Alice cannot collect both 0 and 1.

Wait, maybe I need to adjust my condition.

Wait, perhaps the condition should be count_one > ceil(n/2) - (number of i in S_k with cnt[i]>=2)

Wait, no, that seems overly complicated.

Wait, perhaps I need to consider that Alice has ceil(n/2) moves to pick elements, and she needs to use some of them to collect the i with cnt[i]==1.

For i with cnt[i]>=2, she can collect one without worrying about Bob deleting it.

So, the number of i in S_k with cnt[i]==1 must be <= the number of Alice's moves.

In the first test case, n=4, ceil(n/2)=2

S_k={0,1} for k=2, count_one=0 <=2, so MEX !=2

But sample output is MEX=2

So, my logic is incorrect.

Wait, perhaps I need to find the smallest k where the number of i in S_k with cnt[i]==1 > ceil(n/2) - (number of i in S_k with cnt[i]>=2)

Wait, that seems off.

Wait, perhaps I need to consider that for i with cnt[i]>=2, Alice can collect one without using one of her moves, because even if Bob deletes one, she can pick another.

So, the number of moves Alice needs to protect i with cnt[i]==1 is the number of such i.

In the first test case, count_one=0, so Alice doesn't need to protect any, which is <=2, so MEX !=2

But sample output is MEX=2

So, perhaps my condition is incorrect.

Wait, maybe I need to find the smallest k where the number of i in S_k with cnt[i]==1 > ceil(n/2)

But in this case, count_one=0 <=2, so MEX should be higher than 2, but sample output is 2.

So, my logic is flawed.

Let me think differently.

Perhaps I need to consider that Alice can collect ceil(n/2) elements, and she wants to collect the smallest possible numbers to maximize the MEX.

But Bob can delete floor(n/2) elements to minimize the MEX.

So, the MEX would be the smallest number that Alice cannot collect, given that Bob is trying to prevent her from collecting it.

This seems like a more strategic approach.

Let me consider that Alice can collect ceil(n/2) elements, and she should collect the smallest possible numbers to maximize the MEX.

Bob can delete floor(n/2) elements to minimize the MEX.

So, the MEX would be the smallest number where the number of available instances is less than what Alice can collect.

Wait, I need a better approach.

Let me consider that the game is equivalent to Alice being able to choose ceil(n/2) elements to keep, and Bob chooses floor(n/2) elements to delete.

But since they alternate, with Alice starting, it's similar to that.

So, the MEX would be the smallest number where the number of instances in the array is less than the number of times Alice can pick it.

But this needs more thought.

I think the reference solution might be considering that if a number appears only once, it can be taken by Alice or deleted by Bob.

If there are multiple such numbers, Bob can delete some to prevent Alice from having them.

So, perhaps the MEX is the smallest number where the number of times it appears is less than what Alice can pick.

But I need to formalize this.

Alternatively, perhaps the MEX is the smallest number where the floor of (cnt[i] / 2) < number of times Alice picks.

Wait, I'm getting stuck.

Let me look at the second test case.

Second test case: n=4, a=[0,1,2,3]

Frequency: cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1

According to the sample output, MEX=1

According to my previous logic, for k=1, S_k={0}, count_one=1 <=2, so MEX !=1

But sample output is 1

So, my logic is incorrect.

Wait, perhaps I need to consider that for each k, the number of i in S_k with cnt[i] >=1 is less than or equal to ceil(n/2).

Wait, in the second test case, for k=1, S_k={0}, cnt[0]=1, which is <=2, but sample output is 1, meaning MEX=1.

So, according to the sample, Alice cannot achieve MEX=1, but according to my condition, she can.

So, my condition is not matching the sample.

Perhaps I need to consider that Alice needs to collect all numbers from 0 to k-1, and Bob can delete some to prevent her from collecting them.

In the second test case, for k=1, S_k={0}, cnt[0]=1

Alice needs to collect 0, but since cnt[0]=1, she needs to pick it before Bob deletes it.

She has ceil(4/2)=2 moves.

So, she can pick 0 in one of her moves, and Bob can delete another element.

So, she can collect 0, so MEX should be higher than 1, but sample output is 1.

Wait, maybe I'm misunderstanding.

Looking back at the problem, Alice wants to maximize the MEX, which is the smallest number not in her collection.

So, MEX=1 means that 0 is in her collection, but 1 is not.

In the second test case, a=[0,1,2,3], all numbers from 0 to 3 are present once.

Alice has 2 moves, Bob has 2 moves.

Alice can pick 0 and 1, for example.

Then, Bob deletes 2 and 3.

So, c=[0,1], MEX=2

But the sample output is 1, so perhaps I'm missing something.

Wait, maybe Alice cannot guarantee MEX=2, because Bob can delete something to prevent it.

Wait, but in this case, if Alice picks 0 and 1, then c=[0,1], MEX=2

But the sample output is 1, which suggests that Bob can force MEX=1.

Maybe I need to think differently.

Perhaps Bob can delete 0 in his first move, then Alice picks 1, Bob deletes 2, Alice picks 3.

So, c=[1,3], MEX=0

But MEX is the smallest non-negative integer not in c.

So, 0 is not in c, so MEX=0

But the sample output is 1, not 0.

Wait, in this scenario, MEX would be 0, but sample output is 1.

So, perhaps Bob cannot delete 0.

Wait, but Bob can delete any element.

If Bob deletes 0, then Alice picks 1, Bob picks 2, Alice picks 3, c=[1,3], MEX=0

But sample output is 1, so perhaps there's a different strategy.

Wait, maybe Alice picks 1, Bob deletes 0, Alice picks 2, Bob deletes 3.

Then, c=[1,2], MEX=0

Again, MEX=0, but sample output is 1.

This is confusing.

Wait, perhaps I'm misunderstanding the game.

Let me read the problem again carefully.

"Both players take turns playing, with Alice starting first.

On Alice's turn, she picks one element from a, appends that element to c, and then deletes it from a.

On Bob's turn, he picks one element from a, and then deletes it from a.

The game ends when the array a is empty. Game's score is defined to be the MEX of c. Alice wants to maximize the score while Bob wants to minimize it. Find game's final score if both players play optimally."

So, Alice picks an element, adds it to c, and deletes it from a.

Bob picks an element, deletes it from a, but does not add it to c.

The game ends when a is empty, and the score is MEX of c.

Alice wants to maximize MEX, Bob wants to minimize it.

In the second test case, n=4, a=[0,1,2,3]

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob deletes 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob deletes 3, a=[]

Final c=[0,2], MEX=1

Alternatively:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob deletes 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob deletes 3, a=[]

Final c=[1,2], MEX=0

Another possible game:

- Alice picks 2, c=[2], a=[0,1,3]

- Bob deletes 0, a=[1,3]

- Alice picks 1, c=[2,1], a=[3]

- Bob deletes 3, a=[]

Final c=[2,1], MEX=0

Another possible game:

- Alice picks 3, c=[3], a=[0,1,2]

- Bob deletes 0, a=[1,2]

- Alice picks 1, c=[3,1], a=[2]

- Bob deletes 2, a=[]

Final c=[3,1], MEX=0

In all these scenarios, the MEX is either 0 or 1.

But according to the sample output, it's 1.

So, perhaps the optimal play leads to MEX=1.

Wait, but in one of the sequences, MEX=1, in others MEX=0.

So, perhaps Bob can force MEX to be 1.

Wait, but MEX=1 is lower than MEX=2, which Alice might be able to achieve in some sequences.

But since Bob wants to minimize it, he would choose a sequence where MEX is as small as possible, which is MEX=1 in this case.

Hence, the final MEX is 1.

So, perhaps in some sequences, Alice can achieve MEX=2, but Bob can force it to be MEX=1.

Therefore, the minimal possible MEX that Alice can achieve, with Bob trying to minimize it, is MEX=1.

Hence, the output is 1.

This makes sense now.

So, the correct approach is to find the minimal k such that Alice cannot collect all numbers from 0 to k-1, even if she plays optimally to maximize the MEX.

In the second test case, Alice cannot guarantee MEX >1, because Bob can force MEX=1.

Hence, the output is 1.

Now, back to my earlier logic.

I thought that for k=1, S_k={0}, count_one=1 <= ceil(4/2)=2, so MEX !=1

But according to the sample, MEX=1.

So, my condition is incorrect.

Perhaps I need to consider that Alice needs to collect all numbers from 0 to k-1, and Bob can delete some to prevent her from collecting them.

So, for each k, calculate if Alice can collect all numbers from 0 to k-1, despite Bob's deletions.

In the second test case, for k=1, S_k={0}, cnt[0]=1

Alice needs to collect 0 before Bob deletes it.

She has 2 moves.

So, she can pick 0 in one of her moves, and Bob can delete something else.

Hence, she can collect 0, so MEX should be higher than 1.

But according to the sample, MEX=1.

This suggests that Bob can delete 0 in his move, preventing Alice from collecting it.

Wait, but Alice goes first.

So, she can pick 0 in her first move, adding it to c, and deleting it from a.

Then, Bob deletes 1, Alice picks 2, Bob deletes 3.

c=[0,2], MEX=1

Alternatively, Alice picks 1 first, Bob deletes 0, Alice picks 2, Bob deletes 3.

c=[1,2], MEX=0

So, in one sequence, MEX=1, in another, MEX=0.

But the minimal possible MEX that Alice can achieve, with Bob trying to minimize it, is MEX=1.

Hence, the output is 1.

So, perhaps the condition should be that for each k, the number of i in S_k with cnt[i]==1 must be <= the number of Alice's moves remaining at that point.

This seems more involved.

Alternatively, perhaps I can think in terms of the number of elements Alice needs to protect.

For each k, the number of i in S_k with cnt[i]==1 must be <= the number of Alice's moves.

In the second test case, for k=1, S_k={0}, count_one=1 <=2, so MEX !=1

But sample output is 1.

Wait, perhaps I need to consider that Alice needs to collect all i in S_k with cnt[i]==1 in her moves, and the remaining elements can be collected regardless of Bob's deletions.

Hence, the number of i in S_k with cnt[i]==1 must be <= the number of Alice's moves.

In the second test case, for k=1, count_one=1 <=2, so MEX !=1

But sample output is 1, which contradicts this.

Wait, perhaps I need to consider that Alice has to use some of her moves to collect elements that are not in S_k to maximize the MEX.

This is getting too complicated.

Let me consider another approach.

Let me consider that Alice can collect ceil(n/2) elements, and she wants to collect as many small numbers as possible to maximize the MEX.

Bob can delete floor(n/2) elements to minimize the MEX.

So, the MEX would be the smallest number that Alice cannot collect enough instances of.

But I need a way to compute this efficiently.

Looking back at the reference solution, it seems to iterate through i from 0 to n-1, keeping a counter t that increments when cnt[i]==1, and if t >=2 or cnt[i]==0, it prints i.

In the second test case, n=4, a=[0,1,2,3]

cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1

So, t starts at 0.

For i=0, cnt[0]=1, t=1

For i=1, cnt[1]=1, t=2, t>=2, so print 1

Hence, output is 1, which matches the sample.

Similarly, for the first test case, n=4, a=[0,0,1,1]

cnt[0]=2, cnt[1]=2, cnt[2]=0, cnt[3]=0

For i=0, cnt[0]=2, t=0

For i=1, cnt[1]=2, t=0

For i=2, cnt[2]=0, so print 2

Hence, output is 2, which matches the sample.

For the third test case, n=2, a=[1,1]

cnt[0]=0, cnt[1]=2

For i=0, cnt[0]=0, so print 0

Hence, output is 0, which matches the sample.

So, the reference solution seems to be correct.

Therefore, the condition is:

- Iterate through i from 0 to n-1

- Keep a counter t of the number of i with cnt[i]==1

- If t >=2 or cnt[i]==0, then the MEX is i

This seems to work for the sample inputs.

But why does this work?

I think it's because:

- If cnt[i]==0, then Alice cannot collect i, so MEX is i

- If the number of i with cnt[i]==1 is >=2, then Alice cannot collect both of them with ceil(n/2) moves, so the MEX is the smallest such i

This makes sense in the context of the sample inputs.

In the second test case, cnt[0]=1, cnt[1]=1, so t=2 >=2, hence MEX=1

In the first test case, cnt[0]=2, cnt[1]=2, cnt[2]=0, cnt[3]=0

t=0 <2, so check cnt[2]=0, so MEX=2

In the third test case, cnt[0]=0, cnt[1]=2, so MEX=0

This seems to align with the sample outputs.

Hence, the reference solution is correct.

Therefore, Correctness: **True**