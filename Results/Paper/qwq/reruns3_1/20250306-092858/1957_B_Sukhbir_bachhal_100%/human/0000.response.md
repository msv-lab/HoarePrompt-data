Alright, I have this problem to solve. Let's see what it's asking for. So, I'm given two integers, n and k. I need to construct a sequence of n non-negative integers that sum up to k. Additionally, I have to maximize the number of 1s in the binary representation of the bitwise OR of all these numbers in the sequence.

First, I need to understand what bitwise OR does. Bitwise OR takes two numbers and performs the OR operation on each pair of corresponding bits. For example, 1 OR 2 is 3 because in binary, 1 is 01 and 2 is 10, and OR'ing them gives 11, which is 3.

So, the goal is to have the bitwise OR of all the numbers in the sequence have as many 1s in its binary representation as possible.

Let's consider the constraints:

- n can be from 1 to 2*10^5

- k can be from 1 to 10^9

And there are up to 10^4 test cases, but the sum of n over all test cases doesn't exceed 2*10^5.

Given these constraints, efficiency is important.

Let's think about how to approach this.

First, since the sequence must sum to k, and we have n numbers to choose, I need to distribute k among n numbers such that their sum is k.

Also, I need to maximize the number of 1s in the binary representation of their bitwise OR.

So, what determines the number of 1s in the bitwise OR?

Each bit position can be set to 1 in the OR if at least one of the numbers has that bit set to 1.

Therefore, to maximize the number of 1s in the OR, I need to have as many bit positions as possible set to 1 in at least one of the numbers.

In other words, I need to cover as many bit positions as possible with at least one 1 in that position across all the numbers.

Given that, I need to distribute the sum k among n numbers such that the bitwise OR of these numbers has as many 1s as possible in its binary representation.

Let me think about an example.

Take n=2, k=3.

Possible sequences:

- [1,2]: OR = 1 | 2 = 3 (binary 11), which has two 1s.

- [0,3]: OR = 0 | 3 = 3 (binary 11), same as above.

- [3,0]: same as above.

- [1,2]: same as above.

- [2,1]: same as above.

So, in this case, any distribution where at least one number has each bit set to 1.

Wait, but in this case, 3 is binary 11, so any combination where at least one number is 3 or higher would cover both bits.

But k=3, so higher than 3 isn't possible.

Another example: n=2, k=5.

Possible sequences:

- [4,1]: OR = 4 | 1 = 5 (binary 101), which has two 1s.

- [5,0]: OR = 5 | 0 = 5 (binary 101), same as above.

- [3,2]: OR = 3 | 2 = 3 (binary 011), which has two 1s.

Wait, but 3 | 2 = 3, which is binary 011, which has two 1s.

But 4 | 1 = 5, which is binary 101, which also has two 1s.

So, in this case, it's the same.

Wait, but 5 is binary 101, which has two 1s.

Is there a way to get three 1s?

Let's see.

If I have [5,0], OR is 5 (101), two 1s.

If I have [4,1], OR is 5 (101), two 1s.

If I have [2,3], OR is 3 (011), two 1s.

Is there a way to get more than two 1s?

Wait, 5 in binary is 101, which has two 1s.

Wait, maybe I miscalculated.

Wait, 5 is 101, which has two 1s.

Is there a way to have three 1s in the OR?

Well, to have three 1s, the OR would need to be at least 7 (111).

But is that possible with k=5?

Let's see.

If I have [7, -2], but negative numbers are not allowed.

All numbers must be non-negative.

So, it's impossible to have an OR of 7 because that would require at least one number with the third bit set, but k=5 is less than 7.

Wait, but 7 is 111 in binary, which is 7 in decimal, which is greater than 5.

But the sum is 5, so no single number can be greater than 5.

So, OR can't be greater than 5, because OR can't set a bit that's not set in any of the numbers, and no number can be greater than 5.

Wait, but OR can be less than the maximum number if some bits are not set in some numbers.

Wait, no, OR sets a bit if it's set in any of the numbers.

So, OR can't be greater than the maximum number in the sequence.

Wait, actually, that's not necessarily true.

Wait, no, OR can be equal to the maximum number if that number has all the bits set that any other number has.

But in any case, for k=5, OR can't be greater than 5 because no number in the sequence can be greater than 5.

Wait, but 5 is 101, and OR can't have more bits set than the maximum number in the sequence.

So, in this case, OR can't be greater than 5.

Hence, the maximum number of 1s in OR is the number of 1s in 5, which is two.

Hence, in this case, any sequence where the OR is 5 (101) is optimal.

So, in this case, the program outputs [5,0], which is correct.

Another example: n=2, k=3.

Possible sequences:

- [1,2]: OR = 3 (11), which has two 1s.

- [3,0]: OR = 3 (11), same as above.

- [2,1]: OR = 3 (11).

- [0,3]: OR = 3 (11).

So, any of these are acceptable.

The program outputs [1,2], which is correct.

Now, let's look at n=1, k=5.

Only one number, which is 5.

So, OR is 5 (101), two 1s.

No other options since n=1.

Now, for n=6, k=51.

One possible sequence is [3,1,1,32,2,12].

Let's see:

Sum: 3+1+1+32+2+12 = 51.

OR: 3 | 1 | 1 | 32 | 2 | 12 = ?

Let's compute step by step.

3 is 00000011

1 is 00000001

1 is 00000001

32 is 00100000

2 is 00000010

12 is 00001100

OR of all: 00101111, which is 47 in decimal.

Number of 1s in binary: 5.

Is this the maximum possible?

Let's see.

What's the maximum possible number of 1s in OR for k=51.

First, find the binary representation of 51: 51 is 110011, which has four 1s.

Wait, but OR can have bits set to 1 even if individual numbers don't have those bits set, as long as at least one number has that bit set.

But, in this case, no single number can be larger than 51, because the sum is 51 and there are multiple numbers.

Wait, but in the sequence [3,1,1,32,2,12], the numbers include 32, which is 32 in decimal, binary 100000, which is the 6th bit.

Wait, but 51 is 110011, which is up to the 6th bit.

Wait, 51 is 110011, which is 32 + 16 + 2 + 1 = 32 + 16 = 48, plus 2 and 1 makes 51.

So, the OR is 32 | 16 | 2 | 1 = 32 | 2 | 1 = 35, which is 100011, which has three 1s.

Wait, but in the example, it's [3,1,1,32,2,12], OR is 3 | 1 | 1 | 32 | 2 | 12 = 32 | 2 | 12 | 3 | 1 = 32 is 100000, 2 is 000010, 12 is 001100, 3 is 000011, 1 is 000001.

OR of all: 100000 | 000010 = 100010, | 001100 = 101110, | 000011 = 101111, | 000001 = 101111.

Which is 101111, which is 47, which has five 1s in binary.

Is this the maximum possible?

Well, can we have more than five 1s?

51 in binary is 110011, which has four 1s.

But OR can have more 1s set than in any single number, as long as different numbers set different bits.

Wait, but in this case, no single number can be larger than 51, and the OR can't have more bits set than the union of all bits set in the numbers.

Wait, but 101111 is 47, which is less than 51.

51 is 110011.

Wait, 47 is 101111.

Wait, but 47 is less than 51, but OR can be less than the sum.

So, in this case, it's possible to have OR with five 1s.

Is that the maximum possible?

Well, to maximize the number of 1s in OR, I need to have as many bit positions set to 1 in at least one of the numbers.

Given that, I need to distribute the sum k among n numbers such that as many bit positions as possible are set to 1 in at least one of the numbers.

In other words, I need to cover as many bit positions as possible with at least one 1.

Given that, I should try to set the bits in different numbers to maximize the coverage.

But, I need to ensure that the sum is k.

So, perhaps the strategy is to assign the highest possible numbers first, covering new bit positions, and then filling the remaining sum with smaller numbers.

Wait, but that might not be efficient.

Let me think differently.

Suppose I have n numbers to assign, and I need their sum to be k.

I need to maximize the number of 1s in the bitwise OR of these numbers.

To maximize the number of 1s in the OR, I need to have as many bit positions as possible set to 1 in at least one of the numbers.

So, I should try to set different bit positions in different numbers.

But, since the sum is k, I need to make sure that the sum of these numbers is k.

So, perhaps I should start by finding the minimal number of numbers needed to cover all the bit positions in k, and then fill the remaining numbers with zeros.

Wait, but n can be up to 2*10^5, which is large, so efficiency is key.

Let me consider the following approach:

- Find the binary representation of k.

- Determine the highest set bit in k.

- Assign numbers that cover as many bit positions as possible.

- Fill the remaining sum with zeros.

Wait, but in the example, for n=2, k=5, they assigned [5,0], which covers two 1s in OR.

But [1,4] would also give OR=5, which is the same.

Wait, but in the fourth example, n=6, k=51, they assigned [3,1,1,32,2,12], which gives OR=47, which has five 1s.

Is that better than [51,0,0,0,0,0], which would give OR=51, which has four 1s?

Yes, because 47 has five 1s, which is more than four.

So, by distributing the sum k among multiple numbers, covering more bit positions, we can achieve a higher number of 1s in the OR.

Hence, the strategy is to distribute k among n numbers such that the bitwise OR covers as many bit positions as possible.

To do this efficiently, I can:

- Find the minimal number of numbers needed to cover all the bit positions in k.

- Assign those numbers accordingly.

- Set the remaining numbers to zero.

But, to maximize the number of 1s in OR, I need to cover as many bit positions as possible.

Wait, but in the fourth example, they covered five bit positions with OR=47 (101111), which has five 1s.

While OR=51 (110011) has four 1s.

Hence, by distributing k among multiple numbers, I can cover more bit positions and have more 1s in the OR.

So, the strategy should be:

- Assign one number as the maximal possible to cover as many bit positions as possible.

- Then, assign the remaining sum to other numbers, trying to cover new bit positions.

Wait, but this might not be efficient for large n.

Alternatively, I can find the minimal number of numbers needed to cover all the bit positions in k, and then set the remaining numbers to zero.

Wait, but how do I find the minimal number of numbers needed to cover all the bit positions in k?

Wait, perhaps I need to find the number of distinct bits set in k.

Wait, but that's not accurate.

Wait, for example, k=5 is 101, which has two bits set.

But in the sequence [3,1,1,32,2,12], OR=47 (101111), which has five bits set.

So, by distributing k among multiple numbers, I can cover more bit positions.

Hence, perhaps the strategy is to assign one number as (2^b - 1), where b is the highest set bit in k, and then assign the remaining sum to other numbers.

Wait, in the code, there's a function func_1(n), which seems to find the position of the highest set bit in n.

Wait, let's look at the code.

The code does:

if n > 1:

counter = func_1(k)

arr.append(2 ** counter - 1)

arr.append(k - arr[-1])

for _ in range(n - 2):

arr.append(0)

else:

print(k)

So, for n > 1, it finds the highest set bit position using func_1(k), which seems to return the position of the highest set bit.

Then, it assigns 2**counter - 1 to the first number, and k - that to the second number, and sets the remaining n-2 numbers to zero.

Wait, but 2**counter - 1 is a number with the first counter bits set to 1.

For example, if counter=3, 2**3 -1 = 7 (111), which has three bits set.

So, by choosing 2**counter -1, it sets the first counter bits to 1, and then assigns the remaining sum to the second number.

This way, the OR of the sequence will have at least counter bits set to 1, plus any additional bits set in the second number.

Is this optimal?

Let's see.

Take n=2, k=5.

5 is 101 in binary.

func_1(5) returns position=3 (since the highest set bit is at position 3, which is 4).

So, arr.append(2**3 -1 =7), but 7 is 111, which is greater than k=5.

Wait, but k=5, and 7 >5, which would make arr.append(7), and then arr.append(k -7 =5-7=-2), which is negative, which is invalid.

Wait, but in the code, it's checking if n >1, and then proceeds as above.

Wait, but in the example, for n=2, k=5, it outputs [5,0], which seems to handle this case differently.

Wait, perhaps I need to understand func_1 better.

func_1(n):

if n ==0:

return -1

position=0

while n !=0:

n>>=1

position +=1

return position -1

So, func_1(n) returns the position of the highest set bit minus one.

For n=5 (101), position=3-1=2.

So, counter=2.

Then, 2**2 -1=3.

So, arr.append(3), arr.append(5-3=2), and then for n-2=0 times, append 0.

Hence, arr=[3,2], which OR is 3|2=3 (11 | 10 =11), which is 3, which is binary 11, two 1s.

But in the example, it's [1,2], which OR is 3 (11), same number of 1s.

So, it's equivalent.

But in the problem statement, for n=2, k=5, it shows [5,0], which also has OR=5 (101), which has two 1s.

So, both are acceptable.

Hence, the code seems to be working correctly.

Another example: n=6, k=51.

func_1(51)=position of highest set bit is 5 (32), so counter=5.

2**5 -1=31.

Then, arr.append(31), arr.append(51-31=20), and then append 0 four times.

So, arr=[31,20,0,0,0,0].

OR=31|20=31|10100=31 is 11111, which is 31 in decimal, binary 11111, which has five 1s.

Wait, but in the example, it's [3,1,1,32,2,12], which OR=47 (101111), which has five 1s.

So, both have five 1s, which is the same.

Hence, the code's approach is acceptable.

So, the code seems to be correct.

Hence, Correctness: True

**Final Solution**

To solve this problem, we need to construct a sequence of `n` non-negative integers that sum up to `k`, while maximizing the number of 1s in the binary representation of their bitwise OR.

## Approach

1. **Understanding the Requirements**:
   - We need to create `n` non-negative integers that add up to `k`.
   - The bitwise OR of these integers should have as many bits set to 1 as possible.

2. **Key Insight**:
   - To maximize the number of 1s in the bitwise OR, we need to cover as many bit positions as possible with at least one 1 across all the numbers in the sequence.

3. **Strategy**:
   - For `n > 1`, find the highest bit position in `k` and create a number that sets the first `counter` bits to 1, where `counter` is the position of the highest set bit in `k`.
   - Assign this number and the remainder to `n-1` positions, and set the remaining positions to 0.
   - For `n == 1`, simply output `k`.

## Solution Code

```python
t = int(input())
for _ in range(t):
    (n, k) = [int(x) for x in input().split()]
    arr = []
    if n > 1:
        counter = func_1(k)
        arr.append(2 ** counter - 1)
        arr.append(k - arr[-1])
        for _ in range(n - 2):
            arr.append(0)
        print(*arr)
    else:
        print(k)

def func_1(n):
    if n == 0:
        return -1
    position = 0
    while n != 0:
        n >>= 1
        position += 1
    return position - 1
```

## Explanation

- **func_1(n)**: This function finds the position of the highest set bit in `n`. For example, for `n = 5` (binary `101`), the highest set bit is at position 2 (0-indexed).
  
- **Main Logic**:
  - For each test case, read `n` and `k`.
  - If `n == 1`, directly print `k` as the single number in the sequence.
  - If `n > 1`, compute `counter` as the position of the highest set bit in `k`.
  - Append `2 ** counter - 1` to the sequence, which sets the first `counter` bits to 1.
  - Append the remainder of `k` minus the first number to the sequence.
  - Append zeros to the sequence for the remaining `n - 2` positions.
  - Print the sequence.

This approach ensures that the sequence sums to `k` and maximizes the number of 1s in the bitwise OR of the sequence.