Alright, I have this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform exactly k operations on it. In each operation, I select a contiguous subarray (which could be empty), compute its sum, and insert that sum anywhere in the array. I need to maximize the sum of the array after k such operations, and since the sum can be very large, I have to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation does. Selecting a subarray and inserting its sum into the array means that the array's length increases by one each time. For example, if I have an array [1, 2, 3] and I choose the subarray [2, 3], whose sum is 5, and insert it at the beginning, the new array becomes [5, 1, 2, 3]. The sum has increased by 5, but I need to consider how this affects the overall sum after k operations.

Wait, actually, in this operation, I'm inserting the sum of the subarray into the array, but I'm not removing the original subarray. So, in the example above, inserting 5 at the beginning makes the array [5, 1, 2, 3], and the sum is now 5 + 1 + 2 + 3 = 11, whereas before it was 1 + 2 + 3 = 6. So, the sum increased by 5, which is the sum of the subarray I inserted.

But, if I choose an empty subarray, its sum is 0, and inserting 0 into the array doesn't change the sum. So, in that case, the sum remains the same.

I need to maximize the sum after k operations. So, ideally, I want to increase the sum as much as possible in each operation.

Let me think about what's the best subarray to choose each time. If I choose the subarray with the maximum sum and insert that sum into the array, that would increase the total sum by that maximum sum each time.

Wait, but I can choose any subarray, including the entire array, and insert its sum. So, perhaps choosing the entire array each time and inserting its sum would be optimal.

Let me consider an example. Suppose I have an array [2, 2, 8], and k=3.

If I choose the entire array each time, whose sum is 12, and insert it:

After first operation: [2, 2, 8, 12], sum = 24

After second operation: [2, 2, 8, 12, 24], sum = 48

After third operation: [2, 2, 8, 12, 24, 48], sum = 96

So, the sum is 96.

Is there a better way? If I choose a different subarray, say [2, 8], sum=10, and insert it:

After first operation: [2, 2, 8, 10], sum=22

After second operation: [2, 2, 8, 10, 22], sum=42

After third operation: [2, 2, 8, 10, 22, 42], sum=86

This is less than 96, so choosing the entire array seems better.

Another example: array [-4, -7], k=2.

If I choose the entire array, sum=-11, and insert it:

After first operation: [-4, -7, -11], sum=-22

After second operation: [-4, -7, -11, -22], sum=-44

But, if I choose an empty subarray each time, sum=0, and insert it:

After first operation: [-4, -7, 0], sum=-11

After second operation: [-4, -7, 0, 0], sum=-11

This is better than -44, so in this case, choosing the empty subarray is better.

Wait, but according to the sample input, for n=2, k=2, a=[-4, -7], the output is 999999996, which is -11 modulo 10^9 + 7.

So, in this case, choosing the empty subarray twice is better than choosing the entire subarray.

So, the strategy seems to be: if the sum of the entire array is positive, choose the entire array each time; if it's negative, choose the empty subarray.

But wait, in the first example, sum is -11, which is negative, so choosing the empty subarray is better.

In the second example, sum is 12, which is positive, so choosing the entire array is better.

But, is that always the case?

Let me think about another example. Suppose array is [1, -2, 3], sum=2.

If I choose the entire array, sum=2, and insert it:

After first operation: [1, -2, 3, 2], sum=4

After second operation: [1, -2, 3, 2, 4], sum=8

After third operation: [1, -2, 3, 2, 4, 8], sum=16

But, if I choose a different subarray, say [3], sum=3:

After first operation: [1, -2, 3, 3], sum=5

After second operation: [1, -2, 3, 3, 5], sum=10

After third operation: [1, -2, 3, 3, 5, 10], sum=20

This is better than 16.

Wait, but the sum of the entire array is 2, which is less than the sum of [3], which is 3.

So, in this case, choosing [3] is better than choosing the entire array.

So, maybe I should choose the subarray with the maximum sum each time, not necessarily the entire array.

In this case, choosing [3] each time would be better.

After first operation: [1, -2, 3, 3], sum=5

After second operation: [1, -2, 3, 3, 3], sum=8

After third operation: [1, -2, 3, 3, 3, 3], sum=11

Which is better than choosing the entire array's sum each time.

Wait, but in the first case, choosing [3] led to a higher sum.

In the previous case with [2,2,8], choosing the entire array's sum was better because its sum was higher than any subarray's sum.

Wait, no. In [2,2,8], the entire array's sum is 12, and any other subarray's sum is less than or equal to 12.

Wait, but [2,8] sums to 10, which is less than 12.

So, choosing the entire array is better.

In [1,-2,3], the entire array sums to 2, but choosing [3] gives a higher sum when inserted.

Wait, but in the first operation, choosing [3] and inserting it makes the array [1,-2,3,3], sum=5.

If I choose the entire array, sum=2, insert it to make [1,-2,3,2], sum=4.

So, choosing [3] is better.

In the next operation, again choose [3] and insert it to make [1,-2,3,3,3], sum=8.

Better than choosing the entire array's sum, which would be 5, and inserting 5 to make [1,-2,3,3,5], sum=10.

Wait, that's higher.

Wait, choosing [3] gives sum=8, choosing the entire array gives sum=10.

So, perhaps choosing the entire array is better.

Wait, but in the third operation, choosing the entire array's sum=10, insert it to make [1,-2,3,3,5,10], sum=16.

Choosing [3] would give sum=3, insert it to make [1,-2,3,3,3,3], sum=11.

So, choosing the entire array is better.

Wait, but in the second operation, choosing the entire array's sum=8, insert it to make [1,-2,3,3,8], sum=13.

Then, in the third operation, choose the entire array's sum=13, insert it to make [1,-2,3,3,8,13], sum=26.

That's even better.

Wait, but earlier, when choosing [3] each time, I got sum=11.

So, choosing the entire array's sum each time gives a higher sum.

Wait, but in the second operation, if I choose the entire array's sum=8 and insert it, getting [1,-2,3,3,8], sum=13.

Then, in the third operation, choose the entire array's sum=13 and insert it to make [1,-2,3,3,8,13], sum=26.

This is better than choosing [3] each time, which gave sum=11.

So, perhaps choosing the entire array's sum each time is better.

Wait, but in the first operation, choosing [3] gave sum=5, and choosing the entire array gave sum=4.

So, perhaps it's better to choose the subarray with the maximum sum each time.

In this case, in the first operation, choosing [3] is better than choosing the entire array.

But in subsequent operations, choosing the entire array's sum becomes better.

So, maybe I need to choose the subarray with the maximum sum at each step, considering the current state of the array.

But that seems too time-consuming to compute at each step.

Is there a pattern or a formula that can help me compute the maximum possible sum after k operations without simulating each operation?

Let me think about it.

Each operation involves selecting a subarray, computing its sum, and inserting it into the array.

Inserting a number into the array increases the sum of the array by that number.

So, if I choose a subarray with sum S and insert it, the array's sum increases by S.

Therefore, in k operations, if I can choose subarrays with sums S1, S2, ..., Sk and insert them, the total sum will be the original sum plus S1 + S2 + ... + Sk.

My goal is to maximize this total sum, so I need to maximize the sum of the S1 to Sk.

But each Si is the sum of some subarray of the current array.

Wait, but the array changes after each operation, because I insert a new sum into it.

This seems recursive, but it's complicated to track.

Is there a way to simplify this?

Let me consider that in each operation, I can add any subarray sum to the array's sum.

But the subarray sum is bounded by the maximum subarray sum possible.

So, if I can find the maximum subarray sum, and add it in each operation, that would be optimal.

Wait, but in the earlier example, choosing the entire array's sum was better than choosing a specific subarray's sum.

But in another example, choosing a specific subarray's sum was better.

Wait, perhaps I need to choose the subarray with the maximum sum available at each step.

But the array changes after each operation, so the maximum subarray sum could change.

This seems tricky.

Is there a pattern or mathematical formula that can help?

Let me consider that in each operation, I can add any value that is equal to the sum of some subarray.

But since I can choose where to insert the sum, and the subarray can be chosen freely, perhaps there's a way to model this.

Wait, perhaps I can think in terms of the maximum possible sum after k operations.

Let me denote S as the original sum of the array.

In each operation, I can add any value that is equal to the sum of some subarray of the current array.

I need to maximize the sum after k operations.

Wait, perhaps I can think recursively.

Let me denote M(i) as the maximum sum after i operations.

Then, M(i) = M(i-1) + max_subarray_sum(M(i-1))

But this seems recursive and would be too slow to compute for large k.

Is there a better way?

Wait, maybe I can find a way to compute the maximum possible sum after k operations in terms of the original array's sum and some property of the array.

Let me consider that in each operation, I can add any sum of a subarray to the total sum.

But the subarrays are from the original array, or from the modified array after insertions.

Wait, but the array changes after each insertion.

This is getting complicated.

Perhaps I need to find a different approach.

Let me look at the sample input and output.

In the first sample:

n=2, k=2, a=[-4,-7]

The output is 999999996, which is -11 modulo 10^9 + 7.

In this case, choosing the empty subarray twice is better, as it adds 0 each time, resulting in sum=-11.

If I had chosen the entire array, sum=-11, and inserting it twice would result in sum=-33, which is worse.

So, in this case, choosing the empty subarray is better.

In the second sample:

n=3, k=3, a=[2,2,8]

The output is 96.

As per the explanation, choosing the entire array's sum each time and inserting it leads to sums 12, 24, 48, total sum 96.

This seems to be better than choosing any other subarray.

So, perhaps the strategy is to choose the subarray with the maximum sum and insert it each time.

But in the first sample, choosing the empty subarray is better.

So, perhaps I need to choose between the maximum subarray sum and zero, and choose the one that maximizes the sum.

Wait, but the empty subarray sum is zero, which might be better if the maximum subarray sum is negative.

In the first sample, the maximum subarray sum is -4 (since all elements are negative), which is less than zero, so choosing the empty subarray is better.

In the second sample, the maximum subarray sum is 12, which is greater than zero, so choosing it is better.

So, perhaps the strategy is:

- Find the maximum subarray sum of the original array, let's call it M.

- If M >= 0, then in each operation, choose the entire array's sum and insert it, which adds S to the sum each time, where S is the current sum.

- If M < 0, choose the empty subarray, which adds 0 each time.

Wait, but in the second sample, choosing the entire array's sum adds 12 each time, but according to this, choosing M=12 would add 12 each time.

But in reality, choosing the entire array's sum adds the current sum S each time, which is increasing.

Wait, no, wait.

If I choose the entire array's sum, which is S, and insert it, the new sum becomes S + S = 2S.

Then, in the next operation, choosing the entire array's sum would be 2S, and inserting it makes the sum 2S + 2S = 4S.

After k operations, the sum would be S * (2^k).

But in the sample, with n=3, k=3, a=[2,2,8], S=12.

So, 12 * (2^3) = 12 * 8 = 96, which matches the sample output.

So, in this case, choosing the entire array's sum each time achieves S * 2^k.

But, in the first sample, with n=2, k=2, a=[-4,-7], S=-11.

Choosing the entire array's sum each time would result in -11 * (2^2) = -44, which is worse than choosing the empty subarray, which adds 0 each time, resulting in sum=-11.

So, perhaps the optimal sum is max(M, 0) * (2^k) - M, where M is the maximum subarray sum.

Wait, in the first sample, M=-4, so max(-4, 0) = 0, then 0 * (2^2) - (-4) = 0 - (-4) = 4, but the output is -11.

Wait, that doesn't match.

Wait, perhaps it's max(M, 0) * (2^k) + S - M.

In the first sample, M=-4, S=-11.

So, 0 * 4 + (-11) - (-4) = -11 + 4 = -7, which is still not matching the output of -11.

Hmm.

Wait, perhaps it's max(M, 0) * k + S.

In the first sample, 0 * 2 + (-11) = -11, which matches.

In the second sample, 12 * 2 + 12 = 36, which is not matching the output of 96.

Wait, no, in the second sample, choosing the entire array's sum each time results in S * (2^k) = 12 * 8 = 96, which is different from max(M,0) * k + S = 12*3 + 12 = 48, which doesn't match.

So, that's not correct.

Wait, perhaps it's max(M,0) * (2^k - 1) + S.

In the first sample, 0 * (4 - 1) + (-11) = -11, which matches.

In the second sample, 12 * 7 + 12 = 84 + 12 = 96, which matches.

Okay, this seems promising.

Let me verify with another example.

Consider array [1, -2, 3], S=2, M=3.

According to this formula, max(M,0) * (2^k - 1) + S = 3 * (8 - 1) + 2 = 21 + 2 = 23.

But earlier, when I simulated operations, choosing the entire array's sum led to 2 * 8 = 16, which is less than 23.

Wait, but according to this formula, it's 23, but in practice, I could only get 16.

So, perhaps this formula overestimates the sum.

Wait, maybe I made a mistake in simulation.

Let me try again.

Start with [1,-2,3], S=2.

Choose subarray [3], sum=3, insert it: [1,-2,3,3], S=5.

Choose subarray [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Choose subarray [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

So, sum=17, which is less than the formula's 23.

Wait, what's happening here?

Is the formula incorrect?

Wait, perhaps the formula assumes choosing the maximum possible sum each time, which in this case is choosing the entire array's sum.

But in reality, choosing the entire array's sum leads to:

First operation: choose S=2, insert 2: [1,-2,3,2], S=4.

Second operation: choose S=4, insert 4: [1,-2,3,2,4], S=8.

Third operation: choose S=8, insert 8: [1,-2,3,2,4,8], S=16.

Which is less than the 17 obtained by choosing [3] and [6].

So, the formula seems to overestimate what's achievable.

Wait, perhaps the formula is not accurate.

Let me think differently.

Each operation allows me to insert any subarray's sum into the array, which effectively adds that sum to the total sum.

So, to maximize the sum after k operations, I should choose the subarray with the maximum sum in each operation and insert it.

But in reality, as seen in the example above, choosing the subarrays with higher sums leads to higher total sums.

But, in practice, it's not as straightforward as choosing the entire array's sum each time.

Wait, perhaps I need to find the maximum possible sum that can be added in each operation, considering that the array grows with each insertion.

This seems complicated.

Is there a mathematical pattern here?

Let me consider that in each operation, I can add any sum of a subarray of the current array.

But the current array includes previously inserted sums.

Wait, perhaps I can model this as the sum after k operations being the original sum plus k times the maximum subarray sum.

But in the second sample, that would be 12 + 3*12 = 48, which doesn't match the actual achievable sum of 96.

Wait, perhaps it's the original sum multiplied by 2^k.

In the second sample, 12 * 8 = 96, which matches.

In the first sample, -11 * 4 = -44, but according to the sample, it's -11, meaning that choosing to add 0 in each operation is better.

So, perhaps the formula is:

If the maximum subarray sum is greater than or equal to zero, then the sum is S * (2^k).

Else, if the maximum subarray sum is less than zero, then the sum is S + k*0 = S.

But in the first sample, S=-11, M=-4, so choosing to add 0 each time results in sum=-11, which matches.

In the second sample, S=12, M=12, so sum=12*(2^3)=96, which matches.

In the third sample, n=1, k=7, a=[7], S=7, M=7.

So, sum=7*(2^7)=7*128=896, which matches the expected output.

In the fourth sample, n=5, k=1, a=[4,-2,8,-12,9], S=7, M=8.

According to the formula, since M >=0, sum=7*(2^1)=14, but the sample output is 17.

Wait, that doesn't match.

So, perhaps the formula is not entirely correct.

Wait, in this case, choosing the entire array's sum and inserting it would give [4,-2,8,-12,9,7], sum=14.

But according to the note, it's advantageous to take the sum of the first three numbers, which is 10, and insert it at the beginning, resulting in [10,4,-2,8,-12,9], sum=17.

So, in this case, choosing a specific subarray's sum leads to a higher sum than choosing the entire array's sum.

So, the formula S*(2^k) is not always accurate.

Wait, perhaps I need to choose the maximum possible sum that can be added in each operation, which is the maximum subarray sum.

But in this case, the maximum subarray sum is 8, but choosing the sum of [4,-2,8]=10 leads to a higher sum.

Wait, but 10 is greater than 8?

Wait, no, 4 + (-2) + 8 = 10, which is greater than 8.

So, the maximum subarray sum is 10.

Wait, perhaps I miscalculated M.

Let me compute M for [4,-2,8,-12,9].

Possible subarrays:

[4]: 4

[4,-2]: 2

[4,-2,8]: 10

[4,-2,8,-12]: -2

[4,-2,8,-12,9]: 7

[-2]: -2

[-2,8]: 6

[-2,8,-12]: -6

[-2,8,-12,9]: 3

[8]: 8

[8,-12]: -4

[8,-12,9]: 5

[-12]: -12

[-12,9]: -3

[9]: 9

So, the maximum subarray sum M is 10.

So, according to the formula, S*(2^k) = 7*2 = 14, but choosing the subarray with sum 10 and inserting it gives sum=17, which is higher.

So, the formula underestimates the achievable sum.

So, perhaps the formula is not correct.

Wait, maybe the formula should be (S + M) * (2^k - 1), but in this case, (7 + 10)*(2 - 1)=17*1=17, which matches.

In the second sample, S=12, M=12, (12+12)*(8-1)=24*7=168, which is not matching the sample output of 96.

Wait, perhaps it's S + M * (2^k - 1).

In the fourth sample, S=7, M=10, so 7 + 10*(2 - 1)=7 + 10=17, which matches.

In the second sample, S=12, M=12, 12 + 12*(8 -1)=12 + 84=96, which matches.

In the first sample, S=-11, M=0, -11 + 0*(4 -1)= -11 + 0= -11, which matches.

So, this seems to be the correct formula: S + M * (2^k -1), where M is the maximum subarray sum.

Wait, but in the third sample, n=1, k=7, a=[7], S=7, M=7.

According to the formula, 7 + 7*(128 -1)=7 + 7*127=7 + 889=896, which matches the expected output.

In another example, [1,-2,3], S=2, M=3.

According to the formula, 2 + 3*(8 -1)=2 + 21=23, which is higher than what's achievable by simulation.

But earlier, in simulation, I could only get up to 17 by choosing [3] and [6].

So, perhaps the formula overestimates in some cases.

Wait, perhaps I made a mistake in simulation.

Let me try again.

Start with [1,-2,3], S=2.

Choose subarray [3], sum=3, insert it: [1,-2,3,3], S=5.

Choose subarray [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Choose subarray [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Wait, but according to the formula, it's 2 + 3*(8-1)=23.

So, perhaps there's a way to achieve 23.

Wait, maybe I can choose different subarrays.

First operation: choose [3], sum=3, insert it: [1,-2,3,3], S=5.

Second operation: choose [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Third operation: choose [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Wait, I'm not reaching 23.

Alternatively, first operation: choose [3], sum=3, insert it: [1,-2,3,3], S=5.

Second operation: choose [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Third operation: choose [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Wait, perhaps I need to choose differently.

First operation: choose [3], sum=3, insert it: [1,-2,3,3], S=5.

Second operation: choose [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Third operation: choose [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Still, only 17.

Wait, perhaps I can choose a different subarray in the first operation.

First operation: choose [1,-2,3], sum=2, insert it: [1,-2,3,2], S=4.

Second operation: choose [3,2], sum=5, insert it: [1,-2,3,2,5], S=9.

Third operation: choose [5], sum=5, insert it: [1,-2,3,2,5,5], S=14.

This is less than 17, so 17 is better.

Wait, perhaps there's a better sequence.

First operation: choose [3], sum=3, insert it: [1,-2,3,3], S=5.

Second operation: choose [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Third operation: choose [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Alternatively, third operation: choose [3,3,6], sum=12, insert it: [1,-2,3,3,6,12], S=22.

Ah, that's better.

Then, in the third operation, choosing [3,3,6], sum=12, insert it to make [1,-2,3,3,6,12], S=22.

That's better than 17.

So, perhaps with better choices, I can reach higher sums.

Is there a way to reach 23?

Wait, according to the formula, it's 2 + 3*(7)=2 + 21=23.

So, perhaps with optimal choices, it's possible.

Starting with [1,-2,3], S=2.

First operation: choose [3], sum=3, insert it: [1,-2,3,3], S=5.

Second operation: choose [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Third operation: choose [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Alternatively, third operation: choose [3,3,6], sum=12, insert it: [1,-2,3,3,6,12], S=22.

Wait, that's 22, which is still less than 23.

Is there a way to get to 23?

Wait, maybe:

First operation: choose [3], sum=3, insert it: [1,-2,3,3], S=5.

Second operation: choose [3,3], sum=6, insert it: [1,-2,3,3,6], S=11.

Third operation: choose [6], sum=6, insert it: [1,-2,3,3,6,6], S=17.

Alternatively, third operation: choose [3,6], sum=9, insert it: [1,-2,3,3,6,9], S=20.

Alternatively, choose [1,-2,3,3,6], sum=11, insert it: [1,-2,3,3,6,11], S=22.

Still, no 23.

Wait, perhaps it's not achievable, and the formula is incorrect.

So, perhaps the formula S + M * (2^k -1) overestimates in some cases.

But in the sample cases, it seems to work.

In the fourth sample, S=7, M=10, k=1.

According to the formula, 7 + 10*(2 -1)=17, which matches the note.

In the second sample, S=12, M=12, k=3: 12 + 12*(8 -1)=12 + 84=96, which matches.

In the first sample, S=-11, M=0, k=2: -11 + 0*(4 -1)=-11, which matches.

In the third sample, S=7, M=7, k=7: 7 + 7*(128 -1)=7 + 889=896, which matches.

In the fifth sample, S=8 + 14 + (-9) + 6 + 0 + (-1) + 3=21, M=21.

According to the formula, 21 + 21*(128 -1)=21 + 2649=2670.

But I don't have the sample output for that, but assuming the formula holds.

Wait, in the earlier simulation, I couldn't reach the formula's value, but maybe I wasn't choosing optimally.

Perhaps the formula holds, and I was just not choosing the optimal subarrays in my simulation.

So, perhaps the formula S + M * (2^k -1) is correct, where M is the maximum subarray sum.

So, in code, I need to compute M, which is the maximum subarray sum, and then compute S + M * (2^k -1), and take modulo 10^9 +7.

Wait, but in the simulation, I couldn't reach the formula's value, but maybe it's achievable with better choices.

Assuming the formula is correct, I can proceed with that.

So, in code, I need to compute:

- S: the sum of the original array.

- M: the maximum subarray sum.

Then, the maximum sum after k operations is S + M * (2^k -1), modulo 10^9 +7.

I need to compute M, which is the maximum sum of any subarray of the original array.

I can use Kadane's algorithm to find M.

Then, compute S + M * (2^k -1), and take modulo 10^9 +7.

Wait, but in the first sample, M was 0, because all elements are negative.

Wait, in the first sample, M should be the maximum subarray sum, which is the maximum element, which is -4.

But according to the note, choosing the empty subarray is better, which corresponds to M=0.

Wait, perhaps I need to set M to max(0, maximum subarray sum).

So, if the maximum subarray sum is negative, set M=0.

Else, set M=maximum subarray sum.

Then, the formula becomes S + M * (2^k -1).

In the first sample, S=-11, M=0, so sum=-11 + 0*(4-1)=-11, which matches.

In the second sample, S=12, M=12, sum=12 + 12*7=96, which matches.

In the third sample, S=7, M=7, sum=7 + 7*127=896, which matches.

In the fourth sample, S=7, M=10, sum=7 + 10*1=17, which matches.

So, yes, this seems correct.

Hence, in code, I need to:

- Read t test cases.

- For each test case:

- Read n, k.

- Read array a.

- Compute S: sum(a).

- Compute M: maximum subarray sum.

- If M < 0, set M=0.

- Compute sum = S + M * (2^k -1).

- Take sum modulo 10^9 +7.

- Output the sum.

Now, to implement this efficiently.

Constraints:

- t <= 10^4

- Sum of n and k over all test cases <= 2*10^5.

So, I need an efficient implementation.

Computing sum(a) is O(n).

Computing maximum subarray sum can be done in O(n) using Kadane's algorithm.

Then, computing 2^k can be done in O(log k) time.

So, overall time complexity is O(n + log k) per test case, which should be acceptable.

Edge cases to consider:

- All elements are negative: in this case, M=0, and sum=S.

- S=0, M=0: sum=0.

- S negative, M positive: sum = S + M*(2^k -1).

- k=0: but k >=1, as per constraints.

- n=1: simple case.

- Large n and k: need to handle large exponents efficiently.

Implementing 2^k efficiently modulo 10^9 +7.

In Python, exponentiation is efficient, and we can compute 2^k % (10^9 +6) directly.

Wait, but in the formula, it's M * (2^k -1), so I need to compute (2^k -1) modulo 10^9 +7.

But since 2^k can be large, I can compute 2^k % p, then subtract 1, and take modulo again.

Where p=10^9 +7.

So, (2^k -1) % p = (2^k % p -1) % p.

Similarly, M * (2^k -1) % p = (M % p * (2^k % p -1) % p) % p.

Then, sum = (S % p + M % p * (2^k % p -1) % p) % p.

This way, I can handle large numbers.

Implementing Kadane's algorithm to find M.

Initialize M = max(a[0], 0)

Then, iterate through a[1:]:

current_max = max(a[i], current_max + a[i], 0)

M = max(M, current_max)

This way, M is the maximum subarray sum, and if all elements are negative, M=0.

Wait, but in standard Kadane's algorithm, M should be the maximum sum of any subarray, which could be negative if all elements are negative.

But in this case, since choosing the empty subarray is allowed, and its sum is 0, we should set M to max(Kadane's M, 0).

So, in code, after running Kadane's algorithm, set M = max(M, 0).

But in the implementation above, if current_max + a[i] < 0, we can reset it to 0.

Wait, perhaps a better way is:

Initialize M = 0

Initialize current_sum = 0

For each element a[i]:

current_sum += a[i]

if current_sum < 0:

current_sum = 0

if current_sum > M:

M = current_sum

This way, M is the maximum subarray sum, and if all elements are negative, M=0.

Yes, this is correct.

So, in code, I can implement this.

Now, to handle large exponents, I can use the built-in pow function, which is efficient.

pow(2, k, p) gives 2^k % p.

Then, (pow(2, k, p) -1) % p gives (2^k -1) % p.

Then, M * (2^k -1) % p = (M % p * (pow(2, k, p) -1) % p) % p.

Finally, sum = (S % p + M % p * (pow(2, k, p) -1) % p) % p.

This should handle large numbers efficiently.

Implementing this in code.

I need to read t test cases.

For each test case:

Read n, k

Read array a

Compute S = sum(a)

Compute M using the modified Kadane's algorithm as above.

Compute sum = (S % p + M % p * (pow(2, k, p) -1) % p) % p

Print sum

Edge cases:

- n=1, k=1, a=[-1]: S=-1, M=0, sum=-1 + 0*(2-1)= -1

- n=1, k=1, a=[1]: S=1, M=1, sum=1 +1*(2-1)=2

- n=2, k=2, a=[-1,-1]: S=-2, M=0, sum=-2 +0*(4-1)=-2

- n=2, k=2, a=[1,2]: S=3, M=3, sum=3 +3*(4-1)=12

Seems correct.

I think this should work.

## Final Solution
To solve this problem, we need to maximize the sum of an array after performing exactly k operations, where each operation involves selecting a contiguous subarray (which may be empty), computing its sum, and inserting that sum back into the array.

### Approach
1. **Initial Setup:**
   - Read the number of test cases, t.
   - For each test case, read n (length of the array), k (number of operations), and the array a.

2. **Compute the Original Sum (S):**
   - Calculate the sum of the original array a.

3. **Find the Maximum Subarray Sum (M):**
   - Use a modified version of Kadane's algorithm to find the maximum sum of any subarray in a.
   - If all elements are negative, set M to 0, as choosing an empty subarray is beneficial.

4. **Compute the Final Sum:**
   - Use the formula to compute the maximum possible sum after k operations: 
     \[
     \text{sum} = \left( S \% p + M \% p \times (2^k - 1) \% p \right) \% p
     \]
   - Use efficient modular arithmetic to handle large numbers.

5. **Output the Result:**
   - Print the computed sum for each test case.

### Solution Code
```python
MOD = 10**9 + 7

def max_subarray_sum(a):
    best = 0
    current = 0
    for num in a:
        current += num
        if current < 0:
            current = 0
        if current > best:
            best = current
    return best

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1