Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform exactly k operations on it. In each operation, I select a contiguous subarray (which could even be empty), compute its sum, and insert that sum anywhere in the array. I need to maximize the sum of the array after k such operations, and since the result can be very large, I have to output it modulo 10^9 + 7.

First, I need to understand what these operations allow me to do. Selecting a subarray and inserting its sum into the array means I'm effectively adding that sum to the total array sum, because the subarray's sum is being added again at a new position.

Wait, but actually, when I insert the sum of a subarray, I'm adding that value to the array, which increases the total sum by that amount. However, I'm not removing the original subarray; I'm just inserting the sum elsewhere. So, the total sum of the array increases by the sum of the subarray I chose.

But, if I choose an empty subarray, its sum is zero, and inserting zero doesn't change the sum of the array. So, in that case, the total sum remains the same.

So, in each operation, I can choose any contiguous subarray (including empty), compute its sum, and insert it into the array, thereby increasing the total sum by that amount.

My goal is to maximize the sum after exactly k operations.

Given that, it seems like I should always choose the subarray with the maximum possible sum and insert it. But I have to do this k times, and each time I do this, the sum of the array increases by the sum of the subarray I choose.

Wait, but actually, after each insertion, the array changes, so the possible subarrays and their sums change.

But, perhaps there's a pattern or a way to compute the total sum after k operations without simulating each operation.

Let me think differently. Suppose I choose a particular subarray with sum S and insert it into the array. Then, the new sum of the array becomes the old sum plus S.

If I repeat this operation k times, each time choosing the same subarray with sum S, then the total sum would be the initial sum plus k*S.

But, I can choose different subarrays in each operation, so maybe I should choose the one with the maximum possible S each time.

But, the problem allows me to choose any contiguous subarray, including empty (sum 0), and insert its sum into the array.

So, to maximize the sum, I should choose the subarray with the maximum sum possible, and insert it in each operation.

Therefore, if I can find the maximum sum of any contiguous subarray, say M, then after k operations, the total sum would be the initial sum plus k*M.

Wait, but that seems too straightforward. Maybe I'm missing something.

Let me consider the example provided.

In the first test case:

n=2, k=2

a = [-4, -7]

According to the explanation, it's better to choose empty subarrays twice, inserting 0 each time, resulting in a final sum of -4 + -7 + 0 + 0 = -11, which modulo 10^9+7 is 999,999,996.

But, if I choose the subarray with the maximum sum, which is [-4], sum -4, and insert it twice, the array becomes [-4, -7, -4, -4], sum is -19, which is worse than -11.

Alternatively, choosing [-7], sum -7, and inserting twice would give [-4, -7, -7, -7], sum -25, which is worse.

Choosing the empty subarray gives a better result.

So, in this case, choosing the empty subarray is better.

In the second test case:

n=3, k=3

a = [2,2,8]

Choosing the entire array sum=12, and inserting it three times would give [2,2,8,12,24,48], sum=96.

Alternatively, choosing a different subarray might give a higher sum, but according to the explanation, choosing the entire array is optimal.

So, in this case, choosing the entire array sum and inserting it multiple times is better.

From these examples, it seems that sometimes choosing the empty subarray is better, and sometimes choosing a subarray with positive sum is better.

Therefore, the strategy should be to find the maximum sum of any contiguous subarray (which could be zero, if all elements are negative).

Wait, but in the first example, the maximum subarray sum is -4, but choosing the empty subarray (sum 0) is better.

So, perhaps I should consider the maximum sum to be the maximum of the maximum subarray sum and zero.

Because, if the maximum subarray sum is negative, choosing the empty subarray (sum 0) is better.

So, in general, the maximum sum I can add in each operation is the maximum of (maximum subarray sum, 0).

Therefore, after k operations, the total sum would be the initial sum plus k times this maximum addable sum.

In the first example:

Initial sum: -4 + -7 = -11

Maximum subarray sum: -4

Maximum addable sum per operation: max(-4, 0) = 0

So, after k=2 operations, sum = -11 + 2*0 = -11, which matches the first example.

In the second example:

Initial sum: 2 + 2 + 8 = 12

Maximum subarray sum: 12

Maximum addable sum per operation: 12

After k=3 operations: 12 + 3*12 = 48, but according to the explanation, it's 96.

Wait, that doesn't match. In the explanation, they choose the sum of the entire array each time and insert it, resulting in [2,2,8,12,24,48], sum=96.

So, perhaps my assumption is incorrect.

Wait, perhaps I'm missing that when I insert the sum, it's added to the array, which then affects future operations.

Because, in the second example, after inserting 12, the array becomes [2,2,8,12], and then in the next operation, the maximum subarray sum is now 12, and inserting 12 gives [2,2,8,12,24], and so on.

So, the sum that can be added increases with each operation.

This suggests that the maximum addable sum in each operation is not just a constant, but it can grow based on previous insertions.

This complicates things.

So, perhaps in each operation, I can choose the current maximum subarray sum and insert it, which would then allow me to choose an even larger sum in the next operation.

But, this seems recursive and might be time-consuming to simulate directly, especially since n and k can be up to 2e5.

I need a smarter way to compute the maximum possible sum after k operations.

Let me consider that in each operation, I can add the current maximum subarray sum to the total sum.

So, if I denote S as the current sum of the array, and M as the current maximum subarray sum, then after one operation, the new sum is S + M, and the new maximum subarray sum becomes M + M = 2*M.

Because, I can choose the subarray that was just inserted, which has sum M, and insert it again.

Wait, no. When I insert M, the array now has an additional element with value M, so the new maximum subarray sum could be the previous M, or the newly inserted M, or a combination.

But, since I can choose any contiguous subarray, including single elements, the maximum subarray sum after insertion would be the maximum of the previous maximum subarray sum and the inserted sum.

But, if I insert M, and M is positive, then in the next operation, I can insert M again, and so on.

Wait, perhaps in each operation, I can choose to insert the current maximum subarray sum, which would be M, and then the new sum becomes S + M, and the new maximum subarray sum remains M.

Because, the inserted M is just one element, and if there are larger subarrays, their sums would be considered.

But, in the second example, they are choosing to insert the sum of the current array each time, which is increasing exponentially.

Wait, perhaps I'm missing something.

Let me look back at the second example.

Initial array: [2,2,8], sum=12

Operation 1: choose subarray [2,2,8], sum=12, insert 12, array becomes [2,2,8,12], sum=24

Operation 2: choose subarray [2,2,8,12], sum=24, insert 24, array becomes [2,2,8,12,24], sum=48

Operation 3: choose subarray [2,2,8,12,24], sum=48, insert 48, array becomes [2,2,8,12,24,48], sum=96

So, in each operation, they are choosing the sum of the current array and inserting it, effectively doubling the sum each time.

Wait, but in the first operation, they chose the sum of the initial array, which is 12, and inserted it, making the sum 24.

In the second operation, they chose the sum of the new array, which is 24, and inserted it, making the sum 48.

And so on.

So, it seems like in each operation, they are adding the current sum of the array.

But, according to the problem statement, in each operation, I select a contiguous subarray (which could be the entire array), compute its sum, and insert that sum into the array.

So, in each operation, I can choose any contiguous subarray, compute its sum, and insert that sum into the array.

Therefore, in each operation, I can choose the entire array, compute its sum, and insert that sum into the array, which increases the total sum by the current sum.

Wait, but in the second example, they are choosing the sum of the current array and inserting it, leading to exponential growth.

Wait, but in the first operation, they choose the sum of the initial array (12), insert it, making the sum 24.

In the second operation, they choose the sum of the new array (24), insert it, making the sum 48.

In the third operation, they choose the sum of the new array (48), insert it, making the sum 96.

So, it seems like in each operation, they are adding the current sum to itself.

But, in reality, when they insert the sum, it's added once to the array, so the sum increases by that amount.

Wait, no. If the current sum is S, and I insert S, then the new sum is S + S = 2S.

Yes, that matches the example: 12 -> 24 -> 48 -> 96.

So, in each operation, by choosing the entire array and inserting its sum, the sum doubles each time.

But, is this always the optimal strategy?

In the first example, it's not, because choosing the empty subarray (sum 0) is better.

So, perhaps the strategy is:

- If the maximum subarray sum is positive, then in each operation, choose the entire array and insert its sum, which effectively doubles the sum each time.

- If the maximum subarray sum is non-positive, then choosing the empty subarray (sum 0) is better, as adding zero doesn't decrease the sum.

But, in the first example, the maximum subarray sum is -4, which is negative, so choosing the empty subarray (sum 0) is better.

In the second example, the maximum subarray sum is 12, which is positive, so choosing to insert the sum of the entire array is better.

Wait, but in the second example, they are choosing the sum of the entire array, which is S, and inserting S, making the new sum S + S = 2S.

But, is this always better than choosing a different subarray?

Suppose I have an array with both positive and negative numbers.

Wait, perhaps I need to consider the maximum subarray sum, and if it's positive, then in each operation, I can choose to insert the current sum of the array, effectively doubling it each time.

But, I need to confirm if this is indeed the optimal strategy.

Let me consider another example.

Suppose n=1, k=1, a=[5]

Initial sum: 5

Option 1: Choose the entire array (sum 5), insert it, new array [5,5], sum=10.

Option 2: Choose an empty subarray (sum 0), insert it, new array [5,0], sum=5.

So, choosing the entire array is better.

Another example:

n=1, k=2, a=[-1]

Option 1: Choose the entire array (sum -1), insert it, new array [-1,-1], sum=-2.

Option 2: Choose the empty subarray (sum 0), insert it, new array [-1,0], sum=-1.

Option 3: Choose the empty subarray twice, ending with [-1,0,0], sum=-1.

So, choosing the empty subarray is better.

Another example:

n=2, k=1, a=[1,-2]

Option 1: Choose subarray [1], sum=1, insert it, new array [1,-2,1], sum=0.

Option 2: Choose subarray [-2], sum=-2, insert it, new array [1,-2,-2], sum=-3.

Option 3: Choose subarray [1,-2], sum=-1, insert it, new array [1,-2,-1], sum=-2.

Option 4: Choose empty subarray, sum=0, new array [1,-2,0], sum=-1.

So, choosing the subarray with sum 1 is the best, resulting in sum=0.

But, according to my earlier strategy, the maximum subarray sum is 1, which is positive, so choosing to insert the entire array sum (-1) is worse.

Wait, this contradicts my earlier assumption.

So, in this case, choosing the maximum subarray sum (1) and inserting it results in a better sum (0) compared to choosing the entire array sum (-1) and inserting it (-1), which would give sum=-2.

Therefore, in this case, choosing the maximum subarray sum (1) is better than choosing the entire array sum (-1).

So, perhaps my earlier strategy needs adjustment.

Maybe, when the maximum subarray sum is positive, I should choose to insert that maximum subarray sum in each operation, rather than inserting the sum of the entire array.

Because inserting the maximum subarray sum will add that much to the total sum, and I can do this k times.

In the previous example:

n=2, k=1, a=[1,-2]

Maximum subarray sum: 1

Insert 1, new array [1,-2,1], sum=0

If k=2:

Insert 1 again, new array [1,-2,1,1], sum=1

And so on.

So, in this case, choosing the maximum subarray sum and inserting it in each operation leads to a better sum than choosing the sum of the entire array.

In contrast, in the second test case:

n=3, k=3, a=[2,2,8]

Maximum subarray sum: 12

If I choose to insert 12 in each operation:

Operation 1: insert 12, array becomes [2,2,8,12], sum=24

Operation 2: insert 12 again, array becomes [2,2,8,12,12], sum=36

Operation 3: insert 12 again, array becomes [2,2,8,12,12,12], sum=48

Which is less than the 96 achieved by inserting the sum of the current array each time.

So, in this case, inserting the sum of the entire array leads to a higher sum than just inserting the maximum subarray sum.

Wait, but in this approach, the sum increases by the maximum subarray sum each time, whereas in the other approach, it increases by the current sum of the array.

So, perhaps the strategy should be:

- If the maximum subarray sum is positive, then in each operation, choose to insert the current sum of the array, which allows the sum to double each time.

- If the maximum subarray sum is non-positive, then choose the empty subarray and insert sum 0 in each operation, so the sum remains the same.

Wait, but in the previous example, inserting the current sum allowed the sum to double each time, which is better than just adding the maximum subarray sum.

So, perhaps the optimal strategy is:

- If the maximum subarray sum is positive, then in each operation, choose to insert the current sum of the array, which allows the sum to double each time.

- Else, choose the empty subarray and insert 0.

But, in the earlier example with n=2, k=1, a=[1,-2], choosing to insert the maximum subarray sum (1) leads to sum=0, whereas choosing to insert the current sum (-1) leads to sum=-2.

So, in that case, choosing to insert the maximum subarray sum is better.

So, perhaps my strategy needs refinement.

Let me think differently.

Let me denote:

- S: initial sum of the array

- M: maximum subarray sum

Then, in each operation, I can choose to insert any subarray sum, but to maximize the sum, I should choose the subarray with the maximum sum available at that moment.

But, after inserting a sum, the array changes, and potentially, the new maximum subarray sum could be larger.

But, it's complicated to track this over k operations.

Perhaps, I can consider that in each operation, I can add M to the sum, and potentially, M can grow in subsequent operations.

But, in practice, it's not straightforward.

Looking back at the second test case, by choosing to insert the current sum each time, the sum doubles each operation.

So, starting with sum S, after one operation, sum becomes S + S = 2S

After two operations: 2S + 2S = 4S

After three operations: 4S + 4S = 8S

And so on, up to 2^k * S

But, in reality, in the second test case, they chose to insert the current sum each time, leading to sum being multiplied by 2 each time.

But, in the earlier example with n=2, k=1, a=[1,-2], choosing to insert the current sum would lead to sum=-2, which is worse than choosing to insert the maximum subarray sum of 1, leading to sum=0.

So, perhaps the strategy should be:

- If the initial sum S is positive, then in each operation, choose to insert the current sum, effectively doubling the sum each time.

- Else, if S is non-positive, choose to insert the maximum subarray sum M in each operation, provided M is positive; otherwise, insert 0.

Wait, but in the second test case, S=12 (positive), so double each time.

In the first test case, S=-11 (negative), so choose to insert 0.

In the example with n=2, k=1, a=[1,-2], S=-1 (negative), so choose to insert M=1, leading to sum=0.

Wait, but in that case, S is negative, but M is positive, so choosing to insert M=1 is better than inserting 0.

So, perhaps the strategy should be:

- If S is positive, choose to insert S in each operation, doubling the sum each time.

- Else, if S is non-positive but M is positive, choose to insert M in each operation.

- Else, choose to insert 0.

But, in the second test case, choosing to insert S leads to better results than inserting M.

Wait, in the second test case, M=12, S=12, so inserting S is the same as inserting M.

Wait, no, in the second test case, S=12, M=12, but inserting S allows it to double each time, whereas inserting M would just add 12 each time.

So, inserting S is better because it allows the sum to grow exponentially.

Whereas, in the example with n=2, k=1, a=[1,-2], S=-1, M=1.

Inserting S would give sum=-2, inserting M would give sum=0.

So, in this case, inserting M is better.

So, perhaps the strategy should be:

- If S is positive and M >= S, then choose to insert S in each operation.

- Else, choose to insert M in each operation.

But, in the second test case, S=12, M=12, so insert S.

In the earlier example, S=-1, M=1, so insert M.

Wait, but in the second test case, M=S=12, and inserting S allows doubling, which is better.

Wait, but in general, M <= S, because M is the sum of the maximum subarray, which is less than or equal to S.

Wait, no, M can be greater than S if there are negative elements.

Wait, no, M is the sum of the maximum subarray, which is a part of the array, so M <= S only if all elements are positive.

If there are negative elements, M can be greater than S.

Wait, no, M is the sum of the largest contiguous subarray, which can be less than S.

Wait, in the second test case, M=12, S=12.

In the earlier example, M=1, S=-1.

Wait, perhaps I need to consider that inserting S allows the sum to double each time, whereas inserting M allows adding M each time.

So, if M >= S, then inserting S is better because it allows exponential growth.

Wait, but in the earlier example, n=2, k=1, a=[1,-2], S=-1, M=1.

Inserting S would give sum=-2, inserting M would give sum=0.

So, in this case, inserting M is better.

So, perhaps the condition should be:

- If M > S, then insert M in each operation.

- Else, insert S in each operation.

But, in the second test case, M=12, S=12, so M <= S, insert S.

In the earlier example, M=1, S=-1, M > S, insert M.

Which matches the better outcomes.

So, generalizing:

- If M > S, insert M in each operation, leading to sum = S + k*M

- Else, insert S in each operation, leading to sum = S * (2^k)

But, in the second test case, inserting S leads to sum = S * (2^k)

But, in reality, in the second test case, they performed operations by inserting S each time, leading to sum = S + S + ... + S (k times), which is S + k*S = S*(k+1)

Wait, no, in the explanation, they chose to insert the current sum each time, which allows the sum to double each time.

Wait, perhaps I'm confusing two different approaches.

Let me clarify.

Approach 1:

- In each operation, choose to insert M, leading to sum = S + k*M

Approach 2:

- In each operation, choose to insert the current sum S, leading to sum = S * (2^k)

But, in reality, inserting the current sum each time allows the sum to double each time.

Wait, in the second test case, they chose to insert the current sum each time, which changes the current sum after each insertion.

Wait, perhaps I need to think in terms of geometric progression.

If I insert the current sum S in each operation, then:

- After operation 1: sum = S + S = 2S

- After operation 2: sum = 2S + 2S = 4S

- After operation 3: sum = 4S + 4S = 8S

- ...

- After k operations: sum = S * (2^k)

But, in reality, in the second test case, they chose to insert the current sum each time, leading to sum = 12 * (2^3) = 96, which matches the explanation.

So, if I choose to insert the current sum S in each operation, the sum after k operations is S * (2^k)

But, in the earlier example with n=2, k=1, a=[1,-2], S=-1

If I insert S each time, sum becomes -1 + (-1) = -2

But, if I insert M=1, sum becomes 0

So, in this case, inserting M is better.

Therefore, the strategy should be:

- If M > S, then insert M in each operation, leading to sum = S + k*M

- Else, insert S in each operation, leading to sum = S * (2^k)

But, in the second test case, M=12, S=12, M <= S, so insert S, leading to sum = 12 * (2^3) = 96

In the earlier example, M=1, S=-1, M > S, so insert M, leading to sum = -1 + 1*k = -1 + 1*1 = 0

Which matches the better outcomes.

So, generalizing:

- If M > S, then sum = S + k*M

- Else, sum = S * (2^k)

But, I need to make sure that inserting S each time indeed allows the sum to double each time.

Let me verify with the second test case.

Initial S=12

Operation 1: insert S=12, new sum=12 + 12=24

Operation 2: insert current S=24, new sum=24 + 24=48

Operation 3: insert current S=48, new sum=48 + 48=96

Which matches 12 * (2^3) = 96

So, yes, it works.

In the earlier example, n=2, k=1, a=[1,-2], S=-1

If M > S (1 > -1), then sum = S + k*M = -1 + 1*1 = 0

Which matches the better outcome.

Another example:

n=1, k=1, a=[5]

M=5, S=5, M <= S, so sum = 5 * (2^1) = 10

Which matches choosing to insert S=5, new sum=10

Another example:

n=1, k=1, a=[-1]

M=-1, S=-1, M <= S, so sum = -1 * (2^1) = -2

But, choosing to insert M=-1, sum=-1 + (-1)= -2

Choosing to insert 0, sum=-1 + 0 = -1

So, in this case, choosing to insert 0 is better.

Wait, according to the strategy, since M <= S, choose to insert S, leading to sum=-2

But, choosing to insert 0 is better, leading to sum=-1

So, perhaps the strategy needs adjustment.

Wait, in this case, M=-1, S=-1, M <= S, so sum = S * (2^k) = -1 * 8 = -8

But, in reality, if I insert S each time, sum becomes -1 + (-1) + (-1) + (-1) = -4 for k=3.

But, choosing to insert 0 each time, sum remains -1.

So, in this case, choosing to insert 0 is better.

Wait, but according to the strategy, if M <= S, insert S, leading to sum = S * (2^k)

But, when S is negative, this leads to a smaller (more negative) sum.

Whereas, choosing to insert 0 leads to sum = S + 0*k = S

So, in this case, choosing to insert 0 is better.

Therefore, perhaps the strategy should be:

- If M > S, then sum = S + k*M

- Else, if M > 0, sum = S + k*M

- Else, sum = S + k*0 = S

Wait, but M is the maximum subarray sum.

If M <= S and M <=0, then sum = S

Else if M > S, sum = S + k*M

Wait, perhaps I need to consider M >=0 separately.

Wait, perhaps the correct strategy is:

- If M > 0, then sum = S + k*M

- Else, sum = S + k*0 = S

Because, if M > 0, I can choose to insert M in each operation, adding M each time.

Else, M <=0, so choosing to insert 0 is better.

In the second test case, M=12 >0, so sum = 12 + 3*12 = 48, but according to the explanation, it's 96.

Wait, this contradicts the earlier observation.

Wait, perhaps I need to reconsider.

Wait, perhaps the correct strategy is:

- If M >0, choose to insert M in each operation, leading to sum = S + k*M

- Else, choose to insert 0 in each operation, leading to sum = S + 0*k = S

But, in the second test case, M=12 >0, so sum=12 + 3*12=48, but according to the explanation, it's 96.

So, this suggests that choosing to insert the current sum S each time, leading to sum = S * (2^k), is better.

Wait, but according to my earlier strategy, if M >0, sum = S + k*M

But in this case, S=12, M=12, k=3, sum=12 + 3*12=48, which is less than 12*(2^3)=96

So, perhaps the strategy should be:

- If M > S, choose to insert M in each operation, leading to sum = S + k*M

- Else, choose to insert S in each operation, leading to sum = S * (2^k)

But, in the earlier example with n=2, k=1, a=[1,-2], S=-1, M=1

Here, M > S (1 > -1), so sum = -1 + 1*1 =0, which is better than inserting S=-1, which would give -2

In another example with n=1, k=1, a=[5], S=5, M=5, M <= S, so sum=5*(2^1)=10, which matches inserting S=5

In the example with n=1, k=1, a=[-1], S=-1, M=-1, M <= S, so sum=-1*(2^1)=-2, but choosing to insert 0 would give -1, which is better.

So, perhaps the strategy should be:

- If M >0, choose to insert M in each operation, leading to sum = S + k*M

- Else, choose to insert 0 in each operation, leading to sum = S

But, in the second test case, M=12 >0, so sum=12 + 3*12=48, but choosing to insert S=12 leads to sum=12*(2^3)=96, which is better.

Wait, perhaps I need to consider that if M >0 and M < S, choosing to insert S leads to better results.

So, perhaps the correct strategy is:

- If M >0:

- If M >= S, choose to insert S in each operation, leading to sum = S * (2^k)

- Else (M < S), choose to insert M in each operation, leading to sum = S + k*M

- Else (M <=0), choose to insert 0 in each operation, leading to sum = S

In the second test case, M=12, S=12, M >= S, so sum=12*(2^3)=96

In the earlier example, n=2, k=1, a=[1,-2], M=1, S=-1, M > S, so sum=-1 +1*1=0

In another example, n=1, k=1, a=[5], M=5, S=5, M >= S, so sum=5*(2^1)=10

In the example with n=1, k=1, a=[-1], M=-1, S=-1, M <=0, so sum=-1

Which matches choosing to insert 0.

So, generalizing:

- If M >0:

- If M >= S, sum = S * (2^k)

- Else, sum = S + k*M

- Else, sum = S

This seems to cover all cases.

Let me verify with the examples.

First test case:

n=2, k=2, a=[-4,-7], S=-11, M=-4

M <=0, so sum = -11, which modulo 10^9+7 is 999,999,996

Second test case:

n=3, k=3, a=[2,2,8], S=12, M=12

M >0 and M >= S, so sum=12*(2^3)=96

Third test case:

n=1, k=7, a=[7], S=7, M=7

M >0 and M >= S, so sum=7*(2^7)=7*128=896

Fourth test case:

n=5, k=1, a=[4,-2,8,-12,9], S=7, M=10 (from subarray [4,-2,8])

M >0 and M < S (10 < 7 is False), so sum=7 +1*10=17

But according to the example, it's better to take subarray [4,-2,8], sum=10, and insert it at the beginning, leading to [10,4,-2,8,-12,9], sum=17

So, matches.

Another example:

n=7, k=4, a=[8,14,-9,6,0,-1,3], S=21, M=21 (from subarray [8,14,-9,6,0,-1,3])

M >0 and M >= S, so sum=21*(2^4)=21*16=336

But in the example, the output is 351.

Wait, perhaps I miscalculated M.

Let me compute M.

Subarrays:

[8]: 8

[8,14]:22

[8,14,-9]:13

[8,14,-9,6]:19

[8,14,-9,6,0]:19

[8,14,-9,6,0,-1]:18

[8,14,-9,6,0,-1,3]:21

Other subarrays will have lower sums.

So, M=22 from [8,14]

So, M=22 > S=21, so sum=21 +4*22=21+88=109

But according to the example, it's 351.

Wait, perhaps I need to consider that M can be greater than S.

Wait, in this case, M=22 > S=21, so sum=21 +4*22=109

But the example output is 351, which suggests that choosing to insert S=21 each time leads to sum=21*(2^4)=21*16=336, which is less than 351.

Wait, perhaps my strategy is incorrect.

Wait, perhaps I need to consider that M can be greater than S, but in reality, in this case, M=22, S=21, choosing to insert M=22 in each operation leads to sum=21 +4*22=109, which is less than 336 (from inserting S=21 each time).

But according to the example, the output is 351, which is higher than both.

So, perhaps my strategy is incomplete.

Wait, perhaps I need to consider that inserting M allows me to have M in the array, which can be part of a larger subarray in future operations.

Wait, but in this case, inserting M=22 would make the array [8,14,-9,6,0,-1,3,22], sum=43

Then, in the next operation, M could be higher, perhaps.

But, this seems too complicated to track manually.

Given that, perhaps the strategy should be:

- If M >0:

- If M >= S, sum = S * (2^k)

- Else, sum = S + k*M

- Else, sum = S

In this case, M=22 > S=21, so sum=21*(2^4)=336, but the example output is 351, which suggests that this strategy is not optimal.

Wait, perhaps I need to consider that inserting M allows me to have higher M in future operations.

For example, inserting M=22 into the array makes the new M potentially higher.

Wait, in the first operation, insert M=22, array becomes [8,14,-9,6,0,-1,3,22], sum=43

Now, M could be [14,-9,6,0,-1,3,22], sum=25

Then, insert M=25, array becomes [8,14,-9,6,0,-1,3,22,25], sum=68

Next, M=25 again, insert it, array becomes [8,14,-9,6,0,-1,3,22,25,25], sum=93

Next, M=25 again, insert it, array becomes [8,14,-9,6,0,-1,3,22,25,25,25], sum=118

So, total sum after 4 operations: 118

Which is less than 351.

Wait, perhaps choosing different subarrays leads to higher sums.

Alternatively, perhaps choosing to insert S each time is not the best, and inserting different subarrays leads to higher sums.

This seems too complicated to track manually.

Given time constraints, perhaps I need to accept that my strategy might not cover all edge cases, but it's a reasonable approach.

So, summarizing the strategy:

- Compute the initial sum S of the array.

- Compute the maximum subarray sum M using Kadane's algorithm or similar.

- If M >0:

- If M >= S, then sum = S * (2^k)

- Else, sum = S + k*M

- Else, sum = S

- Finally, take sum modulo 10^9+7

Now, looking at the provided code:

from math import *

t = int(input())

for _ in range(t):

(n, k) = map(int, input().split())

a = list(map(int, input().split()))

max_segment = func_2(a)

if max_segment[0] == -1:

max_segment[0] = 0

answer = max_segment[0] * 2 ** k + sum(a) - max_segment[0]

print(func_1(answer))

def func_1(number):

return number % 1000000007

def func_2(arr):

new_segment = []

max_segment = [0, 0]

segments_variants = []

max_sum = -1

for i in range(len(arr)):

if new_segment:

if arr[i] < 0:

if max_segment[0] > new_segment[0]:

segments_variants.append(max_segment + [i - 1])

else:

segments_variants.append(new_segment + [i - 1])

max_segment = new_segment

new_segment = []

max_segment[0] += arr[i]

else:

max_segment[0] += arr[i]

new_segment[0] += arr[i]

else:

if arr[i] >= 0:

new_segment = [arr[i], i]

max_segment[0] += arr[i]

segments_variants.append(max_segment + [len(arr) - 1])

segments_variants.append(new_segment + [len(arr) - 1])

total_max_segment = [-1]

for segment in segments_variants:

if total_max_segment[0] < segment[0]:

total_max_segment = segment

if len(total_max_segment) == 1:

total_max_segment = [-1]

return total_max_segment

def func_3(number, quantity):

answer = 0

So, the code defines func_2 to compute the maximum subarray sum.

But, the implementation seems overly complicated and might have bugs.

In func_2, it tries to track new_segment and max_segment, but it's not clear what it's doing.

A better approach would be to use Kadane's algorithm to compute the maximum subarray sum efficiently.

In the main logic:

- Compute max_segment using func_2

- If max_segment[0] == -1, set it to 0

- answer = max_segment[0] * 2 ** k + sum(a) - max_segment[0]

- print answer modulo 10^9+7

Wait, according to my earlier strategy:

- If M >0:

- If M >= S, sum = S * (2^k)

- Else, sum = S + k*M

- Else, sum = S

But in the code:

answer = max_segment[0] * 2 ** k + sum(a) - max_segment[0]

Which simplifies to:

answer = sum(a) + (2**k -1) * max_segment[0]

Wait, that's different from my strategy.

So, perhaps the code is implementing a different strategy.

Let me see.

If M is the maximum subarray sum, then