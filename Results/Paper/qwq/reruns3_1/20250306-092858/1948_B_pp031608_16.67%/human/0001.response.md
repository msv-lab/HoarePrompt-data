Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and I can perform a specific operation on any element that's at least 10. The operation allows me to delete that element and insert its digits in the same position. For example, if I have [12, 3, 45, 67] and I apply the operation to the third element, 45, it becomes [12, 3, 4, 5, 67]. Another example is [2, 10], applying the operation to the second element gives [2, 1, 0].

My task is to determine whether it's possible to make the array sorted in non-decreasing order by performing this operation any number of times, possibly zero.

First, I need to understand what the operation does. Essentially, for any number that is 10 or above, I can split it into its individual digits and insert them in place of the number. This can be done any number of times.

So, the question is, can I perform these splits in such a way that the resulting array is sorted in non-decreasing order?

Let me look at the examples provided:

1. Input: [12, 3, 45, 67]

   - If I split 12: [1, 2, 3, 45, 67]

   - Then, check if it's sorted: 1 ≤ 2 ≤ 3 ≤ 45 ≤ 67 → Yes.

   - So, in this case, splitting 12 leads to a sorted array.

2. Input: [12, 28, 5]

   - If I split 12: [1, 2, 28, 5]

     - 1 ≤ 2 ≤ 28 ≤ 5 → No, because 28 > 5.

   - If I split 28: [12, 2, 8, 5]

     - 12 ≤ 2 ≤ 8 ≤ 5 → No, because 12 > 2.

   - If I split both 12 and 28: [1, 2, 2, 8, 5]

     - 1 ≤ 2 ≤ 2 ≤ 8 ≤ 5 → No, because 8 > 5.

   - It seems like no matter how I split, I can't get a sorted array.

3. Input: [0, 0]

   - Already sorted.

So, the output for these cases is YES, NO, YES respectively.

Now, I need to think about a general approach to solve this problem.

First, I need to consider all possible ways I can split the numbers that are 10 or above, and then check if any of these resulting arrays are sorted.

However, since the array can have up to 50 elements, and each element can be up to 99, which means splitting it into at most two digits, the number of possible splits can be quite large if I consider all combinations.

Let's think of a smarter way to approach this.

One key observation is that splitting a number into digits can only help in making the array sorted if the digits are smaller than the original number, potentially allowing for a better ordering.

But in some cases, as shown in the second example, splitting might not be enough to make the array sorted.

Another observation is that if I have a number that is larger than the next number, and that number is less than 10, then I cannot split it further, so I have to rely on splitting the previous number to make it smaller.

Wait, but numbers less than 10 cannot be split because they are less than 10.

So, in such cases, if I have a number that is larger than the next number, and the next number is less than 10, then I must split the previous number if possible.

Let me think about how to approach this.

Maybe I can iterate through the array and whenever I find a pair where the current element is larger than the next one, and the current element is at least 10, I can split the current element and see if that helps in making the array sorted.

But since splitting one element can affect the subsequent elements, I need to handle this carefully.

Perhaps a recursive or iterative approach where I keep splitting elements until no more splits are needed and then check if the array is sorted.

But considering the constraints, with t up to 10^3 and n up to 50, I need an efficient solution.

Let me consider the maximum number of elements after all possible splits.

Since each element can be at most 99, which has two digits, splitting all elements would result in at most 2*n elements.

So, the total number of elements after all possible splits is bounded.

Now, I need to find a way to determine if there's a way to split some elements to make the array sorted.

One way to think about this is to consider the array after all possible splits and see if there's a subsequence of the original array (with splits) that is sorted.

But that seems complicated.

Another approach is to iterate through the array and whenever you find a descent (a[i] > a[i+1]), check if you can split a[i] to make it smaller so that the descent is resolved.

But splitting a[i] can introduce new elements that might create new descents with a[i+1] or other elements.

This seems tricky to manage.

Let me think differently.

Suppose I have the original array, and I can choose to split any element that is >=10 into its digits.

After all splits, I get a new array consisting of single-digit numbers only, since any number >=10 is split into its digits.

Wait, but actually, I can choose which elements to split and which to keep.

So, some elements >=10 can be kept as is, while others can be split.

My goal is to choose for each element >=10 whether to split it or not, in such a way that the resulting array is sorted in non-decreasing order.

So, it's a matter of making choices for each element >=10: keep it as is or split it into its digits.

Then, among all possible combinations of keeping or splitting these elements, check if any of them result in a sorted array.

Given that n is up to 50, and each element can be either kept or split, the total number of possibilities could be up to 2^50, which is too large.

Therefore, I need a more efficient way to check this.

Let me consider that splitting an element increases the number of elements in the array, and the new elements are the digits of the original element.

So, for example, splitting 12 in [12, 3, 45, 67] changes it to [1, 2, 3, 45, 67].

Now, I need to check if, after any sequence of such splits, the array becomes sorted.

I need to find a way to model this efficiently.

One idea is to consider the array as a sequence of elements that can be "expanded" into their digits.

So, I can think of the array as a tree where each node is an element, and if it's >=10, it has children which are its digits.

Then, the problem reduces to checking if there's a path through this tree that results in a sorted sequence.

But this seems too computationally expensive for the given constraints.

I need a better way.

Let me consider that splitting an element is equivalent to replacing it with its digits, which are in a fixed order.

So, the operation doesn't allow me to reorder the digits; they must be inserted in the same order they appear in the original number.

Given that, I can model the array as a sequence of digits, where some digits are "compressed" into numbers >=10.

My task is to "decompress" some of these compressed numbers in such a way that the resulting sequence of digits is sorted.

Wait, but the digits of a number are already in a specific order, and I have to insert them in the same order.

So, perhaps I can think of the entire array as a sequence of digits, some of which are grouped together into numbers >=10.

Then, splitting these groups expands them into their individual digits.

In the end, I want the entire sequence of digits to be sorted.

This seems promising.

Let's consider the first example: [12, 3, 45, 67]

- 12 can be split into 1 and 2

- 45 can be split into 4 and 5

- 67 can be split into 6 and 7

So, if I split all possible elements, I get [1,2,3,4,5,6,7], which is sorted.

But in the problem, it's saying that splitting only 12 is enough to make it sorted: [1,2,3,45,67], which is indeed sorted.

So, in this case, I don't need to split all elements; splitting only some of them is sufficient.

Now, considering the second example: [12,28,5]

- 12 can be split into 1 and 2

- 28 can be split into 2 and 8

- 5 remains 5

If I split both 12 and 28, I get [1,2,2,8,5], which is not sorted because 8 > 5.

If I split only 12: [1,2,28,5], which is not sorted because 28 > 5.

If I split only 28: [12,2,8,5], which is not sorted because 12 > 2 and 8 > 5.

If I split neither: [12,28,5], which is not sorted because 28 > 5.

So, in this case, no matter what splits I perform, I cannot get a sorted array.

Hence, the answer is NO.

In the third example: [0,0]

- Already sorted, so no need to split anything.

Hence, the answer is YES.

From these observations, it seems that I need to find a way to determine whether there exists a combination of splits that results in a sorted array.

Given the constraints, I need an efficient algorithm to check this.

Let me consider that each element in the array can be represented as a list of its digits if it's >=10, or just itself if it's <10.

For example:

- 12 -> [1,2]

- 3 -> [3]

- 45 -> [4,5]

- 67 -> [6,7]

Then, the array [12,3,45,67] can be seen as [[1,2],[3],[4,5],[6,7]].

My task is to decide for each such list whether to keep it as is (if it's a single digit) or to expand it into its individual digits, and then concatenate them into a single sequence, and check if that sequence is sorted.

Given that, I need to find a way to decide which lists to expand so that the resulting sequence is sorted.

This sounds like a dynamic programming problem, where I keep track of the maximum value so far and decide whether to split or not.

But I need to think carefully to avoid exponential time complexity.

Wait, perhaps there's a better way.

Let me consider that splitting an element allows me to insert its digits into the array in their respective order.

So, for each element, if it's >=10, I have two choices: keep it as is or split it into its digits.

I need to choose a combination of these choices such that the resulting array is sorted.

Given that n is up to 50, and t is up to 10^3, I need an efficient solution, preferably O(n) per test case.

Let me think about the properties of a sorted array.

In a sorted array, each element is less than or equal to the next element.

So, for the array to be sorted after splits, for every position i, the element at position i should be <= the element at position i+1.

Now, for each position, the element can be either the original element (if it's <10 or if it's not split), or it can be one of the digits if it's split.

So, for each position, I have to consider what possible values it can take, based on whether the element is split or not.

This seems complex, but perhaps I can iterate through the array and make decisions on the fly.

Let me try to think of an iterative approach.

I can iterate through the array from left to right, keeping track of the last value that was placed in the final array.

At each step, I have to decide whether to split the current element or keep it as is, based on the last value.

Here's a possible algorithm:

1. Initialize an empty list to build the sorted array.

2. Initialize a variable to keep track of the last value added to the sorted array.

3. Iterate through each element in the original array:

a. If the element is <10, it cannot be split, so it must be added as is.

- If it's >= the last value in the sorted array, add it.

- Else, it's impossible to sort, so return "NO".

b. If the element is >=10, I have two choices:

- Keep it as is, if it's >= the last value.

- Split it into its digits, and add them one by one, ensuring each digit is >= the last value.

- If neither option works, it's impossible to sort.

4. If I can iterate through the entire array without issues, return "YES".

Wait, but this seems too simplistic, and it might not cover all cases.

Let me think about it with the first example:

[12,3,45,67]

- Start with an empty array, last_value = -infinity.

- First element: 12 >=10, so choices:

- Keep 12: 12 >= last_value (-inf), so add 12.

- Or split 12 into 1 and 2.

- If I split, 1 >= last_value, add 1; then 2 >=1, add 2.

- So, choosing to split gives [1,2], which is better because it's smaller.

- So, I choose to split 12 into [1,2], and set last_value = 2.

- Second element: 3 <10, cannot split.

- 3 >= last_value (2), so add 3, last_value =3.

- Third element: 45 >=10.

- Option 1: keep 45, 45 >=3, add 45, last_value=45.

- Option 2: split 45 into 4 and 5.

- 4 >=3, add 4; 5>=4, add 5.

- So, choosing to split gives [4,5], which is better.

- So, choose to split, add [4,5], last_value=5.

- Fourth element: 67 >=10.

- Option 1: keep 67, 67 >=5, add 67, last_value=67.

- Option 2: split 67 into 6 and 7.

- 6 >=5, add 6; 7>=6, add7.

- Both options are valid, but keeping 67 is [67], while splitting is [6,7].

- Since [6,7] is better (smaller), I choose to split, add [6,7], last_value=7.

- The final array is [1,2,3,4,5,6,7], which is sorted.

Hence, "YES".

Now, let's try the second example: [12,28,5]

- Start with empty array, last_value=-inf.

- First element: 12 >=10.

- Option 1: keep 12, 12 >= -inf, add 12, last_value=12.

- Option 2: split 12 into 1 and 2.

- 1 >= -inf, add 1; 2>=1, add 2.

- So, choose to split, add [1,2], last_value=2.

- Second element: 28 >=10.

- Option 1: keep 28, 28 >=2, add 28, last_value=28.

- Option 2: split 28 into 2 and 8.

- 2 >=2, add 2; 8>=2, add8.

- So, choosing to split gives [2,8], which is better.

- So, choose to split, add [2,8], last_value=8.

- Third element:5 <10, cannot split.

- 5 >=8? No, so cannot add.

- Hence, impossible, "NO".

This matches the expected output.

Now, third example: [0,0]

- Start with empty array, last_value=-inf.

- First element:0 <10, cannot split.

- 0 >= -inf, add 0, last_value=0.

- Second element:0 <10, cannot split.

- 0 >=0, add 0, last_value=0.

- The final array is [0,0], which is sorted.

Hence, "YES".

This seems to work for the given examples.

Now, let's think about edge cases.

Edge Case 1: All elements are <10 and already sorted.

- For example: [1,2,3,4]

- Should return "YES".

Edge Case 2: All elements are <10 and not sorted.

- For example: [3,2,1]

- Cannot perform any operations, so "NO".

Edge Case 3: All elements are >=10 and can be split to form a sorted array.

- For example: [15,26,37]

- Split all: [1,5,2,6,3,7]

- Which is not sorted, but maybe another combination?

- If I keep 15 as is, split 26, and split 37: [15,2,6,3,7]

- Not sorted.

- If I split 15 and keep 26: [1,5,26,3,7]

- Not sorted.

- If I split 15 and 26, keep 37: [1,5,2,6,37]

- Not sorted.

- If I keep 15 and split 37: [15,26,3,7]

- Not sorted.

- If I split all: [1,5,2,6,3,7]

- Not sorted.

- Seems like no way to sort.

- But perhaps there's a way I'm missing.

Wait, maybe [1,2,3,5,6,7] is sorted, but to get that, I need to split all and rearrange, but I can't rearrange, I can only split in place.

Hence, "NO".

Edge Case 4: Elements that are single digits but need to be reordered.

- For example: [3,2,1]

- Cannot split, cannot reorder, so "NO".

Edge Case 5: Elements that can be split to include smaller digits.

- For example: [23,1,0]

- Split 23: [2,3,1,0]

- Not sorted.

- Keep 23: [23,1,0]

- Not sorted.

- "NO".

Another Edge Case: [10,1]

- Split 10: [1,0,1]

- 0 <1, so not sorted.

- Keep 10: [10,1]

- 10 >1, not sorted.

- "NO".

Another Edge Case: [11,11]

- Split both: [1,1,1,1]

- Sorted.

- Keep both: [11,11]

- Sorted.

- So, "YES".

Another Edge Case: [19,20]

- Split 19: [1,9,20]

- Not sorted (9 >20 is false, 1<=9<=20)

- Split 20: [19,2,0]

- Not sorted (19>2)

- Split both: [1,9,2,0]

- Not sorted.

- Keep both: [19,20]

- Sorted.

- So, "YES".

Wait, in this case, keeping both is sufficient, so "YES".

Hence, the algorithm should consider keeping the number as is or splitting it, and choose the option that leads to a sorted array.

Now, to implement this efficiently, I need to simulate the process of building the sorted array by choosing for each element whether to split it or not, and ensuring that the sequence remains sorted.

Given that n is up to 50, and t is up to 10^3, I need an efficient solution, preferably O(n) per test case.

Let me try to formalize the algorithm.

Algorithm:

1. Initialize an empty list to build the sorted array.

2. Initialize a variable last to keep track of the last value added to the sorted array, starting with -1 (since all a_i >=0).

3. Iterate through each element in the array:

a. If the element is less than 10:

- If element >= last, add it to the sorted array and set last = element.

- Else, it's impossible to sort, return "NO".

b. If the element is >=10:

- Option 1: Keep the element as is.

- If element >= last, add it to the sorted array and set last = element.

- Option 2: Split the element into its digits.

- For each digit:

- If digit >= last, add it to the sorted array and set last = digit.

- Else, cannot add this digit.

- If neither option works, return "NO".

- Choose the option that allows the sequence to remain sorted.

4. If the entire array is processed without issues, return "YES".

But I need to implement this in a way that efficiently chooses between keeping the element or splitting it.

I need to ensure that choosing to split or not leads to the smallest possible sequence that is sorted.

Wait, perhaps I should always prefer splitting because it allows for smaller digits, which are more likely to fit into a sorted sequence.

But in some cases, keeping the number as is might be necessary if splitting leads to digits that disrupt the sorting.

Let me think about a case where keeping the number is better.

Consider [15,2].

- If I split 15: [1,5,2]

- 1 <=5 <=2 → No.

- If I keep 15: [15,2]

- 15 >2 → No.

- So, "NO".

Another case: [15,20]

- Split 15: [1,5,20]

- Sorted: 1 <=5 <=20 → Yes.

- Keep 15: [15,20]

- Sorted: 15 <=20 → Yes.

- So, "YES".

Hence, in some cases, both options are possible, and in others, only splitting or keeping leads to a sorted array.

Therefore, I need to check both options and see if any of them leads to a sorted array.

But checking both options for each element could be too slow for n=50 and t=10^3.

I need a smarter way.

Let me consider that splitting an element allows me to insert its digits, which are smaller than the element itself (since they are single digits), and in a specific order.

Hence, splitting can only help in making the array sorted if the digits are smaller and in the correct order.

Given that, perhaps I can iterate through the array and whenever I find a descent (a[i] > a[i+1]), I check if splitting a[i] can resolve it.

But splitting a[i] can introduce new digits that might create new descents with a[i+1] or other elements.

This seems complicated.

Let me consider a different approach.

I can think of the array as a sequence of "tokens", where each token is either a single digit or a number >=10.

My task is to replace each token with either itself or its digits, and then check if the resulting sequence is sorted.

Given that, I can model this as a graph where each token has two possibilities: as is or split, and find a path that results in a sorted sequence.

But again, this seems too slow.

Wait, perhaps I can use dynamic programming.

Let me define dp[i][j], where i is the current position in the array, and j is the last value added to the sorted array.

But with j potentially being up to 99, and n up to 50, this would be O(n*100), which is acceptable for t=10^3.

Let me think about it.

Define dp[i][last], where i is the current index in the array, and last is the last value added to the sorted array.

dp[i][last] = True if it's possible to reach index i with the last added value being last.

Initialize dp[0][last] for the first element, considering both keeping it as is (if <10) or splitting it.

Then, for each subsequent element, update dp[i][new_last] based on dp[i-1][last] and the choices for the current element.

Finally, if any dp[n-1][last] is True for some last, then the answer is "YES".

But implementing this would require a 2D DP with n=50 and last up to 99, which is feasible.

However, I need to implement this efficiently.

Alternatively, I can keep track of the possible last values at each step using a set.

Initialize a set of possible last values starting with -1.

Then, for each element in the array, for each possible last value, decide whether to keep the element or split it, and update the possible last values accordingly.

At the end, if any possible last value exists, return "YES"; else, "NO".

Let me try to formalize this.

Algorithm:

1. Initialize a set possible_last = {-1}

2. Iterate through each element in the array:

a. For each possible last in possible_last:

- If the element <10:

- If element >= last, add element to new_possible_last

- Else, cannot add, skip

- If the element >=10:

- Option 1: Keep the element as is.

- If element >= last, add element to new_possible_last

- Option 2: Split the element into its digits.

- For each digit:

- If digit >= last, add digit to new_possible_last

- Else, cannot add this digit, skip

- Update possible_last with new_possible_last

- If possible_last is empty at any step, return "NO"

3. If possible_last is not empty at the end, return "YES"; else, "NO"

This way, I'm keeping track of all possible last values at each step, considering both keeping and splitting options.

Given that n is up to 50 and t is up to 10^3, and the number of possible last values is up to 100, this should be efficient enough.

Let's test this algorithm with the first example: [12,3,45,67]

- Initialize possible_last = {-1}

- First element: 12 >=10

- For last = -1:

- Option 1: keep 12, 12 >= -1, add 12

- Option 2: split 12 into 1 and 2

- Add 1 (1 >= -1)

- Add 2 (2 >=1)

- So, new_possible_last = {12,1,2}

- Second element:3 <10

- For last in {12,1,2}:

- If last=12, 3 >=12? No, skip

- If last=1, 3 >=1, add 3

- If last=2, 3 >=2, add 3

- So, new_possible_last = {3}

- Third element:45 >=10

- For last=3:

- Option 1: keep 45, 45 >=3, add 45

- Option 2: split 45 into 4 and 5

- Add 4 (4 >=3)

- Add 5 (5 >=4)

- So, new_possible_last = {45,4,5}

- Fourth element:67 >=10

- For last in {45,4,5}:

- For last=45:

- Option 1: keep 67, 67 >=45, add 67

- Option 2: split 67 into 6 and 7

- Add 6 (6 >=45? No)

- Add 7 (7 >=6? Yes, but since 6 cannot be added, 7 cannot be added)

- So, only 67 can be added from last=45

- For last=4:

- Option 1: keep 67, 67 >=4, add 67

- Option 2: split 67 into 6 and 7

- Add 6 (6 >=4), add 7 (7 >=6)

- So, new_possible_last = {67,6,7}

- For last=5:

- Option 1: keep 67, 67 >=5, add 67

- Option 2: split 67 into 6 and 7

- Add 6 (6 >=5), add7 (7 >=6)

- So, new_possible_last = {67,6,7}

- Hence, possible_last = {67,6,7}

- Since possible_last is not empty, return "YES"

This matches the expected output.

Now, second example: [12,28,5]

- Initialize possible_last = {-1}

- First element:12 >=10

- For last=-1:

- Option 1: keep 12, 12 >= -1, add 12

- Option 2: split 12 into 1 and 2

- Add 1 (1 >= -1)

- Add 2 (2 >=1)

- So, new_possible_last = {12,1,2}

- Second element:28 >=10

- For last in {12,1,2}:

- For last=12:

- Option 1: keep 28, 28 >=12, add 28

- Option 2: split 28 into 2 and 8

- Add 2 (2 >=12? No)

- Add 8 (8 >=2? Yes)

- So, add 28 and 8

- For last=1:

- Option 1: keep 28, 28 >=1, add 28

- Option 2: split 28 into 2 and 8

- Add 2 (2 >=1), add8 (8 >=2)

- So, add 28,2,8

- For last=2:

- Option 1: keep 28, 28 >=2, add 28

- Option 2: split 28 into 2 and 8

- Add 2 (2 >=2), add8 (8 >=2)

- So, add 28,2,8

- Hence, new_possible_last = {28,8,2}

- Third element:5 <10

- For last in {28,8,2}:

- For last=28:

- 5 >=28? No, skip

- For last=8:

- 5 >=8? No, skip

- For last=2:

- 5 >=2, add5

- So, new_possible_last = {5}

- Now, check if 5 <= the next element, but since there are no more elements, and we have possible_last={5}, which is not empty, but we need to ensure that the entire array is processed and the last value is appropriate.

Wait, in this algorithm, I need to ensure that I've processed the entire array and that there are no further elements to consider.

Given that, in this case, after processing all elements, possible_last={5}, which is not empty, so according to the algorithm, it should return "YES".

But according to the problem, the answer should be "NO", because there's no way to make the array sorted.

Hence, there's a flaw in the algorithm.

The issue is that even if I have possible_last={5} after processing all elements, I need to ensure that the sequence is fully sorted up to the end.

In this case, since there are no more elements after the last one, having possible_last={5} might seem okay, but in reality, the sequence before this point may not be sorted.

Wait, perhaps I need to ensure that the sequence built up to the end is sorted, but in this approach, I'm only keeping track of the last value.

Maybe I need to ensure that the entire sequence is sorted, not just the last value.

This suggests that my DP state should keep track of more than just the last value, perhaps the entire sequence so far.

But that would be too slow for n=50.

I need a better way to handle this.

Let me consider that for each position in the array, I need to maintain the possible sequences that can be built up to that position.

But that's too slow.

Alternatively, perhaps I can model this as a graph where each node represents a possible state (the last value), and edges represent the possible transitions when processing the next element.

Then, I can perform a BFS or use a set to track the possible last values at each step.

This is similar to what I did earlier, but perhaps I need to adjust how I handle the transitions.

Let me try to adjust the algorithm.

Adjusted Algorithm:

1. Initialize a set possible_last = {-1}

2. Iterate through each element in the array:

a. Initialize a new set new_possible_last = set()

b. For each possible last in possible_last:

- If the element <10:

- If element >= last, add element to new_possible_last

- Else, cannot add, skip

- If the element >=10:

- Option 1: keep the element as is.

- If element >= last, add element to new_possible_last

- Option 2: split the element into its digits.

- For each digit:

- If digit >= last, add digit to new_possible_last

- Else, cannot add this digit, skip

c. Update possible_last with new_possible_last

d. If possible_last is empty, return "NO"

3. If possible_last is not empty at the end, return "YES"; else, "NO"

Let's apply this to the second example: [12,28,5]

- Initialize possible_last = {-1}

- First element:12 >=10

- For last=-1:

- Option 1: keep 12, 12 >= -1, add 12

- Option 2: split 12 into 1 and 2

- Add 1 (1 >= -1)

- Add 2 (2 >=1)

- So, new_possible_last = {12,1,2}

- Second element:28 >=10

- For last=12:

- Option 1: keep 28, 28 >=12, add 28

- Option 2: split 28 into 2 and 8

- Add 2 (2 >=12? No)

- Add8 (8 >=2? Yes, add8)

- So, add 28 and8

- For last=1:

- Option 1: keep 28, 28 >=1, add28

- Option 2: split 28 into2 and8

- Add2 (2 >=1), add8 (8 >=2)

- So, add28,2,8

- For last=2:

- Option 1: keep28,28 >=2