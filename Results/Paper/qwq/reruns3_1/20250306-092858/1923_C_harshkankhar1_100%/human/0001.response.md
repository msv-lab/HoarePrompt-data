Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this concept of a "good" array, and I need to determine whether certain subarrays are good based on some conditions.

First, let's understand what makes an array "good." According to the problem, an array \( a \) of length \( m \) is considered good if there exists another integer array \( b \) of the same length such that three conditions hold:

1. The sum of elements in \( a \) is equal to the sum of elements in \( b \): \( \sum_{i=1}^{m} a_i = \sum_{i=1}^{m} b_i \).

2. For every index \( i \), \( a_i \) is not equal to \( b_i \): \( a_i \neq b_i \).

3. Every element in \( b \) is positive: \( b_i > 0 \) for all \( i \).

Given an array \( c \) of length \( n \), where each element is greater than 0, and a set of \( q \) queries, each query provides a range \( [l_i, r_i] \), and I need to determine if the subarray from \( c_{l_i} \) to \( c_{r_i} \) is good.

Okay, so my task is to process multiple test cases, each containing an array and several queries, and for each query, decide if the specified subarray is good based on the conditions above.

Let's think about what makes a subarray good. I need to find another array \( b \) with the same sum, where each \( b_i \) is different from \( a_i \) and positive.

So, for each element \( a_i \), I need to choose a \( b_i \) such that \( b_i \neq a_i \) and \( b_i > 0 \), and the total sum remains the same.

Hmm, that sounds a bit tricky. Let me try to rephrase it.

Given \( a_i \), I need to choose \( b_i \) such that:

- \( b_i > 0 \)

- \( b_i \neq a_i \)

- The sum of all \( b_i \) equals the sum of all \( a_i \)

I need to find if such a \( b \) exists for the given subarray.

Let me consider some examples to get a better understanding.

Suppose the subarray is [1, 2, 1, 4, 5], and the query is from index 1 to 5.

So, \( a = [1, 2, 1, 4, 5] \)

I need to find \( b = [b1, b2, b3, b4, b5] \) such that:

- \( b1 + b2 + b3 + b4 + b5 = 1 + 2 + 1 + 4 + 5 = 13 \)

- \( b_i \neq a_i \) for all \( i \)

- \( b_i > 0 \) for all \( i \)

Is this possible?

Let's try to choose \( b_i \) values:

- For \( a1 = 1 \), choose \( b1 = 2 \) (since \( b1 \neq 1 \) and \( b1 > 0 \))

- For \( a2 = 2 \), choose \( b2 = 1 \)

- For \( a3 = 1 \), choose \( b3 = 2 \)

- For \( a4 = 4 \), choose \( b4 = 3 \)

- For \( a5 = 5 \), choose \( b5 = 4 \)

So, \( b = [2, 1, 2, 3, 4] \), and the sum is \( 2 + 1 + 2 + 3 + 4 = 12 \), which is less than 13.

Hmm, not quite matching. Let's try different choices.

- \( b1 = 2 \)

- \( b2 = 1 \)

- \( b3 = 2 \)

- \( b4 = 3 \)

- \( b5 = 5 \) (but \( b5 = a5 = 5 \), which violates \( b_i \neq a_i \))

So, can't choose \( b5 = 5 \). Need to choose something else, like \( b5 = 4 \) or \( b5 = 6 \), etc.

If I choose \( b5 = 4 \), then sum is \( 2 + 1 + 2 + 3 + 4 = 12 \), still less than 13.

What if I choose \( b5 = 6 \)? Then sum is \( 2 + 1 + 2 + 3 + 6 = 14 \), which is more than 13.

Hmm, so in this case, it's possible to have the sum equal to 13 by choosing appropriate \( b_i \)'s.

For example:

- \( b1 = 2 \)

- \( b2 = 1 \)

- \( b3 = 2 \)

- \( b4 = 3 \)

- \( b5 = 5 \) → but can't choose 5, so choose 4.

Total sum is 12, which is less than 13.

Wait, maybe I need to choose higher values for some \( b_i \)'s to make up for the difference.

Let's try:

- \( b1 = 2 \)

- \( b2 = 1 \)

- \( b3 = 2 \)

- \( b4 = 4 \) (different from a4=4, but needs to be different, so choose 3 or 5)

- \( b5 = 6 \)

Sum: \( 2 + 1 + 2 + 3 + 6 = 14 \), which is more than 13.

Alternatively:

- \( b1 = 2 \)

- \( b2 = 1 \)

- \( b3 = 2 \)

- \( b4 = 3 \)

- \( b5 = 5 \) → can't choose 5, so 4 or 6.

If I choose 4, sum is 12; if 6, sum is 14.

Hmm, not 13.

Wait, maybe:

- \( b1 = 2 \)

- \( b2 = 1 \)

- \( b3 = 2 \)

- \( b4 = 4 \) (different from a4=4, choose 3 or 5)

- \( b5 = 6 \)

Sum: \( 2 + 1 + 2 + 3 + 6 = 14 \)

Wait, 14 is more than 13.

Alternatively:

- \( b1 = 2 \)

- \( b2 = 1 \)

- \( b3 = 2 \)

- \( b4 = 3 \)

- \( b5 = 5 \) → can't choose 5, so 4 or 6.

If I choose 4, sum is 12; if 6, 14.

Seems like I can't get exactly 13 with these choices.

Wait, maybe another approach.

Let me think about the minimal and maximal possible sums for \( b \).

Given that \( b_i > 0 \) and \( b_i \neq a_i \), for each \( a_i \), the possible \( b_i \) values are all positive integers except \( a_i \).

So, for each \( a_i \), the possible \( b_i \) values are \( 1, 2, 3, \dots \), excluding \( a_i \).

Therefore, the minimal possible \( b_i \) is 1 if \( a_i \neq 1 \), otherwise it's 2.

Wait, if \( a_i = 1 \), then \( b_i \) can be any positive integer except 1, so minimal \( b_i = 2 \).

If \( a_i > 1 \), then \( b_i \) can be 1 or any other positive integer except \( a_i \), so minimal \( b_i = 1 \).

So, for each \( a_i \), the minimal possible \( b_i \) is:

- If \( a_i = 1 \), then \( b_i = 2 \)

- If \( a_i > 1 \), then \( b_i = 1 \)

Similarly, there's no upper limit on \( b_i \), except that it must be positive and not equal to \( a_i \).

Now, to make the sum of \( b \) equal to the sum of \( a \), I need to choose \( b_i \)'s such that their sum matches the sum of \( a \).

Given that I can choose \( b_i \)'s to be either 1 (if \( a_i > 1 \)) or 2 (if \( a_i = 1 \)), or any other value except \( a_i \), and since I can choose higher values, I need to see if I can adjust the \( b_i \)'s to match the sum.

Wait a minute, perhaps I can think in terms of the minimal sum of \( b \) and see if it's possible to reach the sum of \( a \).

Let me define:

- Let \( min_b \) be the minimal possible sum of \( b \), which is the sum of the minimal possible \( b_i \)'s for each \( i \).

As established:

- If \( a_i = 1 \), \( b_i \geq 2 \)

- If \( a_i > 1 \), \( b_i \geq 1 \)

So, \( min_b = \sum_{i=1}^{m} \text{min possible } b_i = \sum_{i=1}^{m} (\text{if } a_i = 1 \text{ then } 2 \text{ else } 1) \)

Now, since I can choose \( b_i \)'s to be higher than their minimal values, as long as they are positive and not equal to \( a_i \), I can increase \( b_i \)'s to make the total sum larger.

However, I need the sum to be exactly equal to the sum of \( a \).

So, if \( sum(a) \geq min_b \), and the difference between \( sum(a) \) and \( min_b \) can be distributed among the \( b_i \)'s without violating the conditions, then it's possible.

Wait, but since I can choose \( b_i \)'s to be arbitrarily large (as long as they are positive and not equal to \( a_i \)), I can always make up the difference by increasing some \( b_i \)'s.

But I need to ensure that after choosing the minimal \( b_i \)'s, the sum is less than or equal to \( sum(a) \), and that the difference can be distributed without violating the constraints.

Wait, but since I can choose \( b_i \)'s to be larger than their minimal values, and there's no upper limit, I can always make the sum as large as I want, except I have to ensure \( b_i \neq a_i \).

But the problem is to make the sum exactly equal to \( sum(a) \).

So, if \( sum(a) \geq min_b \), and the difference between \( sum(a) \) and \( min_b \) can be distributed among the \( b_i \)'s without making any \( b_i \) equal to \( a_i \), then it's possible.

Wait, but since I can choose \( b_i \)'s to be larger than their minimal values, and I can choose them to be any value except \( a_i \), as long as \( sum(b) = sum(a) \), it should be possible if \( sum(a) \geq min_b \).

Wait, but there might be cases where \( sum(a) = min_b \), but some \( b_i \) would need to be equal to \( a_i \), which is not allowed.

Wait, no. By choosing \( b_i \)'s to be their minimal possible values except where adjustments are needed to match the sum.

Wait, maybe I need to think differently.

Let me consider that for each \( i \), I can choose \( b_i \) to be either 1 (if \( a_i > 1 \)) or 2 (if \( a_i = 1 \)), and then adjust some \( b_i \)'s to higher values to make up the difference.

But I need to ensure that no \( b_i = a_i \).

Wait, perhaps I can think in terms of the sum difference.

Let me denote \( sum_a = sum(a) \)

\( min_b = sum(\text{minimal possible } b_i) \)

Then, the difference \( d = sum_a - min_b \)

Now, if \( d \geq 0 \), and I can distribute this difference among the \( b_i \)'s without making any \( b_i = a_i \), then it's possible.

But how do I ensure that?

Wait, perhaps I can choose some \( b_i \)'s to be higher than their minimal values, as long as I don't set any \( b_i = a_i \).

Given that I can choose \( b_i \)'s to be arbitrarily large (as long as \( b_i \neq a_i \)), I can always make up the difference by increasing some \( b_i \)'s.

But I need to make sure that I don't set any \( b_i = a_i \) in this process.

Wait, suppose I set some \( b_i \)'s to their minimal values, and then distribute the remaining difference among other \( b_i \)'s.

I need to ensure that when I increase some \( b_i \)'s to make up the difference, none of them become equal to \( a_i \).

So, for each \( b_i \), when increasing it, I need to skip \( a_i \), if it falls on that value.

But this seems complicated.

Maybe there's a simpler way.

Let me consider the minimal sum \( min_b \).

If \( sum_a \geq min_b \), then it's possible to choose \( b_i \)'s such that \( sum(b) = sum(a) \), provided that I can adjust the \( b_i \)'s appropriately.

But I need to ensure that no \( b_i = a_i \).

Wait, perhaps I can think about the minimal sum \( min_b \), and see if \( sum_a \) is at least \( min_b \), and also check if the subarray has more than one element.

Wait, in the example given:

Array: [1,2,1,4,5]

Queries:

1. 1 to 5: YES

2. 4 to 4: NO

3. 3 to 4: YES

4. 1 to 3: NO

So, for query 1: subarray [1,2,1,4,5], sum_a = 13, min_b = 2 +1+1+1+1 = 6, difference d = 7.

I need to distribute 7 over 5 elements, increasing some \( b_i \)'s.

But I need to make sure that none of the \( b_i \)'s become equal to \( a_i \).

Wait, for example:

- \( b1 \): minimal 2 (since \( a1=1 \)), can increase to 2,3,4,...

- \( b2 \): minimal 1 (since \( a2=2 \)), can increase to 1,3,4,... but can't be 2.

Wait, but \( b_i \) can't be equal to \( a_i \), so for \( b2 \), it can be 1,3,4,...

Similarly, for \( b1 \), it can be 2,3,4,...

So, I need to choose \( b_i \)'s such that \( b_i \neq a_i \), and sum up to 13.

In this case, it's possible to choose \( b \) such that sum is 13.

Similarly, for query 2: subarray [4], sum_a =4, min_b=1 (since \( a_i=4 \), so \( b_i \) can be 1,3,5,... minimal is 1).

Difference d=3.

So, choose \( b_i =1 +3=4 \), but \( b_i \) can't be 4 because \( b_i \neq a_i \).

So, can't choose \( b_i=4 \), and next possible is 5.

So, \( b_i=5 \), which is different from 4, and sum is 5, which is more than 4.

Wait, but sum_a is 4, and min_b is 1, difference is 3.

If I choose \( b_i=4 \), which is invalid, or \( b_i=5 \), which is sum=5 >4.

So, in this case, it's impossible to make sum(b)=sum(a), hence NO.

For query 3: subarray [1,4], sum_a=5, min_b=2+1=3, difference=2.

Need to choose \( b_i \)'s such that sum is 5.

Possible choices:

- \( b1=2 \), \( b2=3 \): sum=5

- or \( b1=3 \), \( b2=2 \): sum=5

Both are valid.

Hence, YES.

For query 4: subarray [1,2,1], sum_a=4, min_b=2+1+1=4, difference=0.

So, choose \( b_i \)'s as minimal: [2,1,1], sum=4, which is equal to sum_a=4.

But is this valid? Wait, \( b1=2 \neq a1=1 \), \( b2=1 \neq a2=2 \), \( b3=1 \neq a3=1 \)? Wait, \( b3=1 = a3=1 \), which violates \( b_i \neq a_i \).

Oh, so in this case, choosing \( b3=1 \) is invalid because \( b3 = a3 \).

So, even though the sum matches, the condition \( b_i \neq a_i \) is violated for \( i=3 \).

Hence, it's invalid, NO.

So, in this case, choosing minimal \( b_i \)'s results in \( b3=1 = a3=1 \), which is invalid.

Is there a way to adjust the \( b_i \)'s to make sum=4 without having any \( b_i = a_i \)?

Let's see:

- \( b1 \): can be 2,3,4,...

- \( b2 \): can be 1,3,4,...

- \( b3 \): can be 2,3,4,...

If I choose \( b1=2 \), \( b2=1 \), \( b3=1 \), but \( b3=1 = a3=1 \), invalid.

If I choose \( b1=2 \), \( b2=3 \), \( b3= -1 \), but \( b_i >0 \), so invalid.

Wait, \( b3 \) can't be negative.

Alternatively, \( b1=2 \), \( b2=1 \), \( b3=1 \): sum=4, but \( b3=a3 \), invalid.

\( b1=2 \), \( b2=3 \), \( b3=-1 \): invalid because \( b3 <0 \).

\( b1=3 \), \( b2=1 \), \( b3=0 \): invalid because \( b3=0 \) not >0.

\( b1=3 \), \( b2=2 \), \( b3=-1 \): invalid.

Seems like there's no way to choose \( b_i \)'s such that sum=4 and all \( b_i \neq a_i \) and \( b_i >0 \).

Hence, NO.

So, in this case, even though \( sum(a) \geq min_b \), the minimal \( b_i \)'s assignment leads to a violation of \( b_i \neq a_i \), and adjusting doesn't help.

Therefore, I need a way to ensure that when choosing \( b_i \)'s, none of them equal \( a_i \), and the sum matches \( sum(a) \).

From this, it seems that simply checking \( sum(a) \geq min_b \) is not sufficient; I need to ensure that in the minimal assignment, no \( b_i = a_i \), except perhaps in a way that the differences can be adjusted.

Wait, perhaps I need to calculate \( min_b \) such that for each \( a_i \), \( b_i \) is the smallest possible value greater than 0 and not equal to \( a_i \).

So, for each \( a_i \):

- If \( a_i =1 \), then \( b_i \geq 2 \)

- If \( a_i >1 \), then \( b_i \geq 1 \), but \( b_i \neq a_i \)

Wait, but for \( a_i >1 \), \( b_i \) can be 1, which is fine, as long as \( b_i \neq a_i \).

But in the case where \( a_i >1 \), \( b_i \) can be 1, which is fine.

Wait, but in the earlier example, when \( a_i =1 \), \( b_i \geq2 \), and when \( a_i >1 \), \( b_i \geq1 \), but \( b_i \neq a_i \).

Wait, but if \( a_i >1 \), \( b_i \) can be 1, which is fine, as long as \( a_i \neq1 \), but if \( a_i =2 \), then \( b_i \) can be 1,3,4,...

So, in that case, \( b_i \) can be 1, which is fine.

But in the subarray [1,2,1], sum_a=4, min_b=2+1+1=4, but in this case, \( b3=1 = a3=1 \), which is invalid.

So, even though \( sum(a) = min_b \), it's invalid because \( b_i = a_i \) for some \( i \).

Hence, in such cases, I need to ensure that in the minimal assignment, no \( b_i = a_i \).

Wait, but in this case, \( b3=1 = a3=1 \), which is invalid.

So, perhaps I need to adjust the minimal assignment to ensure that no \( b_i = a_i \).

Wait, but in this case, for \( a_i=1 \), \( b_i \geq2 \), and for \( a_i >1 \), \( b_i \geq1 \), but \( b_i \neq a_i \).

Wait, perhaps I need to calculate \( min_b \) such that for each \( a_i \):

- If \( a_i =1 \), \( b_i =2 \)

- If \( a_i >1 \), \( b_i =1 \), unless \( a_i =1 \), but wait, \( a_i >1 \), so \( b_i =1 \) is fine, as \( b_i \neq a_i \)

Wait, but in the subarray [1,2,1], \( min_b =2 +1 +2=5 \), but earlier I thought it was 4, which was incorrect.

Wait, perhaps I made a mistake in calculating \( min_b \).

Let me recast this.

For each \( a_i \):

- If \( a_i =1 \), then \( b_i \geq2 \)

- If \( a_i >1 \), then \( b_i \geq1 \), and \( b_i \neq a_i \)

But in the minimal assignment:

- For \( a_i=1 \), \( b_i=2 \)

- For \( a_i >1 \), \( b_i=1 \), unless \( a_i=1 \), but \( a_i >1 \), so \( b_i=1 \) is allowed as long as \( b_i \neq a_i \)

Wait, but if \( a_i >1 \), and \( b_i=1 \neq a_i \), it's fine.

Hence, for the subarray [1,2,1]:

- For \( a1=1 \), \( b1=2 \)

- For \( a2=2 \), \( b2=1 \)

- For \( a3=1 \), \( b3=2 \)

So, \( min_b =2 +1 +2=5 \)

But sum_a=1+2+1=4, which is less than \( min_b=5 \), which would suggest that it's impossible, but in reality, it's NO because in the minimal assignment, sum is 5, which is greater than sum_a=4, and I can't make sum(b) smaller than min_b.

Wait, but in this case, sum_a=4 < min_b=5, which should imply that it's impossible, but according to the earlier reasoning, it's NO because in the minimal assignment, \( sum(b)=5 >4 \), and I can't make it smaller without setting some \( b_i \) to values less than their minimal, which is not allowed.

Hence, in this case, since sum_a < min_b, it's impossible to have sum(b)=sum_a.

But in the example, for query 4, it's NO, which aligns with this.

Wait, but earlier I thought sum_a=4 and min_b=4, but that was incorrect; actually, min_b=5.

Wait, perhaps I mis-calculated min_b earlier.

Wait, in the initial thought process, I had min_b=2+1+1=4, but according to the correct minimal assignment, it should be 2+1+2=5.

I see, that was my mistake.

So, for \( a_i=1 \), \( b_i \geq2 \), and for \( a_i=2 \), \( b_i \geq1 \), but in the minimal assignment, \( b_i=1 \) for \( a_i=2 \), which is fine, but for \( a_i=1 \), \( b_i=2 \).

Hence, for [1,2,1], min_b=2+1+2=5, which is greater than sum_a=4, hence impossible, NO.

Similarly, for [4], sum_a=4, min_b=1 (since \( a_i=4 \), \( b_i \geq1 \), but \( b_i \neq4 \)), so min_b=1, difference=3.

To make sum(b)=4, choose \( b=4 \), but \( b_i=4=a_i=4 \), invalid.

Next possible is \( b_i=5 \), sum=5, which is greater than 4.

Hence, impossible, NO.

For [1,4], sum_a=5, min_b=2+1=3, which is less than 5.

Hence, possible to choose \( b_i \)'s such that sum=5, for example, \( b=[2,3] \), sum=5, and both \( b_i \neq a_i \), hence YES.

For [1,2,1,4,5], sum_a=13, min_b=2+1+2+1+1=7, which is less than 13.

Hence, possible to choose \( b_i \)'s such that sum=13, for example, [2,1,2,3,5], sum=13, and all \( b_i \neq a_i \), hence YES.

So, from this, it seems that the condition is:

- Calculate min_b as sum of minimal possible \( b_i \)'s:

- For each \( a_i=1 \), \( b_i=2 \)

- For each \( a_i >1 \), \( b_i=1 \)

- If sum_a >= min_b, then it's possible to choose \( b_i \)'s such that sum(b)=sum(a), provided that sum_a >= min_b.

- Otherwise, it's impossible.

But in the earlier example, for [1,2,1], sum_a=4 < min_b=5, hence NO.

For [4], sum_a=4, min_b=1, but choosing \( b_i=4 \) is invalid, and choosing \( b_i=5 \) gives sum=5 >4, hence NO.

Wait, but according to the condition sum_a >= min_b, it should be possible for [4], since 4 >=1, but it's NO.

Hmm, so there must be another condition.

Wait, perhaps in addition to sum_a >= min_b, I need to ensure that for single-element subarrays, sum_a != min_b if \( a_i =1 \), since \( b_i \) cannot be equal to \( a_i \).

Wait, no, in the case of [4], min_b=1, sum_a=4 >=1, but choosing \( b_i=4 \) is invalid, and choosing \( b_i=5 \) gives sum=5 >4.

Hence, in this case, even though sum_a >= min_b, it's impossible because there's only one element, and I can't adjust it to make sum(b)=sum(a) without setting \( b_i = a_i \).

Hence, perhaps for subarrays of length 1, it's only possible if \( a_i >1 \) and sum_a != min_b.

Wait, but in the case of [2], sum_a=2, min_b=1, sum_a >= min_b, but choosing \( b_i=1 \), sum=1 <2; choosing \( b_i=3 \), sum=3 >2.

Hence, impossible to make sum(b)=sum(a), so NO.

Wait, but according to the earlier logic, sum_a >= min_b should be sufficient, but in this case, it's not.

Hence, perhaps for subarrays of length greater than 1, sum_a >= min_b is sufficient, but for subarrays of length 1, it's only possible if \( a_i >1 \) and sum_a != min_b, but even then, it's tricky.

Wait, perhaps the condition is:

- If the subarray length is greater than 1, and sum_a >= min_b, then YES.

- If the subarray length is 1, then it's NO, unless perhaps some specific conditions, but in the example, for [4], it's NO.

Hence, perhaps for subarrays of length 1, it's always NO, unless specific cases where \( a_i >1 \) and sum_a > min_b, but in practice, it's difficult.

Wait, perhaps the general condition is:

- If the subarray length is greater than 1, and sum_a >= min_b, then YES.

- Else, NO.

But in the example, for [1,4], sum_a=5 >= min_b=3, hence YES.

For [4], sum_a=4 >=1, but NO.

Wait, perhaps I need to ensure that sum_a != min_b for single-element subarrays.

Wait, but in [1,4], sum_a=5 != min_b=3, and length >1, hence YES.

For [4], sum_a=4 >=1, but length=1, hence NO.

Hence, perhaps the condition is:

- If the subarray length >1, and sum_a >= min_b, and sum_a != min_b when length=1, then YES.

- Else, NO.

Wait, but in [1,2,1,4,5], sum_a=13 >= min_b=7, and length=5 >1, hence YES.

For [4], sum_a=4 >=1, but length=1, hence NO.

For [1,4], sum_a=5 >=3, length=2 >1, hence YES.

For [1,2,1], sum_a=4 < min_b=5, hence NO.

This aligns with the example outputs.

Hence, the condition is:

- If the subarray length >1 and sum_a >= min_b, then YES.

- Else, NO.

So, to implement this, I need to:

- Compute min_b for the subarray, which is sum of:

- For each element in subarray:

- If element=1, add 2 to min_b.

- Else, add 1 to min_b.

- Then, if the subarray length >1 and sum_a >= min_b, output YES.

- Else, output NO.

This seems to be the correct approach.

Now, considering the constraints:

- t <=10^4 test cases.

- Sum of n over all test cases <=3*10^5.

- Sum of q over all test cases <=3*10^5.

Hence, the total time complexity should be O(n + q) per test case, which needs to be efficient.

Hence, precompute the prefix sums of the array c and the prefix sums of min_b.

Then, for each query, compute sum_a and min_b for the given range, and check the conditions.

Implementing this in code:

- Read t, the number of test cases.

- For each test case:

- Read n and q.

- Read the array c of length n