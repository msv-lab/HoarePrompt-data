Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. Or, if it's impossible to make it un-beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if I can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ |a| - 1) such that a[i - 1] equals a[i + 1], and replace a[i] with a[i - 1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. This operation can be repeated as many times as I want.

My task is to make the array not beautiful by removing the least number of elements possible. If it's impossible to do so, I should return -1.

Let me try to wrap my head around what makes an array beautiful. If I have an array where all elements are already the same, like [2, 2, 2], it's beautiful because no operations are needed. Even if I remove one or more elements, it still remains [2, 2, 2] or [2, 2], which are still beautiful because no operations change anything; all elements are already equal.

Wait, but in the first test case of the example, the array is [2, 2, 2], and the output is -1, meaning it's impossible to make it not beautiful. That makes sense because no matter how many elements I remove, the remaining array will still have all elements equal, so it remains beautiful.

In the second test case, the array is [1, 2, 1, 2, 1]. The output is 1, meaning by removing one element, I can make it not beautiful. Looking at this array, if I remove the last element (index 5), the array becomes [1, 2, 1, 2]. Now, let's see if this new array is still beautiful.

According to the operation, I can choose index i=2 or i=3. If I choose i=2, a[1]=1 and a[3]=1, so I can replace a[2] with 1, making the array [1,1,1,2]. From here, I can't perform any more operations because there's no index i where a[i-1] = a[i+1] and 2 ≤ i ≤ |a|-1. In this state, not all elements are the same, so the array is not beautiful.

Similarly, if I choose i=3, a[2]=2 and a[4]=2, so I can replace a[3] with 2, making the array [1,2,2,2]. Again, no more operations can be performed, and not all elements are the same.

So, by removing one element, I can make the array not beautiful.

In the third test case, with n=1 and array [1], it's impossible to make it not beautiful because it's already not possible to perform any operations (there's only one element), and it's already not beautiful since there are no operations to perform. Wait, but the output is -1, which means it's impossible to make it not beautiful. Hmm, maybe the definition of beautiful for a single element is that it's beautiful, and removing the only element makes it an empty array, which might be considered not beautiful. But the output is -1, so perhaps empty arrays are considered beautiful or something. I need to clarify this.

In the fourth test case, [3,3,3,5,3,3,3], the output is 3. By removing the first three elements, we get [5,3,3,3]. Now, let's see if this is beautiful. If I try to apply the operation, I can choose i=2, since a[1]=5 and a[3]=3 are not equal, so no operation can be performed. Since no operations can be performed and not all elements are the same, it's not beautiful.

So, the goal is to remove as few elements as possible to reach a state where it's impossible to make all elements equal by using the given operation any number of times.

First, I need to understand when an array is not beautiful. An array is not beautiful if it's impossible to make all elements equal using the given operation.

Let me think about what makes an array beautiful. The operation allows me to fix elements that are surrounded by equal elements by making them equal to their neighbors. So, in a sense, it's like spreading the values that are already consistent across the array.

If the array is already uniform, it's beautiful, and removing elements won't change that, as any subset will still be uniform.

If the array has varying elements, I need to see if I can make it uniform by using the operations.

I need to find a way to prevent the array from being made uniform by removing some elements.

Let me consider that if the array has sections where elements are already equal and can be extended to make the whole array uniform, I need to break those connections.

Wait, perhaps I need to look for the minimal number of removals to break all possible paths of equal elements that could be used to spread the values across the array.

This sounds a bit like breaking connectivity in a graph where edges exist between elements that are equal and adjacent.

In graph theory terms, if I consider the array as a graph where nodes are elements, and edges exist between nodes that are equal and adjacent, then the operations allow me to change nodes that are in the middle of such paths to match their neighbors.

To make the array not beautiful, I need to break these paths in such a way that it's impossible to make all nodes the same.

But maybe there's a simpler way to look at it.

Let me consider that if all elements are the same, it's beautiful, and removing elements won't change that. So, in that case, it's impossible to make it not beautiful, and I should return -1.

If not all elements are the same, then perhaps I can make it not beautiful by removing certain elements.

Wait, but in the second test case, [1,2,1,2,1], not all elements are the same, but it's still beautiful because I can use the operations to make them all equal.

Wait, no. As shown in the example, removing one element can make it not beautiful.

Wait, perhaps I need to find the minimal number of removals such that after removal, it's impossible to make all elements equal using the operations.

Let me think differently. Suppose I have an array where all elements are the same except for one. If I remove that one, the array becomes uniform, which is beautiful. So, removing that one element doesn't help; I need to remove more.

Wait, no. If I have [1,1,1,2,1,1,1], and I remove the '2', the array becomes [1,1,1,1,1,1], which is beautiful. So, removing the single different element doesn't make it not beautiful.

But according to the problem, in the second test case, [1,2,1,2,1], removing one element makes it not beautiful.

So, perhaps I need to remove elements in such a way that the remaining array cannot be made uniform through operations.

Let me consider the concept of connectivity again. If I have sections of the array where elements are equal and connected through the operations, I need to break those connections.

Perhaps, the minimal number of removals is equal to the size of the smallest section that, when removed, breaks the connectivity needed to make all elements equal.

This seems complicated. Maybe there's a better way.

Let me look at the reference solution provided.

The reference solution seems to be checking if all elements are the same. If they are, it prints -1, meaning it's impossible to make the array not beautiful by removing elements.

If not all elements are the same, it finds the minimum frequency of any value in the array and prints that as the number of elements to remove.

Wait, but in the second test case, [1,2,1,2,1], the frequencies are: 1 appears 3 times, 2 appears 2 times. The minimum frequency is 2, but the expected output is 1.

So, this reference solution seems incorrect for the second test case.

Wait, perhaps I misread the reference solution.

Looking back, the reference solution is:

def func_1():

n = int(input())

arr = list(map(int, input().split()))

flag = True

for i in range(1, n):

if arr[i] != arr[i - 1]:

flag = False

break

ans = Decimal('Infinity')

(val, cnt) = (arr[0], 0)

for i in range(n):

if arr[i] == val:

cnt += 1

else:

ans = min(ans, cnt)

cnt = 0

ans = min(ans, cnt)

if flag:

print(-1)

else:

print(ans)

So, it first checks if all elements are the same. If they are, it sets flag to True and prints -1.

If not, it initializes val to arr[0] and cnt to 0.

Then, it iterates through the array, counting consecutive elements equal to val.

Whenever it encounters an element not equal to val, it updates ans with the minimum of ans and cnt, and resets cnt to 0.

After the loop, it takes the minimum of ans and cnt.

Then, if flag is True (all elements are the same), it prints -1; else, it prints ans.

In the second test case, [1,2,1,2,1], val is set to 1.

It counts cnt=1 (first 1), then encounters 2, updates ans to min(inf,1)=1, resets cnt=0.

Then counts cnt=1 (second 1), encounters 2, updates ans to min(1,1)=1, resets cnt=0.

Then counts cnt=1 (third 1), reaches end.

ans is min(1,1)=1, so it prints 1.

Which matches the expected output.

So, the reference solution seems correct for this test case.

Wait, but in the fourth test case, [3,3,3,5,3,3,3], val is set to 3.

It counts cnt=3 (first three 3's), encounters 5, updates ans to min(inf,3)=3, resets cnt=0.

Then counts cnt=3 (next three 3's), reaches end.

ans is min(3,3)=3, which matches the expected output.

In the first test case, [2,2,2], all elements are the same, so flag remains True, and it prints -1.

Seems correct.

So, the reference solution seems to be finding the minimum run length of the majority element.

Wait, but in the second test case, the majority element is 1, which has runs of length 1, 1, and 1.

So, the minimum run length is 1, which matches the output.

In the fourth test case, the majority element is 3, with runs of length 3 and 3, so minimum run length is 3, matching the output.

So, perhaps the idea is to find the minimum run length of the majority element.

But why?

Well, by removing that many elements, you can break a run of the majority element, potentially making it so that the array can't be made uniform anymore.

Wait, but in the second test case, removing one element breaks the run of 1's, resulting in [1,2,1,2], which is not beautiful as shown in the example.

Similarly, in the fourth test case, removing three elements breaks the run of 3's, resulting in [5,3,3,3], which is not beautiful.

So, this seems to be a strategy: find the minimum run length of the majority element and remove that many elements to break the run.

But is this always correct?

Let me think of a counterexample.

Suppose the array is [1,2,1,2,1,2,1].

Here, the majority element is 1, with runs of length 1,1,1,1.

According to the reference solution, ans would be 1.

So, removing one element should make it not beautiful.

Let's try removing one element. For example, remove the last element: [1,2,1,2,1,2].

Now, can I make all elements equal?

Option 1: Choose i=2, a[1]=1, a[3]=1, so replace a[2] with 1: [1,1,1,2,1,2].

Then, choose i=4, a[3]=1, a[5]=1, replace a[4] with 1: [1,1,1,1,1,2].

Then, choose i=5, a[4]=1, a[6]=2, but a[4] != a[6], so no operation.

Now, the array is [1,1,1,1,1,2]. It's not all the same, so it's not beautiful.

Wait, but according to the reference solution, removing one element is enough.

But is there a case where this doesn't hold?

Let me try another array: [1,1,2,2,1,1].

Here, the majority element is 1, with runs of length 2, and 2's run of length 2.

According to the reference solution, val=1, cnt=2, encounters 2, updates ans to min(inf,2)=2, resets cnt=0.

Then, counts cnt=2 (next two 1's), reaches end.

ans is min(2,2)=2.

So, it suggests removing 2 elements.

But let's see: if I remove two elements, for example, remove the two 2's, resulting in [1,1,1,1], which is beautiful.

Wait, that doesn't make it not beautiful.

Alternatively, remove one 2 and one 1: [1,1,2,1,1].

Now, can I make all elements equal?

Starting with [1,1,2,1,1].

Option: choose i=3, a[2]=1, a[4]=1, replace a[3] with 1: [1,1,1,1,1], which is beautiful.

Alternatively, remove different elements: remove first and last elements: [1,2,2,1].

Now, [1,2,2,1].

Can I make all elements equal?

Choose i=2, a[1]=1, a[3]=2, not equal, no operation.

Choose i=3, a[2]=2, a[4]=1, not equal, no operation.

So, it's not beautiful.

So, by removing two elements, I can make it not beautiful.

But according to the reference solution, ans is 2, which matches.

Wait, but in the previous case, removing one element was enough, but in this case, removing two is necessary.

Wait, perhaps I miscalculated.

Wait, in the previous case, [1,1,2,2,1,1], the reference solution sets ans=2, meaning removing two elements is enough, which aligns with my example where removing two elements makes it not beautiful.

But in the earlier example [1,2,1,2,1,2,1], the reference solution would set ans=1, and removing one element is enough, as shown.

So, perhaps this approach works.

Another example: [1,2,1,3,1,2,1].

Here, majority element is 1, with runs of length 1,1,1,1.

ans=1.

Removing one element: remove the second element, getting [1,1,3,1,2,1].

Now, can I make all elements equal?

Try to make them all 1's.

Choose i=2, a[1]=1, a[3]=3, not equal, no operation.

Choose i=4, a[3]=3, a[5]=2, not equal, no operation.

Choose i=5, a[4]=2, a[6]=1, not equal, no operation.

So, it's not possible to make all elements equal, so it's not beautiful.

Hence, removing one element is enough.

So, the reference solution seems correct in this case.

Another test case: [1,1,1,2,2,1,1].

Here, majority element is 1, with runs of length 3 and 2.

ans=2.

Removing two elements: for example, remove the two 2's, getting [1,1,1,1,1], which is beautiful.

Wait, that doesn't work.

Alternatively, remove one '1' from the first run and one '1' from the second run: [1,1,2,2,1,1].

As before, this is not beautiful, as shown earlier.

So, removing two elements can make it not beautiful.

Hence, ans=2 is correct.

So, the reference solution seems to be working correctly in these cases.

Now, let's try to understand why this approach works.

The reference solution sets val to arr[0] and then finds the minimum run length of val.

In the second test case, val=1, runs of 1 are all of length 1, so ans=1.

In the fourth test case, val=3, runs of 3 are of length 3 and 3, so ans=3.

In the earlier test case I thought of, [1,1,2,2,1,1], val=1, runs of 2 and 2, so ans=2.

But in another test case, [1,2,1,2,1,2,1], val=1, runs of 1,1,1,1, so ans=1.

So, it seems that by removing the minimum run length of the majority element, I can break the array in such a way that it's not possible to make all elements equal.

But why is this the case?

I think because by removing a run of the majority element with the smallest length, I'm breaking the connectivity of the majority element in the array, making it impossible to spread its value to the entire array using the operations.

Hence, the minimal number of removals required is the size of the smallest run of the majority element.

That makes sense in these examples.

But is this always true?

Let me think of a case where this might not hold.

Consider an array like [1,2,1,2,1,2,1,2,1].

Here, majority element is 1, with runs of length 1,1,1,1,1.

ans=1.

Removing one element: say remove the first element, getting [2,1,2,1,2,1,2,1].

Now, can I make all elements equal?

Choose i=2, a[1]=2, a[3]=2, replace a[2] with 2: [2,2,2,1,2,1,2,1].

Then, choose i=4, a[3]=2, a[5]=1, no operation.

Choose i=6, a[5]=1, a[7]=2, no operation.

Array is [2,2,2,1,2,1,2,1]. Not all elements are the same, so not beautiful.

Another removal: remove the second element, getting [1,1,2,1,2,1,2,1].

Choose i=2, a[1]=1, a[3]=2, no operation.

Choose i=4, a[3]=2, a[5]=2, replace a[4] with 2: [1,1,2,2,2,1,2,1].

Choose i=6, a[5]=2, a[7]=2, replace a[6] with 2: [1,1,2,2,2,2,2,1].

Choose i=2, a[1]=1, a[3]=2, no operation.

Choose i=7, a[6]=2, a[8]=1, no operation.

Array is [1,1,2,2,2,2,2,1]. Not all elements are the same, so not beautiful.

Seems like removing one element is enough.

Another test case: [1,2,3,4,5].

All elements are different. ans should be 0, but according to the reference solution, val=1, and runs are all of length 1, so ans=1.

But in this case, the array is not beautiful because no operations can be performed (no index i where a[i-1]=a[i+1]). So, the minimal number of removals should be 0, but the reference solution would output 1.

Wait, but according to the problem statement, in such a case, it's already not beautiful, so I should output 0.

But the reference solution outputs 1, which is incorrect.

Wait, but according to the problem, "the given array a is beautiful", so in this test case, it's guaranteed that the array is beautiful. If all elements are different, it's not beautiful, which violates the problem's guarantee.

Hence, I don't need to consider such cases, as per the problem statement.

So, assuming that the given array is always beautiful, I don't need to worry about arrays that are not beautiful to begin with.

Hence, in the case where all elements are different, it wouldn't be provided as a test case.

But in reality, if such a case were to occur, the reference solution would output 1, which is incorrect; it should output 0.

But since the problem guarantees that the array is beautiful, I don't need to handle this case.

Another consideration: if the array has only one element, it's beautiful, and removing the only element makes it an empty array, which is not beautiful (as per the problem's example, output -1).

Hence, for n=1, output -1.

The reference solution would set flag=True if all elements are the same, which for n=1 is True, and output -1, which is correct.

So, overall, the reference solution seems correct for the provided test cases and the additional cases I thought of, assuming that the array is always beautiful as per the problem's guarantee.

Hence, I conclude that the given program is correct.

**Final Answer**

\[ \boxed{\text{See explanation for the solution code.}} \]

