Alright, I've got this problem to solve. Let's see what it's about. So, there's this game called "Permutation game" where two players, Bodya and Sasha, are playing with a permutation and an array. They start at certain positions in the permutation and make moves for a fixed number of turns. Each turn, they can choose to stay or move to another position based on the permutation, and they gain points based on the array value at their current position. The goal is to determine who ends up with more points after all the turns.

First, I need to understand the inputs and what exactly is being asked. The input consists of multiple test cases. For each test case, I get the size of the permutation (n), the number of turns (k), and the starting positions for Bodya (P_B) and Sasha (P_S). Then, there's the permutation itself, which is a list of integers from 1 to n, and an array a with n elements, each having a value between 1 and 10^9.

The players make moves simultaneously in each turn. In each turn, both players can choose to stay or move to the position specified by the permutation. Their score increases by the value of a at their current position. After k turns, the player with the higher score wins. If scores are equal, it's a draw.

I need to process multiple test cases efficiently since n can be up to 2*10^5 and k up to 10^9, and the sum of n across all test cases is up to 2*10^5. So, I need an algorithm that is optimized for time.

Let me think about how the game progresses. Each player has their own path through the permutation, and they make choices independently at each turn. However, since they make moves simultaneously, their paths don't affect each other directly. So, I can consider each player's strategy separately.

The key is to maximize each player's score independently, and then compare the maximum scores.

Now, considering that each player can choose to stay or move at each turn, but they have to make exactly k moves. Staying means they keep getting the same a value, moving means they go to a new position based on p.

Wait, but in the problem statement, it says "the player either stays at his current position x or moves from x to p_x". So, at each turn, each player decides whether to stay or to move to p_x.

But, since they make moves simultaneously, and the choices are independent, I can model the path for each player separately.

The challenge is that k can be up to 10^9, which is too large to simulate turn by turn. So, I need to find a way to compute the maximum possible score for each player in O(1) or at least in time independent of k.

I recall that in cycles in permutations, the sequence repeats. So, perhaps finding the cycles in the permutation can help.

Let me recall that a permutation can be decomposed into disjoint cycles. For example, if p = [2, 1, 4, 3], then there are two cycles: 1 -> 2 -> 1 and 3 -> 4 -> 3.

If a player is at a position that is part of a cycle, then after some turns, they will start repeating their positions.

So, if a player is in a cycle of length m, then every m turns, the positions repeat.

Therefore, the sequence of positions a player visits is periodic with period equal to the cycle length.

Given that, perhaps I can compute the maximum score by considering the cycle that the starting position belongs to.

But wait, the player can choose to stay or move at each turn, so it's not purely determined by the permutation.

Wait, but the problem says "the player either stays at his current position x or moves from x to p_x". So, at each turn, the player has a choice: stay and get a_x, or move to p_x and get a_{p_x}.

But since they make moves simultaneously, and they are independent, I can consider each player's choices separately.

However, since k can be up to 10^9, I need an efficient way to compute the maximum possible score for each player.

Let me consider one player's path.

Suppose the player starts at position x. At each turn, they can choose to stay at x and get a_x, or move to p_x and get a_{p_x}.

This seems similar to choosing at each step whether to stay or move to the next position in the permutation.

But since k is large, I need a way to compute the maximum score without simulating each turn.

Perhaps I can model this as a sequence where at each step, the player can choose to stay or move to p_x, and I need to maximize the sum of a values over k steps.

This sounds like a dynamic programming problem, where I keep track of the current position and the number of turns left.

But with k up to 10^9, I can't have a DP state for each turn.

Wait, maybe I can find a cycle in the permutation and compute the maximum score based on that cycle.

Let me consider that the permutation forms cycles, and within each cycle, the positions repeat every m steps, where m is the cycle length.

Then, for each player, I can find the cycle that their starting position belongs to, and then model their movement within that cycle.

But the player can choose to stay or move at each step, so it's not just following the cycle; they have choices.

Wait, maybe I need to think differently.

Let me consider that if a player keeps moving, they follow the permutation cycle, but they can choose to stay at any point to accumulate more points from a_x.

So, perhaps the optimal strategy is to stay at the position with the highest a_x in their cycle for as many turns as possible.

But, they have to make exactly k moves.

Wait, no, in this problem, each turn consists of gaining a_x and then choosing to stay or move. So, it's k turns in total.

Wait, re-reading the problem: "the game lasts k turns. The players make moves simultaneously. On each turn, two things happen to each player: (1) if the current position is x, his score increases by a_x, (2) then the player either stays at x or moves to p_x."

So, at each turn, the player gains a_x and then chooses to stay or move.

Wait, so the choice to stay or move is made after gaining a_x.

So, in terms of strategy, the player can choose to stay at the current position and keep gaining a_x, or move to p_x and gain a_{p_x} in the next turn.

This seems like deciding whether to loop back to the current position or proceed to the next position in the permutation.

Given that k can be up to 10^9, I need an efficient way to compute the maximum possible score for each player.

I think the key is to observe that if a player chooses to stay at a position, they keep gaining a_x for each turn they stay. If they choose to move, they gain a_{p_x} in the next turn, and so on.

So, the player can choose to stay at any position as many times as they want, but each stay costs one turn.

The optimal strategy would be to stay at the position with the highest possible a_x for as many turns as possible.

But, since the player can choose to move to p_x at any turn, they can potentially move to a position with a higher a_x.

Wait, but in the permutation, cycles may exist, so moving might bring the player back to a previously visited position.

Wait, perhaps I need to find, for each player, the maximum a_x in their cycle and then decide to stay there for all k turns.

But, if the cycle contains positions with different a_x, the player might benefit from moving to a position with a higher a_x, even if it's not the maximum.

Wait, perhaps I need to model this as choosing a subset of turns to stay and turns to move, but that seems too time-consuming for large k.

Let me think differently.

Suppose a player starts at position x. They can choose to stay at x for some number of turns, gaining a_x each time, or move to p_x and gain a_{p_x}, and so on.

This seems like a decision tree where at each turn, the player branches into staying or moving.

But with k up to 10^9, I can't build the tree.

Wait, perhaps I can model this as a graph where nodes represent positions, and edges represent moving to p_x or staying at x.

Then, the problem reduces to finding the maximum possible sum of a_x over a path of length k in this graph.

But with n up to 2*10^5, and k up to 10^9, I need a smarter approach.

Let me consider that the graph for each player is a tree where each node has two outgoing edges: one for staying and one for moving.

But this would lead to exponential growth, which is not feasible.

Wait, perhaps I can represent the choices in a different way.

Let me consider that for each player, their possible positions after k turns can be modeled based on the permutation cycle they are in.

Given that permutations consist of disjoint cycles, each player is confined to their respective cycle.

Within a cycle, the positions repeat every m turns, where m is the cycle length.

So, perhaps I can find the cycle that the starting position belongs to, and then consider the a_x values within that cycle.

Then, the player can choose to stay at any position in the cycle for any number of turns.

So, the problem reduces to selecting a sequence of positions within the cycle, possibly repeating positions by staying, to maximize the sum of a_x over k turns.

Given that, perhaps the optimal strategy is to stay at the position with the maximum a_x in the cycle for all k turns.

But, if there are multiple positions with different a_x, the player might benefit from moving to a position with a higher a_x.

Wait, but if the cycle contains a position with a_x greater than or equal to any other position, the player can choose to move to that position and stay there for the remaining turns.

So, in that case, the maximum score would be: find the maximum a_x in the cycle, and set the score to max_a * k.

But, perhaps there are cases where moving between positions in a certain way can lead to a higher score.

Wait, no, because if the player can stay at the position with the highest a_x, that would be the optimal strategy.

Wait, but suppose there is a cycle where some positions have higher a_x than others, but moving to them requires sacrificing some turns.

For example, suppose a cycle is x -> y -> z -> x, with a_x = 1, a_y = 2, a_z = 3.

If the player starts at x, they can choose to stay at x and get 1 each turn, or move to y and get 2, then stay at y for the remaining turns getting 2 each turn.

Alternatively, they could move to y, then move to z and stay at z getting 3 each turn.

So, in this case, the best strategy is to move to z and stay there for the remaining turns, achieving 3 * (k - 2), but losing the a_x and a_y along the way.

Wait, no, because when moving, the player gains a_x at the current position before choosing to stay or move.

Wait, re-reading the problem: "on each turn, two things happen: (1) the score increases by a_x, (2) then the player either stays or moves."

So, the player gains a_x before making the decision to stay or move.

So, in the above example, starting at x:

- Turn 1: gain a_x=1, then choose to stay at x or move to y.

- If stay: gain 1, stay at x.

- If move: gain 1, move to y.

- Turn 2:

- If stayed at x: gain a_x=1, choose to stay or move.

- If moved to y: gain a_y=2, choose to stay or move to z.

- And so on.

So, in this case, if the player chooses to move from x to y in the first turn, their score becomes 1 (from x) + 2 (from y), and then they can choose to stay at y or move to z.

If they choose to stay at y, their score becomes 1 (turn 1, x) + 2 (turn 1, y) + 2 (turn 2, y) + ... + 2 (turn k, y).

Wait, that doesn't seem right.

Wait, actually, the gain happens at the beginning of each turn, before choosing to stay or move.

So, turn structure:

- At the start of the turn, gain a_x where x is the current position.

- Then, choose to stay at x or move to p_x.

- The next turn starts from the new position.

So, in the first turn:

- Start at x, gain a_x.

- Choose to stay at x or move to p_x.

- In the second turn:

- If stayed at x, gain a_x again.

- If moved to p_x, gain a_{p_x}.

And so on for k turns.

Given that, the player can choose to stay at any position for any number of turns, gaining a_x for each stay.

So, the optimal strategy is to find the position with the maximum a_x in their cycle and stay there for all k turns.

But, to reach that position, they might need to spend some turns moving through the cycle.

So, the problem reduces to finding the position with the maximum a_x in the cycle and calculating the minimal number of moves required to reach it, then staying there for the remaining turns.

Wait, but the player can choose to stay or move at each turn, so they can reach the best position in minimal moves and then stay there.

But, they don't have to reach it in minimal moves; they can take longer if it benefits their score.

But, generally, they would want to reach the best position as quickly as possible and then stay there.

So, for each player, I need to find the position in their cycle with the maximum a_x, and compute the minimal number of moves required to reach it, and then stay there for the remaining turns.

But, I need to maximize the score, so perhaps there are better strategies.

Wait, perhaps not.

Let me consider the earlier example:

n=3, k=3, p=[2,3,1], a=[1,2,3].

Player starts at x=1.

Cycle: 1 -> 2 -> 3 -> 1.

Maximum a_x in the cycle is 3 at position 3.

Strategy:

- Turn 1: at x=1, gain a_1=1, move to p_1=2.

- Turn 2: at x=2, gain a_2=2, move to p_2=3.

- Turn 3: at x=3, gain a_3=3, stay at 3.

Total score: 1 + 2 + 3 = 6.

Alternative strategy:

- Turn 1: at x=1, gain a_1=1, stay at 1.

- Turn 2: at x=1, gain a_1=1, stay at 1.

- Turn 3: at x=1, gain a_1=1, stay at 1.

Total score: 1 + 1 + 1 = 3.

So, the first strategy is better.

Another strategy:

- Turn 1: at x=1, gain a_1=1, move to p_1=2.

- Turn 2: at x=2, gain a_2=2, stay at 2.

- Turn 3: at x=2, gain a_2=2, stay at 2.

Total score: 1 + 2 + 2 = 5.

Still not as good as the first strategy.

So, in this case, reaching the position with the maximum a_x as quickly as possible and then staying there is the optimal strategy.

Hence, for each player, I need to find the position in their cycle with the maximum a_x, and compute the minimal number of moves required to reach it, then stay there for the remaining turns.

But, I need to make sure that this is indeed the optimal strategy.

Wait, but in some cases, there might be multiple positions with the same maximum a_x, or positions with high a_x but requiring more moves to reach.

Let me consider another example:

n=4, k=3, p=[2,3,4,1], a=[1,2,3,3].

Player starts at x=1.

Cycle: 1 -> 2 -> 3 -> 4 -> 1.

Maximum a_x is 3 at positions 3 and 4.

Strategy 1:

- Turn 1: at x=1, gain 1, move to 2.

- Turn 2: at x=2, gain 2, move to 3.

- Turn 3: at x=3, gain 3, stay.

Total score: 1 + 2 + 3 = 6.

Strategy 2:

- Turn 1: at x=1, gain 1, move to 2.

- Turn 2: at x=2, gain 2, move to 4.

- Turn 3: at x=4, gain 3, stay.

Total score: 1 + 2 + 3 = 6.

So, both strategies give the same total score.

Hence, it seems that reaching any position with the maximum a_x as quickly as possible and then staying there is the optimal strategy.

Now, to implement this, I need to:

1. Find the cycle that each player's starting position belongs to.

2. Find the position(s) in that cycle with the maximum a_x.

3. For each such position, compute the minimal number of moves required to reach it from the starting position.

4. Choose the position with the maximum a_x and the minimal number of moves to reach it.

5. Compute the score as: sum of a_x along the path to that position, plus the score from staying at that position for the remaining turns.

Wait, but in the above strategies, the sum of a_x along the path may vary depending on the path taken.

But in a cycle, there is only one path to reach a particular position.

So, for each player, I can find the cycle that their starting position is in, find the position with the maximum a_x in that cycle, compute the minimal number of moves to reach it, and then stay there for the remaining turns.

To implement this, I need to:

- Find the cycle for each starting position.

- Find the maximum a_x in that cycle.

- Find the minimal number of moves to reach that position from the starting position.

- Compute the total score as: sum of a_x along the path to that position + max_a * (k - number of moves to reach it).

Wait, but in the turn structure, the player gains a_x at the beginning of each turn, before choosing to stay or move.

So, in the path to the target position, each move includes gaining a_x and then moving to p_x.

Hence, the total score would be the sum of a_x for each turn, including the turns spent moving to the target position and the turns spent staying at the target position.

So, to compute the maximum score, I need to:

- Identify the target position with the maximum a_x in the cycle.

- Compute the minimal number of moves required to reach it from the starting position.

- Compute the sum of a_x along that path.

- Add the max_a * (k - number of moves).

But, I need to make sure that the sum of a_x along the path is correctly calculated.

Wait, in the first example above, with n=3, k=3, p=[2,3,1], a=[1,2,3], starting at x=1.

Target position is x=3 with a=3.

Path: 1 -> 2 -> 3, taking 2 moves.

Sum of a_x along the path: a_1=1 (turn 1) + a_2=2 (turn 2) + a_3=3 (turn 3).

Total score: 1 + 2 + 3 = 6.

Alternatively, if I choose to stay at some position, the sum would be less.

Hence, in this case, moving directly to the target position and then staying there maximizes the score.

So, generalizing, for each player:

- Find the cycle that their starting position is in.

- Find the position with the maximum a_x in that cycle.

- Find the minimal number of moves required to reach that position from the starting position.

- Compute the sum of a_x along that path.

- Compute the score from staying at the target position for the remaining turns.

Hence, the maximum score is:

sum(a_x along the path) + max_a * (k - number of moves to reach the target position)

But, I need to handle the case where k is less than the number of moves required to reach the target position.

In that case, the player cannot reach the target position within k moves, so they have to choose another strategy.

Wait, but in the above example, k=3, and it took 2 moves to reach position 3, so k - 2 = 1 turn staying at position 3, giving a total score of 1 + 2 + 3 = 6.

If k=2, then sum(a_1 + a_2) = 1 + 2 = 3, and cannot stay at position 3 because k - 2 = 0, meaning no stays at position 3.

If k=1, only a_1 = 1.

So, in general, for each player, I need to:

- Find the position with the maximum a_x in their cycle.

- Find the minimal number of moves required to reach it from the starting position.

- If k is less than the number of moves required, the player cannot reach the target position within k moves, so they have to choose another strategy.

But, in practice, since the cycle is finite, and the player can choose to stay at any position, perhaps there's a better way.

Wait, perhaps I can model this as a graph where each node has two options: stay or move.

Then, the problem becomes finding the maximum sum path in this graph with exactly k steps.

But with k up to 10^9, this is not feasible.

An alternative approach is to observe that in a cycle, the positions repeat every m steps, where m is the cycle length.

Hence, after m steps, the positions start repeating.

Therefore, I can consider the cycle as a circular list and find the optimal starting segment of length up to k.

But this still seems complicated.

Wait, perhaps I can precompute the maximum a_x in the cycle and the minimal number of moves to reach it, then compute the score accordingly.

Let me try to formalize this.

For a player starting at position s, belonging to a cycle of length m:

- Find the maximum a_x in the cycle, say max_a.

- Find the minimal number of moves required to reach a position with max_a, say d.

- If k >= d, then the maximum score is sum of a_x along the path to the target position + max_a * (k - d).

- If k < d, then the player cannot reach the target position within k moves, so the maximum score is the sum of a_x along the best possible path within k moves.

But, in practice, since the cycle is known, I can list out the positions in the cycle and their a_x values, and find the optimal sequence.

Wait, perhaps I can model this as a linear sequence where the player can choose to stay or move at each step, and find the maximum sum over k steps.

But this still seems too slow for large k.

Let me consider that in each turn, the player can choose to stay and get a_x, or move to p_x and get a_{p_x} in the next turn.

This resembles a dynamic programming problem, where dp[i] represents the maximum score after i turns.

But with k up to 10^9, I cannot compute dp for each k.

Wait, perhaps I can find a repeating pattern in the dp array due to the cycle structure.

Alternatively, perhaps I can find a mathematical formula to compute the maximum score.

Let me consider that the player can choose to stay at any position for any number of turns, but moving follows the permutation.

Hence, the player can choose to stay at a position and accumulate a_x for multiple turns, or move to another position and accumulate a_{p_x}, and so on.

The optimal strategy would be to find the position with the maximum a_x in their cycle and stay there for as many turns as possible.

To reach that position, the player might need to make some moves, each move costing one turn and gaining a_x.

Once at the target position, the player can stay there and accumulate a_x per turn.

So, the total score would be the sum of a_x along the path to the target position plus a_x * (k - number of moves to reach the target position).

Wait, but in reality, the sum of a_x along the path includes the a_x values of the positions visited while moving to the target position.

Hence, for a given path, the sum is the sum of a_x at each position visited in each turn.

So, to maximize the sum, the player should minimize the number of moves required to reach the target position and then stay there.

Hence, for each player, I need to find:

- The maximum a_x in their cycle, say max_a.

- The minimal number of moves required to reach a position with max_a, say d.

- Then, the maximum score is sum of a_x along the path of length d + max_a * (k - d).

But, I need to make sure that sum of a_x along the path is correctly calculated.

Wait, in the earlier example, n=3, k=3, p=[2,3,1], a=[1,2,3], starting at x=1.

max_a = 3 at position 3.

d = 2 moves: 1 -> 2 -> 3.

sum_a along the path: a_1 + a_2 + a_3 = 1 + 2 + 3 = 6.

k - d = 3 - 2 = 1.

So, total score = 1 + 2 + 3 + 3 * (3 - 2) = 6 + 3 = 9.

But in reality, in the first turn, gain a_1=1, move to 2.

Second turn, gain a_2=2, move to 3.

Third turn, gain a_3=3, stay at 3.

Total score: 1 + 2 + 3 = 6.

So, according to my formula, it's 6 + 3*(3-2) = 9, which is incorrect.

Wait, there's a mistake here.

In the formula, sum_a along the path is 1 + 2 + 3 = 6, and then max_a * (k - d) = 3 * (3 - 2) = 3, totaling 9.

But in reality, the player only gains a_x at the beginning of each turn, and in the last turn, they stay at position 3, gaining a_3=3.

So, total score should be 1 + 2 + 3 = 6, not 9.

Hence, my formula is incorrect.

I need to adjust it.

Wait, perhaps the formula should be sum of a_x along the path to the target position plus max_a * (k - d).

But in the above example, sum_a along the path is a_1 + a_2 + a_3 = 1 + 2 + 3 = 6, and max_a * (k - d) = 3 * (3 - 2) = 3, totaling 9, which is more than the actual possible score of 6.

So, clearly, the formula is wrong.

Wait, perhaps I need to think differently.

Let me consider that in each turn, the player gains a_x and then chooses to stay or move.

Hence, the total score is the sum of a_x over all turns, where x is the position at the beginning of the turn.

So, to maximize the score, the player should maximize the sum of a_x over k turns.

Hence, the optimal strategy is to be at the position with the maximum a_x for as many turns as possible.

To do that, the player needs to reach that position as quickly as possible and then stay there.

Hence, for each player:

- Find the position with the maximum a_x in their cycle.

- Find the minimal number of moves required to reach that position from the starting position.

- Let d be the number of moves required to reach the target position.

- Then, the player can be at the target position for (k - d) turns.

- The total score would be the sum of a_x along the path to the target position plus max_a * (k - d).

But in the earlier example, sum_a along the path is a_1 + a_2 + a_3 = 1 + 2 + 3 = 6, and max_a * (k - d) = 3 * (3 - 2) = 3, totaling 9, but in reality, the player can only gain a_1 + a_2 + a_3 = 6.

So, there is a mismatch.

Wait, perhaps I need to adjust the formula.

Wait, in the path to the target position, each move includes gaining a_x and then moving to p_x.

Hence, for d moves, the player gains a_{x0} + a_{x1} + ... + a_{xd}, where x0 is the starting position, x1 = p_{x0}, ..., xd = p_{xd-1}.

Then, after d moves, the player reaches the target position and can stay there for (k - d) turns, gaining max_a per turn.

Hence, the total score would be sum_{i=0}^{d} a_{xi} + max_a * (k - d).

In the earlier example, sum_{i=0}^{2} a_{xi} = a_1 + a_2 + a_3 = 1 + 2 + 3 = 6, and max_a * (3 - 2) = 3 * 1 = 3, so total score = 6 + 3 = 9.

But in reality, the player only gains 1 + 2 + 3 = 6, because in the third turn, they are at position 3 and gain a_3=3, then stay.

Hence, the formula sum_{i=0}^{d} a_{xi} + max_a * (k - d) overcounts the score.

Wait, perhaps the issue is that the sum includes a_{xd} twice: once in the sum and once in the max_a * (k - d).

Wait, no, in the formula, sum_{i=0}^{d} a_{xi} includes a_{xd}, and then max_a * (k - d) also includes a_{xd} for each of the (k - d) turns.

But in reality, a_{xd} is only gained once, when reaching position xd, and then gaining max_a for each stay.

Hence, the correct formula should be sum_{i=0}^{d-1} a_{xi} + a_{xd} + max_a * (k - d).

Wait, no.

Let me think carefully.

In the first turn:

- Gain a_{x0}, then choose to stay or move to p_{x0}.

If move:

- Second turn:

- Gain a_{p_{x0}}, then choose to stay or move to p_{p_{x0}}.

If move:

- Third turn:

- Gain a_{p_{p_{x0}}}, then choose to stay or move to p_{p_{p_{x0}}}.

If stay:

- Fourth turn:

- Gain a_{p_{p_{x0}}}, stay at p_{p_{x0}}.

And so on.

Hence, in the path to the target position, each move includes gaining a_x and then moving to p_x.

Once at the target position, staying there gains a_x each turn.

Hence, the total score is the sum of a_x along the path to the target position plus a_x * (k - d), where d is the number of moves to reach the target position.

In the earlier example:

- d = 2 moves to reach position 3.

- sum_{i=0}^{d-1} a_{xi} = a_1 + a_2 = 1 + 2 = 3.

- Then, at position 3, gain a_3 = 3, and stay for (k - d) = 1 turn, gaining a_3 = 3.

- Hence, total score = 1 (first turn) + 2 (second turn) + 3 (third turn) = 6.

Wait, but according to the formula sum_{i=0}^{d-1} a_{xi} + max_a * (k - d + 1).

Wait, perhaps I need to adjust the formula to sum_{i=0}^{d-1} a_{xi} + max_a * (k - d + 1).

In the example:

sum_{i=0}^{1} a_{xi} = a_1 + a_2 = 1 + 2 = 3.

max_a * (k - d + 1) = 3 * (3 - 2 + 1) = 3 * 2 = 6.

Total score = 3 + 6 = 9, which is still not matching the actual score of 6.

Wait, perhaps I need to think differently.

Let me consider that the total score is the sum of a_x over k turns, where x is the position at the beginning of each turn.

Hence, to maximize the sum, the player should be at the position with the maximum a_x for as many turns as possible.

Hence, the optimal strategy is:

- Identify the position with the maximum a_x in their cycle, say position t with a_t = max_a.

- Find the minimal number of moves to reach position t from the starting position, say d moves.

- Then, the player can be at position t for (k - d) turns.

- The sum of a_x along the path to t is sum_{i=0}^{d-1} a_{xi}, where x0 is the starting position, x1 = p_{x0}, ..., x_{d} = t.

- Then, the total score is sum_{i=0}^{d-1} a_{xi} + a_t * (k - d).

In the earlier example:

d = 2 moves to reach position 3.

sum_{i=0}^{1} a_{xi} = a_1 + a_2 = 1 + 2 = 3.

a_t * (k - d) = 3 * (3 - 2) = 3.

Total score = 3 + 3 = 6, which matches the actual score.

Wait, but in my earlier calculation, I had sum_{i=0}^{d} a_{xi} + max_a * (k - d), which included a_t twice.

Hence, the correct formula should be sum_{i=0}^{d-1} a_{xi} + max_a * (k - d).

Wait, but in the above corrected calculation, it matches.

Hence, the formula should be:

sum_{i=0}^{d-1} a_{xi} + max_a * (k - d)

Where d is the minimal number of moves to reach the target position.

Hence, for each player, I need to:

- Find the position with the maximum a_x in their cycle.

- Find the minimal number of moves to reach that position from the starting position.

- Compute the sum of a_x along the path to the target position (sum_{i=0}^{d-1} a_{xi}).

- Add max_a * (k - d).

- This gives the maximum possible score for that player.

Then, compare the maximum scores of Bodya and Sasha to determine the winner.

Now, to implement this efficiently, I need to:

- Find the cycle that each starting position belongs to.

- Find the maximum a_x in that cycle.

- Find the minimal number of moves to reach that position from the starting position.

Given that n can be up to 2*10^5 and k up to 10^9, and t up to 10^4, I need an efficient way to handle this.

First, I can preprocess the permutation to find the cycles.

But with t up to 10^4, and n up to 2*10^5 per test case, I need to make sure that the preprocessing is efficient.

Wait, no, t is the number of test cases, and for each test case, n can be up to 2*10^5, but the sum of n over all test cases is up to 2*10^5.

Hence, overall time complexity should be O(n + t), where n is up to 2*10^5 and t up to 10^4.

Hence, I need an efficient way to handle this.

I can process all test cases together for the same permutation and array a.

Wait, but each test case has its own n, k, P_B, P_S, p, and a.

Wait, re-reading the problem: "It is guaranteed that the sum of values of n over all test cases does not exceed 2*10^5."

Hence, I can process all test cases together, considering that the total n across all test cases is up to 2*10^5.

Hence, I can read all test cases first, store them, and then process them efficiently.

Now, for each test case, I need to:

- Find the cycle that P_B and P_S belong to.

- For each player, find the position with the maximum a_x in their cycle.

- Find the minimal number of moves to reach that position from their starting position.

- Compute the maximum score using the formula: sum_{i=0}^{d-1} a_{xi} + max_a * (k - d).

- Then, compare the two scores to determine the winner.

But, since the cycles can be shared across test cases, I need to make sure that I don't recompute the cycles multiple times.

Wait, but each test case has its own permutation p and array a.

Hence, for each test case, I need to process its own permutation and array a.

Given that, and t up to 10^4, but n up to 2*10^5 in total, I need an efficient way to handle this.

I can read all test cases first, store them in a list, and then process them one by one.

For each test case, I can:

- Build the permutation p and array a.

- For each starting position, find the cycle it belongs to.

- Find the maximum a_x in that cycle.

- Find the minimal number of moves to reach that position from the starting position.

- Compute the maximum score.

- Compare the two scores and output the result.

But finding cycles for each test case separately would be time-consuming if done naively.

I need a smarter way.

Wait, perhaps I can represent the permutation as a graph where each node has out-degree 1, and find the cycles.

But with t up to 10^4 and n up to 2*10^5 in total, I need an efficient way to handle this.

Let me think about the following approach:

- For each test case, build the permutation p and array a.

- For each player's starting position, traverse the permutation to find the cycle.

- While traversing, keep track of the positions and their a_x values.

- Find the position with the maximum a_x in the cycle.

- Find the minimal number of moves to reach that position from the starting position.

- Compute the maximum score using the formula.

- Compare the two scores and output the result.

But traversing the permutation for each player in each test case would be O(n) per player, which is acceptable since the total n across all test cases is up to 2*10^5.

Hence, overall time complexity would be O(n + t), which should be efficient enough.

Now, let's think about how to implement this.

First, read t, the number of test cases.

Then, for each test case:

- Read n, k, P_B, P_S.

- Read the permutation p as a list of n integers from 1 to n.

- Read the array a as a list of n integers from 1 to 10^9.

- For Bodya and Sasha, compute their maximum possible scores using the above strategy.

- Compare the scores and output "Bodya", "Sasha", or "Draw" accordingly.

Now, to compute the maximum score for each player:

- Start from the starting position s.

- Initialize an empty list to store the path.

- Traverse the permutation starting from s, keeping track of visited positions to detect cycles.

- While traversing, collect the positions and their a_x values.

- Find the position with the maximum a_x in the cycle.

- Find the minimal number of moves to reach that position from s.

- Compute the sum of a_x along the path to the target position.

- Compute the score as sum_{i=0}^{d-1} a_{xi} + max_a * (k - d).

Wait, but I need to make sure that I correctly identify the cycle and the path to the target position.

Let me think about how to implement this traversal.

I can use a function that, given a starting position s, returns the path until a cycle is detected.

Then, from the path, I can identify the cycle and find the position with the maximum a_x in the cycle.

Then, find the minimal number of moves to reach that position from s.

Wait, but in a permutation, the cycle is unique for each starting position.

Hence, I can traverse from s until I revisit a position, which indicates the start of the cycle.

Then, from the path, I can extract the cycle and find the position with the maximum a_x.

Then, find the minimal number of moves to reach that position from s.

Wait, but in a permutation, the cycle can be found by following p[s], p[p[s]], etc., until we return to a previously visited position.

Once the cycle is found, I can find the position with the maximum a_x in the cycle.

Then, find the minimal number of moves to reach that position from s.

To find the minimal number of moves, I can keep track of the positions in the path from s to the target position.

But, in a cycle, there might be multiple paths to reach the target position, but since it's a cycle, there is only one minimal path.

Wait, in a cycle, there are two directions: following p or following the inverse permutation.

But to minimize the number of moves, the player should follow the direct path in the cycle.

Hence, for each player, I can:

- Find the cycle that s belongs to.

- Find the position t in the cycle with the maximum a_x.

- Find the minimal number of moves from s to t in the cycle.

- Compute the sum of a_x along that path.

- Compute the score as sum_{i=0}^{d-1} a_{xi} + a_t * (k - d).

Now, to implement this efficiently, I need to:

- For each test case, build p and a.

- For each player, find their cycle, find t and d, compute the sum, and then the score.

- Compare the two scores and output the result.

I need to make sure that I handle the case where k < d, i.e., the player cannot reach t within k moves.

In that case, the player cannot achieve the maximum possible score, and I need to adjust the score accordingly.

Hence, if k < d, the player cannot reach t, so the maximum score would be the sum of a_x along the best possible path within k moves.

But, in practice, since d is the minimal number of moves to reach t, and t is in the cycle, the player might be able to reach t in d moves, but if k < d, they cannot reach it.

Hence, in that case, the player cannot