Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers i, j, and x, where 1 ≤ i ≤ j ≤ n, and then setting all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is basically the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I need to spend to achieve this. It's guaranteed that I can always make all elements equal, so I don't have to worry about cases where it's impossible.

First, I need to understand what's the most efficient way to make all elements equal with at most one operation. Since I can only perform the operation once, I need to choose the segment [i, j] wisely to minimize the cost.

Let me think about this. If I choose to set a segment [i, j] to a value x, then all elements in that segment become x. To make the entire array equal, I need to ensure that after this operation, all elements are the same. That means, outside of [i, j], the elements should already be equal to x, or I need to set them in this operation as well.

Wait, but I can only perform the operation once. So, I need to select i and j such that, after setting arr[i] to arr[j] to x, the entire array becomes equal to x. That means, all elements before i and after j should already be equal to x.

Hmm, that seems tricky. Let's consider some examples to get a better understanding.

Take the first example from the problem:

n = 6

arr = [1, 2, 3, 4, 5, 1]

I need to make all elements equal with at most one operation. Let's say I choose i=2, j=4, x=8. Then the array becomes [1,8,8,8,5,1]. But they're not all equal. To make them all equal, I need to choose a segment such that, after setting it to x, the entire array becomes x.

Wait, but I can choose x to be the value that is already present in the array, or any value, since the problem says x can be any integer. But probably, choosing x to be one of the existing values in the array might be optimal.

Let me think differently. If I can perform the operation only once, what's the minimal cost to make the array equal?

Option 1: Perform the operation on the entire array, setting all elements to x. The cost would be n, since j - i + 1 = n.

Option 2: Find a segment [i, j] such that, by setting it to x, the rest of the array already matches x.

Wait, but I can choose x to be any value. So, perhaps choosing x to be the most frequent value in the array would be a good strategy.

Wait, but that might not necessarily minimize the cost. Let me think of another approach.

Let's consider that after the operation, the entire array should be equal to some value x. So, I need to set all elements that are not equal to x to x. But I can only do one operation, which allows me to set a contiguous segment to x.

So, to minimize the cost, I need to maximize the number of elements that are already equal to x, so that I don't have to set them in the operation.

Wait, perhaps I should choose x to be the value that appears most frequently in the array. Then, the number of elements that need to be set to x would be minimized.

But, since I can only set a contiguous segment to x, it's not just about the frequency, but also about the distribution of x in the array.

Let me consider the second example:

n = 7

arr = [1,1,1,1,1,1,1]

Here, all elements are already equal to 1, so the cost is 0, which makes sense.

Third example:

n = 8

arr = [8,8,8,1,2,8,8,8]

Here, the output is 2. So, I need to spend 2 burles to make all elements equal. Probably by setting the segment [4,5] to 8, which costs 2, and then the array becomes [8,8,8,8,8,8,8,8].

Fourth example:

n = 1

arr = [1]

Already equal, cost 0.

Fifth example:

n = 2

arr = [1,2]

Output is 1. So, I can set either the first element to 2 or the second element to 1, both costing 1.

Sixth example:

n = 3

arr = [1,2,3]

Output is 2. So, I can set either [1,2] to 3, or [2,3] to 1, etc., but the minimal cost is 2.

Seventh example:

n = 7

arr = [4,3,2,7,1,1,3]

Output is 6. So, probably setting [1,6] to 3, costing 6, and the array becomes [3,3,3,3,3,3,3].

Eighth example:

n = 9

arr = [9,9,2,9,2,5,5,5,3]

Output is 7. Maybe setting [3,9] to 5, costing 7, and the array becomes [9,9,5,5,5,5,5,5,5].

From these examples, it seems like the strategy is to find the minimal cost to set a segment such that, after setting, all elements are equal.

Now, let's think about how to implement this efficiently, considering that t can be up to 10^4 and n up to 2*10^5, with the sum of n over all test cases up to 2*10^5.

I need an efficient algorithm, preferably linear time per test case.

Let me consider that I need to make all elements equal to some value x. To minimize the cost, I should choose x such that the prefix and suffix that are already equal to x are as long as possible, so that I only need to set the middle segment to x.

So, I can iterate through possible x values, but that would be too slow since x can be up to n, and n is up to 2*10^5.

Wait, but x can be any integer, not necessarily present in the array. So, I need a better approach.

An optimization: Since I can choose any x, I don't need to consider the values in the array for x. I can choose x to be a new value not present in the array, but that wouldn't help because I would have to set the entire array to x, costing n burles.

So, it's better to choose x to be one of the existing values in the array, preferably one that already appears multiple times.

Wait, but as seen in the fifth example, [1,2], choosing x as 1 or 2 would cost 1, which is the minimal possible.

In the sixth example, [1,2,3], choosing any x would cost at least 2, since I need to change at least two elements.

Wait, no, in that example, output is 2, and indeed, choosing x=3, setting [1,2] to 3 costs 2, and the array becomes [3,3,3].

Alternatively, choosing x=1, setting [2,3] to 1 costs 2, resulting in [1,1,1].

So, in this case, multiple choices of x lead to the same minimal cost.

So, perhaps the minimal cost is the length of the array minus the length of the longest prefix and suffix that have the same value.

Wait, let's think about that.

Suppose I choose x to be the value of the first element. Then, I need to set the suffix that doesn't match the first element to x.

Alternatively, choose x to be the value of the last element, and set the prefix that doesn't match the last element to x.

Or choose some other x, but that would require setting both prefix and suffix to x.

It seems more efficient to choose x as the value that maximizes the combined length of the prefix and suffix that are already equal to x.

Wait, perhaps I should find the maximum overlap between prefix and suffix that have the same value, and then set the middle segment to that value.

Let me formalize this.

Let me define:

- Find the largest possible value of k such that there exists some index i where the prefix of length i and the suffix of length k - i have the same value.

Then, the minimal cost would be n - k.

Wait, maybe that's overcomplicating it.

Let me look at the first example again:

n = 6

arr = [1,2,3,4,5,1]

Here, the prefix [1] and the suffix [1] have the same value. So, k = 1 + 1 = 2.

Then, the minimal cost is n - k = 6 - 2 = 4, which matches the sample output.

Second example:

n = 7

arr = [1,1,1,1,1,1,1]

k = 7 (entire array), cost = 0.

Third example:

n = 8

arr = [8,8,8,1,2,8,8,8]

k = 6 (prefix [8,8,8,8] and suffix [8,8,8], overlapping [8,8,8]), cost = 8 - 6 = 2.

Fourth example:

n = 1

arr = [1]

k = 1, cost = 0.

Fifth example:

n = 2

arr = [1,2]

k = 1 (prefix [1] and suffix [2] have no overlapping value), cost = 1.

Wait, but in this case, k should be 1 + 1 = 2, since both prefix and suffix have length 1 and equal value if x is chosen appropriately.

Wait, but in this case, choosing x=1, prefix length 1, suffix length 1, but they don't have the same value. So, k=1.

Wait, maybe my assumption is incorrect.

Wait, perhaps k is the sum of the lengths of the longest prefix and suffix that have the same value, minus the overlap if they overlap.

This seems messy.

Let me try another approach.

Suppose I choose x to be the value of the first element. Then, find the longest suffix that has all elements equal to x. Then, the cost would be n minus the length of the prefix that is already x minus the length of the suffix that is already x plus the overlap if any.

Wait, perhaps it's better to iterate through possible x and compute for each x:

- Find the longest prefix that is equal to x.

- Find the longest suffix that is equal to x.

- Then, k = the sum of the lengths of the prefix and suffix minus the overlap.

- The minimal cost is n - k.

Wait, but this seems complicated to implement efficiently.

Let me consider that the minimal cost is the length of the array minus the length of the intersection of the prefix and suffix that have the same value.

Wait, perhaps I should find the largest x such that there exists some value v where the prefix of length i and the suffix of length j have all elements equal to v, and i + j - overlap is maximized.

This seems too convoluted.

Let me think differently.

Suppose I fix x, then I need to set all elements that are not equal to x to x in one operation.

To minimize the cost, I need to set the smallest possible segment to x that covers all elements that are not equal to x.

Wait, but since I can only set a contiguous segment to x, I need to choose a segment [i, j] such that, outside of this segment, all elements are already equal to x.

So, the cost is j - i + 1, and I need to choose i and j such that all elements before i and after j are equal to x.

So, for a given x, I need to find the minimal j - i + 1 such that arr[1..i-1] and arr[j+1..n] are all equal to x.

If there are elements before i or after j that are not equal to x, then I cannot choose that [i, j].

Wait, so for each x, I need to find the minimal j - i + 1 such that arr[1..i-1] and arr[j+1..n] are all equal to x.

To find this efficiently, I can precompute for each x:

- The maximum i such that arr[1..i] are all equal to x.

- The maximum j such that arr[j..n] are all equal to x.

Then, for each x, k = max(i + (n - j + 1)).

And the minimal cost is n - k.

Wait, but I need to make sure that i-1 <= j, meaning that there is a segment [i, j] that covers the non-x elements.

Wait, this is getting complicated.

Let me see if there's a better way.

An alternative approach: Since I can perform at most one operation, I can either choose to set a segment to a new value, or set a segment to an existing value.

But perhaps it's better to consider that after the operation, the entire array should be equal to some value x.

So, I need to set all elements that are not equal to x to x, but I can only set a contiguous segment to x in one operation.

So, to minimize the cost, I need to maximize the number of elements that are already equal to x.

Thus, the minimal cost is n minus the maximum number of elements already equal to x that form a prefix and a suffix.

Wait, perhaps I should find the maximum number of elements that are equal to x, where these elements form a prefix and a suffix.

Wait, maybe I should find the maximum overlap between the prefix and suffix that have the same value.

Let me try to formalize this.

For each x, compute:

- The length of the longest prefix that is equal to x.

- The length of the longest suffix that is equal to x.

Then, the maximum k for that x is the sum of the prefix and suffix lengths minus the overlap, which is the minimum of the two if they overlap.

Wait, no, if the prefix and suffix overlap, I need to subtract the overlapping part.

But this seems too time-consuming to compute for all x.

Wait, maybe I can iterate through the array and find the maximum number of elements that are equal, forming a prefix and a suffix.

Wait, perhaps I can find the maximum number of elements that are equal at both ends of the array.

For example, in the first sample:

[1,2,3,4,5,1]

The prefix [1] and the suffix [1] are equal, so k=2.

In the second sample:

[1,1,1,1,1,1,1]

The entire array is equal, so k=7.

In the third sample:

[8,8,8,1,2,8,8,8]

The prefix [8,8,8,8] and the suffix [8,8,8] overlap by [8,8,8], so k=6.

Wait, in this case, the prefix of length 4 and suffix of length 3 overlap by 3, so k=6.

In the fifth sample:

[1,2]

k=1, since prefix [1] and suffix [2] have no overlap.

In the sixth sample:

[1,2,3]

k=1, since no overlap between prefix and suffix.

So, in general, for each x, find the length of the longest prefix that is equal to x and the longest suffix that is equal to x, and their sum minus their overlap gives the total number of elements that are equal to x in the prefix and suffix.

Then, k = prefix[x] + suffix[x] - overlap.

But overlap is the minimum of prefix[x] and suffix[x], if they overlap.

Wait, but in the third sample, for x=8, prefix=4, suffix=3, overlap=3, so k=4 + 3 - 3 = 4.

But in the sample, k=6, which is 4 + 3 - 1 = 6, which doesn't make sense.

Wait, perhaps I need to add the minimum of prefix and suffix.

Wait, perhaps k = prefix + suffix - min(prefix, suffix).

But in the third sample, that would be 4 + 3 - 3 = 4, but the sample has k=6.

Wait, maybe I need to add the maximum of prefix and suffix.

Wait, that would be 4 + 3 - 3 = 4, still not 6.

I must be missing something.

Wait, perhaps I need to consider that the overlap is only subtracted if there is an overlap.

In the third sample, the prefix and suffix overlap by 3 elements, so k = 4 + 3 - 3 = 4, but the sample has k=6, which is n - minimal cost = 8 - 2 = 6.

Wait, maybe I need to subtract the overlap only if prefix + suffix > n.

Wait, in the third sample, prefix=4, suffix=3, n=8, so overlap is min(4,3)=3, and k=4 + 3 - 3=4, but the sample has k=6, which suggests that overlap should be min(prefix, suffix), but in this case, it's not matching.

Wait, perhaps I need to consider that k is the sum of prefix and suffix lengths minus the overlap, where overlap is the length of the intersection.

In the third sample, prefix=4, suffix=3, overlap=3 (the last 3 elements of the prefix and the first 3 elements of the suffix are the same), so k=4 + 3 - 3=4, but the sample has k=6, which is n - minimal cost = 8 - 2 =6.

Wait, perhaps I need to consider the maximum of prefix and suffix.

If I take k = max(prefix, suffix), then in the third sample, k=4, which is less than the sample's k=6.

So, that's not it.

Wait, maybe k = prefix + suffix - min(prefix, suffix), which is 4 + 3 - 3 =4, still not 6.

Wait, perhaps I need to consider that the overlap is only subtracted if prefix + suffix > n.

In this case, prefix + suffix =7, which is less than n=8, so no overlap subtraction.

But then k=7, which is not the case.

Wait, in the first sample, prefix=1, suffix=1, min=1, so k=1+1-1=1, but the sample has k=2, which is n - minimal cost =6 -4=2.

Wait, this is confusing.

Let me try another approach.

Suppose I choose x to be a certain value, and I find the first index i from the start where arr[i] != x, and the last index j from the end where arr[j] != x.

Then, setting the segment [i, j] to x would make the entire array equal to x.

The cost is j - i + 1.

I need to choose x such that this cost is minimized.

So, for each x, find the first i where arr[i] != x, and the last j where arr[j] !=x, and set the segment [i, j] to x, costing j - i + 1.

Then, the minimal cost is the minimum over all x of j - i + 1.

Wait, but x can be any integer, not necessarily in the array.

If I choose x not in the array, then I have to set the entire array to x, costing n.

So, it's better to choose x that is in the array.

Wait, but in the fifth sample, [1,2], choosing x=1 or x=2 costs 1, which is better than choosing a new x which would cost 2.

So, yes, choosing x from the array is better.

So, I can iterate over all unique values in the array, compute for each the minimal segment to set, and take the minimum over all those costs.

But in terms of implementation, this might be too slow if the array has many unique values.

Given the constraints, n can be up to 2*10^5, and t up to 10^4, with sum of n over all test cases up to 2*10^5, I need an O(n) per test case solution.

So, iterating over all unique x is not feasible.

I need a better way.

Let me consider that the minimal cost is equal to the length of the array minus the maximum number of elements that are equal at both ends of the array.

Wait, in the first sample, n=6, and k=2, so minimal cost is 4, which is n - k.

In the third sample, n=8, k=6, minimal cost=2, which is n - k.

So, perhaps k is the maximum number of elements that are equal at both ends of the array, meaning the maximum length of a prefix and suffix that have the same value.

Wait, in the first sample, the maximum k is 1 +1=2 (prefix [1] and suffix [1]).

In the third sample, prefix [8,8,8,8] and suffix [8,8,8], so the overlapping part is [8,8,8], so k=6.

Wait, perhaps k is the sum of the lengths of the prefix and suffix that have the same value, minus the overlap.

In this case, k=4 +3 -1=6, which matches the sample.

Wait, but in general, this might be tricky to compute.

Let me think about it differently.

Suppose I fix x, and I find the largest i such that arr[1..i]==x, and the largest j such that arr[j..n]==x.

Then, the total number of elements that are already x is i + (n - j +1).

But, if there is an overlap, meaning i >=j, then I need to subtract the overlapping part.

So, k = i + (n - j +1) - (i - j +1) if i >=j, else k = i + (n - j +1).

Wait, no, if i >=j, then the overlap is j - i +1, so k = i + (n - j +1) - (j - i +1).

Simplify: k = i + n - j +1 - j + i -1 = 2i -2j + n - j.

Wait, that seems off.

Let me think again.

If i >=j, meaning that the prefix and suffix overlap, then the total number of x elements is i + (n -j +1) - (j -i +1).

Wait, perhaps it's better to use k = i + (n -j +1) - overlap, where overlap is max(0, i -j +1).

Wait, in the third sample, i=4, j=6, n=8.

So, k=4 + (8 -6 +1)=4 +3=7 - overlap.

If overlap is i -j +1=4-6+1=-1, which is less than 0, so overlap=0.

So, k=7 -0=7, but the sample has k=6.

Hmm, not matching.

Wait, perhaps overlap is min(i, n -j +1).

Wait, this is getting too complicated.

Let me look at the provided code and see if I can understand the logic behind it.

Given code:

def func_1(arr):

i = 0

n = len(arr)

j = len(arr) - 1

while i < len(arr) - 1 and arr[i] == arr[i + 1]:

i += 1

while j > 0 and arr[j] == arr[j - 1]:

j -= 1

if arr[0] == arr[-1]:

return max(j - i -1, 0)

else:

return max(min(n - i -1, j), 0)

So, the function first finds i as the largest index where arr[0..i] are all equal.

Then, finds j as the smallest index where arr[j..n-1] are all equal.

Then, if arr[0] == arr[-1], it returns max(j - i -1, 0), else max(min(n - i -1, j), 0).

Let's see how this works with the first sample:

arr = [1,2,3,4,5,1]

First, find i:

arr[0]=1, arr[1]=2 != arr[0], so i=0

Then, find j:

arr[5]=1, arr[4]=5 != arr[5], so j=5

Since arr[0] != arr[-1], it returns max(min(6 -0 -1,5),0) = max(min(5,5),0)=5

But the sample output is 4, so this doesn't match.

Wait, perhaps there's a mistake in the function.

Wait, in the function, it's j - i -1 when arr[0] == arr[-1], else min(n - i -1, j).

In the first sample, arr[0] != arr[-1], so it should return max(min(6-0-1,5),0)=max(min(5,5),0)=5, but the sample output is 4.

So, perhaps the function is incorrect.

Wait, maybe I misread the function.

Looking back, in the function, it's:

if arr[0] == arr[-1]:

return max(j - i -1, 0)

else:

return max(min(n - i -1, j), 0)

In the first sample:

i=0, j=5

arr[0]=1 != arr[-1]=1 ?? Wait, arr[-1]=1, so arr[0]==arr[-1]

So, it should return max(5 - 0 -1,0)=4, which matches the sample.

Wait, but in my earlier calculation, I thought arr[-1]=1, but arr[5]=1, so arr[0]==arr[-1].

So, it returns max(j - i -1,0)=4, which matches the sample.

Wait, but in my earlier step, I thought arr[-1]=1, but in the first sample, arr=[1,2,3,4,5,1], so arr[-1]=1.

So, arr[0]==arr[-1], so it returns j - i -1=5-0-1=4, which matches the sample output.

Okay, so in this case, it works.

Let's check the third sample:

arr = [8,8,8,1,2,8,8,8]

n=8

Find i:

arr[0]=8, arr