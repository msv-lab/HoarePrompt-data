Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform at most one operation where I select three integers i, j, and x, and set all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles. My goal is to make all elements of the array equal with the least amount of burles spent.

First, I need to understand what's being asked. I need to make all elements the same, and I can do this by possibly performing one operation where I set a range of elements to a certain value. If I don't perform any operation, that's fine too, but I can do at most one such operation.

Let me think about some examples to get a better grasp.

Example 1:

Input: [1, 2, 3, 4, 5, 1]

Output: 4

Explanation: By setting indices 1 to 4 to 8, we get [1,8,8,8,8,1]. Then, to make all elements equal, I can choose to set the entire array to 1, which would cost 6 burles, but that's not the minimal cost. Wait, but according to the sample input, the answer is 4. So maybe there's a smarter way.

Wait, perhaps the operation can be used to reduce the cost. Let's see.

If I set indices 2 to 5 to 1, the array becomes [1,1,1,1,1,1], which costs 4 burles. That seems to match the sample output.

So, in this case, performing one operation to set a range to a value that matches the ends of the array can minimize the cost.

Example 2:

Input: [1,1,1,1,1,1,1]

Output: 0

Explanation: All elements are already equal, so no operation is needed.

Example 3:

Input: [8,8,8,1,2,8,8,8]

Output: 2

Explanation: If I set indices 3 to 4 to 8, the array becomes [8,8,8,8,8,8,8,8], which costs 2 burles.

Seems like the strategy is to find the largest contiguous segments that are already equal and minimize the cost to make the rest equal to them.

Wait, but I can only perform one operation. So, I need to think differently.

Let me consider that I can set one range to a specific value, and the rest of the array remains as is, but I need to make sure that the entire array ends up with all elements equal.

So, I need to choose a value x, and a range i to j, set a[i..j] to x, and ensure that the entire array becomes equal to x.

Wait, but that's not quite right. Because after setting a[i..j] to x, the elements outside this range remain unchanged. So, for the entire array to be equal to x, the elements outside the range must already be equal to x.

So, I need to choose x such that the elements before i and after j are already equal to x, and then set the range i to j to x.

But, in the first example, [1,2,3,4,5,1], if I choose x=1, and set indices 1 to 4 to 1, the array becomes [1,1,1,1,1,1], which costs 4 burles.

Alternatively, if I choose x=1 and set indices 2 to 5 to 1, it's still 4 burles.

But, is there a way to do it with less cost?

Wait, what if I choose x=1 and set indices 1 to 3 to 1, making the array [1,1,1,4,5,1], and then set indices 3 to 4 to 1, but I can only perform one operation, so that's not allowed.

So, with only one operation, I need to find the minimal cost to make the entire array equal.

Another way to think about it is to find the maximum contiguous segment that is already equal to the desired value x, and then set the remaining parts to x with one operation.

But since I can only perform one operation, I need to maximize the segment that doesn't need changing.

So, the minimal cost would be the length of the array minus the maximum length of a contiguous segment that is equal to the desired value x.

But, I need to choose x optimally.

Wait, but I can choose x to be any value, not necessarily existing in the array.

Wait, but in the operation, x can be any integer, as per the problem statement.

So, I need to choose x such that the maximum contiguous segment with value x is as large as possible, and then the cost is the total length minus this maximum segment length.

But, I need to consider that after setting a range to x, the entire array should be equal to x.

So, it's not just about finding the largest contiguous segment that is equal to x, but ensuring that after setting one range to x, the entire array becomes x.

Wait, maybe I need to find the minimal cost by considering all possible choices of x and all possible ranges to set to x, such that after the operation, all elements are equal to x.

This seems complicated. Let's see if there's a smarter way.

Looking at the sample inputs:

First sample:

n=6

a=[1,2,3,4,5,1]

Output:4

As we saw, setting indices 1 to 4 to 1 costs 4, and the array becomes [1,1,1,1,1,1].

Alternatively, setting indices 2 to 5 to 1 also costs 4.

Second sample:

n=7

a=[1,1,1,1,1,1,1]

Output:0

No operation needed.

Third sample:

n=8

a=[8,8,8,1,2,8,8,8]

Output:2

By setting indices 3 to 4 to 8, costs 2, and the array becomes [8,8,8,8,8,8,8,8].

Fourth sample:

n=1

a=[1]

Output:0

No operation needed.

Fifth sample:

n=2

a=[1,2]

Output:1

If I set index 1 to 2, costs 1, array becomes [2,2].

Alternatively, set index 2 to 1, also costs 1, array becomes [1,1].

Sixth sample:

n=3

a=[1,2,3]

Output:2

Set index 1 to 2 and index 3 to 2, but I can only perform one operation. So, set indices 1 to 3 to 2, costs 3.

But the output is 2, which doesn't match. Wait, in the sample output, it's 2, but according to this, it should be 3.

Wait, maybe there's a mistake in my understanding.

Wait, no, looking back, in the sample input, for n=3, a=[1,2,3], output=2.

Wait, perhaps I misread the sample output. Let me check the sample input again.

Wait, in the sample input, for n=3, a=[1,2,3], output=2.

But according to my earlier logic, setting the entire array to 2 would cost 3, but the sample output is 2.

Wait, maybe there's a different approach.

Wait, perhaps I can set a range to a value that matches one of the existing elements.

Wait, for example, in [1,2,3], if I set indices 1 to 2 to 1, the array becomes [1,1,3], then set index 3 to 1, but I can only perform one operation.

Oh, wait, I can only perform one operation.

So, to get [1,1,1], I need to set indices 2 to 3 to 1, which costs 2.

Similarly, to get [2,2,2], set indices 1 to 1 and indices 3 to 3 to 2, but I can only do one operation, so setting indices 1 to 3 to 2 costs 3.

Similarly, to get [3,3,3], set indices 1 to 2 to 3 costs 2.

So, the minimal cost is 2.

Hence, the sample output is 2.

So, in this case, choosing to make all elements equal to 1 or 3 costs 2, while making them equal to 2 costs 3.

Hence, the minimal cost is 2.

So, the strategy is to choose the value x such that the cost to make the entire array equal to x is minimized, considering that I can set one range to x.

So, I need to choose x and a range to set to x such that the entire array becomes x with minimal cost.

Now, how to find this efficiently.

Let me think differently.

If I choose a value x, then I need to set all elements that are not equal to x to x.

But I can do this in one operation by setting a range to x.

So, I need to find the minimal cost to cover all elements that are not x with at most one operation.

Wait, but I can only perform one operation.

So, for each possible x, find the minimal cost to make the entire array equal to x with at most one operation.

Then, take the minimal among all x.

But iterating over all x is not efficient, since x can be any integer.

But in the problem statement, it's given that 1 ≤ a_i ≤ n, so x can be any integer, but probably choosing x to be one of the existing a_i minimizes the cost.

But I'm not sure.

Wait, in the first sample, choosing x=1 costs 4, choosing x=5 costs 5, choosing x=8 costs 6, but the minimal is 4.

Wait, but x doesn't have to be in the array.

Wait, but in the first sample, choosing x=1 costs 4, which is the minimal.

In the third sample, choosing x=8 costs 2.

In the sixth sample, choosing x=1 or x=3 costs 2, while choosing x=2 costs 3.

So, it seems that choosing x to be one of the existing values in the array gives the minimal cost.

Hence, perhaps I can consider only x being one of the existing values in the array.

This reduces the number of choices for x.

So, for each x in the set of unique values in the array, calculate the minimal cost to make the entire array equal to x with at most one operation.

Then, take the minimal among these costs.

Now, for a fixed x, how do I calculate the minimal cost to make the entire array equal to x with at most one operation?

I need to cover all elements that are not x with at most one operation.

So, find the minimal cost of setting a single range to x that covers all elements not equal to x.

This is equivalent to finding the minimal length of a range that covers all elements not equal to x.

Wait, no.

Actually, I need to set a range to x, and the elements outside this range remain as they are, which should already be equal to x.

So, for the entire array to be equal to x after one operation, the elements outside the chosen range must already be equal to x.

Hence, the range to set to x should cover all elements that are not equal to x.

So, the minimal cost is the minimal length of a range that covers all elements not equal to x.

Hence, for a given x, find the minimal j - i + 1 such that all elements not equal to x are within the range i to j.

Then, the cost is j - i + 1.

Then, the minimal cost for this x is this minimal length.

Then, the overall minimal cost is the minimal over all x of these minimal lengths.

This seems correct.

Let me verify with the sixth sample.

n=3

a=[1,2,3]

Choose x=1:

The elements not equal to 1 are at positions 2 and 3.

So, set i=2, j=3, x=1, cost=2.

Similarly, choose x=3:

Set i=1, j=2, x=3, cost=2.

Choose x=2:

Set i=1, j=3, x=2, cost=3.

Hence, the minimal cost is 2.

Matches the sample output.

Another sample:

n=2

a=[1,2]

Choose x=1:

Set i=2, j=2, x=1, cost=1.

Choose x=2:

Set i=1, j=1, x=2, cost=1.

Hence, minimal cost is 1.

Matches the sample output.

Another sample:

n=1

a=[1]

No operation needed, cost=0.

Correct.

Hence, this approach seems correct.

So, the algorithm is:

- Find all unique values in the array.

- For each unique value x:

- Find all positions where a[i] != x.

- Find the minimal range [i,j] that covers all these positions.

- The cost is j - i + 1.

- If there are no positions where a[i] != x, then cost is 0.

- Take the minimal cost among all x.

Now, to implement this efficiently, since n can be up to 2e5, and t up to 1e4, with total n across all test cases up to 2e5, I need an efficient implementation.

So, for each test case, with n up to 2e5, and t up to 1e4, but total n across all test cases up to 2e5, I need an O(n) per test case solution.

So, for each x, finding the minimal range that covers all positions where a[i] != x can be done efficiently.

Here's how:

- For each x, collect all positions where a[i] != x.

- If there are no such positions, cost is 0.

- Else, the minimal range is from the minimum position to the maximum position among these positions.

- Hence, cost is max_pos - min_pos + 1.

This is very efficient, O(n) per test case.

Let me verify this with the sixth sample.

a=[1,2,3]

Unique x:1,2,3

For x=1:

Positions where a[i]!=1: positions 2 and 3.

min_pos=2, max_pos=3, cost=3-2+1=2.

For x=2:

Positions where a[i]!=2: positions 1 and 3.

min_pos=1, max_pos=3, cost=3-1+1=3.

For x=3:

Positions where a[i]!=3: positions 1 and 2.

min_pos=1, max_pos=2, cost=2-1+1=2.

Hence, minimal cost is 2.

Correct.

Another test:

n=4

a=[1,2,2,1]

Unique x:1,2

For x=1:

Positions where a[i]!=1: positions 2 and 3.

min_pos=2, max_pos=3, cost=2.

For x=2:

Positions where a[i]!=2: positions 1 and 4.

min_pos=1, max_pos=4, cost=4.

Hence, minimal cost is 2.

Which means setting indices 2 to 3 to 1, making the array [1,1,1,1].

Yes, that costs 2, which is minimal.

Correct.

Another test:

n=5

a=[1,1,2,1,1]

Unique x:1,2

For x=1:

Positions where a[i]!=1: position 3.

min_pos=3, max_pos=3, cost=1.

For x=2:

Positions where a[i]!=2: positions 1,2,4,5.

min_pos=1, max_pos=5, cost=5.

Hence, minimal cost is 1.

Which means setting index 3 to 1, making the array [1,1,1,1,1].

Yes, costs 1, which is minimal.

Correct.

Hence, this approach seems correct.

Now, looking at the given program:

def func():

for _ in range(int(input())):

n = int(input())

a = list(map(int, input().split()))

(l, r) = (0, n - 1)

(st, end) = (0, 0)

while l < r and a[l] == a[l + 1]:

l += 1

st += 1

while r > l and a[r] == a[r - 1]:

r -= 1

end += 1

if a[0] == a[-1]:

ans = r - l - 1

elif st == 0 and end == 0 and (a[0] != a[-1]):

ans = len(a) - 1

else:

ans = r - l

print(max(0, ans))

I need to analyze this program and see if it implements the correct logic.

First, it reads the number of test cases t.

Then, for each test case:

- Reads n and the array a.

- Initializes l=0, r=n-1.

- Initializes st=0, end=0.

- Then, it has two while loops:

- First while loop: while l < r and a[l] == a[l+1], increment l and st.

- Second while loop: while r > l and a[r] == a[r-1], decrement r and increment end.

- Then, it has an if-elif-else structure:

- If a[0] == a[-1], then ans = r - l - 1

- Elif st == 0 and end == 0 and a[0] != a[-1], then ans = len(a) - 1

- Else, ans = r - l

- Finally, print max(0, ans)

Let's see what this code is doing.

It seems to be trying to find some range [l, r] where the ends of the array are equal, and then compute the minimal cost based on that.

But, compared to my earlier approach, this seems different and not directly implementing the logic I thought of.

Let me try to understand this code with the first sample input.

First sample:

n=6

a=[1,2,3,4,5,1]

So, l=0, r=5

a[0]=1, a[1]=2 → a[0] != a[1], so first while loop doesn't increment l or st.

Second while loop: a[5]=1, a[4]=5 → a[5] != a[4], so doesn't decrement r or increment end.

Then, since a[0] != a[-1], checks elif: st==0 and end==0 and a[0]!=a[-1], which is true, so ans = 6 - 1 = 5

But the sample output is 4, but according to this code, it would output 5, which is incorrect.

Wait, but in the sample input, it's 4, but according to this code, it's 5.

Hence, this code is wrong for this input.

Wait, maybe I misread the code.

Let me check again.

In the first while loop:

while l < r and a[l] == a[l+1]:

l += 1

st += 1

In the first sample, a[0]=1, a[1]=2, which are not equal, so l and st remain 0.

Second while loop:

while r > l and a[r] == a[r-1]:

r -= 1

end += 1

a[5]=1, a[4]=5, which are not equal, so r and end remain 5 and 0.

Then, since a[0] != a[-1], and st==0 and end==0, it falls into the elif clause and sets ans = len(a) - 1 = 5

But the correct answer is 4, not 5.

Hence, this code is incorrect for this input.

Therefore, the given program is incorrect.

Hence, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]