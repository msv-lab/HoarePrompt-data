Alright, I have this problem to solve. It involves a game between Alice and Bob on an array, and I need to determine the final score based on their optimal plays. Let's break down the problem step by step.

First, understanding the game mechanics:

1. There's an array `a` of size `n`, and Alice starts with an empty array `c`.

2. Players take turns, with Alice going first.

3. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

4. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`.

5. The game ends when `a` is empty, and the score is the MEX of `c`. Alice wants to maximize the MEX, while Bob wants to minimize it.

MEX is the smallest non-negative integer not present in the array. For example:

- MEX of [2,2,1] is 0.

- MEX of [3,1,0,1] is 2.

- MEX of [0,3,1,2] is 4.

Given that, I need to find the final MEX when both players play optimally.

Let's consider the example provided:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

In the first test case:

- n=4, a=[0,0,1,1]

- A possible game:

- Alice picks 1 → a=[0,0,1], c=[1]

- Bob picks 0 → a=[0,1], c=[1]

- Alice picks 0 → a=[1], c=[1,0]

- Bob picks 1 → a=[], c=[1,0]

- MEX of c=[1,0] is 2.

But is this the optimal outcome for both players?

Alice wants to maximize MEX, Bob wants to minimize it.

I need to think about how Alice and Bob will play optimally.

Let's think about the MEX concept. The MEX is the smallest missing integer in the array.

So, to maximize MEX, Alice wants to have as many small integers as possible in `c`, especially the smallest missing one.

Bob, wanting to minimize MEX, would try to prevent Alice from getting certain numbers.

Given that Bob can remove elements from `a` without adding them to `c`, he can potentially remove elements that Alice might want to pick.

But Alice gets to choose elements to add to `c`, while Bob just removes elements.

The total number of turns is `n`, with Alice and Bob alternating, starting with Alice.

The number of elements Alice can add to `c` is ceil(n/2), since she goes first.

Wait, no. Actually, since Alice picks first and they alternate, the number of turns Alice has is ceil(n/2), and Bob has floor(n/2).

In the first test case, n=4:

- Alice's turns: 1 and 3

- Bob's turns: 2 and 4

As in the example:

- Turn 1 (Alice): picks 1 → c=[1]

- Turn 2 (Bob): picks 0 → a=[0,1], c=[1]

- Turn 3 (Alice): picks 0 → c=[1,0]

- Turn 4 (Bob): picks 1 → a=[], c=[1,0]

MEX is 2.

Is this the optimal outcome?

Could Alice have achieved a higher MEX?

Suppose Alice picks differently:

- Turn 1: picks 0 → c=[0]

- Turn 2: Bob picks 0 → a=[1,1], c=[0]

- Turn 3: Alice picks 1 → c=[0,1]

- Turn 4: Bob picks 1 → a=[], c=[0,1]

MEX is 2 again.

Another scenario:

- Turn 1: Alice picks 1 → c=[1]

- Turn 2: Bob picks 1 → a=[0,0], c=[1]

- Turn 3: Alice picks 0 → c=[1,0]

- Turn 4: Bob picks 0 → a=[], c=[1,0]

MEX is 2.

Seems like regardless of their choices, c ends up with [0,1], MEX=2.

Wait, but Bob could have picked differently.

Wait, no, in the first turn, Alice picks 1, then Bob picks 0, etc.

But in any case, c ends up with two elements: 0 and 1, so MEX is 2.

So, in this case, the MEX is 2.

In the second test case:

n=4, a=[0,1,2,3]

- Alice wants to maximize MEX, Bob wants to minimize it.

Possible game:

- Turn 1: Alice picks 0 → c=[0]

- Turn 2: Bob picks 1 → a=[2,3], c=[0]

- Turn 3: Alice picks 2 → c=[0,2]

- Turn 4: Bob picks 3 → a=[], c=[0,2]

MEX is 1, since 1 is missing.

Another possible game:

- Turn 1: Alice picks 1 → c=[1]

- Turn 2: Bob picks 0 → a=[2,3], c=[1]

- Turn 3: Alice picks 2 → c=[1,2]

- Turn 4: Bob picks 3 → a=[], c=[1,2]

MEX is 0, since 0 is missing.

Wait, but according to the sample output, it's 1.

Wait, maybe I miscounted.

Wait, n=4, a=[0,1,2,3], and output is 1.

Wait, in the first scenario, c=[0,2], MEX=1.

In the second scenario, c=[1,2], MEX=0.

So, the optimal play should lead to MEX=1.

How can Alice maximize MEX, and Bob minimize it?

Alice needs to ensure that smaller numbers are included in c, while Bob tries to prevent it.

In this case, perhaps Alice can pick 0 and 2, leading to MEX=1.

Bob can try to minimize by picking elements that help Alice less.

So, the optimal MEX is 1.

In the third test case:

n=2, a=[1,1]

- Turn 1: Alice picks 1 → c=[1]

- Turn 2: Bob picks 1 → a=[], c=[1]

MEX is 0, since 0 is missing.

Another possibility:

- Turn 1: Alice picks 1 → c=[1]

- Turn 2: Bob picks 1 → a=[], c=[1]

Same result.

So, MEX is 0.

From these examples, it seems like the game's score is determined by the elements Alice manages to include in c, given that Bob is trying to hinder her.

I need to find a general strategy for both players.

Let's think about the problem more abstractly.

The game is about selecting elements to include in c, with Alice trying to maximize the MEX and Bob trying to minimize it.

Since MEX is the smallest missing non-negative integer in c, Alice wants to have as many small integers in c as possible, while Bob wants to prevent that.

Given that Alice can choose which elements to include in c, and Bob can remove elements, including those that Alice might want.

But Bob doesn't add anything to c; he only removes elements from a.

So, Bob can remove elements that Alice might want to include in c.

Given that, Alice needs to select elements strategically to maximize the MEX, considering that Bob will remove some elements, possibly those that Alice wants.

Wait, but Bob can remove any element, not necessarily those that Alice wants.

But since Bob's goal is to minimize the MEX, he would want to prevent Alice from having small integers in c.

So, Bob might remove small integers to make them unavailable for Alice.

Wait, but if Bob removes an element, it's removed from a, so Alice can't pick it later.

So, Bob can choose to remove elements that Alice might need to achieve a higher MEX.

Alice, knowing this, needs to select elements in a way that maximizes the MEX despite Bob's removals.

This seems like a combinatorial game theory problem, where both players make optimal moves.

I need to find the optimal MEX that Alice can achieve against Bob's opposition.

Let's consider that Alice has ceil(n/2) moves to pick elements for c, since she starts and they alternate.

But it's not just about the number of moves; it's about which elements she picks and which elements Bob removes.

I need to think differently.

Perhaps I can think in terms of availability of elements at each step.

But that seems too vague.

Let me consider the frequency of each number in a.

Since a contains elements between 0 and n-1, and frequencies can vary.

Let's look at the first test case:

n=4, a=[0,0,1,1]

Frequency:

0:2, 1:2

Alice can pick two elements, and Bob can pick two elements.

Alice needs to have 0 and 1 in c to achieve MEX=2.

In this case, since there are two of each, Alice can ensure that she picks one 0 and one 1, achieving MEX=2.

In the second test case:

n=4, a=[0,1,2,3]

Frequency:

0:1, 1:1, 2:1, 3:1

Alice can pick two elements, Bob picks two elements.

Alice needs to have 0 and 1 in c to achieve MEX=2.

But Bob can remove one element, and since he wants to minimize MEX, he would try to prevent Alice from having both 0 and 1.

If Alice picks 0 first, Bob can pick 1, then Alice picks 2, Bob picks 3, resulting in c=[0,2], MEX=1.

Alternatively, if Alice picks 1, Bob picks 0, Alice picks 2, Bob picks 3, c=[1,2], MEX=0.

So, in this case, the optimal MEX is 1.

Wait, but according to the sample output, it's 1.

But in one scenario, MEX is 0.

Wait, perhaps I miscounted the turns.

Wait, n=4, Alice has two turns, Bob has two turns.

Scenario 1:

- Alice picks 0 → c=[0]

- Bob picks 1 → a=[2,3]

- Alice picks 2 → c=[0,2]

- Bob picks 3 → a=[]

MEX is 1.

Scenario 2:

- Alice picks 1 → c=[1]

- Bob picks 0 → a=[2,3]

- Alice picks 2 → c=[1,2]

- Bob picks 3 → a=[]

MEX is 0.

So, in the second scenario, MEX is 0.

But according to the sample output, it's 1.

So, perhaps the optimal play leads to MEX=1.

Wait, maybe I need to consider that Alice can choose which elements to pick to maximize MEX, and Bob will try to minimize it.

So, in the first scenario, MEX=1, in the second, MEX=0.

So, the minimal possible MEX is 0, but perhaps there's a way for Alice to ensure MEX=1.

Wait, perhaps I need to think in terms of the minimal MEX that Alice can achieve despite Bob's efforts.

Wait, no, Alice wants to maximize MEX, Bob wants to minimize it.

So, the final MEX is the result of both playing optimally.

In this case, it's 1.

I need a better approach to generalize this.

Let me think about the frequency of each number.

Suppose we have frequencies of numbers from 0 to n-1.

Alice wants to include as many small numbers as possible in c.

Bob wants to prevent that by removing elements.

Alice gets ceil(n/2) picks, Bob gets floor(n/2) picks.

But it's not just about the number of picks; it's about which elements are picked and removed.

Wait, perhaps I can think in terms of who has control over which elements.

But that seems complicated.

Let me consider that Alice can select elements to include in c, and Bob can remove elements, including those that Alice might want.

I need to find a way to determine the minimal MEX that Alice can achieve.

Wait, perhaps I should think in terms of the availability of numbers.

For each number i from 0 to n, check if Alice can ensure that i is in c, or that i is not in c, depending on the MEX definition.

But that seems too vague.

Let me consider the following approach:

- For each number i from 0 to n, determine if Alice can include i in c, given Bob's opposition.

- Find the smallest i for which Alice cannot ensure that i is in c.

That would be the MEX.

Wait, that might be a way.

So, for each i, check if Alice can include i in c.

If there exists an i that Alice cannot include in c, then that i is the MEX.

But I need to formalize this.

Let's consider that for each i, if the frequency of i is greater than the number of times Bob can remove it, then Alice can include i in c.

Wait, perhaps.

Let me think.

Bob can remove floor(n/2) elements.

Alice can pick ceil(n/2) elements.

But Bob can choose to remove elements that Alice wants.

So, if the frequency of i is f_i, and Bob can remove up to floor(n/2) elements, then if f_i > floor(n/2), Alice can ensure that at least one i is left to pick.

Wait, but Alice needs to pick it before Bob removes it.

This seems tricky.

Maybe I need to think differently.

Let me consider that Alice can choose to pick elements that she wants, and Bob can remove elements that he wants.

Alice's goal is to include certain elements in c to maximize MEX, while Bob tries to minimize it.

I need to find a way to determine the minimal MEX that Alice can achieve.

Perhaps I can think in terms of the number of times each element appears and how many times Bob can remove them.

Wait, perhaps I can consider that for each i, if the frequency of i is greater than the number of times Bob can remove it, then Alice can include i in c.

Given that Bob can remove floor(n/2) elements, if f_i > floor(n/2), then Alice can include i in c.

But this seems too simplistic.

Wait, for example, in the first test case:

n=4, a=[0,0,1,1]

floor(n/2)=2

For i=0, f_i=2 > 2? No, f_i=2 <= 2.

For i=1, f_i=2 > 2? No.

So, according to this, Alice cannot ensure that 0 or 1 are in c.

But in reality, she can include both 0 and 1 in c.

So, this approach is incorrect.

Wait, maybe I need to consider that Alice has ceil(n/2) picks.

So, if f_i > ceil(n/2), then Alice can include i in c.

But in the first test case, ceil(n/2)=2, f_i=2 >= ceil(n/2), so Alice can include i in c.

Wait, but in the second test case, ceil(n/2)=2, f_i=1 < 2, so Alice cannot include i in c.

But in the second test case, with n=4 and a=[0,1,2,3], f_i=1 for each i.

According to this, Alice cannot include any i in c, but that's not the case.

In reality, she can include two elements in c.

So, this approach is flawed.

I need a different strategy.

Let me consider that Alice can include up to ceil(n/2) elements in c.

She wants to include the smallest possible integers to maximize the MEX.

Bob wants to minimize the MEX by preventing Alice from including certain small integers.

So, perhaps I can iterate through the numbers starting from 0 and check if Alice can include that number in c.

If she can, then that number should be in c, and MEX is the first number that she cannot include.

Wait, but MEX is the smallest missing number in c.

So, if Alice can include 0,1,2,...,k-1 in c, but cannot include k, then MEX is k.

That could be a way to think about it.

So, I need to find the smallest k such that Alice cannot include k in c, given Bob's opposition.

To determine if Alice can include a particular number k in c, I need to see if, after Bob's removals, Alice can pick k.

But this is still vague.

Let me consider the frequency of k.

If the frequency of k is greater than the number of times Bob can remove it, then Alice can include k in c.

Given that Bob can remove floor(n/2) elements, if frequency of k > floor(n/2), then Alice can include k.

Wait, in the first test case, n=4, floor(n/2)=2, f_0=2, f_1=2.

According to this, Alice can include both 0 and 1, so MEX=2.

In the second test case, n=4, floor(n/2)=2, f_0=1, f_1=1, f_2=1, f_3=1.

According to this, Alice cannot include any of them, so MEX=0.

But in the sample output, it's 1.

So, this approach is incorrect.

Wait, perhaps I need to consider that if the frequency of k is greater than the number of times Bob can remove it before Alice can pick it.

Wait, maybe I need to think in terms of the number of times Bob can remove elements before Alice can pick k.

But this seems too convoluted.

Let me try to think differently.

Suppose I sort the unique elements of a and see which ones Alice can include in c.

But sorting might not help directly.

Wait, perhaps I can iterate through the possible MEX values.

Start with MEX=0, check if Alice can ensure that 0 is in c.

If yes, then MEX is not 0, check for MEX=1, and so on.

Find the smallest MEX where Alice cannot ensure that MEX is in c.

To check if Alice can ensure that a particular number k is in c, I need to see if, despite Bob's removals, Alice can pick k.

Given that Bob can remove floor(n/2) elements, and Alice picks ceil(n/2) elements.

If the frequency of k is greater than floor(n/2), then Alice can pick k, because even if Bob removes floor(n/2) elements, at least one k remains for Alice to pick.

Wait, but in the second test case, n=4, floor(n/2)=2, f_0=1, which is not greater than 2, so according to this, Alice cannot include 0 in c.

But in reality, she can include 0 and another element, so MEX=1.

So, this approach is still not accurate.

Wait, maybe I need to consider the total number of elements Alice can pick.

Alice can pick ceil(n/2) elements.

So, if the sum of frequencies of the numbers from 0 to k is greater than the number of elements Bob can remove, then Alice can include all numbers from 0 to k in c.

Wait, perhaps.

Let me formalize this.

Let's define that to have MEX = k, Alice needs to include all numbers from 0 to k-1 in c.

So, for each k, from 0 to n, check if Alice can include all numbers from 0 to k-1 in c, given Bob's removals.

If she can, then MEX is at least k, and check for k+1.

If she cannot, then MEX is k.

So, I need to find the smallest k such that Alice cannot include all numbers from 0 to k-1 in c.

To check if Alice can include all numbers from 0 to k-1 in c, I need to see if the sum of frequencies of these numbers minus the number of elements Bob can remove is greater than or equal to the number of unique numbers she needs to include.

Wait, perhaps.

Let me try.

Let’s define:

- Let s = sum of frequencies of numbers from 0 to k-1.

- Bob can remove floor(n/2) elements.

- Alice needs to include all unique numbers from 0 to k-1 in c.

- Let u = number of unique numbers from 0 to k-1.

- Then, if s - floor(n/2) >= u, Alice can include all u numbers in c.

Because even after Bob removes floor(n/2) elements, there are still enough elements left for Alice to pick.

Wait, but frequencies can be greater than 1.

So, if a number has frequency greater than what Bob can remove, Alice can pick it.

But if a number has frequency <= floor(n/2), Bob can potentially remove all occurrences of that number, preventing Alice from picking it.

So, for each number from 0 to k-1, if its frequency > floor(n/2), Alice can include it in c.

If its frequency <= floor(n/2), Bob can remove all its occurrences, preventing Alice from including it.

Therefore, for Alice to include all numbers from 0 to k-1 in c, for each number in that range, its frequency must be > floor(n/2).

Wait, is that right?

Wait, if a number has frequency > floor(n/2), Alice can always include it, because even if Bob removes floor(n/2) elements, at least one remains for Alice to pick.

If a number has frequency <= floor(n/2), Bob can potentially remove all its occurrences before Alice can pick it.

Therefore, for Alice to include a number in c, its frequency must be > floor(n/2