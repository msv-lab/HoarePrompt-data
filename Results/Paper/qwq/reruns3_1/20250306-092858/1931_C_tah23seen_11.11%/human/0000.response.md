Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation lets me select three integers: i, j, and x, where 1 ≤ i ≤ j ≤ n, and set all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is basically the number of elements I'm changing.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I need to spend to achieve that. It's guaranteed that it can always be done, so I don't have to worry about cases where it's impossible.

First, I need to understand what the operation allows me to do. I can select a subarray from i to j and set all its elements to x, and this costs me the length of the subarray in burles. I can do this operation at most once.

So, if I do nothing, meaning I perform zero operations, some arrays might already be all equal, in which case the cost is zero. For other arrays, I need to perform one operation to make all elements equal.

Wait, but I can perform at most one operation. Does that mean I can choose to perform zero or one operation?

Actually, the problem says "no more than once," so yes, zero or one operation.

Okay, so for each test case, I need to determine the minimal cost to make all elements equal, possibly by doing one operation, or zero if the array is already uniform.

Looking at the examples:

First test case:

6

1 2 3 4 5 1

Output: 4

Presumably, I can set indices 2 to 5 to 1, making the array [1,1,1,1,1,1], and the cost is 4 burles.

Second test case:

7

1 1 1 1 1 1 1

Output: 0

Already all elements are equal, so no operation needed.

Third test case:

8

8 8 8 1 2 8 8 8

Output: 2

Maybe set indices 4 and 5 to 8, costing 2 burles, making the array [8,8,8,8,8,8,8,8]

Fourth test case:

1

1

Output: 0

Only one element, already equal.

Fifth test case:

2

1 2

Output: 1

Set either element to match the other, costing 1 burle.

Sixth test case:

3

1 2 3

Output: 2

Set either the first two to 3, or the last two to 1, or the first and last to 2, etc., but the minimal cost is 2.

Seventh test case:

7

4 3 2 7 1 1 3

Output: 6

Not sure, maybe set indices 1 to 6 to 3, making [3,3,3,3,3,3,3], costing 6 burles.

Eighth test case:

9

9 9 2 9 2 5 5 5 3

Output: 7

Possibly set indices 3 to 9 to 9, making [9,9,9,9,9,9,9,9,9], costing 7 burles.

From these examples, it seems that the minimal cost is equal to the length of the smallest subarray that needs to be modified to make the entire array equal to some value.

Wait, but in the third test case, setting indices 4 and 5 to 8 costs 2, and the array becomes all 8's. But if I set indices 4 to 6 to 8, that would cost 3 burles, which is more expensive.

So, it's about finding the smallest subarray to modify such that the remaining elements are all equal to the value I'm setting the subarray to.

Wait, maybe it's about finding the largest subarray that is already equal to the final value I choose, and then modifying the rest.

Let me think differently.

Suppose I choose to make the entire array equal to some value x. Then, I need to change all elements that are not x to x. If I can perform one operation, I can set a contiguous subarray to x, and the rest will remain as they are.

Wait, no. If I set a subarray to x, the elements outside that subarray remain unchanged. So, to make the entire array equal to x, I need to set all elements that are not x to x in one operation.

So, I need to choose a subarray such that, after setting it to x, all elements in the array are x.

That means, outside of this subarray, all elements should already be x.

So, in other words, all elements outside the chosen subarray must already be x.

Therefore, to choose the subarray to set to x, I need to select the subarray that covers all the elements that are not equal to x.

So, for a given x, the minimal subarray to set is the subarray that includes all non-x elements.

Therefore, for each x, the cost is the length of the subarray from the first non-x to the last non-x.

Then, the minimal cost is the minimum over all possible x of the length from the first non-x to the last non-x.

Wait, but x has to be equal to some x that I choose.

Wait, no, x can be any integer, but in the problem, a_i are integers between 1 and n, so x should be chosen from these values.

Wait, no, x can be any integer, but since a_i are between 1 and n, it's sufficient to consider x in 1 to n, because other values aren't present in the array.

But, if I choose x not in the array, then I would need to set the entire array to x, because none of the elements are equal to x, so the subarray to set is the entire array.

But that would cost n burles.

But it's always better to choose x present in the array, because then I only need to set the subarray that covers the non-x elements.

So, the minimal cost is the minimal, over all x in the array, of the length from the first non-x element to the last non-x element.

And if all elements are already x, then the cost is zero.

So, to compute this, for each possible x, find the subarray from the first non-x to the last non-x, and compute its length.

Then, take the minimum over all x.

But n can be up to 2e5 per test case, and t up to 1e4, but the total n over all test cases is up to 2e5, so it's feasible.

So, in code, for each test case, I can iterate through all possible x, which are the unique values in the array, and for each x, find the first and last occurrence of a non-x element, and compute the length.

But to optimize, I can iterate through the array once and find the first and last indices where a[i] != x, for each x.

But that would require keeping track for each x, the positions where a[i] != x.

Alternatively, a better way is to find, for each x, the first index where a[i] != x, and the last index where a[j] != x.

Then, the cost is j - i + 1.

If there are no such i and j, meaning all a[k] == x, then cost is zero.

So, to implement this efficiently, I can:

- Find all unique values in the array.

- For each unique value x, find the first index where a[i] != x, and the last index where a[j] != x.

- Compute j - i + 1, and take the minimum over all x.

- If all elements are equal to some x, then j - i + 1 will be -1 (since i > j), so the cost is zero.

Wait, in Python, if I try to find the first index where a[i] != x and there is no such i, then i would be len(a), and j would be len(a) - 1 or something, but I need to handle the case where all elements are equal to x.

So, I need to handle that carefully.

Alternatively, I can think of it as finding the minimal length of the subarray that covers all positions where a[i] != x, for some x.

To optimize, I can consider that the array can be made uniform by choosing x as the most frequent value, and then setting the subarray from the first non-x to the last non-x to x.

But actually, it's better to choose x such that the subarray to set is minimized.

Wait, perhaps choosing x as the most frequent value minimizes the subarray to set, but is that necessarily the case?

Wait, no. For example, if x is the most frequent value, but the non-x elements are spread out, then the subarray to set is longer.

Alternatively, if x is a less frequent value, but all non-x elements are concentrated in a small subarray, then the cost is lower.

So, it's not necessarily the most frequent value that gives the minimal cost.

Therefore, I need to consider all possible x and find the one that minimizes the length of the subarray to set.

Given that n can be up to 2e5 and t up to 1e4, but the total n over all test cases is up to 2e5, I need an efficient solution.

So, in code, I can:

- For each test case:

- Read n and the array a.

- Find all unique values in a.

- For each unique x, find the first index where a[i] != x and the last index where a[j] != x.

- If no such i and j exist, meaning all a[k] == x, then cost is 0.

- Else, cost is j - i + 1.

- Take the minimum cost over all x.

But this seems O(n * number of unique x), which in the worst case is O(n^2), but n is up to 2e5, which is too slow.

Wait, but the number of unique x is up to n, which is up to 2e5, so total time over all test cases could be up to 2e5 * 2e5 = 4e10 operations, which is way too slow.

Wait, but the problem says that the sum of n over all test cases does not exceed 2e5, so if I can process each test case in O(n), that should be acceptable.

So, I need a way to compute the minimal subarray length to set, over all possible x, in O(n) time per test case.

Is there a smarter way to do this?

Let me think differently.

Suppose I choose to make all elements equal to the most frequent element in the array.

Then, I need to set all other elements to that value in one operation.

The subarray to set would be from the first occurrence of a non-most_frequent_element to the last occurrence of a non-most_frequent_element.

The cost would be last - first + 1.

But as I saw earlier, this may not necessarily give the minimal cost, because there might be some x with fewer but more spread out non-x elements.

Wait, but perhaps choosing the most frequent x is not always optimal.

Looking back at the third test case:

8

8 8 8 1 2 8 8 8

Unique x values: 8,1,2

For x=8:

All non-8 elements are at positions 4 and 5.

So, set from 4 to 5, cost=2.

For x=1:

Non-1 elements are at positions 1-3 and 5-8, so set from 1 to 8, cost=8.

For x=2:

Non-2 elements are at positions 1-4 and 6-8, so set from 1 to 8, cost=8.

So, minimal cost is 2, achieved by choosing x=8.

This seems consistent.

Another test case:

2

1 2

Unique x:1,2

For x=1: set index 2, cost=1.

For x=2: set index 1, cost=1.

Minimal cost is 1.

Another test case:

3

1 2 3

Unique x:1,2,3

For x=1: set indices 2-3, cost=2.

For x=2: set indices 1 and 3, cost=2.

For x=3: set indices 1-2, cost=2.

Minimal cost is 2.

Seems correct.

Wait, but in the third test case, if I choose x=8, cost=2, which is better than choosing x=1 or x=2, which would cost 8.

Wait, no, the output is 2, which is correct.

Wait, in the second test case, all elements are 1, so choosing x=1, no need to set any subarray, cost=0.

In the fifth test case, 1 and 2, choosing x=1 or x=2, set one element, cost=1.

In the sixth test case, 1,2,3, choosing any x, set two elements, cost=2.

Seems consistent.

So, perhaps choosing the most frequent x is not always optimal, but in practice, it seems to work.

Wait, but in the third test case, choosing x=8, which is the most frequent value, gives the minimal cost.

In the fifth test case, choosing x=1 or x=2, both are equally frequent, and cost is 1.

In the sixth test case, all x have frequency 1, so cost is 2.

Seems okay.

But is there a case where choosing a less frequent x gives a better cost?

Let me think of an example.

Suppose the array is [1,2,1,2,1], n=5.

Unique x:1,2.

Choosing x=1 (frequency 3):

Non-1 elements at positions 2 and 4.

Set from 2 to 4, cost=3.

Choosing x=2 (frequency 2):

Non-2 elements at positions 1,3,5.

Set from 1 to 5, cost=5.

So, minimal cost is 3.

But is there a better way?

No, because I can only perform one operation, and I need to set all elements to be equal to x, so I have to cover all non-x elements in one subarray.

So, in this case, choosing x=1 is better than x=2.

Another example:

[1,2,3,2,1], n=5.

Unique x:1,2,3.

Choosing x=1: non-1 elements at positions 2,3,4.

Set from 2 to 4, cost=3.

Choosing x=2: non-2 elements at positions 1,3,5.

Set from 1 to 5, cost=5.

Choosing x=3: non-3 elements at positions 1,2,4,5.

Set from 1 to 5, cost=5.

Minimal cost is 3.

Again, choosing the most frequent x (x=1, frequency 2) gives the minimal cost.

Another example:

[1,1,2,2,3,3], n=6.

Unique x:1,2,3.

Choosing x=1: non-1 elements at positions 3,4,5,6.

Set from 3 to 6, cost=4.

Choosing x=2: non-2 elements at positions 1,2,5,6.

Set from 1 to 6, cost=6.

Choosing x=3: non-3 elements at positions 1,2,3,4.

Set from 1 to 4, cost=4.

Minimal cost is 4.

But, if I choose to set from positions 3 to 6 to 1, cost=4.

Alternatively, set positions 1 to 4 to 3, cost=4.

But is there a better way?

No, because I have to set at least these subarrays.

Wait, but in this case, choosing x=1 or x=3 both give cost=4.

Is there a way to do it cheaper?

No, because non-x elements are spread out.

Wait, but perhaps choosing x=2 is worse, as shown.

So, in this case, choosing x=1 or x=3 is better.

So, in general, choosing x as one of the most frequent values seems to give the minimal cost.

But is it always the case?

Let me think of a case where choosing a less frequent x gives a better cost.

Suppose the array is [1,2,1,3,1], n=5.

Unique x:1,2,3.

Choosing x=1 (frequency 3):

Non-1 elements at positions 2 and 4.

Set from 2 to 4, cost=3.

Choosing x=2 (frequency 1):

Non-2 elements at positions 1,3,4,5.

Set from 1 to 5, cost=5.

Choosing x=3 (frequency 1):

Non-3 elements at positions 1,2,3,5.

Set from 1 to 5, cost=5.

Minimal cost is 3.

Again, choosing the most frequent x gives the minimal cost.

Another example:

[1,2,3,4,5], n=5.

Unique x:1,2,3,4,5.

Choosing any x, frequency=1.

Non-x elements are positions 1 to 5 except the chosen x's position.

So, set from 1 to 5 except one position, cost=4.

But wait, if I choose x=1, non-x elements are positions 2 to 5, cost=4.

Similarly for x=2: positions 1,3,4,5, cost=4.

And so on.

So, minimal cost is 4.

But is there a better way?

No, because I can only set one subarray to x, and to make all elements equal to x, I need to cover all non-x elements in that subarray.

So, the minimal cost is indeed 4.

So, in this case, choosing any x gives the same cost.

But is there a case where choosing a less frequent x gives a better cost?

Let me try:

Array: [1,2,1,2,3], n=5.

Unique x:1,2,3.

Choosing x=1 (frequency 2):

Non-1 elements at positions 2,4,5.

Set from 2 to 5, cost=4.

Choosing x=2 (frequency 2):

Non-2 elements at positions 1,3,5.

Set from 1 to 5, cost=5.

Choosing x=3 (frequency 1):

Non-3 elements at positions 1,2,3,4.

Set from 1 to 4, cost=4.

Minimal cost is 4.

Again, choosing x=1 or x=3 gives better cost than x=2.

Is there a case where choosing a less frequent x gives a better cost?

Let's try:

Array: [1,2,2,1], n=4.

Unique x:1,2.

Choosing x=1 (frequency 2):

Non-1 elements at positions 2 and 3.

Set from 2 to 3, cost=2.

Choosing x=2 (frequency 2):

Non-2 elements at positions 1 and 4.

Set from 1 to 4, cost=4.

Minimal cost is 2.

So, choosing the most frequent x gives the better cost.

Wait, both x=1 and x=2 have the same frequency, but choosing x=1 gives a better cost.

So, in this case, choosing x=1 is better.

Another example:

Array: [1,2,3,2,1], as before, minimal cost is 3.

No better.

I'm not finding a case where choosing a less frequent x gives a better cost.

Maybe it's always optimal to choose x as one of the most frequent values.

Let me see.

Suppose the array is [1,1,1,2,2,2], n=6.

Unique x:1,2.

Choosing x=1 (frequency 3):

Non-1 elements at positions 4,5,6.

Set from 4 to 6, cost=3.

Choosing x=2 (frequency 3):

Non-2 elements at positions 1,2,3.

Set from 1 to 3, cost=3.

So, minimal cost is 3.

No difference.

Another example:

[1,1,2,2,2,1], n=6.

Unique x:1,2.

Choosing x=1 (frequency 3):

Non-1 elements at positions 3,4,5.

Set from 3 to 5, cost=3.

Choosing x=2 (frequency 3):

Non-2 elements at positions 1,2,6.

Set from 1 to 6, cost=6.

Minimal cost is 3.

Again, choosing the most frequent x gives the better cost.

So, perhaps it's always optimal to choose x as one of the most frequent values.

Because then the subarray to set is minimized.

Wait, but in the earlier example where array is [1,2,1,2,3], choosing x=1 or x=3 both give cost=3, which is better than choosing x=2.

So, it's not necessary that choosing the most frequent x gives the minimal cost, but in practice, it seems to work.

Wait, in that case, x=1 and x=3 have the same frequency, so both are most frequent.

So, perhaps choosing any of the most frequent x gives the minimal cost.

But in the array [1,2,1,2,3], frequencies are 1:2, 2:2, 3:1.

So, most frequent are 1 and 2, both frequency 2.

But choosing x=1 gives cost=3, choosing x=2 gives cost=5.

So, choosing the most frequent x does not necessarily give the minimal cost.

Wait, in this case, choosing x=1 is better than x=2.

So, even among the most frequent x, some give better costs than others.

So, I need to consider all possible x, not just the most frequent ones.

Hence, the initial approach of considering all unique x and finding the minimal cost among them seems correct.

But, as I thought earlier, with n up to 2e5 and t up to 1e4, but total n over all test cases up to 2e5, I need an efficient implementation.

So, in code, for each test case, I need to:

- Read n and the array a.

- Find all unique values in a.

- For each unique x, find the first index where a[i] != x and the last index where a[j] != x.

- Compute j - i + 1, if i <= j, else 0.

- Take the minimal among these costs.

But, as I thought before, this would be O(n * number of unique x), which could be up to O(n^2) in the worst case, but since n is up to 2e5 and total n over all test cases is up to 2e5, and t up to 1e4, but with n per test case up to 2e5, it's still manageable as long as per test case time is O(n).

But in reality, if t is up to 1e4 and n up to 2e5, but total n over all test cases is up to 2e5, then per test case time should be O(n), which is acceptable.

So, I need to implement this efficiently.

In Python, finding unique values can be done using set(a), which is O(n).

Then, for each x in set(a), find the first i where a[i] != x and the last j where a[j] != x.

This can be done by iterating through the array once and collecting all indices where a[i] != x.

Then, the first and last of these indices give i and j.

But if there are no such indices, meaning all a[i] == x, then cost is 0.

So, for each x, this would take O(n) time, and with up to n unique x, it's O(n^2), which is too slow for n=2e5.

Wait, but in practice, the number of unique x is small, since a_i can be up to n, but in many test cases, it's much smaller.

But to be safe, I need a better approach.

Let me think differently.

Suppose I find the minimal cost over all x by finding the minimal length of the subarray that covers all positions where a[i] != x.

This is equivalent to finding the minimal length of the subarray that covers all positions not equal to x, for some x.

Alternatively, I can think of it as finding the minimal length of the subarray such that, outside this subarray, all elements are equal to x.

So, to minimize this, I need to maximize the length of the prefix and suffix that are already equal to x.

So, for each x, the cost is n - (length of the longest prefix of a's equal to x + length of the longest suffix of a's equal to x).

Wait, that might not be exactly correct.

Let me think.

If I have a prefix of length L where a[i] == x, and a suffix of length R where a[i] == x, then the subarray to set is from L+1 to n-R.

So, the length to set is (n - R - L).

But I need to make sure that between L and n-R, all elements are set to x.

Wait, no, because between L and n-R, there might be some elements already equal to x.

Actually, to make the entire array equal to x, I need to set the subarray from the first a[i] != x to the last a[j] != x.

So, the cost is j - i + 1.

If all a[i] == x, then i > j, so cost is 0.

So, to compute this efficiently, I can:

- Find all unique x in the array.

- For each x, find the first i where a[i] != x and the last j where a[j] != x.

- Compute j - i + 1, or 0 if i > j.

- Take the minimal over all x.

But, as I thought earlier, this is O(n * number of unique x), which could be too slow.

Is there a way to compute this more efficiently?

Wait, perhaps I can precompute for each x, the first and last positions where a[i] != x.

But that still seems O(n * number of unique x).

Is there a way to compute this in linear time or close to linear time?

Let me consider that the minimal cost is equal to the minimal, over all x, of the length from the first a[i] != x to the last a[j] != x.

So, to find this efficiently, maybe I can find the minimal j - i + 1 over all i and j where a[i] != a[j], and i <= j.

Wait, no, that's not quite right.

Wait, perhaps I can find the minimal length of the subarray that covers all positions where a[i] != x, for some x.

But I need to find the minimal over all x of j - i + 1, where i is the first a[k] != x and j is the last a[k] != x.

An alternative approach is to find the minimal length of the subarray such that, outside this subarray, all elements are equal.

In other words, find the minimal length of the subarray that, when set to some x, makes the entire array equal to x.

This is equivalent to finding the minimal length of the subarray such that all elements outside this subarray are equal.

So, I need to find the minimal j - i + 1 such that all elements before i and after j are equal.

Wait, more precisely, all elements before i and after j are equal to some x.

But x has to be equal to the value outside the subarray.

So, perhaps I can find the minimal j - i + 1 such that all elements before i are equal and all elements after j are equal to that same value.

Wait, maybe it's better to iterate over possible x and compute the first and last positions where a[k] != x, and then take j - i + 1.

But I need to optimize this.

Let me consider that the minimal cost is equal to the minimal, over all x, of the length from the first a[k] != x to the last a[k] != x.

So, to optimize this, perhaps I can find the maximal length of the prefix and suffix that are equal to x, for some x, and then the cost is n - (len(prefix) + len(suffix) - overlap).

Wait, it's getting complicated.

Let me think of a different approach.

Suppose I fix x and want to compute the cost for that x efficiently.

To compute the cost for a given x, I need to find the first i where a[i] != x and the last j where a[j] != x.

Then, the cost is j - i + 1.

If all a[k] == x, then cost is 0.

So, to compute this for all x efficiently, perhaps I can iterate through the array once and keep track of the first and last positions where a[k] != x, for each x.

But that still seems O(n * number of unique x).

Is there a way to compute this in linear time?

Wait, perhaps I can find the minimal j - i + 1 such that all a[k] for k < i and k > j are equal to some x.

This sounds similar to finding the minimal subarray length that covers all positions where a[k] != x, for some x.

To optimize this, maybe I can find, for each position, the value of a[k], and keep track of the start and end positions for each x.

Wait, perhaps I can group the array by consecutive equal elements and then find the minimal subarray to cover all the groups that are not equal to x, for some x.

But this seems too vague.

Let me consider that the minimal cost is equal to the minimal, over all x, of the length from the first a[k] != x to the last a[k] != x.

So, to compute this efficiently, perhaps I can iterate through the array and keep track of the positions where a[k] changes.

Wait, maybe not.

Another idea: find the intersection of the ranges where a[k] != x, for all x.

Wait, that doesn't make sense.

Let me consider that to make the entire array equal to x, I need to set a subarray from the first a[k] != x to the last a[k] != x to x.

So, the cost is j - i + 1.

I need to minimize this over all x.

So, perhaps I can find the x where the range from first a[k] != x to last a[k] != x is minimized.

To optimize this, maybe I can sort the unique x by the start and end positions where a[k] != x.

Wait, I'm not sure.

An alternative approach is to realize that the minimal cost is equal to the length of the array minus the length of the longest prefix and suffix that are equal to some x.

Wait, perhaps.

Let me think.

Suppose I choose x such that the prefix of length L and suffix of length R are equal to x.

Then, the subarray to set is from L+1 to n-R, and its length is n - L - R.

So, to minimize n - L - R, I need to maximize L + R.

So, the minimal cost is n - maximal (L + R), where L is the length of some prefix equal to x and R is the length of some suffix equal to x, for some x.

Wait, but L and R must be for the same x.

So, I need to choose x such that L + R is maximized, where L is the length of the prefix equal to x and R is the length of the suffix equal to x.

Then, the minimal cost is n - (L + R).

So, to minimize n - (L + R), I need to maximize L + R.

Therefore, I need to find the x that maximizes L + R, where L is the length of the prefix equal to x and R is the length of the suffix equal to x.

Then, the minimal cost is n - (L + R).

This seems correct.

So, for each x, find the length of the longest prefix equal to x and the longest suffix equal to x, and maximize L + R over all x.

Then, minimal cost is n - (L + R).

This way, I only need to compute L and R for each x once, and then find the maximal L + R.

This seems more efficient.

In code, I can:

- For each test case:

- Read n and the array a.

- For each unique x in a:

- Find the largest L such that a[0 to L-1] == x.

- Find the largest R such that a[n-R to n-1] == x.

- Compute L + R.

- Keep track of the maximum L + R over all x.

- Then, minimal cost is n - (maximal L + R).

- If maximal L + R == n, meaning the entire array is equal to some x, then cost is 0.

This seems correct.

Let's verify with some examples.

First test case:

6

1 2 3 4 5 1

Unique x:1,2,3,4,5.

For x=1:

L=1 (a[0]==1), R=1 (a[5]==1), L+R=2.

For x=2:

L=0 (no prefix), R=0 (no suffix), L+R=0.

For x=3:

L=0, R=0, L+R=0.

For x=4:

L=0, R=0, L+R=0.

For x=5:

L=0, R=0, L+R=0.

Maximal L + R is 2, so minimal cost is 6 - 2 = 4, which matches the sample output.

Second test case:

7

1 1 1 1 1 1 1

Unique x:1.

L=7 (whole array), R=7 (whole array), L+R=7.

Minimal cost is 7 - 7 = 0, which matches.

Third test case:

8

8 8 8 1 2 8 8 8

Unique x:8,1,2.

For x=8:

L=3 (a[0:2]==8), R=3 (a[5:7]==8), L+R=6.

For x=1:

L=0, R=0, L+R=0.

For x=2:

L=0, R=0, L+R=0.

Maximal L + R is 6, so minimal cost is 8 - 6 = 2, which matches.

Fourth test case:

1

1

Unique x:1.

L=1, R=1, L+R=1.

Minimal cost is 1 - 1 = 0.

Fifth test case:

2

1 2

Unique x:1,2.

For x=1:

L=1, R=0, L+R=1.

For x=2:

L=0, R=1, L+R=1.

Maximal L + R is 1, minimal cost is 2 - 1 = 1, which matches.

Sixth test case:

3

1 2 3

Unique x:1,2,3.

For x=1:

L=1, R=0, L+R=1.

For x=2:

L=0, R=0, L+R=0.

For x=3:

L=0, R=1, L+R=1.

Maximal L + R is 1, minimal cost is 3 - 1 = 2, which matches.

Seventh test case:

7

4 3 2 7 1 1 3

Unique x:4,3,2,7,1.

For x=4:

L=1, R=0, L+R=1.

For x=3:

L=0, R=1, L+R=1.

For x=2:

L=0, R=0, L+R=0.

For x=7:

L=0, R=0, L+R=0.

For x=1:

L=0, R=2, L+R=2.

Maximal L + R is 2, minimal cost is 7 - 2 = 5.

Wait, but the sample output is 6.

Wait, maybe I miscalculated.

Wait, for x=1:

L=0 (first element is 4, not 1), R=2 (last two are 1,3; only a[5:6]==1), so R=1.

Wait, a[5]==1, a[6]==3.

So, R=1 (only a[5]==1).

Wait, I'm getting confused.

In the array [4,3,2,7,1,1,3], for x=1:

- L=0 (a[0]!=1)

- R=1 (a[5]==1, a[6]!=1), so R=1

So, L + R = 1, not 2.

Wait, but according to the sample output, it's 6.

Wait, maybe I need to compute L and R correctly.

Wait, perhaps I need to find the largest L where a[0:L]==x and the largest R where a[n-R:n]==x.

For x=1:

- L=0 (a[0]!=1)

- R=1 (a[5]==1, a[6]!=1)

- L + R = 1

For x=3:

- L=0 (a[0]!=3)

- R=1 (a[6]==3, a[5]!=3)

- L + R =1

For x=2:

- L=0

- R=0

- L + R=0

For x=7:

- L=0

- R=0

- L + R=0

For x=4:

- L=1 (a[0]==4)

- R=0 (a[6]!=4)

- L + R=1

Maximal L + R is 1, so minimal cost is 7 - 1 = 6, which matches the sample output.

Okay, good.

Eighth test case:

9

9 9 2 9 2 5 5 5 3

Unique x:9,2,5,3.

For x=9:

L=2 (a[0:1]==9)

R=0 (a[8]==3 !=9)

L + R=2

For x=2:

L=0 (a[0]==9 !=2)

R=1 (a[8]==3 !=2)

L + R=1

For x=5:

L=0

R=3 (a[6:8]==5,5,5)

L + R=3

For x=3:

L=0

R=1 (a[8]==3)

L + R=1

Maximal L + R is 3, so minimal cost is 9 - 3 = 6, but the sample output is 7.

Wait, but the sample output is 7.

Wait, perhaps I miscalculated.

Wait, a[6:8]==5,5,5, so for x=5, R=3.

But a[8]==3 !=5, so R=2 (a[7:8]==5,5).

Wait, the suffix is a[6:8]==5,5,5, so R=3.

But a[8]==3 !=5, so R=2.

Wait, no, R is the length of the suffix where a[n-R:n]==x.

So, for x=5:

a[6:8]==5,5,5, but a[8]==3 !=5, so R=2 (a[7:8]==5,5).

Wait, in Python, a[n-R:n], with n=9, R=3 would be a[6:9]==[5,5,5], but a[8]==3 !=5, so R=2, a[7:9]==[5,5].

So, R=2 for x=5.

Similarly, for x=9, L=2 (a[0:1]==9), R=0 (a[8]==3 !=9), L + R=2.

For x=2, L=0, R=1 (a[8]==3 !=2), L + R=1.

For x=5, L=0, R=2, L + R=2.

For x=3, L=0, R=1, L + R=1.

Maximal L + R is 2, so minimal cost is 9 - 2 = 7, which matches the sample output.

Okay, now I'm confident about this approach.

So, in code, for each test case, I need to:

- Read n and the array a.

- Find all unique x in a.

- For each x, compute:

- L: the largest integer such that a[0:L]==x.

- R: the largest integer such that a[n-R:n]==x.

- Compute L + R.

- Keep track of the maximum L + R over all x.

- Then, the minimal cost is n - (maximal L + R).

- If maximal L + R >= n, then cost is 0.

Wait, if maximal L + R >= n, then the entire array can be made equal to x without any operation, but in reality, L + R can't be greater than n.

Because L is the length of the prefix equal to x, and R is the length of the suffix equal to x, and they can overlap only if x is the same throughout.

But in the case where the entire array is equal to x, L + R = n, and cost is 0.

So, the formula is:

if L + R <= n:

cost = n - (L + R)

else:

cost = 0

But since L + R can't be greater than n, because L and R are overlapping, but to be safe, I can set cost = max(0, n - (L + R)).

In code, I can implement this as follows.

To compute L and R for each x efficiently, I can:

- For L, iterate from the start and count how many consecutive a[i]==x.

- For R, iterate from the end and count how many consecutive a[i]==x.

This can be done in O(n) time per x, but since x can be up to n, it's still O(n^2).

Wait, no, x is up to n, but in total over all test cases, n is up to 2e5, so it's acceptable.

But I can optimize it further.

Wait, actually, since the sum of n over all test cases is up to 2e5, and t up to 1e4, but total operations up to 2e5, it's acceptable.

But I can make it more efficient.

An alternative is to precompute for each x, the length of the prefix and suffix equal to x.

So, for each x, L is the largest L where a[0:L]==x.

Similarly, R is the largest R where a[n-R:n]==x.

I can iterate once from the start to compute L for each x, and once from the end to compute R for each x.

Then, for each x, L + R is known, and I can find the maximal L + R.

Then, minimal cost is n - (maximal L + R).

This way, per test case, it's O(n).

Let's see.

In code:

- Read t.

- For each test case:

- Read n and a.

- Initialize a dictionary to store L and R for each x.

- Iterate from the start:

- For each x, count