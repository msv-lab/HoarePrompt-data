Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order, buys as many jewels as she can with her remaining coins, and moves on to the next stall.

My task is to determine if Bob can set up the stalls with prices such that Alice buys exactly k jewels. If it's possible, I need to output "YES" along with the number of stalls and their prices. If not, I should output "NO".

First, I need to understand the constraints and what exactly is being asked. The input consists of multiple test cases, each with two integers n and k, where n is the number of coins Alice has and k is the number of jewels Bob wants Alice to buy. Both n and k can be as large as 10^18, which means I have to be careful with how I handle large numbers.

Looking at the example provided:

In the first test case:

7 coins, wants to buy 3 jewels.

Output:

YES

10

2 3 4 5 6 7 8 9 10 11

Explanation:

At the first stall with price 2, Alice buys 3 jewels (since 7 // 2 = 3), and is left with 1 coin. Since 1 coin is not enough to buy any jewels from the remaining stalls, she stops after buying 3 jewels.

In the third test case:

255 coins, wants to buy 8 jewels.

Output:

YES

8

128 64 32 16 8 4 2 1

Explanation:

Alice buys 1 jewel from each stall, spending 128, 64, 32, 16, 8, 4, 2, and 1 coins respectively, totaling 255 coins and buying exactly 8 jewels.

From these examples, it seems that one strategy is to set up stalls with decreasing prices, starting from a price that allows Alice to buy as many jewels as possible without exceeding k.

But in the first example, they used increasing prices, which is interesting. Let me think about how that works.

In the first example, with prices 2, 3, 4, ..., 11, Alice buys 3 jewels from the first stall (7 // 2 = 3), spends 6 coins, left with 1 coin. Since 1 coin is less than the price of any other stall, she stops, having bought exactly 3 jewels.

So, in this case, by setting the first stall's price low enough that Alice can buy multiple jewels there, and the remaining stalls' prices high enough that Alice can't buy any more jewels after the first stall, we can control exactly how many jewels she buys.

Another approach is to set up stalls with prices that force Alice to buy one jewel from each stall. For example, in the third test case, with prices 128, 64, 32, ..., 1, Alice buys one jewel from each stall, totaling 8 jewels.

So, it seems there are multiple strategies depending on the values of n and k.

Now, let's look at the provided program and see if it's correct.

The program defines a function func_1(n, k) that seems to handle each test case. Let's go through it step by step.

First, it checks if n equals k. If so, it sets up one stall with price 1, so Alice buys n coins / 1 = n jewels, which equals k. That makes sense.

If n < k, it's impossible because Alice can't buy more jewels than the number of coins she has, assuming each jewel costs at least 1 coin. So, output "NO" in this case.

Then, it sets up costs = [n - k + 1, 1]. So, two stalls: one with price n - k + 1 and another with price 1.

It calculates h, which seems to be the total number of jewels Alice would buy with these two stalls.

It does this by:

- curr = n // i for each i in costs

- h += curr

- n -= i * curr

This is simulating how many jewels Alice buys from each stall and updating the remaining coins.

Finally, if h < k, output "NO"; else, output "YES" and the prices.

Wait, but in the first test case, with n=7 and k=3, let's see what this program does.

costs = [7 - 3 + 1 = 5, 1]

So, two stalls with prices 5 and 1.

Calculate h:

- For i=5: curr = 7 // 5 = 1, h +=1, n -=5*1 = 7-5=2

- For i=1: curr = 2 //1 =2, h +=2, n -=1*2=2-2=0

Total h=3, which equals k=3.

So, it should output "YES" and the prices [5,1].

But in the example, it outputs 10 stalls with prices from 2 to 11, but according to this program, it would output 2 stalls with prices 5 and 1.

Is this still correct? Well, as long as it meets the condition of buying exactly k jewels, the number of stalls and their prices can vary, as long as it's at most 60 stalls and within the price limits.

So, in this case, outputting 2 stalls with prices [5,1] should work:

- From stall 1 (price 5), Alice buys 1 jewel, spends 5 coins, left with 2 coins.

- From stall 2 (price 1), Alice buys 2 jewels, spends 2 coins, left with 0 coins.

Total jewels bought: 1 + 2 = 3, which matches k=3.

So, this seems correct.

Now, let's consider the second test case: n=6, k=4.

According to the program:

costs = [6 - 4 +1 =3, 1]

So, two stalls with prices 3 and 1.

Calculate h:

- For i=3: curr=6//3=2, h+=2, n-=3*2=6-6=0

- For i=1: curr=0//1=0, h+=0, n-=1*0=0

Total h=2, which is less than k=4.

So, h < k, hence output "NO", which matches the sample output.

Good.

Third test case: n=255, k=8.

According to the program:

costs=[255-8+1=248,1]

So, two stalls with prices 248 and 1.

Calculate h:

- For i=248: curr=255//248=1, h+=1, n-=248*1=255-248=7

- For i=1: curr=7//1=7, h+=7, n-=1*7=7-7=0

Total h=8, which equals k=8.

So, it should output "YES" and the prices [248,1].

But in the sample output, it's showing 8 stalls with prices [128,64,32,16,8,4,2,1].

Both are valid, as long as the total number of stalls is at most 60.

Now, is there a scenario where this program would fail?

Let me think about cases where n is slightly larger than k.

For example, n=10, k=5.

According to the program:

costs=[10-5+1=6,1]

- For i=6: curr=10//6=1, h+=1, n-=6*1=10-6=4

- For i=1: curr=4//1=4, h+=4, n-=1*4=4-4=0

Total h=5, which equals k=5.

Good.

Another case: n=5, k=2.

costs=[5-2+1=4,1]

- For i=4: curr=5//4=1, h+=1, n-=4*1=5-4=1

- For i=1: curr=1//1=1, h+=1, n-=1*1=1-1=0

Total h=2, which equals k=2.

Good.

Wait, but what if n=4, k=2.

costs=[4-2+1=3,1]

- For i=3: curr=4//3=1, h+=1, n-=3*1=4-3=1

- For i=1: curr=1//1=1, h+=1, n-=1*1=1-1=0

Total h=2, which equals k=2.

Good.

Another case: n=3, k=1.

costs=[3-1+1=3,1]

- For i=3: curr=3//3=1, h+=1, n-=3*1=3-3=0

- For i=1: curr=0//1=0, h+=0, n-=1*0=0

Total h=1, which equals k=1.

Good.

Wait, but according to the program, if n == k, it outputs [1], which is better, but [3,1] also works.

Now, is there a case where h >=k, but actually, we need exactly k, and with the current approach, h could be larger than k.

Wait, in the program, it checks if h < k, then "NO", else "YES".

But what if h > k? In that case, Alice would buy more than k jewels, which is not what we want. We need exactly k.

Wait, but according to the problem, Alice buys as many jewels as possible from each stall until she can't buy any more from the remaining stalls.

So, in the approach used in the program, by setting two stalls with prices [n - k +1, 1], it seems to ensure that Alice buys exactly k jewels.

Let me see.

In general, with prices p1 and p2, where p1 = n - k +1 and p2=1.

First stall: Alice buys floor(n / p1) jewels, spends floor(n / p1) * p1 coins.

Then, with the remaining coins, she buys floor(remaining / p2) jewels.

The total number of jewels should be equal to k.

Let's see:

Let me denote:

j1 = floor(n / p1)

remaining = n - j1 * p1

j2 = floor(remaining / p2)

total jewels = j1 + j2

We set p1 = n - k +1 and p2=1.

So, j1 = floor(n / (n - k +1))

remaining = n - j1 * (n - k +1)

j2 = remaining / 1 = remaining

total jewels = j1 + remaining = j1 + n - j1 * (n - k +1)

I need this to be equal to k.

Let me see:

j1 = floor(n / (n - k +1))

Let me denote m = n - k +1

Then j1 = floor(n / m)

remaining = n - j1 * m

total jewels = j1 + remaining

But remaining = n - j1 * m, so total jewels = j1 + n - j1 * m = n - j1 * (m -1)

Wait, but m = n - k +1

So, total jewels = n - j1 * (n - k +1 -1) = n - j1 * (n - k)

Now, j1 = floor(n / (n - k +1))

Let me see for n=7, k=3:

m = 7 -3 +1 =5

j1 = floor(7/5)=1

total jewels = 7 -1*(7-3)=7-4=3, which matches k=3.

For n=10, k=5:

m=10-5+1=6

j1=floor(10/6)=1

total jewels=10 -1*(10-5)=10-5=5, matches k=5.

For n=6, k=4:

m=6-4+1=3

j1=floor(6/3)=2

total jewels=6 -2*(6-4)=6-4=2 <4, which is why it outputs "NO", which is correct.

Wait, but in this case, h=2 <4, so it's correct.

Another case: n=255, k=8.

m=255-8+1=248

j1=floor(255/248)=1

remaining=255-1*248=7

j2=7//1=7

total jewels=1+7=8, which matches k=8.

Seems consistent.

Wait, but what if n=10, k=3.

m=10-3+1=8

j1=floor(10/8)=1

total jewels=10 -1*(10-3)=10-7=3, which matches k=3.

Another case: n=5, k=2.

m=5-2+1=4

j1=floor(5/4)=1

total jewels=5 -1*(5-2)=5-3=2, matches k=2.

n=4, k=2.

m=4-2+1=3

j1=floor(4/3)=1

total jewels=4 -1*(4-2)=4-2=2, matches k=2.

n=3, k=1.

m=3-1+1=3

j1=floor(3/3)=1

total jewels=3 -1*(3-1)=3-2=1, matches k=1.

Seems to work.

Wait, but what if n=2, k=1.

m=2-1+1=2

j1=floor(2/2)=1

total jewels=2 -1*(2-1)=2-1=1, matches k=1.

Another case: n=1, k=1.

m=1-1+1=1

j1=floor(1/1)=1

total jewels=1 -1*(1-1)=1-0=1, matches k=1.

Good.

Now, what if n=5, k=4.

m=5-4+1=2

j1=floor(5/2)=2

total jewels=5 -2*(5-4)=5-4=1 <4, so h=1 <4, so output "NO", which is correct because it's impossible to buy exactly 4 jewels with 5 coins.

Wait, is it impossible?

Let me see.

If I set up one stall with price 2, Alice buys 2 jewels, spends 4 coins, left with 1 coin, can't buy from next stall with price >=1.

Total jewels:2 <4.

If I set up two stalls: [1,2]

From stall 1 (price 1): buys 5 jewels, spends 5 coins, left with 0 coins.

Total jewels:5 >4.

Not exactly 4.

Alternatively, [2,3]

From stall 1 (price 2): buys 2 jewels, spends 4 coins, left with 1 coin.

From stall 2 (price 3): can't buy any.

Total jewels:2 <4.

Another try: [1,3]

From stall 1 (price 1): buys 5 jewels, spends 5 coins, left with 0 coins.

Total jewels:5 >4.

No.

Another try: [2,4]

From stall 1 (price 2): buys 2 jewels, spends 4 coins, left with 1 coin.

From stall 2 (price 4): can't buy any.

Total jewels:2 <4.

Not enough.

Seems like it's impossible to buy exactly 4 jewels with 5 coins, hence the program correctly outputs "NO".

Good.

So, the program seems to be correct in these cases.

But wait, is there a case where h >=k, but total jewels are exactly k?

Wait, in the program, it only checks if h <k, then "NO", else "YES".

But what if h >k? In the earlier examples, h equals k, but what if h >k?

Wait, in the first test case, with n=7 and k=3, h=3 which equals k=3.

In the third test case, h=8 which equals k=8.

But what if n=10 and k=5, h=5.

What if n=10 and k=4.

According to the program:

costs=[10-4+1=7,1]

- For i=7: curr=10//7=1, h+=1, n-=7*1=10-7=3

- For i=1: curr=3//1=3, h+=3, n-=1*3=3-3=0

Total h=4, which equals k=4.

So, it should output "YES" with prices [7,1].

Let me check:

- Stall 1 (7): buys 1 jewel, spends 7 coins, left with 3 coins.

- Stall 2 (1): buys 3 jewels, spends 3 coins, left with 0 coins.

Total jewels:1+3=4, which matches k=4.

Good.

Another case: n=10, k=6.

costs=[10-6+1=5,1]

- For i=5: curr=10//5=2, h+=2, n-=5*2=10-10=0

- For i=1: curr=0//1=0, h+=0, n-=0

Total h=2 <6, so output "NO", which is correct because it's impossible to buy 6 jewels with 10 coins.

Wait, is it impossible?

Let's see.

If I set up one stall with price 1, Alice buys 10 jewels, which is more than 6.

But I need exactly 6.

Is there a way to make her buy exactly 6?

Maybe set up two stalls: [2,1]

- Stall 1 (2): buys 5 jewels, spends 10 coins, left with 0 coins.

Total jewels:5 >6.

Not good.

Another try: [3,1]

- Stall 1 (3): buys 3 jewels, spends 9 coins, left with 1 coin.

- Stall 2 (1): buys 1 jewel, spends 1 coin, left with 0 coins.

Total jewels:4 <6.

Not enough.

Another try: [2,3]

- Stall 1 (2): buys 5 jewels, spends 10 coins, left with 0 coins.

Total jewels:5 <6.

No.

Seems impossible.

Hence, the program correctly outputs "NO".

Good.

Now, what if n=15, k=10.

costs=[15-10+1=6,1]

- For i=6: curr=15//6=2, h+=2, n-=12, left with 3

- For i=1: curr=3//1=3, h+=3, n-=3, left with 0

Total h=5 <10.

So, program outputs "NO".

But is there another way to set up stalls to get exactly 10 jewels?

Let's try setting up more stalls.

For example, three stalls: [2,2,2]

- Stall 1 (2): buys 7 jewels, spends 14 coins, left with 1 coin.

- Stall 2 (2): can't buy any.

Total jewels:7 >10.

Not good.

Another try: [1,1,1]

- Stall 1 (1): buys 15 jewels, spends 15 coins, left with 0.

Total jewels:15 >10.

No.

Another try: [2,3,4]

- Stall 1 (2): buys 7 jewels, spends 14 coins, left with 1 coin.

- Stall 2 (3): can't buy any.

Total jewels:7 <10.

No.

Another try: [1,2,3]

- Stall 1 (1): buys 15 jewels, spends 15 coins, left with 0.

Total jewels:15 >10.

No.

Seems like it's impossible to get exactly 10 jewels with 15 coins, hence the program correctly outputs "NO".

Good.

Another consideration: what if k=1, any n >=1.

According to the program:

If n ==1 and k==1, output [1].

Else, costs=[n -1 +1= n,1]

- For i=n: curr=n//n=1, h+=1, n-=n*1=0

- For i=1: curr=0//1=0, h+=0, n-=0

Total h=1, which equals k=1.

Good.

Edge case: n=1, k=1.

Output "YES", 1, [1].

Good.

Edge case: n=1, k=2.

Since n <k, output "NO".

Good.

Another edge case: n=10^18, k=10^18.

Program does:

If n ==k, output [1].

Alice buys n jewels, which equals k.

Good.

Another edge case: n=10^18, k=1.

costs=[10^18 -1 +1=10^18,1]

- For i=10^18: curr=10^18//10^18=1, h+=1, n-=10^18*1=0

- For i=1: curr=0//1=0, h+=0, n-=0

Total h=1, which equals k=1.

Good.

Another edge case: n=10^18, k=2.

costs=[10^18 -2 +1=10^18 -1,1]

- For i=10^18 -1: curr= floor(10^18 / (10^18 -1))=1, h+=1, n-= (10^18 -1)*1=10^18 -1, left with 1

- For i=1: curr=1//1=1, h+=1, n-=1, left with 0

Total h=2, which equals k=2.

Good.

Seems solid.

Now, is there any case where h >=k, but total jewels are more than k, and the program outputs "YES", which would be incorrect?

Wait, in the program, it only checks if h <k, then "NO", else "YES".

But according to the earlier analysis, h should be equal to k with this approach.

In all the cases I checked, h equals k when h >=k.

Is there a case where h >k?

Wait, in the case where n=10 and k=5, h=5.

n=7 and k=3, h=3.

n=255 and k=8, h=8.

n=5 and k=2, h=2.

n=4 and k=2, h=2.

n=3 and k=1, h=1.

n=2 and k=1, h=1.

n=1 and k=1, h=1.

Seems consistent.

But what if n=10 and k=3.

costs=[10-3+1=8,1]

- For i=8: curr=10//8=1, h+=1, n-=8, left with 2

- For i=1: curr=2//1=2, h+=2, n-=2, left with 0

Total h=3, which equals k=3.

Good.

Another case: n=10 and k=4.

costs=[10-4+1=7,1]

- For i=7: curr=10//7=1, h+=1, n-=7, left with 3

- For i=1: curr=3//1=3, h+=3, n-=3, left with 0

Total h=4, which equals k=4.

Good.

Wait, earlier I thought h=4 >=k=4, and the program outputs "YES", which is correct.

So, it seems that with this approach, h equals k in all cases where h >=k.

Hence, the program is correct.

Additionally, the problem allows up to 60 stalls, and in the program, it only uses 2 stalls, which is within the limit.

Therefore, the program is correct.

**Final Solution**

To solve this problem, we need to determine if Bob can set up at most 60 stalls with integer prices per jewel such that Alice buys exactly k jewels using her n coins. Alice buys jewels greedily from each stall in order.

### Approach

1. **Initial Check**:
   - If the number of coins (n) is less than the number of jewels (k), it's impossible for Alice to buy k jewels since each jewel costs at least one coin.
   - If n equals k, set up a single stall with price 1, so Alice buys exactly k jewels.

2. **Setting Stall Prices**:
   - Use two stalls with prices calculated as follows:
     - First stall price: p1 = n - k + 1
     - Second stall price: p2 = 1
   - Calculate the number of jewels Alice can buy from each stall:
     - From the first stall, she buys floor(n / p1) jewels.
     - From the second stall, she buys floor(remaining_coins / p2) jewels.
   - Sum these to check if the total jewels bought equal k.

3. **Output Result**:
   - If the total jewels bought equal k, output "YES" along with the number of stalls and their prices.
   - If not, output "NO".

### Solution Code

```python
t = int(input())
for _ in range(t):
    (n, k) = list(map(int, input().split()))
    func_1(n, k)

def func_1(n, k):
    if n == k:
        print('YES')
        print(1)
        print(1)
        return
    if n < k:
        print('NO')
        return
    costs = [n - k + 1, 1]
    h = 0
    for i in costs:
        curr = n // i
        h += curr
        n -= i * curr
    if h < k:
        print('NO')
    else:
        print('YES')
        print(2)
        print(*costs)
```

### Explanation

- **Initial Check**:
  - If n < k, output "NO" because it's impossible.
  - If n == k, set up one stall with price 1 to buy exactly k jewels.

- **Two Stall Strategy**:
  - Set up two stalls with prices p1 = n - k + 1 and p2 = 1.
  - Calculate jewels bought from each stall:
    - From stall 1: floor(n / p1)
    - From stall 2: floor(remaining_coins / p2)
  - Sum these jewels and check if it equals k.

- **Output**:
  - If the sum equals k, output "YES" with the number of stalls and their prices.
  - If the sum is less than k, output "NO".

This approach ensures that Alice buys exactly k jewels by carefully setting the prices of the stalls.