Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a "beautiful" array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. If it's impossible to make it not beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if I can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ n-1) such that a[i-1] equals a[i+1], and replace a[i] with a[i-1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. This operation can be repeated as many times as I want.

My task is to remove as few elements as possible from this array to make it not beautiful. That means, after removal, I should not be able to perform any operations that would make all elements equal.

Looking at the examples:

1. For the array [2, 2, 2], it's already all the same, so no matter how many elements I remove, it will still be beautiful because there's nothing to change.

2. For [1, 2, 1, 2, 1], removing one element can make it not beautiful.

3. For [1], it's already not beautiful because there's only one element, and you can't perform the operation.

4. For [3, 3, 3, 5, 3, 3, 3], removing the first three elements makes it [5, 3, 3, 3], which is not beautiful.

I need to find a general approach for any given beautiful array.

Let me think about the properties of a beautiful array.

If the array is already all equal, like [2, 2, 2], it's impossible to make it not beautiful by removal since any subset will still be all equal.

In the second example, [1, 2, 1, 2, 1], it's alternating. By removing one element, I can break the pattern.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], there's a single 5 in the middle. Removing the first three 3's leaves [5, 3, 3, 3], which cannot be made all equal by the operation.

I need to find the minimal number of removals to ensure that the array cannot be made beautiful.

First, I need to understand when an array cannot be made beautiful.

If the array has only one element, it's not beautiful because the operation requires at least three elements with the middle one replaceable.

If the array has two elements and they are different, it's not beautiful because the operation cannot be performed.

If the array has two elements and they are the same, it's already beautiful, and removing one would make it have only one element, which is not beautiful.

So, for arrays of length 1 or 2:

- If n == 1: not beautiful.

- If n == 2:

- If a[1] == a[2]: beautiful.

- If a[1] != a[2]: not beautiful.

For n >= 3, it's more complicated.

Given that the array is beautiful, I need to remove elements to make it not beautiful.

I need to find the minimal number of removals such that after removal, the array cannot be made beautiful.

One way to approach this is to look for the smallest subset that, when removed, breaks the beauty of the array.

Let me consider the operation allowed: replace a[i] with a[i-1] if a[i-1] == a[i+1].

This operation allows "fixing" elements that are different from their neighbors, provided their neighbors are equal.

So, in a sequence like a b a, I can change b to a, making it a a a.

Similarly, in a a a, no changes are needed.

In a sequence like a b c, if b != a or c, then no operation can be performed on b.

So, for the array to be not beautiful, it should be impossible to perform any operations that would make all elements equal.

One strategy is to remove elements such that no subarray satisfies the condition for the operation.

But that seems too vague.

Let me think differently.

Suppose the array is composed of repeating blocks of the same value, like [a, a, a, b, b, b, a, a, a].

In this case, the blocks are separated by different values.

To make the array not beautiful, I need to ensure that no block can be extended to cover the entire array through operations.

Wait, but the operation allows me to fix elements within a block.

Wait, maybe I need to consider the runs of identical elements.

Let's define a "run" as a consecutive sequence of the same value.

For example, in [1, 1, 2, 2, 2, 1, 1], there are three runs: [1, 1], [2, 2, 2], [1, 1].

In such a case, the operation can be used to make all elements equal to the value of the runs that are extended.

Wait, maybe I need to remove runs in such a way that the remaining array cannot be made uniform.

This seems complicated.

Let me look at the examples again.

In the first example, [2, 2, 2], it's impossible to make it not beautiful, so output -1.

In the second example, [1, 2, 1, 2, 1], removing one element can make it not beautiful.

For instance, removing the last element makes it [1, 2, 1, 2], which cannot be made uniform.

Similarly, removing one of the 1's might also work.

In the third example, [1], it's already not beautiful, so output -1.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], removing the first three 3's leaves [5, 3, 3, 3], which cannot be made uniform because there's a 5 in the middle.

Alternatively, removing three elements to break the runs.

Wait, perhaps the minimal number of removals is related to the smallest run.

Let me consider that.

If I have runs of different lengths, maybe the minimal number of removals is the size of the smallest run.

In the second example, runs are [1], [2], [1], [2], [1]. The smallest run has size 1.

Removing one element from any run could break the beauty.

In the fourth example, runs are [3, 3, 3], [5], [3, 3, 3]. The smallest run has size 1 (the [5]). Removing three elements to eliminate the [5] run isn't straightforward.

Wait, but in that case, removing the first three 3's leaves [5, 3, 3, 3], which has runs [5], [3, 3, 3]. Now, can I make all elements equal? Well, I can't perform any operations because there's no i where a[i-1] == a[i+1] since 5 != 3.

Hence, it's not beautiful.

But in this case, removing three elements (the first three 3's) achieves this.

But is there a way to remove fewer elements?

If I remove only two elements, for example, removing the first two 3's, the array becomes [3, 5, 3, 3, 3]. Now, can I make all elements equal?

Looking at it:

- Initially, runs are [3], [5], [3, 3, 3].

- I can choose i=2 (since a[1]=3 == a[3]=5? No.

Wait, a[1]=3, a[3]=5, but 3 != 5, so no operation can be performed.

Wait, but according to the problem, the operation can only be performed if a[i-1] == a[i+1].

In this case, a[1]=3 and a[3]=5, which are different, so no operation can be performed.

Hence, the array [3,5,3,3,3] is not beautiful.

So, by removing two elements, I achieved the goal.

But according to the example, the output is 3, which seems inconsistent with this.

Wait, perhaps I made a mistake.

In the example, they removed the first three 3's, leaving [5,3,3,3], which is not beautiful.

But according to my previous thought, removing two 3's also makes it not beautiful.

So why is the answer 3 in the example?

Wait, perhaps I need to minimize the number of removals, but in this case, removing two 3's seems sufficient.

Wait, maybe I need to consider that after removal, the array must not be beautiful for any possible sequence of operations.

In the case where I remove two 3's and get [3,5,3,3,3], it seems not beautiful.

But perhaps there are cases where removing fewer elements doesn't always make it not beautiful.

Wait, maybe I need to consider the entire array and find the minimal number of removals such that no sequence of operations can make it uniform.

Alternatively, perhaps the minimal number of removals is equal to the size of the smallest run.

Wait, in the first example, all elements are the same, so any removal doesn't make it not beautiful, hence -1.

In the second example, the smallest run is of size 1, so removing one element makes it not beautiful.

In the third example, only one element, which is already not beautiful, so -1.

In the fourth example, the smallest run is of size 1 (the [5]), so removing one element should make it not beautiful.

But according to the example, the answer is 3.

This suggests that my assumption is incorrect.

Perhaps there's more to it.

Let me think differently.

Suppose I have runs of different lengths.

To make the array not beautiful, I need to ensure that after removal, there is no way to make all elements equal by performing the allowed operations.

One way to achieve this is to ensure that there are at least two different values that cannot be made equal through the operations.

For example, in the second test case, [1,2,1,2,1], removing one element can leave [1,2,1,2], which has alternating 1 and 2, and no operation can make them all equal.

In the fourth test case, [3,3,3,5,3,3,3], removing three 3's to leave [5,3,3,3], which has a 5 and 3's, and no operation can change the 5 to 3 or vice versa.

So, perhaps the minimal number of removals is equal to the size of the smallest run.

In the second example, smallest run is of size 1, so remove 1 element.

In the fourth example, smallest run is of size 1, but the answer is 3.

Wait, that doesn't match.

Wait, perhaps I need to remove enough elements to break all runs of the most frequent value.

Wait, I'm getting confused.

Let me consider another approach.

Suppose I try to remove elements to make sure that no two identical elements are adjacent.

If no two identical elements are adjacent, then no operation can be performed because a[i-1] == a[i+1] would require a[i-1] != a[i+1] if they are not equal.

Wait, no, if a[i-1] != a[i+1], then the operation cannot be performed.

So, if I remove elements such that no three identical elements are in a row, perhaps that helps.

But in the second example, [1,2,1,2,1], there are no three identical elements in a row, but it's still beautiful because operations can make all elements equal.

Wait, no, in that case, it's alternating, so operations cannot be performed because there's no i where a[i-1] == a[i+1].

Wait, in [1,2,1,2,1], for i=2, a[1]=1 == a[3]=1, so a[2]=2 can be replaced with 1.

After replacement, it becomes [1,1,1,2,1]. Now, for i=4, a[3]=1 == a[5]=1, so a[4]=2 can be replaced with 1, making all elements 1.

So, it is beautiful.

But if I remove the last element, it becomes [1,2,1,2], which cannot be made uniform.

Because after replacing i=2 and i=3, it becomes [1,1,1,2], and then no more operations can be performed because a[2]=1 == a[3]=1, but a[4]=2 !=1, so no operation can fix a[4].

Hence, it's not beautiful.

Similarly, in [3,3,3,5,3,3,3], removing the first three 3's leaves [5,3,3,3], which cannot be made uniform.

Because a[1]=5 != a[3]=3, so no operation can be performed.

Hence, it's not beautiful.

So, perhaps the minimal number of removals is equal to the size of the smallest run in the array.

In the second example, smallest run is of size 1, so remove 1 element.

In the fourth example, smallest run is of size 1 (the [5]), but according to the example, removing three elements is necessary.

Wait, perhaps I need to remove enough elements to break all runs of the majority value.

Wait, but in the fourth example, the majority value is 3, with runs of size 3 and 3, and a single 5.

Removing the run of size 3 would leave [3,3,3], which is still beautiful.

Wait, no, removing the first three 3's leaves [5,3,3,3], which is not beautiful.

Alternatively, removing the single 5 would leave [3,3,3,3,3], which is beautiful.

So, removing the smallest run isn't sufficient in this case.

Wait, perhaps I need to remove all elements of the minority run.

In this case, the minority run is [5], of size 1.

Removing one 3 wouldn't help because [3,3,3,5,3,3,3] still can be made uniform.

Removing two 3's: for example, removing the first two 3's leaves [3,5,3,3,3], which is not beautiful, as previously determined.

So, removing two 3's is sufficient.

But according to the example, the answer is 3.

Wait, perhaps there's a different interpretation.

Looking back at the problem statement, it says: "the minimum number of elements you have to remove from it in order for it to stop being beautiful."

And in the fourth example, the answer is 3.

But according to my previous thought, removing two 3's seems sufficient.

Perhaps the answer is not necessarily the size of the smallest run, but something else.

Maybe I need to consider the entire structure of the array.

Let me consider that in the fourth example, the array is [3,3,3,5,3,3,3].

If I remove the first three 3's, I'm removing a run of size 3, leaving [5,3,3,3], which is not beautiful.

Alternatively, removing the single 5 would leave [3,3,3,3,3], which is beautiful.

So, removing the smallest run (size 1) isn't enough; I need to remove more.

Wait, but removing two 3's also works, as previously thought.

So, why is the answer 3 in the example?

Perhaps I'm missing something.

Wait, maybe I need to remove all occurrences of the minority value.

In this case, there's only one 5, so removing one 5 shouldn't be enough, but as we've seen, it leaves a beautiful array.

Removing three 3's breaks the runs in a way that makes it not beautiful.

But I'm still confused.

Let me think differently.

Suppose I try to make the array not beautiful by ensuring that after removal, there are at least two different values that cannot be made equal through operations.

In other words, no matter what operations I perform, I cannot make all elements equal.

So, in the fourth example, [3,3,3,5,3,3,3], if I remove the first three 3's, leaving [5,3,3,3], there's no way to make all elements 5 or all elements 3 through operations.

Because for 5 to become 3, there's no operation that can change 5 to 3, since the operation only allows changing a[i] to a[i-1] if a[i-1] == a[i+1].

Similarly, in [5,3,3,3], a[i-1] and a[i+1] are both 3, so I can change any 5 to 3 if surrounded by 3's, but in this case, the 5 is at the start, so I can't perform the operation on it.

Hence, it's not beautiful.

But as I thought earlier, removing two 3's also achieves this.

So, why is the answer 3 in the example?

Wait, perhaps I need to remove the smallest number of elements that guarantees that no matter what operations are performed, the array cannot be made beautiful.

But in that case, removing two 3's seems sufficient.

Wait, maybe I need to remove elements such that the remaining array has at least two distinct values, and no operations can make them equal.

But in [5,3,3,3], there are two distinct values, and no operations can make 5 equal to 3.

Hence, it's not beautiful.

Similarly, removing two 3's to get [3,5,3,3,3] also results in an array that is not beautiful.

So, why is the answer 3 in the example?

Maybe I need to consider the worst-case scenario, where I have to remove as many elements as the smallest run size.

In this case, the smallest run is of size 1 ([5]), but removing one element isn't always sufficient, as seen earlier.

Wait, perhaps the answer is the size of the smallest run in the majority value.

Wait, I'm getting tangled.

Let me look for another approach.

Suppose I try to find the minimal number of removals to make sure that no operation can make the array uniform.

One way to ensure this is to remove elements such that the remaining array has at least two different values, and no operations can convert one value to another.

But in the given operation, you can only change a[i] to a[i-1] if a[i-1] == a[i+1].

So, if the remaining array has isolated elements that cannot be changed, then it's not beautiful.

Perhaps the minimal number of removals is equal to the size of the smallest run in the array.

In the second example, smallest run is 1, so remove 1 element.

In the fourth example, smallest run is 1, but according to the example, the answer is 3.

So, perhaps it's not that simple.

Wait, perhaps it's the size of the smallest run of the minority value.

In the fourth example, the minority value is 5, with run size 1, but removing one 5 isn't sufficient.

Wait, removing the run of 5 (size 1) leaves [3,3,3,3,3], which is beautiful.

So, I need to remove enough elements to ensure that no single value dominates in a way that allows operations to make all elements equal.

This seems tricky.

Let me consider that in a beautiful array, all elements can be made equal by a series of operations.

Hence, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal through operations.

One way to achieve this is to have at least two distinct values in the array, and ensure that there's no sequence of operations that can make them all equal.

This can be achieved by breaking the connectivity of the majority value or ensuring that there are isolated elements that cannot be changed.

In the second example, [1,2,1,2,1], removing one element can leave [1,2,1,2], where no operations can make all elements equal.

In the fourth example, [3,3,3,5,3,3,3], removing three 3's to leave [5,3,3,3], which cannot be made uniform.

But as I thought earlier, removing two 3's also achieves this.

So, perhaps the answer isn't simply the size of the smallest run.

Alternatively, maybe it's the size of the smallest run of the minority value, but in this case, removing one 5 isn't enough.

Wait, perhaps it's the size of the smallest run that, when removed, leaves the array not beautiful.

In that case, in the fourth example, removing the run of 5 (size 1) isn't enough, so I need to remove additional elements.

Hence, removing three 3's (a run of size 3) achieves this.

So, perhaps the minimal number of removals is the size of the smallest run that, when removed, makes the array not beautiful.

But this seems too vague.

Let me consider another angle.

Suppose I try to make the array not beautiful by ensuring that after removal, there are at least two different values, and no operation can convert one to another.

In other words, ensure that there are at least two distinct values, and no a[i-1] == a[i+1] for any i.

But this seems too restrictive.

Wait, perhaps the minimal number of removals is equal to the number of elements in the smallest run of the most frequent value.

Wait, in the second example, the most frequent value is 1, with runs of size 1, so removing one element suffices.

In the fourth example, the most frequent value is 3, with runs of size 3, so removing three elements (a run of 3's) makes it not beautiful.

This seems to match the example.

Hence, perhaps the minimal number of removals is equal to the size of the smallest run of the most frequent value.

In the first example, all elements are the same, so any removal doesn't make it not beautiful, hence -1.

In the third example, only one element, which is already not beautiful, so -1.

In the second example, most frequent value is 1, with runs of size 1, so remove 1 element.

In the fourth example, most frequent value is 3, with runs of size 3, so remove 3 elements.

This seems consistent.

Hence, my approach is:

- Find the most frequent value.

- Find the smallest run of that most frequent value.

- The minimal number of removals is equal to the size of that smallest run.

- If the array is composed of only one value, output -1.

- If the array is already not beautiful (e.g., only one element or cannot be made uniform), output -1.

Now, to implement this:

- I need to find the most frequent value(s).

- Then, find the smallest run of that value.

- Return the size of that run.

- Handle special cases where the array is already not beautiful.

Looking back at the examples:

- First test case: [2,2,2]. All elements are the same. Any removal doesn't make it not beautiful. So, output -1.

- Second test case: [1,2,1,2,1]. Most frequent value is 1, with runs of size 1. So, remove 1 element.

- Third test case: [1]. Only one element, already not beautiful. Output -1.

- Fourth test case: [3,3,3,5,3,3,3]. Most frequent value is 3, with runs of size 3. So, remove 3 elements.

This seems to align with the sample outputs.

Hence, I can proceed with this approach.

Now, to handle multiple test cases efficiently, considering the constraints (sum of n over all test cases does not exceed 3*10^5), I need an efficient implementation.

I'll need to:

- Read t test cases.

- For each test case:

- Read n and the array a.

- Determine the most frequent value.

- Find the smallest run of that most frequent value.

- Output the size of that run.

- If the array is already not beautiful, output -1.

To find the most frequent value, I can use a counter.

To find the smallest run, I need to iterate through the array and identify consecutive sequences of the most frequent value and find the minimum length among them.

Edge cases to consider:

- n == 1: already not beautiful, output -1.

- n == 2:

- If a[0] == a[1]: beautiful. Need to remove enough elements so that it's not beautiful.

- If a[0] != a[1]: already not beautiful, output -1.

- All elements are the same: cannot make it not beautiful by removal, output -1.

- Arrays where the most frequent value has multiple runs with different lengths.

- Arrays where removing the smallest run isn't sufficient to make it not beautiful.

Wait, in the fourth example, according to my earlier thought, removing the smallest run of 3's (size 3) makes it not beautiful.

But in reality, removing two 3's also makes it not beautiful.

So, perhaps my approach is not optimal.

Wait, maybe I need to remove enough elements to ensure that no operation can make the array uniform.

In other words, ensure that after removal, there are at least two distinct values,