Alright, I've got this problem to solve. Let's see what it's asking for. So, Vladislav has a binary square grid of n by n cells, and on this grid, there's either a triangle or a square drawn with '1's. I need to determine which shape is drawn based on the grid provided.

First, I need to understand what constitutes a triangle and a square in this context.

For a triangle:

- It's made up of k rows (k > 1), where each row i has 2*i - 1 '1's.

- These '1's are centered in such a way that they form a triangle.

- There's also an "upside-down" triangle, which is also valid.

So, for example, if k=3, the triangle would look like:

Row 1: 1 '1'

Row 2: 3 '1's

Row 3: 5 '1's

Or upside down:

Row 1: 5 '1's

Row 2: 3 '1's

Row 3: 1 '1'

Got it.

For a square:

- It's made up of k rows (k > 1), each with exactly k '1's.

- These '1's are positioned at an equal distance from the left edge.

So, for k=3, it would be:

Row 1: '111'

Row 2: '111'

Row 3: '111'

All '1's aligned in columns.

Now, the problem says that the grid contains exactly one triangle or one square, and it's guaranteed that the shape is larger than 1 '1'.

Input:

- First line: number of test cases, t.

- For each test case:

- First line: n (2 <= n <= 10), size of the grid.

- Next n lines: n characters of '0's and '1's.

Output:

- For each test case, print "SQUARE" or "TRIANGLE" based on the shape.

Looking at the provided program:

def func():

a = int(input())

for i in range(a):

k = []

for _ in range(int(input())):

b = input()

if '1' in b:

k.append(b.count('1'))

if k[0] == k[1]:

print(k)

Wait, this seems incomplete. It's reading the input, counting the number of '1's in each row that contains at least one '1', and then checking if the first two counts are equal. But this doesn't seem to fully solve the problem.

Let me think about how to approach this correctly.

First, for each test case, I need to analyze the grid to determine if the '1's form a square or a triangle.

I need to consider both triangles and upside-down triangles.

For a square, it's straightforward: all rows in the shape should have the same number of '1's, and this number should be equal to the number of rows.

For a triangle, the number of '1's in each row should follow the pattern 1, 3, 5, etc., or in the upside-down case, decreasing from the largest odd number.

So, my plan is:

1. For each test case, read n and then read n rows of the grid.

2. Collect all rows that contain at least one '1'.

3. Determine if these rows form a square or a triangle.

For square detection:

- All rows in the shape should have the same number of '1's.

- The number of such rows should be equal to the number of '1's in each row.

For triangle detection:

- The number of '1's in each row should form a sequence like 1,3,5,... or decreasing like 5,3,1, etc.

So, in the program provided, it's collecting the count of '1's in each row that has at least one '1', and then checking if the first two counts are equal. But this is not sufficient.

For example, in a square of size 3, all three rows should have exactly 3 '1's.

In a triangle of size 3, the rows should have 1,3,5 '1's, but since n=3, it's not possible to have 5 '1's in a row, so perhaps k is limited by n.

Wait, but n can be up to 10, so k can be up to 10.

I need to generalize this.

Let me think about how to implement this.

First, collect all rows that contain '1's.

Let's say we have m such rows.

For square:

- All m rows should have exactly m '1's.

For triangle:

- The counts should form an increasing sequence of odd numbers starting from 1, or a decreasing sequence.

But, in the problem statement, it shows that for a triangle, it's k rows with 2*i -1 '1's, where i is from 1 to k.

So, for k=3, counts should be 1,3,5.

But, in the grid, n can be larger than k, so there might be rows with '0's only.

Wait, no, the problem says the grid contains exactly one triangle or one square, and it's guaranteed that the shape is larger than 1 '1'.

So, I need to consider only the rows that have '1's.

In the provided code, it's collecting counts of '1's in rows that have at least one '1', storing them in list k.

Then, it checks if k[0] == k[1]. That seems insufficient.

I need to improve this.

Let me think about properties.

For square:

- All rows in the shape have exactly k '1's, and there are k such rows.

For triangle:

- Rows have 1,3,5,... '1's, or 5,3,1, etc., depending on whether it's normal or upside down.

So, for triangle, the counts should be strictly increasing or decreasing sequence of odd numbers.

For square, all counts should be equal to the number of rows.

So, in code, for each test case:

- Read n.

- Read n rows.

- Collect rows that have '1's.

- Let m be the number of such rows.

- Count the number of '1's in each of these m rows.

- For square: check if all counts are equal to m.

- For triangle: check if counts form an increasing or decreasing sequence of odd numbers with step 2.

If square conditions are met, print "SQUARE".

Else, if triangle conditions are met, print "TRIANGLE".

Need to implement this logic.

The provided code is incomplete and incorrect because it only checks if the first two counts are equal, which is not sufficient for determining a square or a triangle.

Hence, the given program is incorrect.

So, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]