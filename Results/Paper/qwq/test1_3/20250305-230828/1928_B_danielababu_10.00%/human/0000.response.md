Alright, I have this problem to solve. Let's read it carefully.

Vasya has an array `a` of length `n`, and he can add to it any permutation of length `n`. So, he chooses a permutation `p` and adds it to `a` element-wise: `a_i := a_i + p_i`. After this operation, he wants to find the maximum number of elements in the array that are equal to the same number.

My task is to determine the maximum value of such frequency for each test case.

First, I need to understand what a permutation is. A permutation of length `n` is a sequence containing each number from 1 to `n` exactly once, in any order. For example, for `n=3`, possible permutations are [1,2,3], [3,1,2], [2,3,1], etc.

Given that, I need to choose a permutation `p` such that when I add it to `a`, some elements of `a` become equal, and I need to maximize the frequency of any single value in the resulting array.

Let me think about how to approach this.

Suppose I have an array `a = [a1, a2, ..., an]`, and I add a permutation `p = [p1, p2, ..., pn]`, where `p` is some permutation of 1 to n.

The resulting array will be `[a1+p1, a2+p2, ..., an+pn]`.

I need to maximize the number of elements in this resulting array that are equal to some value `x`.

Let me consider what values `x` can take. Since `p_i` ranges from 1 to n, `x` can be anywhere from `a_i + 1` to `a_i + n`, for each `i`.

But I need to choose `p` such that as many `a_i + p_i` as possible are equal to the same `x`.

This sounds tricky. Maybe I can look for a way to make `a_i + p_i` equal for as many `i` as possible.

Let's consider that `a_i + p_i = x` for some `x`. Then, for each `i`, `p_i = x - a_i`.

But `p_i` must be a permutation of 1 to n, so `x - a_i` must be an integer between 1 and n, inclusive.

Therefore, for each `i`, `x` must be in the range `a_i + 1` to `a_i + n`.

Now, since `p` is a permutation, all `p_i` must be distinct. So, if I choose `x` such that multiple `p_i = x - a_i` are the same, that would violate the permutation property.

Wait, no. Since `p_i` must all be distinct, `x - a_i` must all be distinct.

But I want as many `a_i + p_i` as possible to be equal to `x`. So, I need to have as many `i` as possible where `a_i + p_i = x`, which implies `p_i = x - a_i`.

But since `p_i` must all be distinct, `x - a_i` must all be distinct for those `i` where `a_i + p_i = x`.

Wait, that seems contradictory. If `p_i = x - a_i`, and `p_i` must be distinct, then `x - a_i` must be distinct for those `i`.

So, if I have multiple `i` with `a_i + p_i = x`, then `p_i = x - a_i` must all be distinct.

But if `x - a_i` are distinct for different `i`, that means that for those `i`, `p_i` are distinct, which is fine.

But I need to choose `x` such that as many `i` as possible satisfy `p_i = x - a_i`, with `p_i` being a distinct permutation from 1 to n.

So, perhaps I need to find an `x` such that the values `x - a_i` are as many as possible within the range 1 to n, and distinct.

Wait, but I need to maximize the number of `i` where `a_i + p_i = x`, given that `p_i` is a permutation of 1 to n.

Alternatively, perhaps I should think in terms of sorting.

Let me consider sorting the array `a`. Maybe that can help.

Suppose I sort `a` in ascending order: `a_sorted`.

Then, I need to choose `p` such that `a_sorted[i] + p_i = x` for as many `i` as possible.

But `p` is a permutation of 1 to n, so `p_i` are distinct integers from 1 to n.

So, for each `i`, `p_i = x - a_sorted[i]`.

For `p_i` to be a valid permutation, `x - a_sorted[i]` must be distinct and within 1 to n.

To maximize the number of `i` where `a_sorted[i] + p_i = x`, I need to choose `x` such that as many `x - a_sorted[i]` as possible are distinct integers between 1 and n.

Wait, perhaps I can fix `x` and see how many `i` satisfy `x - a_sorted[i]` is between 1 and n, and all `x - a_sorted[i]` are distinct.

But this seems a bit convoluted.

Let me think differently.

Suppose I fix `x`, and for each `i`, compute `p_i = x - a_i`.

Then, `p_i` must be distinct and within 1 to n.

So, for a fixed `x`, the number of valid `i` is the number of distinct `p_i` within 1 to n.

I need to choose `x` such that this number is maximized.

But I need to consider that `p_i` must be a permutation, meaning all `p_i` are distinct and within 1 to n.

Wait, but I'm dealing with multiple `i`, and for each `i`, `p_i = x - a_i`.

So, for different `i`, `x - a_i` must be distinct and within 1 to n.

Therefore, for a fixed `x`, the number of valid `i` is the number of distinct `x - a_i` that lie between 1 and n.

But I need to maximize this over all possible `x`.

This seems tricky.

Maybe I can look at it differently.

Let me consider that `p_i` is a permutation of 1 to n.

So, the set of `p_i` is exactly {1, 2, ..., n}.

Now, I need to maximize the number of `i` where `a_i + p_i = x`, for some `x`.

In other words, I need to maximize the frequency of some value `x` in the array `a + p`.

To maximize the frequency, I need to maximize the number of pairs `(i, x)` such that `a_i + p_i = x`.

But `p_i` are distinct and range from 1 to n.

So, for each `i`, `p_i` is unique.

I need to assign `p_i` to maximize the number of `i` where `a_i + p_i = x`, for some `x`.

This seems like I need to assign `p_i` such that as many `a_i + p_i` as possible are equal to `x`.

But `p_i` are a permutation of 1 to n, so each `p_i` is used exactly once.

This is getting complicated.

Let me try to think about small examples to get some intuition.

Take the first test case from the example:

n = 2

a = [1, 2]

Possible permutations p: [1,2] and [2,1]

Option 1: p = [1,2]

Then a becomes [1+1, 2+2] = [2,4]

Frequencies: 2 appears once, 4 appears once. Maximum frequency is 1.

Option 2: p = [2,1]

Then a becomes [1+2, 2+1] = [3,3]

Frequencies: 3 appears twice. Maximum frequency is 2.

So, the maximum frequency is 2.

In this case, it's possible to make all elements equal.

But in the second test case:

n = 4

a = [7,1,4,1]

Possible permutation p: [1,2,3,4]

Option 1: p = [1,2,3,4]

Then a becomes [8,3,7,5]

Frequencies: 8 appears once, 3 appears once, 7 appears once, 5 appears once. Max frequency is 1.

Option 2: p = [4,3,2,1]

Then a becomes [11,4,6,2]

Frequencies: 11 appears once, 4 appears once, 6 appears once, 2 appears once. Max frequency is 1.

Option 3: p = [2,3,4,1]

Then a becomes [9,4,8,2]

Frequencies: 9 appears once, 4 appears once, 8 appears once, 2 appears once. Max frequency is 1.

Wait, but according to the example, with p = [2,3,1,4], a becomes [9,4,5,5], so 5 appears twice. Max frequency is 2.

Okay, so it's possible to get a frequency of 2.

Is it possible to get higher than that?

Let's see.

Is there a way to make three elements equal?

Suppose I try to make three elements equal to some x.

Then, for three different i, j, k, we need a_i + p_i = a_j + p_j = a_k + p_k = x.

Which implies p_i = x - a_i, p_j = x - a_j, p_k = x - a_k.

Since p_i must be distinct, x - a_i, x - a_j, x - a_k must all be distinct.

Also, p_i must be between 1 and n.

In this case, n=4.

So, p_i are from 1 to 4.

Let's see if we can find x such that x - a_i, x - a_j, x - a_k are all distinct and within 1 to 4.

Given a = [7,1,4,1]

Suppose we choose x=5.

Then p_i = 5 - 7 = -2 (invalid, not in 1 to 4)

p_j = 5 - 1 = 4

p_k = 5 - 4 = 1

p_l = 5 - 1 = 4 (but 4 is already used for p_j, so invalid)

So, only two elements can be made 5.

Hence, frequency 2 is the maximum possible.

Similarly, for other x values.

So, in this case, the answer is 2.

Another test case:

n=3

a=[103,102,104]

Possible permutation p=[1,2,3]

Option 1: p=[1,2,3]

a becomes [104,104,107]

Frequencies: 104 appears twice, 107 appears once. Max frequency is 2.

Option 2: p=[3,1,2]

a becomes [106,103,106]

Frequencies: 106 appears twice, 103 appears once. Max frequency is 2.

Option 3: p=[2,3,1]

a becomes [105,105,105]

Wait, 105 appears three times. So, max frequency is 3.

But according to the example output, it's 3.

So, it's possible to make all three elements equal to 105 by choosing p=[2,3,1].

So, in this case, the maximum frequency is 3.

Another test case:

n=5

a=[1,101,1,100,1]

Possible permutation p=[1,2,3,4,5]

Option 1: p=[1,2,3,4,5]

a becomes [2,103,4,104,6]

Frequencies: 2,103,4,104,6, all appear once.

Option 2: p=[3,4,5,1,2]

a becomes [4,105,6,101,3]

Frequencies: 4,105,6,101,3, all appear once.

Option 3: p=[5,1,2,3,4]

a becomes [6,102,3,103,5]

Frequencies: 6,102,3,103,5, all appear once.

But according to the example, the answer is 2.

Wait, perhaps I can make two elements equal.

For example, p=[2,1,3,4,5]

a becomes [3,102,4,104,6]

Frequencies: 3 appears once, 102 once, 4 once, 104 once, 6 once.

Wait, still 1.

Another option: p=[4,3,5,1,2]

a becomes [5,104,8,101,3]

Frequencies: all unique.

Wait, maybe p=[3,2,1,4,5]

a becomes [4,103,2,104,6]

Frequencies: 4 once, 103 once, 2 once, 104 once, 6 once.

Still 1.

Wait, but the example says the answer is 2, so perhaps I'm missing something.

Wait, maybe p=[4,5,1,2,3]

a becomes [5,106,2,102,4]

Here, 5,106,2,102,4 are all unique.

Wait, maybe p=[5,4,3,1,2]

a becomes [6,105,4,101,3]

All unique.

Wait, perhaps p=[2,4,1,3,5]

a becomes [3,105,2,103,6]

All unique.

Wait, maybe p=[3,1,2,4,5]

a becomes [4,102,4,104,6]

Now, 4 appears twice, 102 once, 104 once, 6 once.

So, frequency is 2.

Ah, there we go. So, the maximum frequency is 2.

Hence, the answer is 2.

Okay, so in this case, it's possible to have two elements equal, but not more.

Another test case:

n=5

a=[1,10,100,1000,1]

Possible permutation p=[1,2,3,4,5]

Option 1: p=[1,2,3,4,5]

a becomes [2,12,103,1004,6]

All unique.

Option 2: p=[5,4,3,2,1]

a becomes [6,14,103,1002,2]

Frequencies: all unique.

Option 3: p=[2,1,4,3,5]

a becomes [3,11,104,1003,6]

All unique.

Option 4: p=[3,5,1,2,4]

a becomes [4,15,101,1002,5]

All unique.

Wait, maybe it's not possible to have any duplicates.

Wait, but according to the example, the answer is 1.

So, in this case, the maximum frequency is 1.

Another test case:

n=2

a=[3,1]

Possible permutations p=[1,2] and [2,1]

Option 1: p=[1,2]

a becomes [4,3]

Frequencies: 4 once, 3 once.

Option 2: p=[2,1]

a becomes [5,2]

Frequencies: 5 once, 2 once.

So, maximum frequency is 1.

Hence, the answer is 1.

Last test case:

n=3

a=[1000000000,999999997,999999999]

Possible permutations p=[1,2,3]

Option 1: p=[1,2,3]

a becomes [1000000001,999999999,1000000002]

Frequencies: all unique.

Option 2: p=[2,1,3]

a becomes [1000000002,999999998,1000000002]

Now, 1000000002 appears twice, 999999998 once.

So, frequency is 2.

Option 3: p=[3,2,1]

a becomes [1000000003,999999999,1000000000]

Frequencies: all unique.

Option 4: p=[1,3,2]

a becomes [1000000001,999999999,1000000001]

Now, 1000000001 appears twice, 999999999 once.

So, frequency is 2.

Hence, the maximum frequency is 2.

From these examples, it seems that the maximum frequency depends on how many elements can be made equal by choosing an appropriate permutation p.

Now, I need to find a general approach to solve this for any given n and a.

Looking back at the problem, I need to maximize the frequency of any value x in the array after adding a permutation p to a.

Given that p is a permutation of 1 to n, each p_i is unique and lies between 1 and n.

So, for each i, a_i + p_i = x, which implies p_i = x - a_i.

For p_i to be a valid permutation, x - a_i must be unique for each i and lie between 1 and n.

Therefore, for a fixed x, the number of i such that x - a_i is unique and between 1 and n is the number of i where p_i = x - a_i is valid.

To maximize the frequency, I need to choose x such that as many i as possible satisfy x - a_i is unique and within 1 to n.

In other words, I need to choose x such that the number of i where x - a_i is in [1, n] and all x - a_i are distinct is maximized.

This sounds like finding the maximum number of unique x - a_i that lie within 1 to n.

This seems similar to finding the maximum number of a_i such that a_i = x - p_i, where p_i is a permutation of 1 to n.

Wait, perhaps I can think in terms of shifting a_i by p_i.

Alternatively, perhaps I can sort a_i and consider assigning p_i in a way that maximizes the frequency.

Wait, maybe I can sort a_i and assign p_i in a specific order.

Let me try sorting a.

Suppose I sort a in ascending order: a_sorted.

Then, assign p_i in a way that a_sorted[i] + p_i = x.

So, p_i = x - a_sorted[i].

To maximize the frequency, I need as many p_i as possible to be within 1 to n and distinct.

So, for a given x, the number of valid i is the number of distinct x - a_sorted[i] that lie between 1 and n.

I need to choose x to maximize this number.

This seems like I need to find x such that the number of p_i = x - a_sorted[i] that are distinct and within 1 to n is maximized.

This sounds similar to finding the x that covers the most a_sorted[i] such that x - a_sorted[i] is a unique value between 1 and n.

This is getting complicated.

Maybe I can look at the difference between the elements.

Wait, perhaps I can look at the frequency of a_i + p_i.

But p_i is a permutation of 1 to n, so p_i are distinct.

So, a_i + p_i = x implies p_i = x - a_i.

For p_i to be distinct, x - a_i must be distinct.

Also, p_i must be between 1 and n.

So, for each i, x - a_i must be unique and in [1, n].

Therefore, for a fixed x, the number of i where x - a_i is unique and in [1, n] is the number of i where p_i = x - a_i is valid.

To maximize the frequency, I need to maximize the number of such i for any x.

This seems like I need to find the x that allows the maximum number of valid p_i = x - a_i.

Alternatively, perhaps I can look at the differences between a_i and a_j.

Wait, maybe I can consider the a_i's and see how they can be adjusted by p_i to coincide at some x.

Let me think about the minimal and maximal possible a_i + p_i.

The minimal a_i + p_i is a_i + 1.

The maximal a_i + p_i is a_i + n.

So, for each i, a_i + p_i lies in [a_i + 1, a_i + n].

I need to find an x that lies in the intersection of as many [a_i + 1, a_i + n] as possible.

Wait, but the intervals [a_i + 1, a_i + n] may overlap for different i.

So, perhaps I need to find the x that lies in the maximum number of these intervals.

This sounds like finding the x that is in the intersection of the most intervals [a_i + 1, a_i + n].

This can be solved using a sweep line algorithm, where I keep track of the number of intervals that contain each x.

But given the constraints (n up to 2e5 per test case, and t up to 2e4), this approach may be too slow if implemented naively.

I need a more efficient way.

Let me think differently.

Suppose I sort the a_i's in ascending order.

Let's sort a: a_sorted.

Now, I need to assign p_i's to a_sorted[i] such that a_sorted[i] + p_i = x.

So, p_i = x - a_sorted[i].

Since p_i must be a permutation of 1 to n, p_i must be distinct and in [1, n].

To maximize the frequency, I need to maximize the number of i where p_i = x - a_sorted[i] is valid.

But x is the same for all these i.

Wait, perhaps I can fix x and see how many i satisfy x - a_sorted[i] is in [1, n] and all x - a_sorted[i] are distinct.

But this seems too slow for large n.

Is there a smarter way?

Let me consider that for a given x, the p_i = x - a_i must be distinct and in [1, n].

So, for a given x, the number of valid i is equal to the number of unique x - a_i that lie in [1, n].

But I need to maximize this over all x.

This seems similar to finding the x that maximizes the number of unique x - a_i in [1, n].

This is getting too abstract.

Let me consider another approach.

Suppose I sort a in ascending order: a_sorted.

Then, assign p_i in a way that a_sorted[i] + p_i is as concentrated as possible.

Since p_i is a permutation of 1 to n, perhaps I can assign the smallest p_i to the largest a_sorted[i], to minimize the spread of a_sorted[i] + p_i.

Wait, but I need to maximize the frequency of a particular value.

Alternatively, maybe I can assign p_i such that a_sorted[i] + p_i is as close as possible to some central value.

But I'm not sure.

Wait, perhaps I can look at the differences a_i - a_j.

If a_i - a_j = c, then to have a_i + p_i = a_j + p_j, we need p_i - p_j = c.

But p_i and p_j are distinct and in [1, n].

So, p_i - p_j = c implies that the difference between p_i and p_j is c.

But since p is a permutation, the differences between p_i and p_j can be at most n - 1, and at least 1.

This seems complicated.

Let me try to think about the maximum frequency possible.

In the best case, if all a_i are equal, then I can choose p_i such that a_i + p_i is the same for all i, by choosing p_i = x - a_i for some x.

But since p_i must be a permutation, p_i must be distinct.

So, if all a_i are equal, then p_i = x - a_i would be the same for all i, which is only possible if n = 1.

For n >= 2, it's impossible to have all p_i equal, so I can't have all a_i + p_i equal.

Hence, for n >= 2 and all a_i equal, the maximum frequency is n - something.

Wait, no, for n=2 and a=[1,1], I can choose p=[1,2], so a becomes [2,3], frequency 1.

Or p=[2,1], a becomes [3,2], frequency 1.

So, maximum frequency is 1.

Wait, but according to the problem, n >=1.

Wait, in the first test case, n=2, a=[1,2], and with p=[2,1], a becomes [3,3], frequency 2.

So, when a_i are distinct, it's possible to make a_i + p_i equal for all i.

Wait, but in the case where a_i are all equal, it's impossible to make a_i + p_i equal for all i when n >=2.

Hence, the maximum frequency depends on how similar the a_i's are.

If all a_i are equal, maximum frequency is 1 for n >=2.

Wait, no, in the third test case, n=3, a=[103,102,104], and with p=[2,3,1], a becomes [105,105,105], frequency 3.

So, when a_i's are almost equal, it's possible to make them equal by choosing appropriate p_i.

Wait, but in this case, a=[103,102,104], p=[2,3,1], so 103+2=105, 102+3=105, 104+1=105.

So, p_i's are chosen such that p_i = 105 - a_i.

So, p_i's are 105-103=2, 105-102=3, 105-104=1, which are [2,3,1], a valid permutation.

Hence, in this case, all three elements can be made equal to 105.

So, the maximum frequency is 3.

But in other cases, it's lower.

Looking back, perhaps the maximum frequency is equal to the minimal frequency of a_i's after adjusting with p_i.

Wait, that doesn't sound right.

Alternatively, perhaps it's related to the frequency of the median or something similar.

I need a better approach.

Let me consider sorting a in ascending order: a_sorted.

Then, assign p_i in descending order to a_sorted[i], so p_i = n - i + 1, where i is from 1 to n.

Wait, but p_i must be a permutation of 1 to n.

Alternatively, maybe assign the smallest p_i to the largest a_sorted[i], to minimize the spread.

But I'm not sure.

Wait, perhaps I can look at the problem as trying to make a_i + p_i as concentrated as possible.

To do that, I can try to minimize the range of a_i + p_i.

Since p_i is a permutation of 1 to n, the minimal possible a_i + p_i is a_i + 1, and the maximal is a_i + n.

So, the range is from min(a_i) + 1 to max(a_i) + n.

I need to choose p_i such that as many a_i + p_i as possible are equal within this range.

Alternatively, perhaps I can look at the differences a_i - a_j and see how they relate to p_i - p_j.

Wait, a_i + p_i = a_j + p_j implies p_i - p_j = a_j - a_i.

Since p_i - p_j can take values from -(n-1) to n-1, but p_i are distinct, p_i - p_j are unique differences.

This seems too involved.

Let me consider another angle.

Suppose I fix x and try to find the number of i where a_i + p_i = x, with p_i being a permutation of 1 to n.

This is equivalent to finding the number of i where p_i = x - a_i, with p_i being distinct and in [1, n].

So, for a fixed x, the number of valid i is equal to the number of unique x - a_i that lie in [1, n].

I need to maximize this over all x.

To do this efficiently, perhaps I can consider the range of possible x.

Since x = a_i + p_i, and p_i is from 1 to n, x lies in [min(a_i) + 1, max(a_i) + n].

So, I can iterate over x in this range and find the number of i where x - a_i is unique and in [1, n].

But with n up to 2e5, this is too slow.

I need a smarter way.

Let me consider the frequency of x - a_i for all i.

I need to choose x such that the number of unique x - a_i that are in [1, n] is maximized.

Wait, but x - a_i can be any value depending on x.

This seems too vague.

Let me think about it differently.

Suppose I sort a in ascending order: a_sorted.

Then, assign p_i from 1 to n in some order.

I need to maximize the frequency of a_sorted[i] + p_i.

To maximize the frequency, perhaps I should assign p_i such that a_sorted[i] + p_i is as concentrated as possible.

One way to do this is to assign p_i such that a_sorted[i] + p_i is equal to a_sorted[j] + p_j for as many i and j as possible.

But how?

Wait, perhaps I can assign p_i to minimize the differences a_sorted[i] + p_i.

Since a_sorted is sorted, assigning smaller p_i to larger a_sorted[i] might help concentrate the sum.

Wait, maybe assigning p_i = n - i + 1 to a_sorted[i], so that larger a_sorted[i] get smaller p_i.

Let's try with the third test case:

n=3

a_sorted = [102,103,104]

Assign p_i = [2,3,1]

So, a_sorted[0] + p_0 = 102 + 2 = 104

a_sorted[1] + p_1 = 103 + 3 = 106

a_sorted[2] + p_2 = 104 + 1 = 105

In this case, all sums are different.

But in the example, with p=[2,3,1], it's [104,106,105], all different.

Wait, but in the earlier step, with p=[2,3,1], it was [105,105,105], which is different.

Wait, perhaps I miscalculated.

Wait, in the third test case, a=[103,102,104], and p=[2,3,1], so:

103 + 2 = 105

102 + 3 = 105

104 + 1 = 105

All three sums are 105.

So, frequency is 3.

So, in this case, assigning p_i in a specific way allowed all sums to be equal.

Is there a general pattern here?

Another test case:

n=5

a=[1,101,1,100,1]

Sort a: [1,1,1,100,101]

Assign p=[2,3,4,1,5]

Then sums are:

1+2=3

1+3=4

1+4=5

100+1=101

101+5=106

Frequencies: 3,4,5,101,106, all unique.

Another assignment: p=[3,4,5,1,2]

Sums: 4,5,6,101,103

All unique.

Wait, but earlier I saw that with p=[4,3,5,1,2], it was [5,4,8,101,3], frequencies: 5,4,8,101,3, all unique.

Wait, perhaps in this case, it's not possible to have frequency higher than 2.

Wait, but earlier I saw with p=[4,3,5,1,2], a becomes [5,4,8,101,3], all unique.

Wait, but in the earlier step, with p=[3,2,1,4,5], a becomes [4,3,2,104,6], frequencies: all unique.

Wait, perhaps it's not possible to have frequency higher than 2 in this case.

Hence, the answer is 2.

So, maybe in this case, the maximum frequency is 2.

Wait, but according to the example, the answer is 2.

So, perhaps in general, the maximum frequency is equal to the minimal number of overlaps possible.

Wait, I need a better approach.

Let me look for a mathematical way to determine the maximum frequency without enumerating all possibilities.

Given that p is a permutation of 1 to n, the set of p_i is exactly {1,2,...,n}.

So, for a given x, the number of i where a_i + p_i = x is equal to the number of i where p_i = x - a_i, with p_i being distinct and in {1,2,...,n}.

Hence, for a fixed x, the number of such i is equal to the number of unique x - a_i that lie in {1,2,...,n}.

To maximize this over x, I need to find the x that maximizes the number of unique x - a_i in {1,2,...,n}.

This seems similar to finding the x that covers the most a_i's such that x - a_i is a unique value in {1,2,...,n}.

This sounds like finding the x that allows the maximum number of p_i = x - a_i to be distinct and within {1,2,...,n}.

This is essentially finding the x that maximizes the size of the set {x - a_i | x - a_i âˆˆ {1,2,...,n}}.

To maximize this, I need to choose x such that as many x - a_i as possible are distinct and within {1,2,...,n}.

This seems tricky to compute directly, especially for large n.

I need a more efficient way.

Let me consider the frequency of x - a_i for each i.

I can think of x - a_i as offsets that must be unique and in {1,2,...,n}.

So, for each a_i, x - a_i must be in {1,2,...,n}, and all x - a_i must be distinct.

Hence, for a fixed x, the number of i where x - a_i is in {1,2,...,n} and all x - a_i are distinct is at most n.

But I need to maximize the number of such i over all possible x.

Wait, but x is a variable I can choose.

Let me consider that for each i, x - a_i must be in {1,2,...,n}, which implies that x lies in [a_i + 1, a_i + n].

So, for each i, there is an interval of x where x - a_i is in {1,2,...,n}.

Hence, the problem reduces to finding an x that lies in the maximum number of intervals [a_i + 1, a_i + n].

This is a classic problem in algorithm design, known as finding the maximum coverage in a set of intervals.

To solve this efficiently, I can use a sweep line algorithm.

Here's how it works:

- For each a_i, define the interval [a_i + 1, a_i + n].

- Find the x that lies in the maximum number of these intervals.

To implement this efficiently, I can sort the left and right endpoints of all intervals and then sweep through them to find the maximum overlap.

Here's a step-by-step plan:

1. Initialize two lists: starts and ends.

2. For each a_i, do:

- left = a_i + 1

- right = a_i + n

- Add left to the starts list

- Add right to the ends list

3. Sort both starts and ends.

4. Initialize two pointers, current = 0, max_freq = 0, count = 0.

5. Iterate through all events (starts and ends sorted):

- If the current event is a start, increment count.

- If the current event is an end, decrement count.

- Keep track of the maximum count.

This will give me the maximum number of intervals that overlap at any point x.

Wait, but in this approach, I need to distinguish between starts and ends.

So, I should sort all the start and end points, and as I sweep through them, I increment count when I hit a start and decrement when I hit an end.

The maximum count during this process will be the maximum number of overlapping intervals.

This is a standard sweep line algorithm for interval coverage.

Implementing this should be efficient enough, as n can be up to 2e5, and t can be up to 2e4, but since the sum of n over all test cases is up to 2e5, the total time should be acceptable.

Hence, in code, for each test case, I can:

- Read n and a.

- For each a_i, define the interval [a_i + 1, a_i + n].

- Use the sweep line algorithm to find the maximum number of overlapping intervals.

Implementing the sweep line algorithm:

- Collect all start and end points.

- Sort them.

- Iterate through the sorted list, keeping a counter for the number of active intervals.

- Keep track of the maximum counter value.

However, to implement this efficiently, I need to handle the starts and ends separately, marking them as such.

In code, I can represent each event as a tuple (position, event_type), where event_type is 0 for start and 1 for end.

Then, sort all events by position, and for same positions, process starts before ends.

Then, iterate through the sorted events, incrementing count on start and decrementing on end, while keeping track of the maximum count.

This should work.

Let me test this approach with the first test case.

Test case 1:

n=2

a=[1,2]

Intervals:

For a=1: [1+1,1+2] = [2,3]

For a=2: [2+1,2+2] = [3,4]

Possible x values:

x=2: lies in [2,3] (a=1), not in [3,4] (a=2) -> count=1

x=3: lies in [2,3] and [3,4] -> count=2

x=4: lies in [3,4] -> count=1

Hence, maximum overlap is 2, which matches the first test case.

Another test case:

n=4

a=[7,1,4,1]

Intervals:

a=7: [7+1,7+4]=[8,11]

a=1: [1+1,1+4]=[2,5]

a=4: [4+1,4+4]=[5,8]

a=1: [1+1,1+4]=[2,5]

Possible x values:

x=2: [2,5] (a=1 and a=1) -> count=2

x=3: [2,5] (a=1 and a=1), [5,8] (a=4) if x=5 -> count=3

Wait, for x=5: lies in [2,5] (a=1 and a=1), [5,8] (a=4), [8,11] (a=7) if x=8.

Wait, at x=5:

- [2,5] (a=1 and a=1): x=5 is in both intervals for a=1

- [5,8] (a=4): x=5 is in this interval

- [8,11] (a=7): x=5 is not in this interval

So, at x=5, it lies in three intervals: two for a=1 and one for a=4.

But since a=1 has two intervals, but they are the same interval, so it's still count=3.

But in reality, since a=1 has two elements with the same interval, it's still count=3.

Hence, maximum overlap is 3.

But according to the example, the answer is 2.

Wait, perhaps because for x=5, p_i = x - a_i must be unique.

So, for a=1, p_i =5-1=4

For a=1, p_i=5-1=4 (but already used)

For a=4, p_i=5-4=1

For a=7, not in [8,11]

So, only two p_i can be assigned to x=5: p_i=4 and p_i=1.

Hence, only two elements can have a_i + p_i =5.

Hence, frequency is 2.

So, perhaps my initial approach is missing this uniqueness constraint for p_i.

Wait, in the sweep line approach, I'm counting the number of intervals x lies in, but I need to ensure that for each interval, the p_i =x - a_i is unique.

Hence, the sweep line approach gives the potential maximum overlap, but I need to ensure that the p_i's are unique.

So, perhaps I need to adjust my approach to account for the uniqueness of p_i.

This complicates things.

Let me think about how to handle this.

Suppose I have x, and I have multiple a_i's such that x - a_i is in [1,n], but I can only choose one of them because p_i must be unique.

Hence, for each x, the number of p_i =x - a_i that are unique and in [1,n] corresponds to the number of a_i's where x - a_i is in [1,n], but with the constraint that x - a_i are distinct.

Wait, but x - a_i must be distinct because p_i must be distinct.

So, for a given x, the number of a_i's where x - a_i is in [1,n] and all x - a_i are distinct is equal to the number of unique x - a_i in [1,n].

But x - a_i must be distinct across all i.

Wait, no.

Wait, for a given x, I can choose only those i where x - a_i is in [1,n], and among those, p_i =x - a_i must be unique.

Hence, for each x, the number of a_i's where x - a_i is in [1,n], but since p_i must be unique, I can only choose one p_i for each value of x - a_i.

Hence, for each x, the number of a_i's where x - a_i is in [1,n] and x - a_i are