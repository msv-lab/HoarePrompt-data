Alright, I have this problem to solve. Let's see what it's about.

So, there are n cows with unique ratings, each in a specific position from 1 to n. They're participating in a coding tournament with n-1 matches. The matches are structured in a way where the first match is between cow 1 and cow 2, and then each subsequent match is between the winner of the previous match and the next cow in line.

The key point is that in each match, the cow with the higher rating wins and proceeds to the next match.

Now, I own cow k, and I want to maximize the number of wins for this cow. I have the option to swap my cow's position with another cow's position exactly once, or choose not to swap at all.

My goal is to find the maximum number of wins my cow can achieve with this opportunity to swap positions.

First, I need to understand how the tournament progresses based on the positions of the cows.

Let's consider the initial setup:

- Cows are in positions 1 to n.

- Match 1: Position 1 vs Position 2.

- Match 2: Winner of Match 1 vs Position 3.

- Match 3: Winner of Match 2 vs Position 4.

- And so on, until Match n-1.

In each match, the cow with the higher rating wins.

I need to see how my cow can participate in as many matches as possible, meaning it should keep winning to face more opponents.

But here's the thing: the tournament progresses in a specific order, and my cow's position affects when it enters the tournament.

If I don't swap, my cow is in position k, and it will first play in match k-1 against the winner of match k-2.

But if I swap my cow with another position, say position p, then my cow is in position p, and it will first play in match p-1 against the winner of match p-2.

So, swapping allows me to change when my cow enters the tournament.

My aim is to choose a position that allows my cow to win as many matches as possible.

Let me think about this step by step.

First, let's consider the scenario where I don't swap. My cow is in position k.

I need to simulate the tournament and count how many wins my cow achieves.

Then, I need to consider swapping my cow to other positions and see if that leads to more wins.

Finally, I choose the option that gives the maximum number of wins.

But considering that n can be up to 10^5 and t up to 10^4, with the sum of n over all test cases up to 10^5, I need an efficient solution, probably O(n) per test case.

Let me first think about how the tournament progresses.

The tournament is essentially a sequence of matches where the winner of the previous match faces the next cow in line.

This resembles a single-elimination tournament where the opponent changes in each round.

Given that all ratings are unique, there's a clear hierarchy: higher-rated cows win against lower-rated ones.

So, the cow with the highest rating will win all its matches until it faces a cow with a higher rating, but since all ratings are unique, it will only lose if it faces a cow with a higher rating.

Wait, but the problem states that all ratings are distinct, so there is a strict ordering.

My cow has a specific rating, and I want it to win as many matches as possible.

Each win means it defeats the opponent and proceeds to the next match.

So, the number of wins is equal to the number of opponents it defeats before losing.

I need to maximize this number by choosing its position optimally.

Let me consider the initial setup without any swaps.

In the initial setup, the tournament proceeds as follows:

- Match 1: Cow 1 vs Cow 2. The higher-rated cow wins.

- Match 2: Winner of Match 1 vs Cow 3.

- Match 3: Winner of Match 2 vs Cow 4.

- ...

- Match n-1: Winner of Match n-2 vs Cow n.

Now, if my cow is in position k, it will first participate in match k-1, assuming that the winner of match k-2 is available to play against it.

Wait, actually, in the described setup, each match i is between the winner of match i-1 and cow i+1.

So, match 1: cow 1 vs cow 2.

Then, match 2: winner of match 1 vs cow 3.

Match 3: winner of match 2 vs cow 4.

And so on.

So, my cow in position k would participate in match k-1.

I need to trace how many matches it can win from there.

But perhaps there's a better way to model this.

Let me think recursively or iteratively about the tournament.

Given the sequence of cows in positions 1 to n, with their ratings known, I can simulate the tournament and see how many wins my cow achieves in different positions.

But simulating the entire tournament for each test case would be too slow because n can be up to 10^5 and t up to 10^4, though the total sum of n over all test cases is up to 10^5, so that's manageable.

Still, I need an efficient way to compute the number of wins for my cow in different positions.

Let me consider that the tournament is essentially a series of challenges where the current champion (initially cow 1) faces the next cow in line, and the winner becomes the new champion.

This continues until all cows have been challenged.

My cow can be placed at any position, and I want to choose the position where it can maximize the number of wins before it loses.

Alternatively, perhaps there's a smarter way to calculate this without simulating the entire tournament.

Let me consider that my cow will keep winning as long as it has a higher rating than the cows it faces.

But the cows it faces are determined by the sequence of the tournament.

Wait, perhaps I can model this as my cow entering the tournament at a certain point and then seeing how far it can go.

But I need to consider that the previous matches have already determined the current champion up to that point.

Hmm.

Let me try to think differently.

Suppose I fix the position of my cow to be p.

Then, in the tournament, my cow will participate in match p-1, against the winner of match p-2.

I need to know who the winner of match p-2 is, which depends on the previous matches.

This seems recursive and potentially time-consuming.

Is there a way to precompute some information about the tournament?

Let me consider that in the initial sequence, the tournament progresses from left to right, with the winner accumulating wins as it proceeds.

If I can determine, for each position, who would be the winner up to that point, I might be able to calculate how many wins my cow can achieve if placed there.

Wait, perhaps I can find, for each position p, the strongest cow to the left of p, and see if my cow can defeat that cow.

But it's not straightforward.

Let me try to think about the number of wins my cow can achieve if placed at position p.

In order to maximize the number of wins, I need my cow to face as many cows as possible with lower ratings than itself.

Moreover, I need to consider that to reach match p-1, the winner of match p-2 must be able to be defeated by my cow.

This seems complicated.

Maybe I should look for a different approach.

Let me consider that the number of wins my cow can achieve is equal to the number of cows to its left that it can defeat, plus one if it can defeat the current champion up to that point.

Wait, perhaps I can iterate from left to right, keeping track of the maximum rating encountered so far, and see how many cows my cow can defeat consecutively starting from its position.

But I'm not sure.

Let me consider that if I place my cow at position p, then the number of wins it can achieve is equal to the number of cows to its right (including itself) that it can defeat, until it encounters a cow with a higher rating.

But I need to think carefully.

Wait, perhaps I can iterate from left to right, keeping track of the maximum rating seen so far, and for each position, determine if my cow can defeat that maximum rating.

But I'm getting confused.

Let me try to think in terms of the number of wins.

Each win corresponds to defeating one opponent.

So, if my cow is placed at position p, it will first face the winner of match p-1.

If it wins, it proceeds to face the next cow, and so on.

So, the number of wins is equal to the number of consecutive cows to the right of p-1 that it can defeat.

Wait, perhaps.

Let me try to formalize this.

If my cow is placed at position p, then it will participate in match p-1.

The opponent is the winner of match p-2.

If my cow wins against the winner of match p-2, it proceeds to match p, against cow p+1, and so on.

So, the number of wins is equal to the number of consecutive cows starting from p that my cow can defeat, assuming that it wins against the winner of match p-2.

This seems too vague.

Maybe I need to consider that the number of wins is equal to the number of cows to the right of p-1 that my cow can defeat, as long as my cow is stronger than the winner of match p-2.

But this still doesn't give me a clear way to compute it.

Perhaps I need to consider two scenarios:

1. My cow is placed at position p, and it defeats all cows from p to some point where it would lose.

2. My cow is placed at position p, but it doesn't defeat the winner of match p-2, so it doesn't even get to start winning.

This seems too involved.

Let me try to think differently.

Suppose I fix the position p for my cow.

Then, the number of wins my cow achieves is equal to the number of cows to the right of p-1 that it can defeat, as long as it can defeat the winner of match p-2.

Wait, perhaps I can precompute for each position p, who the winner of match p-2 is.

But this seems too time-consuming.

Let me consider that the tournament can be modeled as a stack or some kind of monotonic structure.

Given that higher-rated cows win, the tournament progresses by having higher-rated cows advance.

I need to see how my cow can be placed to maximize the number of wins.

Wait, perhaps I can iterate from left to right, keeping track of the maximum rating seen so far, and for my cow, determine how many consecutive cows to its right it can defeat.

But I need to make sure that it can defeat the cow that would be the champion up to its position.

Let me try to think in terms of the maximum rating to the left of each position.

If I have the maximum rating to the left of position p, and my cow's rating is higher than that, then my cow can defeat all the cows up to p.

Wait, perhaps.

Let me formalize this.

Let's define for each position p:

- left_max[p]: the maximum rating among cows from position 1 to p-1.

Then, if my cow is placed at position p, and its rating is higher than left_max[p], it can defeat all cows from p to the first cow with a rating higher than its own.

Otherwise, if its rating is lower than left_max[p], it cannot even start winning, so it wins 0 matches.

So, for each possible position p, I can:

- Compute left_max[p].

- If a_k > left_max[p], then count how many consecutive cows to the right of p-1 it can defeat.

This seems promising.

Now, to implement this efficiently, I need to:

1. Compute left_max[p] for all p from 1 to n.

2. For each possible p, if a_k > left_max[p], then count the number of consecutive cows starting from p that my cow can defeat.

3. Find the maximum among these counts.

But since n can be up to 10^5 and t up to 10^4, with the sum of n over all test cases up to 10^5, I need this to be O(n) per test case.

Computing left_max[p] is straightforward: it's a prefix maximum.

Then, for each possible p, I need to check if a_k > left_max[p], and if so, count the number of consecutive cows starting from p that my cow can defeat.

But checking for each p would be O(n), which is acceptable since the total sum of n is 10^5.

However, to optimize further, perhaps I can find a way to group positions p that have the same left_max[p] and compute the counts in a smarter way.

But maybe that's overcomplicating.

Let me try to formalize the algorithm.

Algorithm:

For each test case:

1. Read n, k, and the array a of size n.

2. Compute left_max[p] for p from 1 to n, where left_max[p] is the maximum rating among cows from position 1 to p-1.

   - left_max[1] = 0 (no cows to the left).

   - For p from 2 to n, left_max[p] = max(left_max[p-1], a[p-1]).

3. Initialize a variable max_wins = 0.

4. For each possible p from 1 to n:

   a. If p == k, calculate the number of wins without swapping (since swapping with itself is the same as not swapping).

   b. Else, calculate the number of wins if swapping my cow to position p.

   c. Update max_wins with the maximum of these values.

5. Output max_wins.

But this is O(n) per test case, which should be acceptable given the constraints.

Now, let's think about how to calculate the number of wins for a given p.

Given p, if a_k > left_max[p], then my cow can start winning from position p.

Then, count the number of consecutive cows starting from p that my cow can defeat, i.e., cows with rating less than a_k.

This can be done by finding the first cow to the right of p-1 with rating greater than a_k, and the number of wins is the number of cows from p to that position minus one.

Wait, more precisely:

- If p == k, then my cow is already at position p, and I don't need to swap.

- If p != k, then I need to swap my cow to position p, which means position k now has some other cow.

- But in the problem, when I swap, I choose to swap my cow with another cow's position, so position k now has the cow that was originally at position p.

Wait, I need to be careful about this.

Let me clarify:

- Original positions: 1 to n, with cow k at position k.

- If I choose to swap position p with position k, then:

  - Cow k moves to position p.

  - Cow p moves to position k.

- Then, the tournament proceeds with the new positions.

Wait, but in the problem, it's allowed to swap position k with any other position exactly once.

So, in terms of the array a, swapping a[k-1] with a[p-1].

Then, in the new array, a[k-1] is now the cow that was originally at position p, and a[p-1] is now my cow.

But actually, no: if I swap position k with position p, then a[k-1] becomes a[p-1], and a[p-1] becomes a[k-1].

Wait, in Python, list indices start from 0, so a[0] is position 1, a[1] is position 2, etc.

So, to swap positions p and k, I need to swap a[p-1] and a[k-1].

Then, in the new array, my cow is at position p, with rating a[k-1] (since it was swapped from position k to position p).

And the cow that was at position p is now at position k, with rating a[p-1].

Now, I need to simulate the tournament with this new array and count the number of wins for my cow, which is now at position p.

Wait, but in the problem, k is the index of my cow, and positions are from 1 to n.

So, in the original array, a[k-1] is my cow's rating.

If I choose to swap positions k and p, then a[k-1] and a[p-1] are swapped.

Then, in the new array, my cow is at position p, with rating a[k-1], and the cow that was at position p is now at position k, with rating a[p-1].

Now, I need to simulate the tournament with this new array and count how many wins my cow achieves.

But simulating the entire tournament for each possible p would be too slow.

So, I need a smarter way to calculate the number of wins for my cow at position p.

Let me consider that in the tournament, my cow at position p will first play against the winner of match p-1.

If p == 1, it plays against cow 2.

If p == 2, it plays against cow 1.

Wait, no.

According to the problem:

- Match 1: cow 1 vs cow 2.

- Match 2: winner of match 1 vs cow 3.

- Match 3: winner of match 2 vs cow 4.

- ...

- Match n-1: winner of match n-2 vs cow n.

So, in general, match i is between the winner of match i-1 and cow i+1.

Therefore, for my cow at position p, it will participate in match p-1, against the winner of match p-2.

Unless p == 1, in which case it plays against cow 2 in match 1.

Wait, perhaps it's better to think in terms of the current champion.

The tournament progresses as follows:

- Start with cow 1 as the current champion.

- In match 1, cow 1 vs cow 2; the winner becomes the new champion.

- In match 2, the current champion vs cow 3; the winner becomes the new champion.

- And so on, until match n-1, where the current champion vs cow n.

So, at each step, the current champion faces the next cow in line.

Now, if my cow is at position p, then in match p-1, the current champion up to that point faces cow p.

If my cow wins, it becomes the new champion and proceeds to face cow p+1, and so on.

The number of wins is equal to how many consecutive cows starting from p it can defeat.

In other words, it's the length of the winning streak starting from match p-1.

So, for my cow at position p, the number of wins is equal to the number of consecutive cows starting from p that it can defeat, i.e., the number of cows from p to the first cow with a higher rating than my cow.

Wait, almost.

Actually, it's the number of cows from p onwards that my cow can defeat, until it encounters a cow with a higher rating.

But there's a catch: to even start winning at position p, my cow needs to be stronger than the current champion up to position p-1.

So, I need to ensure that my cow's rating is higher than the maximum rating among cows from position 1 to p-1.

If it is, then it can start winning at position p, and the number of wins is the number of consecutive cows starting from p that it can defeat, i.e., cows with lower ratings than mine.

If not, it can't even start winning at position p, so the number of wins is 0.

Therefore, for each possible p, the number of wins is:

- 0, if a_k < left_max[p]

- Otherwise, the number of consecutive cows starting from p that have a rating less than a_k.

So, to maximize the number of wins, I need to choose p such that:

- left_max[p] < a_k

- And the number of consecutive cows starting from p with rating < a_k is maximized.

Therefore, I can precompute left_max[p] for all p, and then for each p, compute the number of consecutive cows starting from p with rating < a_k, but only if a_k > left_max[p].

Then, take the maximum among these values.

This seems efficient enough, as it's O(n) per test case.

Now, let's think about how to implement this efficiently.

First, compute left_max[p] for all p from 1 to n.

left_max[1] = 0 (no cows to the left)

for p from 2 to n:

left_max[p] = max(left_max[p-1], a[p-1])

Then, for each p from 1 to n:

if a_k > left_max[p]:

count = 0

i = p-1

while i < n and a[i] < a_k:

count += 1

i += 1

max_wins = max(max_wins, count)

else:

max_wins = max(max_wins, 0)

But this is O(n) per test case, which should be acceptable since the sum of n over all test cases is up to 10^5.

However, I can optimize this further by precomputing the number of consecutive cows starting from each p with rating < a_k.

This can be done using a suffix array that stores, for each p, the number of consecutive cows starting from p with rating < a_k.

Then, for each p, if a_k > left_max[p], then the number of wins is the precomputed suffix count for p.

Otherwise, it's 0.

This way, I can compute the suffix counts in O(n) time and then compute the maximum wins in O(n) time per test case.

But perhaps there's a smarter way to do this without iterating over all p.

Wait, maybe I can find the position p where a_k > left_max[p] and the suffix count is maximized.

Given that left_max[p] is non-decreasing (since it's the maximum so far), I can find the range of p where a_k > left_max[p], and then find the maximum suffix count within that range.

This might reduce the time complexity, but given that n is up to 10^5 and t is up to 10^4 with sum of n up to 10^5, the initial approach should suffice.

Now, let's consider the example provided to verify this logic.

Example 1:

n = 6, k = 1

a = [12, 10, 14, 11, 8, 3]

left_max[p] for p from 1 to 6:

p=1: 0

p=2: 12

p=3: 12

p=4: 12

p=5: 12

p=6: 12

a_k = 12

So, for p=1:

a_k > left_max[1] = 0 → yes

count = number of consecutive cows starting from p=1 with rating < 12, which is 0 (since cow 1 has rating 12, which is equal, not less).

Wait, but in the problem, it's specified that ratings are distinct, so equal ratings shouldn't occur, but in this case, a_k = 12, and cow 1 has rating 12.

Wait, but in the initial setup, if I don't swap, my cow is at position k=1 with rating 12.

If I choose to swap position k=1 with position p=1, it's effectively doing nothing.

If I choose to swap with another position, say p=3, then my cow is at position 3 with rating 14, and cow 3 originally has rating 14.

Wait, but in the example, it says that doing nothing is optimal, resulting in 1 win.

Wait, perhaps I need to adjust my understanding.

In the initial setup, without swapping:

- Match 1: cow 1 (12) vs cow 2 (10), cow 1 wins.

- Match 2: cow 1 (12) vs cow 3 (14), cow 3 wins.

- Match 3: cow 3 (14) vs cow 4 (11), cow 3 wins.

- Match 4: cow 3 (14) vs cow 5 (8), cow 3 wins.

- Match 5: cow 3 (14) vs cow 6 (3), cow 3 wins.

So, my cow (cow 1) wins only match 1.

Hence, 1 win.

In the second test case:

n=6, k=5

a=[7,2,727,10,12,13]

left_max[p]:

p=1: 0

p=2: 7

p=3: 7

p=4: 7

p=5: 7

p=6: 7

a_k=12

If I don't swap, my cow is at position 5 with rating 12.

left_max[5]=7 < 12, so it can start winning.

Then, it can defeat cow 5 (12) against left_max[5]=7, but in the tournament:

- Match 1: cow 1 (7) vs cow 2 (2), cow 1 wins.

- Match 2: cow 1 (7) vs cow 3 (727), cow 3 wins.

- Match 3: cow 3 (727) vs cow 4 (10), cow 3 wins.

- Match 4: cow 3 (727) vs cow 5 (12), cow 3 wins.

- Match 5: cow 3 (727) vs cow 6 (13), cow 3 wins.

So, my cow at position 5 never gets to play because cow 3 defeats all before reaching position 5.

Hence, number of wins is 0.

But according to the explanation, it's optimal to swap to position 3.

Wait, in the explanation, they swap cow k=5 (rating 12) with position 3 (rating 727), so now:

a=[7,2,12,10,727,13]

Then:

- Match 1: cow 1 (7) vs cow 2 (2), cow 1 wins.

- Match 2: cow 1 (7) vs cow 3 (12), cow 3 wins.

- Match 3: cow 3 (12) vs cow 4 (10), cow 3 wins.

- Match 4: cow 3 (12) vs cow 5 (727), cow 5 wins.

- Match 5: cow 5 (727) vs cow 6 (13), cow 5 wins.

So, my cow at position 3 wins two matches.

Hence, the number of wins is 2.

This matches the explanation.

So, in this case, swapping to position 3 is better than not swapping or swapping to other positions.

Let me see if my algorithm would capture this.

Compute left_max[p]:

p=1: 0

p=2: 7

p=3: 7

p=4: 7

p=5: 7

p=6: 7

a_k=12

For p=1:

left_max[1]=0 < 12 → count number of consecutive cows starting from p=1 with rating < 12.

Cows: 7 < 12, 2 < 12, 12 == 12 (not less), so count=2.

But in reality, if swapped to p=1, a[0]=12, a[1]=2, a[2]=7, etc.

Then:

- Match 1: cow 1 (12) vs cow 2 (2), cow 1 wins.

- Match 2: cow 1 (12) vs cow 3 (7), cow 1 wins.

- Match 3: cow 1 (12) vs cow 4 (10), cow 1 wins.

- Match 4: cow 1 (12) vs cow 5 (727), cow 5 wins.

- Match 5: cow 5 (727) vs cow 6 (13), cow 5 wins.

So, my cow wins 3 matches.

Wait, but according to the explanation, swapping to position 3 gives 2 wins, and not swapping gives 1 win.

But in this calculation, swapping to position 1 gives 3 wins, which seems better.

But in the explanation, they chose to swap to position 3 to get 2 wins.

I must be misunderstanding something.

Wait, perhaps the problem is that when you swap, you can only swap once, and the explanation chose to swap k=5 with p=3 to achieve 2 wins, but in reality, swapping k=5 with p=1 gives 3 wins.

So, perhaps the maximum is 3, but in the explanation, they only achieved 2 wins.

Maybe I misread the example.

Wait, in the first test case, it says:

"In the first test case, it is optimal to do nothing. Let a' be the Cowdeforces rating of the cows in the original order (with your cow's rating bolded), then

- Initially, a' = [12, 10, 14, 11, 8, 3]. Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [12, 14, 11, 8, 3]. Your cow plays against the cow with Cowdeforces rating 14 and loses."

So, in the original setup, my cow at position 1 wins once.

In the second test case:

"In the second test case, it is optimal to swap your cow to position 3 . Then, let a' be the Cowdeforces rating of the cows in the order after the swap.

- Initially, a' = [7, 2, 12, 10, 727, 13]. The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, 12, 10, 727, 13]. The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [12, 10, 727, 13]. Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [12, 727, 13]. Your cow plays against the cow with Cowdeforces rating 727 and loses."

So, my cow wins 2 matches.

But according to my earlier calculation, swapping to position 1 would give 3 wins.

Wait, perhaps I made a mistake in simulating the tournament.

Let me simulate swapping k=5 with p=1:

a = [12, 2, 7, 10, 727, 13]

Tournament:

- Match 1: cow 1 (12) vs cow 2 (2), cow 1 wins.

- Match 2: cow 1 (12) vs cow 3 (7), cow 1 wins.

- Match 3: cow 1 (12) vs cow 4 (10), cow 1 wins.

- Match 4: cow 1 (12) vs cow 5 (727), cow 5 wins.

- Match 5: cow 5 (727) vs cow 6 (13), cow 5 wins.

So, my cow at position 1 wins 3 matches.

But in the explanation, they achieved only 2 wins by swapping to position 3.

So, why didn't they consider swapping to position 1 to get 3 wins?

Maybe because in the problem statement, the matches are structured in a specific way, and perhaps my simulation is incorrect.

Wait, perhaps I need to consider that after each match, the loser is eliminated, and the winner proceeds.

But in the problem description, it seems that the loser stays, but only the winner proceeds to the next match.

Wait, re-reading the problem:

"In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match."

So, the winner proceeds to the next match, and the loser is out.

Hence, in the tournament, the champion updates in each match.

In the first test case, without swapping:

- Match 1: cow 1 (12) vs cow 2 (10), cow 1 wins.

- Match 2: cow 1 (12) vs cow 3 (14), cow 3 wins.

- Match 3: cow 3 (14) vs cow 4 (11), cow 3 wins.

- Match 4: cow 3 (14) vs cow 5 (8), cow 3 wins.

- Match 5: cow 3 (14) vs cow 6 (3), cow 3 wins.

So, my cow (cow 1) wins only match 1.

In the second test case:

Original a = [7,2,727,10,12,13]

Swap k=5 with p=3: a = [7,2,12,10,727,13]

- Match 1: cow 1 (7) vs cow 2 (2), cow 1 wins.

- Match 2: cow 1 (7) vs cow 3 (12), cow 3 wins.

- Match 3: cow 3 (12) vs cow 4 (10), cow 3 wins.

- Match 4: cow 3 (12) vs cow 5 (727), cow 5 wins.

- Match 5: cow 5 (727) vs cow 6 (13), cow 5 wins.

So, my cow (now at position 3) wins two matches.

But if I swap to position 1:

a = [12,2,7,10,727,13]

- Match 1: cow 1 (12) vs cow 2 (2), cow 1 wins.

- Match 2: cow 1 (12) vs cow 3 (7), cow 1 wins.

- Match 3: cow 1 (12) vs cow 4 (10), cow 1 wins.

- Match 4: cow 1 (12) vs cow 5 (727), cow 5 wins.

- Match 5: cow 5 (727) vs cow 6 (13), cow 5 wins.

So, my cow wins 3 matches.

But