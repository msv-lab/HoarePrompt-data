Alright, I've got this problem to solve. Let's see what it's about. There are three friends playing chess together. In each game, two of them play against each other. The winner gets 2 points, the loser gets 0, and in case of a draw, both get 1 point each. After all the games, their scores are p1, p2, and p3, with p1 ≤ p2 ≤ p3. I need to find the maximum number of draws that could have happened, or print -1 if such a scenario isn't possible.

First, I need to understand the scoring system. Each game contributes either 2 points in total (if there's a winner and a loser) or 2 points in total (if it's a draw, since both get 1 point). So, regardless of the outcome, each game adds 2 points to the total points pool.

Given that, the total points scored by all three players should be equal to 2 times the number of games played. So, if I sum p1 + p2 + p3, it should be even, because it's 2 times the number of games. If it's odd, that means it's impossible, and I should return -1.

Okay, so first check: if (p1 + p2 + p3) % 2 != 0, then return -1.

Next, I need to find the maximum number of draws. A draw contributes 2 points to the total, just like a game with a winner and a loser. But in terms of points distribution, a draw gives 1 point to each player involved, whereas a game with a winner gives 2 points to one player and 0 to the other.

To maximize the number of draws, I need to maximize the number of games where points are distributed as 1 and 1, rather than 2 and 0.

Let me think about how to approach this.

Let's denote:

- Let G be the total number of games played.

- Let D be the number of draws.

- Let W be the number of games with a winner (no draw).

So, G = D + W.

Each game contributes 2 points to the total, so total points = 2 * G.

Given that p1 + p2 + p3 = 2 * G.

Now, in terms of points distribution:

- For each draw, two players get 1 point each.

- For each game with a winner, one player gets 2 points and the other gets 0.

So, if there are D draws and W games with a winner, then:

- Total points from draws: D * 2.

- Total points from games with a winner: W * 2.

- So, p1 + p2 + p3 = 2 * (D + W).

This is consistent with the earlier equation.

But I need to distribute these points among the three players, considering that in each draw, two specific players get a point, and in each game with a winner, one specific player gets 2 points.

This seems a bit tricky. Maybe I can think in terms of the maximum number of draws.

To maximize D, I need to have as many games as possible end in draws, while still achieving the given scores p1, p2, p3.

Let me consider the constraints on p1, p2, p3.

Given that p1 ≤ p2 ≤ p3, and all are integers between 0 and 30.

First, as I thought earlier, if p1 + p2 + p3 is odd, it's impossible, so return -1.

Second, I need to check if the scores are achievable given the rules.

I need to find non-negative integers D and W such that:

- 2 * (D + W) = p1 + p2 + p3.

Additionally, I need to consider how the points are distributed among the players.

Let me think about the minimal and maximal possible points for each player.

- The minimal possible points for a player is 0, if they didn't play any games or always lost.

- The maximal possible points for a player is 2 * G, if they won all their games.

But since there are three players, and in each game, two of them play, I need to consider the pairwise interactions.

This seems complicated. Maybe there's a better way.

Let me look at the example provided.

Example input:

7

0 0 0

0 1 1

1 1 1

1 1 2

3 3 3

3 4 5

1 1 10

Output:

0

1

-1

2

-1

6

2

Let's analyze the first test case: 0 0 0

- No games were played, so no draws. That makes sense.

Second test case: 0 1 1

- One game was played between player 2 and player 3, and it was a draw. So, one draw.

Third test case: 1 1 1

- This is marked as -1, meaning it's impossible.

Wait, why is 1 1 1 impossible?

If all three players have 1 point each, that would require that each pair played exactly one draw.

But in that case, each pair would have to play one draw:

- Player 1 and 2 draw: both get 1 point.

- Player 1 and 3 draw: both get 1 point.

- Player 2 and 3 draw: both get 1 point.

But each player would then have 2 points, not 1 point.

Wait, no. If each pair plays one draw, then:

- Player 1 plays with player 2: both get 1 point. Now p1=1, p2=1.

- Player 1 plays with player 3: both get 1 point. Now p1=2, p3=1.

- Player 2 plays with player 3: both get 1 point. Now p2=2, p3=2.

So, total points: p1=2, p2=2, p3=2.

But we need p1=1, p2=1, p3=1.

So, it's impossible to achieve p1=1, p2=1, p3=1 with the given rules.

Hence, -1.

Okay, that makes sense.

Fourth test case: 1 1 2

- Output is 2.

How is that possible?

Let's see:

- Suppose player 1 and player 2 play a draw: p1=1, p2=1.

- Then player 3 plays with either player 1 or player 2.

- If player 3 plays with player 1 and wins: p1=1+0=1, p3=2+0=2.

- So, p1=1, p2=1, p3=2.

- Total points: 1+1+2=4, which is even.

- Number of games: 2.

- Number of draws: 1 (from the first game).

Wait, but the output is 2. So, maybe there are two draws.

Let me think differently.

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 2 and player 3 draw: p2=1+1=2, p3=1.

- Player 1 and player 3 draw: p1=1+1=2, p3=1+1=2.

But then p1=2, p2=2, p3=2, which is not what we want.

Alternatively:

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 2 and player 3 draw: p2=2, p3=1.

- Player 1 and player 3 draw: p1=2, p3=2.

But that gives p1=2, p2=2, p3=2 again.

Wait, maybe fewer games.

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 2 and player 3 draw: p2=2, p3=1.

- Player 1 and player 3 don't play.

Total points: p1=1, p2=2, p3=1.

But p2=2 is higher than p3=1, which violates p1 ≤ p2 ≤ p3.

Wait, but in the input, p1 ≤ p2 ≤ p3, so p3 should be at least p2.

Wait, in this case, p3=1 and p2=2, which is invalid because p3 should be at least p2.

Wait, no, in the test case, p1=1, p2=1, p3=2, which satisfies p1 ≤ p2 ≤ p3.

So, perhaps only two games were played:

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 2 and player 3 draw: p2=2, p3=1.

Total points: 1 + 2 + 1 = 4, which is even.

Number of games: 2.

Number of draws: 2.

This matches p1=1, p2=2, p3=1, but in the problem, p1 ≤ p2 ≤ p3, so p3 should be at least p2, but in this case, p3=1 < p2=2, which violates the ordering.

Wait, but in the test case, it's p1=1, p2=1, p3=2, which satisfies p1 ≤ p2 ≤ p3.

So, maybe the second draw is between player 1 and player 3.

Wait, let's try:

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 1 and player 3 draw: p1=2, p3=1.

- Player 2 and player 3 draw: p2=2, p3=2.

But then p1=2, p2=2, p3=2, which is not what we want.

Alternatively:

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 1 and player 3 draw: p1=2, p3=1.

- Player 2 and player 3 don't play.

Total points: p1=2, p2=1, p3=1.

But this doesn't match p1=1, p2=1, p3=2.

Wait, maybe only one draw and one game with a winner.

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 2 and player 3 play, player 3 wins: p2=1, p3=2.

Total points: 1 + 1 + 2 = 4, which is even.

Number of games: 2.

Number of draws: 1.

But the output is 2, meaning there could be two draws.

Wait, maybe there is a way to have two draws and achieve p1=1, p2=1, p3=2.

Let me think differently.

Suppose:

- Player 1 and player 2 draw: p1=1, p2=1.

- Player 2 and player 3 draw: p2=2, p3=1.

- Player 1 and player 3 don't play.

Total points: p1=1, p2=2, p3=1.

But in the problem, p1=1, p2=1, p3=2.

Wait, perhaps there is a mistake in my reasoning.

Wait, maybe:

- Player 1 and player 3 draw: p1=1, p3=1.

- Player 2 and player 3 draw: p2=1, p3=2.

Total points: p1=1, p2=1, p3=2.

That works! Two draws.

So, two draws can achieve p1=1, p2=1, p3=2.

Hence, the output is 2.

Okay, that makes sense.

Now, let's look at another test case: 3 3 3

Output is -1.

Why is that?

Let's see.

Total points: 3 + 3 + 3 = 9, which is odd. So, impossible.

Wait, but 9 is odd, so it should be impossible.

But in the problem statement, it says to check if the total points are even.

Yes, in the program, it checks if total_points % 2 != 0, then return -1.

In this case, 9 % 2 != 0, so return -1.

But in the explanation, it says -1, but according to the program, it should be -1.

Wait, but in the note, it says "It's easy to see that there's no set of games achieving the scores in the third example, so the answer for it is -1."

Wait, in the third example, it's 1 1 1, which sums to 3, which is odd, so -1.

But in the fifth example, 3 3 3, which sums to 9, which is also odd, so -1.

Wait, but in the program, it seems to handle this correctly.

Wait, but in the program, for p1=0, p2=2, p3=3, which sums to 5, which is odd, so it should return -1.

But in the example input, it's 0 2 3, and the output is not provided, but according to the reasoning, it should be -1.

Wait, in the example input, it's:

7

0 0 0

0 1 1

1 1 1

1 1 2

3 3 3

3 4 5

1 1 10

Output:

0

1

-1

2

-1

6

2

So, for input 0 2 3, which sums to 5, which is odd, it should be -1, but it's not in the example.

Wait, in the problem statement, it says "the first line contains the number of test cases t (1 ≤ t ≤ 500)", then t lines follow with p1, p2, p3.

In the example, t=7, and the cases are:

0 0 0 → 0

0 1 1 → 1

0 2 3 → missing in the output

3 3 3 → -1

3 4 5 → 6

1 1 10 → 2

Wait, but in the output, there are 7 lines: 0,1,-1,2,-1,6,2

So, the third case is 1 1 1 → -1

Fourth case is 1 1 2 → 2

Fifth case is 3 3 3 → -1

Sixth case is 3 4 5 → 6

Seventh case is 1 1 10 → 2

Wait, but according to the input, the third case is 0 2 3, which sums to 5, odd, so -1.

But in the output, the third line is -1, which corresponds to 1 1 1, which also sums to 3, odd.

Wait, there might be a mistake in the problem statement or the example.

Wait, looking back, the problem statement says:

"Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 500 ). The description of the test cases follows.

The first line of each test case contains three integers p1 , p2 and p3 (0 ≤ p1 ≤ p2 ≤ p3 ≤ 30 ) — the scores of the three players, sorted non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws that could've happened, or -1 if the scores aren't consistent with any valid set of games and results.

Example

Input

7

0 0 0

0 1 1

0 2 3

3 3 3

3 4 5

1 1 10

0 0 6

Output

0

1

-1

-1

6

2

3

Note

In the first example, no games were played at all, so no draws could occur either.

For the second example, exactly one game occurred between the second and the third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third example, so the answer for it is -1 ."

Wait, but in the provided program, the test cases are:

cas_de_test = [(0, 0, 0), (0, 1, 1), (0, 2, 3), (3, 3, 3), (3, 4, 5), (1, 1, 10), (0, 0, 6)]

And the expected output is:

0

1

-1

-1

6

2

3

But in the initial problem statement, it shows a different seventh test case: (1,1,10) → 2, but in the example, it's (0,0,6) → 3.

Wait, perhaps there was a confusion in the problem statement.

Anyway, moving forward, I need to focus on the program provided and verify its correctness.

So, the program is:

t = 7

cas_de_test = [(0, 0, 0), (0, 1, 1), (0, 2, 3), (3, 3, 3), (3, 4, 5), (1, 1, 10), (0, 0, 6)]

resultats = func_1(t, cas_de_test)

print('\n'.join(map(str, resultats)))

def func_1(t, cas_de_test):

resultats = []

for (p1, p2, p3) in cas_de_test:

total_points = p1 + p2 + p3

if total_points % 2 != 0:

resultats.append(-1)

continue

total_matchs = total_points // 2

if total_matchs > 3 or p3 > total_matchs:

resultats.append(-1)

continue

egalites = total_points - 2 * (p3 - p2) - 2 * (p3 - p1)

if egalites < 0:

resultats.append(-1)

else:

resultats.append(egalites // 2)

return resultats

First, it takes t=7 and cas_de_test as a list of tuples.

Then, for each testcase (p1,p2,p3):

1. Check if total_points = p1 + p2 + p3 is even. If odd, return -1.

2. Calculate total_matchs = total_points // 2.

3. Check if total_matchs > 3 or p3 > total_matchs. If yes, return -1.

4. Calculate egalites = total_points - 2*(p3 - p2) - 2*(p3 - p1).

5. If egalites < 0, return -1.

6. Else, append egalites // 2 to resultats.

I need to verify if this logic is correct.

First, checking if total_points is even is correct, as each game contributes 2 points.

Then, total_matchs = total_points // 2 is correct.

But why is there a check if total_matchs > 3 or p3 > total_matchs?

Wait, in the problem statement, it says "it is guaranteed that p1 ≤ p2 ≤ p3 holds."

So, p3 is the highest score.

If p3 > total_matchs, that means one player has more points than the total number of games played, which is impossible because in each game, a player can gain at most 2 points, and there are total_matchs games.

Wait, no. If there are total_matchs games, a player can have up to 2 * total_matchs points, but in this case, p3 cannot be greater than 2 * total_matchs.

Wait, but in the program, it checks if p3 > total_matchs, not p3 > 2 * total_matchs.

Wait, that seems incorrect.

Wait, no, in each game, a player can gain at most 2 points, and there are total_matchs games, so the maximum points a player can have is 2 * total_matchs.

Therefore, p3 should be less than or equal to 2 * total_matchs.

But in the program, it checks if p3 > total_matchs, and if so, returns -1.

That's incorrect. It should check if p3 > 2 * total_matchs.

Wait, but total_matchs is total_points // 2, and total_points = p1 + p2 + p3.

So, total_matchs = (p1 + p2 + p3) // 2.

Is p3 > 2 * total_matchs possible?

Let's see:

2 * total_matchs = p1 + p2 + p3.

So, p3 > p1 + p2 + p3 would imply p3 - p1 - p2 - p3 > 0, which simplifies to -p1 - p2 > 0, which is only possible if p1 and p2 are negative, but p1, p2, p3 ≥ 0, so p3 > p1 + p2 + p3 is impossible.

Wait, no. p3 > p1 + p2 + p3 simplifies to 0 > p1 + p2, which is impossible since p1 and p2 are non-negative.

Therefore, p3 cannot be greater than p1 + p2 + p3.

So, the condition p3 > total_matchs is equivalent to p3 > (p1 + p2 + p3) // 2.

But (p1 + p2 + p3) // 2 is floor division, so if p1 + p2 + p3 is even, it's equal to (p1 + p2 + p3)/2.

If p1 + p2 + p3 is odd, it's floor of (p1 + p2 + p3)/2.

But since we already checked that p1 + p2 + p3 is even, total_matchs = (p1 + p2 + p3)/2.

So, p3 > total_matchs is p3 > (p1 + p2 + p3)/2.

Given that p1 ≤ p2 ≤ p3, p3 ≤ (p1 + p2 + p3)/2 should hold.

Let me see:

If p1 ≤ p2 ≤ p3, then p1 + p2 + p3 ≥ 3*p1, p3 ≥ p1.

Wait, not sure.

Let me consider an example.

Take p1=0, p2=0, p3=0.

Total_matchs=0.

p3=0 > 0 is False, so okay.

Take p1=0, p2=1, p3=1.

Total_matchs=1.

p3=1 >1 is False, so okay.

Take p1=0, p2=2, p3=3.

Total_matchs=2.5, but since it's integer division, total_matchs=2.

p3=3 >2, which is True, so it returns -1.

But is p1=0, p2=2, p3=3 possible?

Total points: 5, which is odd, so it's already invalid.

Wait, in the program, it first checks if total_points is odd, and only if it's even, it proceeds to check p3 > total_matchs.

So, in this case, total_points=5, which is odd, so it returns -1 before checking p3 > total_matchs.

Wait, but in the test cases, cas_de_test includes (0,2,3), which sums to 5, which is odd, so it's correctly handled.

Another test case: p1=1, p2=1, p3=2.

Total_points=4, total_matchs=2.

p3=2 >2 is False, so proceed.

Then, egalites = 4 - 2*(2-1) -2*(2-1) = 4 - 2*1 - 2*1 = 4 - 2 - 2 = 0.

egalites=0 >=0, so egalites//2=0.

But in the example, it's supposed to be 2.

Wait, but according to the earlier analysis, it's possible to have two draws to achieve p1=1, p2=1, p3=2.

But according to the program, it calculates egalites=0, which would mean 0 draws.

That's incorrect.

Wait, perhaps there's a mistake in the formula used in the program.

Let me think differently.

I need to find the maximum number of draws.

Each draw contributes 2 points to the total, same as a game with a winner.

But to maximize draws, I need to maximize the number of games that ended in a draw, while satisfying the given point distribution.

Let me consider that in each draw, two players each get 1 point, and in each game with a winner, one player gets 2 points and the other gets 0.

So, if I have D draws and W games with a winner, then:

- Total games: G = D + W.

- Total points: 2 * G.

- Points distribution:

- For draws: each draw adds 1 point to two players.

- For games with a winner: each adds 2 points to one player.

So, for each player, their points come from the draws they participated in and the wins they had.

Let me denote:

- Let d_i be the number of draws for player i.

- Let w_i be the number of wins for player i.

Then, the points for player i would be: p_i = d_i + 2 * w_i.

But this might not be the best way to model it, as a player can participate in multiple draws.

Wait, maybe I need to consider the number of times each pair draws.

Let me consider the pairwise draws.

There are three pairs: (1,2), (1,3), (2,3).

Let me denote:

- D_12: number of draws between player 1 and player 2.

- D_13: number of draws between player 1 and player 3.

- D_23: number of draws between player 2 and player 3.

Similarly, let's denote:

- W_12: number of games between player 1 and player 2 with a winner.

- W_13: number of games between player 1 and player 3 with a winner.

- W_23: number of games between player 2 and player 3 with a winner.

In each W_ij, one of the players gets 2 points and the other gets 0, depending on who wins.

In each D_ij, both players get 1 point.

So, the total points for each player can be expressed as:

p1 = D_12 + D_13 + 2 * (number of wins by player 1 in W_12 and W_13)

Similarly,

p2 = D_12 + D_23 + 2 * (number of wins by player 2 in W_12 and W_23)

p3 = D_13 + D_23 + 2 * (number of wins by player 3 in W_13 and W_23)

This seems a bit complicated.

Maybe I can think in terms of the total number of draws.

Total number of draws D = D_12 + D_13 + D_23.

I need to maximize D, given the constraints on p1, p2, p3.

Also, the total number of games G = D + W, where W = W_12 + W_13 + W_23.

And 2 * G = p1 + p2 + p3.

So, G = (p1 + p2 + p3) / 2.

Our goal is to maximize D, which means minimizing W.

What's the minimal possible W?

Well, W needs to be such that the points can be achieved.

Let me think about the minimal W required to achieve the points.

Wait, maybe I should consider the minimal number of wins W, and then D = G - W.

To maximize D, I need to minimize W.

So, how to find the minimal W?

In other words, what's the minimal number of games with a winner needed to achieve the points.

Let me consider that.

Each game with a winner contributes 2 points to one player and 0 to the other.

Each draw contributes 1 point to each of the two players.

So, to minimize W, I need to maximize the draws, which is what we're trying to do.

Wait, perhaps another approach.

Let me consider that the sum of the points is 2 * G.

And p1 + p2 + p3 = 2 * G.

Also, p1 ≤ p2 ≤ p3.

Now, to maximize the number of draws, I need to maximize the number of times two players share 1 point each, rather than one player getting 2 points and the other getting 0.

Let me consider the highest score, p3.

To maximize draws, I need to minimize the number of wins by the highest scorer.

So, perhaps p3 can have some wins, and the others have draws.

Wait, maybe I can express it in terms of p3.

Wait, perhaps it's better to look for a formula that directly calculates the maximum number of draws.

Let me consider that.

Let me think about the minimal number of wins.

The minimal number of wins W is determined by the excess points that cannot be achieved through draws.

Each draw contributes 2 points to the total, same as a game with a winner.

But in draws, the points are distributed equally between two players.

In wins, 2 points go to one player.

So, to minimize W, I need to maximize the points distributed through draws.

But I need to ensure that the individual scores are achieved.

Let me consider the following:

Let me denote D as the total number of draws.

Then, W = G - D.

The total points are 2 * G.

The points from draws are 2 * D (since each draw contributes 2 points).

The points from wins are also 2 * W (since each win contributes 2 points to one player).

But in reality, in wins, one player gets 2 points and the other gets 0.

So, the distribution matters.

Wait, perhaps I need to consider the sum and the individual constraints.

Alternatively, perhaps I can look at the maximal number of draws as the minimal of the pairwise sums minus the third.

Wait, that might not be it.

Let me consider that in order to maximize draws, I need to maximize the number of times two players draw against each other.

But I need to ensure that the individual scores are met.

This seems tricky.

Let me look back at the program's approach.

In the program, after checking that total_points is even and p3 ≤ total_matchs, it calculates egalites = total_points - 2*(p3 - p2) - 2*(p3 - p1).

Then, if egalites < 0, it returns -1, else egalites // 2.

Wait, perhaps there's a formula behind this.

Let me try to derive it.

Let me denote:

- D as the total number of draws.

- W as the total number of games with a winner.

- G = D + W = total_matchs.

Now, the points can be expressed as:

p1 = d1 + 2 * w1

p2 = d2 + 2 * w2

p3 = d3 + 2 * w3

Where d1, d2, d3 are the number of draws each player participated in, and w1, w2, w3 are the number of wins each player had.

Also, d1 = D_12 + D_13

Similarly, d2 = D_12 + D_23

d3 = D_13 + D_23

Similarly, w1 = number of wins in W_12 and W_13.

w2 = number of wins in W_12 and W_23.

w3 = number of wins in W_13 and W_23.

This seems too complicated.

Maybe I need a different approach.

Let me consider the maximal possible draws.

To maximize draws, I need to maximize the number of games where two players draw.

But I need to ensure that the points add up correctly.

Wait, perhaps I can think in terms of the minimal number of wins needed.

Each win allows one player to gain 2 points, which cannot be achieved through draws alone.

So, the minimal number of wins is determined by the excess of points that cannot be achieved through draws.

Each draw contributes 1 point to two players.

