Alright, I've got this problem to figure out. Let's see what it's asking. So, Nikita has some cubes and he wants to build a tower using exactly n moves. In each move, he can either add one cube to the top of the tower or remove one cube from the top. The question is, after these n moves, can he end up with exactly m cubes in the tower?

First, I need to understand the operations. Each move is either adding one cube or removing one cube from the top. That means he can't remove a cube from the middle or anything like that; it's always the top cube.

Let me think about this step by step. Suppose he starts with no cubes. If he makes one move by adding a cube, he has one cube. If he makes another move adding another cube, he has two cubes, and so on. If at any point he decides to remove a cube, he removes the top one, so the number of cubes decreases by one.

Wait, but he can't remove a cube if there are none, right? So, he has to make sure that when he chooses to remove a cube, there is at least one cube in the tower.

Okay, so the sequence of moves matters here. The order in which he adds and removes cubes affects the final number of cubes in the tower.

Let me consider some examples to get a better understanding.

Example 1:

n = 3, m = 3

Possible sequence:

Add -> Add -> Add

Result: 3 cubes

So, "Yes", it's possible.

Example 2:

n = 2, m = 4

Possible sequence:

Add -> Add

Result: 2 cubes, which is less than 4.

Is there any way to reach 4 cubes with only 2 moves? No, because he can only add one cube per move.

Wait, but if he adds and removes in some order, does that help?

Let's see:

Add -> Remove -> Add -> Add

But that's 3 moves, which is more than n=2.

So, with n=2, maximum m he can have is 2, assuming he only adds cubes.

If he removes a cube at some point, the tower will have fewer cubes.

Hence, for n=2, m=4 is impossible. So, "No".

Example 3:

n = 5, m = 3

Possible sequence:

Add -> Add -> Add -> Remove -> Add

Result: 3 cubes.

Wait, that's 5 moves.

Let's count:

Start: 0

Add: 1

Add: 2

Add: 3

Remove: 2

Add: 3

So, yes, with 5 moves, he can have 3 cubes.

Alternatively:

Add -> Add -> Add -> Add -> Remove

Result: 3 cubes

So, "Yes".

From these examples, it seems that the key is to find a sequence of n moves (each being either add or remove) that results in exactly m cubes.

Let me try to generalize this.

Let’s denote:

- Let a be the number of add operations.

- Let r be the number of remove operations.

Then, n = a + r

And the final number of cubes in the tower would be:

m = a - r

Because each add increases the count by 1, and each remove decreases it by 1.

So, we have:

n = a + r

m = a - r

I can solve these two equations for a and r.

Adding them:

n + m = 2a => a = (n + m)/2

Subtracting them:

n - m = 2r => r = (n - m)/2

For a and r to be non-negative integers, since you can't have fractional operations, a and r must be integers, and since you can't have negative operations, a and r must be >= 0.

Therefore, for the solution to be valid:

1. (n + m)/2 must be an integer.

2. (n - m)/2 must be an integer.

3. a = (n + m)/2 >= 0

4. r = (n - m)/2 >= 0

Conditions 3 and 4 are equivalent to:

- (n + m)/2 >= 0

- (n - m)/2 >= 0

But since n and m are both positive integers (from the input constraints), and n >=1, m >=1, these should generally hold, but we need to make sure that n >= m for the remove operations to make sense.

Wait, no, n doesn't have to be >= m, because he can remove cubes that he has added previously.

Wait, but in reality, he can't remove more cubes than he has added.

Wait, but in the sequence of operations, he can interleave adds and removes, but he can't remove a cube that isn't there.

So, the sequence must be such that at no point does he try to remove a cube when there are none.

This is getting complicated. Maybe there's a simpler way to look at it.

Let me consider the net effect of the operations.

Each add operation increases the cube count by 1, and each remove operation decreases it by 1.

So, after n operations, the change in the cube count is a - r, which is m.

But since a + r = n, as before.

So, a = (n + m)/2

r = (n - m)/2

For a and r to be integers, (n + m) must be even, and (n - m) must be even.

Wait, but (n + m) and (n - m) are both even only if n and m are both even or both odd.

Because:

- If n and m are both even, n + m is even, n - m is even.

- If n and m are both odd, n + m is even, n - m is even.

- If one is even and the other is odd, n + m is odd, n - m is odd.

But in the odd case, (n + m)/2 and (n - m)/2 would not be integers.

Hence, a and r would not be integers, which is invalid.

Therefore, a necessary condition is that n and m have the same parity (both even or both odd).

But is this sufficient?

Wait, not necessarily, because even if n and m have the same parity, and a and r are integers, we still need to ensure that in the sequence of operations, he doesn't try to remove a cube when there are none.

This is similar to the concept of a Dyck word in formal languages, where you have to ensure that the number of opens is always at least the number of closes at any point in the sequence.

In this case, it's similar: the number of adds should always be at least the number of removes at any point in the sequence.

So, to ensure that, we need to make sure that the partial sums never go negative.

This sounds like it could be related to Catalan numbers or something similar, but maybe there's a simpler way to think about it.

Let me consider the minimal number of cubes he can have after n moves.

If he removes as much as possible, but without trying to remove more than he has.

For example, if he has 0 cubes and wants to remove, he can't.

So, the minimal number of cubes he can have after n moves is max(0, n - 2k), where k is the number of remove operations.

Wait, this seems messy.

Maybe I should look back at the equations.

We have:

a + r = n

a - r = m

So, a = (n + m)/2

r = (n - m)/2

Both a and r must be integers and non-negative.

So, for the solution to be possible:

1. (n + m) % 2 == 0

2. (n - m) % 2 == 0

3. (n + m)/2 >= 0

4. (n - m)/2 >= 0

Given that n and m are positive integers, and considering the problem constraints, conditions 3 and 4 should hold as long as m <= n.

Wait, but m can be greater than n, but in that case, it's impossible because you can't have more cubes than the number of moves.

Wait, no, actually, you can have more cubes than moves if you add and remove in a certain order.

Wait, no, each add operation increases the cube count by 1, and remove decreases it by 1.

So, the maximum possible m is n, if all operations are adds.

The minimum possible m is -n, if all operations are removes.

But, in reality, you can't have negative cubes, so m >= 0.

Wait, but in the problem statement, m >=1, so m is at least 1.

But, in practice, m can be 0, but according to the problem, m >=1.

Wait, no, looking back, m can be 1 to 100.

But in the example, m can be 0, but in the problem, m >=1.

Wait, no, in the problem statement, m >=1.

Wait, let's check:

"1 ≤ n, m ≤ 100"

So, both n and m are at least 1.

But, in reality, m can be 0, but according to the problem, m >=1.

Wait, no, the problem says "the tower has exactly m cubes", and m is from 1 to 100.

So, in the problem, m is at least 1.

But in reality, m could be 0 if all operations are adds and removes in a certain way, but since m >=1, we don't need to consider m=0.

Ok, so, given that, the conditions are:

- (n + m) is even

- (n - m) is even

- (n + m)/2 >=0

- (n - m)/2 >=0

Given that m >=1 and n >=1, and m <=100, n<=100.

But, (n + m)/2 >=0 is always true since n and m are positive.

Similarly, (n - m)/2 >=0 implies that n >= m.

Wait, no, (n - m)/2 >=0 implies that n >= m, but only if n and m have the same parity.

Wait, but in the earlier example, for n=5 and m=3, which are both odd, and n >= m, it's possible.

For n=3 and m=3, possible.

For n=2 and m=4, n < m, which is not possible.

So, seems like n >= m is a necessary condition, but not sufficient.

Wait, but in the first example, n=3, m=3, possible.

Second example, n=2, m=4, n < m, not possible.

Third example, n=5, m=3, n > m, possible.

Wait, but in the third example, n=5, m=3, both odd, (5+3)/2=4, (5-3)/2=1, both integers, and n >= m.

So, seems like the conditions are:

- n >= m

- (n + m) is even

- (n - m) is even

Wait, but (n + m) and (n - m) being even is equivalent to n and m having the same parity.

So, the conditions are:

- n >= m

- n and m have the same parity

But, in the earlier example, n=5, m=3, both odd, n >= m, possible.

n=2, m=4, both even, n < m, not possible.

n=3, m=3, both odd, n >= m, possible.

Wait, but in the second example, n=2, m=4, both even, but n < m, not possible.

So, n >= m is necessary, but not sufficient.

Wait, but in the first example, n=3, m=3, n >= m, and they have the same parity.

In the third example, n=5, m=3, n >= m, and same parity.

In the second example, n=2, m=4, n < m, same parity, but not possible.

Wait, but according to the conditions, n >= m and same parity.

But in the second example, n=2, m=4, n < m, same parity, not possible.

So, seems like n >= m is a necessary condition, but in the second example, n < m, which violates n >= m, hence not possible.

Wait, but in the third example, n=5, m=3, n >= m, same parity, possible.

So, perhaps the conditions are:

- n >= m

- n and m have the same parity

But, is this always sufficient?

Wait, let's think about another example.

Suppose n=4, m=2.

n >= m, both even, should be possible.

Sequence:

Add, Add, Add, Remove => 3 cubes

Add, Add, Remove, Add => 3 cubes

Add, Remove, Add, Add => 3 cubes

Add, Add, Remove, Remove => 1 cube

Add, Remove, Add, Remove => 1 cube

Add, Remove, Remove, Add => 1 cube

Remove, Add, Add, Add => invalid, because starting with remove when there are no cubes.

Wait, but he can't start with remove.

So, sequences starting with remove are invalid.

Hence, only sequences starting with add.

So, possible sequences:

Add, Add, Add, Remove -> 3 cubes

Add, Add, Remove, Add -> 3 cubes

Add, Remove, Add, Add -> 3 cubes

Add, Add, Remove, Remove -> 1 cube

Add, Remove, Add, Remove -> 1 cube

Add, Remove, Remove, Add -> 1 cube

So, with n=4, m=2, none of these sequences give m=2.

Wait, but according to the earlier conditions, n=4, m=2, n >= m, both even, should be possible, but in practice, it's not giving m=2.

Wait, maybe I'm missing something.

Wait, perhaps my understanding is incomplete.

Let me think differently.

Maybe I need to consider the minimal and maximal possible m after n moves.

The maximal m is n, if all operations are adds.

The minimal m is max(0, n - 2k), but I need to think carefully.

Wait, in reality, m can be from 0 up to n, but with constraints based on the parity.

Wait, but in the problem, m is at least 1, but in reality, m can be 0.

But according to the problem, m >=1.

Wait, but in the example, m can be 0, but in the problem constraints, m >=1.

Wait, no, in the problem, m >=1.

But in reality, m can be 0, but since the problem says m >=1, we don't need to consider m=0.

Ok, so, perhaps the conditions are:

- n >= m

- n and m have the same parity

But in the earlier example with n=4, m=2, which satisfies both, but I couldn't find a sequence that results in m=2.

Wait, perhaps I made a mistake in enumerating the sequences.

Let me try again.

Possible sequences for n=4, m=2:

Add, Add, Remove, Add -> 2 cubes

Start: 0

Add: 1

Add: 2

Remove: 1

Add: 2

Yes, this sequence gives m=2.

Wait, earlier I thought it was 3, but actually, it's 2.

So, "Yes", it's possible.

Wait, perhaps I miscalculated earlier.

So, in this case, n=4, m=2, same parity, n >= m, possible.

Another sequence:

Add, Remove, Add, Add -> 2 cubes

Start: 0

Add:1

Remove:0

Add:1

Add:2

Wait, but in the third operation, remove when there are 1 cube, so it becomes 0, then add two more to make 2.

Yes, that works.

So, my earlier mistake was in enumerating the sequences incorrectly.

Hence, the conditions seem to hold:

- n >= m

- n and m have the same parity

Then, it's possible.

Otherwise, not possible.

So, in the program provided, let's see what it's doing.

Program code:

def func():

t = int(input())

for i in range(t):

(n, m) = [int(i) for i in input().split()]

if n == m:

print('Yes')

elif m > n:

print('No')

elif m == n - 1:

print('Yes')

elif m % 2 == 0 and n % 2 == 0:

print('Yes')

elif m % 2 != 0 and n % 2 != 0:

print('Yes')

else:

print('No')

So, let's analyze this.

First, it reads the number of test cases, t.

Then, for each test case, it reads n and m.

Then, it checks:

if n == m:

print('Yes')

elif m > n:

print('No')

elif m == n - 1:

print('Yes')

elif m % 2 == 0 and n % 2 == 0:

print('Yes')

elif m % 2 != 0 and n % 2 != 0:

print('Yes')

else:

print('No')

So, let's see.

First, if n == m, it's "Yes".

This makes sense because if n == m, he can just add a cube in each move, without any removes, to get m cubes.

Second, if m > n, it's "No".

This makes sense because he can't have more cubes than the number of moves.

Third, if m == n - 1, it's "Yes".

This seems specific. Let's see.

For example, n=3, m=2.

Possible sequence:

Add, Add, Remove -> 2 cubes

Yes, that works.

Another example: n=2, m=1.

Add, Add, Remove -> but n=2, so only two operations.

Add, Remove -> 0 cubes, which is not m=1.

Wait, so n=2, m=1.

Possible sequences:

Add, Add -> 2 cubes

Add, Remove -> 1 cube

Remove, Add -> invalid, since can't remove initially.

So, only Add, Remove -> 1 cube.

Wait, but in reality, Remove, Add would be invalid, so only Add, Add or Add, Remove are valid sequences.

Add, Add: 2 cubes

Add, Remove: 1 cube

So, yes, m=1 is possible with n=2.

But according to the program, m == n - 1 is "Yes".

So, n=2, m=1, "Yes".

But according to the earlier condition, n >= m and n and m have the same parity.

In this case, n=2 (even), m=1 (odd), which have different parity, so should be "No", but the program says "Yes".

Wait, this seems incorrect.

Wait, in the sequence Add, Remove: n=2, m=1, which is different parity, but the program outputs "Yes".

But according to the earlier analysis, n and m should have the same parity for it to be possible.

So, perhaps the program is incorrect in this case.

Wait, but in the sequence Add, Remove: n=2, m=1, which has different parity, but it's possible.

Wait, but according to the earlier equations, a = (n + m)/2 = (2 + 1)/2 = 1.5, which is not an integer, so it should be impossible.

But in reality, the sequence Add, Remove gives m=1.

Wait, but a and r must be integers, so if a is not integer, it's impossible.

But in this case, a = 1.5, which is not integer, so it's impossible.

But the sequence Add, Remove gives m=1.

Wait, let's see:

Start: 0

Add:1

Remove:0

Add:1

Wait, but n=2, so only two operations: Add, Remove -> 0 cubes.

Wait, I think I made a mistake earlier.

Wait, in two operations: Add, Remove -> 0 cubes.

Wait, no, starting from 0, Add:1, Remove:0.

So, m=0, but m >=1, so not considered.

Alternatively, Add, Add: m=2.

So, with n=2, possible m values are 0 or 2.

But m=1 is not achievable with n=2.

Wait, but earlier I thought Add, Remove gives m=1, but actually, it gives m=0.

Wait, let's clarify:

Start: 0

Add:1

Remove:0

So, m=0.

Or, Add, Add: m=2.

So, with n=2, m can be 0 or 2.

But m=1 is not achievable with n=2.

Wait, but in the program, when m == n -1, which is m=1, n=2, it prints "Yes".

But in reality, m=1 is not achievable with n=2, so it should print "No".

Hence, the program is incorrect in this case.

Wait, but according to the earlier analysis, a = (n + m)/2 = (2 + 1)/2 = 1.5, which is not integer, so impossible.

Hence, the program is incorrect.

So, the condition m == n -1 should not lead to "Yes" in general.

Wait, but in some cases, it might be possible.

Wait, let's take n=3, m=2.

a = (3 + 2)/2 = 2.5, not integer.

But earlier, I thought Add, Add, Remove gives m=2.

Wait, but a=2.5 is not integer, so it's impossible.

But in reality, Add, Add, Remove gives:

Start:0

Add:1

Add:2

Remove:1

So, m=1, not m=2.

Wait, I must have miscalculated earlier.

So, sequence Add, Add, Remove gives m=1, not m=2.

Wait, to get m=2 with n=3:

Add, Add, Add: m=3

Add, Add, Remove: m=1

Add, Remove, Add: m=1

Remove, Add, Add: invalid, since can't remove initially.

Hence, m=2 is not achievable with n=3.

But according to the program, m == n -1, which is m=2 when n=3, prints "Yes", but in reality, it's not possible.

Hence, the program is incorrect.

So, the correct conditions should be:

- n >= m

- n and m have the same parity

Then, it's possible.

Otherwise, not possible.

Hence, the program should be:

if n >= m and n % 2 == m % 2:

print('Yes')

else:

print('No')

But in the given program, it has more conditions, which are incorrect.

Hence, the program is incorrect.

**Final Answer**

\[ \boxed{\text{false}} \]