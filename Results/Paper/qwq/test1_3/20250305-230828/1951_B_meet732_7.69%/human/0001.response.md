Alright, I have this problem to solve. Let's understand it step by step.

So, there are n cows with unique ratings, each in their initial positions from 1 to n. The tournament works like this:

1. The first match is between cow 1 and cow 2.

2. The winner of each match then plays against the next cow in line.

The winner is always the one with the higher rating.

I own cow k, and I want to maximize the number of wins this cow gets. I can choose to swap my cow with any other cow or do nothing.

My task is to find the maximum number of wins my cow can achieve with at most one swap.

First, I need to simulate the tournament process and see how my cow can win more matches by possibly swapping positions.

Let's think about how the tournament progresses:

- Start with match between cow 1 and cow 2.

- The winner plays against cow 3.

- Then the winner plays against cow 4.

- And so on, until all cows have participated.

My goal is to position my cow in such a way that it wins as many matches as possible.

I need to consider where to place my cow to maximize its wins. Since the cow with the higher rating always wins, I need to ensure that my cow has higher ratings compared to the cows it will be facing in the matches.

Let me consider the sequence of matches:

- Match 1: cow 1 vs cow 2 → winner W1

- Match 2: W1 vs cow 3 → winner W2

- Match 3: W2 vs cow 4 → winner W3

- ...

- Match n-1: W_{n-2} vs cow n → winner W_{n-1}

The final winner is W_{n-1}.

Now, for my cow k, I need to see in which positions it can be placed to win the maximum number of matches.

First, let's see what happens if I don't swap my cow at all.

In the initial position, cow k is at position k.

I need to see how many matches it can win from there.

Let me try to simulate the tournament with the initial positions.

But simulating the entire tournament for each test case might be inefficient, especially since n can be up to 10^5 and t up to 10^4, with the sum of n over all test cases up to 10^5.

I need a smarter approach.

Let me think about the properties of the tournament.

Each match is between the current winner and the next cow in line.

So, the sequence of opponents for my cow depends on where it is placed and who wins before it.

This seems complicated to simulate directly for large n.

I need to find a way to calculate the number of wins for my cow without simulating all the matches.

Let me consider the rating of my cow, a_k.

I need to place it in a position where it can win as many matches as possible.

Given that higher-rated cows always win, I should place my cow against lower-rated cows as much as possible.

Wait, but the sequence is fixed except for one swap.

Wait, no, I can choose to swap my cow with any other cow once, or choose not to swap.

So, I can choose to place my cow in any position by swapping it with another cow.

But I can only perform at most one swap.

Wait, actually, the problem says I can choose to swap my cow with another cow only once or choose to do nothing.

So, I can perform at most one swap involving my cow.

That is, I can choose another cow to swap positions with my cow, or keep it in its original position.

Then, the tournament proceeds as described, and I need to count the maximum number of wins my cow can achieve.

So, I need to choose where to place my cow (either in its original position or in the position of another cow) to maximize its wins.

But wait, swapping my cow with another cow means that my cow takes the position of that other cow, and that other cow takes my cow's original position.

So, in the tournament, the sequence of matches is based on the positions.

I need to decide whether to keep my cow in position k or swap it with another position, say position p, so my cow is in position p and the cow that was in position p is now in position k.

Then, the tournament proceeds as usual.

But this seems tricky because the sequence of matches depends on the positions.

I need a better way to model this.

Let me think differently.

Suppose I fix the position of my cow, say I place it at position pos.

Then, I need to see how many matches it can win from that position.

How can I calculate that?

Let me consider that my cow will participate in the tournament starting from position pos.

I need to see how long it can keep winning matches.

Given that it has rating a_k, and it will face the cows in the sequence starting from pos.

Wait, no.

Actually, the tournament is a series of matches where the winner of the previous match faces the next cow in line.

So, if I place my cow at position pos, then it will face the winner of the previous match.

Wait, it's a bit involved.

Maybe I need to think in terms of the path my cow can take through the tournament.

Wait, perhaps I can think in terms of the cows that are stronger than my cow and how they affect its path.

Let me consider the ratings.

Since all ratings are unique, there is a total ordering of the cows by their ratings.

Let me sort the cows in decreasing order of their ratings.

Let's say the cow with the highest rating is cow h1, then h2, and so on, down to the cow with the lowest rating.

Now, in the tournament, the cow with the highest rating will win all its matches, assuming it reaches the final.

But I need to maximize the number of wins for my cow, which may not be the highest-rated cow.

Let me consider that my cow needs to reach as far as possible in the tournament, winning as many matches as it can.

I need to place it in a position where it can progress through the matches, facing cows with lower ratings, until it faces a cow with a higher rating.

So, the number of wins my cow can achieve is equal to the number of cows with lower ratings that it can defeat before facing a cow with a higher rating.

But the sequence matters because of the way the tournament is structured.

Wait, maybe I can find the minimal number of higher-rated cows that can block my cow's path.

Or something like that.

This is getting complicated.

Let me look at small examples to get some intuition.

Take the first sample input:

n = 6, k = 1

a = [12, 10, 14, 11, 8, 3]

So, cow k=1 has rating 12.

Initial sequence: [12, 10, 14, 11, 8, 3]

First match: cow 1 (12) vs cow 2 (10). 12 > 10, so cow 1 wins.

Second match: cow 1 (12) vs cow 3 (14). 12 < 14, so cow 1 loses.

Total wins for cow 1: 1

But the output says that even if we swap cow 1 with another cow, we can't get more than 1 win.

Another sample:

n = 6, k = 5

a = [7, 2, 727, 10, 12, 13]

Cow k=5 has rating 12.

Initial sequence: [7, 2, 727, 10, 12, 13]

First match: cow 1 (7) vs cow 2 (2). 7 > 2, cow 1 wins.

Second match: cow 1 (7) vs cow 3 (727). 7 < 727, cow 3 wins.

Third match: cow 3 (727) vs cow 4 (10). 727 > 10, cow 3 wins.

Fourth match: cow 3 (727) vs cow 5 (12). 727 > 12, cow 3 wins.

Fifth match: cow 3 (727) vs cow 6 (13). 727 > 13, cow 3 wins.

So, cow 5 (12) never gets to play in this scenario.

But if we swap cow 5 with cow 3, then:

Sequence: [7, 2, 12, 10, 727, 13]

First match: cow 1 (7) vs cow 2 (2). 7 > 2, cow 1 wins.

Second match: cow 1 (7) vs cow 3 (12). 7 < 12, cow 3 wins.

Third match: cow 3 (12) vs cow 4 (10). 12 > 10, cow 3 wins.

Fourth match: cow 3 (12) vs cow 5 (727). 12 < 727, cow 5 wins.

Fifth match: cow 5 (727) vs cow 6 (13). 727 > 13, cow 5 wins.

So, cow 3 (original cow 5, now with rating 12) wins 2 matches.

Hence, the output is 2.

Another sample:

n = 2, k = 2

a = [1000000000, 1]

Cow k=2 has rating 1.

Initial sequence: [1000000000, 1]

First match: cow 1 (1000000000) vs cow 2 (1). 1000000000 > 1, cow 1 wins.

So, cow 2 loses immediately, 0 wins.

If we swap cow 2 with cow 1:

Sequence: [1, 1000000000]

First match: cow 1 (1) vs cow 2 (1000000000). 1 < 1000000000, cow 2 wins.

Still, cow 1 (original cow 2) loses immediately.

Hence, output is 0.

From these examples, it seems that placing my cow in a position where it can win against the previous winner and continue winning as much as possible.

I need to find the position where, starting from that position, my cow can defeat the previous winner and then keep winning until it faces a higher-rated cow.

Wait, but the previous winner depends on the sequence before my cow's position.

This seems tricky.

Let me try to think in terms of the sequence of matches and who the previous winner is.

Let me define a function that, given the sequence, can simulate the tournament and count how many times my cow wins.

But since n can be up to 10^5 and t up to 10^4, with sum of n over all test cases up to 10^5, I need an efficient solution, preferably O(n) per test case or better.

I need a smarter approach.

Let me consider that in the tournament, the winner of each match is the one with the higher rating.

So, the tournament can be seen as a process where the current winner faces the next cow in line, and the higher-rated one wins and becomes the new current winner.

I need to maximize the number of wins for my cow.

Let me consider that my cow needs to be placed in a position where:

1. It can reach that position by not being eliminated earlier.

2. From that position, it can win against the previous winner and then keep winning against the next cows until it faces a higher-rated cow.

But this seems too vague.

Let me try to think differently.

Suppose I fix the position of my cow, say pos.

Then, I need to see:

- What is the rating of the previous winner when my cow is about to play.

- If my cow's rating is higher than the previous winner, it wins, becomes the new winner, and proceeds to the next match.

- It keeps winning as long as its rating is higher than the next cows it faces.

So, to maximize the number of wins, I need to choose pos such that:

- The previous winner's rating is lower than my cow's rating.

- And then, starting from pos, my cow can win against as many subsequent cows as possible.

But determining the previous winner for each position is not straightforward.

Wait, perhaps I can precompute for each position, who would be the winner up to that position.

Let me try to simulate the tournament and keep track of the winner after each match.

Let's define a variable current_winner with initial rating a[0].

Then, for each subsequent cow, from position 1 to n-1:

- If current_winner's rating > a[i], current_winner remains the same.

- Else, current_winner is updated to a[i].

The number of wins for a cow is equal to how many times it remains the current_winner before being defeated.

But in this setup, it's not directly helping me to maximize the wins for my cow.

Wait, maybe I can see that the number of wins for a cow is equal to the number of cows after it that it can defeat before being defeated itself.

But I need to consider the sequence of matches.

This is getting too complicated.

Let me look for a different approach.

I recall that in such tournament problems, sometimes it's useful to find the minimal or maximal elements and see how they affect the outcome.

But here, since I can swap my cow once, I need to find the best position for it to maximize its wins.

Let me consider that my cow needs to be placed before higher-rated cows to maximize its wins.

Wait, but higher-rated cows would likely win more matches, but I need to see how my cow can win as many matches as possible.

Wait, perhaps I need to place my cow just after the lowest possible higher-rated cow.

Wait, maybe I need to find the cows with ratings higher than my cow's rating and see how their positions affect my cow's path.

Let me think about the cows with ratings higher than a_k.

These are the cows that can defeat my cow.

So, in the tournament, my cow can keep winning until it faces a higher-rated cow.

So, the number of wins is determined by how many lower-rated cows are between my cow and the nearest higher-rated cow.

But in the tournament structure, it's not exactly that, because the winner progresses to the next match.

Wait, maybe I can find the number of cows with lower ratings that are before my cow in the sequence, and that can be defeated by my cow before it faces a higher-rated cow.

This is still unclear.

Let me try to think in terms of the initial sequence and see what happens.

Suppose I have the initial sequence a = [a1, a2, ..., an].

I can precompute the winner of the entire tournament by iteratively comparing the current winner with the next cow.

But I need to maximize the wins for my cow, not necessarily winning the entire tournament.

I need to see how many matches my cow can win, which is equivalent to how many cows it can defeat before being defeated itself.

So, perhaps I can find, for a given position of my cow, how many cows with lower ratings are after it, until the first cow with a higher rating.

But again, considering the tournament structure, it's not straightforward.

I need to think differently.

Let me consider that in the tournament, the current winner is the one with the highest rating among all the cows it has faced so far.

So, the final winner is the cow with the highest rating in the entire sequence.

Now, for my cow, I want it to win as many matches as possible, which means it should face as many lower-rated cows as possible before facing a higher-rated cow.

So, perhaps I should place my cow just before the highest-rated cow, so it can win all the matches until then.

But that might not be optimal, because there might be a sequence where my cow can win more matches by being placed elsewhere.

Wait, perhaps I need to find the position where the previous winner has a lower rating than my cow, and then my cow can win against as many subsequent cows as possible.

Let me try to formalize this.

Define:

- Let r = a_k be the rating of my cow.

- Let p be the position where I place my cow.

- Let w_p be the rating of the winner before my cow at position p.

If w_p < r, then my cow wins and becomes the new winner, and then it faces the next cows.

The number of wins is equal to the number of cows after position p that have ratings lower than r, until the first cow with rating higher than r.

So, for each possible position p, I can calculate the number of wins as:

- If w_p >= r, then 0 wins, because my cow loses immediately.

- Else, count the number of cows after p with ratings < r until the first cow with rating > r.

But I need to find w_p, the rating of the winner before position p.

This seems tricky because w_p depends on the sequence before p.

Wait, perhaps I can precompute the winner up to each position.

Let me try that.

Define an array w where w[i] is the rating of the winner up to position i.

Initialize w[0] = a[0].

For i from 1 to n-1:

w[i] = max(w[i-1], a[i])

Wait, but in the tournament, it's not just the maximum, it's the winner of the previous match versus the next cow.

Wait, no.

Let me think again.

In the tournament:

- Match 1: cow 1 vs cow 2 → winner is max(a1, a2)

- Match 2: winner of match 1 vs cow 3 → winner is max(w1, a3)

- Match 3: winner of match 2 vs cow 4 → winner is max(w2, a4)

- And so on.

So, the winner up to position i is the maximum rating among the cows up to position i.

Wait, is that correct?

Wait, no.

Actually, in each match, the winner is the one with the higher rating.

So, the winner up to position i is the maximum rating among the winners of the previous matches.

Wait, more precisely:

- After match 1, the winner has the higher of a1 and a2.

- In match 2, this winner plays against a3, and the winner is the higher of the two.

- So, the winner up to match 2 is the maximum of a1, a2, a3.

- Similarly, the winner up to match 3 is the maximum of a1, a2, a3, a4.

- And so on.

Wait, yes, the winner up to position i is the maximum rating among the first i+1 cows.

So, w[i] = max(a1, a2, ..., a_{i+1})

Because in each match, the current winner is faced with the next cow, and the higher-rated one wins.

Hence, w[i] = max(a[0..i])

So, w[i] can be computed by taking the prefix maximum of the array a.

Okay, that's helpful.

So, w[i] = max(a[0], a[1], ..., a[i])

Now, if I place my cow at position p, then:

- The winner up to position p-1 is w[p-1].

- If w[p-1] > a_k, then my cow loses immediately.

- Else, my cow becomes the new winner and can proceed to face the next cows.

- My cow will keep winning as long as its rating is higher than the ratings of the subsequent cows.

- It will stop when it faces a cow with a higher rating.

So, the number of wins is:

- If w[p-1] >= a_k, then 0.

- Else, find the smallest q > p such that a[q] > a_k, and the number of wins is q - p.

- If no such q exists, then it's n - p.

Wait, but in the tournament structure, it's not exactly q - p, because the matches are not sequential in that way.

Wait, perhaps I need to think differently.

Given that w[p-1] < a_k, my cow can win against w[p-1] and become the new winner.

Then, it will face the next cow, which is cow p+1.

If a[p+1] < a_k, it wins again.

It continues winning until it faces a cow with a rating higher than a_k.

So, the number of wins is equal to the number of cows after position p that have ratings less than a_k, until the first cow with rating greater than a_k.

Hence, it's the length of the sequence from p+1 to the first cow with rating > a_k, where all cows have rating < a_k.

So, it's similar to finding the length of the sequence from p+1 where a[j] < a_k until the first a[j] > a_k.

But in the tournament structure, since the winner up to position p-1 is w[p-1], and if w[p-1] < a_k, then my cow becomes the new winner and can proceed to win against all cows with ratings < a_k until it faces a cow with rating > a_k.

Hence, the number of wins is equal to the number of cows after p with ratings < a_k until the first cow with rating > a_k.

So, for each possible p, I can compute this number.

But I need to choose p optimally, considering that I can only swap my cow with one other cow.

Wait, but actually, I can choose to place my cow at any position by swapping it with another cow.

So, I need to choose p such that:

- I can place my cow at position p by swapping it with the cow currently at position p.

- Note that swapping my cow with position p means that my cow goes to p, and the cow that was at p goes to k.

- But in the tournament, I'm only interested in my cow, so I need to consider where my cow is placed.

- The other cow that was at p is now at k, but since I'm only interested in my cow, I can ignore what happens to the other cows.

Wait, no, because the sequence of matches depends on the positions of all cows.

But since I'm only interested in my cow, and assuming that I place it at position p, then the tournament proceeds with the new sequence.

So, for each possible p, I can consider placing my cow at p and compute the number of wins.

Then, I choose the p that maximizes this number.

But since n can be up to 10^5 and t up to 10^4, with sum of n over all test cases up to 10^5, I need an efficient way to compute this.

Let's see.

First, compute w[p-1] for all p.

w[p-1] is the maximum of a[0] to a[p-1].

Then, for each p, if w[p-1] < a_k, then my cow can win against w[p-1] and become the new winner.

Then, it will face a[p+1], then a[p+2], and so on, until it faces a cow with rating > a_k.

So, for each p, I need to find the smallest q > p such that a[q] > a_k, and the number of wins is q - p - 1.

If no such q exists, then it's n - p - 1.

Also, if p == 0, w[-1] is undefined, so w[-1] can be considered as negative infinity, so my cow can always win against it.

Wait, in programming terms, w[-1] = -infinity.

Hence, for p == 0, my cow can always win, provided a_k > a[0].

Wait, but a_k might be less than a[0].

Wait, no, w[-1] is -infinity, so a_k > -infinity, so my cow can always win against w[-1], so it's only limited by the cows after p.

Wait, but in reality, for p == 0, w[-1] doesn't exist, so the first match is between my cow at p=0 and cow at p=1.

Wait, perhaps I need to handle p == 0 separately.

But according to the problem, the first match is between cow 1 and cow 2, assuming positions are 0-based.

Wait, the problem says:

"the first match is between the cow in position 1 and the cow in position 2."

Wait, the problem is 1-indexed for positions.

Wait, no, in the problem statement:

"There are n cows participating in a coding tournament. Cow i has a Cowdeforces rating of a_i (all distinct), and is initially in position i ."

Then,

"the first match is between the cow in position 1 and the cow in position 2."

Assuming position 1 is index 0 in 0-based indexing.

So, in 0-based indexing:

- Match 1: cow 0 vs cow 1.

- Match 2: winner of match 1 vs cow 2.

- Match 3: winner of match 2 vs cow 3.

- And so on.

Hence, w[p-1] is the winner up to position p-1.

So, for p == 0, p-1 == -1, which is undefined.

In this case, there is no previous winner, so my cow at p=0 automatically becomes the winner, provided it wins against cow 1.

Wait, no.

In the tournament structure:

- Match 1: cow 0 vs cow 1.

- Match 2: winner of match 1 vs cow 2.

- And so on.

So, for p