Alright, I have this problem to solve. Let's understand what's being asked here. We have n signs of the apocalypse, each occurring every a_i years. These signs must occur sequentially, meaning each sign must happen one after the other in the order specified. So, if the first sign occurs in year x, we start waiting for the second sign from year x+1, and so on.

First, I need to parse the input. The input consists of multiple test cases. The first line is an integer t, representing the number of test cases. For each test case, there's an integer n, which is the number of signs, followed by n integers representing the periodicity of each sign.

My goal is to find out in which year the nth sign will occur, given that each sign must occur strictly after the previous one.

Let me think about how to approach this.

Each sign occurs every a_i years. So, for the first sign, it occurs in years a_1, 2*a_1, 3*a_1, and so on. Similarly, for the second sign, it occurs in years a_2, 2*a_2, 3*a_2, etc.

But there's a catch: each sign must occur after the previous one. So, the occurrence of the second sign must be after the first sign's occurrence, and so forth.

Let me try to formalize this.

Let's say we have the current year, starting from year 0. For each sign, we need to find the earliest year in which it occurs after the previous sign's year.

So, for the first sign, it's straightforward: the earliest occurrence is in year a_1.

For the second sign, it must occur in a year that is a multiple of a_2 and is greater than the year in which the first sign occurred.

Similarly, for the third sign, it must occur in a year that is a multiple of a_3 and is greater than the year in which the second sign occurred.

And so on, until the nth sign.

So, for each sign i from 1 to n, given the previous sign's year (let's call it prev_year), I need to find the smallest year y such that:

1. y is a multiple of a_i.

2. y > prev_year.

Once I find y, it becomes the new prev_year for the next sign.

Finally, the year in which the nth sign occurs is the answer for that test case.

Let me try to implement this logic step by step.

First, I need to read t, the number of test cases.

Then, for each test case:

- Read n, the number of signs.

- Read the list of a_i's, the periodicities of the signs.

Initialize prev_year to 0.

Then, for each sign from 1 to n:

- Find the smallest y such that y is a multiple of a_i and y > prev_year.

- Set prev_year to y.

Finally, output prev_year for that test case.

Now, how do I find the smallest y that is a multiple of a_i and y > prev_year?

Well, y should be the smallest multiple of a_i that is strictly greater than prev_year.

Mathematically, y = ceil((prev_year + 1)/a_i) * a_i.

Alternatively, in code, I can calculate it as:

if prev_year % a_i == 0:

next_year = prev_year + a_i

else:

next_year = (prev_year // a_i + 1) * a_i

Yes, that seems correct.

Let me test this logic with the first example:

Test case 1:

n = 6

a = [3, 2, 4, 5, 9, 18]

Start with prev_year = 0

First sign: a_i = 3

prev_year = 3

Second sign: a_i = 2

Find smallest y > 3 that is a multiple of 2.

y = 4

prev_year = 4

Third sign: a_i = 4

Find smallest y > 4 that is a multiple of 4.

y = 8

prev_year = 8

Fourth sign: a_i = 5

Find smallest y > 8 that is a multiple of 5.

y = 10

prev_year = 10

Fifth sign: a_i = 9

Find smallest y > 10 that is a multiple of 9.

y = 18

prev_year = 18

Sixth sign: a_i = 18

Find smallest y > 18 that is a multiple of 18.

y = 36

prev_year = 36

So, the answer is 36, which matches the first output in the example.

Good.

Let's check the second test case:

n = 5

a = [1, 2, 3, 4, 5]

Start with prev_year = 0

First sign: a_i = 1

y = 1

prev_year = 1

Second sign: a_i = 2

y = 2

prev_year = 2

Third sign: a_i = 3

y = 3

prev_year = 3

Fourth sign: a_i = 4

y = 4

prev_year = 4

Fifth sign: a_i = 5

y = 5

prev_year = 5

So, the answer is 5, which matches the second output in the example.

Third test case:

n = 5

a = [1, 1, 1, 1, 1]

Start with prev_year = 0

First sign: a_i = 1

y = 1

prev_year = 1

Second sign: a_i = 1

y = 2

prev_year = 2

Third sign: a_i = 1

y = 3

prev_year = 3

Fourth sign: a_i = 1

y = 4

prev_year = 4

Fifth sign: a_i = 1

y = 5

prev_year = 5

So, the answer is 5, matching the third output.

Fourth test case:

n = 6

a = [50, 30, 711, 200, 503, 1006]

Start with prev_year = 0

First sign: a_i = 50

y = 50

prev_year = 50

Second sign: a_i = 30

Find smallest y > 50 that is a multiple of 30.

y = 60

prev_year = 60

Third sign: a_i = 711

Find smallest y > 60 that is a multiple of 711.

y = 711

prev_year = 711

Fourth sign: a_i = 200

Find smallest y > 711 that is a multiple of 200.

y = 800

prev_year = 800

Fifth sign: a_i = 503

Find smallest y > 800 that is a multiple of 503.

y = 1006

prev_year = 1006

Sixth sign: a_i = 1006

Find smallest y > 1006 that is a multiple of 1006.

y = 2012

prev_year = 2012

So, the answer is 2012, matching the fourth output.

Seems like the logic is correct.

Now, let's look at the given program and see if it implements this logic.

The program reads t, then reads all test cases, stores them in test_cases, then calls func_1(t, test_cases), which processes each test case and collects the results, which are then printed one by one.

Looking at func_1:

def func_1(t, test_cases):

results = []

for test in test_cases:

(n, a) = test

current_year = 0

for ai in a:

if current_year % ai == 0:

next_year = current_year + ai

else:

next_year = (current_year // ai + 1) * ai

current_year = next_year

results.append(current_year)

return results

This seems to match the logic I described earlier.

It initializes current_year to 0, then for each a_i in the list a, it calculates the next_year as the smallest multiple of a_i that is greater than current_year.

It does this by checking if current_year is already a multiple of a_i. If it is, then the next multiple is current_year + a_i. If not, it calculates the next multiple using (current_year // ai + 1) * ai.

This aligns with my earlier reasoning.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]