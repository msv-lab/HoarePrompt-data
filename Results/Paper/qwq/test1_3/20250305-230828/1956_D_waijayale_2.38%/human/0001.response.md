Alright, I've got this problem to solve. So, let's understand what's being asked here. I have an array of integers, and I can perform a specific operation on it multiple times. The operation involves choosing a subarray defined by indices l and r, computing the MEX of that subarray, and then setting all elements in that subarray to that MEX value. The goal is to maximize the sum of the array after performing these operations, and I need to output the maximum sum along with a sequence of operations that achieve this sum.

First, I need to make sure I understand what MEX means. MEX of a set of integers is the smallest non-negative integer not present in the set. For example, MEX of [0, 1, 2] is 3, MEX of [1, 2, 3] is 0, and MEX of [0, 2, 3] is 1.

Given that n can be up to 18, it's manageable to consider exponential time solutions, but I need to be careful with the number of operations since it's limited to 5*10^5, which is half a million operations. However, considering n is small, maybe I can find an efficient way to maximize the sum without using too many operations.

Looking at the provided code, there are a few functions: func_1, func_2, and func_3. Func_3 seems to be the main function that reads input and calls func_2, which in turn calls recursive_maximize_sum. Func_1 appears to be a helper function that performs operations on the array.

Let's dive into func_2 and recursive_maximize_sum to understand the logic.

In func_2, there's a function called recursive_maximize_sum that takes left and right indices as parameters. It seems to be a recursive function that tries to maximize the sum of the subarray from l to r.

The first thing it does is calculate the sum of the subarray from l to r and checks if this sum is less than or equal to the square of the length of the subarray (i.e., (r - l + 1)^2). If it is, it calls func_1 to perform operations that set the entire subarray to the length of the subarray, and then appends an operation to ops.

If the sum is greater than (r - l + 1)^2, it finds the maximum value in the subarray and its position, then recursively calls recursive_maximize_sum on the left and right parts of the subarray around this maximum.

This seems like a divide-and-conquer approach where the array is split around the maximum elements, and operations are performed on segments where the sum can be increased by setting them to their length.

Now, func_1 is another function that seems to ensure that a subarray from l to r is set to a certain value, possibly the MEX of that subarray.

Looking at the operations, it seems like the strategy is to identify segments where replacing the elements with their length can increase the sum, and do so, especially focusing on segments where the sum is less than or equal to the square of their length.

I need to verify if this approach indeed maximizes the sum.

Let's consider the examples provided:

First example:

Input:

2

0 1

Output:

4 1

1 2

Explanation: After setting a[1:2] to MEX([0,1])=2, the array becomes [2,2], sum=4.

It's claimed that 4 is the maximum possible sum.

Is this correct? Let's see.

Possible operations:

- Choose l=1, r=1: MEX([0])=1, set a[1]=1. Array becomes [1,1]. Sum=2.

- Choose l=2, r=2: MEX([1])=0, set a[2]=0. Array becomes [1,0]. Sum=1.

- Choose l=1, r=2: MEX([0,1])=2, set a[1:2]=2. Array becomes [2,2]. Sum=4.

Indeed, 4 seems to be the maximum.

Second example:

Input:

3

1 3 9

Output:

13 0

No operations are performed, and the sum remains 13.

Is this optimal? Let's check.

Possible operations:

- Choose l=1, r=1: MEX([1])=0, set a[1]=0. Array becomes [0,3,9]. Sum=12.

- Choose l=2, r=2: MEX([3])=0, set a[2]=0. Array becomes [1,0,9]. Sum=10.

- Choose l=3, r=3: MEX([9])=0, set a[3]=0. Array becomes [1,3,0]. Sum=4.

- Choose l=1, r=2: MEX([1,3])=0, set a[1:2]=0. Array becomes [0,0,9]. Sum=9.

- Choose l=1, r=3: MEX([1,3,9])=0, set a[1:3]=0. Array becomes [0,0,0]. Sum=0.

- Choose l=2, r=3: MEX([3,9])=0, set a[2:3]=0. Array becomes [1,0,0]. Sum=1.

So, indeed, without any operations, the sum is maximized at 13.

Third example:

Input:

4

1 100 2 1

Output:

105 2

3 3

3 4

Explanation:

- After first operation (l=3, r=3): MEX([2])=0, set a[3]=0. Array becomes [1,100,0,1]. Sum=102.

- After second operation (l=3, r=4): MEX([0,1])=2, set a[3:4]=2. Array becomes [1,100,2,2]. Sum=105.

Is this the maximum? Let's see.

Alternative operations:

- Choose l=1, r=4: MEX([1,100,2,1])=0, set a[1:4]=0. Sum=0.

- Choose l=1, r=2: MEX([1,100])=0, set a[1:2]=0. Array becomes [0,0,2,1]. Sum=3.

- Choose l=2, r=4: MEX([100,2,1])=0, set a[2:4]=0. Array becomes [1,0,0,0]. Sum=1.

- Choose l=1, r=1: MEX([1])=0, set a[1]=0. Array becomes [0,100,2,1]. Sum=103.

- Choose l=2, r=2: MEX([100])=0, set a[2]=0. Array becomes [1,0,2,1]. Sum=4.

- Choose l=3, r=4: MEX([2,1])=0, set a[3:4]=0. Array becomes [1,100,0,0]. Sum=101.

- Choose l=4, r=4: MEX([1])=0, set a[4]=0. Array becomes [1,100,2,0]. Sum=103.

So, the operations provided in the sample output seem to achieve a higher sum of 105, which seems optimal.

Fourth example:

Input:

1

0

Output:

1 1

1 1

Explanation: Choose l=1, r=1: MEX([0])=1, set a[1]=1. Sum=1.

Indeed, this is the maximum possible sum for a single element starting at 0.

Now, looking back at the code, I need to verify if the approach is correct and if it always maximizes the sum.

The key idea seems to be that for a subarray, if the sum of its elements is less than or equal to the square of its length, it's beneficial to set the entire subarray to its length, as this will increase the sum.

For example, in the first sample, the array is [0,1], sum=1, length=2, 2^2=4. Since 1 <= 4, setting the subarray to 2 increases the sum to 4.

In the second sample, [1,3,9], sum=13, length=3, 3^2=9. Since 13 > 9, no operation is performed.

In the third sample, [1,100,2,1], sum=104, length=4, 4^2=16. Since 104 > 16, no operation is performed on the entire array, but operations are performed on subarrays.

The recursive_maximize_sum function seems to identify segments where sum <= (length)^2 and performs operations on them.

However, I need to think carefully if this is always correct.

Consider a subarray with sum > (length)^2. In such cases, the function seems to find the maximum element and split the array around it, recursively processing the left and right parts.

Is this the right approach?

Let me think of a counterexample where this approach might not lead to the maximum sum.

Suppose we have an array [0, 2, 0]. Sum = 2, length = 3, 3^2 = 9. Since 2 <= 9, the function would set the entire array to 3, resulting in [3,3,3], sum=9.

Is there a way to get a higher sum? Let's see:

- Operation on [1,1]: MEX([0])=1, set to 1: [1,2,0], sum=3.

- Operation on [2,2]: MEX([2])=0, set to 0: [1,0,0], sum=1.

- Operation on [3,3]: MEX([0])=1, set to 1: [1,0,1], sum=2.

- Operation on [1,2]: MEX([1,0])=2, set to 2: [2,2,0], sum=4.

- Operation on [2,3]: MEX([0,1])=2, set to 2: [2,2,2], sum=6.

- Operation on [1,3]: MEX([0,2,0])=1, set to 1: [1,1,1], sum=3.

So, the best sum I can get through operations is 6, but the function sets it to [3,3,3], sum=9, which is higher. So, in this case, the function's approach works.

Another example: [0,0,0]. Sum=0, length=3, 3^2=9. Set to 3: [3,3,3], sum=9.

Alternative operations:

- Operation on [1,1]: MEX([0])=1, set to 1: [1,0,0], sum=1.

- Operation on [1,2]: MEX([1,0])=2, set to 2: [2,2,0], sum=4.

- Operation on [1,3]: MEX([0,0,0])=1, set to 1: [1,1,1], sum=3.

So, again, the function's approach of setting the entire array to 3 gives a higher sum.

Wait a minute, but in the first example with [0,2,0], the function sets the entire array to 3, sum=9, which is better than any sequence of operations I can think of. So, perhaps this approach is correct.

Let me think about the general case.

Suppose we have a subarray of length k. The maximum sum we can achieve by setting all elements to x is k*x. We need to choose x such that x is the MEX of the subarray.

What is the MEX of a subarray? It's the smallest non-negative integer not present in the subarray.

So, if the subarray contains all integers from 0 to m-1, and m is missing, then MEX is m.

But in the function, it seems to set the subarray to k, the length of the subarray.

Is k always the MEX of the subarray?

No, not necessarily. For example, in [0,1,2], MEX is 3, which is equal to the length 3.

In [0,1,3], MEX is 2, which is less than the length 3.

In [1,2,3], MEX is 0, which is less than the length 3.

So, setting the subarray to k only works when the MEX is k, which is not always the case.

However, in the function, it sets the subarray to k regardless of the current MEX.

Wait, is that correct?

Looking back at func_1, it sets the subarray to r - l + 1, which is the length of the subarray.

But, as I just thought, the MEX might not be equal to the length.

So, is this a mistake in the code?

Wait, but in the examples, it seems to work.

In the first example, [0,1], MEX is 2, which is equal to the length 2.

In the third example, [1,100,2,1], MEX is 0, which is not equal to the length 4.

But the function sets it to 4.

Wait, no, in the third example, operations are performed on subarrays [3,3] and [3,4].

For [3,3], MEX([2])=0, set to 0.

Then [3,4], MEX([0,1])=2, set to 2.

So, it's not setting the entire array to its length, but rather performing operations on smaller subarrays where the MEX happens to be suitable.

I need to understand better.

Perhaps the function is trying to maximize the sum by identifying subarrays where setting them to their length increases the sum, and doing so recursively.

But, as I saw in my earlier example, [0,2,0], setting the entire array to 3 gives sum=9, which is better than any other sequence of operations.

But is this always the case?

Let me consider another example: [0,1,2,3].

Sum=6, length=4, 4^2=16.

According to the function, since 6 <= 16, set the entire array to 4, sum=16.

Is there a better sum?

Let's see:

- Operation on [1,4]: MEX([0,1,2,3])=4, set to 4: [4,4,4,4], sum=16.

- Operation on [1,3]: MEX([0,1,2])=3, set to 3: [3,3,3,3], sum=12.

- Operation on [2,4]: MEX([1,2,3])=0, set to 0: [0,0,0,3], sum=3.

- Operation on [1,2]: MEX([0,1])=2, set to 2: [2,2,2,3], sum=9.

- Operation on [3,4]: MEX([2,3])=0, set to 0: [2,2,0,0], sum=4.

- Operation on [1,1]: MEX([0])=1, set to 1: [1,1,2,3], sum=7.

- Operation on [2,2]: MEX([1])=0, set to 0: [1,0,2,3], sum=6.

- Operation on [3,3]: MEX([2])=0, set to 0: [1,1,0,3], sum=5.

- Operation on [4,4]: MEX([3])=0, set to 0: [1,1,2,0], sum=4.

So, the best sum is 16, achieved by setting the entire array to 4.

But in this case, MEX([0,1,2,3])=4, which is equal to the length 4.

So, setting to length works here.

Another example: [0,1,2,4].

Sum=7, length=4, 4^2=16.

Since 7 <= 16, the function would set the entire array to 4, sum=16.

But MEX([0,1,2,4])=3, which is less than the length 4.

So, setting to 4 is actually incorrect because MEX is 3, not 4.

Wait, is MEX([0,1,2,4])=3? Let's see: 0 is present, 1 is present, 2 is present, 3 is missing, 4 is present. So, MEX=3.

Therefore, setting the array to 4 is invalid because MEX is 3, not 4.

So, in this case, the function would set the array to 4, but MEX is 3, which means we can't set it to 4.

This suggests a flaw in the function's logic.

Wait, but looking back at the code, func_1 sets the subarray to r - l + 1, which is the length, but it should be setting it to the MEX of the subarray.

So, there's a discrepancy here.

Looking at the code again:

In func_1, it sets a[l:r+1] to r - l + 1, which is the length of the subarray.

But, according to the problem, it should set it to the MEX of the subarray.

So, this seems incorrect.

Wait, but in the first example, MEX([0,1])=2, which is equal to the length 2.

In the third example, MEX([1,100,2,1])=0, which is not equal to the length 4.

But in the operations provided, it first sets [3,3] to MEX([2])=0, then [3,4] to MEX([0,1])=2.

So, perhaps in some cases, the MEX happens to be equal to the length, and in other cases, it's not.

But in the code, it's unconditionally setting the subarray to its length, which is wrong because MEX might be different.

This seems like a mistake in the code.

So, if the code is setting the subarray to its length regardless of the actual MEX, it's incorrect.

In the earlier example I thought about, [0,1,2,4], the function would set the entire array to 4, but the MEX is 3, which is less than 4. So, this operation isn't allowed according to the problem statement.

Hence, the code is incorrect.

Wait, but in the sample inputs and outputs, it seems to work.

Let me check the first sample again.

Input:

2

0 1

Operation: set [1,2] to MEX([0,1])=2, resulting in [2,2], sum=4.

In the code, it sets [1,2] to r - l + 1 = 2 - 1 + 1 = 2, which matches the MEX in this case.

Similarly, in the third sample, for [3,3], MEX([2])=0, which is set correctly.

Then, [3,4], MEX([0,1])=2, set to 2.

So, in these cases, it happens to work because the MEX coincides with the length in some operations.

But in general, as in my example [0,1,2,4], it won't work because MEX is 3, but the code sets it to 4.

Therefore, the code is incorrect because it doesn't compute the MEX correctly; it just sets the subarray to its length.

Hence, the answer is:

Correctness: **False**

