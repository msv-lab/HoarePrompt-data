Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, a positive integer m, and a string of commands consisting of 'L's and 'R's. For each command, I need to output the product of the current array modulo m, and then remove either the leftmost or the rightmost element of the array based on whether the command is 'L' or 'R'.

First, I need to understand the problem clearly. I have to process n commands, where n is the length of the array and the string s. Each command corresponds to removing either the first or last element of the array and outputting the product of the remaining elements modulo m.

Looking at the example, it seems straightforward, but I need to make sure I handle the modulo operation correctly, especially since the product can get very large.

Let me think about how to approach this. One way is to simulate the process step by step: for each command, calculate the product of the current array modulo m, and then remove the appropriate element.

However, calculating the product from scratch each time would be inefficient, especially since n can be up to 2*10^5 and t can be up to 10^4, with the total sum of n across all test cases being up to 2*10^5.

I need a smarter way to compute the product modulo m efficiently.

Wait a minute, I recall that in problems involving products and removal of elements from either end, we can keep track of the product of the remaining elements by dividing out the removed element. But since we're dealing with modulo m, and m can be any positive integer, I need to handle division carefully, especially if m is not a prime number.

Actually, in modulo arithmetic, division is tricky unless we're working with a prime modulus, because not all elements have inverses. Since m can be any positive integer up to 10^4, I can't assume it's prime.

Alternatively, maybe I can keep track of the product of the remaining elements by multiplying and dividing by the removed elements appropriately.

But removing elements from either end and keeping track of the product seems challenging this way.

Let me consider another approach. Since all commands are given in advance, I can determine which elements are removed at each step and in what order.

Wait, actually, the commands specify the order in which elements are removed, either from the left or the right. So, the sequence of removed elements is determined by the string s.

Perhaps I can first collect the sequence of elements that are removed and in what order, and then compute the products accordingly.

Let me try to think differently. Suppose I have the initial product of all elements modulo m. Then, for each removal, I can divide the current product by the removed element and take modulo m again to get the new product.

But again, division in modulo m is not straightforward.

Wait, maybe I can keep track of the product of the remaining elements by maintaining a list of the remaining elements and updating the product as I remove elements.

But that seems inefficient for large n.

Let me consider the fact that elements are removed from either end, which suggests that the order of removal is important.

Maybe I can use a deque (double-ended queue) to simulate the removals, but I still need an efficient way to compute the product of the remaining elements each time.

Another idea: since the removals are either from the left or the right, the remaining elements after some removals will form a subarray that is a substring of the original array.

Wait, but with mixed 'L's and 'R's, the remaining elements might not be contiguous, but in this problem, since we're removing one at a time from either end, the remaining elements will always form a contiguous subarray.

Wait, no, actually, if I have a sequence like 'LRRL', as in the first example, let's see:

Start with [3,1,4,2]

First command 'L': remove 3, remaining [1,4,2]

Second command 'R': remove 2, remaining [1,4]

Third command 'R': remove 4, remaining [1]

Fourth command 'L': remove 1, remaining []

So, yes, the remaining elements are always a contiguous subarray.

Wait, but in the third step, after removing 4, remaining is [1], which is a contiguous subarray.

Wait, actually, no, in the second step, after removing 2, remaining is [1,4], which is contiguous.

Wait, but in general, with mixed 'L's and 'R's, the remaining subarray changes accordingly.

Wait, no, actually, it's always a subarray from some index l to some index r.

Wait, but in the first step, 'L' removes the first element, so the remaining array is from index 1 to n-1.

Then, 'R' removes the last element of the current array, so removes index n-1, remaining is from index 1 to n-2.

Then, another 'R' removes the last element again, so removes index n-2, remaining is from index 1 to n-3.

And so on.

Wait, in the example, n=4, so after first 'L', remove index 0, remaining [1,4,2].

Then 'R', remove index 2, remaining [1,4].

Then 'R', remove index 1, remaining [1].

Then 'L', remove index 0, remaining [].

So, yes, the remaining elements are always a contiguous subarray.

Wait, but in this process, the remaining subarray is from some l to some r, and l and r change based on the commands.

So, maybe I can keep track of the current l and r indices and compute the product of a[l..r] modulo m each time.

But computing the product from scratch each time is too slow for large n.

I need a way to compute the product of a subarray efficiently.

I recall that for sum queries, we can use prefix sums, but for product queries, it's more complicated because multiplication isn't as straightforward as addition.

However, since m can be up to 10^4, and a[i] can be up to 10^4, the product can be very large, so I need to handle modulo m properly.

Wait, maybe I can precompute prefix products modulo m.

Let me think about this.

Define prefix[i] = a[0] * a[1] * ... * a[i-1] mod m

Then, the product of a[l..r] would be prefix[r+1] * mod_inverse(prefix[l]) mod m, if mod_inverse exists.

But again, mod_inverse might not exist if m is not prime.

Wait, m is any positive integer up to 10^4, so it may not be prime.

Therefore, this approach might not work.

I need another way.

Let me consider that since m can be up to 10^4, and n can be up to 2*10^5, I need an efficient way to compute the product modulo m for each step.

Wait, maybe I can compute the product of the entire array modulo m, and then, for each removal, divide the current product by the removed element and take modulo m.

But division in modulo m is tricky.

Wait, perhaps I can precompute the modular inverses of all elements that will be removed.

But again, not all elements have inverses modulo m.

Wait, maybe I can factor m into its prime factors and handle each prime separately, but that seems complicated.

Let me think differently.

Maybe I can keep track of the product of the remaining elements by multiplying and dividing by the removed elements, but handle the modulo operation carefully.

Wait, but without inverses, division is not straightforward.

Another idea: since m is small (up to 10^4), I can compute the product modulo m directly, but I need to handle large intermediate products.

Wait, but in Python, integers can be arbitrarily large, so I can compute the product without worrying about overflow, and then take modulo m.

But for large n, say n=2*10^5, computing the product of 2*10^5 numbers each up to 10^4 would result in a very large number, which might be inefficient.

Python can handle big integers, but it's still not efficient for large n.

I need a better way.

Wait, perhaps I can compute the product incrementally.

Let me consider that after each removal, the product of the remaining elements is equal to the previous product divided by the removed element, modulo m.

But again, division is problematic.

Wait, maybe I can keep track of the product of the remaining elements and update it accordingly.

Wait, perhaps I can maintain a list of the remaining elements and compute their product modulo m each time.

But that would still be O(n^2) time in the worst case, which is too slow for n up to 2*10^5.

I need a more efficient approach.

Let me consider the sequence of removals.

Since the removals are either from the left or the right, the remaining elements are always a subarray in the middle.

So, perhaps I can keep track of the current subarray and compute its product modulo m efficiently.

But again, computing the product each time from scratch is too slow.

Wait, maybe I can precompute prefix products modulo m and use them to compute the product of the current subarray.

But as I mentioned earlier, division is a problem because m may not be prime.

Wait, perhaps I can handle the division by keeping track of the product of removed elements and somehow adjusting the current product.

But I'm not sure.

Let me consider another angle.

Suppose I process all removals first and keep track of which elements are removed, and in what order.

Then, I can compute the product of the initial array, and then, for each removal, divide by the removed element.

But again, division is tricky.

Wait, maybe I can compute the product of all elements, and then for each step, divide by the removed element and take modulo m.

But without inverses, this is not straightforward.

Wait, perhaps I can compute the product of all elements, and then for each step, divide by the removed element, but only if the removed element and m are coprime, i.e., gcd(a[i], m) == 1, in which case the inverse exists.

But if gcd(a[i], m) != 1, then division is not possible.

So, this approach seems problematic.

Let me think differently.

Maybe I can factor m into its prime factors and compute the product modulo each prime power, and then use the Chinese Remainder Theorem to combine the results.

But m can be up to 10^4, which is 10000, and factoring m might be time-consuming for large m.

Also, handling Chinese Remainder Theorem might be complicated.

I need a simpler approach.

Wait, perhaps I can precompute the product of all elements, and then for each removal, adjust the product by dividing by the removed element and multiplying by its inverse modulo m, if it exists.

But again, this runs into the problem that the inverse may not exist.

Wait, maybe I can compute the product of the remaining elements directly without dividing.

But how?

Let me consider that for each step, I need the product of the current subarray.

So, perhaps I can precompute prefix products and suffix products modulo m.

Define prefix[i] = a[0] * a[1] * ... * a[i-1] mod m

Define suffix[i] = a[i] * a[i+1] * ... * a[n-1] mod m

Then, at any step, the product of the remaining subarray can be expressed as prefix[l] * suffix[r] mod m, where l and r are the current left and right indices.

Wait, but this is not correct because prefix[l] and suffix[r] would overlap if l < r.

Wait, no, suffix[i] is the product from a[i] to a[n-1], so if the remaining subarray is from l to r, then product = prefix[l] * suffix[r] mod m, but prefix[l] includes a[0] to a[l-1], and suffix[r] includes a[r] to a[n-1], so their product would include a[0] to a[n-1], which is not what I want.

Wait, actually, the product of a[l..r] would be prefix[r+1] * inverse(prefix[l]) mod m, if inverse exists.

But again, inverse may not exist.

This seems like a dead end.

Let me consider another approach.

Perhaps I can process the removals in reverse order.

That is, start from the end, where the array is empty, and add elements in the reverse order of their removal.

Wait, that's an interesting idea.

If I process the commands in reverse, building up the array step by step, I can keep track of the current product modulo m.

Then, to get the sequence of products in the original order, I can reverse the final list.

Let's see.

Start with an empty array.

Then, for each command in reverse order:

- If the command is 'L', it means in the original sequence, we removed from the left. So, in reverse, we're adding to the left.

- Similarly, if the command is 'R', in reverse, we're adding to the right.

Wait, actually, in reverse, 'L' in original means we're adding to the left, and 'R' in original means adding to the right.

So, I can maintain a list or a deque, and add elements to the left or right based on the reverse command.

At each step, I can update the product by multiplying the new element.

Then, the product at each step in reverse would correspond to the product after that addition.

But in the original sequence, I need the product before the removal.

Wait, maybe this can work.

Let me try with the first example:

n=4, m=6, a=[3,1,4,2], s="LRRL"

Reverse s: "LRRL"

Start with empty array, product=1.

1. Reverse command 'L': add 1 (original first element) to the left.

Now array: [1], product=1*1=1 mod 6=1

2. Reverse command 'R': add 2 (original last element) to the right.

Now array: [1,2], product=1*2=2 mod 6=2

3. Reverse command 'R': add 4 to the right.

Now array: [1,2,4], product=2*4=8 mod 6=2

4. Reverse command 'L': add 3 to the left.

Now array: [3,1,2,4], product=2*3=6 mod 6=0

So, in reverse, the products are: 1,2,2,0

Reversing this gives: 0,2,2,1

But in the example output, it's 0,2,4,1

Wait, there's a discrepancy.

In the example, the outputs are 0,2,4,1, but according to this approach, I get 0,2,2,1.

So, something's wrong here.

Wait, perhaps I made a mistake in the calculation.

Let me recalculate:

Start with empty array, product=1.

1. Add 1 to the left: array=[1], product=1*1=1 mod 6=1

2. Add 2 to the right: array=[1,2], product=1*2=2 mod 6=2

3. Add 4 to the right: array=[1,2,4], product=2*4=8 mod 6=2

4. Add 3 to the left: array=[3,1,2,4], product=2*3=6 mod 6=0

But in the example, after first output 0, then 2, then 4, then 1.

So, according to this approach, I have 0,2,2,1, but the correct sequence is 0,2,4,1.

So, this approach is incorrect.

Wait, perhaps I need to multiply the new element with the current product and then take modulo m.

But that's what I did.

Wait, maybe I need to consider the order of multiplication.

Wait, perhaps I should be multiplying in the reverse order.

Wait, no, in reverse, I should be adding elements in the reverse order of removal.

Wait, maybe I need to multiply the product by the new element each time.

Wait, but that's what I did.

I'm confused why there's a discrepancy.

Wait, perhaps I need to think differently.

Let me consider that in the original sequence, the product at each step is the product of the current array modulo m.

So, in the first step, product is a[0]*a[1]*a[2]*a[3] mod 6=3*1*4*2=24 mod 6=0

Then, remove a[0]=3, remaining [1,4,2], product=1*4*2=8 mod 6=2

Then, remove a[3]=2 (since it's 'R'), remaining [1,4], product=1*4=4 mod 6=4

Then, remove a[2]=4, remaining [1], product=1 mod 6=1

Then, remove a[0]=1, remaining [], product=1 (but empty product is 1, but in modulo, it's 0?)

Wait, no, in the example, the output is 0,2,4,1.

Wait, but empty product should be 1, but maybe in the problem, it's considered 0.

Wait, no, in the problem statement, it says "output the remainder of the product of all elements of the array a when divided by m", and for an empty array, the product is 1, but in the example, for the last step, it's 1, which is correct.

Wait, but in the first step, the product is 0, which matches 24 mod 6=0.

Then, after removing 3, product is 8 mod 6=2.

Then, remove 2, product is 4 mod 6=4.

Then, remove 4, product is 1 mod 6=1.

So, the sequence is 0,2,4,1.

But in my reverse approach, I got 0,2,2,1, which is incorrect.

So, perhaps the reverse approach isn't working correctly.

Wait, maybe I need to handle the product differently in the reverse approach.

Let me try to think differently.

Perhaps I can collect the sequence of elements that are removed in the order specified by s, and then compute the products step by step.

Wait, but that would be O(n^2), which is too slow.

Wait, no, perhaps I can collect the elements that are removed and keep track of the product of the remaining elements.

Wait, but I still need an efficient way to compute the product modulo m at each step.

Another idea: precompute the product of all elements modulo m, and then for each removal, divide by the removed element if possible.

But again, division is tricky.

Wait, perhaps I can compute the product of all elements, and then for each step, divide by the removed element, but only if m and the removed element are coprime.

But if they are not coprime, then division is not possible.

This seems too complicated.

Let me consider that m is small, only up to 10^4, and n is up to 2*10^5.

Perhaps I can factor m into its prime factors and compute the product modulo each prime power, then use the Chinese Remainder Theorem to combine them.

But this seems too involved and time-consuming, especially since m can have multiple prime factors.

I need a simpler approach.

Wait, maybe I can compute the product of the array modulo m, and then keep track of the product as I remove elements, but adjust for the removal in a way that avoids division.

But I'm not sure how.

Let me consider that in each step, I'm removing one element, and I need to compute the product of the remaining elements modulo m.

So, if I have the product of all elements, and I remove one element, the product of the remaining elements should be (product * inverse of removed element) mod m, provided that the removed element and m are coprime.

But if they are not coprime, then the inverse doesn't exist, and this approach fails.

So, this is not reliable.

Wait, perhaps I can compute the product of the remaining elements directly by multiplying the elements that are still in the array.

But for n=2*10^5, this would be too slow if done naively.

I need a way to compute the product of a subarray efficiently.

Wait, perhaps I can precompute prefix and suffix products, and then for each step, compute the product as prefix[l] * suffix[r] mod m, where l and r are the current left and right indices.

But as I thought earlier, this doesn't account for the overlapping parts correctly.

Wait, no, actually, if I define prefix[i] as the product of a[0] to a[i-1] mod m, and suffix[i] as the product of a[i] to a[n-1] mod m, then the product of the subarray from l to r is (suffix[l] / a[l]^{n-r} ) mod m, but this seems too complicated.

I need another way.

Let me consider that since m is small, I can compute the product modulo m directly for each step, but in an efficient manner.

Wait, perhaps I can use logarithms to convert multiplication to addition, but in modulo m, this might not be straightforward.

Wait, that's not helpful.

Let me consider that in each step, I'm removing one element from either end, and I need to compute the product of the remaining elements modulo m.

So, perhaps I can keep track of the product of the elements that have not been removed yet.

Wait, but to compute this efficiently, I need a way to update the product quickly when removing an element.

But without division or inverses, I'm stuck.

Wait, maybe I can precompute the product of all elements, and then for each removal, adjust the product by some factor that accounts for the removed element.

But I don't see how.

Let me consider an alternative approach: since the sequence of removals is given, I can determine which elements are still in the array at each step.

In other words, for each step, I can know which elements have not been removed yet, and compute their product modulo m.

But again, this would be too slow for large n.

Wait, perhaps I can model the remaining array as a subarray and compute its product efficiently using precomputed prefix products.

But I'm back to the same issue.

I need to find a way to compute the product of a subarray efficiently modulo m.

Wait, maybe I can accept that computing the product directly is necessary, and find optimizations to make it efficient.

Given that n can be up to 2*10^5 and t can be up to 10^4, with the total sum of n across all test cases up to 2*10^5, I need an O(n) per test case solution.

So, perhaps I can accept that I need to compute the product for each step in O(1) time, but I don't see how.

Wait, maybe I can precompute the product of all elements, and then for each step, divide by the removed element, but handle the division carefully.

Wait, but without inverses, I need another way.

Let me consider that m is small, only up to 10^4, so perhaps I can compute the product modulo m directly without worrying about large intermediate values, since in Python, integers can handle large values.

But even in Python, computing the product of 2*10^5 numbers each up to 10^4 would result in a very large number, and taking modulo m each time would be time-consuming.

I need a better approach.

Wait, perhaps I can keep track of the product of the remaining elements by maintaining a variable that stores the current product, and update it as I remove elements.

But again, without division, I don't see how to update it efficiently.

Wait, maybe I can keep a list of the remaining elements and compute their product each time, but that would be O(n^2) time, which is too slow.

I need to think differently.

Let me consider that in each step, the array gets smaller by one element, so perhaps I can model the sequence of products as a sequence of multiplications and divisions.

But again, without division being straightforward in modulo m, this is problematic.

Wait, perhaps I can factor m and compute the product modulo each prime power factor, then use the Chinese Remainder Theorem to combine them.

But this seems too involved and time-consuming.

I need a simpler approach.

Let me consider that m can be factored into its prime factors, and for each prime power, compute the product modulo that prime power, then combine them.

But m is up to 10^4, which is 10000, and its prime factors can be handled, but it's still complicated.

I need a better way.

Wait, perhaps I can accept that for this problem, an O(n) per test case solution exists, and I need to implement it efficiently, even if it's not immediately obvious.

Given that, perhaps I can proceed with computing the product of the remaining elements for each step, accepting the time it takes.

But I need to make sure it's optimized.

Wait, perhaps I can precompute the product of all elements, and then for each removal, adjust the product by dividing by the removed element, but handle the division by computing the inverse if possible.

But as I thought earlier, this is problematic when the inverse doesn't exist.

Wait, maybe I can compute the greatest common divisor (gcd) of the removed element and m, and adjust the product accordingly.

Let's think about this.

If I remove an element a, and gcd