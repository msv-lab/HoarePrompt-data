Alright, I've got this problem to solve. Let's read it carefully.

So, Jay created a problem of difficulty x and wants to make it the second problem for Codeforces Round #921. But Yash is worried that this might make the contest unbalanced, so he decides to break this problem into n sub-problems, each with a positive integer difficulty, and the sum of these sub-problems should be equal to x.

Now, the coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems.

Our task is to find the maximum balance Yash can achieve by optimally choosing the difficulties of the sub-problems.

Input:

- First line: number of test cases t (1 ≤ t ≤ 10^3)

- Each test case: two integers x (1 ≤ x ≤ 10^8) and n (1 ≤ n ≤ x)

Output:

- For each test case, print a single integer: the maximum balance achievable.

Example:

Input:

3

10 3

5 5

420 69

Output:

2

1

6

Explanation for the first test case:

One possible way is to break the problem of difficulty 10 into sub-problems of difficulties 4, 2, and 4. The GCD is 2.

For the second test case:

Only one way: five sub-problems each of difficulty 1. GCD is 1.

For the third test case:

Somehow, the maximum GCD is 6.

Alright, now I need to think about how to approach this.

First, understanding what we need:

- We need to split x into n positive integers whose sum is x.

- Among all possible such splits, we need to choose the one where the GCD of the n integers is maximized.

So, the goal is to maximize the GCD of the n sub-problems.

Let me think about what GCD means. The GCD of a set of numbers is the largest number that divides all of them without leaving a remainder.

So, if I want to maximize the GCD, I need to find the largest possible d such that x can be split into n numbers, each of which is a multiple of d.

Wait, more formally:

Let’s say the GCD is d.

Then, each of the n sub-problems must be a multiple of d.

So, if I denote the sub-problems as a1, a2, ..., an, then:

a1 + a2 + ... + an = x

And GCD(a1, a2, ..., an) = d

Which implies that each ai is a multiple of d.

So, I can write ai = d * bi, where bi are positive integers.

Then, summing up:

d * (b1 + b2 + ... + bn) = x

So, d must be a divisor of x.

Also, since there are n sub-problems, and each bi >=1 (since ai are positive integers), the minimal sum of bi's is n (when all bi=1).

So, b1 + b2 + ... + bn >= n

Therefore, d * n <= x

Because d * n <= d * (b1 + b2 + ... + bn) = x

Hence, d <= x / n

So, the maximum possible d is floor(x / n)

But is this always achievable?

Wait, let's check with the examples.

First test case: x=10, n=3

Floor(10/3)=3

But in the example, they have chosen d=2, not 3.

Wait, is d=3 possible?

If d=3, then sum of bi's should be 10/3 = 3.333, which is not integer.

Wait, but bi must be integers.

Wait, sum of bi's must be floor(10/3)=3, but 3*3=9 <10.

So, it's not possible to have d=3.

Wait, perhaps I need to adjust my approach.

Let me think again.

Given that ai = d * bi, and sum ai = x, so d*(sum bi) = x

Also, bi >=1 for all i, so sum bi >=n

Therefore, d <= x / sum bi <= x / n

So, d <= floor(x/n)

But d must be such that x is divisible by d, because d divides x.

So, d must be a divisor of x.

Hence, to maximize d, I need to find the largest divisor of x that is less than or equal to floor(x/n).

So, the approach is:

- Find all divisors of x.

- Find the largest divisor that is <= floor(x/n).

That should be the maximum possible d.

Let me verify this with the first test case.

x=10, n=3

floor(10/3)=3

Divisors of 10: 1,2,5,10

The largest divisor <=3 is 2.

Which matches the example.

Second test case:

x=5, n=5

floor(5/5)=1

Divisors of 5:1,5

Largest divisor <=1 is 1.

Which matches the example.

Third test case:

x=420, n=69

floor(420/69)= floor(6.087)=6

Divisors of 420: 1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420

Largest divisor <=6 is 6.

Which matches the example.

So, this seems correct.

Hence, the algorithm is:

- For each test case, given x and n,

- Compute floor(x/n)

- Find all divisors of x

- Find the largest divisor that is <= floor(x/n)

- That's the answer.

Now, to implement this efficiently, especially since x can be up to 10^8 and t up to 10^3, I need an efficient way to find the divisors of x.

Finding all divisors of a number up to 10^8 can be time-consuming if done naively for 10^3 test cases.

So, I need an optimized way.

I recall that the number of divisors of a number is usually small, especially for numbers up to 10^8.

In fact, the maximum number of divisors for numbers up to 10^8 is around 100-200, but on average, it's much smaller.

So, an optimized approach would be to iterate through possible divisors up to sqrt(x), and collect them.

Then, find the largest divisor that is <= floor(x/n)

Let's think about the implementation.

First, for each test case:

- Read x and n

- Compute floor(x/n)

- Find all divisors of x

- Among these divisors, find the largest one that is <= floor(x/n)

- Print that divisor

Now, to find all divisors of x, I can iterate from 1 to sqrt(x), and for each i that divides x, add both i and x/i to the list of divisors, unless i==x/i.

Then, sort the list of divisors in descending order, and find the largest one that is <= floor(x/n)

But since x can be up to 10^8, and t up to 10^3, and finding divisors for each test case, I need to make sure that the implementation is efficient.

I think it should be fine, as finding divisors up to sqrt(x) is efficient.

Let me think about possible edge cases.

Edge Cases:

1. n=1

- Then, the only sub-problem has difficulty x, so GCD is x.

- So, answer is x.

2. n=x

- Then, each sub-problem has difficulty 1, since sum is x and there are x sub-problems.

- So, GCD is 1.

3. x < n

- This should be invalid, but according to the constraints, n <=x, so x >=n.

4. x is divisible by n

- Then, d = x/n is possible, and it's a divisor of x.

- So, d = x/n is achievable.

5. x is not divisible by n

- Then, d must be less than x/n.

- So, find the largest divisor of x that is <= floor(x/n)

Let me consider an example where d is not x/n.

Like the first test case: x=10, n=3

floor(10/3)=3

Divisors of 10:1,2,5,10

Largest divisor <=3 is 2.

So, possible splits:

- 2,2,6 (GCD=2)

- 2,4,4 (GCD=2)

- 1,3,6 (GCD=1)

- 1,4,5 (GCD=1)

- 3,3,4 (GCD=1)

So, indeed, the maximum GCD is 2.

Another example:

x=12, n=3

floor(12/3)=4

Divisors of 12:1,2,3,4,6,12

Largest divisor <=4 is 4.

Possible splits:

-4,4,4 (GCD=4)

-3,3,6 (GCD=3)

-2,4,6 (GCD=2)

-1,5,6 (GCD=1)

So, maximum GCD is 4.

Another example:

x=15, n=4

floor(15/4)=3

Divisors of 15:1,3,5,15

Largest divisor <=3 is 3.

Possible splits:

-3,3,3,6 (GCD=3)

-3,3,4,5 (GCD=1)

-2,3,5,5 (GCD=1)

-1,4,5,5 (GCD=1)

So, maximum GCD is 3.

Seems correct.

Now, think about implementation.

I need to find all divisors of x efficiently.

I can do this by iterating from 1 to sqrt(x), and for each i that divides x, add both i and x/i to the list of divisors.

Then, find the largest divisor that is <= floor(x/n)

Also, need to handle the case when floor(x/n)=0, but since n<=x, floor(x/n)>=1.

Wait, for n=1, floor(x/1)=x, and d=x is possible.

For n=x, floor(x/x)=1, d=1 is possible.

Ok.

Now, in code, I need to read t test cases, for each test case, read x and n, compute floor(x/n), find all divisors of x, find the largest divisor <= floor(x/n), and print it.

I need to make sure that the code is efficient, as t can be up to 10^3 and x up to 10^8.

I should avoid redundant computations.

Also, precomputing divisors for all x up to 10^8 is not feasible, as it would be too time-consuming.

So, for each test case, compute the divisors on the fly.

But since t=10^3 and x=10^8, and finding divisors up to sqrt(x) is around 10^4 operations per test case, total operations would be around 10^7, which should be acceptable.

Now, think about the given code.

Wait, the problem says: "Assume valid inputs as described in the problem description."

So, I don't need to handle invalid inputs.

Now, look at the given code.

from math import sqrt

def func():

for q in range(int(input())):

(x, n) = list(map(int, input().split(' ')))

ans = 1

for i in range(1, int(sqrt(x)) + 1):

if x % i == 0:

if x - n * i >= 0 and (x - n * i) % i == 0:

ans = max(ans, i)

if x - n * (x // i) >= 0 and x // i > 0 and ((x - n * (x // i)) % (x // i) == 0):

ans = max(ans, x // i)

print(ans)



So, the code defines a function func(), which reads t test cases, and for each test case, reads x and n, initializes ans=1, then iterates i from 1 to sqrt(x), and for each i that divides x, checks two conditions:

1. if x - n * i >=0 and (x - n * i) % i ==0, then ans = max(ans, i)

2. if x - n * (x // i) >=0 and x // i >0 and (x - n * (x // i)) % (x // i) ==0, then ans = max(ans, x // i)

Finally, prints ans.

Wait, this seems a bit convoluted.

Let me try to understand what's happening here.

First, it's trying to find divisors of x by iterating i from 1 to sqrt(x).

For each i that divides x (i.e., x % i ==0), it considers both i and x//i as potential divisors.

Then, for each such i, it checks:

1. If x - n * i >=0 and (x - n * i) % i ==0, then updates ans to max(ans, i)

2. Similarly, if x - n * (x//i) >=0 and x//i >0 and (x - n * (x//i)) % (x//i) ==0, then updates ans to max(ans, x//i)

Wait, why is it doing this?

Let me recall that for each divisor d, it needs to check if it's possible to split x into n numbers, each multiple of d, summing up to x.

From earlier reasoning, d <= floor(x/n), and d must divide x.

So, perhaps this code is trying to find the largest d that divides x and for which x - n*d is divisible by d.

Wait, let's see.

In the first condition:

if x - n * i >=0 and (x - n * i) % i ==0:

ans = max(ans, i)

This seems to be checking if d=i, then x - n*d should be divisible by d.

Similarly, the second condition is checking for d=x//i.

Wait, but according to our earlier reasoning, d should be <= floor(x/n), and a divisor of x.

So, perhaps this code is trying to find the largest d that is a divisor of x and d <= floor(x/n), and (x - n*d) is divisible by d.

Wait, but x - n*d should be zero or something, I need to think carefully.

Wait, in our earlier reasoning, we have:

sum of ai = x, with ai = d * bi, and sum bi >=n

So, d * sum bi = x, with sum bi >=n

Hence, d <= x / n

And d must divide x.

So, perhaps the condition (x - n*d) % d ==0 is to ensure that x - n*d is a multiple of d, but since d divides x, and d divides n*d, it should automatically hold that d divides x - n*d.

Wait, but only if n*d <=x.

Which it should be, since d <= floor(x/n)

Wait, perhaps this is just a way to ensure that d <= floor(x/n)

But I'm not entirely sure about the logic here.

Let me try to see with an example.

Take x=10, n=3

floor(x/n)=3

Divisors of 10:1,2,5,10

Check d=1: x - n*d =10-3*1=7, 7%1==0? yes

d=2: x - n*d=10-6=4, 4%2==0? yes

d=5: x - n*d=10-15= -5, which is <0, so skip

d=10: x - n*d=10-30= -20, <0, skip

So, among d=1 and d=2, the largest is d=2, which is correct.

Another example: x=5, n=5

floor(5/5)=1

Divisors:1,5

d=1: 5-5*1=0, 0%1==0? yes

d=5: 5-5*5=-20,<0, skip

So, ans=1, correct.

Another example: x=420, n=69

floor(420/69)=6

Divisors of 420:1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420

Check d=6: x - n*d=420-69*6=420-414=6, 6%6==0? yes

d=5: x - n*5=420-345=75, 75%5==0? yes

d=4: x - n*4=420-276=144, 144%4==0? yes

d=3: x - n*3=420-207=213, 213%3==0? yes

d=2: x - n*2=420-138=282, 282%2==0? yes

d=1: x - n*1=420-69=351, 351%1==0? yes

So, the largest d is 6, which is correct.

Seems like this logic works.

But is there a better way to think about it?

Well, according to our earlier reasoning, the maximum d is the largest divisor of x that is <= floor(x/n)

So, in the code, instead of checking (x - n*d) % d ==0, which is redundant because d divides x and d divides n*d, hence d divides x - n*d.

So, the condition (x - n*d) % d ==0 is always true when d divides x.

Hence, we can simplify the code to just find the largest divisor of x that is <= floor(x/n)

So, the code can be improved for clarity.

But the given code seems to be working correctly, even though it's a bit convoluted.

Hence, I would say that the given program is correct.

**Final Answer**

\boxed{\text{Yes}}