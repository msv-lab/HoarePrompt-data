Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX of an array is the smallest non-negative integer not present in that array. For example, MEX of [1,2,3] is 0, because 0 is the smallest non-negative integer not in the array. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. I need to find which number is at each position in p based on the a array.

Let's consider the first element p_1. The MEX of just p_1 is the smallest non-negative integer not equal to p_1. So, if p_1 is x, then MEX(p_1) is 0 if x is not 0, otherwise it's 1. Wait, no. If p_1 is 0, then MEX is 1, because 0 is present. If p_1 is 1, MEX is 0, since 0 is missing. So, a_1 = MEX(p_1) - p_1.

Let me try to express p_i in terms of a_i and MEX.

Given a_i = MEX(p_1 to p_i) - p_i, so p_i = MEX(p_1 to p_i) - a_i.

I need to find p_i, but MEX depends on all previous p's, so this seems a bit circular. Maybe I need to find a way to compute MEX incrementally as I build the permutation.

Let me think about the MEX function. As I add more elements to the array, the MEX can only stay the same or increase. It can't decrease because once a number is used, it's present in the array, and the MEX is the smallest missing number.

So, as I build the permutation step by step, keeping track of the MEX at each step, and using the a_i to find p_i.

Let me try to build p step by step.

Initialize an empty list for p and keep track of used numbers.

Start with i=1 (first element).

Compute MEX of current p (which is empty), which is 0.

Then, a_1 = MEX - p_1, so p_1 = MEX - a_1.

But wait, if p is empty, MEX is 0.

So p_1 = 0 - a_1.

But a_1 = MEX - p_1, which is 0 - p_1, so p_1 = -a_1.

Wait, that seems straightforward for the first element.

But let's see with an example.

Take the first test case:

n=5

a = [1,1,-2,1,2]

So, for i=1:

MEX of p_1 is 0 (if p_1 !=0) or 1 if p_1=0.

a_1 = MEX(p_1) - p_1 = 1

So, if p_1 = x, then MEX(p_1) = 0 if x !=0, else 1.

If x !=0, then a_1 = 0 - x = 1 => x = -1, but x has to be between 0 and 4, so x can't be -1.

If x =0, then a_1 =1 - 0 =1, which matches.

So p_1 =0.

Now, for i=2:

p_1=0, so MEX of [0] is 1 (since 0 is present).

a_2 = MEX([0, p_2]) - p_2 =1

If p_2 =1, then MEX([0,1])=2, so a_2=2-1=1, which matches.

If p_2=2, MEX([0,2])=1, a_2=1-2=-1, doesn't match.

If p_2=3, MEX([0,3])=1, a_2=1-3=-2, doesn't match.

If p_2=4, MEX([0,4])=1, a_2=1-4=-3, doesn't match.

So p_2=1.

Now, for i=3:

p_1=0, p_2=1, so MEX([0,1, p_3]).

a_3 = MEX([0,1,p_3]) - p_3 = -2

If p_3=2, MEX([0,1,2])=3, a_3=3-2=1, doesn't match.

If p_3=3, MEX([0,1,3])=2, a_3=2-3=-1, doesn't match.

If p_3=4, MEX([0,1,4])=2, a_3=2-4=-2, matches.

So p_3=4.

For i=4:

p_1=0, p_2=1, p_3=4, so MEX([0,1,4,p_4]).

a_4 = MEX([0,1,4,p_4]) - p_4 =1

If p_4=2, MEX([0,1,4,2])=3, a_4=3-2=1, matches.

If p_4=3, MEX([0,1,4,3])=2, a_4=2-3=-1, doesn't match.

So p_4=2.

For i=5:

p_1=0, p_2=1, p_3=4, p_4=2, so MEX([0,1,4,2,p_5]).

a_5 = MEX([0,1,4,2,p_5]) - p_5 =2

If p_5=3, MEX([0,1,4,2,3])=5, a_5=5-3=2, matches.

If p_5=5, but 5 is not in 0 to 4, so invalid.

So p_5=3.

Thus, p=[0,1,4,2,3], which matches the sample output.

Okay, so from this, I can see a pattern.

At each step i, I need to choose p_i such that a_i = MEX(p_1 to p_i) - p_i.

Given that, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

I need to find p_i based on a_i and the MEX.

Wait, but MEX depends on p_i, which I'm trying to find.

This seems circular.

Is there a way to compute MEX incrementally?

Yes, because as I add more elements, the MEX can only increase or stay the same.

I can keep track of the used numbers and find the current MEX.

Wait, but to find MEX at step i, I need to know all p_1 to p_i.

But p_i depends on MEX(p_1 to p_i) and a_i.

So, perhaps I can iterate through the array, keep track of used numbers, and for each i, find p_i such that p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

So, if I have p_1 to p_{i-1}, and I choose p_i, then MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

But p_i depends on this MEX.

This seems tricky.

Maybe I can try to compute p_i directly using a_i and the used numbers.

Let me think differently.

Let me consider that p is a permutation, so all p_i are unique and in 0 to n-1.

I can keep a set of used numbers.

Initialize used = set()

For each i from 1 to n:

Find MEX of p_1 to p_i, which is the smallest non-negative integer not in used.

But p_i = MEX - a_i.

But MEX is the smallest non-negative integer not in used.

So, MEX can be computed as the smallest integer x >=0 such that x not in used.

I can keep track of MEX as I add numbers to used.

Wait, but p_i depends on MEX and a_i.

So, perhaps I can set p_i = MEX - a_i, and then add p_i to used.

But I need to ensure that p_i is unique and within 0 to n-1.

Let me try this approach with the first test case.

Test case 1:

n=5

a=[1,1,-2,1,2]

Initialize:

used = set()

MEX =0 (since nothing is used)

i=1:

p1 = MEX - a1 =0 -1=-1

But p1 must be between 0 and 4, -1 is invalid.

Wait, this doesn't work.

Maybe I need to adjust how I calculate MEX.

Wait, in the first step, when p is empty, MEX should be 0.

But if p1=0, then MEX([0])=1.

Wait, in the earlier manual calculation, when p1=0, a1=1-0=1, which matches.

So perhaps, MEX is calculated after p_i is added.

Wait, a_i = MEX(p1 to pi) - p_i.

So, MEX(p1 to pi) is after adding p_i.

Wait, maybe I need to think differently.

Let me consider that MEX(p1 to pi) is equal to some value m, and a_i = m - p_i.

Therefore, p_i = m - a_i.

But m is the MEX of p1 to pi.

So, p_i = MEX(p1 to pi) - a_i.

But MEX depends on p_i, which depends on MEX.

This seems circular.

Maybe I can iterate and for each i, assume MEX(p1 to pi), and find p_i, then check if it's consistent.

Wait, perhaps I can iterate and keep track of the current MEX.

Initialize MEX=0.

For each i from 1 to n:

p_i = MEX - a_i.

Then, add p_i to used.

Update MEX to be the smallest non-negative integer not in used.

But I need to ensure that p_i is not already used.

Let's try this with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize:

used = set()

MEX=0

i=1:

p1 = MEX - a1 =0 -1=-1

But -1 is invalid, and also not in 0 to 4.

This doesn't work.

Hmm.

Maybe I need to adjust how I calculate MEX.

Wait, perhaps MEX should be calculated before adding p_i.

Wait, but according to the definition, a_i = MEX(p1 to pi) - p_i, where MEX is after including p_i.

So, MEX is after p_i is added.

Therefore, MEX is the smallest non-negative integer not in p1 to pi, where pi is included.

So, perhaps I can iterate, keep track of used numbers, and for each i, find p_i such that p_i = MEX - a_i, where MEX is the MEX of p1 to pi, including pi.

But pi is part of the MEX calculation.

This seems tricky.

Maybe I need to find another way.

Let me look at the second test case.

n=5

a=[1,1,1,1,1]

Output: [0,1,2,3,4]

Let's verify:

p=[0,1,2,3,4]

Compute a_i:

a1 = MEX(0) - 0 =1 -0=1

a2 = MEX(0,1) -1=2-1=1

a3 = MEX(0,1,2)-2=3-2=1

a4 = MEX(0,1,2,3)-3=4-3=1

a5 = MEX(0,1,2,3,4)-4=5-4=1

Which matches the a array.

So, in this case, p is simply the identity permutation.

Now, the third test case:

n=3

a=[-2,1,2]

Output: [2,0,1]

Let's verify:

p=[2,0,1]

a1 = MEX(2)-2=0-2=-2

a2 = MEX(2,0)-0=1-0=1

a3 = MEX(2,0,1)-1=3-1=2

Which matches.

So, in this case, p=[2,0,1]

Now, looking back, perhaps I can find a general way to construct p from a.

Let me try to find a pattern or formula.

Looking at the first test case:

a=[1,1,-2,1,2]

p=[0,1,4,2,3]

Looking at the second test case:

a=[1,1,1,1,1]

p=[0,1,2,3,4]

Third test case:

a=[-2,1,2]

p=[2,0,1]

Hmm.

I need a systematic way.

Let me think about the MEX.

At any step i, MEX is the smallest non-negative integer not used yet.

So, if I have used certain numbers up to step i, MEX is the smallest non-negative integer not in the used set.

So, perhaps I can keep track of the used set and find p_i such that p_i = MEX - a_i, and ensure p_i is not already used.

Wait, but in the first test case, when i=1:

used={}

MEX=0

p1=0 -1=-1, which is invalid.

But earlier manual calculation showed p1=0.

Wait, perhaps I need to adjust how I calculate MEX.

Wait, in the first test case, when p1=0, MEX([0])=1, and a1=1-0=1, which matches.

So, perhaps MEX is calculated after adding p_i.

So, MEX(p1 to pi) is after p_i is included.

Therefore, MEX is the smallest non-negative integer not in p1 to pi.

So, perhaps I can iterate through the array, keep track of used numbers, and for each i, set p_i = MEX - a_i, where MEX is the MEX of p1 to pi.

But since MEX depends on p_i, which I'm trying to find, it's still circular.

Maybe I need to find another way.

Let me try to express MEX in terms of used numbers.

MEX is the smallest non-negative integer not in used.

So, if I have used={0,1,4,2}, then MEX=3.

So, perhaps I can keep track of used numbers, find MEX, then set p_i = MEX - a_i, then add p_i to used.

But in the first test case, when i=1:

used={}

MEX=0

p1=0 -1=-1, invalid.

But in reality, p1=0.

Wait, perhaps I need to set p_i = MEX - a_i, but ensure p_i is the smallest non-negative integer not yet used.

Wait, but p_i has to be a unique number from 0 to n-1.

Maybe I can iterate through i from 1 to n:

Find MEX as the smallest non-negative integer not in used.

Set p_i = MEX - a_i.

If p_i is already used or out of range, adjust accordingly.

But in the first test case, this fails because p1 becomes -1, which is invalid.

Wait, maybe I need to consider that MEX is after adding p_i, so perhaps MEX = MEX(p1 to p_{i-1}) if p_i is not affecting the MEX.

Wait, this is getting complicated.

Maybe I need to look for a different approach.

Let me consider that p is a permutation, so all p_i are unique.

I can iterate through i from 1 to n, keep track of used numbers, and for each i, choose p_i as the smallest unused number that satisfies p_i = MEX(p1 to pi) - a_i.

But again, MEX depends on p_i.

This seems too circular.

Perhaps I need to consider that MEX is the smallest non-negative integer not in p1 to p_{i-1}, and not yet in p_i.

Wait, but MEX is the smallest non-negative integer not in p1 to pi, including p_i.

So, MEX is the smallest x not in p1 to pi.

So, if I choose p_i, then MEX is the smallest x not in p1 to p_i.

But p_i depends on MEX.

This seems too interdependent.

Maybe I need to find a way to compute MEX incrementally, and at each step, determine p_i based on a_i and the current MEX.

Let me try to think differently.

Suppose I have a_i = MEX(p1 to pi) - p_i.

So, p_i = MEX(p1 to pi) - a_i.

But MEX(p1 to pi) is the smallest x not in p1 to pi.

So, p_i = smallest x not in p1 to pi - a_i.

Wait, perhaps I can iterate through i from 1 to n, keep track of used numbers, and for each i, set p_i = smallest x not in used - a_i, and then add p_i to used.

But I need to ensure that p_i is unique and within 0 to n-1.

Wait, let's try this with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize:

used={}

i=1:

smallest x not in used is 0.

p1 =0 -1=-1, invalid.

But p1 should be 0.

Wait, this doesn't work.

Maybe I need to adjust.

Wait, perhaps p_i = smallest x not in used - a_i, and then add p_i to used.

But in the first step, p1 =0 -1=-1, invalid.

But in reality, p1=0.

So, perhaps I need to set p_i = smallest x not in used such that x - a_i is unique and within 0 to n-1.

This seems too convoluted.

Maybe I need to consider that p_i + a_i = MEX(p1 to pi).

So, p_i + a_i = smallest x not in p1 to pi.

So, p_i + a_i is the smallest x not in p1 to pi.

Maybe I can use this to find p_i.

Let me try with the first test case.

i=1:

p1 + a1 = MEX(p1) => p1 +1 = smallest x not in p1.

If p1=0, then 0 +1=1, which is the smallest x not in {0}, which is 1. Matches.

i=2:

p2 +1 = smallest x not in {0, p2}.

If p2=1, then 1 +1=2, which is the smallest x not in {0,1}, which is 2. Matches.

i=3:

p3 +(-2)= smallest x not in {0,1,p3}.

If p3=4, then 4 +(-2)=2, which is the smallest x not in {0,1,4}, which is 2. Matches.

i=4:

p4 +1= smallest x not in {0,1,4,p4}.

If p4=2, then 2 +1=3, which is the smallest x not in {0,1,4,2}, which is 3. Matches.

i=5:

p5 +2= smallest x not in {0,1,4,2,p5}.

If p5=3, then 3 +2=5, which is the smallest x not in {0,1,4,2,3}, which is 5. Matches.

So, in all cases, p_i + a_i = MEX(p1 to p_i).

And MEX(p1 to p_i) is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

Maybe I can use this to build p step by step.

Let me try to formalize this.

At step i, p_i + a_i = smallest x not in p1 to p_i.

I can keep track of the used numbers (p1 to p_{i-1}), and p_i is part of the used set at step i.

Wait, but p_i is being determined.

So, at step i, used_so_far = p1 to p_{i-1}.

p_i is not yet used.

So, the smallest x not in p1 to p_i is the smallest x not in used_so_far and not equal to p_i.

But p_i is determined by p_i = smallest x not in p1 to p_i - a_i.

This is still confusing.

Maybe I need to iterate through i from 1 to n, keep track of used numbers, find the smallest x not in used_so_far, set p_i = x - a_i, and ensure p_i is unique and within 0 to n-1.

Let me try this with the first test case.

i=1:

used_so_far={}

smallest x not in used_so_far=0

p1=0 -1=-1, invalid.

But p1 should be 0.

This approach is not working.

Wait, perhaps I need to adjust the order.

Maybe I need to set p_i = smallest x not in used_so_far - a_i, and then add p_i to used.

Let's try:

i=1:

used_so_far={}

smallest x not in used_so_far=0

p1=0 -1=-1, invalid.

Wait, doesn't work.

Maybe I need to choose p_i such that p_i + a_i is the smallest x not in used_so_far.

So, p_i = smallest x not in used_so_far - a_i.

But again, with i=1:

smallest x not in used_so_far=0

p1=0 -1=-1, invalid.

Hmm.

This seems not to be working.

Maybe I need to consider that p_i + a_i is the smallest x not in used_so_far.

Wait, but in the first test case, p1=0, a1=1, so p1 + a1=1, which is the smallest x not in used_so_far={0}, which is 1.

Similarly, p2=1, a2=1, p2 + a2=2, which is the smallest x not in {0,1}, which is 2.

p3=4, a3=-2, p3 + a3=2, which is the smallest x not in {0,1,4}, which is 2.

p4=2, a4=1, p4 + a4=3, which is the smallest x not in {0,1,4,2}, which is 3.

p5=3, a5=2, p5 + a5=5, which is the smallest x not in {0,1,4,2,3}, which is 5.

So, in all cases, p_i + a_i = MEX(p1 to p_i).

So, p_i = MEX(p1 to p_i) - a_i.

But MEX(p1 to p_i) is the smallest x not in p1 to p_i.

So, p_i = smallest x not in p1 to p_i - a_i.

But this seems to lead to the same issue as before.

Wait, perhaps I can iterate through i from 1 to n, keep track of used numbers, for each i, set p_i = smallest x not in used_so_far - a_i, then add p_i to used.

But in the first step, p1=0-1=-1, invalid.

This isn't working.

Maybe I need to find another way.

Let me consider that p_i + a_i = MEX(p1 to p_i), and MEX is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

But p_i is part of p1 to p_i, so the smallest x not in p1 to p_i is the smallest x not in p1 to p_{i-1} and not equal to p_i.

Wait, but p_i is determined by p_i = smallest x not in p1 to p_i - a_i.

This seems too circular.

Maybe I need to look for a different approach altogether.

Let me consider that p is a permutation, so all p_i are unique.

I can iterate through i from 1 to n, and assign p_i to be some value that hasn't been used yet, and satisfies p_i = MEX(p1 to p_i) - a_i.

But again, this seems too dependent.

Perhaps I can iterate through i from 1 to n, keep track of used numbers, and for each i, find the p_i that hasn't been used yet and makes p_i + a_i equal to the smallest x not in used_so_far.

Wait, but that's similar to what I was doing before.

Maybe I need to think about the properties of MEX and how it relates to p_i and a_i.

Let me consider that MEX(p1 to p_i) is equal to p_i + a_i.

And MEX is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

But p1 to p_i include p_i.

So, smallest x not in p1 to p_i is the smallest x not in p1 to p_{i-1} and not equal to p_i.

So, p_i + a_i = smallest x not in p1 to p_{i-1} that is not equal to p_i.

Wait, but p_i is being determined.

This seems too tangled.

Maybe I need to consider that p_i + a_i is equal to the smallest x not in p1 to p_{i-1}, and p_i is not equal to that x.

Wait, but in the first test case, p1 + a1 =1, which is not equal to p1=0.

Similarly, p2 + a2=2, which is not equal to p2=1.

p3 + a3=2, which is not equal to p3=4.

p4 + a4=3, not equal to p4=2.

p5 + a5=5, not equal to p5=3.

So, p_i + a_i = smallest x not in p1 to p_{i-1}, and p_i != x.

Wait, in the first step:

p1 + a1 =1, which is the smallest x not in {}, which is 0, but 0 is p1, so x=1.

Wait, no, smallest x not in {} is 0, but p1=0, so x=1.

So, p1 + a1=1, which matches.

Similarly, p2 + a2=2, which is the smallest x not in {0}, which is 1, but p2=1, so x=2.

And so on.

So, perhaps p_i + a_i = smallest x not in p1 to p_{i-1} that is greater than or equal to 0.

Wait, but in the first step, smallest x not in {} is 0, but p1=0, so next is 1, which matches p1 + a1=1.

So, p_i + a_i = smallest x not in p1 to p_{i-1} that is not equal to p_i.

But p_i is not yet known.

This is still confusing.

Maybe I need to look for a different approach.

Let me consider that p_i = MEX(p1 to p_i) - a_i.

And MEX(p1 to p_i) is the smallest x not in p1 to p_i.

So, p_i = smallest x not in p1 to p_i - a_i.

But this seems too vague.

Perhaps I can iterate through i from 1 to n, keep track of used numbers, and for each i, set p_i = smallest x not in used_so_far - a_i, then add p_i to used.

But in the first step, p1=0-1=-1, invalid.

This isn't working.

Wait, maybe I need to choose p_i such that p_i + a_i is the smallest x not in used_so_far.

So, p_i = x - a_i.

I need to choose x as the smallest not in used_so_far, then set p_i = x - a_i, then add p_i to used.

Wait, but in the first step, x=0, p_i=0 -1=-1, invalid.

Not working.

Maybe I need to choose x such that x - a_i is the smallest available number.

This seems too convoluted.

Perhaps I need to consider that p_i + a_i is equal to the MEX, which is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

But p_i is part of p1 to p_i, so it's included in the used set.

Therefore, p_i + a_i = smallest x not in p1 to p_{i-1} that is greater than p_i.

Wait, but that still doesn't help me find p_i directly.

This seems too recursive.

Maybe I need to look for a different strategy.

Let me consider that p is a permutation, so all p_i are unique and cover 0 to n-1.

I can iterate through i from 1 to n, and for each i, assign p_i to be the smallest available number that satisfies p_i = MEX(p1 to p_i) - a_i.

But again, MEX depends on p_i.

This seems too interdependent.

Perhaps I need to iterate through i from 1 to n, keep track of used numbers, and for each i, set p_i = MEX - a_i, where MEX is the smallest x not in used_so_far, and then add p_i to used.

But in the first step, p1=0-1=-1, invalid.

This isn't working.

Wait, maybe I need to adjust the way I calculate MEX.

Perhaps MEX(p1 to p_i) can be calculated based on the used set up to i-1 and the current p_i.

But p_i is being determined, so it's still tricky.

This seems too circular to handle directly.

Maybe I need to consider that p_i + a_i = MEX(p1 to p_i), and since MEX is the smallest x not in p1 to p_i, then p_i + a_i is equal to that x.

So, p_i + a_i = smallest x not in p1 to p_i.

But p_i is part of p1 to p_i, so p_i + a_i = smallest x not in p1 to p_{i-1} that is greater than p_i.

This seems too involved.

Perhaps I need to consider that p_i + a_i is equal to the MEX, which is the smallest x not in p1 to p_i.

So, p_i + a_i = MEX(p1 to p_i).

But MEX(p1 to p_i) is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

Therefore, p_i + a_i = smallest x not in p1 to p_{i-1} that is not equal to p_i.

Wait, but p_i is being determined.

This seems too recursive.

Maybe I need to find a way to compute p_i directly based on a_i and the used set.

Let me try to think differently.

Suppose I have a_i = MEX(p1 to p_i) - p_i.

So, a_i + p_i = MEX(p1 to p_i).

And MEX(p1 to p_i) is the smallest x not in p1 to p_i.

So, a_i + p_i is the smallest x not in p1 to p_i.

Therefore, a_i + p_i is the smallest x not in p1 to p_i.

So, p_i = (smallest x not in p1 to p_i) - a_i.

But this is still recursive because p_i is part of p1 to p_i.

This seems too tangled to solve directly.

Maybe I need to consider that p_i + a_i is equal to the MEX, which is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

Therefore, p_i + a_i = smallest x not in p1 to p_{i-1} that is not equal to p_i.

But p_i is being determined.

This seems too recursive.

Perhaps I need to look for a different approach altogether.

Let me consider that p is a permutation, so all p_i are unique.

I can iterate through i from 1 to n, keep track of used numbers, and for each i, set p_i to be the smallest available number that hasn't been used yet.

But this would only work for the second test case, where a_i=1 for all i, and p_i=i.

But in the first test case, p is not simply 0 to n-1.

So, this approach is too simplistic.

Maybe I need to consider that p_i = i - a_i.

But in the first test case, p1=0, a1=1, so 0=1-1, which matches.

p2=1, a2=1, 1=2-1, but i is from 1 to n, so i=2, p2=1=2-1.

Wait, in the first test case:

p=[0,1,4,2,3]

a=[1,1,-2,1,2]

So, p1=0=1-1, p2=1=2-1, p3=4=3-(-1), p4=2=4-2, p5=3=5-2.

Wait, that doesn't seem consistent.

Wait, if p_i = i - k, where k is a_i.

Wait, not sure.

Maybe I need to consider that p_i = i - a_i.

But in the first test case:

p1=0, a1=1, 0=1-1.

p2=1, a2=1, 1=2-1.

p3=4, a3=-2, 4=3-(-2).

p4=2, a4=1, 2=4-2.

p5=3, a5=2, 3=5-2.

So, p_i = i - a_i.

Wait, but in the first step, i=1 (assuming 1-based indexing), p1=0, a1=1, 0=1-1.

In the second step, i=2, p2=1, a2=1, 1=2-1.

Third step, i=3, p3=4, a3=-2, 4=3 - (-2).

Fourth step, i=4, p4=2, a4=1, 2=4 -2.

Wait, in the fourth step, 2=4 -2, but a4=1, but 2=4 -2, which is not matching a4=1.

Wait, perhaps I need to consider 0-based indexing.

Assuming 0-based indexing, i from 0 to n-1.

So, i=0, p1=0, a1=1, 0=0 -1.

Wait, that's -1, which doesn't match.

Wait, perhaps not.

Wait, maybe p_i = i - a_i.

In the first test case:

i=0, p1=0, a1=1, 0=0-1, which is -1, doesn't match.

Wait, no.

Wait, perhaps p_i = i + a_i.

In the first test case:

i=0, p1=0, a1=1, 0=0+1=1, doesn't match.

Wait, no.

Maybe p_i = i - a_i.

In the first test case:

i=0, p1=0, a1=1, 0=0-1=-1, doesn't match.

Wait, no.

This isn't working.

Wait, perhaps p_i = something else.

Maybe I need to consider that p_i = MEX(p1 to p_{i-1}) - a_i.

So, at each step, p_i = smallest x not in p1 to p_{i-1} - a_i.

Then, add p_i to used.

Let's try this with the first test case.

Initialize:

used={}

i=1:

smallest x not in used=0

p1=0 -1=-1, invalid.

But p1 should be 0.

This doesn't work.

Wait, perhaps I need to set p_i = smallest x not in used - a_i, then add p_i to used.

But in the first step, p1=0-1=-1, invalid.

This isn't working.

Maybe I need to consider p_i = smallest x not in used + a_i.

But in the first step, p1=0 +1=1, which is not 0.

Doesn't match.

Wait, perhaps p_i = smallest x not in used - a_i, but adjust a_i accordingly.

This seems too vague.

Maybe I need to consider that p_i + a_i = MEX(p1 to p_i), and MEX is the smallest x not in p1 to p_i.

So, p_i + a_i = smallest x not in p1 to p_i.

Therefore, p_i + a_i = smallest x not in p1 to p_{i-1} that is greater than p_i.

But this still doesn't help me find p_i directly.

This seems too recursive to handle in a straightforward manner.

Perhaps I need to look for a different approach.

Let me consider that p is a permutation, and I need to arrange the numbers such that for each prefix, a_i = MEX(prefix) - p_i.

Given that, maybe I can think about the positions where a_i is positive or negative.

For example, in the first test case, a=[1,1,-2,1,2]

p=[0,1,4,2,3]

For i=1: a1=1, p1=0

MEX([0])=1, 1-0=1

For i=2: a2=1, p2=1

MEX([0,1])=2, 2-1=1

For i=3: a3=-2, p3=4

MEX([0,1,4])=2, 2-4=-2

For i=4: a4=1, p4=2

MEX([0,1,4,2])=3, 3-2=1

For i=5: a5=2, p5=3

MEX([0,1,4,2,3])=5, 5-3=2

So, in this case, a_i can be positive or negative.

Wait, in the third step, a3=-2, which is negative.

This happens when p_i is larger than MEX(p1 to p_i).

So, when a_i is negative, p_i > MEX(p1 to p_i).

When a_i is positive, p_i < MEX(p1 to p_i).

When a_i=0, p_i = MEX(p1 to p_i).

But in the first test case, a3=-2, which is p3=4 > MEX([0,1,4])=2.

Wait, but 4 > 2, so a_i is negative.

Similarly, in the second test case, a=[1,1,1,1,1], p=[0,1,2,3,4], all a_i=1, which is positive, and p_i < MEX(p1 to p_i).

In the third test case, a=[-2,1,2], p=[2,0,1]

For i=1: a1=-2, p1=2, MEX([2])=0, 0-2=-2

For i=2: a2=1, p2=0, MEX([2,0])=1, 1-0=1

For i=3: a3=2, p3=1, MEX([2,0,1])=3, 3-1=2

So, in this case, a1 is negative, a2 is positive, a3 is positive.

Corresponding to p1=2 > MEX([2])=0, p2=0 < MEX([2,0])=1, p3=1 < MEX([2,0,1])=3.

So, the sign of a_i indicates whether p_i >, <, or = to MEX(p1 to p_i).

But I'm not sure if this helps in constructing p from a.

Maybe I need to consider that when a_i is negative, p_i is larger than the MEX, so I need to choose a p_i that is larger than the current MEX.

But this seems too vague.

Perhaps I need to iterate through i from 1 to n, keep track of used numbers, and for each i, set p_i = MEX - a_i, then add p_i to used.

But as seen before, this leads to invalid p_i in some cases.

Wait, perhaps I need to adjust the MEX calculation.

Maybe MEX is not just the smallest x not in used_so_far, but considering p_i as well.

This seems too involved.

Maybe I need to consider that p_i = MEX - a_i, and ensure that p_i is unique and within 0 to n-1.

But again, this seems too vague.

Perhaps I need to look for a different strategy altogether.

Let me consider that p is a permutation, and I need to arrange the numbers such that for each prefix, a_i = MEX(prefix) - p_i.

Given that, maybe I can iterate through i from 1 to n, keep track of used numbers, and for each i, choose p_i as the smallest available number that satisfies p_i = MEX - a_i.

But again, MEX depends on p_i.

This seems too recursive.

Maybe I need to consider that p_i = i - a_i.

Wait, I tried that before, but it didn't work.

In the first test case:

p=[0,1,4,2,3]

a=[1,1,-2,1,2]

If p_i = i - a_i (assuming 0-based indexing):

i=0: p0=0 -1=-1, invalid.

i=1: p1=1 -1=0

i=2: p2=2 -(-2)=4

i=3: p3=3 -1=2

i=4: p4=4 -2=2, but p3 already has 2, so invalid.

Wait, doesn't work.

Maybe p_i = i + a_i.

In the first test case:

i=0: p0=0+1=1

i=1: p1=1+1=2

i=2: p2=2+(-2)=0

i=3: p3=3+1=4

i=4: p4=4+2=6, which is out of range.

Doesn't work.

Wait, perhaps p_i = i - a_i, but adjust for negative values.

In the first test case:

i=0: p0=0-1=-1, invalid.

i=1: p1=1-1=0

i=2: p2=2-(-2)=4

i=3: p3=3-1=2