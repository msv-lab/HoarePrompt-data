Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find a permutation of length n such that the Manhattan value, which is the sum of the absolute differences between each element and its position, equals a given k. If no such permutation exists, I should output "No"; otherwise, "Yes" and the permutation.

First, I need to understand what the Manhattan value represents. For a permutation p of length n, the Manhattan value is calculated as |p1 - 1| + |p2 - 2| + ... + |pn - n|. So, it's essentially the sum of how much each element deviates from its position in the identity permutation [1, 2, 3, ..., n].

Let's look at the examples provided:

- For n=3 and k=4, the permutation [3,1,2] has a Manhattan value of |3-1| + |1-2| + |2-3| = 2 + 1 + 1 = 4.

- For n=7 and k=0, the permutation [1,2,3,4,5,6,7] has a Manhattan value of 0 since each element is in its correct position.

- For n=1 and k=1000000000000, it's impossible because the only permutation [1] has a Manhattan value of 0.

- For n=8 and k=14, there is a permutation that satisfies this.

- For n=112 and k=777, it's not possible.

- For n=5 and k=12, there is a permutation like [5,4,3,1,2].

- For n=5 and k=2, there is a permutation like [2,1,3,4,5].

From these, I can see that for smaller n, it's manageable to check permutations manually, but for larger n (up to 2*10^5), I need an efficient algorithm.

First, I need to figure out the range of possible Manhattan values for a given n.

- The minimum Manhattan value is 0, which occurs only for the identity permutation [1,2,3,...,n].

- The maximum Manhattan value can be calculated by maximizing the sum |p1 - 1| + |p2 - 2| + ... + |pn - n|.

To maximize this sum, we should pair the smallest elements with the largest positions and vice versa. For example, for n=4, the permutation [4,3,2,1] gives |4-1| + |3-2| + |2-3| + |1-4| = 3 + 1 + 1 + 3 = 8.

Wait, but for n=4, the maximum is 8, but in the second test case, n=4 and k=5 is not possible, as per the sample output.

So, for n=4, the maximum Manhattan value is 8, and k=5 is not achievable.

Similarly, for n=3, the maximum is |3-1| + |2-2| + |1-3| = 2 + 0 + 2 = 4.

Wait, but in the first test case, n=3 and k=4 is possible.

For n=7, k=0 is possible.

For n=1, k=1000000000000 is not possible since the only permutation has k=0.

For n=8 and k=14, it's possible.

For n=112 and k=777, it's not possible.

For n=5 and k=12, it's possible.

For n=5 and k=2, it's possible.

So, I need to find out for given n and k, whether there exists a permutation whose Manhattan value is k, and if so, construct one such permutation.

First, I need to understand the possible values of k for a given n.

Let's think about how to calculate the maximum possible k for a given n.

For each position i from 1 to n, the maximum possible |p_i - i| is max(p_i - i, i - p_i). To maximize the sum, we can arrange p so that for each i, |p_i - i| is as large as possible.

One way to achieve this is to pair the smallest p_i with the largest i and the largest p_i with the smallest i.

Wait, for n=4, [4,3,2,1] gives |4-1| + |3-2| + |2-3| + |1-4| = 3 + 1 + 1 + 3 = 8.

Is this the maximum? Let's see another permutation: [1,4,3,2]: |1-1| + |4-2| + |3-3| + |2-4| = 0 + 2 + 0 + 2 = 4, which is less than 8.

Another one: [2,1,4,3]: |2-1| + |1-2| + |4-3| + |3-4| = 1 + 1 + 1 + 1 = 4.

Seems like [4,3,2,1] achieves the maximum sum.

Similarly, for n=3, [3,2,1] gives |3-1| + |2-2| + |1-3| = 2 + 0 + 2 = 4, which matches the first test case.

For n=2, [2,1] gives |2-1| + |1-2| = 1 + 1 = 2, which is the maximum.

For n=1, [1] gives 0, which is the only possible value.

So, for n even, the maximum sum seems to be n^2 / 2, and for n odd, (n^2 - 1)/2.

Wait, for n=3, (9 - 1)/2 = 4, which matches.

For n=4, 16/2 = 8, which matches.

So, the maximum possible k is:

- If n is even: n^2 / 2

- If n is odd: (n^2 - 1)/2

Now, I need to check if a given k is achievable between 0 and this maximum value.

But looking at the sample input, for n=8 and k=14, it's possible, since 14 is less than or equal to 32 (8^2 / 2 = 32).

But for n=4 and k=5, it's not possible, even though 5 < 8.

So, not all k between 0 and max_k are achievable.

I need to find out which k are achievable.

Looking at the problem, the Manhattan value is the sum of |p_i - i| for i from 1 to n.

Each |p_i - i| is an integer between 0 and n-1.

Moreover, since p is a permutation, each p_i is unique and in [1,n].

I need to find a rearrangement of [1,2,...,n] such that the sum of |p_i - i| equals k.

I need to find if such a rearrangement exists, and if so, construct one.

This seems like a problem that can be solved by understanding the possible sums of |p_i - i|.

First, note that for each i, |p_i - i| can take values from 0 to n-1, but not all values are possible due to the permutation constraint.

I need a way to construct a permutation with a given sum k.

One approach is to start from the identity permutation, which has sum 0, and perform swaps to increase the sum.

Each swap can increase the sum by a certain amount.

But this might not be efficient for large n.

Another approach is to consider the maximum matching in a bipartite graph, but that seems too slow for n up to 2e5.

I need a smarter way.

Looking at the reference solution, it seems to handle the problem based on the parity of k and some specific constructions.

Let me analyze the reference solution step by step.

First, there's a function func_4() that reads n and k, and checks if k is even. If k is odd, it returns (0,0), indicating "No". Otherwise, it calculates the maximum possible k based on whether n is even or odd and checks if k is within the range [0, max_k].

So, it seems that for this problem, k must be even to have a valid permutation. That's an important observation.

Wait, in the sample input, for n=3 and k=4, which is even, it's possible. For n=7 and k=0, which is even, it's possible. For n=1 and k=1000000000000, which is even, it's impossible, but that's because k exceeds the maximum possible for n=1.

But in the sample input, for n=5 and k=12, which is even, it's possible, and for n=5 and k=2, which is even, it's possible.

In the second test case, n=4 and k=5, which is odd, it's impossible, but actually, according to the reference solution, it checks if k is even, and if not, outputs "No".

Wait, but in the sample input, n=4 and k=5 is odd, so it should output "No", which matches the sample output.

Similarly, for n=112 and k=777, if 777 is odd, it should output "No", which again matches the sample output.

Wait, but in the first test case, n=3 and k=4, which is even, it's possible.

So, it seems that k must be even to have a valid permutation.

But why?

Let's think about the sum |p1 - 1| + |p2 - 2| + ... + |pn - n|.

Each |p_i - i| is an integer, but why must their sum be even?

Is there a property that makes the sum always even?

Wait, for n=3, the possible sums are:

- [1,2,3]: 0 (even)

- [1,3,2]: |1-1| + |3-2| + |2-3| = 0 + 1 + 1 = 2 (even)

- [2,1,3]: |2-1| + |1-2| + |3-3| = 1 + 1 + 0 = 2 (even)

- [2,3,1]: |2-1| + |3-2| + |1-3| = 1 + 1 + 2 = 4 (even)

- [3,1,2]: |3-1| + |1-2| + |2-3| = 2 + 1 + 1 = 4 (even)

- [3,2,1]: |3-1| + |2-2| + |1-3| = 2 + 0 + 2 = 4 (even)

So, for n=3, all possible sums are even.

Similarly, for n=2:

- [1,2]: 0 (even)

- [2,1]: |2-1| + |1-2| = 1 + 1 = 2 (even)

So, indeed, for n=2, sums are even.

For n=1: only [1], sum=0 (even).

So, it seems that for all n, the sum is always even.

That's why in the reference solution, if k is odd, it immediately returns "No".

Now, I need to confirm if this is always the case.

Let's consider n=4:

- [1,2,3,4]: 0 (even)

- [1,2,4,3]: |1-1| + |2-2| + |4-3| + |3-4| = 0 + 0 + 1 + 1 = 2 (even)

- [1,3,2,4]: |1-1| + |3-2| + |2-3| + |4-4| = 0 + 1 + 1 + 0 = 2 (even)

- [1,3,4,2]: |1-1| + |3-2| + |4-3| + |2-4| = 0 + 1 + 1 + 2 = 4 (even)

- [1,4,2,3]: |1-1| + |4-2| + |2-3| + |3-4| = 0 + 2 + 1 + 1 = 4 (even)

- [1,4,3,2]: |1-1| + |4-2| + |3-3| + |2-4| = 0 + 2 + 0 + 2 = 4 (even)

- [2,1,3,4]: |2-1| + |1-2| + |3-3| + |4-4| = 1 + 1 + 0 + 0 = 2 (even)

- [2,1,4,3]: |2-1| + |1-2| + |4-3| + |3-4| = 1 + 1 + 1 + 1 = 4 (even)

- [2,3,1,4]: |2-1| + |3-2| + |1-3| + |4-4| = 1 + 1 + 2 + 0 = 4 (even)

- [2,3,4,1]: |2-1| + |3-2| + |4-3| + |1-4| = 1 + 1 + 1 + 3 = 6 (even)

- [2,4,1,3]: |2-1| + |4-2| + |1-3| + |3-4| = 1 + 2 + 2 + 1 = 6 (even)

- [2,4,3,1]: |2-1| + |4-2| + |3-3| + |1-4| = 1 + 2 + 0 + 3 = 6 (even)

- [3,1,2,4]: |3-1| + |1-2| + |2-3| + |4-4| = 2 + 1 + 1 + 0 = 4 (even)

- [3,1,4,2]: |3-1| + |1-2| + |4-3| + |2-4| = 2 + 1 + 1 + 2 = 6 (even)

- [3,2,1,4]: |3-1| + |2-2| + |1-3| + |4-4| = 2 + 0 + 2 + 0 = 4 (even)

- [3,2,4,1]: |3-1| + |2-2| + |4-3| + |1-4| = 2 + 0 + 1 + 3 = 6 (even)

- [3,4,1,2]: |3-1| + |4-2| + |1-3| + |2-4| = 2 + 2 + 2 + 2 = 8 (even)

- [3,4,2,1]: |3-1| + |4-2| + |2-3| + |1-4| = 2 + 2 + 1 + 3 = 8 (even)

- [4,1,2,3]: |4-1| + |1-2| + |2-3| + |3-4| = 3 + 1 + 1 + 1 = 6 (even)

- [4,1,3,2]: |4-1| + |1-2| + |3-3| + |2-4| = 3 + 1 + 0 + 2 = 6 (even)

- [4,2,1,3]: |4-1| + |2-2| + |1-3| + |3-4| = 3 + 0 + 2 + 1 = 6 (even)

- [4,2,3,1]: |4-1| + |2-2| + |3-3| + |1-4| = 3 + 0 + 0 + 3 = 6 (even)

- [4,3,1,2]: |4-1| + |3-2| + |1-3| + |2-4| = 3 + 1 + 2 + 2 = 8 (even)

- [4,3,2,1]: |4-1| + |3-2| + |2-3| + |1-4| = 3 + 1 + 1 + 3 = 8 (even)

So, for n=4, all possible sums are even numbers between 0 and 8.

Hence, for k=5, which is odd, it's impossible, which matches the sample output.

Similarly, for n=3, sums are 0,2,4.

For n=2, sums are 0,2.

For n=1, sum is 0.

So, it seems that the sum is always even.

But why is that?

Let's think about the sum S = |p1 - 1| + |p2 - 2| + ... + |pn - n|.

Each |p_i - i| is the absolute difference between p_i and i.

Now, p is a permutation of [1,2,...,n], so each p_i is unique and in [1,n].

I need to see why S is always even.

One way to approach this is to consider the parity of each |p_i - i|.

But, absolute differences can be odd or even, and their sum could be odd or even.

Wait, perhaps there's another way to look at it.

Let's consider that S = sum_{i=1 to n} |p_i - i|.

This can be rewritten as S = sum_{i=1 to n} (p_i - i) if p_i >= i, otherwise i - p_i.

But in any case, it's the sum of the unsigned differences.

I need to see if this sum is always even.

Alternatively, perhaps I can look at the total sum of p_i and the sum of i.

The sum of p_i for i=1 to n is the same as the sum of i from 1 to n, since p is a permutation.

So, sum_{i=1 to n} p_i = sum_{i=1 to n} i = n(n+1)/2.

Similarly, sum_{i=1 to n} i = n(n+1)/2.

Therefore, sum_{i=1 to n} (p_i - i) = sum p_i - sum i = 0.

But S = sum |p_i - i|.

Now, |a| + |b| >= |a + b|, but in this case, since sum (p_i - i) = 0, sum |p_i - i| >= 0.

But I need to see the parity of S.

Wait, perhaps I can consider that S = sum |p_i - i| = sum (p_i - i if p_i >= i, else i - p_i).

This can be written as S = sum (p_i - i) if p_i >= i, else (i - p_i).

Which is the same as sum (p_i - i) for p_i >= i, and sum (i - p_i) for p_i < i.

But since sum p_i - sum i = 0, then sum (p_i - i) = 0.

So, sum (p_i - i) for p_i >= i plus sum (i - p_i) for p_i < i equals 0.

But S = sum (p_i - i for p_i >= i) + sum (i - p_i for p_i < i).

Let me denote A = sum (p_i - i for p_i >= i), and B = sum (i - p_i for p_i < i).

Then, S = A + B, and A - B = sum (p_i - i) = 0, so A = B.

Therefore, S = A + B = 2A, which is always even.

Hence, S is always even, which explains why in the reference solution, if k is odd, it immediately returns "No".

Now, assuming k is even, I need to construct a permutation p such that sum |p_i - i| = k.

Given that, I need to find a way to construct such a permutation efficiently, especially since n can be up to 2e5, and the total sum over all test cases is up to 2e5, so it needs to be efficient.

Looking at the reference solution, it seems to handle this in func_1, func_2, and func_3.

Let's try to understand what these functions are doing.

First, func_4 reads n and k, checks if k is even, and calculates the maximum possible k based on whether n is even or odd.

If k is greater than the maximum possible or less than 0, it returns (0,0), indicating "No".

Otherwise, it returns n and k.

Then, func_6 calls func_4, and if n is 0, it prints "NO"; else, it calls func_1 to get the permutation and prints it using func_5.

So, the main part is func_1, which seems to construct the permutation.

Looking at func_1:

def func_1(n, k):

k = k // 2

l = list(range(1, n + 1))

c = 0

for i in range(n, -1, -2):

c += 1

if k == 0:

return l

if k < i - 1:

return func_2(c, k, l)

k = k - i + 1

l = func_3(c, l)

So, it starts with the identity permutation l = [1,2,3,...,n].

Then, it iterates from i = n down to 0, stepping by -2.

In each iteration, it increments c by 1.

If k == 0, it returns the current l.

If k < i - 1, it calls func_2(c, k, l).

Else, it subtracts (i - 1) from k and updates l by calling func_3(c, l).

Wait, but k is initially set to k // 2, which makes sense because S is always even, so k must be even, and we can work with k // 2.

Now, what does c represent? It seems to be a counter that increases with each iteration.

Looking at func_2 and func_3:

def func_2(c, k, l):

(x, y) = (l[-c], l[-c - k])

(l[-c], l[-c - k]) = (y, x)

return l

def func_3(c, l):

(x, y) = (l[-c], l[c - 1])

(l[c - 1], l[-c]) = (x, y)

return l

So, func_2 swaps l[-c] and l[-c - k], and func_3 swaps l[-c] and l[c - 1].

I need to understand what these swaps are achieving in terms of increasing the sum S.

Let me try to understand with an example.

Take n=3, k=4.

So, k // 2 = 2.

Initialize l = [1,2,3].

Start loop from i=3 to -1, step -2.

First iteration, i=3:

c=1

k=2

k < 3 -1 =2? 2 < 2 is False.

So, k = 2 - 3 +1 =0

l = func_3(1, [1,2,3])

func_3(1, [1,2,3]):

x = l[-1] = 3

y = l[0] =1

Swap l[0] and l[-1]: [3,2,1]

So, l becomes [3,2,1]

Now, k=0

Next iteration, i=1:

c=2

k=0

k ==0, so return l=[3,2,1]

Sum S = |3-1| + |2-2| + |1-3| = 2 + 0 + 2 =4, which matches k=4.

Another example: n=5, k=12

k//2=6

l=[1,2,3,4,5]

i=5:

c=1

k=6

k <5-1=4? 6<4? No

k=6 -5 +1=2

l=func_3(1, [1,2,3,4,5]) -> swap l[0] and l[-1]: [5,2,3,4,1]

i=3:

c=2

k=2

k <3-1=2? 2<2? False

k=2-3+1=0

l=func_3(2, [5,2,3,4,1])

func_3(2, [5,2,3,4,1]): swap l[1] and l[-2]: [5,4,3,2,1]

i=1:

c=3

k=0

return l=[5,4,3,2,1]

Sum S= |5-1| + |4-2| + |3-3| + |2-4| + |1-5| =4 + 2 +0 +2 +4=12, which matches k=12.

Another example: n=5, k=2

k//2=1

l=[1,2,3,4,5]

i=5:

c=1

k=1

k <5-1=4? 1<4? True

Call func_2(1,1,[1,2,3,4,5])

func_2(1,1,l):

x=l[-1]=5

y=l[-1 -1]=l[-2]=4

Swap l[-1] and l[-2]: [1,2,3,5,4]

So, l becomes [1,2,3,5,4]

Return this.

Sum S= |1-1| + |2-2| + |3-3| + |5-4| + |4-5| =0+0+0+1+1=2, which matches k=2.

So, it seems to work.

Now, I need to understand the logic behind func_1.

It seems to be building the permutation by making specific swaps that increase the sum S by certain amounts.

Specifically, each iteration seems to allow increasing S by up to i-1, where i decreases by 2 each time.

func_3 seems to perform a swap that increases S by i-1, and func_2 performs a swap that increases S by a smaller amount.

Wait, in the first example with n=3, k=4, it performed one func_3 swap to get [3,2,1], which increases S by 4.

In n=5, k=12, it performed func_3 twice to get [5,4,3,2,1], which increases S by 12.

In n=5, k=2, it performed func_2 once to get [1,2,3,5,4], which increases S by 2.

So, it seems that func_3 increases S by a maximum amount, and func_2 increases it by a smaller, specified amount.

I need to understand how much each swap increases S.

Let's analyze the swap in func_3:

def func_3(c, l):

(x, y) = (l[-c], l[c - 1])

(l[c - 1], l[-c]) = (x, y)

return l

So, it swaps l[c-1] and l[-c].

For c=1, it swaps l[0] and l[-1].

For c=2, it swaps l[1] and l[-2].

And so on.

Let's see how much S increases with such a swap.

Suppose we have l, and we swap l[a] and l[b].

Then, the change in S is:

delta_S = |l[a] - (a+1)| + |l[b] - (b+1)| - |original_a - (a+1)| - |original_b - (b+1)|

But this seems complicated.

Alternatively, since we are starting from the identity permutation, where S=0, each swap increases S by a certain amount.

Wait, but in the identity permutation, S=0, and each swap increases S by the sum of the absolute differences for the two positions involved.

Wait, perhaps it's easier to think in terms of the positions being swapped.

Let me consider n=3, c=1:

Swap l[0] and l[2]: [1,2,3] -> [3,2,1]

Original S=0.

New S= |3-1| + |2-2| + |1-3| = 2 + 0 + 2 =4.

So, delta_S =4.

Similarly, for n=5, c=1:

Swap l[0] and l[4]: [1,2,3,4,5] -> [5,2,3,4,1]

S= |5-1| + |2-2| + |3-3| + |4-4| + |1-5| =4 +0 +0 +0 +4=8.

Similarly, c=2:

Swap l[1] and l[3]: [5,2,3,4,1] -> [5,4,3,2,1]

S= |5-1| + |4-2| + |3-3| + |2-4| + |1-5| =4 +2 +0 +2 +4=12.

So, each func_3 swap increases S by 4.

Wait, but in n=3, c=1, it increased S by 4.

In n=5, c=1, swap increases S by 8, and c=2 increases by 4.

Wait, but in n=3, c=1, swap increases by 4.

Wait, perhaps the increase is 2*(i -1), where i is the current loop variable.

In n=3, i=3, c=1, delta_S=4=2*(3-1).

In n=5, c=1, i=5, delta_S=8=2*(5-1).

c=2, i=3, delta_S=4=2*(3-1).

So, it seems that each func_3 swap increases S by 2*(i-1), where i is the current loop variable.

Similarly, func_2 seems to perform a partial swap to achieve a smaller increase in S.

In n=5, k=2, it performs func_2 with c=1, k=1, l=[1,2,3,4,5].

func_2(1,1,l):

Swap l[-1]=5 and l[-1-1]=4: so swap l[3] and l[4]: [1,2,3,5,4]

S= |1-1| + |2-2| + |3-3| + |5-4| + |4-5| =0+0+0+1+1=2, which is the desired k=2.

So, func_2 allows for a finer control over the increase in S.

It seems that func_1 is trying to build the permutation by making swaps that increase S by the maximum possible amount (2*(i-1)) using func_3, and when k is less than that, it uses func_2 to make a smaller swap.

This way, it can reach any even k between 0 and the maximum possible.

Given that, and seeing that the sample inputs and outputs match, and the logic seems sound, I would say that the reference solution is correct.

Therefore, Correctness: **True**