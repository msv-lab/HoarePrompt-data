Alright, I've got this problem to solve. Let's see what it's asking for. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (where 2 ≤ i ≤ n-1), and then decrementing a[i-1], a[i], and a[i+1] by 1, 1, and 1 respectively, but a[i] is decremented by 2. The goal is to make all elements of the array zero using these operations.

First, I need to understand what this operation does. It seems like it's a way to reduce the values in the array, particularly targeting the middle elements more heavily since a[i] is reduced by 2. The operation can be applied any number of times, and any index i (between 1 and n-1) can be chosen for each operation.

I need to figure out if it's possible to apply these operations in such a way that all elements become zero.

Let me think about the constraints and what they imply.

Given that n is at least 3 and can be up to 2*10^5, I need to consider the efficiency of my solution because anything above O(n) might be too slow, especially since t can be up to 10^4, and the total sum of n over all test cases is up to 2*10^5. So, an O(n) per test case should be acceptable.

Now, to approach this problem, I should think about what the operations allow me to do. Each operation affects three consecutive elements, reducing them in a specific manner. I need to see if I can manipulate these operations to zero out the entire array.

One way to think about this is to model the operations as a system of equations and see if I can solve for the number of times each operation needs to be applied.

Let me denote the number of times I apply the operation at position i as x_i. Then, for each position in the array, I can write an equation based on how the operations affect that position.

For position 1:

a_1 - x_1 = 0

For position 2:

a_2 - x_1 - 2*x_2 - x_3 = 0

For position 3:

a_3 - x_2 - 2*x_3 - x_4 = 0

...

For position n-1:

a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

For position n:

a_n - x_{n-1} = 0

Wait, but in the problem, the operation is defined for 2 ≤ i ≤ n-1, so x_i corresponds to operations on i from 2 to n-1.

Let me adjust the equations accordingly.

For position 1:

a_1 - x_2 = 0

For position 2:

a_2 - x_1 - 2*x_2 - x_3 = 0

For position 3:

a_3 - x_2 - 2*x_3 - x_4 = 0

...

For position n-1:

a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

For position n:

a_n - x_{n-1} = 0

Wait, that doesn't seem right. Let's think again.

If I apply an operation at index i (where 2 ≤ i ≤ n-1), then:

a_{i-1} -= 1

a_i -= 2

a_{i+1} -= 1

So, for each operation at i, a_{i-1}, a_i, and a_{i+1} are reduced by 1, 2, and 1 respectively.

So, for position 1, it can only be affected by operations at i=2.

Similarly, position n can only be affected by operations at i=n-1.

Position k (2 ≤ k ≤ n-1) can be affected by operations at i=k-1, i=k, and i=k+1.

Wait, no. For position k, operations at i=k-1 would affect a_{k-2}, a_{k-1}, a_k.

Operations at i=k would affect a_{k-1}, a_k, a_{k+1}.

Operations at i=k+1 would affect a_k, a_{k+1}, a_{k+2}.

So, for position k, it can be influenced by operations at i=k-1, i=k, and i=k+1.

Given that, I can set up equations for each position.

Let me try to write the equations more carefully.

Let x_i be the number of times operation is applied at position i (2 ≤ i ≤ n-1).

Then, for position 1:

a_1 - x_2 = 0

For position 2:

a_2 - x_1 - 2*x_2 - x_3 = 0

For position 3:

a_3 - x_2 - 2*x_3 - x_4 = 0

...

For position n-1:

a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

For position n:

a_n - x_{n-1} = 0

Wait, but in the operation, when I apply it at i, I decrement a_{i-1}, a_i, and a_{i+1} by 1, 1, and 1 respectively, but a_i is decremented by 2. So, a_i is actually decremented by 2.

Wait, no. Let's read the problem again carefully.

"operation:

- a_{i - 1} = a_{i - 1} - 1

- a_i = a_i - 2

- a_{i + 1} = a_{i + 1} - 1"

Yes, a_i is decremented by 2, and a_{i-1} and a_{i+1} are each decremented by 1.

So, in terms of x_i, the number of times operation is applied at position i.

Then, for position 1:

a_1 - x_2 = 0

Because only operations at i=2 affect a_1.

For position 2:

a_2 - x_1 - 2*x_2 - x_3 = 0

Operations at i=1 affect a_2 by -2, operations at i=2 affect a_2 by -2, operations at i=3 affect a_2 by -1.

Wait, but i starts from 2, so i=2 can affect a_2.

i=1 is not allowed, since i starts from 2.

Wait, no, the operation can be applied for i from 2 to n-1.

So, for position 2, it can be affected by operations at i=2 (which affects a_1, a_2, a_3), and operations at i=3 (which affects a_2, a_3, a_4), but operations at i=2 affect a_2 by -2, and operations at i=3 affect a_2 by -1.

Wait, no, operations at i=2 affect a_2 by -2, and operations at i=3 affect a_2 by -1.

Similarly, operations at i=1 would affect a_2 by -1, but i starts from 2, so i=2 is the only operation that affects a_2 by -2, and i=3 affects it by -1.

Wait, but i starts from 2, so for position 2, it's only affected by operations at i=2 and i=3.

Similarly, for position 1, only affected by operations at i=2.

So, equations:

Pos 1: a1 - x2 = 0

Pos 2: a2 - 2*x2 - x3 = 0

Pos 3: a3 - x2 - 2*x3 - x4 = 0

...

Pos n-1: a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

Pos n: a_n - x_{n-1} = 0

Wait, but in the operation, a_{i-1} -=1, a_i -=2, a_{i+1} -=1.

So, for position k, the coefficients would be:

- If k ==1: -x2

- If k ==n: -x_{n-1}

- Else: -x_{k-1} -2*x_k -x_{k+1}

Wait, no. Wait, in the equations above, for position 1: a1 - x2 =0, which makes sense because operations at i=2 affect a1 by -1.

Similarly, for position 2: a2 -2*x2 -x3 =0, because operations at i=2 affect a2 by -2, and operations at i=3 affect a2 by -1.

Similarly for position 3: a3 -x2 -2*x3 -x4 =0, and so on.

So, I can set up a system of equations:

For k from 1 to n:

sum over i=2 to n-1 of (something)*x_i = a_k

Where the coefficient of x_i for each a_k is:

- For k=1: -1 if i=2, else 0

- For k=2: -2 if i=2, -1 if i=3, else 0

- For k=3: -1 if i=2, -2 if i=3, -1 if i=4, else 0

- ...

- For k=n-1: -1 if i=n-2, -2 if i=n-1, -1 if i=n, else 0

- For k=n: -1 if i=n-1, else 0

Wait, but in the operation, a_{i-1} -=1, a_i -=2, a_{i+1} -=1.

So, in terms of x_i, the number of times operation is applied at position i.

Then, for each position k:

a_k - sum over i such that operation at i affects a_k =0

Specifically:

- operation at i affects a_{i-1} by -1, a_i by -2, a_{i+1} by -1.

So, for position k:

a_k - sum over i where operation at i affects a_k =0

Which is:

a_k - [if k>=2, x_{k-1}] - 2*[if k>=1 and k<=n-1, x_k] - [if k<=n-2, x_{k+1}] =0

Wait, more carefully:

For position k:

- if k=1: a1 - x2 =0

- if k=2 to n-1: a_k - x_{k-1} -2*x_k -x_{k+1} =0

- if k=n: a_n - x_{n-1} =0

So, that seems consistent with what I had earlier.

Now, I need to solve this system of equations to see if there exists non-negative integers x_2, x_3, ..., x_{n-1} such that all these equations are satisfied, and all a_k become zero.

Given that the operations can be applied any number of times, and the x_i represent the number of times operation is applied at position i, they must be non-negative integers.

This looks like a system of linear equations with integer coefficients, and I need to check if there's a non-negative integer solution for x_2 to x_{n-1} that satisfies all the equations.

Given the constraints on n and t, I need an efficient way to solve this for each test case.

Solving a system of n equations for each test case would be too slow if done naively, especially since n can be up to 2*10^5 and t up to 10^4, but with the total sum of n over all test cases being up to 2*10^5, so per-test-case efficiency is crucial.

I need a smarter way to solve this.

Let me see if I can find a pattern or a way to simplify these equations.

Looking at the equations:

Eq1: a1 - x2 =0

Eq2: a2 - x1 -2*x2 -x3 =0

Wait, no, from earlier:

For position 1: a1 - x2 =0

For position 2: a2 -x1 -2*x2 -x3 =0

Wait, but in the operation, operations start from i=2 to i=n-1.

Wait, let me think differently.

Let me consider the operations as a way to reduce the array step by step.

I need to see if I can reduce the entire array to zero by repeatedly applying these operations.

Another way to think about it is to consider the effect of the operations on the array.

Each operation reduces a[i-1], a[i], and a[i+1] by 1,1,1 respectively, but a[i] is reduced by 2.

So, it's like applying a specific pattern of reductions across the array.

I need to see if I can apply these patterns in such a way that the entire array becomes zero.

Perhaps I can model this as a system where I need to satisfy certain conditions based on the operations.

Let me consider the differences between consecutive elements.

Let me look at the differences between a[i] and a[i+1].

Define d[i] = a[i] - a[i+1] for i from 1 to n-1.

Let me see if there's a pattern in d[i].

After applying an operation at position i, the differences change as follows:

Before operation:

d[i-1] = a[i-1] - a[i]

d[i] = a[i] - a[i+1]

After operation at i:

a[i-1] -=1

a[i] -=2

a[i+1] -=1

So, new d[i-1] = (a[i-1]-1) - (a[i]-2) = (a[i-1] - a[i]) +1 = d[i-1] +1

new d[i] = (a[i]-2) - (a[i+1]-1) = (a[i] - a[i+1]) -1 = d[i] -1

So, applying an operation at i increases d[i-1] by 1 and decreases d[i] by 1.

This is interesting.

So, each operation at i adjusts d[i-1] and d[i] in a specific way.

This might give me a way to think about the problem in terms of differences.

Let me consider the sequence of differences d[i] from 1 to n-1.

Initially, d[i] = a[i] - a[i+1]

After applying an operation at i (2 ≤ i ≤ n-1), d[i-1] increases by 1 and d[i] decreases by 1.

So, operation at i affects d[i-1] and d[i].

I can think of this as a way to adjust the differences.

My goal is to make all a[k] =0, which would imply that all d[k] =0 -0=0.

Wait, no. If all a[k]=0, then d[k]=0-0=0 for all k.

So, I need to adjust the differences to all be zero.

But how can I do that using the operations, which adjust d[i-1] and d[i] in specific ways?

Let me consider the cumulative effect of operations on the differences.

If I apply x_i operations at position i, then:

d[i-1] += x_i

d[i] -= x_i

So, for each i from 2 to n-1, d[i-1] increases by x_i and d[i] decreases by x_i.

My goal is to have d[i] =0 for all i from 1 to n-1.

So, I need to solve for x_i such that:

For i=1: d[1] + x_2 =0

For i=2: d[2] - x_2 + x_3 =0

For i=3: d[3] - x_3 + x_4 =0

...

For i=n-2: d[n-2] - x_{n-2} + x_{n-1} =0

For i=n-1: d[n-1] - x_{n-1} =0

Wait, this seems complicated. Maybe there's a better way to approach this.

Let me consider the sum of all a[i]. Each operation reduces the sum by 1+2+1=4.

Wait, no, each operation reduces a[i-1] by 1, a[i] by 2, and a[i+1] by 1, so the total reduction is 1+2+1=4 per operation.

So, the sum of the array decreases by 4 with each operation.

Therefore, for the array to be reducible to all zeros, the total sum must be divisible by 4.

Wait, that's an interesting observation.

So, a necessary condition is that sum(a) is divisible by 4.

But is it sufficient?

Wait, no. Consider a simple array like [0,4,0]. Sum is 4, which is divisible by 4.

Can I reduce it to [0,0,0]?

Applying operation at i=2: a[1]=0-1= -1, a[2]=4-2=2, a[3]=0-1=-1.

Wait, but negative numbers are allowed in intermediate steps, but the problem likely assumes non-negative integers, and we cannot have negatives.

Wait, in the problem statement, it says "valid inputs as described in the problem description", and "0 ≤ a_j ≤ 10^9", but it doesn't specify that intermediate steps cannot have negatives. It might allow intermediate negatives, but perhaps the problem assumes that only non-negative arrays are considered.

But in the example, starting from [1,3,5,5,2], after some operations, it goes through negative values, but the final answer is "YES".

Wait, in the example, all operations lead to non-negative arrays, I think.

Wait, in the first operation: [1,3,5,5,2] -> choose i=4: a[3]=5-1=4, a[4]=5-2=3, a[5]=2-1=1 -> [1,3,4,3,1]

All elements are still non-negative.

Second operation: choose i=3: [1,3,4,3,1] -> [1,2,2,2,1]

Third operation: choose i=2: [1,2,2,2,1] -> [0,0,1,2,1]

Fourth operation: choose i=4: [0,0,1,2,1] -> [0,0,0,0,0]

So, in this case, all intermediate steps保持非负。

So, perhaps the operations are only allowed if they result in non-negative arrays.

Therefore, in my approach, I need to ensure that at each step, the operations do not lead to negative values in the array.

Given that, I need to find a sequence of operations that reduces the array to zero without ever having negative values.

This seems tricky.

Alternatively, perhaps there's a way to check the feasibility without simulating all operations.

Let me think about the problem differently.

Suppose I have the array a[1..n].

I need to apply operations that affect a[i-1], a[i], a[i+1] in a specific way.

I need to see if I can zero out the entire array.

Another approach is to consider the operations as a kind of convolution or filtering, and see if I can invert it to reach zero.

But that might be too abstract.

Let me consider smaller arrays to see if I can find a pattern.

For n=3: [a,b,c]

Operations can only be applied at i=2.

Operation at i=2: a -=1, b-=2, c-=1.

To make a=0, b=0, c=0, we need:

a - x=0 => x=a

b - 2x=0 => x=b/2

c - x=0 => x=c

So, x=a, x=b/2, x=c must all be equal.

Therefore, a must equal c, and b must be 2a.

So, for n=3, the condition is a == c and b == 2a.

In this case, x=a=b/2=c.

If these conditions are met, then "YES", else "NO".

For n=4: [a,b,c,d]

Operations can be at i=2 and i=3.

Operation at i=2: a-=1, b-=2, c-=1

Operation at i=3: b-=1, c-=2, d-=1

Let x be the number of times operation at i=2 is applied, and y at i=3.

Then:

a - x =0 => x=a

b - 2x - y =0 => 2a + y = b => y=b-2a

c - x - 2y =0 => a + 2*(2a - b) = c => a + 4a - 2b = c => 5a - 2b =c

d - y =0 => y=d

So, y=b-2a=d

And y must be non-negative.

So, b-2a=d >=0

Also, c =5a -2b

This seems complicated.

I need to find a general approach that works for any n.

Let me consider the problem in terms of linear algebra.

The operations can be represented as vectors that are subtracted from the array vector.

Each operation corresponds to a specific vector: [0,0,...,0,1,2,1,0,...,0], where the 1,2,1 are at positions i-1, i, i+1.

I need to see if the vector a is a linear combination of these operation vectors, with non-negative integer coefficients.

This is equivalent to solving a system of linear equations with the operation vectors as columns.

But with large n, this approach is not practical.

I need a smarter way.

Let me consider the cumulative sum of the array.

Define s[k] = a[1] + a[2] + ... + a[k]

Then, look at how operations affect s[k].

Operation at i changes:

a[i-1] -=1 => s[k] -=1 for k >=i-1

a[i] -=2 => s[k] -=2 for k >=i

a[i+1] -=1 => s[k] -=1 for k >=i+1

So, s[k] after operation at i:

s[k] -=1 if k >=i-1

s[k] -=2 if k >=i

s[k] -=1 if k >=i+1

Wait, but these overlaps.

This seems messy.

Maybe cumulative sum is not the way to go.

Let me consider the differences again.

From earlier, each operation at i increases d[i-1] by 1 and decreases d[i] by 1.

So, d[i] = a[i] - a[i+1]

After operations, d[i] should be zero for all i.

So, I need to adjust d[i] to zero using the operations.

Given that each operation increases d[i-1] by 1 and decreases d[i] by 1.

So, operations allow me to decrease d[i] by 1 and increase d[i-1] by 1, in tandem.

This looks like I can shift value from d[i] to d[i-1].

I need to make all d[i]=0.

So, starting from d[1] to d[n-1], I need to adjust them to zero.

Given that operations allow me to shift value from d[i] to d[i-1], I can think of this as a chain where I can propagate values leftward.

To make d[i]=0, I can use operations at i to reduce d[i] by 1 and increase d[i-1] by 1.

I need to ensure that I can propagate all values to the left until d[1]=0.

Wait, but d[1] is affected only by operations at i=2.

So, I can only increase d[1] by operations at i=2.

Wait, but in the operation, applying at i=2 increases d[1] by 1 and decreases d[2] by 1.

Similarly, applying at i=3 increases d[2] by 1 and decreases d[3] by 1.

So, in essence, I can shift value from d[i] to d[i-1] by applying operations at i.

So, to make d[i]=0 for all i, I need to shift all values to the left, ultimately to d[0], which doesn't exist.

But in reality, d[1] must be zero initially, because there's no way to adjust it other than by operations at i=2, which increase d[1] but decrease d[2].

Wait, but if d[1] is not zero, I can apply operations at i=2 to increase d[1], but I need d[1]=0.

So, perhaps d[1] must be zero initially, and then I can adjust the rest.

This seems too convoluted.

Let me consider another approach.

Suppose I try to greedily apply operations starting from the left or the right.

If I start from the left, I can look for positions where a[i] is greater than zero and try to apply operations to reduce them.

But since operations affect three positions, I need to be careful about overlapping effects.

This seems tricky.

Alternatively, perhaps I can model this as a system where I need to satisfy certain conditions based on the operations.

Let me consider the sum of the array.

Each operation reduces the sum by 4, as established earlier.

So, sum(a) must be divisible by 4.

But is this sufficient?

Wait, in the example given:

Test case 1: n=5, a=[1,3,5,5,2], sum=16, which is divisible by 4, and the answer is "YES".

Test case 2: n=5, a=[2,4,4,5,1], sum=16, which is divisible by 4, but the answer is "NO".

So, sum being divisible by 4 is necessary but not sufficient.

Therefore, there must be another condition to check.

I need to find what that condition is.

Looking at the operations again, each operation reduces a[i-1], a[i], a[i+1] by 1,2,1 respectively.

I need to see if there's a way to ensure that after applying some operations, all a[i] become zero.

Perhaps I can consider the array in terms of its "peaks" and "valleys".

Each operation reduces a "peak" and its adjacent elements.

Alternatively, maybe I can model this as a system of inequalities.

But I'm not sure.

Let me consider the problem in terms of invariants.

An invariant is a property that remains unchanged by the operations.

Is there any invariant in this problem that can help me determine if the array can be zeroed out?

Let me consider the differences again.

From earlier, operations adjust d[i-1] and d[i] by +1 and -1 respectively.

So, the sum d[1] + d[2] + ... + d[n-1] remains unchanged because d[i-1] increases by 1 and d[i] decreases by 1.

So, the sum of differences is invariant.

But sum of differences is d[1] + d[2] + ... + d[n-1] = a[1] - a[n]

So, a[1] - a[n] must remain unchanged.

Therefore, a[1] - a[n] must be zero for the array to be reducible to all zeros, because in the zero array, a[1] - a[n] =0.

Hence, a[1] must equal a[n].

Additionally, sum(a) must be divisible by 4.

But in the second test case, a=[2,4,4,5,1], a[1]=2, a[n]=1, which are not equal, and yet sum is 16, which is divisible by 4.

But the answer is "NO", which aligns with the condition that a[1] must equal a[n].

Wait, but in the first test case, a[1]=1, a[n]=2, which are not equal, but the answer is "YES".

Wait, hold on, in the first test case, a=[1,3,5,5,2], a[1]=1, a[n]=2, which are not equal, but the answer is "YES".

Wait, that contradicts my earlier assertion.

So, perhaps a[1] must equal a[n] only if sum(a) is divisible by 4.

Wait, no, in the first test case, sum is 16, divisible by 4, and a[1]!=a[n], but answer is "YES".

So, my earlier thought is incorrect.

Therefore, a[1] must equal a[n] is not a necessary condition.

Wait, perhaps I made a mistake in calculating the sum of differences.

Wait, sum of differences d[1]+d[2]+...+d[n-1] = a[1] - a[n]

In the first test case, a=[1,3,5,5,2], so a[1]=1, a[n]=2, so sum of differences is 1 - 2 = -1.

But in the zero array, sum of differences is 0 - 0 =0.

So, -1 !=0, which suggests it's impossible, but the answer is "YES".

Wait, that's confusing.

Perhaps I need to reconsider the invariant.

Let me think differently.

Suppose I have the array a.

Each operation reduces a[i-1], a[i], a[i+1] by 1,2,1 respectively.

I need to find x_i (number of operations at i) such that:

for each j from 1 to n:

a[j] - sum over i such that operation at i affects a[j]) =0

Specifically:

- for j=1: a[1] - x[2] =0

- for j=2: a[2] - x[1] -2*x[2] -x[3] =0

- for j=3: a[3] - x[2] -2*x[3] -x[4] =0

...

- for j=n-1: a[n-1] - x[n-2] -2*x[n-1] -x[n] =0

- for j=n: a[n] - x[n-1] =0

Wait, but in the operation, i ranges from 2 to n-1, so x_i are for i from 2 to n-1.

Wait, no, in the code provided, it's from 1 to n-1, but according to the problem, i starts from 2.

Wait, in the problem, i starts from 2 to n-1.

So, x_i are for i from 2 to n-1.

Wait, but in the code, it's from 1 to n-1, which might be incorrect.

Wait, in the code:

def func_2(list, n):

for i in range(1, n - 1):

while list[i] > 1 and list[i - 1] > 0 and (list[i + 1] > 0):

list[i - 1] -= 1 * list[i - 1]

list[i] -= 2 * list[i - 1]

list[i + 1] -= 1 * list[i - 1]

This seems flawed.

First, the operation should decrement by 1,2,1 respectively, but here it's decremented by list[i-1], 2*list[i-1], list[i-1], which doesn't make sense.

Wait, perhaps it's a typo in the code.

It should be:

list[i - 1] -=1

list[i] -=2

list[i + 1] -=1

But in the code, it's written as:

list[i - 1] -= 1 * list[i - 1]

list[i] -= 2 * list[i - 1]

list[i + 1] -= 1 * list[i - 1]

Which is equivalent to:

list[i - 1] -= list[i - 1]

list[i] -= 2 * list[i - 1]

list[i + 1] -= list[i - 1]

This would set list[i - 1] to zero, and decrement list[i] and list[i + 1] by list[i - 1].

This doesn't seem correct according to the problem description.

The problem says:

operation:

a_{i - 1} = a_{i - 1} - 1

a_i = a_i - 2

a_{i + 1} = a_{i + 1} - 1

So, each operation decrements a_{i-1}, a_i, a_{i+1} by 1,2,1 respectively.

Therefore, the code should be:

list[i - 1] -=1

list[i] -=2

list[i + 1] -=1

But in the given code, it's decremented by list[i-1], 2*list[i-1], list[i-1], which is different.

Therefore, the given code is incorrect.

Hence, Correctness: False

**Final Answer**

\[ \boxed{\text{False}} \]