Alright, I've got this problem to solve. Let's see what it's asking for. So, Jay created a problem of difficulty x and wants to make it the second problem for Codeforces Round #921. But Yash is worried that this might make the contest unbalanced, so he decides to break this problem into n sub-problems, each with a positive integer difficulty, and the sum of these sub-problems should be equal to x.

Now, the coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems. Yash wants to choose the difficulties of these sub-problems in such a way that this balance is maximized.

So, my task is to find the maximum possible GCD for any set of n positive integers that sum up to x.

First, I need to understand what GCD is. GCD of a set of numbers is the largest number that divides all of them without leaving a remainder. For example, GCD of 8 and 12 is 4 because 4 is the largest number that divides both 8 and 12.

Given that, I need to split x into n parts such that their GCD is as large as possible.

Let me think about this. If I have x and n, I need to distribute x into n parts with each part being a positive integer.

One way to maximize the GCD is to make all the parts as equal as possible. Because if they are equal, their GCD would be that number itself. But that might not always be possible because x might not be divisible by n.

Wait, if x is divisible by n, then I can divide x by n to get each part equal to x/n, and since all parts are equal, the GCD would be x/n.

But if x is not divisible by n, then I can't have all parts equal to x/n. Some parts will be x/n and some will be x/n + 1.

Wait, no. If x is not divisible by n, then x = n * q + r, where q is the quotient and r is the remainder when x is divided by n. So, r is between 1 and n-1.

In this case, I can have r parts with value q+1 and n - r parts with value q.

So, the parts are mostly q with some being q+1.

Now, what is the GCD of these numbers?

Let me take an example.

Suppose x = 10 and n = 3.

Then, q = 10 // 3 = 3, r = 10 % 3 = 1.

So, I have 1 part with 4 and 2 parts with 3.

So, the parts are 4, 3, 3.

GCD of 4 and 3 is 1.

But according to the example, it's possible to have a GCD of 2.

Wait, maybe I need to choose the parts differently.

Wait, in the first test case, x=10, n=3.

One possible way is 4, 2, 4. GCD is 2.

But according to my earlier logic, I got 4,3,3 with GCD 1.

So, there must be a better way to choose the parts to maximize the GCD.

Hmm.

Let me think differently.

Suppose the GCD is d.

Then, each sub-problem's difficulty must be a multiple of d.

And the sum of these difficulties is x, which means that x must be divisible by d, because each difficulty is a multiple of d, and there are n of them.

Wait, no. Wait, the sum of multiples of d is also a multiple of d.

So, x must be divisible by d.

Moreover, since each difficulty is at least 1, and there are n of them, the smallest possible difficulty is 1, so d must be at least 1.

Also, the maximum possible d is the largest d such that d divides x and n <= x/d, because each difficulty must be at least d.

Wait, let's see.

If d is the GCD, then each difficulty is at least d, since d divides each difficulty.

So, the smallest possible difficulty is d.

Therefore, n * d <= x, because there are n difficulties, each at least d.

So, d <= x / n.

Therefore, the maximum possible d is the largest d such that d divides x and d <= x / n.

So, to maximize d, I need to find the largest d that divides x and is less than or equal to floor(x / n).

So, the approach should be:

1. Compute q = floor(x / n).

2. Find the largest d <= q such that d divides x.

To find such a d, I can iterate from q down to 1, and check if d divides x.

But for large x and n, this could be time-consuming if done naively.

I need a more efficient way.

Let's think about the divisors of x.

I can find all the divisors of x, then select the largest one that is <= q.

To do this efficiently, I need to find all divisors of x up to q.

Finding all divisors of x up to q can be done by iterating from 1 to sqrt(x), and for each i that divides x, add i and x/i to the list of divisors if they are <= q.

Then, among these, select the largest one.

Wait, but in the code provided, it seems to be doing something different.

Let me look at the given code.

The code is:

def func():

for _ in range(int(input())):

(x, n) = map(int, input().split())

k = x // n

if k == 1:

print(1)

continue

ans = 1

for i in range(1 + (1 if x % 2 == 0 else 0), int(x ** 0.5) + 1, 2):

if x % i == 0:

l = [ans]

if i <= k:

l.append(i)

if x // i <= k:

l.append(x // i)

ans = max(l)

print(ans)

So, it handles the case when k=1 separately, printing 1.

Then, for other cases, it iterates from 1 to sqrt(x), in steps of 2, but starting from 1 or 2 depending on whether x is even.

Inside the loop, it checks if i divides x, and if i or x/i is <= k, it considers them for the answer.

Wait, this seems inefficient and perhaps incorrect.

In the first test case, x=10, n=3, k=3.

It should find divisors of 10 up to 3, which are 1 and 2 and 5.

But 5 is greater than k=3, so it should consider only 1 and 2.

The largest is 2, which matches the example.

In the second test case, x=5, n=5, k=1.

It directly prints 1.

In the third test case, x=420, n=69, k=6.

It should find divisors of 420 up to 6.

Divisors of 420 are 1, 2, 3, 4, 5, 6, 7, 10, 12, 14, 15, 20, 21, 28, 30, 35, 42, 60, 70, 84, 105, 140, 210, 420.

Up to 6, they are 1,2,3,4,5,6.

The largest is 6, which matches the example.

So, in the code, for k >=2, it seems to be trying to find the largest divisor <=k.

But the way it's implemented seems a bit convoluted.

Let me try to understand the code.

It has:

for i in range(1 + (1 if x % 2 == 0 else 0), int(x ** 0.5) + 1, 2):

So, it's starting from 1 or 2 depending on whether x is even, and iterating by 2 up to sqrt(x).

Wait, that seems inefficient because it's only checking odd numbers, except when x is even.

But, actually, when x is even, it starts from 2, which is even, but then steps by 2, so it's checking even numbers only.

Wait, no, wait, 1 is odd, and if x is even, it's 1 +1=2, so starts from 2 and steps by 2, so checks even numbers.

If x is odd, it starts from 1 and steps by 2, checking odd numbers.

But this seems suboptimal because it doesn't check all possible divisors efficiently.

For example, for x=10, which is even, it starts from 2 and steps by 2, so checks 2,4,6,8,10.

But 5 is a divisor, but it's odd, so it would be missed in this loop.

Wait, but 10**0.5 is about 3.16, so it only goes up to 3.

So, it checks i=2, since x=10 is even, starts from 2, then i=4 which is > sqrt(10), so stops.

So, it only checks i=2, and since 2 divides 10, it appends 2 and x/i=5 if x/i <=k.

So, for x=10, n=3, k=3.

It appends 2 and 5, since both 2 and 5 <=3? Wait, 5 >3, so only 2 is appended.

Hence, ans=2, which is correct.

Similarly, for x=420, n=69, k=6.

It starts from 2 (since x is even), steps by 2.

Checks i=2,4,6,8,10,12,... up to sqrt(420)=about 20.49.

So, i=2,4,6,8,10,12,14,16,18,20.

For i=2, x/i=210 >k=6, so only append i=2.

i=4, x/i=105 >k=6, append i=4.

i=6, x/i=70 >k=6, append i=6.

i=8, x/i=52.5, not integer, skip.

And so on.

So, it appends 2,4,6.

Hence, ans=6, which is correct.

So, in this case, it works.

But is this the most efficient way?

I think there's a better way to find all divisors up to k.

Here's a better approach:

1. Find all divisors of x.

2. Filter those divisors to keep only those <= k.

3. Take the maximum of these filtered divisors.

To find all divisors of x efficiently, we can iterate from 1 to sqrt(x), and for each i that divides x, add both i and x/i to the list of divisors, unless i == x/i.

Then, filter those <= k and take the maximum.

This ensures we don't miss any divisors.

In the code provided, it seems to be trying to iterate only odd numbers for odd x, and even numbers for even x, but it's a bit convoluted.

Moreover, in the first test case, it correctly found 2, which is the largest divisor <=3.

In the second test case, k=1, so directly prints 1.

In the third test case, it found 6, which is correct.

So, despite the convoluted loop, it seems to be working correctly for these cases.

But I think the logic can be simplified.

Here's a revised version:

def func():

for _ in range(int(input())):

x, n = map(int, input().split())

k = x // n

if k == 1:

print(1)

continue

# Find all divisors of x up to k

divisors = set()

for i in range(1, int(x**0.5)+1):

if x % i == 0:

divisors.add(i)

divisors.add(x // i)

# Filter divisors <= k and find the maximum

candidates = [d for d in divisors if d <= k]

if candidates:

print(max(candidates))

else:

print(1)

But in the original code, it seems to handle k==1 separately, which is fine.

Also, for k=1, the GCD can only be 1, since all difficulties are at least 1.

So, the original code seems to be correct.

Hence, the answer is True.

**Final Answer**

\[ \boxed{\text{True}} \]