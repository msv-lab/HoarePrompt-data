Alright, I've got this problem to solve. Let's see what it's about. So, there's this game between Alice and Bob where they play on an array of size n. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from a, appends it to c, and deletes it from a. Bob, on his turn, picks an element from a, and deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c. Alice wants to maximize the MEX, and Bob tries to minimize it. I need to find the final score assuming both play optimally.

First, I need to understand MEX better. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [0,1,2] is 3, MEX of [0,1,3] is 2, and MEX of [1,2,3] is 0. So, it's essentially the smallest missing number starting from 0.

Now, Alice wants to maximize this MEX, which means she wants to have as many small numbers in c as possible, in order to make the MEX as large as possible. Bob, on the other hand, wants to minimize the MEX, so he will try to prevent Alice from achieving that by possibly removing elements that Alice needs.

Since Alice can only add elements to c, and Bob can only remove elements from a, I need to think about how their actions influence the final MEX.

Let's consider the total number of elements, n, and the fact that Alice gets to choose elements for c, but Bob can interfere by removing elements that might be useful for Alice.

I need to find a way to simulate their optimal play without actually playing out the game, as that would be too slow for the given constraints.

Let me think about the properties of MEX. MEX is determined by the presence or absence of integers starting from 0. So, if 0 is in c, then MEX is at least 1. If 0 and 1 are in c, MEX is at least 2, and so on.

Given that, Alice wants to include as many low numbers in c as possible, while Bob tries to prevent that.

Let's consider the frequency of each number in the array a. If a number appears multiple times, Alice can potentially pick multiple instances of it, but Bob can also remove some instances.

I need to model how Alice and Bob's turns alternate and how they affect the final composition of c.

Wait, perhaps I can think in terms of the number of times Alice and Bob get to play. Since Alice starts, and they alternate, the number of times Alice plays is either equal to or one more than Bob, depending on whether n is even or odd.

Specifically, if n is even, both play n/2 times. If n is odd, Alice plays (n+1)/2 times, and Bob plays (n-1)/2 times.

But directly simulating this seems inefficient for n up to 2e5 per test case, and t up to 2e4.

I need a smarter approach.

Let me consider that Alice can choose elements for c, and Bob can delete elements from a, but not directly from c.

Wait, no, Bob deletes from a, which affects what Alice can choose in future turns.

I need to find out which numbers Alice can ensure to include in c, despite Bob's interference.

Let's consider each number from 0 upwards and see if Alice can include it in c.

For a number i, if it appears at least k times in a, where k is the number of times Alice can pick before Bob can remove all but k - (number of times Bob plays) instances.

This seems complicated. Maybe I need to think in terms of the frequency of each number and the number of times Alice and Bob can play.

Let me try to formalize it.

Let freq[i] be the frequency of number i in a.

Let total turns be n.

Alice plays ceil(n/2) times, Bob plays floor(n/2) times.

Wait, no. If n is even, both play n/2 times. If n is odd, Alice plays (n+1)/2 times, Bob plays (n-1)/2 times.

Wait, more precisely, since Alice starts, she plays first, then Bob, then Alice, and so on.

So, if n is even, Alice and Bob each play n/2 times.

If n is odd, Alice plays (n+1)/2 times, Bob plays (n-1)/2 times.

Now, Alice wants to include as many small numbers in c as possible.

Bob wants to prevent that.

For each number i, if freq[i] > number of times Bob can play, then Alice can ensure to include at least one i in c.

Because she can pick it more times than Bob can remove it.

Wait, but Bob can only remove from a, not directly from c.

Wait, no, Bob removes from a, which reduces the available elements for Alice to pick in future turns.

So, if a number i appears freq[i] times, and Bob plays b times, he can remove up to b instances of i.

Similarly, Alice can pick up to a times, where a is the number of times Alice plays.

But since they alternate, and Alice starts, the order matters.

This seems tricky.

Maybe I can think in terms of the difference between Alice's and Bob's moves.

If freq[i] > floor(n/2), then Alice can ensure to pick at least one i, because even if Bob removes floor(n/2) instances, there's still at least one left.

Wait, but freq[i] could be less than floor(n/2).

I need a better way.

Let me look at the reference solution provided.

The solution sorts the array and then iterates through it, keeping track of the current MEX value.

It maintains a dictionary M to keep track of how many times each number up to the current MEX has been added to c.

At the end, it calculates the MEX based on the sums in M.

Wait, I need to understand this code.

Let's go line by line.

First, it reads the number of test cases T.

Then, for each test case, it reads n and the array N.

It sorts N.

 Initializes cur to -1, which likely stands for the current MEX.

Then, it iterates through the sorted array.

If the current number is greater than cur, it checks if it's more than cur + 1.

If it is, it increments cur and breaks.

Otherwise, it sets cur to that number and adds it to M with count 1.

If the number is less than or equal to cur, it increments the count in M for that number.

After processing all numbers, it checks if the sum of counts in M equals S (which is n, the size of the array).

If so, it increments cur.

Then, it iterates from 0 to cur-1 and checks if M[i] <= i, in which case it sets cur to i and breaks.

Finally, it prints cur.

This seems convoluted.

I need to verify if this logic correctly computes the MEX under the game's rules.

Let me consider the first example from the problem:

n = 4

a = [0,0,1,1]

According to the solution:

Sort a: [0,0,1,1]

Initialize cur = -1

M = {}

First num = 0 > cur (-1), and 0 > cur +1 (-1 +1 = 0), so cur +=1 => cur=0

Then, num=0 == cur, so M[0]=1

Next num=0 == cur, so M[0]=2

Next num=1 > cur (0), and 1 > cur +1 (1 >1), which is false, so cur=1, M[1]=1

Sum of M values: 2 +1 =3 == S=4? No, 3 !=4, so no increment.

Then, iterate from i=0 to cur-1=0 to 0:

Check M[0] <=0 : M[0]=2 <=0? No, so no break.

So, print cur=1

But in the problem's example, the output is 2.

Wait, that's different.

In the note, it says that c=[1,0], which has MEX=2.

But according to this code, it's printing 1.

So, there's a discrepancy here.

Maybe I misread the variables.

Wait, in the code, S is n, which is 4.

M = {0:2, 1:1}, sum=3 == S=4? No, 3 !=4, so cur +=1? Wait, no, the condition is sum M.values() == S, which is 3 ==4, which is False, so cur doesn't increment.

Then, iterate i from 0 to cur-1=0 to 0:

Check M[0] <=0 : 2 <=0? No, so no break.

Print cur=1, but the expected output is 2.

So, the code seems incorrect for this test case.

Wait, perhaps S is not n.

Looking back at the code:

S = int(input())

N = list(map(int, input().split()))

So, S is n, the size of the array.

But in this test case, n=4, sum M.values()=3 !=4, so cur doesn't increment.

Then, check M[i] <=i for i in 0 to cur-1=0:

M[0]=2 <=0? No, so no change.

Print cur=1, but the correct answer is 2.

So, the code is wrong.

Wait, perhaps S is supposed to be the number of times Alice plays.

Wait, in the problem, S is n, the size of the array.

But in this test case, the output should be 2, but the code outputs 1.

So, the code is incorrect.

But the problem says to find the MEX of c when both play optimally.

I need to find a correct approach.

Let me try to think differently.

The game is turn-based, with Alice and Bob playing optimally.

Alice wants to maximize MEX, Bob wants to minimize it.

I need to find the final MEX when both play optimally.

This sounds like a game theory problem.

I need to find the optimal strategy for both players.

Let me consider that Alice can choose to pick any remaining element, and Bob can choose to delete any remaining element.

Since Alice wants to maximize MEX, she wants to include as many small numbers as possible in c.

Bob, wanting to minimize MEX, would want to prevent Alice from including certain numbers in c.

Wait, but Bob can only delete elements from a, not directly from c.

So, Bob can remove elements that Alice might want to include in c in future turns.

I need to model this interaction.

Let me consider that the game is equivalent to Alice selecting a subset of elements from a, of size ceil(n/2), and Bob selecting the remaining floor(n/2) elements.

But it's not that simple because of the turn-based nature.

Wait, perhaps it is.

Since Alice plays first, she gets to choose ceil(n/2) elements to include in c, and Bob gets to choose floor(n/2) elements to remove from a.

But it's not exactly removal; Bob deletes elements from a.

Wait, actually, Bob picks an element and deletes it from a.

So, Bob is removing elements that could potentially be in c.

But Alice gets to choose which elements to include in c from the remaining elements.

Wait, perhaps I can think of it as Alice selecting ceil(n/2) elements to include in c, and Bob selecting floor(n/2) elements to remove from a, but Alice gets to choose her elements after Bob's removal.

This is getting complicated.

Let me look for a different approach.

I recall that in game theory, such games can be analyzed using the concept of "choosing" and "blocking".

Alice is trying to include certain elements, and Bob is trying to block her by removing elements.

I need to find a way to determine which elements Alice can ensure to include in c.

Let me consider that for each number i from 0 to n, Alice needs to include it in c to maximize MEX.

Bob will try to prevent that by removing instances of i from a.

I need to find out for each i, whether Alice can include at least one i in c, given Bob's interference.

Let me formalize this.

Let freq[i] be the frequency of i in a.

Let a_plays = ceil(n/2)

Let b_plays = floor(n/2)

For each i, if freq[i] > b_plays, then Alice can ensure to include at least one i in c, because even if Bob removes b_plays instances, there's still at least one left for Alice to pick.

If freq[i] <= b_plays, then Bob can potentially remove all instances of i, preventing Alice from including it in c.

So, for each i from 0 upwards, if freq[i] > b_plays, Alice can include it, else, Bob can prevent it.

Therefore, the MEX would be the smallest i where freq[i] <= b_plays.

Wait, but in the first test case:

n=4, a=[0,0,1,1], freq[0]=2, freq[1]=2

b_plays = floor(4/2)=2

For i=0: freq[0]=2 >2? No, 2<=2, so Bob can prevent Alice from including 0 in c.

For i=1: freq[1]=2 >2? No, 2<=2, so Bob can prevent 1.

But in the example, c=[1,0], which has MEX=2.

Wait, but according to this logic, Bob can prevent both 0 and 1 from being in c.

But in the example, c=[1,0], which has MEX=2.

So, perhaps this logic is incomplete.

Wait, maybe I need to consider that Alice can choose which elements to include in c, and Bob can only remove elements from a.

So, in the first turn, Alice chooses 1, so c=[1], a=[0,0,1]

Bob then removes 0, so a=[0,1]

Alice chooses 0, so c=[1,0], a=[1]

Bob removes 1, so a=[]

Final c=[1,0], MEX=2

So, even though freq[0]=2 and freq[1]=2, and b_plays=2, Bob couldn't prevent Alice from including both 0 and 1 in c.

So, my previous logic is flawed.

I need to think differently.

Let me consider that Alice can choose to include any elements she wants, as long as she has enough opportunities to pick them before Bob can remove them.

Wait, perhaps I need to think in terms of the number of times Alice can pick an element before Bob can remove it.

Given that Alice plays first, she has an advantage.

Wait, maybe I can think in terms of the number of times Alice can pick an element compared to Bob's ability to remove it.

Let me consider that for each element, Alice can pick it up to freq[i] times, and Bob can remove it up to b_plays times.

But since Bob removes from a, not directly from c, Alice can choose to pick it before Bob removes it.

This is getting too tangled.

Let me look for a different strategy.

I recall that in such games, the MEX is determined by the numbers present in c.

Alice wants to include as many small numbers as possible, while Bob wants to prevent that.

Perhaps I can consider the minimal i such that the number of times Alice can include i in c is less than or equal to the number of times Bob can remove instances of i from a.

Wait, perhaps more precisely, for each i, calculate the number of times Alice can include i in c despite Bob's removals.

If Alice can include at least one i in c, then MEX should be higher.

Wait, perhaps I need to calculate for each i, the residual frequency after Bob's removals.

If residual freq[i] >0, then Alice can include i in c.

Otherwise, MEX should be i.

So, for each i, residual freq[i] = freq[i] - b_plays

If residual freq[i] >0, then Alice can include i in c.

Else, MEX is i.

Wait, but in the first test case, freq[0]=2, b_plays=2, residual=0, so MEX should be 0, but the example shows MEX=2.

This contradicts.

Wait, perhaps I need to adjust the residual calculation.

Wait, perhaps residual freq[i] = freq[i] - floor((freq[i]-1)/2), or something like that.

I need a better way.

Let me consider that Alice can include floor(freq[i]/2) +1 if freq[i] is odd.

Wait, perhaps not.

Wait, perhaps I need to consider the game as a selection game where Alice selects elements to include, and Bob selects elements to exclude.

Given that, perhaps the number of elements Alice can include is ceil(freq[i]/2), because she gets to choose first.

Wait, for each i, if freq[i] >=2*k, then Alice can include k instances.

But this seems off.

I need to think differently.

Let me consider that for each number i, the number of times Alice can include it in c is ceil(freq[i]/2).

Because for each pair of turns, Alice and Bob each pick once, so Alice can pick freq[i]/2 times, rounded up.

Wait, perhaps.

So, ceil(freq[i]/2).

Then, if ceil(freq[i]/2) >=1, Alice can include at least one i in c.

Else, she cannot.

So, for each i, if ceil(freq[i]/2) >=1, then Alice can include i, else not.

Then, the MEX would be the smallest i where ceil(freq[i]/2)=0, which is when freq[i]=0.

Wait, but freq[i] can be zero.

Wait, no, freq[i] is the count in a, which can be zero.

But in the example, all freq[i] are at least 1, but according to this, Alice can include at least one of each i where freq[i] >=1.

But in the first test case, freq[0]=2, ceil(2/2)=1, so Alice can include 1 zero.

Freq[1]=2, ceil(2/2)=1, so Alice can include 1 one.

So, c=[0,1], MEX=2, which matches the example.

In the second test case, n=4, a=[0,1,2,3], freq[i]=1 for i in [0,1,2,3]

Ceil(1/2)=1, so Alice can include one of each, c=[0,1,2,3], MEX=4.

But the sample output is 1, which contradicts.

Wait, perhaps I'm missing something.

Wait, n=4, a=[0,1,2,3], Alice plays first, picks 0, c=[0], a=[1,2,3]

Bob picks 1, a=[2,3]

Alice picks 2, c=[0,2], a=[3]

Bob picks 3, a=[]

Final c=[0,2], MEX=1

Wait, according to this, MEX is 1, because 1 is missing in c.

But according to my previous logic, ceil(1/2)=1, so Alice can include 1 of each, but in this scenario, she couldn't include all of them.

So, my previous assumption is incorrect.

Hence, I need a better approach.

Let me try to think in terms of the total number of picks Alice has.

Let a_plays = ceil(n/2)

Bob plays b_plays = floor(n/2)

Alice needs to include as many small numbers as possible in her a_plays picks.

Bob will try to prevent that by removing elements that Alice wants.

So, perhaps I need to find the minimal set of small numbers that Alice can guarantee to include in c with her a_plays picks.

Wait, maybe I can sort the unique numbers and see how many of them Alice can include.

Wait, perhaps prioritize the smallest numbers.

Alice will try to include the smallest numbers first, and Bob will try to prevent that.

So, perhaps I can sort the unique numbers and see how many of them Alice can guarantee to include.

Let me try to formalize this.

Let unique numbers be sorted as u[0], u[1], ..., u[m-1]

Alice wants to include as many u[i] as possible, starting from u[0].

Bob wants to prevent that.

So, for each u[i], Alice needs to include at least one instance in c.

Bob can delete elements from a, trying to prevent Alice from including u[i].

So, for each u[i], if freq[u[i]] > b_plays, then Alice can ensure to include at least one u[i] in c.

Because even if Bob removes b_plays instances, there's still some left for Alice to pick.

If freq[u[i]] <= b_plays, then Bob can potentially remove all instances of u[i], preventing Alice from including it in c.

Therefore, for each u[i], if freq[u[i]] > b_plays, Alice can include it, else not.

So, the MEX would be the smallest u[i] where freq[u[i]] <= b_plays.

But in the first test case, u=[0,1], freq[0]=2, freq[1]=2, b_plays=2.

According to this, for u[0], freq[0]=2 >2? No, 2<=2, so Bob can prevent Alice from including 0.

For u[1], freq[1]=2 >2? No, 2<=2, so Bob can prevent 1.

But in the example, c=[1,0], which has MEX=2.

This contradicts.

Wait, perhaps I need to consider that if freq[u[i]] > b_plays, Alice can include u[i], else not.

But in the example, even though freq[0]=2 and freq[1]=2, which are equal to b_plays=2, Alice was able to include both 0 and 1 in c.

So, perhaps the condition should be freq[u[i]] >= b_plays +1, then Alice can include at least one u[i].

Wait, if freq[u[i]] >= b_plays +1, then even if Bob removes b_plays instances, one remains for Alice to pick.

So, in the first test case, freq[0]=2 >=2+1=3? No, 2 <3, so Bob can prevent Alice from including 0.

Similarly, freq[1]=2 <3, so Bob can prevent 1.

But in the example, Alice included both 0 and 1.

So, perhaps this condition is not sufficient.

Wait, maybe I need to consider a_plays instead.

If freq[u[i]] >= a_plays, then Alice can include at least one u[i], because she can pick a_plays instances, and if freq[u[i]] >= a_plays, she can pick at least one.

Wait, a_plays = ceil(n/2)

In the first test case, n=4, a_plays=2, freq[0]=2 >=2, so Alice can include 0.

Similarly, freq[1]=2 >=2, so she can include 1.

Hence, MEX=2.

But according to the reference solution, it's printing 1, but the expected output is 2.

Wait, perhaps the reference solution is incorrect.

Let me check another test case.

Second test case:

n=4

a=[0,1,2,3]

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

a_plays=2

According to this, for u[0]=0, freq=1 <2, so Alice cannot include 0.

For u[1]=1, freq=1 <2, cannot include 1.

So, MEX should be 0, but the sample output is 1.

Wait, but c=[0,2], MEX=1, as per the example.

Wait, but according to this, since freq[0]=1 <2, Alice cannot include 0, and freq[1]=1 <2, cannot include 1, so MEX should be 0, but sample output is 1.

This is confusing.

Wait, perhaps I need to adjust the condition.

Maybe Alice can include u[i] if freq[u[i]] > b_plays.

Because Bob can remove up to b_plays elements, so if freq[u[i]] > b_plays, Alice can pick at least one.

In the first test case, freq[0]=2 > b_plays=2? No, 2<=2, so cannot include 0.

Freq[1]=2 >2? No, so cannot include 1.

But in the example, she included both.

So, perhaps the condition should be freq[u[i]] >= b_plays +1.

In the first test case, freq[0]=2 >=3? No.

Freq[1]=2 >=3? No.

But she included both.

This suggests that my condition is too strict.

Wait, perhaps I need to consider the total picks.

Let me think differently.

Let me consider that Alice can include floor(freq[u[i]] /2) +1 if freq[u[i]] is odd.

Wait, perhaps not.

Let me consider that for each u[i], the number of times Alice can include it is ceil(freq[u[i]] /2).

Because for every two turns (Alice and Bob), Alice can pick once.

So, ceil(freq[u[i]] /2) is the number of times Alice can include u[i].

If ceil(freq[u[i]] /2) >=1, then Alice can include at least one u[i].

Else, she cannot.

In the first test case, ceil(2/2)=1 >=1, so include 0 and 1.

Hence, c=[0,1], MEX=2.

In the second test case, ceil(1/2)=1 >=1, so she can include 0 and 1 and 2 and 3.

But in the example, c=[0,2], which has