Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The sum of all the water in these containers is divisible by n, which means that theoretically, we can distribute the water equally among all containers. The question is whether it's possible to achieve this equal distribution using a specific operation: pouring water from one container to another, but only from a container with a lower index to a higher index.

First, I need to understand the constraints and what operation I can perform. The operation allows me to pour any amount of water from container i to container j, but only if i < j. That means I can only pour water forward in the sequence, not backward. This is important because it imposes a direction on how water can be moved.

Given that, I need to find out if it's possible to make all containers have the same amount of water by only pouring water forward.

Let's think about what the target amount of water per container should be. Since the total sum is divisible by n, the target amount is sum(a)/n. Let's call this target value 'target'.

Now, I need to check if it's possible to rearrange the water in such a way that each container ends up with 'target' amount of water, using only the allowed operations.

One way to approach this is to consider the cumulative sum from left to right. Since we can only pour water forward, the amount of water in the first container can only affect the containers to its right, not to its left.

Let's consider the cumulative sum up to each position. If at any point, the cumulative sum up to that position is less than the expected sum up to that position (which would be target * position), it means that we need to have poured some water from earlier containers to make up for this deficit. But since we can only pour forward, the earlier containers must have had excess water to pour into the current one.

Wait, maybe I need to think differently. Let's consider that for each container, if it has more than the target amount, it can pour the excess to the containers on its right. If it has less than the target amount, it needs to receive water from the containers on its left.

But given the operation only allows pouring from lower index to higher index, it means that each container can only receive water from the containers immediately to its left, not from any container further left.

Hmm, maybe I should consider the problem in reverse. Starting from the last container, since we can't pour anything into it from the right, it has to have exactly the target amount, or it must receive water from the containers on its left, but since it's the last one, it can't receive anything. So, the last container must already have at least the target amount.

Wait, no. If the last container has less than the target, there's no way to pour more into it because we can't pour from the right. So, it must have at least the target amount. But if it has more than the target, it can't pour anything back, so it must exactly have the target.

Wait, that doesn't seem right. Let's look at the example in the problem.

In the third test case:

n = 5

a = [4, 5, 2, 1, 3]

Sum is 4+5+2+1+3 = 15, which is divisible by 5, so target = 3.

Now, according to the explanation, they perform the following operations:

1. Pour 1 unit from container 1 to container 4: a becomes [3,5,2,2,3]

2. Pour 1 unit from container 2 to container 3: a becomes [3,4,3,2,3]

3. Pour 1 unit from container 2 to container 4: a becomes [3,3,3,3,3]

So, it's possible to make all containers have 3 units.

Looking at this, container 1 had 4, which is more than 3, so it can pour 1 to container 4.

Container 2 had 5, which is more than 3, so it can pour 1 to container 3 and then 1 to container 4.

Container 3 had 2, which is less than 3, so it receives 1 from container 2.

Container 4 had 1, which is less than 3, so it receives 1 from container 1 and 1 from container 2.

Container 5 already had 3, so it doesn't need to receive or pour any.

This makes sense, but how can I generalize this?

Another way to think about it is to consider the cumulative sum up to each position and see if it meets or exceeds the required sum up to that position.

Let's define prefix_sum[i] as the sum of a[0] to a[i-1] (0-indexed).

The required prefix_sum[i] should be i*target.

At any point, if prefix_sum[i] < i*target, it means that we need to have poured some water from earlier containers to make up for this deficit. But since we can only pour forward, the earlier containers must have had excess to compensate.

Wait, but in the operation, we can pour from any earlier container to any later container, as long as i < j. It's not restricted to adjacent containers.

So, perhaps I need to ensure that for every position i, the sum of a[0] to a[i] is at least (i+1)*target.

Wait, no. Let's think carefully.

Actually, since we can pour water from any earlier container to any later container, as long as i < j, the order of pouring doesn't matter. The key is that any deficit in a later container can be compensated by any excess in earlier containers.

Given that, the necessary and sufficient condition is that the cumulative sum up to any point is at least the required sum up to that point.

Wait, maybe prefix_sum[i] >= (i+1)*target for all i from 0 to n-1.

Let's check this with the example.

For n=5, target=3.

prefix_sum[0] = 4 >= 3 (yes)

prefix_sum[1] = 4+5=9 >= 6 (yes)

prefix_sum[2] = 9+2=11 >= 9 (yes)

prefix_sum[3] = 11+1=12 >= 12 (yes)

prefix_sum[4] = 12+3=15 >= 15 (yes)

All conditions are satisfied, and indeed, it's possible to make all containers equal.

Another test case where it's not possible:

n=2, a=[1,3], target=2.

prefix_sum[0] = 1 >= 2? No.

So, according to this condition, since prefix_sum[0] < 2, it's not possible, which matches the sample output "NO".

Another test case:

n=3, a=[1,2,3], target=2.

prefix_sum[0] =1 >=2? No.

So, "NO", which matches the sample.

Another one:

n=7, a=[4,5,5,0,6,4,4], target=4.

prefix_sum[0]=4 >=4

prefix_sum[1]=4+5=9 >=8

prefix_sum[2]=9+5=14 >=12

prefix_sum[3]=14+0=14 >=16? No.

So, "NO", matches the sample.

Last one:

n=7, a=[6,5,5,1,3,4,4], target=4.

prefix_sum[0]=6 >=4

prefix_sum[1]=6+5=11 >=8

prefix_sum[2]=11+5=16 >=12

prefix_sum[3]=16+1=17 >=16

prefix_sum[4]=17+3=20 >=20

prefix_sum[5]=20+4=24 >=24

prefix_sum[6]=24+4=28 >=28

All conditions satisfied, so "YES", matches the sample.

So, this seems to be a correct condition: for all i from 0 to n-1, prefix_sum[i] >= (i+1)*target.

If this holds, then it's possible to make all containers equal; otherwise, not.

Now, looking at the given program, let's see what it's doing.

def func():

t = int(input())

for _ in range(t):

n = int(input())

nums = list(map(int, input().strip().split()))

last = nums[-1]

curr = 0

for i in nums:

if i != 0:

curr += i - last

if curr == 0:

print('YES')

else:

print('NO')

Hmm, this seems different from what I thought.

It's taking the last element, and then for each non-zero element in nums, it's adding (i - last) to curr, and then checking if curr == 0.

Wait, that doesn't seem to align with the condition I derived.

In my condition, I need to check that the prefix sum up to each position is at least (position+1)*target.

But in the code, it's computing curr as sum of (i - last) for all non-zero i in nums, and then checking if curr == 0.

This seems off.

Let me take the third test case:

n=5, nums=[4,5,2,1,3], target=3.

last = 3.

curr = (4-3) + (5-3) + (2-3) + (1-3) + (3-3) = 1 + 2 -1 -2 + 0 = 0.

So, it would print "YES", which is correct.

Another test case:

n=2, nums=[1,3], target=2.

last=3.

curr=(1-3) + (3-3) = -2 + 0 = -2 !=0, so "NO".

Correct.

n=3, nums=[1,2,3], target=2.

last=3.

curr=(1-3) + (2-3) + (3-3) = -2 -1 +0 = -3 !=0, so "NO".

Correct.

n=7, nums=[4,5,5,0,6,4,4], target=4.

last=4.

curr=(4-4) + (5-4) + (5-4) + (0-4) + (6-4) + (4-4) + (4-4) = 0 +1 +1 -4 +2 +0 +0 = 0.

But according to my earlier reasoning, it should be "NO" because prefix_sum[3]=14 < 16.

But here, curr=0, so it would print "YES", which contradicts the sample output "NO".

Wait, but according to the sample, it's "NO".

So, this seems incorrect.

Wait, in the sample input, for n=7, a=[4,5,5,0,6,4,4], it's "NO", but according to this code, curr=0, so it would print "YES", which is wrong.

Another test case: n=7, a=[6,5,5,1,3,4,4], target=4.

last=4.

curr=(6-4)+(5-4)+(5-4)+(1-4)+(3-4)+(4-4)+(4-4)=2+1+1-3-1+0+0=0.

And the sample output is "YES", which is correct.

So, this code is incorrect because in the case where it should output "NO", it outputs "YES".

Therefore, the given program is incorrect.

So, the correctness is False.

Wait, but in the first few test cases, it seems to work, but it fails in at least one case.

Hence, the program is incorrect.

## Final Solution
To solve this problem, we need to determine if it is possible to make the amount of water in each container equal by only pouring water from a container with a lower index to one with a higher index.

### Approach

1. **Understanding the Problem**:
    - We have `n` containers with initial amounts of water `a1, a2, ..., an`.
    - We can pour water from container `i` to container `j` only if `i < j`.
    - The total sum of water is divisible by `n`, so the target amount of water in each container is `sum(a)/n`.

2. **Key Insight**:
    - To achieve equal distribution, the cumulative sum of water up to any point should be at least the expected sum up to that point (i.e., `prefix_sum[i] >= target * (i+1)` for all `i`).
    - This ensures that we can compensate for any deficits in later containers using the excess in earlier containers.

3. **Algorithm**:
    - Calculate the target amount of water each container should have.
    - Compute the prefix sums and check if they meet or exceed the expected sums at each step.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        nums = list(map(int, input().strip().split()))
        target = sum(nums) // n
        prefix_sum = 0
        expected = 0
        possible = True
        for num in nums:
            prefix_sum += num
            expected += target
            if prefix_sum < expected:
                possible = False
                break
        print('YES' if possible else 'NO')

func()
```

### Explanation

1. **Reading Input**:
    - Read the number of test cases `t`.
    - For each test case, read the number of containers `n` and the list of water amounts `nums`.

2. **Calculating the Target**:
    - Compute the target amount of water each container should have: `target = sum(nums) // n`.

3. **Checking Cumulative Sums**:
    - Initialize `prefix_sum` and `expected` to 0.
    - Iterate through the containers, updating `prefix_sum` and `expected`.
    - If at any point `prefix_sum < expected`, it's impossible to equalize the water amounts, and we set `possible` to False and break.

4. **Output the Result**:
    - Print 'YES' if it's possible to equalize the water amounts, otherwise 'NO'.

This approach ensures that we are correctly checking the feasibility of equalizing the water amounts under the given constraints.