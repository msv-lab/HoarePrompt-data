Alright, I have this problem to solve. Let's read it carefully.

We have a contest with n problems. Each problem has an expected difficulty upper limit, given in array b, and the current difficulties of the problems are in array a. Both a and b are sorted in non-decreasing order.

We need to make sure that for every problem i, a_i ≤ b_i. If some a_i are greater than b_i, we need to add new problems with certain difficulties, sort the array a again, and remove the most difficult problem each time we add a new one.

The goal is to find the minimum number of new problems we need to add to satisfy the condition a_i ≤ b_i for all i.

Let's look at the example to understand better.

In the first test case:

n = 6

a = [1000, 1400, 2000, 2000, 2200, 2700]

b = [800, 1200, 1500, 1800, 2200, 3000]

We need to ensure that:

1000 ≤ 800 → No, 1400 ≤ 1200 → No, 2000 ≤ 1500 → No, 2000 ≤ 1800 → Yes, 2200 ≤ 2200 → Yes, 2700 ≤ 3000 → Yes.

So, the first three problems in a are greater than their corresponding b_i.

The solution says that by adding two new problems with difficulties 800 and 1800, we can achieve the desired condition.

Let's see:

First, add w=800:

a becomes [1000, 1400, 2000, 2000, 2200, 2700] + [800] → sorted: [800, 1000, 1400, 2000, 2000, 2200, 2700] → remove the last element: [800, 1000, 1400, 2000, 2000, 2200]

Now, check:

800 ≤ 800 → Yes, 1000 ≤ 1200 → Yes, 1400 ≤ 1500 → Yes, 2000 ≤ 1800 → No, 2000 ≤ 2200 → Yes, 2200 ≤ 3000 → Yes.

Still, one problem doesn't satisfy: 2000 > 1800.

So, add w=1800:

a becomes [800, 1000, 1400, 2000, 2000, 2200] + [1800] → sorted: [800, 1000, 1400, 1800, 2000, 2000, 2200] → remove the last element: [800, 1000, 1400, 1800, 2000, 2000]

Now, check:

800 ≤ 800 → Yes, 1000 ≤ 1200 → Yes, 1400 ≤ 1500 → Yes, 1800 ≤ 1800 → Yes, 2000 ≤ 2200 → Yes, 2000 ≤ 3000 → Yes.

All conditions are satisfied after adding two new problems.

Another test case:

n = 6

a = [4,5,6,7,8,9]

b = [1,2,3,4,5,6]

We need to make sure:

4 ≤ 1 → No, 5 ≤ 2 → No, 6 ≤ 3 → No, 7 ≤ 4 → No, 8 ≤ 5 → No, 9 ≤ 6 → No.

So, all problems in a are greater than their corresponding b_i.

The solution says to add three new problems with difficulties 1, 2, and 3.

First, add w=1:

a becomes [4,5,6,7,8,9] + [1] → sorted: [1,4,5,6,7,8,9] → remove the last element: [1,4,5,6,7,8]

Check:

1 ≤ 1 → Yes, 4 ≤ 2 → No, 5 ≤ 3 → No, 6 ≤ 4 → No, 7 ≤ 5 → No, 8 ≤ 6 → No.

Still not all satisfy.

Second, add w=2:

a becomes [1,4,5,6,7,8] + [2] → sorted: [1,2,4,5,6,7,8] → remove the last element: [1,2,4,5,6,7]

Check:

1 ≤ 1 → Yes, 2 ≤ 2 → Yes, 4 ≤ 3 → No, 5 ≤ 4 → No, 6 ≤ 5 → No, 7 ≤ 6 → No.

Still not all satisfy.

Third, add w=3:

a becomes [1,2,4,5,6,7] + [3] → sorted: [1,2,3,4,5,6,7] → remove the last element: [1,2,3,4,5,6]

Check:

1 ≤ 1 → Yes, 2 ≤ 2 → Yes, 3 ≤ 3 → Yes, 4 ≤ 4 → Yes, 5 ≤ 5 → Yes, 6 ≤ 6 → Yes.

All conditions are satisfied after adding three new problems.

From these examples, it seems that the strategy is to add new problems with difficulties equal to the expected difficulties in b, starting from the smallest.

But in the first test case, they added 800 and 1800, which are b_1 and b_4.

Wait, b is sorted, so b_1 is the smallest expected difficulty.

In the second test case, they added 1, 2, and 3, which are b_1, b_2, and b_3.

It seems like we need to add some b_j's until the condition is satisfied.

But it's not clear yet.

Let me think about the general approach.

We have two sorted arrays a and b, both of length n.

We need to ensure that a_i ≤ b_i for all i.

If a_i > b_i for some i, we need to add a new problem with some difficulty w, sort a and remove the largest element.

We need to find the minimum number of such additions.

I need to find an efficient way to determine how many times I need to add a new problem to satisfy the condition.

Let me consider the following approach:

Initialize a counter cnt to 0.

Use two pointers, i and j, starting from the beginning of a and b.

While both pointers are within their respective arrays:

If a[i] > b[j], it means we need to add a new problem to replace the largest a.

So, we add b[j], sort a, and remove the largest a.

Increment cnt.

Otherwise, move both pointers forward.

Continue until all elements are checked.

But I need to think about how to implement this without actually sorting the array each time, as it's inefficient for large n.

Wait, n is up to 100, so efficiency might not be a big issue, but still, I need a clear logic.

Let me think differently.

Since both a and b are sorted, I can iterate through them simultaneously.

I need to ensure that for each position i, a_i ≤ b_i.

If a_i > b_i, I need to add a new problem with difficulty ≤ b_i and remove the largest a.

Each time I add a new problem, I'm essentially replacing the largest a with something ≤ b_j for some j.

I need to minimize the number of such replacements.

This sounds like a greedy algorithm where I always add the smallest possible b_j to replace the largest a.

Let me try to formalize this.

Initialize cnt = 0.

While there exists an i where a_i > b_i:

Find the largest a_k in a.

Replace a_k with the smallest b_j that is ≥ a_k.

But wait, we can choose any w ≤ b_j, so perhaps choosing w = b_j is not necessary.

Wait, no. When we add a new problem with difficulty w, we insert it into a, sort a, and remove the largest element.

So, effectively, we're replacing the largest a with w.

But w can be any value ≤ some b_j.

But to minimize the number of additions, we should choose w as small as possible to replace the largest a.

Wait, but w has to be ≤ some b_j.

Wait, actually, w can be any value, but to satisfy a_i ≤ b_i, we should choose w ≤ b_j for some j.

But it's complicated.

Let me think of it in terms of the number of elements in a that are greater than their corresponding b_i.

Initially, find how many a_i > b_i.

This gives the number of problems that need to be replaced.

Since we can replace the largest a with a new problem w each time, and w can be chosen as ≤ some b_j, we need to choose w such that after sorting, a_i ≤ b_i.

Wait, perhaps it's better to count the number of a_i that are greater than b_i.

Let's define the number of a_i > b_i as k.

Then, we need to perform at least k operations to make a_i ≤ b_i for all i.

Because each operation allows us to replace the largest a with a new w.

So, for each operation, we can fix one a_i that was greater than b_i.

Hence, the minimum number of operations is equal to the number of a_i > b_i.

But wait, in the first example:

a = [1000,1400,2000,2000,2200,2700]

b = [800,1200,1500,1800,2200,3000]

Comparing:

1000 > 800 → No

1400 > 1200 → No

2000 > 1500 → No

2000 ≤ 1800 → No

2200 ≤ 2200 → Yes

2700 ≤ 3000 → Yes

Wait, in the comparison:

1000 > 800 → No (actually, 1000 > 800, so it's not satisfying a_i ≤ b_i)

Similarly, 1400 > 1200 → No

2000 > 1500 → No

2000 ≤ 1800 → Wait, 2000 > 1800 → No

2200 ≤ 2200 → Yes

2700 ≤ 3000 → Yes

So, actually, in this case, there are four a_i > b_i.

But in the solution, they only added two new problems.

This contradicts my earlier assumption that the number of operations is equal to the number of a_i > b_i.

Hmm, maybe I miscounted.

Wait, in the first test case, a_i > b_i for i=1,2,3,4.

Because:

1000 > 800

1400 > 1200

2000 > 1500

2000 > 1800

But the solution says only two additions are needed.

So, my assumption is incorrect.

I need a better approach.

Let me think in terms of matching a_i with b_j.

Since both arrays are sorted, I can use a two-pointer approach.

Initialize two pointers, i and j, starting from the beginning of a and b.

If a[i] ≤ b[j], move both pointers forward.

If a[i] > b[j], it means a[i] doesn't satisfy the condition, so I need to add a new problem.

By adding a new problem with difficulty w ≤ b[j], I can replace the largest a with this w.

After sorting and removing the largest a, the new a will have one less element, and I need to repeat the process.

But I need to keep track of the current state of a after each addition.

But since a is being modified each time, it's tricky to handle.

An alternative approach is to realize that each addition allows me to reduce the largest a to some w.

So, I need to reduce the largest a that don't satisfy a_i ≤ b_i.

But it's still unclear.

Let me consider the following plan:

- Find the number of a_i that are greater than b_i.

- This gives the minimum number of operations needed.

But as the first test case shows, there are four a_i > b_i, but only two additions are needed.

So, my initial plan is incorrect.

I need to think differently.

Let me consider that when I add a new problem with difficulty w, I'm effectively replacing the largest a with w.

So, I should prioritize replacing the largest a that don't satisfy a_i ≤ b_i.

I can iterate from the end of a and b, and count how many times a[i] > b[j].

Wait, since both arrays are sorted, I can use two pointers starting from the end.

Initialize i = n-1 and j = n-1.

While i >= 0 and j >= 0:

if a[i] > b[j]:

cnt +=1

i -=1

else:

i -=1

j -=1

This seems similar to merging two sorted arrays.

But in this approach, for the first test case:

a = [1000,1400,2000,2000,2200,2700]

b = [800,1200,1500,1800,2200,3000]

Start with i=5, j=5

a[5]=2700 > b[5]=3000 → cnt=1, i=4

a[4]=2200 > b[5]=3000 → cnt=2, i=3

a[3]=2000 > b[5]=3000 → cnt=3, i=2

a[2]=2000 > b[5]=3000 → cnt=4, i=1

a[1]=1400 > b[5]=3000 → cnt=5, i=0

a[0]=1000 > b[5]=3000 → cnt=6

This gives cnt=6, but the correct answer is 2.

So, this approach is wrong.

I need to adjust it.

Wait, perhaps I need to match the largest a with the largest b, and count how many a's are larger than b's at the same position.

But in the first test case, four a's are larger than their corresponding b's, but only two additions are needed.

So, maybe I need to consider that adding one new problem can fix multiple a's.

Wait, no. Each addition replaces the largest a with w, and w can be chosen optimally.

Wait, perhaps it's better to think in terms of the number of a's that are larger than the smallest b's.

Wait, I'm getting confused.

Let me look at the reference solution provided.

The reference solution is:

import math

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

b = list(map(int, input().split()))

cnt = 0

i = 0

j = 0

while i < n and j < n:

if b[j] < a[i]:

a.pop(-1)

a = a[:i] + [b[j]] + a[i+1:]

cnt +=1

j +=1

else:

i +=1

j +=1

print(cnt)

def func_1(arr):

return sorted(arr, reverse=True)

So, in this solution, they are iterating through a and b with two pointers.

If b[j] < a[i], it means that a[i] is too large, so they need to add a new problem with difficulty b[j], insert it into a, sort a, and remove the largest element.

Then, they increment cnt and move to the next b.

Otherwise, they move both pointers forward.

Finally, they print cnt.

Wait, but in the first test case, with n=6, a=[1000,1400,2000,2000,2200,2700], b=[800,1200,1500,1800,2200,3000]

Let's simulate this:

Initialize i=0, j=0, cnt=0

Compare b[j=0]=800 < a[i=0]=1000 → add b[j]=800, sort a, remove last element

a becomes [800,1000,1400,2000,2000,2200] → sorted: [800,1000,1400,2000,2000,2200] → remove 2200 → a=[800,1000,1400,2000,2000]

cnt=1, j=1

Now, i=0, j=1

Compare b[j=1]=1200 < a[i=0]=800 → No, since 1200 > 800 → move both pointers: i=1, j=2

Compare b[j=2]=1500 < a[i=1]=1000 → No, since 1500 > 1000 → move both pointers: i=2, j=3

Compare b[j=3]=1800 < a[i=2]=1400 → No, since 1800 > 1400 → move both pointers: i=3, j=4

Compare b[j=4]=2200 < a[i=3]=2000 → No, since 2200 > 2000 → move both pointers: i=4, j=5

Compare b[j=5]=3000 < a[i=4]=2000 → No, since 3000 > 2000 → move both pointers: i=5, j=6

End of loop, cnt=1

But according to the example, cnt should be 2.

Wait, perhaps I made a mistake in simulating.

Let's try again.

Initialize i=0, j=0, cnt=0

a=[1000,1400,2000,2000,2200,2700], b=[800,1200,1500,1800,2200,3000]

Compare b[j=0]=800 < a[i=0]=1000 → Yes

Add b[j]=800 to a, sort a, remove the last element

a becomes [800,1000,1400,2000,2000,2200,2700] → sorted: [800,1000,1400,2000,2000,2200,2700] → remove 2700 → a=[800,1000,1400,2000,2000,2200]

cnt=1, j=1

Now, i=0, j=1

Compare b[j=1]=1200 < a[i=0]=800 → No

Move both pointers: i=1, j=2

Compare b[j=2]=1500 < a[i=1]=1000 → Yes

Add b[j]=1500 to a, sort a, remove the last element

a becomes [800,1000,1400,1500,2000,2000,2200] → sorted: [800,1000,1400,1500,2000,2000,2200] → remove 2200 → a=[800,1000,1400,1500,2000,2000]

cnt=2, j=3

Now, i=2, j=3

Compare b[j=3]=1800 < a[i=2]=1400 → Yes

Add b[j]=1800 to a, sort a, remove the last element

a becomes [800,1000,1400,1500,1800,2000,2000] → sorted: [800,1000,1400,1500,1800,2000,2000] → remove 2000 → a=[800,1000,1400,1500,1800,2000]

cnt=3, j=4

Now, i=3, j=4

Compare b[j=4]=2200 < a[i=3]=1500 → Yes

Add b[j]=2200 to a, sort a, remove the last element

a becomes [800,1000,1400,1500,1800,2000,2200] → sorted: [800,1000,1400,1500,1800,2000,2200] → remove 2200 → a=[800,1000,1400,1500,1800,2000]

cnt=4, j=5

Now, i=4, j=5

Compare b[j=5]=3000 < a[i=4]=1800 → Yes

Add b[j]=3000 to a, sort a, remove the last element

a becomes [800,1000,1400,1500,1800,2000,3000] → sorted: [800,1000,1400,1500,1800,2000,3000] → remove 3000 → a=[800,1000,1400,1500,1800,2000]

cnt=5, j=6

End of loop.

But according to the example, cnt should be 2.

This suggests that the reference solution is incorrect.

Wait, perhaps I misread the reference solution.

Looking back at the reference solution:

while i < n and j < n:

if b[j] < a[i]:

a.pop(-1)

a = a[:i] + [b[j]] + a[i+1:]

cnt +=1

j +=1

else:

i +=1

j +=1

print(cnt)

In my simulation, I was adding b[j] at position i, but perhaps it's different.

Wait, in Python, a.pop(-1) removes the last element, then a = a[:i] + [b[j]] + a[i+1:]

This means that it's inserting b[j] at position i and removing the element at position i.

Wait, no.

a[:i] + [b[j]] + a[i+1:] means that it's replacing a[i] with b[j], not inserting.

Wait, a.pop(-1) removes the last element, then a = a[:i] + [b[j]] + a[i+1:]

So, it's replacing a[i] with b[j], and removing the last element.

Wait, but in my earlier simulation, I was inserting b[j] at position i, sorting, and removing the last element.

But according to the code, it's replacing a[i] with b[j], not inserting.

So, let's simulate again correctly.

Initialize i=0, j=0, cnt=0

a=[1000,1400,2000,2000,2200,2700], b=[800,1200,1500,1800,2200,3000]

Check b[j=0]=800 < a[i=0]=1000 → Yes

a.pop(-1) → a=[1000,1400,2000,2000,2200]

a = a[:0] + [800] + a[1:] → a=[800,1400,2000,2000,220