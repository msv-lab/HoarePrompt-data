Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign appears every a_i years. The signs have to occur sequentially, meaning that after the first sign appears, we start waiting for the second sign in the next year, and so on.

Okay, so I need to find out in which year all n signs will have occurred in this sequential manner.

Let me try to understand this with the first example provided:

Input:

6

3 2 4 5 9 18

Output:

36

According to the explanation:

- First sign in year 3

- Wait for the second sign starting from year 4

- Second sign occurs in year 4 (since 4 is a multiple of 2)

- Wait for the third sign starting from year 5

- Third sign occurs in year 8 (since 8 is a multiple of 4)

- Wait for the fourth sign starting from year 9

- Fourth sign occurs in year 10 (since 10 is a multiple of 5)

- Wait for the fifth sign starting from year 11

- Fifth sign occurs in year 18 (since 18 is a multiple of 9)

- Wait for the sixth sign starting from year 19

- Sixth sign occurs in year 36 (since 36 is a multiple of 18)

So, the final year is 36.

Alright, so the process is:

1. The first sign happens in year a_1.

2. For each subsequent sign, we find the smallest year greater than the previous sign's year where that sign occurs.

Wait, but in the example, for the second sign, it's in year 4, which is greater than 3, and 4 is a multiple of 2.

Similarly, for the third sign, it's in year 8, which is greater than 4, and 8 is a multiple of 4.

So, for each sign i from 2 to n, find the smallest year that is greater than the year of the previous sign and is a multiple of a_i.

That makes sense.

So, generalizing, if the year of the (i-1)-th sign is y, then the year of the i-th sign is the smallest year >= y + 1 that is a multiple of a_i.

How do I find that smallest year >= y + 1 that is a multiple of a_i?

Well, to find the smallest multiple of a_i that is greater than or equal to y + 1, I can use the formula:

next_year = ((y + 1 + a_i - 1) // a_i) * a_i

This is a standard way to find the smallest multiple of a number that is greater than or equal to a given value.

Let me verify this with the first example:

First sign: y = 3

For second sign: a_i = 2

next_year = ((3 + 1 + 2 - 1) // 2) * 2 = (5 // 2) * 2 = 2 * 2 = 4

Yes, that's correct.

Then, y = 4

For third sign: a_i = 4

next_year = ((4 + 1 + 4 - 1) // 4) * 4 = (8 // 4) * 4 = 2 * 4 = 8

Correct again.

And so on for the rest of the signs.

So, the algorithm is:

- Initialize y as a_1

- For each subsequent sign from 2 to n:

- Calculate next_year = ((y + 1 + a_i - 1) // a_i) * a_i

- Set y = next_year

- The final y is the year when the nth sign occurs.

Now, looking at the code provided:

if __name__ == '__main__':

func_1()

def func_1():

import sys

input = sys.stdin.read

data = input().split()

index = 0

T = int(data[index])

index += 1

results = []

for _ in range(T):

n = int(data[index])

index += 1

a = list(map(int, data[index:index + n]))

index += n

last_year = a[0]

for i in range(1, n):

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

last_year = next_year

results.append(str(last_year))

sys.stdout.write('\n'.join(results) + '\n')

This seems to match the algorithm I just described.

It reads the input, processes each test case one by one, and for each test case, it iterates through the signs, calculating the next year for each sign based on the previous one using the formula we derived.

Let me check it with another example from the input:

Input:

5

1 2 3 4 5

Output:

5

Let's see:

First sign: year 1

Second sign: smallest year >= 2 that is a multiple of 2 → year 2

Third sign: smallest year >= 3 that is a multiple of 3 → year 3

Fourth sign: smallest year >= 4 that is a multiple of 4 → year 4

Fifth sign: smallest year >= 5 that is a multiple of 5 → year 5

So, the final year is 5.

Another input:

5

1 1 1 1 1

Output:

5

First sign: year 1

Second sign: smallest year >= 2 that is a multiple of 1 → year 2

Third sign: smallest year >= 3 that is a multiple of 1 → year 3

Fourth sign: smallest year >= 4 that is a multiple of 1 → year 4

Fifth sign: smallest year >= 5 that is a multiple of 1 → year 5

So, the final year is 5.

Last input:

6

50 30 711 200 503 1006

Output:

2012

Let's verify:

First sign: year 50

Second sign: smallest year >= 51 that is a multiple of 30

next_year = ((50 + 1 + 30 - 1) // 30) * 30 = (80 // 30) * 30 = 2 * 30 = 60

Third sign: smallest year >= 61 that is a multiple of 711

next_year = ((60 + 1 + 711 - 1) // 711) * 711 = (771 // 711) * 711 = 2 * 711 = 1422

Wait, but the output is 2012, so maybe I'm misunderstanding something.

Wait, perhaps I need to double-check the calculation.

Wait, 50 + 1 = 51

next_year for second sign: ((51 + 30 - 1) // 30) * 30 = (80 // 30) * 30 = 2 * 30 = 60

Then, third sign: ((60 + 1 + 711 - 1) // 711) * 711 = (771 // 711) * 711 = 2 * 711 = 1422

But the output is 2012, which doesn't match. So maybe there's a mistake in the code or in my understanding.

Wait, perhaps I need to look back at the problem statement.

"the i -th sign occurs every a_i years (in years a_i , 2 \cdot a_i , 3 \cdot a_i , \dots )"

So, the signs occur in years that are multiples of a_i.

And the waiting starts from the year after the previous sign.

So, in the last example:

First sign: year 50

Second sign: next multiple of 30 after 50 → 60

Third sign: next multiple of 711 after 60 → 711

Fourth sign: next multiple of 200 after 711 → 800

Fifth sign: next multiple of 503 after 800 → 1006

Sixth sign: next multiple of 1006 after 1006 → 1006

Wait, but 1006 is already a multiple of 1006, so no waiting is needed.

So, the final year is 1006.

But the output is 2012. So perhaps I'm missing something.

Wait, maybe I need to consider that the signs must occur sequentially, meaning that each sign must occur strictly after the previous one.

So, for the third sign: next multiple of 711 after 60 is 711.

Fourth sign: next multiple of 200 after 711 → 800

Fifth sign: next multiple of 503 after 800 → 1006

Sixth sign: next multiple of 1006 after 1006 → 2012

Ah, I see. So, the sixth sign occurs in year 2012, which is the next multiple of 1006 after 1006.

That makes sense now.

So, the code seems to be correctly implementing this logic.

Therefore, I can conclude that the given program is correct.

**Final Answer**

\[ \boxed{2012} \]