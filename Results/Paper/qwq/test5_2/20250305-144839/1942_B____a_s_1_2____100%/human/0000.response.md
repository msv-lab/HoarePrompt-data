Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct p from a.

First, I need to understand what MEX is. MEX stands for "minimum excluded," which means for a set of numbers, it's the smallest non-negative integer not present in that set. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the list. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that a valid p always exists for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. That's important.

I need to find p such that for each i, a_i = MEX(p_1 to p_i) - p_i.

Let me try to find a way to compute p_i from a_i and the MEX.

From the equation, p_i = MEX(p_1 to p_i) - a_i.

So, if I can find MEX(p_1 to p_i), I can compute p_i.

But MEX depends on the values of p_1 to p_i, which are partially known.

This seems a bit circular. Maybe I need to find a way to compute MEX incrementally as I build p.

Let me consider building p from the end to the beginning, since the MEX for a_i depends on the prefix up to i.

Wait, the MEX is defined for p_1 to p_i, so it's a prefix.

If I build p from the start to the end, maintaining the MEX as I go, it might be manageable.

But let's look at the first example to get some intuition.

In the first test case:

n = 5

a = [1, 1, -2, 1, 2]

And the corresponding p is [0,1,4,2,3]

Let's verify:

For i=1:

MEX(p1) = MEX(0) = 1

a1 = 1 - 0 = 1, which matches.

i=2:

MEX(0,1) = 2 - 1 = 1, matches.

i=3:

MEX(0,1,4) = 2 - 4 = -2, matches.

i=4:

MEX(0,1,4,2) = 3 - 2 = 1, matches.

i=5:

MEX(0,1,4,2,3) = 5 - 3 = 2, matches.

Okay, that makes sense.

Now, how to generalize this.

I need to find p_i such that a_i = MEX(p_1 to p_i) - p_i.

Rearranged, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

This seems tricky because MEX depends on the entire prefix.

Maybe I can keep track of which numbers have been used in p so far, and determine the MEX accordingly.

Wait, but maintaining MEX for each prefix could be inefficient if n is large, since n can be up to 2e5.

I need a more efficient way.

Let me think differently.

Suppose I iterate from the end to the beginning.

Let me consider i from n to 1.

At position i, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

Wait, but if I'm iterating from the end, I know p_{i+1} to p_n.

But that might not help directly.

Wait, maybe I can think of MEX(p_1 to p_i) as the MEX of the prefix up to i.

Let me try to find a way to compute MEX incrementally.

Alternatively, perhaps I can keep track of the available numbers that haven't been used in p yet.

Let me consider that.

Initialize a set with numbers from 0 to n-1.

As I assign p_i, I remove that number from the set.

At any point, the MEX of p_1 to p_i is the smallest number in the set that is not in p_1 to p_i.

Wait, but that's still not directly helpful.

Let me see if there's a way to compute p_i directly.

Looking back at the formula: p_i = MEX(p_1 to p_i) - a_i.

I need to find p_i such that this holds.

But MEX(p_1 to p_i) is the smallest missing number up to i.

This seems recursive, as MEX depends on previous p's.

This is getting complicated.

Maybe I can look for patterns or properties.

Let me consider small n.

Take n=1.

Then p has only one element, 0.

a1 = MEX(p1) - p1 = MEX(0) - 0 = 1 - 0 = 1.

So a=[1].

Yes, that makes sense.

Another small case, n=2.

Possible p: [0,1]

a1 = MEX(0) - 0 = 1 - 0 = 1

a2 = MEX(0,1) - 1 = 2 - 1 = 1

So a=[1,1]

Alternatively, p=[1,0]

a1 = MEX(1) - 1 = 0 - 1 = -1

a2 = MEX(1,0) - 0 = 2 - 0 = 2

So a=[-1,2]

So for n=2, possible a's are [1,1] or [-1,2]

Now, given a, I need to find p.

Let me try to reconstruct p from a.

Take a=[1,1]

Then p1 = MEX(p1) - a1 => p1 = MEX(p1) -1

But MEX(p1) is the smallest non-negative integer not in p1.

Wait, p1 is a single number, so MEX(p1) is the smallest non-negative integer not equal to p1.

If p1 = x, then MEX(p1) = 0 if x !=0, else 1.

Wait, if p1 =0, then MEX(p1)=1

If p1=1, then MEX(p1)=0

So a1 =1 if p1=0

a1=-1 if p1=1

Similarly, for p2:

If p1=0, then p2 can be 1.

a2 = MEX(p1,p2) - p2 = MEX(0,1)=2 -1=1

Or if p1=1, p2=0.

a2 = MEX(1,0)=2 -0=2

So a=[-1,2]

This seems consistent with earlier.

Now, for n=3.

Possible p: [0,1,2]

a1=1, a2=1, a3=1

Or p=[0,1,3], but n=3, wait, numbers from 0 to n-1.

Wait, n=3, p=[0,1,2]

a1=1, a2=1, a3=1

Or p=[0,2,1]

a1=1, a2=2-2=0, a3=2-1=1

Wait, n=3, p=[0,2,1]

a1=1, a2=0, a3=1

Another p: [1,0,2]

a1=0-1=-1, a2=2-0=2, a3=3-2=1

Or p=[1,2,0]

a1=0-1=-1, a2=1-2=-1, a3=3-0=3

p=[2,0,1]

a1=0-2=-2, a2=1-0=1, a3=2-1=1

So possible a's for n=3 are:

[1,1,1]

[1,0,1]

[-1,2,1]

[-1,-1,1]

[-2,1,1]

So, given a, I need to find one p that satisfies.

Now, how to generalize this.

Looking at the program provided:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

p = [-1] * n

mex = n

for i in range(n-1, -1, -1):

p[i] = mex - a[i]

mex = min(mex, p[i])

print(*p)

So, it initializes p as a list of -1's, and mex as n.

Then, iterates from i=n-1 to 0:

p[i] = mex - a[i]

Then, mex = min(mex, p[i])

Finally, prints p.

Wait, is this correct?

Let me verify with the first test case.

n=5

a=[1,1,-2,1,2]

According to the code:

Initialize p=[-1,-1,-1,-1,-1], mex=5

i=4:

p[4]=5 - 2=3, mex=min(5,3)=3

i=3:

p[3]=3 -1=2, mex=min(3,2)=2

i=2:

p[2]=2 - (-2)=4, mex=min(2,4)=2

i=1:

p[1]=2 -1=1, mex=min(2,1)=1

i=0:

p[0]=1 -1=0, mex=min(1,0)=0

So p=[0,1,4,2,3], which matches the first example.

Another test case:

n=5

a=[1,1,1,1,1]

p=[0,1,2,3,4]

Check:

i=4:

p[4]=5-1=4, mex=min(5,4)=4

i=3:

p[3]=4-1=3, mex=min(4,3)=3

i=2:

p[2]=3-1=2, mex=min(3,2)=2

i=1:

p[1]=2-1=1, mex=min(2,1)=1

i=0:

p[0]=1-1=0, mex=min(1,0)=0

So p=[0,1,2,3,4], which matches the second example.

Third test case:

n=3

a=[-2,1,2]

p=[-1,-1,-1], mex=3

i=2:

p[2]=3-2=1, mex=min(3,1)=1

i=1:

p[1]=1-1=0, mex=min(1,0)=0

i=0:

p[0]=0 - (-2)=2, mex=min(0,2)=0

So p=[2,0,1], which matches the third example.

Okay, so the code seems to produce the correct p for the given a in the examples.

But is this algorithm correct in general?

Let me try to understand the logic.

The code sets p[i] = mex - a[i], and then updates mex to min(mex, p[i])

In the first iteration, mex is n, so p[n-1] = n - a[n-1]

Then, mex becomes min(mex, p[n-1])

In the next iteration, p[n-2] = mex - a[n-2], and mex becomes min(mex, p[n-2])

And so on.

I need to see if this correctly computes p such that a_i = MEX(p1 to pi) - p_i

Let me think about what MEX(p1 to pi) represents.

It's the smallest non-negative integer not present in p1 to pi.

Now, in the code, mex seems to be decreasing as we iterate backwards.

Wait, in the first iteration, mex is n, which is larger than any p_i since p_i are from 0 to n-1.

Then p[n-1] = n - a[n-1]

Depending on a[n-1], p[n-1] could be within 0 to n-1.

Then, mex is updated to min(mex, p[n-1])

Since p[n-1] could be less than n, mex is now p[n-1]

Then, for the next iteration, p[n-2] = mex - a[n-2]

Which is p[n-1] - a[n-2]

Wait, this seems arbitrary.

I need to see why this works.

Let me consider that at each step, mex is the current MEX of p1 to pi.

But in the code, mex is being updated to min(mex, p[i])

Wait, that doesn't make immediate sense to me.

Let me think differently.

Suppose I have p1 to pi, and I need a_i = MEX(p1 to pi) - p_i

Then, MEX(p1 to pi) = a_i + p_i

So, MEX(p1 to pi) is determined by a_i and p_i.

But I don't know p_i yet.

Wait, in the code, it's setting p[i] = mex - a[i], which seems consistent with this.

Because if MEX(p1 to pi) = a_i + p_i, then p_i = MEX(p1 to pi) - a_i

So, p_i = mex - a[i], assuming that mex is indeed MEX(p1 to pi)

But how does the code ensure that mex is the correct MEX for p1 to pi?

In the code, mex is initialized to n, and then updated to min(mex, p[i]) in each step.

Wait, is mex being maintained as the current MEX for p1 to pi?

Let's see.

Starting from the end, p[n-1] = n - a[n-1]

Then mex = min(mex, p[n-1])

For p[n-2], p[n-2] = mex - a[n-2], and then mex = min(mex, p[n-2])

And so on.

I need to see if this maintains the correct MEX for each prefix.

Let me consider that at each step, mex is the MEX of p1 to pi for the current i.

But in the code, mex seems to be decreasing as we go backwards.

Wait, maybe it's maintaining the MEX correctly.

Let me consider that in the last step, p[n-1] is set to n - a[n-1]

Since for i=n, MEX(p1 to pn) is n, because p1 to pn contain all numbers from 0 to n-1.

So, MEX(p1 to pn) = n

Thus, p[n-1] = n - a[n-1]

Then, for i=n-1, MEX(p1 to p_{n-1}) is the smallest number not in p1 to p_{n-1}

Which is min(mex, p[n-1])

Wait, no.

I'm getting confused.

Let me try to think of it differently.

Suppose I have p1 to pi, and I need to ensure that MEX(p1 to pi) = a_i + p_i

But p_i is what I'm trying to find.

Wait, perhaps I can look at the properties of MEX.

MEX(p1 to pi) is the smallest non-negative integer not in p1 to pi.

So, for p1 to pi, the numbers present are p1 to pi, and the MEX is the smallest missing one.

Given that, a_i = MEX(p1 to pi) - p_i

So, p_i = MEX(p1 to pi) - a_i

Now, in the code, it's setting p[i] = mex - a[i], and then mex = min(mex, p[i])

Is this maintaining the correct MEX for each prefix?

Let me consider the sequence of operations.

Start with mex = n

Set p[n-1] = n - a[n-1]

Then mex = min(mex, p[n-1])

Now, for i=n-2, set p[n-2] = mex - a[n-2]

Then mex = min(mex, p[n-2])

And so on.

I need to see if, at each step, mex correctly represents MEX(p1 to pi)

Wait, maybe I can look at it in reverse.

Suppose I have p fully constructed, then for each i, MEX(p1 to pi) is some value, and a_i is defined as MEX(p1 to pi) - p_i

Now, the code is trying to reconstruct p from a.

It's using the fact that p_i = MEX(p1 to pi) - a_i

And it's maintaining mex as some value that should represent MEX(p1 to pi)

But I need to verify if this algorithm correctly maintains the correct MEX for each prefix.

Alternatively, maybe there's a smarter way to see that this works.

Given that the problem states that a valid p always exists for the given a, I don't have to worry about invalid inputs.

Also, in the examples, the code produces the correct p.

So, perhaps this algorithm is correct.

But I need to be sure.

Let me consider another small test case.

Take n=3, a=[0,0,0]

What should p be?

If a=[0,0,0], then:

p1 = MEX(p1) - a1 => p1 = MEX(p1) - 0 => p1 = MEX(p1)

If p1=0, MEX(p1)=1, but 1 != 0, so not possible.

If p1=1, MEX(p1)=0, 0=0, so p1=1 is possible.

Then, p2 = MEX(p1,p2) - a2

p2 = MEX(1,p2) - 0 => p2 = (0 if p2 !=0 else 2) - 0

If p2=0, MEX(1,0)=2, so p2=2-0=2

If p2=2, MEX(1,2)=0, so p2=0-0=0

But p2 can't be both 0 and 2.

Wait, this seems conflicting.

Wait, if p2=0, then MEX(1,0)=2, so p2=2-0=2, which contradicts p2=0

If p2=2, then MEX(1,2)=0, so p2=0-0=0, again contradicting p2=2

So, no solution, but the problem says that a valid p always exists for the given a.

Wait, maybe a=[0,0,0] is not a valid a.

But according to the problem, it's guaranteed that at least one valid p exists for the given a.

So, perhaps a=[0,0,0] is not possible, hence I don't need to worry about it.

Wait, but in the problem statement, it's guaranteed that a valid p exists for the given a.

So, I can assume that a is such that at least one p satisfies the condition.

Therefore, I don't need to handle cases where no p exists.

Now, going back to the algorithm.

The code seems to work correctly for the provided examples.

It computes p[i] = mex - a[i], and then updates mex to min(mex, p[i])

Given that, and that a valid p exists, this algorithm produces a valid p.

Therefore, I can conclude that the given program is correct.

**Final Answer**

\[ \boxed{\text{Yes}} \]

