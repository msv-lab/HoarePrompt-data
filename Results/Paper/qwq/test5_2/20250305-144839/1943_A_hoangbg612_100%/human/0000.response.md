Alright, I have this problem to solve. It involves a game between Alice and Bob on an array of integers, and I need to determine the final score of the game based on their optimal plays. The score is defined as the MEX of the array that Alice constructs.

First, let's understand what MEX means. MEX of an array is the smallest non-negative integer not present in the array. For example, for [2,2,1], MEX is 0; for [3,1,0,1], it's 2; and for [0,3,1,2], it's 4.

Now, the game is played in turns, with Alice starting first. On Alice's turn, she picks an element from the array a, appends it to her array c, and deletes it from a. Bob, on his turn, picks an element from a, and deletes it from a. The game ends when a is empty, and the score is the MEX of c.

Alice wants to maximize the MEX, while Bob wants to minimize it. Both play optimally, meaning they make the best possible moves to achieve their goals.

Given that, I need to find out what the final MEX will be when both play optimally.

Let's consider the example provided:

Test case 1:

n = 4

a = [0,0,1,1]

A possible game is:

- Alice picks 1 → a=[0,0,1], c=[1]

- Bob picks 0 → a=[0,1], c=[1]

- Alice picks 0 → a=[1], c=[1,0]

- Bob picks 1 → a=[], c=[1,0]

MEX of c is 2.

Is this the optimal outcome?

Let's see if Alice can force a higher MEX or if Bob can force a lower MEX.

Another possible game:

- Alice picks 0 → a=[0,1,1], c=[0]

- Bob picks 0 → a=[1,1], c=[0]

- Alice picks 1 → a=[1], c=[0,1]

- Bob picks 1 → a=[], c=[0,1]

MEX is 2 again.

Another one:

- Alice picks 1 → a=[0,0,1], c=[1]

- Bob picks 1 → a=[0,0], c=[1]

- Alice picks 0 → a=[0], c=[1,0]

- Bob picks 0 → a=[], c=[1,0]

MEX is 2.

It seems like MEX 2 is the best Alice can achieve, given Bob's opposition.

Test case 2:

n = 4

a = [0,1,2,3]

Possible game:

- Alice picks 0 → a=[1,2,3], c=[0]

- Bob picks 1 → a=[2,3], c=[0]

- Alice picks 2 → a=[3], c=[0,2]

- Bob picks 3 → a=[], c=[0,2]

MEX is 1.

Another possible game:

- Alice picks 1 → a=[0,2,3], c=[1]

- Bob picks 0 → a=[2,3], c=[1,0]

- Alice picks 2 → a=[3], c=[1,0,2]

- Bob picks 3 → a=[], c=[1,0,2,3]

MEX is 4.

Wait, but Bob wants to minimize the MEX. So in this case, he would prefer the first scenario where MEX is 1.

How can Bob force MEX to be 1?

He can do that by picking elements in such a way that Alice is forced to have at least one number missing in her array c.

In this case, if Bob picks 1 and 3, leaving Alice with 0 and 2, then c=[1,0,2,3], MEX=4, which is not what Bob wants.

Wait, maybe I need to think differently.

Wait, actually, in the second scenario, Alice ends up with c=[1,0,2,3], MEX=4, which is higher than in the first scenario.

But Bob's goal is to minimize MEX, so he would prefer the first scenario where MEX is 1.

But how does he force that?

If Bob picks 1 and 3, then Alice picks 0 and 2, c=[1,0,2,3], MEX=4.

If Bob picks 0 and 2, then Alice picks 1 and 3, c=[1,3], MEX=0.

Wait, that's worse for Bob.

Wait, in that case, MEX would be 0, which is even lower.

Wait, but according to the output, it's 1.

Wait, perhaps I'm missing something.

Wait, in the second test case, the output is 1.

But in the scenario where Bob picks 0 and 2, c=[1,3], MEX is 0.

But that's lower than 1, which is not what Bob wants.

So, perhaps Bob cannot force MEX to be 1 in this case.

Wait, perhaps I misread the example output.

Wait, the second test case output is 1, but in the scenario where Bob picks 0 and 2, MEX is 0, which is lower than 1.

So perhaps Bob cannot force MEX to be 1, but Alice can force MEX to be at least 1.

Wait, perhaps the optimal play leads to MEX=1.

Wait, I need to think differently.

Maybe I should think in terms of who has the control over which numbers end up in c.

Alice picks numbers to include in c, Bob picks numbers to exclude from c.

Alice wants to maximize MEX, which means she wants to have as many small integers as possible in c.

Bob wants to minimize MEX, which means he wants to prevent Alice from having small integers in c.

So, Bob will try to force Alice to pick larger numbers or duplicates in a way that skips some small integers.

I need to find a strategy for both players.

Let's consider that in each turn, Alice chooses a number to add to c, and Bob chooses a number to remove from a.

They alternate turns until a is empty.

I need to find the final MEX of c when both play optimally.

Let me consider the frequency of each number.

Let's count the frequency of each number in a.

Let's sort the unique numbers in a.

Then, for each number from 0 to some maximum, check if it's possible to have it in c.

Wait, but it's not that simple because of the turns.

Wait, perhaps I can think in terms of the number of times each number appears.

If a number appears only once, then Alice can choose to pick it or Bob can choose to delete it.

If a number appears multiple times, Alice can choose to pick some instances and Bob can delete others.

I need to model this.

Let me try to think of it in terms of the frequency of each number.

Let me consider the frequency of each number in a.

For each number x, if it appears f(x) times, then Alice and Bob will have f(x) chances to pick or delete it.

Since Alice picks first, she can choose to pick one of the f(x) instances, and Bob can delete another, and so on.

So, for each number x, the net number of times it ends up in c is ceil(f(x)/2).

Because for every pair, Bob can delete one, and Alice can pick one.

If f(x) is odd, Alice can pick the last one.

Wait, is that correct?

Wait, let's see:

If f(x) = 1:

- Alice can pick it, or Bob can delete it.

- If Alice picks it, it goes to c.

- If Bob deletes it, it doesn't go to c.

- So, Alice can choose to have it in c if she picks it.

- But Bob can choose to delete it.

- So, Alice can have it in c only if she picks it before Bob deletes it.

Wait, but the turns alternate, and they delete one element per turn.

This might be more complicated.

Wait, perhaps I need to think in terms of the total number of elements.

Total elements is n.

Total turns is n, alternating between Alice and Bob.

Alice starts first.

So, Alice gets to pick n//2 elements to add to c (rounded up if n is odd).

Wait, no.

Wait, in each of her turns, she picks one element to add to c and deletes it from a.

Bob, in his turn, picks one element to delete from a.

So, in total, per turn:

- Alice: pick one to add to c and delete from a.

- Bob: pick one to delete from a.

So, in total, after all turns, a is empty, and c contains Alice's picks.

Wait, no.

Wait, in each turn:

- Alice picks one from a, adds it to c, and deletes it from a.

- Bob picks one from a, deletes it from a.

So, for each pair of turns (Alice and Bob), two elements are deleted from a: one goes to c, one is deleted.

If n is even, there are n/2 such pairs.

If n is odd, there are n//2 pairs and one extra turn for Alice.

So, in total, the number of elements Alice adds to c is:

- If n is even: n/2

- If n is odd: n/2 + 0.5, which is (n+1)//2

Wait, more precisely:

Total elements in c: number of times Alice picks.

Total turns: n, since each turn deletes one element.

Alice picks on her turns, which are turns 1,3,5,... up to n.

So, if n is even, Alice picks n/2 elements.

If n is odd, Alice picks (n+1)/2 elements.

Because she picks on every odd-numbered turn.

Wait, turn 1: Alice picks 1 element for c.

Turn 2: Bob deletes 1 element.

Turn 3: Alice picks 1 element for c.

Turn 4: Bob deletes 1 element.

...

So, for even n, Alice picks n/2 elements.

For odd n, Alice picks (n+1)/2 elements.

Wait, but in reality, since a is being modified, it's not just a matter of counting turns, but also considering which elements are left at each turn.

This seems more involved.

Perhaps I should think in terms of the frequency of each number and who can control their inclusion in c.

Let me try to think differently.

Let's consider the frequency of each number x in a.

If x appears f(x) times.

Alice wants x in c as much as possible, Bob wants to prevent it.

Given that, for each x, the number of times x ends up in c depends on the choices of Alice and Bob.

Wait, perhaps I can think in terms of the minimal excluded integer based on the possible choices.

But this seems too vague.

Let me look at small examples to see a pattern.

Example 1:

n=4

a=[0,0,1,1]

Possible c=[1,0] → MEX=2

Another c=[1,0,1] → MEX=2 (since 1 is repeated)

Wait, but in the first scenario, c=[1,0], MEX=2

In the second scenario, c=[1,0,1], MEX=2 (since 1 is repeated, but 2 is still the MEX)

Another possible c=[0,1], MEX=2

Seems like MEX=2 is achievable.

Is it possible to achieve MEX=3?

That would require c to contain 0,1,2.

But 2 is not in a, so MEX=3 is impossible.

Wait, in this case, 2 is not in a, so MEX cannot be 3.

Wait, but MEX is the smallest missing, so since 2 is not in a, it cannot be in c, so MEX=2.

Wait, but according to the game, MEX=2 is achievable.

So, in this case, the answer is 2.

Example 2:

n=4

a=[0,1,2,3]

Possible c=[0,1,2,3], MEX=4

Another c=[0,1,2], MEX=3

Another c=[0,1,3], MEX=2

Another c=[0,2,3], MEX=1

Another c=[1,2,3], MEX=0

Bob wants to minimize MEX, so he would prefer MEX=0, but Alice wants to maximize it.

So, in this case, what is the optimal MEX?

According to the output, it's 1.

Wait, but in the output, it's 1.

Wait, perhaps I miscounted.

Wait, in the output, for this test case, it's 1.

Wait, but in my earlier thought, if c=[0,2,3], MEX=1, which is what Bob wants.

But Alice could aim for higher MEX.

But Bob can force MEX to be 1.

How?

Perhaps by deleting elements in a way that forces Alice to have a missing number.

Wait, perhaps I need to think in terms of the number of available copies of each number.

Let me try to think of a general strategy.

Let me consider that Alice wants as many small numbers as possible in c, and Bob wants to prevent that.

So, for each number x, starting from 0 upwards, Alice wants to include x in c if possible, and Bob wants to prevent it.

So, for x=0, Alice wants to include 0 in c, Bob wants to prevent it.

Similarly for x=1, and so on.

So, perhaps I can iterate through x from 0 to some maximum, and decide if Alice can include x in c or not, given Bob's opposition.

Let me try to formalize this.

Let me sort the unique numbers in a and count their frequencies.

Then, for each x starting from 0 upwards, check if Alice can include x in c.

To include x in c, Alice needs to pick x before Bob deletes all copies of x.

Given that, the number of times x can be included in c is ceil(f(x)/2), because for every two copies, Bob can delete one, and Alice can pick one.

If f(x) is odd, Alice can pick the last one.

So, the number of times x can be included in c is ceil(f(x)/2).

But since c can only contain one instance of x (as it's just a list of numbers, not necessarily unique), we can consider if ceil(f(x)/2) >=1, then x can be in c.

Wait, but actually, c can contain multiple instances of x, but for MEX, we only care about the presence of x, not the number of copies.

So, for MEX, we just need to know if x is in c or not.

So, for each x, if ceil(f(x)/2) >=1, then x is in c.

Otherwise, x is not in c.

But Bob can try to prevent x from being in c.

Wait, but according to this, if f(x) >=1, then ceil(f(x)/2) >=1, so x is in c.

But that can't be right, because in the second test case, with a=[0,1,2,3], n=4, the output is 1, meaning c=[0,1,2], MEX=3, but according to this, all x from 0 to 3 have f(x)=1, so ceil(1/2)=0.5, which is less than 1, so x not in c.

Wait, that doesn't make sense.

Wait, ceil(1/2)=1, because ceil(0.5)=1.

So, according to this, x is in c if ceil(f(x)/2) >=1.

But in the second test case, f(x)=1 for x=0,1,2,3.

So, ceil(1/2)=1 >=1, so all x are in c, which would make MEX=4.

But the output is 1, so this logic is flawed.

Wait, perhaps I need to consider the turns.

Wait, perhaps the order in which elements are picked matters.

Because Bob can choose to delete elements that Alice wants.

Wait, perhaps I need to consider the total number of elements Alice can pick and see which x's she can include in c.

Let me think differently.

Let me sort the unique elements in a.

Let me try to include as many small x's as possible in c.

Alice wants to include small x's, Bob wants to prevent it.

So, for each x, starting from 0 upwards, check if Alice can include x in c.

To include x in c, Alice needs to pick at least ceil(f(x)/2) elements to ensure that at least one remains in c.

Wait, perhaps I need to think in terms of the number of times Alice can pick x compared to Bob deleting it.

Wait, perhaps it's better to think in terms of the total number of elements Alice can pick.

Total elements Alice picks:

- If n is even: n/2

- If n is odd: (n+1)/2

In the second test case, n=4, which is even, so Alice picks 2 elements.

So, c has 2 elements.

In this case, to achieve MEX=1, c must contain 0 but not 1.

But according to the output, it's 1, which means c must be missing 1.

Wait, but in this case, c has only 2 elements.

If c contains 0 and 1, MEX=2.

If c contains 0 and 2, MEX=1.

If c contains 0 and 3, MEX=1.

If c contains 1 and 2, MEX=0.

If c contains 1 and 3, MEX=0.

If c contains 2 and 3, MEX=0.

So, to achieve MEX=1, c must contain 0 and either 2 or 3.

Bob can force this by deleting 1.

Wait, but how does Bob delete 1?

Let's simulate:

Turn 1: Alice picks 0 → c=[0], a=[1,2,3]

Turn 2: Bob deletes 1 → a=[2,3]

Turn 3: Alice picks 2 → c=[0,2], a=[3]

Turn 4: Bob deletes 3 → a=[]

Final c=[0,2], MEX=1.

Alternatively:

Turn 1: Alice picks 1 → c=[1], a=[0,2,3]

Turn 2: Bob deletes 0 → a=[2,3]

Turn 3: Alice picks 2 → c=[1,2], a=[3]

Turn 4: Bob deletes 3 → a=[]

Final c=[1,2], MEX=0.

Wait, but according to the output, it's 1.

So, perhaps Bob cannot always force MEX=0.

Wait, in the first scenario, MEX=1, in the second, MEX=0.

So, the minimal MEX Bob can force is 0, but according to the output, it's 1.

Wait, perhaps I'm missing something.

Wait, maybe I need to consider that Alice can choose which elements to pick, and Bob chooses which to delete, but Alice goes first.

Wait, perhaps I need to think in terms of the number of times Alice can pick an element before Bob can delete it.

Wait, maybe I should look at the frequency of each number and see how many times Alice can include it in c.

Let me consider that for each number x, if it appears f(x) times, then the number of times Alice can include it in c is ceil(f(x)/2).

Because for every two copies, Bob can delete one, and Alice can pick one.

If f(x) is odd, Alice can pick the last one.

So, for x to be in c, ceil(f(x)/2) >=1, which means f(x) >=1.

Wait, but ceil(1/2)=1, which is >=1.

So, according to this, x can be in c if f(x) >=1.

But in the second test case, f(x)=1 for all x, so all x can be in c, but according to the output, MEX=1, meaning that c does not contain 1.

So, this approach is incorrect.

Wait, perhaps I need to consider the total number of elements Alice can pick and allocate them optimally to include as many small x's as possible.

Let me think about it differently.

Let me sort the unique x's in a, in ascending order.

Then, try to include as many consecutive x's starting from 0 as possible in c, given the constraints of the game.

So, I need to check, for each x, whether Alice can include it in c, given that Bob is trying to prevent it.

Let me iterate through x from 0 upwards, and for each x, check if Alice can include it in c.

To include x in c, Alice needs to pick at least one copy of x before Bob deletes all copies.

So, if f(x) is the frequency of x in a.

If f(x) is 1:

- Alice can pick it, or Bob can delete it.

- If Alice picks it, it goes to c.

- If Bob deletes it, it doesn't go to c.

- So, Alice can choose to include it if she picks it before Bob deletes it.

If f(x) is 2:

- Alice can pick one, Bob can delete one.

- So, x is included in c.

If f(x) is 3:

- Alice can pick two, Bob deletes one.

- So, x is included in c.

In general, if f(x) >=1, Alice can include x in c.

Wait, but in the second test case, f(x)=1 for all x, and according to the output, MEX=1, meaning that c does not contain 1.

But according to this, Alice can include all x in c.

Wait, perhaps I need to consider the total number of elements Alice can pick.

In the second test case, n=4, which is even, so Alice picks n/2=2 elements.

So, she can pick 2 elements for c.

To maximize MEX, she would pick the smallest possible x's.

So, she picks 0 and 1, making c=[0,1], MEX=2.

But according to the output, it's 1.

Wait, but in the earlier simulation, Bob can force MEX=1 by deleting 1.

Wait, perhaps I need to consider that Bob can delete elements that Alice wants.

Wait, perhaps I need to think in terms of the minimal x that Alice cannot include in c, even if she tries.

So, sort the unique x's in a, in ascending order.

Then, for each x, check if Alice can include it in c, despite Bob's attempts to prevent it.

If Alice can include all x's up to some point, then MEX is the next x.

Otherwise, MEX is the first x that Alice cannot include in c.

So, I need to find the smallest x that Alice cannot include in c, given that Bob is trying to prevent it.

To do that, I need to calculate how many elements Alice can pick, and see if she can cover all x's up to a certain point.

Let me define:

- Sort the unique x's in a in ascending order.

- Let's say the unique x's are x1 < x2 < x3 < ... < xk.

- Alice wants to include as many x_i as possible in c, starting from the smallest.

- Bob wants to prevent her from including as many as possible.

Given that, Alice can include x_i in c if she can pick at least one copy of x_i before Bob deletes all copies.

So, for each x_i, if f(x_i) >=1, Alice can include it, unless Bob can delete all copies before Alice picks any.

But since Alice picks first, and they alternate turns, Alice has some advantage.

Wait, perhaps I need to calculate the minimal x that Alice cannot include in c, given the constraints.

Let me try to think in terms of the number of elements Alice can pick.

Total elements Alice can pick:

- If n is even: n/2

- If n is odd: (n+1)/2

In the second test case, n=4, which is even, so Alice picks 2 elements.

So, she can pick 2 distinct x's, assuming no duplicates.

But in this case, all x's have f(x)=1.

So, she can pick any 2 x's.

To maximize MEX, she would pick the smallest 2 x's: 0 and 1, making c=[0,1], MEX=2.

But according to the output, it's 1.

So, perhaps I'm missing that Bob can delete elements that Alice wants.

Wait, perhaps Bob can delete elements that Alice would pick, forcing her to pick higher x's.

Wait, in the second test case:

a=[0,1,2,3]

Alice picks first:

- Picks 0 → c=[0], a=[1,2,3]

- Bob deletes 1 → a=[2,3]

- Alice picks 2 → c=[0,2], a=[3]

- Bob deletes 3 → a=[]

Final c=[0,2], MEX=1.

Alternatively:

- Alice picks 1 → c=[1], a=[0,2,3]

- Bob deletes 0 → a=[2,3]

- Alice picks 2 → c=[1,2], a=[3]

- Bob deletes 3 → a=[]

Final c=[1,2], MEX=0.

Wait, in this case, MEX=0.

But according to the output, it's 1.

Wait, perhaps I misread the output.

Wait, the output for the second test case is 1.

So, perhaps Bob can force MEX=1 by deleting 1, making Alice pick 0 and another number, say 2, resulting in c=[0,2], MEX=1.

But Alice could also pick 0 and 1, resulting in MEX=2.

Wait, perhaps Bob can choose which element to delete to minimize the MEX.

So, Bob can choose to delete 1, forcing Alice to have c=[0,2], MEX=1.

Alternatively, if Bob deletes 2, then Alice can pick 1 and 3, c=[1,3], MEX=0.

So, Bob can choose to delete 1 to minimize the MEX.

Hence, the minimal MEX is 1.

Wait, but in the first scenario, MEX=1, and in the second scenario, MEX=0.

So, the minimal MEX Bob can force is 0, but according to the output, it's 1.

Wait, perhaps I need to consider that Alice can choose which elements to pick, and Bob chooses deletions to minimize the MEX.

So, Bob wants to minimize the MEX, which means he wants to force Alice to have as many small x's missing as possible.

In this case, by deleting 1, Bob forces Alice to have c=[0,2], MEX=1.

Alternatively, by deleting 2, Alice can have c=[0,1], MEX=2.

So, Bob chooses to delete 1 to minimize the MEX to 1.

Hence, the minimal MEX is 1.

Wait, but in another scenario, Bob could delete 