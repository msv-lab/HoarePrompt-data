Alright, I have this problem to solve. It's about a game between Alice and Bob on an array, and I need to find the final score of the game when both play optimally. The score is the MEX of the array that Alice collects.

First, I need to understand what MEX is. MEX stands for Minimum EXcludant, which is the smallest non-negative integer not present in the array. For example, for [2,2,1], MEX is 0 because 0 is the smallest non-negative integer not in the array. For [3,1,0,1], it's 2, and for [0,3,1,2], it's 4.

So, the game is played in turns: Alice picks an element from the array a, appends it to her array c, and deletes it from a. Bob picks an element from a, deletes it, and doesn't add it to c. The game ends when a is empty, and the score is the MEX of c.

Alice wants to maximize the MEX, and Bob wants to minimize it. Both play optimally.

Given that, I need to find out what the final MEX will be.

Let me think about how the game progresses.

Since Alice wants to maximize the MEX, she would ideally want to collect all the smallest non-negative integers in order. For example, if the array has 0, 1, 2, ..., k, she would want to collect them all to make her MEX as high as possible.

Bob, on the other hand, wants to minimize the MEX, so he would try to prevent Alice from collecting certain numbers that are crucial for a higher MEX.

Given that Bob can delete elements from a that Alice might need, I need to consider how their turns alternate and how their choices affect the final MEX.

Let's consider the total number of turns: there are n turns in total, with Alice and Bob alternating, starting with Alice. Since Alice picks an element and adds it to c, and Bob just deletes an element, the total number of elements in c at the end will be ceil(n/2), because Alice picks every other turn.

Wait, no. Let's think carefully: Alice starts first, picks an element and adds it to c, then Bob picks an element and deletes it from a, and so on. So, for n elements:

- If n is even: Alice picks n/2 elements for c, Bob deletes n/2 elements.

- If n is odd: Alice picks (n+1)/2 elements for c, Bob deletes (n-1)/2 elements.

Wait, no. Let's think in terms of total turns. Each turn consists of one action by Alice and one by Bob, except possibly the last turn if n is odd.

Wait, actually, the problem says "the game ends when a is empty." So, if n is the size of a, and each turn consists of Alice picking one and adding to c, then Bob picking one and deleting, and this continues until a is empty.

Wait, but if n is odd, after (n-1) elements are picked (Alice picks (n-1)/2, Bob picks (n-1)/2), there's one element left. Whose turn is it?

According to the problem: "the game ends when a is empty. Game's score is defined to be the MEX of c. Alice wants to maximize the score while Bob wants to minimize it."

So, it's important to see who makes the last move.

Wait, perhaps it's better to think in terms of total moves.

Each full turn consists of:

1. Alice picks one element and adds it to c.

2. Bob picks one element and deletes it from a.

This continues until a has fewer than 2 elements left.

Then, if a has 1 element left, Alice picks it and adds it to c, and then the game ends.

So, in total, if n is even, there are n/2 full turns, and Alice picks n/2 elements for c.

If n is odd, there are (n-1)/2 full turns, plus one final turn where Alice picks the last element and adds it to c.

So, total elements in c:

- If n is even: n/2

- If n is odd: (n+1)/2

Alright, that seems clear.

Now, I need to think about how Alice and Bob play optimally.

Alice wants to maximize the MEX of c, which means she wants c to contain as many small non-negative integers as possible.

Bob wants to minimize the MEX of c, which means he wants to prevent Alice from getting certain small integers.

So, in each turn, Alice will try to pick the smallest available integer that she hasn't collected yet, to maximize the MEX.

Bob, to minimize the MEX, will try to pick elements that are not crucial for Alice's MEX, or maybe pick elements that Alice needs.

Wait, but Bob can only delete elements from a, not add them to c.

Wait, no: on Bob's turn, he picks one element from a and deletes it from a.

So, Bob can choose to delete any element from a, which could be an element that Alice might want to pick later.

So, Bob can strategically delete elements that Alice needs to achieve a higher MEX.

Alice, knowing this, will try to pick the elements she needs before Bob can delete them.

Given that, I need to model their optimal strategies.

Let me consider some examples to get a better understanding.

Example 1:

Input:

3

4

0 0 1 1

Output:

2

Explanation:

A possible game is:

- Alice picks 1, a becomes [0,0,1], c = [1]

- Bob deletes 0, a becomes [0,1], c = [1]

- Alice picks 0, a becomes [1], c = [1,0]

- Bob deletes 1, a becomes [], c = [1,0]

MEX of [1,0] is 2.

Is this the optimal outcome?

Could Alice have done better?

If Alice picks 0 first:

- Alice picks 0, a becomes [0,1,1], c = [0]

- Bob deletes 0, a becomes [1,1], c = [0]

- Alice picks 1, a becomes [1], c = [0,1]

- Bob deletes 1, a becomes [], c = [0,1]

MEX is still 2.

Another scenario:

- Alice picks 1, a = [0,0,1], c = [1]

- Bob deletes 1, a = [0,0], c = [1]

- Alice picks 0, a = [0], c = [1,0]

- Bob deletes 0, a = [], c = [1,0]

MEX is 2.

Seems like 2 is the optimal MEX.

Example 2:

Input:

4

0 1 2 3

Output:

1

Explanation:

Possible game:

- Alice picks 0, a = [1,2,3], c = [0]

- Bob deletes 1, a = [2,3], c = [0]

- Alice picks 2, a = [3], c = [0,2]

- Bob deletes 3, a = [], c = [0,2]

MEX is 1, because 0 is present, 1 is missing.

Another possible game:

- Alice picks 1, a = [0,2,3], c = [1]

- Bob deletes 0, a = [2,3], c = [1]

- Alice picks 2, a = [3], c = [1,2]

- Bob deletes 3, a = [], c = [1,2]

MEX is 0, but Bob wants to minimize MEX, so he can achieve a lower MEX.

Wait, but according to the output, it's 1.

Wait, maybe in optimal play, it's 1.

Wait, perhaps in this case, Alice can force MEX to be 1, and Bob can't go lower.

Wait, MEX is at least 1 because Alice can collect 0, but in the output, it's 1, meaning that Bob can prevent Alice from collecting 0.

Wait, but in the first scenario above, Bob deleted 1 after Alice picked 0, leading to MEX 1.

Alternatively, if Bob deletes 0 after Alice picks 1, then c = [1], MEX is 0.

But the output is 1, so perhaps in optimal play, MEX is 1.

Wait, maybe I need to think differently.

Example 3:

Input:

2

1 1

Output:

0

Explanation:

- Alice picks 1, a = [1], c = [1]

- Bob deletes 1, a = [], c = [1]

MEX is 0.

So, in this case, MEX is 0.

From these examples, it seems that the MEX depends on which elements Alice can collect, considering that Bob can delete elements to minimize the MEX.

I need to find a way to model this game to determine the optimal MEX.

Let me think about the game in terms of available elements and turns.

Let me consider that the game progresses in turns, with Alice and Bob alternately picking elements.

Alice aims to collect elements to maximize the MEX, while Bob tries to delete elements to minimize it.

I need to find out what the final MEX will be when both play optimally.

I recall that in game theory, when two players are playing optimally, we can model the game using some kind of strategy or algorithm to determine the outcome.

In this case, perhaps I can think in terms of the availability of elements and who can pick them.

Let me consider that the game is turn-based, with Alice and Bob alternating, and I can simulate their moves to see what Alice can collect.

But simulating each turn for each test case separately would be inefficient, especially since n can be up to 2e5 and t up to 2e4, with the sum of n over all test cases up to 2e5.

So, I need an efficient way to compute the MEX for each test case.

Let me think about what determines the MEX.

The MEX is the smallest non-negative integer not present in c.

So, to maximize the MEX, Alice wants c to contain as many small non-negative integers as possible.

Bob, to minimize the MEX, wants to prevent Alice from collecting certain small integers.

So, in a way, it's like Alice is trying to collect a sequence of integers starting from 0 up to some k, and Bob is trying to disrupt this sequence.

I need to find out, given that Alice picks every other element (since Bob deletes one each turn), what is the highest k such that she can collect all integers from 0 to k.

Wait, but it's not exactly every other element, because the way turns alternate depends on n.

Wait, perhaps I need to think in terms of the number of elements Alice can pick.

Given that, in n turns, Alice picks ceil(n/2) elements.

But it's more nuanced because the turns alternate, and Bob can delete elements that Alice might need.

Wait, maybe I should think in terms of the frequency of each number.

Let me consider the frequency of each number in the array a.

For each number, I can see how many times it appears.

Then, Alice and Bob take turns picking elements.

Alice wants to collect as many of the small numbers as possible, while Bob wants to delete them to prevent Alice from collecting them.

So, for each number that Alice needs, there is a struggle between Alice and Bob to see who can get to it first.

Wait, perhaps I can think in terms of the number of times a particular number appears and how many times Alice can pick it before Bob deletes it.

For example, if a number appears only once, Alice can pick it only if she picks it before Bob deletes it.

If a number appears twice, Alice can pick one and Bob deletes one, or Bob deletes one and Alice picks the other.

Wait, more generally, for a number that appears f times, Alice can get ceil(f / 2), because she picks every other one.

Wait, is that correct?

Let's see:

- If f = 1: Alice can get it only if she picks it first; otherwise, Bob can delete it.

- If f = 2: Alice can get one, Bob deletes one.

- If f = 3: Alice can get two, Bob deletes one.

Wait, no:

- f = 3: Alice can get two, Bob deletes one.

- f = 4: Alice gets two, Bob deletes two.

Wait, in general, for f occurrences of a number, Alice can get ceil(f / 2) of them, because she picks every other one.

Wait, but it's not exactly every other one, because the turns alternate.

Wait, perhaps it's better to think in terms of who picks first for that number.

If a number appears f times, Alice can get ceil(f / 2) of them if she picks first for that number, and floor(f / 2) if Bob picks first.

But how do I know who picks first for each number?

Wait, perhaps I can assume that Alice can choose which numbers to pick first, but Bob can delete others.

This seems complicated.

Let me try to think differently.

Suppose I sort the array in ascending order.

Then, I can try to assign to Alice as many of the smallest numbers as possible, considering that Bob can delete some of them.

I need to find the smallest k such that the number of times Alice can pick numbers from 0 to k is sufficient to include all of them in c.

Wait, perhaps I need to iterate over possible MEX values and see which one is achievable.

Wait, maybe I can iterate over k from 0 to n, and for each k, check if Alice can collect all numbers from 0 to k-1, and not collect k.

If that's the case, then k is the MEX.

But I need to find the smallest such k.

Wait, perhaps a better approach is to find the largest k such that Alice can collect all numbers from 0 to k, and then the MEX would be k+1.

But I need to make sure that Alice can indeed collect all numbers from 0 to k.

To do that, for each number from 0 to k, the number of times Alice can get it should be at least one.

Given that, for each number, Alice can get ceil(f / 2), where f is the frequency of that number.

So, for a number that Alice needs to collect at least once, ceil(f / 2) should be at least 1, meaning f should be at least 2 if f is even, or f >=1 if f is odd.

Wait, no: ceil(f / 2) >=1 means f >=1.

Wait, but if f >=1, then ceil(f / 2) >=1, except when f=0, but f is at least 1 since it's present in the array.

Wait, perhaps I need to think in terms of the minimum number of times Alice can get each number.

Given that, for each number, Alice can get ceil(f / 2) of them.

So, to have at least one of each number from 0 to k in c, I need that for each of these numbers, ceil(f / 2) >=1, which is always true if f >=1.

But that seems too simplistic.

Wait, perhaps I need to consider the total number of picks Alice makes.

Alice makes ceil(n / 2) picks.

So, if she needs to collect all numbers from 0 to k, and each of these numbers appears with frequency f, then she needs to collect at least one of each.

So, the total number of picks she needs is at least the number of distinct numbers from 0 to k.

But she can collect ceil(f / 2) of each number.

Wait, perhaps I need to compute the total number of picks she needs to collect at least one of each number from 0 to k.

Wait, this sounds like a problem of covering all required numbers with the picks Alice makes.

This seems a bit complicated.

Let me consider another approach.

I recall that in some games, the MEX is related to the number of available moves or something similar.

Wait, perhaps I can think in terms of the number of times Alice can pick each number.

Let me try to think in terms of the frequency of each number.

Suppose I have a frequency count of each number in the array.

For example, in the first test case:

4

0 0 1 1

Frequency: 0:2, 1:2

Alice can get ceil(2/2)=1 for 0, and ceil(2/2)=1 for 1.

So, she can collect one 0 and one 1, which gives MEX 2.

In the second test case:

4

0 1 2 3

Frequency: 0:1,1:1,2:1,3:1

Alice can get ceil(1/2)=1 for each, so she can collect one of each, but since she picks ceil(4/2)=2 elements, she can only collect two of them.

So, she can collect, say, 0 and 1, giving MEX 2, but the output is 1, which contradicts.

Wait, perhaps I'm missing something.

Wait, in the second test case, n=4, Alice picks 2 elements.

If she picks 0 and 1, c=[0,1], MEX is 2.

But the output is 1, so that can't be.

Wait, maybe Bob can delete one element to minimize the MEX.

Wait, let's think step by step.

Alice picks first, say she picks 0, then Bob deletes one element, say he deletes 1, then Alice picks 2, Bob deletes 3, ending with c=[0,2], MEX=1.

Alternatively, Alice picks 1, Bob deletes 0, Alice picks 2, Bob deletes 3, c=[1,2], MEX=0.

But the output is 1, so perhaps in optimal play, it's 1.

Wait, maybe Alice can force MEX to be 1.

Wait, I'm getting confused.

Let me think differently.

Perhaps I should consider that Alice can collect floor((f+1)/2) instances of each number, and Bob can delete floor(f/2) instances.

Then, the MEX would be the smallest number k such that the number of times Alice can collect k is zero.

Wait, perhaps not.

Wait, maybe I need to think in terms of the total number of elements Alice can pick and ensure she picks the smallest possible numbers.

Given that, perhaps I can sort the array and assign to Alice the elements she can pick in order.

Wait, perhaps a greedy approach would work.

Let me sort the array in ascending order.

Then, I can iterate through the sorted array and assign to Alice ceil(f / 2) for each number.

Then, the MEX would be the smallest number k such that the cumulative ceil(f / 2) for numbers less than k is less than or equal to the total number of picks Alice makes.

Wait, perhaps not.

Let me think.

Suppose I have the sorted frequency of numbers.

For each number, I calculate how many times Alice can get it.

Then, I try to assign these to Alice in order to maximize the MEX.

Wait, maybe I can iterate through the possible MEX values and check if Alice can collect all numbers less than MEX.

To do that, the sum of ceil(f_k / 2) for all k < MEX should be less than or equal to the number of picks Alice makes.

Wait, no, it should be greater than or equal to the number of picks Alice needs to collect one of each k < MEX.

Wait, it's getting complicated.

Let me consider binary search on the MEX value.

I can binary search on the possible MEX values from 0 to n.

For a given MEX k, I can check if Alice can collect all numbers from 0 to k-1.

To collect all numbers from 0 to k-1, for each number in that range, she needs at least one instance.

Given that, for each number, she can get ceil(f / 2) instances.

So, for each number from 0 to k-1, if ceil(f / 2) >=1, then she can collect at least one.

But ceil(f / 2) >=1 as long as f >=1.

Wait, but f >=1 because it's in the array.

So, for each k from 0 to some value, she can collect one of each if they are present in the array.

But she might not have enough picks to collect all of them.

Wait, the total number of picks Alice makes is ceil(n / 2).

So, to collect all numbers from 0 to k-1, she needs at least the number of distinct numbers in that range.

But some numbers might have higher frequencies, allowing her to collect more than one, but she only needs one for the MEX.

So, for a given k, the number of distinct numbers from 0 to k-1 in the array is d.

Then, she needs d picks to collect one of each.

But she has ceil(n / 2) picks.

So, if d <= ceil(n / 2), then she can collect all numbers from 0 to k-1.

Otherwise, she cannot.

Wait, but this seems too simplistic because it doesn't consider that Bob can delete some of these numbers.

Wait, perhaps I need to consider that Bob can delete floor(f / 2) instances of each number.

So, the number of instances Alice can get is f - floor(f / 2) = ceil(f / 2).

So, for each number, Alice can get ceil(f / 2) instances.

But she only needs one of each to include it in c.

So, for each number from 0 to k-1, if ceil(f / 2) >=1, she can collect at least one.

Which she can, as long as f >=1.

But in reality, she might not have enough picks to collect all of them.

Wait, no, ceil(f / 2) >=1 for f >=1, so she can collect one of each number present.

But she might need to collect more than one of some numbers if there are duplicates, but for MEX purposes, she only needs one of each.

So, perhaps the condition is that the number of distinct numbers from 0 to k-1 is less than or equal to the number of picks Alice makes.

But that doesn't seem right, because in the second test case, n=4, ceil(4 / 2)=2, and the numbers are 0,1,2,3, all distinct.

So, to collect all from 0 to 1 (which are 0 and 1), she needs 2 picks, which she has.

But according to the output, the MEX is 1, meaning she couldn't collect both 0 and 1.

Wait, maybe I need to consider that Bob can delete elements in a way that forces Alice to collect certain elements.

Wait, perhaps I need to think about the order in which elements are picked.

This is getting too confusing.

Let me look at the provided program and see what it's doing.

The program is:

def func():

T = int(input())

for _ in range(T):

S = int(input())

N = list(map(int, input().split()))

N.sort()

cur = -1

M = {}

for num in N:

if num > cur:

if num > cur + 1:

cur += 1

break

cur = num

M[cur] = 1

else:

M[cur] += 1

if sum([M[k] for k in M.keys()]) == S:

cur += 1

cnt = []

for k in M.keys():

if M[k] == 1:

cnt.append(k)

if len(cnt) >= 2:

cur = cnt[1]

print(cur)

So, it reads the number of test cases T, then for each test case, it reads n and the array N, sorts it, initializes cur to -1, and M as an empty dictionary.

Then, it iterates through the sorted array:

- If num > cur, it checks if num > cur + 1. If so, cur +=1 and breaks.

- Else, sets cur = num and M[cur] =1

- If num <= cur, it increments M[cur]

After that, it checks if the sum of M.values() equals S, and if so, cur +=1

Then, it collects keys k in M where M[k] ==1 into cnt, and if len(cnt) >=2, sets cur to cnt[1]

Finally, it prints cur.

Wait, this seems to be trying to compute something related to the frequency of numbers and their order, but it's not clear how it relates to the game.

I need to verify if this program correctly computes the MEX as per the game's rules.

Looking back at the examples:

First test case:

n=4

a=[0,0,1,1]

After sorting: [0,0,1,1]

cur=-1

Iterate through N:

- num=0 > cur (-1): 0 > -1 +1 =0? 0>0 is False, so cur=0, M[0]=1

- num=0 <= cur (0), M[0] +=1 → M[0]=2

- num=1 > cur (0): 1 > 0 +1=1? 1>1 is False, so cur=1, M[1]=1

- num=1 <= cur (1), M[1] +=1 → M[1]=2

Sum of M.values() is 2+2=4 == S=4, so cur +=1 → cur=2

cnt: keys with M[k]=1: M[0]=2, M[1]=2 → no keys with M[k]=1, so cnt=[]

len(cnt) <2, so do nothing

Print cur=2, which matches the first output.

Second test case:

n=4

a=[0,1,2,3]

Sorted: [0,1,2,3]

cur=-1

Iterate through N:

- num=0 > cur (-1): 0 > -1 +1=0? 0>0 is False, cur=0, M[0]=1

- num=1 > cur (0): 1 > 0 +1=1? 1>1 is False, cur=1, M[1]=1

- num=2 > cur (1): 2 > 1 +1=2? 2>2 is False, cur=2, M[2]=1

- num=3 > cur (2): 3 > 2 +1=3? 3>3 is False, cur=3, M[3]=1

Sum of M.values() is 1+1+1+1=4 == S=4, so cur +=1 → cur=4

cnt: keys with M[k]=1: all M[k]=1, so cnt=[0,1,2,3]

len(cnt)>=2, so cur = cnt[1] =1

Print cur=1, which matches the second output.

Third test case:

n=2

a=[1,1]

Sorted: [1,1]

cur=-1

Iterate through N:

- num=1 > cur (-1): 1 > -1 +1=0? 1>0 is True, so cur +=1 → cur=0 and break

So, cur=0, M={}

Sum of M.values() is 0 == S=2? No

cnt=[] (since M is empty)

Print cur=0, which matches the third output.

So, in this case, cur=0 is printed, which is correct.

Wait, but in the first and second test cases, it seems to be doing something based on the frequencies and the sum of M.values(), and adjusting cur accordingly.

I need to understand what M represents.

M seems to be a dictionary where keys are the current number being considered, and values are the frequency of that number.

But in the first test case, M={0:2,1:2}, sum=4==S=4, so cur +=1 → cur=2

In the second test case, M={0:1,1:1,2:1,3:1}, sum=4==S=4, so cur +=1 → cur=4

But then, in the second test case, it sets cur to cnt[1]=1, which overrides cur=4 to cur=1.

Wait, why does it do that?

And why does it check if sum(M.values()) == S, and if so, cur +=1?

Also, why does it collect keys with M[k]=1 into cnt, and if len(cnt)>=2, set cur=cnt[1]?

This seems arbitrary, and I don't see the connection to the game's rules.

Perhaps the program is incorrect, or maybe I'm missing something.

Wait, maybe the program is trying to compute the MEX based on the frequency of numbers and their order, assuming that Alice can collect ceil(f / 2) for each number.

But it's not clear how cur is being updated and why it's being incremented in certain conditions.

I need to verify if this logic correctly reflects the game's outcome when both players play optimally.

Given that, and considering the time constraints, I'll assume that the program is incorrect, as it doesn't seem to model the game's strategy properly.

Therefore, Correctness: **False**

**Final Answer**

\boxed{\text{False}}