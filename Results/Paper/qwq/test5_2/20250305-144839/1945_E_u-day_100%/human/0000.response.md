Alright, I have this problem to solve. Let's see what it's about. So, Anton has a permutation of size n and a number x that he wants to find using a binary search-like algorithm. But here's the twist: the array isn't sorted, and I can perform at most two swaps on the permutation before running this binary search to make sure that after the algorithm, p_l equals x.

First, I need to understand what a permutation is. A permutation of size n is just an array containing each number from 1 to n exactly once, but in any order. So, for n=3, possible permutations are [1,2,3], [1,3,2], [2,1,3], etc.

Now, the binary search algorithm described here is a bit unusual. It initializes l=1 and r=n+1, which is different from the standard binary search where l=0 and r=n. Then, it enters a loop where it calculates m as the floor of (r + l)/2, checks if p_m <= x, and adjusts l or r accordingly. The loop continues until r - l = 1.

The goal is to rearrange the permutation using at most two swaps so that after running this binary search, p_l equals x.

The problem also mentions that two operations are always sufficient, which is interesting. So, no matter how the permutation is arranged, I can always make p_l equal to x after at most two swaps.

First, I need to understand how this binary search works. It's a bit confusing because in standard binary search, the array is sorted, and we look for the target value. Here, the array is not sorted, and we're doing something similar but adapted to an unsorted array.

Let me try to see how this binary search proceeds with an example.

Take the first test case:

n=6, x=3

arr = [1,2,3,4,5,6]

So, the array is already sorted. Let's see how the binary search proceeds.

Initialize l=0, r=7 (since n=6, n+1=7)

Loop while r - l > 1:

m = floor((r + l)/2) = floor((7 + 0)/2) = 3

Check if p_m <= x: p_3 = 4 <= 3? No, so r = m = 3

Now, l=0, r=3

m = floor((3 + 0)/2) = 1

p_1 = 2 <= 3? Yes, so l = m = 1

Now, l=1, r=3

m = floor((3 + 1)/2) = 2

p_2 = 3 <= 3? Yes, so l = m = 2

Now, l=2, r=3

m = floor((3 + 2)/2) = 2

Check p_2 = 3 <= 3? Yes, so l = m = 2

Now, r - l = 1, so loop ends.

p_l = p_2 = 3, which equals x=3.

So, in this case, no swaps are needed.

Next test case:

n=6, x=5

arr = [3,1,6,5,2,4]

Let's apply the binary search.

l=0, r=7

m = floor((7+0)/2) = 3

p_3 = 6 <= 5? No, so r = m = 3

Now, l=0, r=3

m = floor((3+0)/2) = 1

p_1 = 1 <= 5? Yes, so l = m = 1

Now, l=1, r=3

m = floor((3+1)/2) = 2

p_2 = 6 <= 5? No, so r = m = 2

Now, l=1, r=2

m = floor((2+1)/2) = 1

p_1 = 1 <= 5? Yes, so l = m = 1

Now, r - l = 1, loop ends.

p_l = p_1 = 1, which is not equal to x=5.

So, swaps are needed.

The sample output suggests that one swap is enough: swap positions 3 and 4.

So, arr becomes [3,1,5,6,2,4]

Let's see how the binary search proceeds now.

l=0, r=7

m = floor((7+0)/2) = 3

p_3 = 5 <= 5? Yes, so l = m = 3

Now, l=3, r=7

m = floor((7+3)/2) = 5

p_5 = 2 <= 5? Yes, so l = m = 5

Now, l=5, r=7

m = floor((7+5)/2) = 6

p_6 = 4 <= 5? Yes, so l = m = 6

Now, l=6, r=7

m = floor((7+6)/2) = 6

p_6 = 4 <= 5? Yes, so l = m = 6

Now, r - l = 1, loop ends.

p_l = p_6 = 4, which is not equal to x=5.

Hmm, that doesn't seem right. Wait, in the sample output, it shows:

1

3 4

Which means swap positions 3 and 4.

But in zero-based indexing, that would be positions 2 and 3.

After swap:

arr = [3,1,5,6,2,4]

Wait, but according to the sample, after this swap, the binary search should find p_l = x.

But in my calculation, p_l = 4 != 5.

Maybe I'm misunderstanding the indexing.

In the problem, it seems that the array is one-based indexed, since the output shows positions starting from 1.

So, arr[1] = 3, arr[2] =1, arr[3]=6, arr[4]=5, arr[5]=2, arr[6]=4.

After swapping positions 3 and 4, arr[3]=5 and arr[4]=6.

So, arr = [3,1,5,6,2,4]

Now, binary search:

l=1, r=7

m = floor((7+1)/2) = 4

p_m = p4 =6 <=5? No, so r = m =4

Now, l=1, r=4

m = floor((4+1)/2)=2

p_m = p2=1 <=5? Yes, so l=m=2

Now, l=2, r=4

m=floor((4+2)/2)=3

p_m = p3=5 <=5? Yes, so l=m=3

Now, l=3, r=4

m=floor((4+3)/2)=3

p_m = p3=5 <=5? Yes, so l=m=3

Now, r - l =1, loop ends.

p_l = p3=5, which equals x=5.

Okay, so it works.

So, the strategy seems to be: find where x is in the array, and try to move it to the position where the binary search will stop.

In this case, without any swaps, the binary search stops at p1=1.

But after swapping positions 3 and 4, x=5 is at position 3, and the binary search stops at p3=5.

So, the idea is to move x to the position where the binary search will end.

But how to generalize this?

First, I need to simulate the binary search to see where it would stop if I don't make any swaps.

If p_l equals x, then no swaps are needed.

If not, I need to make swaps to move x to that position.

But I can make at most two swaps.

The problem says that two operations are always sufficient.

So, I need to find a way to move x to the desired position with at most two swaps.

Let me think about how the binary search works in this scenario.

The binary search starts with l=1 and r=n+1.

It calculates m as floor((l+r)/2), checks p_m <= x, and adjusts l or r accordingly.

It continues until r - l =1, then stops with p_l.

So, the final l is where the binary search stops.

I need to ensure that p_l =x.

So, one way is to find out where the binary search stops without any swaps, and if p_l !=x, then swap p_l with x's current position.

But in some cases, one swap might not be enough, hence the allowance of up to two swaps.

Wait, in the sample input, sometimes one swap is enough, sometimes two are needed.

Looking at the sample output:

First test case: 0 swaps needed, since the array is already sorted and p_l =x.

Second test case: 1 swap: positions 3 and 4.

Third test case: 2 swaps.

So, it varies.

I need to find the minimal number of swaps, but the problem says I don't need to minimize k, just output any k between 0 and 2.

So, I can afford to be a bit inefficient as long as I don't exceed two swaps.

Let me think about an algorithm.

Step 1: Simulate the binary search to find the final l without any swaps.

Step 2: If p_l ==x, then no swaps are needed.

Step 3: If p_l !=x, then I need to make swaps to move x to position l.

But, if x is already at position l, then no swaps are needed.

Otherwise, I need to swap x's current position with position l.

But, if there are other elements in between, I might need a second swap.

Wait, since I can perform up to two swaps, I should find a way to move x to position l with at most two swaps.

One approach could be:

- Find the current position of x, say pos_x.

- Find the position where binary search stops, say pos_l.

- If pos_x == pos_l, then no swaps needed.

- Else, swap pos_x with pos_l.

- But, if after this swap, some other element is displaced, and it affects the binary search path, maybe I need a second swap.

Wait, but since I can perform up to two swaps, I can first swap x to position l, and if necessary, perform another swap to fix any disruption.

But I need to ensure that after at most two swaps, p_l ==x.

Let me consider an example where one swap is not enough.

Take the third test case:

n=5, x=1

arr = [3,5,4,2,1]

Let's simulate the binary search.

l=1, r=6

m=floor((6+1)/2)=3

p_m = p3=4 <=1? No, so r=m=3

Now, l=1, r=3

m=floor((3+1)/2)=2

p_m = p2=5 <=1? No, so r=m=2

Now, l=1, r=2

m=floor((2+1)/2)=1

p_m = p1=3 <=1? No, so r=m=1

Now, l=1, r=1

Loop ends.

p_l = p1=3 !=1

So, need to swap.

If I swap p1=3 with p5=1, then arr becomes [1,5,4,2,3]

Now, binary search:

l=1, r=6

m=floor((6+1)/2)=3

p_m = p3=4 <=1? No, r=3

l=1, r=3

m=floor((3+1)/2)=2

p_m = p2=5 <=1? No, r=2

l=1, r=2

m=floor((2+1)/2)=1

p_m = p1=1 <=1? Yes, l=m=1

Now, r - l =1, loop ends.

p_l = p1=1 ==x=1

So, one swap suffices.

But according to the sample output, it used two swaps:

2

2 4

1 5

Wait, positions 2 and 4, then 1 and 5.

Let's see what that does.

Original arr: [3,5,4,2,1]

After swapping 2 and 4: [3,2,4,5,1]

After swapping 1 and 5: [1,2,4,5,3]

Now, binary search:

l=1, r=6

m=floor((6+1)/2)=3

p_m = p3=4 <=1? No, r=3

l=1, r=3

m=floor((3+1)/2)=2

p_m = p2=2 <=1? No, r=2

l=1, r=2

m=floor((2+1)/2)=1

p_m = p1=1 <=1? Yes, l=m=1

Loop ends with p_l =1 ==x=1

So, two swaps also work, but one swap would have been sufficient.

But the problem says I don't need to minimize k, just output any k between 0 and 2.

So, in this case, one swap would have been enough, but the sample output used two swaps.

So, it's acceptable to use more swaps than necessary, as long as k <=2.

Another test case:

n=6, x=3

arr = [4,3,1,5,2,6]

Simulate binary search:

l=1, r=7

m=floor((7+1)/2)=4

p_m = p4=5 <=3? No, r=4

l=1, r=4

m=floor((4+1)/2)=2

p_m = p2=3 <=3? Yes, l=m=2

Now, l=2, r=4

m=floor((4+2)/2)=3

p_m = p3=1 <=3? Yes, l=m=3

Now, l=3, r=4

m=floor((4+3)/2)=3

p_m = p3=1 <=3? Yes, l=m=3

Loop ends with p_l = p3=1 !=3

So, need swaps.

One way: swap p3=1 with p1=4, arr becomes [1,3,4,5,2,6]

Binary search:

l=1, r=7

m=4

p4=5 <=3? No, r=4

l=1, r=4

m=2

p2=3 <=3? Yes, l=2

Now, l=2, r=4

m=3

p3=4 <=3? No, r=3

l=2, r=3

m=2

p2=3 <=3? Yes, l=2

Loop ends with p_l = p2=3 ==x=3

So, one swap suffices.

But according to the sample output, it used two swaps:

2

4 5

2 4

Let's see what that does.

Original arr: [4,3,1,5,2,6]

Swap 4 and 5: positions 4 and 5, elements 5 and 2 -> [4,3,1,2,5,6]

Swap 2 and 4: positions 2 and 4, elements 3 and 2 -> [4,2,1,3,5,6]

Now, binary search:

l=1, r=7

m=4

p4=3 <=3? Yes, l=4

Now, l=4, r=7

m=5

p5=5 <=3? No, r=5

l=4, r=5

m=4

p4=3 <=3? Yes, l=4

Loop ends with p_l = p4=3 ==x=3

So, two swaps also achieve the goal.

Again, one swap would have been sufficient, but two are allowed.

Last test case:

n=3, x=2

arr = [3,2,1]

Binary search:

l=1, r=4

m=floor((4+1)/2)=2

p_m = p2=2 <=2? Yes, l=2

Now, l=2, r=4

m=floor((4+2)/2)=3

p_m = p3=1 <=2? Yes, l=3

Now, l=3, r=4

m=3

p3=1 <=2? Yes, l=3

Loop ends with p_l = p3=1 !=2

Need swaps.

One way: swap p1=3 with p2=2, arr becomes [2,3,1]

Binary search:

l=1, r=4

m=2

p2=3 <=2? No, r=2

l=1, r=2

m=1

p1=2 <=2? Yes, l=1

Loop ends with p_l = p1=2 ==x=2

So, one swap suffices.

Sample output shows:

1

1 3

Wait, positions 1 and 3: swap 3 and 1, arr becomes [1,3,2]

Binary search:

l=1, r=4

m=2

p2=3 <=2? No, r=2

l=1, r=2

m=1

p1=1 <=2? Yes, l=1

Loop ends with p_l = p1=1 !=2

That doesn't work.

Wait, maybe I misread the sample output.

Sample output for the last test case is:

1

1 3

But according to my calculation, swapping positions 1 and 2 would work, but swapping positions 1 and 3 doesn't.

Wait, perhaps I made a mistake.

Let's see:

Original arr: [3,2,1]

Swap positions 1 and 3: arr becomes [1,2,3]

Binary search:

l=1, r=4

m=2

p2=2 <=2? Yes, l=2

Now, l=2, r=4

m=3

p3=3 <=2? No, r=3

l=2, r=3

m=2

p2=2 <=2? Yes, l=2

Loop ends with p_l = p2=2 ==x=2

Ah, it does work. I must have miscalculated earlier.

So, swapping positions 1 and 3 makes arr=[1,2,3], and the binary search stops at p2=2, which is correct.

So, in this case, swapping positions 1 and 3 works.

But earlier, I thought p_l would be p1=1, but actually, with arr=[1,2,3], the binary search proceeds differently.

So, my mistake was in simulating the binary search correctly after the swap.

Therefore, in this case, swapping positions 1 and 3 achieves the goal.

Hence, one swap is sufficient.

From these observations, it seems that one swap is often sufficient, but the problem allows up to two swaps.

So, a general strategy could be:

1. Simulate the binary search to find the final l without any swaps.

2. If p_l == x, then output 0 swaps.

3. Else, find the position of x, say pos_x.

4. Swap pos_x with l.

5. Simulate the binary search again to check if p_l == x.

6. If yes, output 1 swap: swap pos_x with l.

7. Else, perform a second swap to fix any discrepancies.

But I need a more concrete plan for the second swap.

Alternatively, since two swaps are always sufficient, I can find a way to move x to the desired position l with at most two swaps.

One possible way is:

- Find the current position of x, pos_x.

- Find the position where binary search stops, pos_l.

- If pos_x == pos_l, no swaps needed.

- Else, swap pos_x with pos_l.

- Then, check if p_l == x.

- If yes, output 1 swap.

- Else, find the current position of x after the first swap, pos_x_new.

- Swap pos_x_new with pos_l.

- Output 2 swaps.

But I need to verify if this always works.

Let's consider a case where one swap is not enough.

Take n=4, x=2

arr = [4,3,1,2]

Simulate binary search:

l=1, r=5

m=floor((5+1)/2)=3

p3=1 <=2? Yes, l=3

Now, l=3, r=5

m=floor((5+3)/2)=4

p4=2 <=2? Yes, l=4

Now, l=4, r=5

m=4

p4=2 <=2? Yes, l=4

Loop ends with p_l = p4=2 ==x=2

So, no swaps needed.

Another case: n=4, x=1

arr = [4,3,1,2]

Binary search:

l=1, r=5

m=3

p3=1 <=1? Yes, l=3

Now, l=3, r=5

m=4

p4=2 <=1? No, r=4

l=3, r=4

m=3

p3=1 <=1? Yes, l=3

Loop ends with p_l = p3=1 ==x=1

No swaps needed.

Another case: n=4, x=3

arr = [4,3,1,2]

Binary search:

l=1, r=5

m=3

p3=1 <=3? Yes, l=3

Now, l=3, r=5

m=4

p4=2 <=3? Yes, l=4

Now, l=4, r=5

m=4

p4=2 <=3? Yes, l=4

Loop ends with p_l = p4=2 !=3

Need swaps.

Current position of x=3 is pos_x=2

Position where binary search stops is pos_l=4

Swap pos_x=2 with pos_l=4: arr becomes [4,2,1,3]

Now, binary search:

l=1, r=5

m=3

p3=1 <=3? Yes, l=3

Now, l=3, r=5

m=4

p4=3 <=3? Yes, l=4

Now, l=4, r=5

m=4

p4=3 <=3? Yes, l=4

Loop ends with p_l = p4=3 ==x=3

So, one swap suffices.

Another case: n=5, x=4

arr = [3,5,1,2,4]

Binary search:

l=1, r=6

m=3

p3=1 <=4? Yes, l=3

Now, l=3, r=6

m=4

p4=2 <=4? Yes, l=4

Now, l=4, r=6

m=5

p5=4 <=4? Yes, l=5

Now, l=5, r=6

m=5

p5=4 <=4? Yes, l=5

Loop ends with p_l = p5=4 ==x=4

So, no swaps needed.

Another case: n=5, x=2

arr = [3,5,1,4,2]

Binary search:

l=1, r=6

m=3

p3=1 <=2? Yes, l=3

Now, l=3, r=6

m=4

p4=4 <=2? No, r=4

l=3, r=4

m=3

p3=1 <=2? Yes, l=3

Loop ends with p_l = p3=1 !=2

Need swaps.

pos_x=5 (since x=2 is at position 5)

pos_l=3

Swap pos_x=5 with pos_l=3: arr becomes [3,5,2,4,1]

Now, binary search:

l=1, r=6

m=3

p3=2 <=2? Yes, l=3

Now, l=3, r=6

m=4

p4=4 <=2? No, r=4

l=3, r=4

m=3

p3=2 <=2? Yes, l=3

Loop ends with p_l = p3=2 ==x=2

So, one swap suffices.

Another case: n=4, x=3

arr = [1,2,4,3]

Binary search:

l=1, r=5

m=3

p3=4 <=3? No, r=3

l=1, r=3

m=2

p2=2 <=3? Yes, l=2

Now, l=2, r=3

m=2

p2=2 <=3? Yes, l=2

Loop ends with p_l = p2=2 !=3

Need swaps.

pos_x=4

pos_l=2

Swap pos_x=4 with pos_l=2: arr becomes [1,3,4,2]

Now, binary search:

l=1, r=5

m=3

p3=4 <=3? No, r=3

l=1, r=3

m=2

p2=3 <=3? Yes, l=2

Now, l=2, r=3

m=2

p2=3 <=3? Yes, l=2

Loop ends with p_l = p2=3 ==x=3

So, one swap suffices.

Wait, but what if one swap is not enough?

Let's try n=5, x=3

arr = [5,1,2,4,3]

Binary search:

l=1, r=6

m=3

p3=2 <=3? Yes, l=3

Now, l=3, r=6

m=4

p4=4 <=3? No, r=4

l=3, r=4

m=3

p3=2 <=3? Yes, l=3

Loop ends with p_l = p3=2 !=3

Need swaps.

pos_x=5

pos_l=3

Swap pos_x=5 with pos_l=3: arr becomes [5,1,3,4,2]

Now, binary search:

l=1, r=6

m=3

p3=3 <=3? Yes, l=3

Now, l=3, r=6

m=4

p4=4 <=3? No, r=4

l=3, r=4

m=3

p3=3 <=3? Yes, l=3

Loop ends with p_l = p3=3 ==x=3

So, one swap suffices.

Another case: n=6, x=2

arr = [4,3,1,5,2,6]

Binary search:

l=1, r=7

m=4

p4=5 <=2? No, r=4

l=1, r=4

m=2

p2=3 <=2? No, r=2

l=1, r=2

m=1

p1=4 <=2? No, r=1

l=1, r=1

Loop ends with p_l = p1=4 !=2

Need swaps.

pos_x=5

pos_l=1

Swap pos_x=5 with pos_l=1: arr becomes [2,3,1,5,4,6]

Now, binary search:

l=1, r=7

m=4

p4=5 <=2? No, r=4

l=1, r=4

m=2

p2=3 <=2? No, r=2

l=1, r=2

m=1

p1=2 <=2? Yes, l=1

Loop ends with p_l = p1=2 ==x=2

So, one swap suffices.

Wait, but what if x is not directly swappable to l?

Let's consider n=5, x=2

arr = [3,1,4,5,2]

Binary search:

l=1, r=6

m=3

p3=4 <=2? No, r=3

l=1, r=3

m=2

p2=1 <=2? Yes, l=2

Now, l=2, r=3

m=2

p2=1 <=2? Yes, l=2

Loop ends with p_l = p2=1 !=2

Need swaps.

pos_x=5

pos_l=2

Swap pos_x=5 with pos_l=2: arr becomes [3,2,4,5,1]

Now, binary search:

l=1, r=6

m=3

p3=4 <=2? No, r=3

l=1, r=3

m=2

p2=2 <=2? Yes, l=2

Now, l=2, r=3

m=2

p2=2 <=2? Yes, l=2

Loop ends with p_l = p2=2 ==x=2

So, one swap suffices.

Seems consistent.

Wait, but according to the problem, two swaps are always sufficient.

In all the above cases, one swap sufficed.

Is there a case where one swap is not enough?

Let's try n=4, x=2

arr = [1,4,3,2]

Binary search:

l=1, r=5

m=3

p3=3 <=2? No, r=3

l=1, r=3

m=2

p2=4 <=2? No, r=2

l=1, r=2

m=1

p1=1 <=2? Yes, l=1

Loop ends with p_l = p1=1 !=2

Need swaps.

pos_x=4

pos_l=1

Swap pos_x=4 with pos_l=1: arr becomes [2,4,3,1]

Now, binary search:

l=1, r=5

m=3

p3=3 <=2? No, r=3

l=1, r=3

m=2

p2=4 <=2? No, r=2

l=1, r=2

m=1

p1=2 <=2? Yes, l=1

Loop ends with p_l = p1=2 ==x=2

So, one swap suffices.

Another case: n=5, x=3

arr = [1,2,4,5,3]

Binary search:

l=1, r=6

m=3

p3=4 <=3? No, r=3

l=1, r=3

m=2

p2=2 <=3? Yes, l=2

Now, l=2, r=3

m=2

p2=2 <=3? Yes, l=2

Loop ends with p_l = p2=2 !=3

Need swaps.

pos_x=5

pos_l=2

Swap pos_x=5 with pos_l=2: arr becomes [1,3,4,5,2]

Now, binary search:

l=1, r=6

m=3

p3=4 <=3? No, r=3

l=1, r=3

m=2

p2=3 <=3? Yes, l=2

Now, l=2, r=3

m=2

p2=3 <=3? Yes, l=2

Loop ends with p_l = p2=3 ==x=3

Again, one swap suffices.

Wait, maybe in some cases, one swap is not enough.

Let's consider n=6, x=3

arr = [5,4,1,2,6,3]

Binary search:

l=1, r=7

m=4

p4=2 <=3? Yes, l=4

Now, l=4, r=7

m=5

p5=6 <=3? No, r=5

l=4, r=5

m=4

p4=2 <=3? Yes, l=4

Loop ends with p_l = p4=2 !=3

Need swaps.

pos_x=6

pos_l=4

Swap pos_x=6 with pos_l=4: arr becomes [5,4,1,3,6,2]

Now, binary search:

l=1, r=7

m=4

p4=3 <=3? Yes, l=4

Now, l=4, r=7

m=5

p5=6 <=3? No, r=5

l=4, r=5

m=4

p4=3 <=3? Yes, l=4

Loop ends with p_l = p4=3 ==x=3

So, one swap suffices.

Another case: n=5, x=4

arr = [1,2,3,5,4]

Binary search:

l=1, r=6

m=3

p3=3 <=4? Yes, l=3

Now, l=3, r=6

m=4

p4=5 <=4? No, r=4

l=3, r=4

m=3

p3=3 <=4? Yes, l=3

Loop ends with p_l = p3=3 !=4

Need swaps.

pos_x=5

pos_l=3

Swap pos_x=5 with pos_l=3: arr becomes [1,2,4,5,3]

Now, binary search:

l=1, r=6

m=3

p3=4 <=4? Yes, l=3

Now, l=3, r=6

m=4

p4=5 <=4? No, r=4

l=3, r=4

m=3

p3=4 <=4? Yes, l=3

Loop ends with p_l = p3=4 ==x=4

So, one swap suffices.

Wait, I can't find a case where one swap is not enough.

Is it possible that one swap is always sufficient?

But the problem says that two swaps are always sufficient, implying that one swap might not be always sufficient, but I can't find such a case.

Let me try n=4, x=2

arr = [3,1,4,2]

Binary search:

l=1, r=5

m=3

p3=4 <=2? No, r=3

l=1, r=3

m=2

p2=1 <=2? Yes, l=2

Now, l=2, r=3

m=2

p2=1 <=2? Yes, l=2

Loop ends with p_l = p2=1 !=2

Need swaps.

pos_x=4

pos_l=2

Swap pos_x=4 with pos_l=2: arr becomes [3,2,4,1]

Now, binary search:

l=1, r=5

m=3

p3=4 <=2? No, r=3

l=1, r=3

m=2

p2=2 <=2? Yes, l=2

Now, l=2, r=3

m=2

p2=2 <=2? Yes, l=2

Loop ends with p_l = p2=2 ==x=2

So, one swap suffices.

Another case: n=5, x=2

arr = [4,3,1,5,2]

Binary search:

l=1, r=6

m=3

p3=1 <=2? Yes, l=3

Now, l=3, r=6

m=4

p4=5 <=2? No, r=4

l=3, r=4

m=3

p3=1 <=2? Yes, l=3

Loop ends with p_l = p3=1 !=2

Need swaps.

pos_x=5

pos_l=3

Swap pos_x=5 with pos_l=3: arr becomes [4,3,2,5,1]

Now, binary search:

l=1, r=6

m=3

p3=2 <=2? Yes, l=3

Now, l=3, r=6

m=4

p4=5 <=2? No, r=4

l=3, r=4

m=3

p3=2 <=2? Yes, l=3

Loop ends with p_l = p3=2 ==x=2

Again, one swap suffices.

Wait, maybe in some cases, x is not directly swappable to l.

Let's consider n=6, x=3

arr = [2,1,4,5,6,3]

Binary search:

l=1, r=7

m=4

p4=5 <=3? No, r=4

l=1, r=4

m=2

p2=1 <=3? Yes, l=2

Now, l=2, r=4

m=3

p3=4 <=3? No, r=3

l=2, r=3

m=2

p2=1 <=3? Yes, l=2

Loop ends with p_l = p2=1 !=3

Need swaps.

pos_x=6

pos_l=2

Swap pos_x=6 with pos_l=2: arr becomes [2,3,4,5,6,1]

Now, binary search:

l=1, r=7

m=4

p4=5 <=3? No, r=4

l=1, r=4

m=2

p2=3 <=3? Yes, l=2

Now, l=2, r=4

m=3

p3=4 <=3? No, r=3

l=2, r=3

m=2

p2=3 <=3? Yes, l=2

Loop ends with p_l = p2=3 ==x=3

So, one swap suffices.

Another case: n=5, x=3

arr = [1,5,2,4,3]

Binary search:

l=1, r=6

m=3

p3=2 <=3? Yes, l=3

Now, l=3, r=6

m=4

p4=4 <=3? No, r=4

l=3, r=4

m=3

p3=2 <=3? Yes, l=3

Loop ends with p_l = p3=2 !=3

Need swaps.

pos_x=5

pos_l=3

Swap pos_x=5 with pos_l=3: arr becomes [1,5,3,4,2]

Now, binary search:

l=1, r=6

m=3

p3=3 <=3? Yes, l=3

Now, l=3, r=6

m=4

p4=4 <=3? No, r=4

l=3, r=4

m=3

p3=3 <=3? Yes, l=3

Loop ends with p_l = p3=3 ==x=3

Again, one swap suffices.

Wait, maybe in some cases, x is not present in the array, but according to the problem, x is always present since it's a permutation of 1 to n, so x is always in the array.

Alternatively, maybe in some cases, swapping x to l doesn't fix the issue, and a second swap is needed.

But in all the cases I tried, one swap suffices.

Maybe the problem allows two swaps to cover those cases where one swap isn't enough, but in practice, one swap is sufficient.

Alternatively, perhaps in some cases, after swapping x to l, some other element disrupts the binary search path.

But in the cases I tried, that didn't happen.

So, perhaps the general approach is:

- Find the position where binary search stops without any swaps, pos_l.

- Find the current position of x, pos_x.

- If pos_x == pos_l, no swaps needed.

- Else, swap pos_x with pos_l.

- Check if p_l ==x.

- If yes, output 1 swap.

- Else, perform a second swap to fix any discrepancies.

But in practice, one swap seems to suffice.

Given that, perhaps the program provided in the problem does exactly that.

Let me look at the provided program.

The program seems to implement exactly this:

- Find pos_x.

- Simulate the binary search to find pos_l.

- If p_l ==x, output 0.

- Else, output 1 swap: swap pos_l with pos_x.

In the sample input, for the second test case, it swaps positions 3 and 4, which are pos_l and pos_x.

And as seen in the earlier simulation, this works.

Similarly, in other test cases, one swap suffices.

So, perhaps two swaps are only needed in more complex scenarios, but in practice, one swap is enough.

Given that, the provided program seems correct.

It finds pos_x, simulates the binary search to find pos_l, and if p_l !=x, performs one swap between pos_l and pos_x.

According to my simulations, this works.

Hence, the program is correct.

**Final Solution**

To solve this problem, we need to ensure that a modified binary search algorithm correctly identifies a specific element `x` in a permutation `p` of size `n`. We are allowed to perform up to two swaps on the permutation to achieve this. The goal is to make sure that after performing the binary search, the element at the final position `l` is equal to `x`.

### Approach

1. **Identify Positions**:
   - Find the position of `x` in the permutation (`pos_x`).
   - Simulate the binary search to determine the final position `l` (`pos_l`) where the search ends.

2. **Check if No Swap is Needed**:
   - If the element at `pos_l` is already `x`, no swaps are needed.

3. **Perform Swaps**:
   - If the element at `pos_l` is not `x`, swap the elements at `pos_l` and `pos_x`.
   - In most cases, one swap is sufficient. If not, a second swap might be required, but based on analysis, one swap generally suffices.

### Solution Code

```python
for _ in range(int(input())):
    func_3()

def func_1():
    return map(int, input().split())

def func_2():
    return list(func_1())

def func_3():
    (n, k) = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
    (low, high) = (0, n)
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        st.add(mid)
        if arr[mid] > k:
            high = mid
        else:
            low = mid
    if arr[low] == k:
        print(0)
    else:
        print(1)
        print(low + 1, pos + 1)
```

### Explanation

1. **Reading Input**:
   - Read the number of test cases.
   - For each test case, read `n` (size of permutation) and `x` (the element to find).
   - Read the permutation array `p`.

2. **Finding Positions**:
   - Locate the position `pos_x` of `x` in the array.
   - Simulate the binary search to find the final position `pos_l`.

3. **Performing Swaps**:
   - If `p[pos_l]` is not `x`, perform a swap between `p[pos_l]` and `p[pos_x]`.
   - Output the number of swaps performed (either 0 or 1) and the positions involved in the swap