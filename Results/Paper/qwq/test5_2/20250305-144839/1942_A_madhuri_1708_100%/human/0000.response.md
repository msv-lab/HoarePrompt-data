Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of length n, where each element is between 1 and 10^9, and exactly k out of its n cyclic shifts are sorted. If no such array exists, I should output -1.

First, I need to understand what a cyclic shift is. From the description, the x-th cyclic shift of an array a is basically rotating the array x positions to the left. For example, if n=4 and a=[1,2,3,3], the cyclic shifts are:

- x=1: [1,2,3,3]

- x=2: [2,3,3,1]

- x=3: [3,3,1,2]

- x=4: [3,1,2,3]

And among these, only x=1 is sorted in non-decreasing order.

So, for a given n and k, I need to find an array where exactly k of these shifts are sorted.

Let me think about the constraints:

- 1 ≤ k ≤ n ≤ 10^3

- Sum of n over all test cases ≤ 10^3

- t ≤ 10^3 test cases

I need to handle up to 10^3 test cases efficiently, but since n can be up to 10^3 and t*n ≤ 10^6, it's manageable.

Now, I need to find any array that satisfies the condition or determine that no such array exists.

Let me consider some small values of n and k to find a pattern or a general rule.

**Case 1: n=1, k=1**

For n=1, there's only one cyclic shift, which is the array itself. So, any single element array is sorted. So, [1] would work.

**Case 2: n=2, k=1**

Possible arrays:

- [1,2]: shifts are [1,2] and [2,1]. Only one is sorted.

- [2,1]: shifts are [2,1] and [1,2]. Only one is sorted.

- [1,1]: both shifts are [1,1] and [1,1], both are sorted. So, k=2.

So, for k=1, [1,2] or [2,1] work.

**Case 3: n=2, k=2**

From above, [1,1] works since both shifts are sorted.

Alternatively, [2,2] would also work.

**Case 4: n=3, k=1**

From the example, a=[69420,69,420] has exactly one sorted cyclic shift.

Let's verify:

- [69420,69,420]: 69420 > 69, not sorted.

- [69,420,69420]: 69 ≤ 420 ≤ 69420, sorted.

- [420,69420,69]: 420 ≤ 69420 but 69420 > 69, not sorted.

So, only one sorted shift.

**Case 5: n=3, k=2**

Let's try to find such an array.

Suppose a=[1,2,3]:

- [1,2,3]: sorted.

- [2,3,1]: 2 ≤ 3 ≤ 1? No.

- [3,1,2]: 3 ≤ 1? No.

Only one sorted shift.

Another try: a=[1,1,2]:

- [1,1,2]: sorted.

- [1,2,1]: 1 ≤ 2 ≤ 1? No.

- [2,1,1]: 2 ≤ 1? No.

Only one sorted shift.

Another try: a=[1,2,2]:

- [1,2,2]: sorted.

- [2,2,1]: 2 ≤ 2 ≤ 1? No.

- [2,1,2]: 2 ≤ 1? No.

Again, only one sorted shift.

Another try: a=[1,1,1]:

- All shifts are [1,1,1], all sorted. So, k=3.

Not what we need.

Seems like for n=3, k=2 is not possible. At least, I can't find an array that satisfies it.

**Case 6: n=4, k=2**

Let's see if it's possible.

Try a=[1,1,2,2]:

- [1,1,2,2]: sorted.

- [1,2,2,1]: 1 ≤ 2 ≤ 2 ≥ 1? Not sorted.

- [2,2,1,1]: 2 ≤ 2 ≤ 1? No.

- [2,1,1,2]: 2 ≤ 1? No.

Only one sorted shift.

Another try: a=[1,2,3,2]:

- [1,2,3,2]: 1 ≤ 2 ≤ 3 ≥ 2? Not sorted.

- [2,3,2,1]: 2 ≤ 3 ≥ 2 ≥ 1? No.

- [3,2,1,2]: 3 ≥ 2 ≥ 1 ≤ 2? No.

- [2,1,2,3]: 2 ≥ 1 ≤ 2 ≤ 3? No.

None are sorted.

Another try: a=[1,1,2,3]:

- [1,1,2,3]: sorted.

- [1,2,3,1]: 1 ≤ 2 ≤ 3 ≥ 1? No.

- [2,3,1,1]: 2 ≤ 3 ≥ 1 ≥ 1? No.

- [3,1,1,2]: 3 ≥ 1 ≤ 1 ≤ 2? No.

Only one sorted shift.

Seems like for n=4, k=2 is also not possible.

From these observations, it seems that for some values of n and k, no such array exists.

Let me try to find a general rule.

First, note that if all elements are equal, then all cyclic shifts are sorted. So, if k=n, we can simply choose an array where all elements are equal.

Similarly, if k=1, we need exactly one cyclic shift to be sorted. From the examples above, it seems possible for some n.

But for k=2 and n=3 or 4, it's not possible.

Let me think about when k=0. Wait, k must be at least 1 because the array itself is always a sorted cyclic shift if the array is sorted. Wait, no, k is at least 1 only if the array is sorted. But according to the problem, k can be from 1 to n.

Wait, in the problem statement, it says 1 ≤ k ≤ n. So, k=0 is not allowed.

But in the example, for n=3, k=2, it's impossible, so we output -1.

Let me see if I can find a pattern.

Suppose the array is sorted. Then, all cyclic shifts that are rotations of the sorted array will be sorted only if the array is strictly increasing or has some repeated elements.

Wait, in the case where all elements are equal, k=n.

In the case where the array is strictly increasing, like [1,2,3,4], only one cyclic shift is sorted: the array itself.

If there are duplicates, like [1,1,2,3], still only one sorted cyclic shift.

So, for k=1, it's easy: just have a strictly increasing array.

For k=2, I need to have exactly two sorted cyclic shifts.

Is that possible?

Let me consider n=4, k=2.

Suppose a=[1,1,2,2].

As above, only one sorted shift.

Another try: a=[1,2,1,2].

Shifts:

- [1,2,1,2]: 1 ≤ 2 ≥ 1 ≤ 2? Not sorted.

- [2,1,2,1]: 2 ≥ 1 ≤ 2 ≥ 1? Not sorted.

- [1,2,1,2]: same as first.

- [2,1,2,1]: same as second.

Only the original array is sorted, so k=1.

Another try: a=[1,2,2,1].

Shifts:

- [1,2,2,1]: 1 ≤ 2 ≤ 2 ≥ 1? Not sorted.

- [2,2,1,1]: 2 ≤ 2 ≤ 1? No.

- [2,1,1,2]: 2 ≤ 1? No.

- [1,1,2,2]: sorted.

Only one sorted shift.

Seems like for n=4, k=2 is impossible.

Wait, maybe for some n and k, it's possible.

Let me consider n=4, k=3.

If I have three sorted shifts, what would that look like?

Suppose a=[1,1,1,2].

Shifts:

- [1,1,1,2]: sorted.

- [1,1,2,1]: 1 ≤ 1 ≤ 2 ≥ 1? Not sorted.

- [1,2,1,1]: 1 ≤ 2 ≥ 1 ≤ 1? No.

- [2,1,1,1]: 2 ≥ 1 ≤ 1 ≤ 1? No.

Only one sorted shift.

Another try: a=[1,1,2,2].

As before, only one sorted shift.

Another try: a=[1,2,2,2].

Shifts:

- [1,2,2,2]: sorted.

- [2,2,2,1]: 2 ≤ 2 ≤ 2 ≥ 1? Not sorted.

- [2,2,1,2]: 2 ≤ 2 ≥ 1 ≤ 2? No.

- [2,1,2,2]: 2 ≥ 1 ≤ 2 ≤ 2? No.

Again, only one sorted shift.

Seems like it's hard to get k=3 for n=4.

Maybe it's impossible.

Wait, perhaps for some specific arrays, it's possible.

Let me think differently.

Suppose I have an array where all elements are equal except one.

For example, a=[1,1,1,2].

As above, only one sorted shift.

Alternatively, a=[1,1,2,1].

Shifts:

- [1,1,2,1]: 1 ≤ 1 ≤ 2 ≥ 1? Not sorted.

- [1,2,1,1]: 1 ≤ 2 ≥ 1 ≤ 1? No.

- [2,1,1,1]: 2 ≥ 1 ≤ 1 ≤ 1? No.

- [1,1,1,2]: sorted.

Again, only one sorted shift.

Seems like for n=4, k=2,3 are impossible.

Only k=1 and k=4 are possible.

Wait, for n=4, k=4, set all elements equal, like [1,1,1,1], and all shifts are sorted.

For n=4, k=2 seems impossible.

Similarly, for n=3, k=2 seems impossible.

So, maybe for any n, k cannot be between 1 and n-1, except for some specific cases.

Wait, let's check n=5, k=2.

Try a=[1,1,1,1,2].

Shifts:

- [1,1,1,1,2]: sorted.

- [1,1,1,2,1]: 1 ≤ 1 ≤ 1 ≤ 2 ≥ 1? Not sorted.

- [1,1,2,1,1]: 1 ≤ 1 ≤ 2 ≥ 1 ≤ 1? No.

- [1,2,1,1,1]: 1 ≤ 2 ≥ 1 ≤ 1 ≤ 1? No.

- [2,1,1,1,1]: 2 ≥ 1 ≤ 1 ≤ 1 ≤ 1? No.

Only one sorted shift.

Another try: a=[1,1,1,2,2].

Shifts:

- [1,1,1,2,2]: sorted.

- [1,1,2,2,1]: 1 ≤ 1 ≤ 2 ≤ 2 ≥ 1? Not sorted.

- [1,2,2,1,1]: 1 ≤ 2 ≤ 2 ≥ 1 ≤ 1? No.

- [2,2,1,1,1]: 2 ≤ 2 ≥ 1 ≤ 1 ≤ 1? No.

- [2,1,1,1,2]: 2 ≥ 1 ≤ 1 ≤ 1 ≤ 2? No.

Again, only one sorted shift.

Seems like for n=5, k=2 is impossible.

Wait, maybe if I make the array have more variations.

Try a=[1,2,3,2,1].

Shifts:

- [1,2,3,2,1]: 1 ≤ 2 ≤ 3 ≥ 2 ≥ 1? Not sorted.

- [2,3,2,1,1]: 2 ≤ 3 ≥ 2 ≥ 1 ≤ 1? No.

- [3,2,1,1,2]: 3 ≥ 2 ≥ 1 ≤ 1 ≤ 2? No.

- [2,1,1,2,3]: 2 ≥ 1 ≤ 1 ≤ 2 ≤ 3? No.

- [1,1,2,3,2]: 1 ≤ 1 ≤ 2 ≤ 3 ≥ 2? No.

Only the original array is sorted, so k=1.

Seems like for n=5, k=2 is still impossible.

From these observations, it seems that for any n, k can only be 1 or n, but not anything in between.

Wait, but in the example, for n=3, k=1 is possible.

For n=2, k=2 is possible with [1,1].

For n=2, k=1 is possible with [1,2].

For n=3, k=1 is possible, but k=2 is not.

For n=4, k=1 is possible, k=4 is possible, but k=2 and k=3 are not.

So, it seems that for any n, k can be 1 or n, but not anything in between.

Is that always the case?

Let me think about n=1: k=1 is possible.

n=2: k=1 and k=2 are possible.

n=3: k=1 and k=3 are possible.

n=4: k=1 and k=4 are possible.

So, perhaps for n ≥ 2, k=1 and k=n are possible, but no other k is possible.

Wait, but for n=2, k=2 is possible by setting both elements equal.

For n=3, k=3 is possible by setting all elements equal.

For n=4, k=4 is possible by setting all elements equal.

And for any n, k=1 is possible by setting the array to be strictly increasing.

Wait, but for n=2, k=1 is possible with [1,2], which is strictly increasing.

For n=3, k=1 is possible with [1,2,3], which is strictly increasing.

Similarly, for n=4, k=1 is possible with [1,2,3,4].

But in these cases, only one cyclic shift is sorted.

Wait, but for n=1, k=1 is trivially satisfied.

So, perhaps for any n, k=1 and k=n are possible, but no other k.

But in that case, for n=2, k=2 is possible by setting both elements equal.

Similarly, for n=3, k=3 is possible by setting all elements equal.

But for n=3, k=2 is impossible.

Similarly, for n=4, k=2 and k=3 are impossible.

So, perhaps the only possible k values are k=1 and k=n.

Hence, if k is not equal to 1 or n, we should output -1.

Wait, but in the example, for n=3, k=1 is possible, and for n=2, k=2 is possible.

Also, for n=3, k=2 is impossible, as per the example output.

Hence, in the program, for k >=2, if n ==k, output an array with all elements equal, else output -1.

And for k=1, output any strictly increasing array.

Wait, but in the program, for k >=2, if n ==k, output an array with all elements equal, else output -1.

For k=1, output an array like [1,2,3,...,n].

Which aligns with our observations.

So, the program seems correct.

Hence, Correctness: **True**

**Final Solution**

To solve this problem, we need to determine if there exists an array of length \( n \) such that exactly \( k \) of its cyclic shifts are sorted. If such an array exists, we output it; otherwise, we output -1.

### Approach

1. **Understanding Cyclic Shifts and Sorted Arrays:**
   - A cyclic shift of an array involves rotating its elements in a circular manner.
   - We need to ensure that exactly \( k \) out of \( n \) possible cyclic shifts of the array are sorted in non-decreasing order.

2. **Key Observations:**
   - If \( k = n \), meaning all cyclic shifts must be sorted, this is only possible if all elements in the array are equal.
   - If \( k = 1 \), we can use a strictly increasing array to ensure only one cyclic shift (the array itself) is sorted.
   - For other values of \( k \) (i.e., \( 2 \leq k < n \)), it is generally not possible to have exactly \( k \) sorted cyclic shifts for arbitrary \( n \).

3. **Solution Strategy:**
   - For \( k = n \), output an array where all elements are the same.
   - For \( k = 1 \), output a strictly increasing array.
   - For other values of \( k \), output -1 since it's not generally possible to satisfy the condition.

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        k = int(data[index + 1])
        index += 2
        if k == n:
            print(' '.join([str(1)] * n))
        elif k == 1:
            print(' '.join(map(str, range(1, n + 1))))
        else:
            print(-1)

if __name__ == "__main__":
    main()
```

### Explanation

- **Input Handling:**
  - Read all input data at once for efficiency.
  - Parse the number of test cases \( t \).
  - For each test case, read \( n \) and \( k \).

- **Condition Checks:**
  - If \( k = n \), create an array where all elements are equal (e.g., all 1s).
  - If \( k = 1 \), create a strictly increasing array from 1 to \( n \).
  - For other values of \( k \), output -1 since it's not feasible to have exactly \( k \) sorted cyclic shifts.

This approach ensures that we handle multiple test cases efficiently while adhering to the problem constraints.