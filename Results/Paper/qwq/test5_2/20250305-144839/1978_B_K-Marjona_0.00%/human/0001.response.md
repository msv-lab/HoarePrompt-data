Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he bakes n buns that he wants to sell. Normally, each bun costs a coins, but he's running a promotion to attract customers. The promotion works like this: he can choose some integer k, which can be between 0 and the minimum of n and b. For the first k buns sold, each one has a modified price: the i-th bun costs (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price of a coins each.

My task is to help Bob determine the maximum profit he can make by choosing the best k for selling all n buns.

First, I need to understand the promotion clearly. So, if he chooses k = 0, he sells all n buns at the usual price a coins each. If he chooses k = 1, he sells the first bun at b coins, and the remaining (n - 1) buns at a coins each. If k = 2, the first bun is sold at b coins, the second at (b - 1) coins, and the remaining (n - 2) buns at a coins each. This pattern continues up to k = min(n, b), where for each k, the first k buns are sold at decreasing prices starting from b down to (b - k + 1) coins, and the rest at a coins each.

The goal is to maximize the total profit, which is the sum of the prices of all buns sold.

I need to find the optimal k that maximizes this total profit.

Let me think about when it's beneficial to choose a higher k or stick with k = 0.

First, if b <= a, meaning the modified price for the first bun is less than or equal to the usual price, there's no benefit in choosing k > 0 because selling any bun at a modified price lower than a wouldn't increase the profit. In fact, it would decrease it. So, in this case, the maximum profit is simply n * a.

On the other hand, if b > a, there might be some benefit in choosing k > 0 because the first few buns could be sold at prices higher than a, increasing the total profit.

But, as k increases, the prices for the first k buns decrease gradually. So, there must be an optimal k where the sum of the modified prices for the first k buns plus the usual prices for the remaining buns is maximized.

I need to find this optimal k.

Let me try to formularize the total profit for a given k.

Total profit P(k) = sum of prices of the first k buns + sum of prices of the remaining (n - k) buns.

The sum of the first k buns' prices is the sum of an arithmetic series starting from b down to (b - k + 1).

The formula for the sum of the first k terms of an arithmetic series is:

sum = (k / 2) * (first term + last term)

Here, first term is b, and last term is (b - k + 1).

So, sum of first k buns = (k / 2) * (b + (b - k + 1)) = (k / 2) * (2b - k + 1)

The sum of the remaining (n - k) buns = (n - k) * a

Therefore, total profit P(k) = (k / 2) * (2b - k + 1) + (n - k) * a

I need to maximize P(k) over k from 0 to min(n, b).

I need to find the value of k that maximizes P(k).

Let me consider P(k) as a function of k and see how it behaves.

P(k) = (k / 2) * (2b - k + 1) + (n - k) * a

Let me simplify this:

P(k) = (k / 2) * (2b - k + 1) + n a - k a

P(k) = (k b - (k^2)/2 + k/2) + n a - k a

P(k) = - (k^2)/2 + (b + 1/2 - a) k + n a

This is a quadratic function in terms of k: P(k) = A k^2 + B k + C, where

A = -1/2

B = b + 0.5 - a

C = n a

Since A is negative, this is an downward-opening parabola, meaning it has a maximum at its vertex.

The maximum occurs at k = -B / (2 A)

Plugging in A and B:

k = -(b + 0.5 - a) / (2 * (-1/2)) = (b + 0.5 - a) / 1 = b + 0.5 - a

But k must be an integer between 0 and min(n, b).

So, the optimal k is floor(b + 0.5 - a), but it can't exceed min(n, b) or go below 0.

Wait, but k has to be an integer, so I need to consider k = floor(b + 0.5 - a) and k = ceil(b + 0.5 - a), and choose the one that gives the higher P(k).

But, considering that k must be between 0 and min(n, b), I need to ensure that the chosen k is within these bounds.

However, since n and b can be up to 1e9, and t can be up to 1e4, I need an efficient way to compute this.

But perhaps there's a better way to approach this.

Let me consider the difference in profit when increasing k by 1.

Let's compute P(k+1) - P(k):

= [ (k+1)/2 * (2b - (k+1) + 1) + (n - (k+1)) * a ] - [ k/2 * (2b - k + 1) + (n - k) * a ]

Simplify:

= [ (k+1)/2 * (2b - k) ] + [ (n - k - 1) * a ] - [ k/2 * (2b - k + 1) ] - [ (n - k) * a ]

= [ (k+1)(2b - k)/2 ] + [ n a - k a - a ] - [ k(2b - k + 1)/2 ] - [ n a - k a ]

= [ (k+1)(2b - k)/2 - k(2b - k + 1)/2 ] + [ n a - k a - a - n a + k a ]

= [ (k+1)(2b - k) - k(2b - k + 1) ] / 2 + [ -a ]

= [ (2b(k+1) - k(k+1) - 2b k + k(2b - k + 1)) ] / 2 - a

Wait, that seems messy. Maybe there's a better way.

Let me think differently.

I can consider that for each k, the profit is the sum of the first k modified prices plus (n - k) * a.

I can compute the sum of the first k modified prices as the sum from i=1 to k of (b - i + 1) = k b - (1 + 2 + ... + k) + k = k b - k(k+1)/2 + k = k(b - k/2 - 0.5 + 1) = k(b - k/2 + 0.5)

Wait, earlier I had sum of first k modified prices as (k / 2) * (2b - k + 1), which is correct.

So, P(k) = (k / 2) * (2b - k + 1) + (n - k) * a

I can think of choosing k to maximize P(k).

I can iterate k from 0 to min(n, b), compute P(k), and pick the maximum.

But with t up to 1e4 and n, b up to 1e9, I need a faster way than iterating through all possible k for each test case.

I need to find the optimal k directly.

Given that P(k) is a quadratic function in k, and it's a downward-opening parabola, the maximum occurs at the vertex.

From earlier, k_opt = b + 0.5 - a

But k has to be an integer between 0 and min(n, b).

So, I can compute k_opt, then set k to be floor(k_opt) and ceil(k_opt), within the bounds, and choose the one that gives the higher P(k).

But since k must be an integer, I can compute k_opt, round it to the nearest integer, and adjust within bounds.

Wait, but in programming, floating points might not be precise, especially with large inputs.

Maybe there's a better way to determine the optimal k without using floating points.

Let me consider the difference P(k+1) - P(k):

P(k+1) - P(k) = [ (k+1)/2 * (2b - (k+1) + 1) + (n - k - 1) * a ] - [ k/2 * (2b - k + 1) + (n - k) * a ]

Simplify:

= [ (k+1)/2 * (2b - k) ] + [ (n - k - 1) * a ] - [ k/2 * (2b - k + 1) ] - [ (n - k) * a ]

= [ (k+1)(2b - k)/2 - k(2b - k + 1)/2 ] + [ -a ]

= [ (k+1)(2b - k) - k(2b - k + 1) ] / 2 - a

Expand (k+1)(2b - k):

= 2b(k+1) - k(k+1) = 2b k + 2b - k^2 - k

And k(2b - k + 1) = 2b k - k^2 + k

So, (k+1)(2b - k) - k(2b - k + 1) = (2b k + 2b - k^2 - k) - (2b k - k^2 + k) = 2b - 2k

Thus, P(k+1) - P(k) = (2b - 2k)/2 - a = (b - k) - a

Therefore, P(k+1) - P(k) = b - k - a

This is useful!

So, P(k+1) - P(k) = b - k - a

This tells me when to increase k:

- If b - k - a > 0, then P(k+1) > P(k), so increasing k increases the profit.

- If b - k - a < 0, then P(k+1) < P(k), so increasing k decreases the profit.

- If b - k - a = 0, then P(k+1) = P(k), so it doesn't matter.

So, to maximize P(k), I should increase k as long as b - k - a > 0.

Set b - k - a > 0 => k < b - a

So, as long as k < b - a, P(k+1) > P(k), and I should increase k.

When k = b - a, P(k+1) - P(k) = b - (b - a) - a = 0, so P(k+1) = P(k).

Beyond that, P(k+1) - P(k) becomes negative.

Therefore, the optimal k is k = b - a, as long as k <= min(n, b).

But k must be >= 0, so k = max(0, b - a)

But wait, if b - a < 0, then k = 0.

But from earlier, if b <= a, then k = 0 is optimal.

If b > a, then k = b - a is optimal, but k cannot exceed min(n, b).

So, the optimal k is min(n, b, b - a).

Wait, but b - a could be greater than b, but in reality, k cannot exceed b.

Wait, b - a can be greater than b if a < 0, but in the problem, a >= 1, b >=1, n >=1.

So, b - a can be less than b.

Wait, no, b - a can be less than b if a > 0, which it is.

Wait, b - a can be negative if b < a.

But in that case, k = 0 is optimal.

So, the optimal k is min(n, b, max(0, b - a))

Wait, but from the earlier analysis, P(k+1) - P(k) = b - k - a

So, increasing k as long as b - k - a > 0, i.e., k < b - a

So, the optimal k is the maximum of 0 and min(n, b, b - a)

Wait, but b - a could be greater than b if a < 0, but a >=1, so b - a <= b -1 < b.

Wait, no, if b = 2, a =1, b - a =1 < b=2.

If b=5, a=3, b - a=2 < b=5.

So, b - a <= b -1 < b.

Therefore, the optimal k is min(n, b, b - a)

But k cannot be negative, so k = min(n, b, max(0, b - a))

Wait, but b - a can be negative, if b < a.

So, k = min(n, b, b - a) if b - a >=0, else k=0.

In other words, k = min(n, b, b - a) if b >= a, else k=0.

Alternatively, k = min(n, b - a, b)

But ensure that k >=0.

Wait, in code, it's better to write k = min(n, b - a, b)

But since b - a can be less than 0, and k cannot be negative, I should set k = max(0, min(n, b - a, b))

But actually, since min(n, b - a, b) could be negative only if b - a <0, but min(n, b, b - a) will be b - a if b - a < b and b - a <n, but if b - a <0, then min(n, b, b -a) = b -a <0, so k = max(0, min(n, b, b -a))

Therefore, the optimal k is k = max(0, min(n, b, b - a))

Then, the total profit is P(k) = (k / 2) * (2b - k +1) + (n -k) * a

This seems efficient to compute, and since it's constant time per test case, it should work within time limits.

Let me verify this with the sample inputs.

First sample input:

4 4 5

n=4, a=4, b=5

k = max(0, min(4,5,5-4)) = max(0, min(4,5,1)) = max(0,1) =1

P(1) = (1/2)*(2*5 -1 +1) + (4-1)*4 = (1/2)*(10) + 3*4 = 5 + 12 =17

Which matches the first sample output.

Second sample input:

5 5 9

n=5, a=5, b=9

k = max(0, min(5,9,9-5)) = max(0, min(5,9,4)) =4

P(4) = (4/2)*(2*9 -4 +1) + (5-4)*5 = 2*(18 -4 +1) +1*5 =2*(15) +5 =30+5=35

Which matches the second sample output.

Third sample input:

10 10 5

n=10, a=10, b=5

k = max(0, min(10,5,5-10)) = max(0, min(10,5,-5)) = max(0,-5) =0

P(0) =0*(something) +10*10=100

Which matches the third sample output.

Seems correct.

So, in code, I can implement this logic.

But in the given code, it's written as:

k = min(n, b - a)

if b <= a:

print(a * n)

else:

print((b + (b - k +1))//2 *k + (n -k)*a)

Wait, according to my earlier analysis, k should be min(n, b, b -a)

But in the code, it's min(n, b -a)

Wait, but in my analysis, it's max(0, min(n, b, b -a))

But in the code, it's min(n, b -a), and then if b <=a, k=0

Wait, if b <=a, then k=0, else k=min(n, b -a)

Wait, but min(n, b -a) could be negative if b -a <0, but since b <=a in that case, k=0

But in code, min(n, b -a) will be negative if b -a <0, but in python, min(n, negative number) will return the negative number, but since k is used in sum formula, we need to ensure k >=0

So, in code, it's better to set k = max(0, min(n, b -a))

But in the given code, it's min(n, b -a), and if b <=a, print(a*n), else compute P(k)

So, when b <=a, k=0 is used implicitly by printing a*n

Otherwise, k = min(n, b -a), and compute P(k)

Wait, but according to my earlier analysis, k = min(n, b, b -a)

But min(n, b, b -a) is equal to min(n, min(b, b -a))

If b <=a, then b -a <=0, so min(b, b -a) = b -a <=0, so k=0

If b >a, then b -a >0, so min(b, b -a) = b -a

Then min(n, b -a), which is appropriate.

Hence, the given code seems correct.

But to be thorough, let's check with some test cases.

Test case 1:

n=4, a=4, b=5

k = min(4,5-4)= min(4,1)=1

P(1)= (5 + (5 -1 +1))//2 *1 + (4-1)*4= (5+5)//2 *1 +3*4=5 +12=17

Correct.

Test case 2:

n=5, a=5, b=9

k = min(5,9-5)= min(5,4)=4

P(4)=(9 + (9-4 +1))//2 *4 + (5-4)*5= (9+6)//2 *4 +1*5= (15)//2 *4 +5=7*4 +5=28+5=33

Wait, but in the sample input, it's 35.

Wait, what's going on here.

Wait, let's recalculate P(4):

P(4)=(9 + (9 -4 +1))//2 *4 + (5-4)*5= (9 +6)//2 *4 +1*5= (15)//2 *4 +5=7*4 +5=28+5=33

But according to earlier, P(4)=35.

Wait, discrepancy here.

Wait, perhaps I made a mistake in the formula.

Wait, in the code, it's (b + (b -k +1))//2 *k + (n -k)*a

But in my earlier derivation, sum of first k modified prices is (k/2)*(2b -k +1)

Wait, but in code, it's (b + (b -k +1))//2 *k

Which is same as (2b -k +1)//2 *k

But in integer division, it's equivalent to floor((2b -k +1)/2)*k

But in my earlier formula, it's (k/2)*(2b -k +1)

In integer division, it should be floor(k*(2b -k +1)/2)

But in code, it's floor((2b -k +1)/2)*k

Which may not be exactly the same if k is odd.

Wait, perhaps there's a mistake in the code.

Let me check with sample input 2.

n=5, a=5, b=9

k=4

sum of first 4 modified prices should be 9 +8 +7 +6 =30

But according to the code: (9 + (9 -4 +1))//2 *4= (9 +6)//2 *4= (15)//2 *4=7*4=28

Which is 28, but actual sum is 30.

Wait, that's incorrect.

So, the code is computing floor((b + (b -k +1))/2) *k

But the actual sum is (k/2)*(2b -k +1)

Which is floor((k*(2b -k +1))/2)

These two are not always equal, especially when k is even.

Wait, let's see:

(k/2)*(2b -k +1) = (k*(2b -k +1)) / 2

In integer division, it's floor((k*(2b -k +1))/2)

While in code, it's floor((b + (b -k +1))/2) *k

Which is floor((2b -k +1)/2) *k

These are different when k is even.

Wait, for k even:

floor((k*(2b -k +1))/2) = (k*(2b -k +1)) //2

floor((2b -k +1)/2) *k = floor((2b -k +1)/2) *k

These are equal when k is even.

When k is odd:

floor((k*(2b -k +1))/2) = floor((k*(2b -k +1))/2)

floor((2b -k +1)/2) *k = floor((2b -k +1)/2) *k

These might differ.

Wait, let's take an example.

Let k=4, b=9

sum = (4/2)*(2*9 -4 +1) =2*(18 -4 +1)=2*15=30

In code: floor((9 + (9 -4 +1))/2)*4= floor(15/2)*4=7*4=28

Difference of 2.

So, the code is computing 28, but actual sum is 30.

Wait, that's a problem.

So, the formula in the code is incorrect for even k.

Wait, no, for k=4, which is even, the formula in the code gives 28, but the actual sum is 30.

Wait, perhaps I made a mistake in the formula.

Wait, the sum of an arithmetic series is (number of terms)/2 * (first term + last term)

Here, first term is b=9, last term is b -k +1=9-4+1=6

So, sum = k/2 * (b + (b -k +1)) =4/2*(9 +6)=2*15=30

But in code, it's (b + (b -k +1))//2 *k= (9+6)//2 *4=15//2*4=7*4=28

The issue is that (9+6)=15, 15//2=7, then 7*4=28

But the correct sum is 30.

So, the formula in the code is incorrect for this case.

Wait, perhaps I need to adjust the formula to avoid integer division errors.

Maybe compute floor((k*(2b -k +1))/2)

But in code, it's implemented as (b + (b -k +1))//2 *k, which for k even, may not be equal to floor((k*(2b -k +1))/2)

So, the code is incorrect in this aspect.

Alternative approach: compute the sum of the first k modified prices correctly.

Given that k can be up to 1e9, and t up to 1e4, I need an efficient way.

Perhaps I need to compute sum = k*b - (k*(k+1))/2 +k

Wait, earlier I had sum = (k/2)*(2b -k +1)

Which is equal to k*b - (k*(k+1))/2 +k

Wait, no:

(k/2)*(2b -k +1) = k*b - (k^2)/2 + k/2

Wait, but in integer division, need to be careful.

Perhaps it's better to compute sum = (k*(2*b -k +1))//2

This should be equivalent to floor((k*(2b -k +1))/2)

In code, that would be (k*(2*b -k +1))//2

But in the given code, it's (b + (b -k +1))//2 *k, which is ((2*b -k +1))//2 *k

Which is different from (k*(2*b -k +1))//2

Wait, no, (b + (b -k +1))//2 *k = ((2*b -k +1))//2 *k

Which is different from (k*(2*b -k +1))//2

So, the code is incorrect.

For example, with k=4, b=9:

Correct sum: (4*(2*9 -4 +1))//2=(4*15)//2=60//2=30

Code sum: ((2*9 -4 +1)//2)*4=(15//2)*4=7*4=28

Difference of 2.

Hence, the code is incorrect.

So, to fix this, I need to compute (k*(2*b -k +1))//2

Instead of ((2*b -k +1)//2)*k

Because the former correctly computes the sum of the arithmetic series.

Hence, the given code is incorrect.

Therefore, Correctness: False

**Final Solution**

To solve this problem, we need to determine the maximum profit Bob can obtain by selling all his buns with a promotional pricing strategy. We need to carefully handle the calculation to ensure integer division is managed correctly for large inputs.

## Approach

1. **Understanding the Promotion:**
   - Bob can choose an integer \( k \) (0 ≤ \( k \) ≤ min(\( n \), \( b \))) where \( k \) is the number of buns sold at a modified price.
   - The price of the \( i \)-th bun (1 ≤ \( i \) ≤ \( k \)) is \( b - i + 1 \) coins.
   - The remaining \( n - k \) buns are sold at the usual price \( a \) coins each.

2. **Determine the Optimal \( k \):**
   - If \( b \) ≤ \( a \), it's better to sell all buns at the usual price.
   - If \( b \) > \( a \), we need to find the optimal \( k \) that maximizes the profit.

3. **Calculate the Profit:**
   - For a chosen \( k \), the profit from the first \( k \) buns is the sum of an arithmetic series: \( \frac{k}{2} \times (b + (b - k + 1)) \).
   - The profit from the remaining \( n - k \) buns is \( (n - k) \times a \).
   - The total profit is the sum of these two.

4. **Optimal \( k \) Calculation:**
   - The optimal \( k \) is min(\( n \), \( b - a \)), but we must ensure it doesn't exceed \( n \) or \( b \).
   - Use integer division carefully to handle large numbers accurately.

## Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    idx = 1
    for _ in range(t):
        n = int(data[idx])
        a = int(data[idx+1])
        b = int(data[idx+2])
        idx += 3
        if b <= a:
            print(n * a)
        else:
            k = min(n, b - a)
            # Correct sum calculation for the first k buns
            sum_k = (k * (2 * b - k + 1)) // 2
            remaining = (n - k) * a
            print(sum_k + remaining)

if __name__ == "__main__":
    main()
```

## Explanation

1. **Reading Input:**
   - Read all input data at once for efficiency.
   - Parse the number of test cases \( t \).

2. **Processing Each Test Case:**
   - For each test case, read \( n \), \( a \), and \( b \).
   - If \( b \) ≤ \( a \), selling all buns at the usual price \( a \) is optimal.
   - If \( b \) > \( a \), compute the optimal \( k \) as min(\( n \), \( b - a \)).
   - Calculate the sum of the first \( k \) buns using the correct formula for the sum of an arithmetic series: \( \frac{k}{2} \times (2b - k + 1) \).
   - Calculate the profit from the remaining \( n - k \) buns.
   - Output the total profit.

This approach ensures that we handle large inputs efficiently and correctly compute the maximum profit using integer arithmetic.