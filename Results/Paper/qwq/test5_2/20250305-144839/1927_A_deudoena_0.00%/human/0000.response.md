Alright, I have this problem to solve. Let's see what it's asking for. So, there's a strip of cells, each either white ('W') or black ('B'). I need to choose one continuous segment to paint white, and after painting, all 'B's in that segment become 'W's, and the 'W's stay the same. The goal is to make the entire strip white, and I need to find the minimum length of such a segment.

First, I need to understand what it means to paint a segment white. It means that in that chosen segment, any 'B' will be changed to 'W'. So, to make the entire strip white, I need to cover all the 'B's in the strip with this one segment.

Wait, but that seems too straightforward. If I just paint the entire strip white, that would certainly make everything white, but that's not necessarily the minimal segment.

Let me think about it differently. If I choose a segment that covers all the 'B's, then after painting, all 'B's in that segment become 'W's, and since the segment covers all 'B's, the entire strip becomes white.

So, the minimal segment would be the smallest segment that includes all the 'B's.

But is that correct? Let me consider an example.

Take the first example from the input:

n = 6

s = W B B W B W

I need to find the minimal segment to paint white so that all cells become white.

Let's identify the positions of 'B's:

Positions: 1: W, 2: B, 3: B, 4: W, 5: B, 6: W

So 'B's are at positions 2, 3, and 5.

So, to cover all 'B's, I need to cover positions 2 to 5, which is a segment of length 4.

According to the example, the output is 4, which matches this.

Another example:

n = 1

s = B

Clearly, I need to paint the entire segment, which is of length 1.

Another one:

n = 2

s = W B

'B' is at position 2, so I need to paint at least position 2, which is length 1.

Another one:

n = 3

s = B B W

'B's are at positions 1 and 2, so painting positions 1 to 2 (length 2) would suffice.

Wait, but according to the example, the output is 2, which matches.

Another one:

n = 4

s = B W W B

'B's are at positions 1 and 4.

So, to cover both, I need to paint from 1 to 4, which is length 4.

Output in the example is 4, which matches.

So, it seems that the minimal segment to cover all 'B's is indeed the solution.

But wait, is there any case where this might not hold?

Let me think about a strip like:

n = 5

s = B W B W B

If I paint from position 1 to 5, that's length 5, but is there a shorter segment?

If I paint from position 1 to 3, that covers the first three cells, changing B W B to W W W, but the last two cells are W B, so after painting, it would be W W W W B, which is not all white. So, that's not sufficient.

If I paint from position 2 to 4: W B W to W W W, so the strip becomes B W W W B, which still has 'B's.

If I paint from position 3 to 5: B W B to W W W, so the strip becomes W W W W W, which is all white. That's length 3.

Is there a shorter segment? Let's try length 2:

Paint positions 3 and 4: B W to W W, so the strip becomes W W W W B, which still has a 'B'.

Paint positions 4 and 5: W B to W W, so the strip becomes W W B W W, still has a 'B'.

Paint positions 2 and 3: W B to W W, so the strip is B W W W B, still has 'B's.

So, no, length 3 is indeed the minimal in this case.

So, it seems that the minimal segment to cover all 'B's is the correct approach.

Now, how do I implement this?

I need to find the leftmost 'B' and the rightmost 'B', and the minimal segment that covers all 'B's is from the leftmost 'B' to the rightmost 'B'.

So, in the first example, leftmost 'B' is at position 2, rightmost 'B' is at position 5, so the segment from 2 to 5, length 4.

In the second example, n=1, s=B, leftmost and rightmost 'B' are at position 1, so length 1.

In the third example, n=2, s=WB, leftmost 'B' at position 2, rightmost 'B' at position 2, so length 1.

In the fourth example, n=3, s=BBW, leftmost 'B' at position 1, rightmost 'B' at position 2, so length 2.

In the fifth example, n=4, s=BWWB, leftmost 'B' at position 1, rightmost 'B' at position 4, so length 4.

Seems consistent.

But wait, what if there is only one 'B'? Like n=1, s=B, or n=2, s=WB.

In those cases, the minimal segment is just the position of that single 'B', which makes sense.

So, general approach:

- Find the leftmost 'B' position (ind1)

- Find the rightmost 'B' position (ind2)

- The minimal segment to cover all 'B's is from ind1 to ind2, inclusive.

- The length of this segment is ind2 - ind1 + 1

Wait, but in the program given, it's doing something different.

Let's look at the provided program:

def func():

inpstr = input()

ind1 = 0

ind2 = 0

outind = 0

for (i, j) in enumerate(inpstr):

if j == 'B':

ind1 = i

break

for i in range(len(inpstr)):

if inpstr[-i - 1] == 'B':

ind2 = i

break

print(len(inpstr) - ind2 - ind1)

So, it's finding the leftmost 'B' position (ind1) correctly.

Then, it's finding the rightmost 'B' position by iterating from the end, and storing the distance from the end (ind2).

Then, it's computing len(inpstr) - ind2 - ind1

Wait, is that correct?

Let's see with the first example:

n=6, s=WBBWBW

leftmost 'B' at position 1 (0-based: i=1)

rightmost 'B' at position 4 (0-based: i=4)

len(inpstr) = 6

ind1 = 1

ind2 = 6 - 4 -1 = 1 (since -i-1 for i=2, because 6-2-1=3, but wait, this seems off)

Wait, let's simulate it.

for i in range(6):

if inpstr[-i-1] == 'B':

ind2 = i

break

So, i starts from 0:

- i=0: inpstr[-1] = 'W' → not 'B'

- i=1: inpstr[-2] = 'B' → 'B' found, ind2 = 1

So, ind2 =1

Then, len(inpstr) - ind2 - ind1 = 6 -1 -1 =4, which matches the expected output.

Another example:

n=1, s=B

ind1=0 (since s[0]='B')

ind2=0 (since s[-1]='B', i=0)

len(s) - ind2 - ind1 =1 -0 -0=1, which is correct.

Another example:

n=2, s=WB

ind1=1 (s[1]='B')

ind2=0 (s[-1]='B', i=0)

len(s) - ind2 - ind1 =2 -0 -1=1, which is correct.

Another example:

n=3, s=BBW

ind1=0 (s[0]='B')

ind2=1 (s[-2]='B', i=1)

len(s) - ind2 - ind1=3 -1 -0=2, which is correct.

So, it seems that len(s) - ind2 - ind1 gives the correct length.

But why?

Wait, ind1 is the leftmost 'B' index.

ind2 is the distance from the end to the rightmost 'B', starting from 0.

So, rightmost 'B' index is len(s) - ind2 -1.

Wait, in the first example, ind2=1, len(s)=6, rightmost 'B' index=6-1-1=4, which is correct.

So, the segment length is rightmost 'B' index - leftmost 'B' index +1.

Which is (len(s) - ind2 -1) - ind1 +1 = len(s) - ind2 -1 - ind1 +1 = len(s) - ind2 - ind1.

Yes, that makes sense.

So, len(s) - ind2 - ind1 gives the correct segment length.

Therefore, the program is correct.

Wait, but is there any edge case where this might fail?

Let's consider n=1, s=B.

ind1=0, ind2=0, len(s)-ind2-ind1=1-0-0=1, which is correct.

n=1, s=W.

But according to the problem, it's guaranteed that there is at least one 'B', so s=W is not possible.

n=2, s=WB.

ind1=1, ind2=0, len(s)-0-1=1, which is correct.

n=2, s=BB.

ind1=0, ind2=0, len(s)-0-0=2, which is correct.

n=3, s=BWB.

ind1=0, ind2=1 (since s[-2]='B'), len(s)-1-0=2, which is correct (segment from 0 to 1, covering all 'B's at 0,2, but wait, to cover 'B's at 0 and 2, segment from 0 to 2 is needed, which is length 3.

Wait, this seems incorrect.

Wait, in s=BWB, 'B's are at positions 0 and 2.

So, to cover both, need to paint from 0 to 2, which is length 3.

But according to the program:

ind1=0, ind2=1 (since s[-2]='B'), len(s)-1-0=2, which is incorrect, should be 3.

Wait, this seems like a mistake.

Wait, in s=BWB, len(s)=3.

ind1=0 (first 'B' at position 0)

ind2=1 (since s[-2]='B')

len(s)-ind2-ind1=3-1-0=2, but actual minimal segment to cover 'B's at 0 and 2 is from 0 to 2, which is length 3.

So, the program gives 2, which is incorrect.

Wait, but according to the problem, painting a segment will change all 'B's in that segment to 'W's, and 'W's remain 'W's.

So, if I paint from 0 to 1 (length 2), 'B's at 0 and 1 become 'W's, but 'B' at 2 remains 'B', so it's not fully white.

So, the program is incorrect in this case.

Wait, but in the earlier examples, it seemed correct.

Is there a mistake in the program?

Let's see what's wrong.

The program calculates len(s) - ind2 - ind1, where ind1 is the leftmost 'B' index, and ind2 is the distance from the end to the rightmost 'B'.

But in s=BWB, len(s)=3, ind1=0, ind2=1, len(s)-ind2-ind1=2, but actual minimal segment is 3.

So, it's miscalculating.

What's the issue?

Wait, perhaps the formula is wrong.

The correct segment length should be rightmost 'B' index - leftmost 'B' index +1.

In s=BWB, rightmost 'B' at index 2, leftmost at index 0, so 2-0+1=3.

But according to the program, len(s)-ind2-ind1=3-1-0=2, which is incorrect.

So, the program is incorrect.

What's the mistake in the formula?

len(s) - ind2 - ind1 is not equal to rightmost - leftmost +1.

Wait, rightmost 'B' index is len(s) - ind2 -1, and leftmost is ind1.

So, segment length should be rightmost - leftmost +1 = (len(s) - ind2 -1) - ind1 +1 = len(s) - ind2 - ind1.

Wait, in the s=BWB case, len(s)-ind2-ind1=3-1-0=2, but actual length is 3.

Wait, that seems inconsistent.

Wait, perhaps I'm miscounting.

Wait, in s=BWB, indices are 0:B, 1:W, 2:B.

Leftmost 'B' at 0, rightmost at 2, so segment from 0 to 2, length 3.

len(s)-ind2-ind1=3-1-0=2, which is incorrect.

So, the formula is wrong.

The correct formula should be rightmost - leftmost +1.

In this case, rightmost=2, leftmost=0, 2-0+1=3.

But len(s)-ind2-ind1=3-1-0=2.

So, the program is incorrect.

What's the mistake?

Wait, perhaps ind2 needs to be adjusted differently.

In the program, ind2 is found by iterating from the end:

for i in range(len(inpstr)):

if inpstr[-i-1] == 'B':

ind2 = i

break

In s=BWB, inpstr[-1]='W', i=0 → not 'B'

inpstr[-2]='B', i=1 → ind2=1

So, rightmost 'B' is at position len(s) - ind2 -1 =3 -1 -1=1, but actually it's at position 2.

Wait, that's incorrect.

Wait, perhaps there's a mistake in interpreting ind2.

Let me re-examine.

In the program, ind2 is the offset from the end where 'B' is found.

So, ind2=1 means the rightmost 'B' is at position len(s) - ind2 -1.

In s=BWB, len(s)=3, ind2=1, so rightmost 'B' at 3-1-1=1, but actually it's at position 2.

Wait, no, s[-2]='B', which is position 2 (0-based indexing).

Wait, s[-1]=position 2, s[-2]=position 1, s[-3]=position 0.

Wait, in Python, negative indexing starts from -1 for the last element.

So, in s=BWB, s[-1]='W', s[-2]='B', s[-3]='B'.

So, when iterating:

i=0: inpstr[-1]='W' → not 'B'

i=1: inpstr[-2]='B' → ind2=1

So, rightmost 'B' is at position len(s) - ind2 -1 =3 -1 -1=1, but actually it's at position 2.

Wait, that seems off.

Wait, perhaps the formula to calculate rightmost 'B' index is wrong.

Wait, s[-2] is position 1 (since s[1]='W'), but in s=BWB, positions are:

0:B, 1:W, 2:B

So, s[-2]='W' which is position 1, but the rightmost 'B' is at position 2.

Wait, s[-1]='W' (position 2), s[-2]='B' (position 1), s[-3]='B' (position 0).

Wait, I think there's confusion in the indexing.

Wait, maybe it's better to directly find the rightmost 'B' index.

In standard indexing, left to right: 0,1,2 for n=3.

In negative indexing: -1 is position 2, -2 is position 1, -3 is position 0.

So, in s=BWB, 'B' at positions 0 and 2.

When searching from the end, ind2 is set to 1 because s[-2]='B'.

Then, rightmost 'B' index is len(s) - ind2 -1 =3 -1 -1=1, but actually the rightmost 'B' is at position 2.

This seems incorrect.

Wait, no, s[-1]='W' (position 2), which is not 'B'.

So, ind2 remains 0? Wait, in the code, if s[-1]='W', i=0, not 'B'.

Then i=1, s[-2]='B', so ind2=1.

Then, rightmost 'B' index is len(s) - ind2 -1 =3 -1 -1=1, but actual rightmost 'B' is at position 2.

This is incorrect.

So, the formula is wrong.

The rightmost 'B' index should be len(s) - ind2 -1, but in this case, it's giving 1, while actual is 2.

Wait, s[-2]='B', which is position 1, but there is also a 'B' at position 2.

Wait, s[-1]='W', so ind2=1.

Wait, perhaps I need to find the rightmost 'B' correctly.

Wait, maybe the way ind2 is calculated is wrong.

Perhaps I should iterate from the end and find the first 'B', which is at s[-1], but in this case s[-1]='W', so ind2 would be set based on s[-2]='B', which is position 1, but there is a 'B' at position 2.

Wait, s=BWB:

positions: 0:B, 1:W, 2:B

So, to cover all 'B's, need to cover from 0 to 2, length 3.

But according to the program:

ind1=0 (first 'B' at position 0)

ind2=1 (since s[-2]='B', i=1)

len(s)-ind2-ind1=3-1-0=2, which is incorrect.

So, the program is wrong.

What's the mistake?

Perhaps the formula for rightmost 'B' index is incorrect.

Rightmost 'B' index should be len(s) - ind2 -1, but in this case, it's 1, while actual is 2.

Wait, s[-1]='W', so ind2 is set based on s[-2]='B', i=1, rightmost 'B' index=len(s)-1-1=1, but actually it's at position 2.

Wait, perhaps I need to adjust the formula.

Wait, maybe rightmost 'B' index is len(s) - ind2 -1 when ind2 is the offset from the end.

Wait, in s=BWB:

- leftmost 'B' at position 0

- rightmost 'B' at position 2

- so, len(s)=3, ind1=0, ind2=1 (since s[-2]='B')

- len(s)-ind2-ind1=3-1-0=2, but actual segment length needed is 3.

So, the formula is incorrect.

Alternative approach: directly find the minimum segment that covers all 'B's.

So, find the leftmost 'B' and the rightmost 'B', and the segment from leftmost to rightmost 'B' inclusive.

Then, the length is rightmost - leftmost +1.

In s=BWB, rightmost 'B' at position 2, leftmost at 0, so 2-0+1=3.

In the program, it's calculating len(s)-ind2-ind1, which is 3-1-0=2, which is wrong.

So, the program is incorrect.

What's the mistake?

Perhaps the way ind2 is calculated is wrong.

Instead of setting ind2 to i, it should be set to the actual index.

Wait, perhaps I should find the rightmost 'B' index directly.

Alternative implementation:

- Find the leftmost 'B' index.

- Find the rightmost 'B' index.

- Compute the segment length as rightmost - leftmost +1.

In s=BWB, that would be 2-0+1=3, which is correct.

In n=6, s=WBBWBW:

'B's at positions 1,2,4

So, leftmost=1, rightmost=4, length=4-1+1=4, which matches the example output.

In n=3, s=BBW:

'B's at positions 0,1

leftmost=0, rightmost=1, length=1-0+1=2, which matches the example.

In n=4, s=BWWB:

'B's at positions 0,3

length=3-0+1=4, which matches the example.

In n=2, s=WB:

'B' at position 1

leftmost=1, rightmost=1, length=1-1+1=1, which is correct.

In n=1, s=B:

leftmost=0, rightmost=0, length=1, which is correct.

So, the correct formula is rightmost - leftmost +1.

But in the program, it's len(s)-ind2-ind1.

Which, as we saw in s=BWB, gives 3-1-0=2, but correct is 3.

So, the program is incorrect.

Is there a way to fix the program?

Yes, instead of ind2 being the offset from the end, perhaps find the rightmost 'B' index directly.

Alternative code:

def func():

inpstr = input()

n = len(inpstr)

ind1 = -1

ind2 = -1

for i in range(n):

if inpstr[i] == 'B':

if ind1 == -1:

ind1 = i

ind2 = i

if ind1 != -1:

print(ind2 - ind1 +1)

else:

print(0)

But according to the problem, there is at least one 'B', so ind1 will be set.

This would correctly compute the minimal segment length.

So, the original program is incorrect.

Therefore, Correctness: **False**

**Final Solution**

To solve this problem, we need to determine the minimum length of a continuous segment of cells that should be painted white to make the entire strip white. The strip consists of cells that are either white ('W') or black ('B'), and we need to handle multiple test cases.

### Approach

1. **Identify the Positions of 'B's:** 
   - Find the leftmost 'B' and the rightmost 'B' in the strip.
   
2. **Calculate the Minimum Segment Length:**
   - The minimum segment that needs to be painted white is the segment from the leftmost 'B' to the rightmost 'B', inclusive.
   - The length of this segment is given by: `(rightmost 'B' index - leftmost 'B' index + 1)`.

### Solution Code

```python
def func():
    inpstr = input()
    n = len(inpstr)
    ind1 = -1
    ind2 = -1
    for i in range(n):
        if inpstr[i] == 'B':
            if ind1 == -1:
                ind1 = i
            ind2 = i
    if ind1 != -1:
        print(ind2 - ind1 + 1)
    else:
        print(0)

# Reading the number of test cases
import sys
input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
for _ in range(t):
    n = int(data[index])
    s = data[index + 1]
    index += 2
    # Simulate function calls with the input data
    # Here, we would call the function and pass the string 's'
    # But since the function reads from input, we need to redirect input
    import sys
    sys.stdin = sys.__stdin__
    import StringIO
    sys.stdin = StringIO.StringIO(s + '\n')
    func()
```

### Explanation

1. **Finding the Leftmost and Rightmost 'B's:**
   - We iterate through the string to find the first occurrence of 'B' (leftmost) and the last occurrence of 'B' (rightmost).

2. **Calculating the Segment Length:**
   - The minimal segment that needs to be painted white is from the leftmost 'B' to the rightmost 'B', inclusive.
   - The length of this segment is calculated as `(rightmost index - leftmost index + 1)`.

3. **Handling Multiple Test Cases:**
   - Read the number of test cases and each test case's input.
   - For each test case, extract the string and simulate the function call with the string.

This approach ensures that we correctly identify and paint the minimal segment containing all 'B's to