Alright, I have this problem to solve. Let's see what it's about. So, Polycarp lost a string, but he has its "trace." The trace is an array of integers that represent, for each position in the string, how many times the character at that position has appeared before it in the string. For example, for the string "abracadabra," the trace is [0,0,0,1,0,2,0,3,1,1,4]. That makes sense because the first 'a' has no previous 'a's, the second 'a' has one previous 'a', and so on.

My task is to, given this trace array, reconstruct any possible string that could have produced this trace. The string should only consist of lowercase Latin letters.

First, I need to understand the input and output formats. The input starts with an integer t, representing the number of test cases. For each test case, there's an integer n, which is the length of the string, followed by an array of n integers, which is the trace.

I need to output, for each test case, a string that corresponds to the given trace.

Looking at the example:

Input:

5

11

0 0 0 1 0 2 0 3 1 1 4

10

0 0 0 0 0 1 0 1 1 0

1

0

8

0 1 2 3 4 5 6 7

8

0 0 0 0 0 0 0 0

Output:

abracadabra

codeforces

a

aaaaaaa

dijkstra

So, for the first test case, the trace [0,0,0,1,0,2,0,3,1,1,4] corresponds to "abracadabra." Let's see why:

- The first 'a' has 0 previous 'a's.

- The 'b' has 0 previous 'b's.

- The 'r' has 0 previous 'r's.

- The second 'a' has 1 previous 'a'.

- The 'c' has 0 previous 'c's.

- The third 'a' has 2 previous 'a's.

- The 'd' has 0 previous 'd's.

- The fourth 'a' has 3 previous 'a's.

- The 'b' has 1 previous 'b'.

- The 'r' has 1 previous 'r'.

- The fifth 'a' has 4 previous 'a's.

That matches the trace.

Now, I need to think about how to reconstruct the string from the trace array.

I need to assign a character to each position based on the value in the trace array. The character assigned should have appeared exactly 'a_i' times before this position.

One way to approach this is to keep track of how many times each character has been used so far. For each position in the string, I look for a character that has been used 'a_i' times up to that point.

I need to make sure that for each position, there's a character that has been used exactly 'a_i' times before.

Given that there are only 26 lowercase letters, I can maintain a count for each letter.

Let me think about an algorithm:

1. For each test case:

a. Read n and the trace array a.

b. Initialize an array or list to keep track of the count of each character. Since there are 26 lowercase letters, I can use a list of 26 zeros, one for each letter from 'a' to 'z'.

c. Iterate through each position i from 0 to n-1:

i. For the current position i, I need to find a character that has been used exactly a[i] times so far.

ii. Loop through each possible character from 'a' to 'z':

- Check if the count of that character equals a[i].

- If it does, assign that character to position i in the string, increment its count, and move to the next position.

iii. Since it's guaranteed that a valid string exists, I don't need to worry about cases where no such character is found.

2. After constructing the string for all positions, print it.

This seems straightforward. Let's see if this works with the first example.

Example 1:

n = 11

a = [0,0,0,1,0,2,0,3,1,1,4]

Initialize count = [0,0,0,...,0] (26 zeros)

Position 0: a[0] = 0

- Look for a character with count 0.

- Assign 'a' (count['a'] = 0), set count['a'] = 1

- s = 'a'

Position 1: a[1] = 0

- Look for a character with count 0.

- 'b' (count['b'] = 0), set count['b'] = 1

- s = 'ab'

Position 2: a[2] = 0

- Look for a character with count 0.

- 'r' (count['r'] = 0), set count['r'] = 1

- s = 'abr'

Position 3: a[3] = 1

- Look for a character with count 1.

- 'a' (count['a'] = 1), set count['a'] = 2

- s = 'abra'

Position 4: a[4] = 0

- Look for a character with count 0.

- 'c' (count['c'] = 0), set count['c'] = 1

- s = 'abrac'

Position 5: a[5] = 2

- Look for a character with count 2.

- 'a' (count['a'] = 2), set count['a'] = 3

- s = 'abracad'

Position 6: a[6] = 0

- Look for a character with count 0.

- 'd' (count['d'] = 0), set count['d'] = 1

- s = 'abracada'

Position 7: a[7] = 3

- Look for a character with count 3.

- 'a' (count['a'] = 3), set count['a'] = 4

- s = 'abracadab'

Position 8: a[8] = 1

- Look for a character with count 1.

- 'b' (count['b'] = 1), set count['b'] = 2

- s = 'abracadabb'

Position 9: a[9] = 1

- Look for a character with count 1.

- 'r' (count['r'] = 1), set count['r'] = 2

- s = 'abracadabbr'

Position 10: a[10] = 4

- Look for a character with count 4.

- 'a' (count['a'] = 4), set count['a'] = 5

- s = 'abracadabbra'

Wait, the expected output is "abracadabra," but according to this, it's "abracadabbra." Hmm, maybe I messed up somewhere.

Wait, at position 9, a[9] = 1. I chose 'r' with count 1, which is correct. But in the expected output, it's 'a' at position 9. Wait, no, in "abracadabra," position 9 is 'a', but according to the trace, a[9] = 1, meaning one previous 'a'. But by position 9, 'a' has appeared four times already (positions 0,3,5,7). So that doesn't match.

Wait, maybe I miscounted the positions. Let's index from 0:

Positions:

0: a (0)

1: b (0)

2: r (0)

3: a (1)

4: c (0)

5: a (2)

6: d (0)

7: a (3)

8: b (1)

9: r (1)

10: a (4)

So, position 9 is 'r', not 'a'. In "abracadabra," position 9 is 'r', which matches the trace.

But in my reconstruction, position 9 is also 'r'. So, my previous step was correct. And position 10 is 'a' with count 4, which matches.

So, why does the expected output have 'a' at position 9? Wait, no, in "abracadabra," position 9 is 'r', which matches.

So, my reconstruction is correct: 'a','b','r','a','c','a','d','a','b','r','a' -> "abracadabrax" where x is 'a'. Wait, but it should be "abracadabra".

Wait, perhaps I need to choose different characters.

Let me try again:

Position 0: a[0] = 0 -> choose 'a', count['a'] = 1, s = 'a'

Position 1: a[1] = 0 -> choose 'b', count['b'] = 1, s = 'ab'

Position 2: a[2] = 0 -> choose 'r', count['r'] = 1, s = 'abr'

Position 3: a[3] = 1 -> choose 'a', count['a'] = 2, s = 'abra'

Position 4: a[4] = 0 -> choose 'c', count['c'] = 1, s = 'abrac'

Position 5: a[5] = 2 -> choose 'a', count['a'] = 3, s = 'abracad'

Position 6: a[6] = 0 -> choose 'd', count['d'] = 1, s = 'abracad'

Position 7: a[7] = 3 -> choose 'a', count['a'] = 4, s = 'abracada'

Position 8: a[8] = 1 -> choose 'b', count['b'] = 2, s = 'abracadab'

Position 9: a[9] = 1 -> choose 'r', count['r'] = 2, s = 'abracadabr'

Position 10: a[10] = 4 -> choose 'a', count['a'] = 5, s = 'abracadabra'

Okay, that matches the expected output. So, my initial approach seems correct.

Let me check another example.

Second test case:

n = 10

a = [0,0,0,0,0,1,0,1,1,0]

Let's construct the string step by step.

Initialize count = [0,0,0,...,0]

Position 0: a[0] = 0 -> choose 'c', count['c'] = 1, s = 'c'

Position 1: a[1] = 0 -> choose 'o', count['o'] = 1, s = 'co'

Position 2: a[2] = 0 -> choose 'd', count['d'] = 1, s = 'cod'

Position 3: a[3] = 0 -> choose 'e', count['e'] = 1, s = 'code'

Position 4: a[4] = 0 -> choose 'f', count['f'] = 1, s = 'codef'

Position 5: a[5] = 1 -> choose 'o', count['o'] = 2, s = 'codefo'

Position 6: a[6] = 0 -> choose 'r', count['r'] = 1, s = 'codefor'

Position 7: a[7] = 1 -> choose 'c', count['c'] = 2, s = 'codeforc'

Position 8: a[8] = 1 -> choose 'e', count['e'] = 2, s = 'codeforce'

Position 9: a[9] = 0 -> choose 's', count['s'] = 1, s = 'codeforces'

That matches the expected output.

Another test case:

n = 1

a = [0]

Choose any letter with count 0, say 'a'.

Output: 'a'

Matches the expected output.

Next:

n = 8

a = [0,1,2,3,4,5,6,7]

Choose:

Position 0: a[0] = 0 -> 'a', count['a'] = 1, s = 'a'

Position 1: a[1] = 1 -> 'a', count['a'] = 2, s = 'aa'

Position 2: a[2] = 2 -> 'a', count['a'] = 3, s = 'aaa'

Position 3: a[3] = 3 -> 'a', count['a'] = 4, s = 'aaaa'

Position 4: a[4] = 4 -> 'a', count['a'] = 5, s = 'aaaaa'

Position 5: a[5] = 5 -> 'a', count['a'] = 6, s = 'aaaaaa'

Position 6: a[6] = 6 -> 'a', count['a'] = 7, s = 'aaaaaaa'

Position 7: a[7] = 7 -> 'a', count['a'] = 8, s = 'aaaaaaaa'

But the expected output is "aaaaaaa", which has 7 'a's, but according to the trace [0,1,2,3,4,5,6,7], it should be 8 'a's. Wait, the length is 8, so it should be 8 characters.

Wait, the expected output is "aaaaaaa", which is 7 characters, but n=8. That doesn't match.

Wait, perhaps I misread the expected output. Looking back, for n=8, trace [0,1,2,3,4,5,6,7], output is "aaaaaaa", but that's 7 characters, but n=8. That seems inconsistent.

Wait, no, the expected output is "aaaaaaa", but according to the trace, it should be 8 characters. Maybe there's a typo in the expected output.

Wait, perhaps the expected output is "aaaaaaaa", but it was mistakenly written as "aaaaaaa". Or maybe I misread the problem.

Wait, looking back, for n=8, trace [0,1,2,3,4,5,6,7], the expected output is "aaaaaaa", but according to the trace, it should be 8 'a's. So perhaps there's an error in the sample output.

But assuming the sample output is correct, perhaps I need to choose different characters.

Wait, if I choose different characters, for example:

Position 0: a[0] = 0 -> 'a', count['a'] = 1, s = 'a'

Position 1: a[1] = 1 -> 'a', count['a'] = 2, s = 'aa'

Position 2: a[2] = 2 -> 'a', count['a'] = 3, s = 'aaa'

Position 3: a[3] = 3 -> 'a', count['a'] = 4, s = 'aaaa'

Position 4: a[4] = 4 -> 'a', count['a'] = 5, s = 'aaaaa'

Position 5: a[5] = 5 -> 'a', count['a'] = 6, s = 'aaaaaa'

Position 6: a[6] = 6 -> 'a', count['a'] = 7, s = 'aaaaaaa'

Position 7: a[7] = 7 -> 'a', count['a'] = 8, s = 'aaaaaaaa'

So, according to this, it should be 8 'a's, but the expected output is "aaaaaaa", which is 7 'a's. So, perhaps there's a mistake in the sample output.

However, since the problem states that a valid string exists for each test case, I'll assume that the sample output is correct and try to see what's happening.

Wait, perhaps in this case, the string can have different characters, but in the trace, each character's count matches the required number.

For example, for n=8, trace [0,1,2,3,4,5,6,7], one possible string is "abcdefg", where each character is unique, and the count increases sequentially.

Wait, but in this case, each a[i] represents the number of times the character at position i has appeared before position i.

In "abcdefg", each character appears for the first time, so a[i] should be 0 for all i, which doesn't match the trace [0,1,2,3,4,5,6,7].

So, that can't be it.

Alternatively, if I have a string like "aaaaaaa", which is 7 'a's, but n=8, it doesn't match.

Wait, perhaps the expected output is "aaaaaaa" for n=7, but in this case, n=8.

This is confusing. Wait, perhaps I misread the sample output.

Looking back, for n=8, trace [0,1,2,3,4,5,6,7], the expected output is "aaaaaaa", but that can't be right because it's of length 7, but n=8.

Wait, perhaps it's a typo in the problem statement. I'll proceed with my initial approach, assuming that the sample output is incorrect and proceed with the logic I have.

Another test case:

n=8

trace=[0,0,0,0,0,0,0,0]

This should correspond to a string where each character has not appeared before it, meaning all characters are unique.

For example, "dijkstra", where all characters are unique.

My approach would assign 'a','b','c','d','e','f','g','h', but since the problem allows any valid string, "dijkstra" is also valid.

Now, moving on to implement the function.

I need to implement a function that, given n and the trace array a, returns a string s that corresponds to the trace.

I'll use the approach I described earlier.

Implement a list of counts for each character from 'a' to 'z'.

Iterate through each position in the string, and for each position, find a character that has been used exactly a[i] times so far.

Assign that character to the position and increment its count.

Since it's guaranteed that a valid string exists, I don't need to handle cases where no such character is found.

I need to make sure that this is efficient because n can be up to 2*10^5, and t is up to 10^4, but the total sum of n over all test cases does not exceed 2*10^5.

So, the total time complexity should be O(26*n) = O(n), which is acceptable.

Now, looking at the given program:

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

print(func_1(n, a))

def func_1(n, a):

s = ''

char_count = [0] * 26

for i in range(n):

for j in range(26):

if char_count[j] == a[i]:

s += chr(j + ord('a'))

char_count[j] += 1

break

return s

This seems to match the approach I described.

It initializes a list char_count with 26 zeros, one for each lowercase letter.

Then, for each position i in the string:

- It loops through each possible character j from 0 to 25 (corresponding to 'a' to 'z').

- If the count of that character equals a[i], it assigns that character to the string, increments its count, and moves to the next position.

This should work correctly, as demonstrated in the example I walked through.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{Yes}} \]