Alright, I've got this problem to solve. Let's see what it's asking for. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (between 2 and n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to make all elements of the array zero.

First, I need to understand what this operation does. It seems like it's a way to reduce the values in the array, particularly targeting the element at position i by subtracting 2, and its neighbors by subtracting 1 each. Since this operation can be applied any number of times, I need to find out if it's possible to apply these operations in such a way that all elements become zero.

I should think about this in terms of linear algebra or maybe some kind of system of equations. Each operation corresponds to subtracting a specific vector from the array: [0, ..., 0, -1, -2, -1, 0, ..., 0], where the -1, -2, -1 are at positions i-1, i, i+1 respectively.

The problem is to determine if, by applying such operations multiple times, I can transform the initial array into an array of all zeros.

One approach is to model this as a system of linear equations. Each operation corresponds to subtracting a specific vector from the array, and I need to see if the initial array is a linear combination of these operation vectors.

However, since the operations can be applied any number of times, and the coefficients are integers (specifically, the number of times each operation is applied), this seems like a problem in integer linear combinations.

But maybe there's a simpler way to look at it. Let's consider the array as a sequence of numbers, and see how the operations affect adjacent elements.

Looking at the operation: a[i-1] -=1, a[i] -=2, a[i+1] -=1 for some i from 2 to n-1.

I can think of this as subtracting a specific pattern from the array: [-1, -2, -1] at positions i-1, i, i+1.

To make all elements zero, I need to subtract these patterns in such a way that the sum of all subtractions equals the initial array.

This sounds similar to solving a system where each operation affects three consecutive elements.

Given the constraints on n and the input sizes, I need an efficient algorithm, probably O(n) per test case, since n can be up to 2e5 and t up to 1e4, but the total sum of n over all test cases is 2e5.

Let me think about how to approach this.

One idea is to process the array from left to right, keeping track of the required operations to make each element zero, and see if these operations can be consistently applied.

Let's try to simulate the process.

Start from the first element, a[0]. Since the operation only affects a[i-1], a[i], and a[i+1] for i from 2 to n-1, a[0] can only be affected by operations where i=2, because for i=2, a[i-1]=a[1], a[i]=a[2], a[i+1]=a[3]. So a[0] is not directly affected by any operation.

Wait, that doesn't make sense. The operation is defined for i from 2 to n-1, which corresponds to positions starting from index 1 (since indices are 1-based in the problem statement).

Wait, the problem says indices are from 1 to n, but in Python, lists are 0-indexed. So, a[0] is element 1, a[1] is element 2, and so on.

Let me rephrase: operations can be performed on i from 2 to n-1 (1-based), which correspond to indices 1 to n-2 in the Python list.

Each operation on i (1-based):

- a[i-1] (0-based: a[i-2]) -=1

- a[i] (0-based: a[i-1]) -=2

- a[i+1] (0-based: a[i]) -=1

Wait, I'm getting confused with indexing.

Let me clarify:

- 1-based indexing in the problem:

- a_1 corresponds to a[0] in Python

- a_2 corresponds to a[1]

- ...

- a_n corresponds to a[n-1]

Operation is on i, where 2 <= i <= n-1:

- a_{i-1} -=1

- a_i -=2

- a_{i+1} -=1

In Python indexing:

- a[i-2] -=1

- a[i-1] -=2

- a[i] -=1

Given that, I need to find a sequence of such operations to make all a[j] = 0.

Let me consider the constraints and see if there's a way to model this.

An alternative approach is to consider the differences between consecutive elements.

Let me think in terms of differences.

Suppose I have the array a = [a1, a2, a3, a4, a5]

An operation on i=2 (1-based, corresponding to a[1] in Python):

- a1 -=1

- a2 -=2

- a3 -=1

Similarly, operation on i=3:

- a2 -=1

- a3 -=2

- a4 -=1

And so on.

I can represent these operations as vectors and see if the initial array can be expressed as a linear combination of these operation vectors.

But with large n, this matrix approach is not efficient.

I need a smarter way.

Let me consider the operations in reverse. Instead of subtracting, think about adding these patterns to reach from all zeros to the given array.

But that might not help directly.

Another idea: since each operation reduces a[i-1], a[i], a[i+1] by specific amounts, maybe I can iterate through the array and decide how many times to apply each operation based on the current values.

Let me try to iterate from left to right.

Start with a[0]. Since no operation affects a[0] directly except when i=2 (which affects a[0], a[1], a[2]), but wait, operations only start from i=2 (1-based), which is a[1] in Python.

Wait, a[0] can only be affected by operations where i=2 (1-based), meaning a[1] in Python.

Wait, no. Operation on i=2 (1-based):

- a[1] -=1 (a_{i-1})

- a[2] -=2 (a_i)

- a[3] -=1 (a_{i+1})

So, a[0] is not directly affected by any operation.

Therefore, to make a[0]=0, it must already be zero, because no operation can change it.

Wait, that can't be right. In the example, a[0]=1, and they manage to make it zero through operations on i=3 and i=4.

Wait, in the first operation, i=4: a[3]=5, a[4]=5, a[5]=2.

After operation on i=4:

a[3] -=1 (a[3]=4)

a[4] -=2 (a[4]=3)

a[5] -=1 (a[5]=1)

Then, operation on i=3:

a[2] -=1 (a[2]=4)

a[3] -=2 (a[3]=2)

a[4] -=1 (a[4]=2)

And so on.

So, a[0] can be affected indirectly by operations on higher i.

Wait, no, in this specific sequence, operations are on i=4 and i=3, which don't directly affect a[0].

Wait, perhaps my earlier assumption is wrong.

Let me think differently.

Suppose I have the array a = [a0, a1, a2, a3, a4]

I need to make a0=0, a1=0, a2=0, a3=0, a4=0 using operations on i=2,3,4 (1-based).

Each operation on i subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

I need to find operations such that the total subtraction makes all a[j]=0.

This seems like a system of linear equations.

Let me define:

Let o2, o3, o4 be the number of operations performed on i=2,3,4 respectively.

Then:

- For a0: only affected by o2: -1*o2

- For a1: affected by o2: -2*o2 and o3: -1*o3

- For a2: affected by o2: -1*o2, o3: -2*o3, o4: -1*o4

- For a3: affected by o3: -1*o3, o4: -2*o4

- For a4: affected by o4: -1*o4

So, the system of equations is:

- a0 - o2 = 0

- a1 - 2*o2 - o3 = 0

- a2 - o2 - 2*o3 - o4 = 0

- a3 - o3 - 2*o4 = 0

- a4 - o4 = 0

I need to solve for o2, o3, o4 such that all these equations hold.

This is a system of linear equations, and I can solve it to find if non-negative integer solutions exist for o2, o3, o4.

Given that operations can be applied any number of times (including zero), the o's must be non-negative integers.

This seems feasible, but with n up to 2e5, I need an efficient way to solve this for general n.

In general, for an array of size n, I have n equations and (n-2) operations (o2 to o_{n-1}).

This is an underdetermined system when n > 2.

Wait, actually, for n elements, I have n equations and (n-2) variables (operations o2 to o_{n-1}).

So, it's an underdetermined system, and generally, there are either zero or infinitely many solutions.

But since all a[i] are given and I need exactly zero, it's possible only if the system is consistent.

But in this case, since operations can be applied any number of times, I need to check if the system has a non-negative integer solution.

This seems complex to solve directly, especially for large n.

I need a smarter way.

Let me consider the operations in terms of their effects.

Starting from the end might be easier.

Looking at a[n-1], it's only affected by operation on o_{n-1}.

So, a[n-1] - o_{n-1} = 0 => o_{n-1} = a[n-1]

Similarly, a[n-2] is affected by o_{n-2} and o_{n-1}.

So, a[n-2] - o_{n-2} - o_{n-1} = 0 => o_{n-2} = a[n-2] - o_{n-1}

But o_{n-1} is already determined.

Similarly, a[n-3] is affected by o_{n-3}, o_{n-2}, o_{n-1}.

Wait, but in general, each a[i] is affected by o_{i-1}, o_i, o_{i+1}, but need to map correctly.

Wait, perhaps Gaussian elimination could solve this, but it's too slow for n=2e5.

I need a better approach.

Let me try to iterate from the end.

Set o_{n-1} = a[n-1]

Then, o_{n-2} = a[n-2] - o_{n-1}

o_{n-3} = a[n-3] - o_{n-2} - o_{n-1}

and so on.

Wait, but need to check if all o's are non-negative.

Wait, perhaps this is a way.

Let me try with the first example:

n=5, a=[1,3,5,5,2]

Set o3 = a[4] = 2

Then o2 = a[3] - o3 = 5 - 2 = 3

Then o1 = a[2] - o2 - o3 = 5 - 3 - 2 = 0

Then check a1 - o1 - o2 = 3 - 0 - 3 = 0

And a0 - o1 = 1 - 0 =1, which is not zero.

Wait, but in the example, they manage to make a0=0.

Hmm, maybe this approach is incorrect.

Wait, perhaps I need to adjust the way I'm calculating the operations.

Let me try again.

From the equations:

a0 - o1 = 0 => o1 = a0

a1 - 2*o1 - o2 = 0 => o2 = a1 - 2*o1

a2 - o1 - 2*o2 - o3 = 0 => o3 = a2 - o1 - 2*o2

a3 - o2 - 2*o3 = 0 => o3 = (a3 - o2)/2

a4 - o3 = 0 => o3 = a4

Wait, this seems inconsistent.

Wait, perhaps I need to solve it step by step.

Let me try to express o's in terms of previous variables.

From a4 - o3 = 0 => o3 = a4

From a3 - o2 - 2*o3 = 0 => o2 = a3 - 2*o3

From a2 - o1 - 2*o2 - o3 = 0 => o1 = a2 - 2*o2 - o3

From a1 - 2*o1 - o2 = 0 => o2 = a1 - 2*o1

From a0 - o1 = 0 => o1 = a0

Wait, this seems cyclic.

Let me try to substitute.

From a0 - o1 = 0 => o1 = a0

From a1 - 2*o1 - o2 = 0 => o2 = a1 - 2*o1 = a1 - 2*a0

From a2 - o1 - 2*o2 - o3 = 0 => o3 = a2 - o1 - 2*o2 = a2 - a0 - 2*(a1 - 2*a0) = a2 - a0 - 2*a1 + 4*a0 = a2 - 2*a1 + 3*a0

From a3 - o2 - 2*o3 = 0 => o2 = a3 - 2*o3 = a3 - 2*(a2 - 2*a1 + 3*a0) = a3 - 2*a2 + 4*a1 - 6*a0

But o2 was previously a1 - 2*a0, so set them equal:

a1 - 2*a0 = a3 - 2*a2 + 4*a1 - 6*a0

Simplify:

a1 - 2*a0 - a1 + 2*a2 - 4*a1 + 6*a0 = 0

Combine like terms:

(-4*a1) + (2*a2) + (4*a0) = 0

So, -4*a1 + 2*a2 + 4*a0 = 0

Simplify by dividing by 2:

-2*a1 + a2 + 2*a0 = 0

So, a2 = 2*a1 - 2*a0

In the first example, a=[1,3,5,5,2]

Check: a2 = 5, 2*a1 - 2*a0 = 2*3 - 2*1 = 6 - 2 = 4 â‰  5

But in the example, it's possible to make all zeros.

This suggests that my equation is incorrect.

Wait, perhaps I made a mistake in the derivation.

Let me double-check.

From earlier:

o1 = a0

o2 = a1 - 2*o1 = a1 - 2*a0

o3 = a2 - o1 - 2*o2 = a2 - a0 - 2*(a1 - 2*a0) = a2 - a0 - 2*a1 + 4*a0 = a2 - 2*a1 + 3*a0

From a3 - o2 - 2*o3 = 0 => o2 = a3 - 2*o3

But o2 = a1 - 2*a0, so:

a1 - 2*a0 = a3 - 2*(a2 - 2*a1 + 3*a0)

Expand:

a1 - 2*a0 = a3 - 2*a2 + 4*a1 - 6*a0

Bring all terms to one side:

a1 - 2*a0 - a3 + 2*a2 - 4*a1 + 6*a0 = 0

Combine like terms:

(-3*a1) + (2*a2) + (4*a0) - a3 = 0

So, -3*a1 + 2*a2 + 4*a0 - a3 = 0

For the first example: a0=1, a1=3, a2=5, a3=5

Plug in: -3*3 + 2*5 + 4*1 - 5 = -9 + 10 + 4 - 5 = 0

Which holds true.

Similarly, from a4 - o3 = 0 => o3 = a4

But from earlier, o3 = a2 - 2*a1 + 3*a0

So, a2 - 2*a1 + 3*a0 = a4

In the first example: 5 - 2*3 + 3*1 = 5 - 6 + 3 = 2, which matches a4=2

So, the equations are consistent.

Now, to make sure all o's are non-negative:

o1 = a0 = 1 >=0

o2 = a1 - 2*a0 = 3 - 2 =1 >=0

o3 = a2 - 2*a1 + 3*a0 =5 -6 +3=2 >=0

All o's are non-negative, so it's possible.

In the second example, where n=5 and a=[2,4,4,5,1]

Compute:

o1 = a0 =2

o2 = a1 -2*a0 =4-4=0

o3 = a2 -2*a1 +3*a0 =4 -8 +6=2

Check a3 - o2 -2*o3 =5 -0 -4=1 !=0

Wait, but according to the problem, it's "NO"

So, perhaps the condition is that all derived o's must satisfy the equations and be non-negative.

In this case, o3 =2, but a3 - o2 -2*o3 =1 !=0, which violates the equation.

Hence, "NO"

So, perhaps the approach is to compute o1, o2, ..., o_{n-1} sequentially and check if they satisfy all equations and are non-negative.

But for larger n, this might be time-consuming.

I need a way to generalize this.

Looking back, it seems that o1 = a0

Then o2 = a1 - 2*o1 = a1 - 2*a0

o3 = a2 - o1 -2*o2 = a2 - a0 -2*(a1 - 2*a0) = a2 - a0 -2*a1 +4*a0 = a2 -2*a1 +3*a0

o4 = a3 - o2 -2*o3 = a3 - (a1 -2*a0) -2*(a2 -2*a1 +3*a0) = a3 -a1 +2*a0 -2*a2 +4*a1 -6*a0 = a3 -2*a2 +3*a1 -4*a0

And so on.

This pattern seems to be forming a recurrence relation.

Perhaps I can find a general formula for o_i in terms of a_j's.

But for practical purposes, I need an efficient algorithm to compute these o's and check if they are non-negative and satisfy all equations.

Given the time constraints, I need an O(n) solution per test case.

Let me consider iterating from left to right, keeping track of the required operations.

Set o1 = a0

Then o2 = a1 - 2*o1

Then o3 = a2 - o1 -2*o2

And so on, until o_{n-1} = a_{n-2} - o_{n-3} -2*o_{n-2}

Finally, check if o_{n-1} = a_{n-1}

This seems similar to the approach I took earlier.

Let me try to implement this step by step.

Initialize o[1] = a[0]

Then for i from 2 to n-2:

o[i] = a[i-1] - o[i-1] - 2*o[i-2]

Finally, o[n-1] = a[n-2] - o[n-3] - 2*o[n-2]

And check if o[n-1] = a[n-1]

Also, ensure all o[i] >=0

Wait, I'm getting confused.

Let me try to formalize this.

Define o[1] = a[0]

o[2] = a[1] - 2*o[1]

o[3] = a[2] - o[1] - 2*o[2]

o[4] = a[3] - o[2] - 2*o[3]

...

o[k] = a[k-1] - o[k-3] - 2*o[k-2]

Wait, perhaps I need to adjust the indices.

Wait, maybe it's better to iterate through the array and subtract the operations' effects step by step.

Let me consider another approach.

Suppose I fix the number of operations o2, o3, ..., o_{n-1}, and compute the resulting array after applying these operations.

Then, set up equations to solve for o2, o3, ..., o_{n-1} such that the resulting array is zero.

This seems similar to solving a system of linear equations, which is not efficient for large n.

Is there a way to simplify this?

Let me consider the differences between consecutive elements.

Wait, maybe cumulative sum or prefix sums can help here.

Alternatively, perhaps there's a way to model this as a difference array.

Wait, perhaps I can consider the operations as a form of discrete derivatives.

Let me think differently.

Suppose I have the array a, and I want to make it zero using operations that subtract a specific pattern at each step.

This resembles solving a system where each operation corresponds to a specific vector, and I need to see if the initial array is a linear combination of these operation vectors.

But again, this seems too slow for large n.

Let me look for an invariant or some property that must hold for the array to be reducible to zero.

Looking back at the equations, I notice that for the operations to make all a[j]=0, certain linear combinations must hold.

From earlier, for n=5:

o1 = a0

o2 = a1 - 2*a0

o3 = a2 - a0 -2*(a1 -2*a0) = a2 -2*a1 +3*a0

o4 = a3 - (a1 -2*a0) -2*(a2 -2*a1 +3*a0) = a3 -2*a2 +3*a1 -4*a0

And finally, o4 should equal a4.

So, a4 = a3 -2*a2 +3*a1 -4*a0

This seems like a pattern where coefficients are increasing and decreasing in a specific manner.

Perhaps there's a general formula for o_{n-1} in terms of a0, a1, ..., a_{n-1}.

But I need a more efficient way to compute this.

Let me consider the operations in terms of their impact on the array.

Each operation on i subtracts [-1, -2, -1] from [a_{i-1}, a_i, a_{i+1}]

So, to reverse this, to reach from all zeros to the given array, it would involve adding these patterns.

But since we're going the other way, from given array to zero, it's subtracting these patterns.

I need to find a sequence of operations that, when subtracted, result in all zeros.

This is equivalent to solving a system of linear equations where each operation corresponds to a row in the matrix.

But with n up to 2e5, I need a smarter way.

Let me consider the problem in terms of differences.

Define d1 = a1 - a0

Define d2 = a2 - a1

...

Define d_{n-1} = a_{n-1} - a_{n-2}

But I'm not sure if this helps directly.

Wait, perhaps I can consider the second differences.

In numerical analysis, second differences can relate to the curvature of the array, but I'm not sure if that's applicable here.

Let me consider the operations again.

Each operation on i subtracts 1 from a_{i-1}, 2 from a_i, and 1 from a_{i+1}.

So, the total subtraction from the sum of the array is 1 + 2 + 1 =4.

But the sum of the array decreases by 4 with each operation.

Therefore, for the array to be reducible to zero, the sum of the array must be divisible by 4.

Wait, but in the first example, sum is 1+3+5+5+2=16, which is divisible by 4, and it's "YES"

In the second example, 2+4+4+5+1=16, which is divisible by 4, but it's "NO"

So, sum being divisible by 4 is not sufficient.

Hence, this is not a valid invariant.

Wait, perhaps it's not the sum that matters, but some other property.

Let me look for another approach.

Looking back at the equations:

We have o1 = a0

o2 = a1 - 2*o1 = a1 - 2*a0

o3 = a2 - o1 -2*o2 = a2 - a0 -2*(a1 -2*a0) = a2 - a0 -2*a1 +4*a0 = a2 -2*a1 +3*a0

o4 = a3 - o2 -2*o3 = a3 - (a1 -2*a0) -2*(a2 -2*a1 +3*a0) = a3 -a1 +2*a0 -2*a2 +4*a1 -6*a0 = a3 -2*a2 +3*a1 -4*a0

And so on.

I can see a pattern here: each o_i is a linear combination of a0, a1, a2, ..., with coefficients increasing and decreasing.

This seems like a recurrence relation.

Perhaps I can model this with matrix multiplication or some other efficient method.

But time is limited, and I need an efficient solution.

Let me consider that for each operation, it affects three elements.

So, perhaps I can iterate through the array and decide how many operations to apply based on the current element.

Start from the left, decide how many operations to apply to make a0=0, then move to a1, and so on.

But I need to make sure that the operations don't affect previous elements.

Wait, maybe I can use a sliding window approach.

Let me consider that operations on i affect a[i-1], a[i], a[i+1].

So, if I process from left to right, I can decide how many operations to apply based on the current element and its neighbors.

But I need to make sure that the operations don't mess up the previous elements.

This seems tricky.

Let me consider the following algorithm:

Initialize an array of operations, o[2] to o[n-1], all set to zero.

Iterate from left to right:

For each position i from 2 to n-1:

If a[i-1] >0, apply operations on i to reduce a[i-1], a[i], a[i+1]

But this seems too vague.

Let me think differently.

Suppose I have the array a.

I can model the operations as a matrix and solve the system.

But again, with n up to 2e5, this is not feasible.

I need a better way.

Looking back at the equations, perhaps I can express o_i in terms of a_i and previous o's.

From the earlier example, o1 = a0

o2 = a1 - 2*o1

o3 = a2 - o1 -2*o2

o4 = a3 - o2 -2*o3

...

o_{n-1} = a_{n-2} - o_{n-3} -2*o_{n-2}

Finally, check if o_{n-1} = a_{n-1}

If all o_i >=0 and the final condition holds, then "YES", else "NO"

This seems like a feasible approach.

Implementing this would require iterating through the array and computing o_i step by step.

Let me try to implement this logic.

Initialize o[1] = a[0]

o[2] = a[1] - 2*o[1]

o[3] = a[2] - o[1] -2*o[2]

...

o[k] = a[k-1] - o[k-3] -2*o[k-2]

Wait, perhaps I need to adjust the indices.

Wait, in code, it's easier to use 0-based indexing.

Let me redefine:

Set o[0] = a[0]

Set o[1] = a[1] - 2*o[0]

Set o[2] = a[2] - o[0] -2*o[1]

Set o[3] = a[3] - o[1] -2*o[2]

...

Set o[n-2] = a[n-2] - o[n-4] -2*o[n-3]

Finally, check if o[n-2] == a[n-1]

Wait, I'm getting confused with the indices.

Let me try to formalize this.

Define o[0] = a[0]

For i from 1 to n-2:

o[i] = a[i] - o[i-1] -2*o[i-2] (for i >=2)

Wait, perhaps it's better to iterate and keep track of o[i] based on previous o's.

Wait, perhaps I can implement this step by step.

Initialize o[0] = a[0]

o[1] = a[1] - 2*o[0]

o[2] = a[2] - o[0] -2*o[1]

o[3] = a[3] - o[1] -2*o[2]

...

o[n-2] = a[n-2] - o[n-4] -2*o[n-3]

Finally, check if o[n-2] == a[n-1]

If all o[i] >=0 and the final condition holds, then "YES", else "NO"

This seems workable.

Let me try it with the first example:

n=5, a=[1,3,5,5,2]

o[0] =1

o[1]=3-2*1=1

o[2]=5-1-2*1=2

o[3]=5-1-2*2=0

Check if o[3]=a[4]=2, but o[3]=0 != a[4]=2

Wait, but in the example, it's possible.

Hmm, seems inconsistent.

Wait, perhaps I messed up the indices.

Let me try again.

From the earlier equations:

o1 = a0 =1

o2 = a1 -2*o1 =3-2=1

o3 = a2 -o1 -2*o2 =5-1-2=2

o4 = a3 -o2 -2*o3 =5-1-4=0

But according to the earlier equation, o4 should equal a4=2, but 0 !=2

Wait, but in the example, it's possible.

Perhaps this approach is incorrect.

Wait, maybe I need to adjust the way I compute o[i].

Let me check the equations again.

From a0 - o1 =0 => o1 =a0=1

From a1 -2*o1 -o2=0 => o2=a1 -2*o1=3-2=1

From a2 -o1 -2*o2 -o3=0 => o3=a2 -o1 -2*o2=5-1-2=2

From a3 -o2 -2*o3=0 => o2 +2*o3 =1 +4=5, but a3=5, so it holds

From a4 -o3=0 => o3=a4=2, but o3=2, which matches.

Wait, in my earlier calculation, o4=0, but in this case, o3=2=a4=2, so it's fine.

Wait, perhaps I misapplied the formula.

Let me try to generalize.

For i from 1 to n-2:

o[i] = a[i] - o[i-1] -2*o[i-2]

And o[0]=a[0]

o[1]=a[1]-2*o[0]

Then, for o[2]=a[2]-o[0]-2*o[1]

...

Until o[n-2]=a[n-2]-o[n-4]-2*o[n-3]

Finally, check if o[n-2]=a[n-1]

Wait, but in the first example, o3=0, but a4=2, which is not equal.

But according to the earlier equations, o3 should be equal to a4.

Wait, perhaps I need to set o[n-2]=a[n-1]

So, in code, after computing o[n-2], check if it equals a[n-1]

If yes and all o[i]>=0, then "YES", else "NO"

In the first example, o3=0 !=a4=2, so it should be "NO", but in the example, it's "YES"

Wait, that's confusing.

Perhaps this approach is incorrect.

Let me try another example.

Take n=4, a=[1,2,7,2]

Compute:

o1=a0=1

o2=a1-2*o1=2-2=0

o3=a2 -o1 -2*o2=7-1-0=6

Check if o3=a3=2, but 6 !=2, so "NO"

According to this approach, it's "NO", which matches the example.

Another example: n=3, a=[7,1,0]

Compute:

o1=a0=7

o2=a1-2*o1=1-14=-13

Already negative, so "NO"

Which matches the example.

Another example: n=4, a=[1,1,1,1]

Compute:

o1=1

o2=1-2*1=-1

Negative, so "NO"

Which matches the example.

Wait, but in the first example, it should be "YES", but according to this approach, it's "NO"

Wait, perhaps I have a mistake in the approach.

Looking back, in the first example, after operations, a becomes [0,0,0,0,0], but according to the equations, o3=0 !=a4=2

Wait, perhaps a4 should be o4, but in my earlier calculations, I didn't have o4.

Wait, perhaps I need to adjust the indices.

Let me try to redefine.

Set o[0]=a[0]

o[1]=a[1]-2*o[0]

o[2]=a[2]-o[0]-2*o[1]

o[3]=a[3]-o[1]-2*o[2]

o[4]=a[4]-o[2]-2*o[3]

Wait, but n=5, so o[0] to o[4]

Finally, check if o[4]=0

Wait, in the first example, o[4]=a[4]-o[2]-2*o[3]=2-2-0=0

So, o[4]=0, which should be equal to 0, as required.

But in my earlier approach, I was checking o[n-2]=a[n-1], which was incorrect.

Actually, I need to ensure that after computing all o's, the last condition holds.

Wait, perhaps I need to compute o[0] to o[n-2], and set o[n-1]=a[n-1]-o[n-3]-2*o[n-2], and check if o[n-1]=0

Wait, I'm getting tangled in indices.

Let me try to formalize this.

Define o[0] to o[n-2]

Then, set o[n-1]=a[n-1]-o[n-3]-2*o[n-2]

And require that o[n-1]=0

In the first example:

o[0]=1

o[1]=3-2=1

o[2]=5-1-2=2

o[3]=5-1-4=0

o[4]=2-2-0=0

Which satisfies o[4]=0

Hence, "YES"

In the second example:

o[0]=2

o[1]=4-4=0

o[2]=4-2-0=2

o[3]=5-0-4=1

o[4]=1-0-2=-1

Which is negative, so "NO"

In the third example:

o[0]=0

o[1]=1-0=1

o[2]=3-0-2=1

o[3]=3-1-2=0

o[4]=1-1-0=0

All o's are non-negative, so "YES"

In the fourth example:

o[0]=5

o[1]=6-10=-4

Negative, so "NO"

Fifth example:

o[0]=1

o[1]=2-2=0

o[2]=7-1-0=6

o[3]=2-0-12=-10

Negative, so "NO"

Sixth example:

o[0]=7

o[1]=1-14=-13

Negative, so "NO"

Seventh example:

o[0]=1

o[1]=1-2=-1

Negative, so "NO"

This seems consistent with the expected outputs.

Hence, the approach is:

- Initialize o[0] = a[0]

- For i from 1 to n-2:

o[i] = a[i] - o[i-1] - 2*o[i-2]

- Set o[n-1] = a[n-1] - o[n-3] - 2*o[n-2]

- Check if o[n-1] == 0 and all o[i] >=0

- If yes, output "YES"; else, "NO"

This can be implemented efficiently in O(n) per test case.

Now, let's look at the provided code.

Code:

def func():

for _ in range(int(input())):

a = int(input())

b = list(map(int, input().split()))

for i in range(0, a - 2):

if b[i] < 0:

print('NO')

break

b[i + 1] -= b[i] * 2

b[i + 2] -= b[i]

b[i] -= b[i]

else:

if b[-1] != 0 or b[-2] != 0:

print('NO')

else:

print('YES')



Analyze the code:

- Read the number of test cases t.

- For each test case:

- Read n and the array b of size n.

- Iterate from i=0 to n-3:

- If b[i] < 0, print 'NO' and break.

- Otherwise, update b[i+1] -= b[i] * 2

- Update b[i+2] -= b[i]

- Update b[i] -= b[i] (which sets b[i] to 0)

- If the loop completes without breaking:

- Check if b[-1] == 0 and b[-2] ==0

- If yes, print 'YES'; else, 'NO'

This seems to implement the approach I just formalized.

Let's map it to the earlier equations.

In the loop:

For each i from 0 to n-3:

- If b[i] <0: invalid, print 'NO'

- Else:

- Subtract b[i]*2 from b[i+1]

- Subtract b[i] from b[i+2]

- Set b[i] to 0

This is equivalent to applying operations on i+2 (1-based), with the number of operations equal to b[i].

Wait, in the code, b[i] corresponds to o[i+1] in my earlier notation.

Wait, perhaps I need to adjust the indices.

Let me see with the first example:

n=5, b=[1,3,5,5,2]

Iteration 1: i=0

b[0]=1 >=0

b[1] -=1*2 => b[1]=3-2=1

b[2] -=1 => b[2]=5-1=4

b[0]-=1 => b[0]=0

Array now: [0,1,4,5,2]

Iteration 2: i=1

b[1]=1 >=0

b[2] -=1*2 => b[2]=4-2=2

b[3] -=1 => b[3]=5-1=4

b[1]-=1 => b[1]=0

Array now: [0,0,2,4,2]

Iteration 3: i=2

b[2]=2 >=0

b[3] -=2*2 => b[3]=4-4=0

b[4] -=2 => b[4]=2-2=0

b[2]-=2 => b[2]=0

Array now: [0,0,0,0,0]

Finally, check b[-1]=0 and b[-2]=0, which holds, so "YES"

This matches the expected output.

Another example: n=5, b=[2,4,4,5,1]

Iteration 1: i=0

b[0]=2 >=0

b[1]-=4 => b[1]=0

b[2]-=2 => b[2]=2

b[0]=0

Array: [0,0,2,5,1]

Iteration 2: i=1

b[1]=0 >=0

b[2]-=0 => b[2]=2

b[3]-=0 => b[3]=5

b[1]=0

Array: [0,0,2,5,1]

Iteration 3: i=2

b[2]=2 >=0

b[3]-=4 => b[3]=1

b[4]-=2 => b[4]=-1

b[2]=0

Array: [0,0,0,1,-1]

Now, b[-1]=-1 !=0, so "NO"

Which matches the expected output.

Hence, the code implements the correct approach.

Therefore, the answer is True.

**Final Answer**

\[ \boxed{\text{True}} \]