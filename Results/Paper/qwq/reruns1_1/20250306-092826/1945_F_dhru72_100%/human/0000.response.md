Alright, I've got this problem to solve. Let's see what it's asking for.

So, there are n mushrooms under a Wise Oak, each with a magic power v_i. Kirill wants to pick some mushrooms to make an elixir, and the strength of this elixir is the product of the number of mushrooms he picks and the minimum magic power among those mushrooms. So, if he picks k mushrooms, and the smallest magic power among them is m, then the strength is k * m.

But there's a catch. There's a permutation p of numbers from 1 to n, and if Kirill picks k mushrooms, then the magic power of the mushrooms with indices p_1 through p_{k-1} becomes zero. He doesn't use mushrooms with zero magic power in his elixir.

So, I need to help Kirill pick mushrooms in such a way that he maximizes the strength of the elixir, and among all options that give this maximum strength, he picks the one with the minimum number of mushrooms.

First, I need to understand how the permutation affects the magic powers. The permutation p determines which mushrooms lose their magic power based on how many mushrooms Kirill decides to pick.

Let me try to rephrase the problem to make sure I understand it correctly.

Kirill chooses to pick k mushrooms. As a result, the mushrooms at positions p_1 through p_{k-1} have their magic power set to zero. Then, from the remaining mushrooms (those not having their magic power set to zero), he selects k mushrooms to make the elixir, and the strength is k times the minimum magic power among these k mushrooms.

Wait, but the problem says he picks k mushrooms sequentially, and the magic powers of p_1 through p_{k-1} become zero. Then, he doesn't use mushrooms with zero magic power. So, the mushrooms he picks are from the ones that haven't had their magic power set to zero.

Actually, re-reading the problem: "If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, …, p_{k-1} will become 0. Kirill will not use mushrooms with zero magic power to prepare the elixir."

So, when he picks k mushrooms, the first k-1 mushrooms in the permutation p have their magic power set to zero, and he cannot use them in his elixir. He can only use the mushrooms that are not among p_1 to p_{k-1}.

Wait, but the problem says "Kirill can gather mushrooms in any order." But the permutation p seems to be fixed, and it determines which mushrooms lose their magic power based on how many he picks.

I think I need to consider that the permutation p is given, and when Kirill picks k mushrooms, the first k-1 mushrooms in the permutation p have their magic power set to zero. Then, he prepares the elixir using the remaining mushrooms, i.e., excluding those with zero magic power.

So, to maximize the strength, which is k times the minimum magic power among the k mushrooms he picks, but he cannot use the mushrooms whose magic power is set to zero.

I need to find the optimal k and the corresponding mushrooms to pick to maximize this strength.

This seems a bit tricky. Let's try to think differently.

Suppose I fix k, the number of mushrooms Kirill picks. Then, the first k-1 mushrooms in the permutation p have their magic power set to zero. So, the mushrooms with indices p_1 to p_{k-1} have v=0.

Then, Kirill prepares the elixir using k mushrooms from the remaining mushrooms, i.e., excluding those with v=0.

Wait, but he picks k mushrooms, and the first k-1 in the permutation have v=0. So, when he picks the k-th mushroom, the first k-1 have v=0, and he cannot use them. So, he can only use the mushrooms from p_k to p_n.

Wait, but that doesn't seem right. Let's look at the example to understand better.

Take the first example:

n=3

v=[9,8,14]

p=[3,2,1]

So, p_1=3, p_2=2, p_3=1

If k=1, then p_1=3 has v set to 0. So, v[3]=0. Kirill can only use p_2=2 and p_3=1, but since he picks only k=1, he has to pick one mushroom from the ones that are not p_1 to p_{k-1}. But for k=1, there are no p_{k-1}, so all mushrooms are available. Wait, p_{k-1} for k=1 is p_0, which doesn't exist. So, for k=1, no mushrooms have v set to 0.

Wait, the problem says "if Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, …, p_{k-1} will become 0."

So, for k=1, p_1=3 has v set to 0. So, v[3]=0. Then, Kirill picks one mushroom from the remaining mushrooms, which are p_2=2 and p_3=1, but p_3 has v=0, so only p_2=2 with v=8.

So, strength = 1 * 8 = 8.

For k=2, p_1=3 and p_2=2 have v set to 0. So, v[3]=0 and v[2]=0. Kirill picks 2 mushrooms from p_3=1 and p_4,..., but since n=3, only p_3=1 with v=0, which he cannot use. So, he can only pick from p_3=1 (v=0) and p_2=2 (v=0), but both have v=0, so he cannot make any elixir.

Wait, but in the example, output is 16 2, which suggests that for k=2, he can make an elixir with strength 16.

Wait, perhaps I misunderstood.

Wait, in the first example, output is 16 2, meaning that with k=2, the strength is 16.

But according to my earlier reasoning, for k=2, p_1=3 and p_2=2 have v=0, so only p_3=1 has v=0, and p_2=2 has v=0, so no mushrooms available to pick from.

But the output says 16, which is 2 * 8, meaning he picked two mushrooms with minimum v=8.

Wait, perhaps I need to reconsider how the permutation affects the magic powers.

Let me read the problem again carefully.

"If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, …, p_{k-1} will become 0. Kirill will not use mushrooms with zero magic power to prepare the elixir."

So, when he picks k mushrooms, the first k-1 mushrooms in the permutation have their v set to 0, and he cannot use those in his elixir.

But, he has to pick k mushrooms from the remaining ones, excluding those with v=0.

Wait, but in the first example, for k=2, p_1=3 and p_2=2 have v=0, so v[3]=0 and v[2]=0, and v[1]=9.

So, he can pick k=2 mushrooms from the ones that are not p_1 to p_{k-1}, which are p_3=1 and p_2=2, but p_2=2 has v=0, so only p_3=1 with v=9.

But to pick k=2 mushrooms, he needs to pick from available mushrooms, but only one is available, so he can't pick k=2.

This seems contradictory to the sample output.

Wait, perhaps I'm misunderstanding the permutation's role.

Let me look at the first sample input again.

n=3

v=[9,8,14]

p=[3,2,1]

According to the output, for k=2, strength=16, which is 2*8.

But according to the permutation p, p_1=3, p_2=2, p_3=1.

So, if k=2, p_1=3 and p_2=2 have v set to 0. So, v[3]=0 and v[2]=0.

Then, Kirill can only use p_3=1 (v=0, cannot use), p_2=2 (v=0, cannot use), and p_1=3 (v=0, cannot use). So, no mushrooms available to pick from.

But the sample output says 16 2, meaning he picked k=2 mushrooms with minimum v=8, giving strength=16.

Wait, perhaps I'm misinterpreting the permutation indices.

Wait, p is a permutation of numbers from 1 to n, indicating the order in which mushrooms lose their magic power.

Wait, perhaps p is the order in which Kirill picks the mushrooms.

Wait, but the problem says: "If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, …, p_{k-1} will become 0."

So, p is the order in which he picks the mushrooms.

Wait, perhaps p is the order in which the mushrooms lose their magic power when he picks k mushrooms.

Wait, I'm getting confused.

Let me try to think differently.

Suppose Kirill decides to pick k mushrooms. Then, the mushrooms at positions p_1 through p_{k-1} have their magic power set to zero. Then, he prepares the elixir using k mushrooms from the remaining ones, excluding those with zero magic power.

But in the first sample, for k=2, p_1=3 and p_2=2 have v=0. So, v[3]=0 and v[2]=0. Then, he can pick k=2 mushrooms from p_3=1 (v=0, cannot use), p_2=2 (v=0, cannot use), and p_1=3 (v=0, cannot use). So, no mushrooms available.

But the sample output says 16 2, meaning he picked k=2 mushrooms with minimum v=8.

Wait, perhaps I need to consider that the permutation p indicates the order in which mushrooms are considered for zeroing out their magic power.

Wait, maybe when he picks k mushrooms, the first k-1 mushrooms in the permutation p have their magic power set to zero, but he can still pick those mushrooms, just not use them in the elixir.

Wait, but the problem says he doesn't use mushrooms with zero magic power in the elixir.

Wait, perhaps I need to consider that when he picks k mushrooms, the first k-1 mushrooms in the permutation p have their magic power set to zero, and then he prepares the elixir using k mushrooms from the remaining ones, excluding those with zero magic power.

But in the first sample, for k=2, p_1=3 and p_2=2 have v=0, so v[3]=0 and v[2]=0, and p_3=1 has v=9.

So, he can pick k=2 mushrooms from p_3=1 (v=9), p_2=2 (v=0, cannot use), and p_1=3 (v=0, cannot use). So, only p_3=1 is available with v=9.

But to pick k=2 mushrooms, he needs two mushrooms, but only one is available. So, he can't pick k=2 mushrooms.

But according to the sample output, he can pick k=2 mushrooms with minimum v=8, giving strength=16.

I must be misunderstanding something.

Wait, perhaps the permutation p indicates the order in which mushrooms are picked.

Wait, let's consider that the permutation p indicates the order in which Kirill picks the mushrooms.

So, p_1 is the first mushroom he picks, p_2 is the second, and so on.

Then, if he picks k mushrooms, the first k-1 mushrooms he picks have their magic power set to zero, and he cannot use them in the elixir.

Then, the k-th mushroom he picks is the one he can use in the elixir, along with any mushrooms picked after that that haven't had their magic power set to zero.

Wait, but the problem says "If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, …, p_{k-1} will become 0."

So, when he picks k mushrooms, the first k-1 mushrooms in the permutation p have their magic power set to zero, and he cannot use them in the elixir.

Then, he prepares the elixir using k mushrooms from the remaining ones, excluding those with zero magic power.

But in the first sample, for k=2, p_1=3 and p_2=2 have v=0, so v[3]=0 and v[2]=0.

Then, he can pick k=2 mushrooms from p_3=1 (v=9), p_2=2 (v=0, cannot use), and p_1=3 (v=0, cannot use). So, only p_3=1 is available with v=9.

But to pick k=2 mushrooms, he needs two mushrooms, but only one is available. So, he can't pick k=2 mushrooms.

But according to the sample output, he can pick k=2 mushrooms with minimum v=8, giving strength=16.

This suggests that perhaps the mushrooms he picks are the ones with indices p_k to p_n, and he can only pick up to n - (k - 1) mushrooms, since the first k-1 have v=0.

Wait, perhaps I need to consider that when he picks k mushrooms, he can only use the mushrooms from p_k to p_n, since p_1 to p_{k-1} have v=0.

So, for k=2, he can use p_2=2 (v=0, cannot use) and p_3=1 (v=9).

Wait, but p_2=2 has v=0, so he cannot use it.

So, only p_3=1 with v=9 is available.

But he needs to pick k=2 mushrooms, but only one is available. So, he can't pick k=2 mushrooms.

This contradicts the sample output.

Wait, perhaps the permutation p indicates the order in which mushrooms lose their magic power, but he can still pick the ones that have lost their magic power, just not use them in the elixir.

Wait, maybe he picks k mushrooms, but only uses those that haven't had their magic power set to zero in the elixir.

So, for k=2, p_1=3 and p_2=2 have v=0, so when he picks k=2 mushrooms, he can pick any k=2 mushrooms, but only uses those that are not p_1 to p_{k-1}, i.e., not p_1=3 and p_2=2.

So, he can pick p_3=1 (v=9), and one other mushroom, say p_2=2 (v=0, cannot use), so only p_3=1 is usable, giving k=1, which contradicts.

This is confusing.

Wait, maybe I need to think in terms of choosing a subset of mushrooms to pick, and then determining which ones can be used in the elixir based on the permutation.

Wait, perhaps I need to consider that the permutation p determines the order in which mushrooms are considered for zeroing out their magic power.

Let me try to think differently.

Suppose I fix a subset S of k mushrooms to pick.

Then, the first k-1 mushrooms in the permutation p have their magic power set to zero.

Then, Kirill prepares the elixir using k mushrooms from S, excluding those with v=0.

So, to maximize the strength, I need to choose S such that the minimum v among the k mushrooms in S that are not among p_1 to p_{k-1} is maximized.

This seems complicated.

Maybe I need to find a way to select k mushrooms such that the smallest v among them is maximized, considering that the first k-1 in the permutation have v=0.

Wait, perhaps I need to sort the permutation p in a certain way.

Wait, maybe I need to sort the permutation based on the magic powers.

Wait, but p is given as a permutation, and v is given as an array.

Let me think about the problem differently.

Suppose I sort the mushrooms in decreasing order of their magic power.

Then, I can consider picking the top k mushrooms with the highest magic powers, but I need to make sure that the first k-1 in the permutation don't have their magic power set to zero.

Wait, perhaps I need to find a way to maximize the minimum magic power among the k mushrooms I pick, while minimizing k.

But the problem is to maximize the strength, which is k times the minimum v among the k mushrooms.

And among all such possibilities, choose the smallest k.

This seems like a classic optimization problem.

Maybe I can use binary search to find the maximum possible minimum v, and then find the smallest k that achieves that.

Wait, but I need to consider the permutation p as well.

Wait, perhaps I can iterate over possible k and find the maximum strength.

Let me consider that.

For each possible k from 1 to n, I can:

- Identify which mushrooms have their magic power set to zero: p_1 to p_{k-1}.

- From the remaining mushrooms (those not in p_1 to p_{k-1}), select k mushrooms with the highest magic powers.

- Compute the strength as k * min(v among the selected k mushrooms).

- Keep track of the maximum strength and the minimum k that achieves it.

But this seems inefficient for n up to 2e5.

I need a better approach.

Let me consider the following approach:

- Sort the mushrooms in decreasing order of their magic power.

- Then, assign the positions in the permutation p to these sorted mushrooms.

- So, the mushroom with the highest v is assigned to p_k for some k.

Wait, perhaps not.

Wait, maybe I can think in terms of choosing k and then selecting the top k mushrooms that are not among p_1 to p_{k-1}.

Wait, perhaps I can precompute for each k, which mushrooms are available.

Wait, but n is up to 2e5, and t is up to 1e4, but the sum of n over all test cases is up to 2e5, so I need an efficient solution.

Let me try to think about the problem in terms of the permutation p.

Suppose I sort the permutation p in the order of increasing v[p_i].

Then, for each k, p_1 to p_{k-1} have the smallest v, and p_k to p_n have larger v.

But I need to consider that when picking k mushrooms, p_1 to p_{k-1} have v=0.

Wait, maybe I can iterate over k and keep track of the available mushrooms.

Wait, perhaps I need to consider that for a given k, the mushrooms that are not among p_1 to p_{k-1} are those from p_k to p_n.

So, for each k, the available mushrooms are p_k to p_n, and their v are not set to zero.

Then, Kirill needs to pick k mushrooms from these available mushrooms.

So, he picks k mushrooms from p_k to p_n, and the strength is k * min(v among the k picked mushrooms).

To maximize the strength, he should pick the k mushrooms with the highest v from p_k to p_n.

Wait, but p_k to p_n are in some order, and their v may not be sorted.

So, for each k, I need to select k mushrooms from p_k to p_n with the highest v, and compute k * min among these k.

Then, I need to find the k that maximizes this value, and among those, choose the smallest k.

This seems manageable.

So, for each k from 1 to n:

- Identify the mushrooms available: p_k to p_n.

- Select the k mushrooms with the highest v from p_k to p_n.

- Compute strength = k * min(v among these k mushrooms).

- Keep track of the maximum strength and the minimum k that achieves it.

But this is O(n^2), which is too slow for n up to 2e5.

I need a better way.

Let me think about sorting the permutation p based on v[p_i].

Wait, but p is a permutation, and v is given.

Perhaps I can sort the indices based on v in decreasing order.

Let me consider that.

Suppose I sort the indices from 1 to n based on v in decreasing order.

Let's say I have a list q where q[0] is the index of the mushroom with the highest v, q[1] is the next highest, and so on.

Then, for a given k, the k mushrooms with the highest v are q[0] to q[k-1].

But, in order to pick these k mushrooms, I need to make sure that none of them are among p_1 to p_{k-1}.

Wait, no. Actually, when picking k mushrooms, the mushrooms p_1 to p_{k-1} have v=0.

So, to pick k mushrooms, I need to pick them from the mushrooms that are not among p_1 to p_{k-1}.

Wait, but p is the order in which mushrooms lose their magic power.

Wait, perhaps I can iterate over k and keep track of the available mushrooms.

Wait, maybe I need to consider the permutation p in the order given.

Let me try to think differently.

Suppose I fix k and try to compute the maximum possible strength for that k.

To maximize the strength for a fixed k, I need to maximize the minimum v among the k mushrooms I pick, excluding those among p_1 to p_{k-1}.

So, for a fixed k, the available mushrooms are p_k to p_n.

From these, I need to pick k mushrooms with the highest v.

Wait, but p_k to p_n are in some order, and I need to pick k mushrooms from them.

This seems tricky.

Maybe I can sort the available mushrooms in decreasing order of v and pick the top k.

Wait, but I need to pick k mushrooms from p_k to p_n.

Wait, perhaps I can sort the indices p_k to p_n based on v in decreasing order and pick the top k.

Then, the minimum v among these k mushrooms would be the k-th largest v among p_k to p_n.

So, for each k, the strength is k * (k-th largest v among p_k to p_n).

I need to maximize this value over k from 1 to n.

Then, among all k that achieve this maximum strength, I need to choose the smallest k.

This seems promising.

Now, how can I efficiently compute, for each k, the k-th largest v among p_k to p_n?

If I can do that efficiently, then I can compute the strength for each k and find the maximum.

Given that n can be up to 2e5, I need an efficient way to compute this.

One way is to use a data structure that allows me to query the k-th largest element in a subset of p_k to p_n.

A SortedMultiset or a policy-based data structure in C++ can help with this.

In Python, I can use a sorted list or a bisect module to maintain a sorted list of v from p_k to p_n.

Wait, but maintaining a sorted list for each k would be too slow.

Wait, perhaps I can pre-sort p in decreasing order of v[p_i], and then for each k, select the top k from p_k to p_n.

Wait, perhaps I need to sort p based on v[p_i] in decreasing order.

Let me try to think about it.

Suppose I sort the permutation p in decreasing order of v[p_i].

Let's say I have a sorted list s where s[0] is the index with the highest v, s[1] is the next highest, and so on.

Then, for a given k, the top k mushrooms from p_k to p_n would be the top k elements from s, excluding the first k-1 elements of p.

Wait, this is getting complicated.

Let me try to think about it differently.

Suppose I have a list of v[p_k] to v[p_n], sorted in decreasing order.

Then, the top k mushrooms from p_k to p_n would be the first k elements from this sorted list.

So, for each k, I can sort v[p_k] to v[p_n] in decreasing order and take the k-th element.

But sorting for each k is too slow.

Is there a way to precompute this efficiently?

Wait, perhaps I can precompute the sorted list of v[p_k] to v[p_n] for all k.

But that would still be O(n^2 log n), which is too slow.

I need a smarter approach.

Let me consider that as k increases, the range p_k to p_n decreases.

So, for larger k, the available mushrooms are a subset of those for smaller k.

Wait, but I'm not sure if that helps.

Wait, perhaps I can consider that for a given k, the available mushrooms are p_k to p_n, and I need to pick k mushrooms from them with the highest v.

So, to maximize the strength, I need to pick the k mushrooms with the highest v from p_k to p_n.

Then, the minimum v among these k mushrooms is the k-th largest v in p_k to p_n.

So, strength = k * (k-th largest v in p_k to p_n).

I need to maximize this over k from 1 to n.

So, I need to find k that maximizes k * (k-th largest v in p_k to p_n).

To do this efficiently, I need a way to compute, for each k, the k-th largest v in p_k to p_n.

One way is to reverse the permutation p, so p_n to p_k, and then use a data structure to keep track of the top k elements.

Wait, perhaps I can sort the v in decreasing order and then map them back to their positions in p.

Wait, maybe I need to sort the v in decreasing order and keep track of their positions in p.

Let me try to think about it.

Suppose I sort the v in decreasing order, and get a sorted list s of indices.

Then, for each k, I need to find the k-th largest v in p_k to p_n.

Which is equivalent to finding the k-th element in the sorted list s, but only considering elements that are in p_k to p_n.

This seems complicated.

Wait, perhaps I can iterate over k from n down to 1, and maintain a sorted set of v from p_k to p_n.

Then, for each k, I can query the k-th largest v in this set.

Wait, but maintaining a sorted set for each k would be too slow.

Wait, perhaps I can build a sorted set of all v from p_1 to p_n, and then remove the first k-1 elements to get the set from p_k to p_n.

Then, for each k, I can query the k-th largest element in this set.

But removing elements and querying the k-th element efficiently requires a data structure that supports these operations.

In Python, I can use a SortedList from the sortedcontainers module, which allows me to delete elements and query the k-th element efficiently.

But since t can be up to 1e4 and n up to 2e5, with sum of n over all test cases up to 2e5, I need an efficient solution per test case.

Let me consider implementing a SortedMultiset in Python, similar to policy-based data structures in C++.

I can implement a SortedMultiset using a list of sorted lists, as shown in the given code.

Then, for each test case, I can:

- Build a SortedMultiset with v[p_1] to v[p_n].

- For each k from 1 to n:

- Remove the first k-1 elements from the SortedMultiset.

- Query the k-th largest element in the remaining set.

- Compute strength = k * (k-th largest element).

- Keep track of the maximum strength and the minimum k that achieves it.

But in the given code, it seems to be implementing a SortedMultiset and then iterating over k to find the maximum strength.

Looking at the given code:

- It reads t, the number of test cases.

- For each test case:

- Reads n, the number of mushrooms.

- Reads the array v of magic powers.

- Reads the permutation p.

- Creates a list a, where a[i] = -v[p[i]-1]. (Note: p is 1-based, so p[i]-1 is 0-based index.)

- Initializes a SortedMultiset r with a.

- Initializes ans = -1 and idx = 1.

- For i from 0 to (n + 1) // 2 - 1:

- Computes x = (i + 1) * -r[i]

- If x > ans, sets ans = x and idx = i + 1

- Discards a[i] from r

- Prints ans and idx

Wait, this seems to be trying to compute the strength for k from 1 to (n + 1) // 2, but I'm not sure.

I need to verify if this approach is correct.

First, creating a list a where a[i] = -v[p[i]-1]. So, a is the negation of v in the order of permutation p.

Then, it initializes a SortedMultiset r with a.

Then, it iterates i from 0 to (n + 1) // 2 - 1:

- Computes x = (i + 1) * -r[i]

- If x > ans, sets ans = x and idx = i + 1

- Discards a[i] from r

Wait, this seems off.

Wait, r is a SortedMultiset of a, which is sorted in ascending order by default, but a contains -v[p_i].

So, -r[i] would be v[p_j] for some j.

Wait, perhaps the idea is to have a sorted multiset of -v[p_i], and then for each k, the k-th smallest element in r is -v[p_j], so -r[i] would be v[p_j].

Then, x = (i + 1) * -r[i] = (i + 1) * v[p_j]

But I'm not sure if this corresponds to the strength for some k.

Moreover, it only iterates up to (n + 1) // 2, which might not be sufficient.

I think there's a better way to approach this problem.

Let me try to think about it again.

For a given k, the available mushrooms are p_k to p_n, since p_1 to p_{k-1} have v=0.

So, for each k, I need to select k mushrooms from p_k to p_n with the highest v.

The strength is k * min(v among these k mushrooms).

To maximize this, I need to maximize k * min(v among the top k mushrooms from p_k to p_n).

I need to find the k that maximizes this value.

One way to do this efficiently is to sort the v[p_k] to v[p_n] in decreasing order for each k, but that's too slow.

An alternative approach is to realize that for a given k, the k-th largest v in p_k to p_n is v[p_j], where p_j is the j-th largest in p_k to p_n.

But this is still not straightforward.

Wait, perhaps I can reverse the permutation p, so p_n to p_k, and build a sorted set.

Let me consider that.

Suppose I reverse p, so p_n, p_{n-1}, ..., p_k.

Then, for each k, the available mushrooms are p_k to p_n.

I can build a SortedMultiset with v[p_k] to v[p_n].

Then, for each k, I can query the k-th largest element in this set.

But building a SortedMultiset for each k is too slow.

Wait, perhaps I can build a SortedMultiset with v[p_1] to v[p_n], and then remove the first k-1 elements to get v[p_k] to p_n.

Then, for each k, I can query the k-th largest element in the remaining set.

But in Python, SortedList or SortedMultiset allows me to delete elements and query the k-th element efficiently.

So, perhaps I can implement this approach efficiently.

Looking back at the given code, it seems to be attempting something similar.

It creates a SortedMultiset r with a = [-v[p[i]-1] for i in range(n)]

So, r contains -v[p[i]-1] sorted in ascending order.

Then, for i in range((n + 1) // 2):

x = (i + 1) * -r[i]

if x > ans:

ans = x

idx = i + 1

r.discard(a[i])

Wait, I think the idea here is to maintain a SortedMultiset of -v[p_i], and for each k, consider the k-th smallest element in r, which is -v[p_j], and compute x = k * (-r[i]) = k * v[p_j].

Then, keep track of the maximum x and the corresponding k.

But I'm not sure if this is correct.

In particular, I'm concerned about the range of i being only up to (n + 1) // 2, which might not cover all possible k.

Moreover, discarding a[i] from r for each i might not correctly represent the available mushrooms for each k.

I think there's a better way.

Let me consider that for a given k, the available mushrooms are p_k to p_n.

So, for each k, I need to consider the set {v[p_k], v[p_{k+1}], ..., v[p_n]}.

Then, select k mushrooms from this set with the highest v.

The strength is k * min(v among these k mushrooms).

To maximize this, I need to choose the k mushrooms with the highest v from p_k to p_n, and take the minimum among them.

So, the min(v among these k mushrooms) is the k-th largest v in p_k to p_n.

Hence, strength = k * (k-th largest v in p_k to p_n).

I need to maximize this over k from 1 to n.

To do this efficiently, I can sort the v in decreasing order and map them back to their positions in p.

Wait, perhaps I can sort the v in decreasing order and find, for each k, the smallest position in p that is >=k.

Wait, maybe not.

An alternative approach is to sort the v in decreasing order and keep track of how many mushrooms are available starting from each k.

Wait, perhaps I need to sort the v in decreasing order and assign them to positions in p in some way.

This is getting too complicated.

Let me consider a different approach.

Suppose I fix the minimum v in the elixir, say m.

Then, I need to pick k mushrooms with v >= m, and k is as large as possible.

But I need to consider that when picking k mushrooms, the first k-1 mushrooms in p have v=0.

Wait, perhaps I can iterate over possible m and find the maximum k for which there are k mushrooms with v >= m among p_k to p_n.

This sounds similar to the initial approach.

Wait, maybe I can sort the v in decreasing order and assign them to positions in p.

Let me try to think differently.

Suppose I sort the permutation p in decreasing order of v[p_i].

Then, p_1 is the mushroom with the highest v, p_2 is the next highest, and so on.

Then, for a given k, the available mushrooms are p_k to p_n.

Among these, the top k mushrooms are p_k to p_{k + k - 1}, but I need to ensure that I don't exceed n.

Wait, perhaps I can sort the v in decreasing order and then assign them to p in some way.

This seems too vague.

Let me look at the sample input again.

Sample Input:

6

3

9 8 14

3 2 1

5

1 2 3 4 5

1 2 3 4 5

6

1 2 3 4 5 6

6 5 4 3 2 1

5

1 4 6 10 10

2 1 4 5 3

4

2 2 5 5

4 2 3 1

5

1 2 9 10 10

1 4 2 3 5

Sample Output:

16 2

9 3

8 2

20 2

5 1

20 2

Looking at the first test case:

n=3

v=[9,8,14]

p=[3,2,1]

According to the output, strength=16, k=2.

So, k=2, strength=2*8=16.

How was this achieved?

When k=2, p_1=3 and p_2=2 have v=0.

So, v[3]=0 and v[2]=0.

Then, the available mushrooms are p_3=1 (v=9), p_2=2 (v=0, cannot use), and p_1=3 (v=0, cannot use).

So, only p_3=1 with v=9 is available.

But to pick k=2 mushrooms, he needs two mushrooms, but only one is available.

So, how is the strength 16?

Wait, perhaps I'm misunderstanding the problem.

Let me read the problem statement again carefully.

"As soon as everyone in the camp fell asleep, Kirill sneaked out of the tent and went to the Wise Oak to gather mushrooms.

It is known that there are n mushrooms growing under the Oak, each of which has magic power v_i. Kirill really wants to make a magical elixir of maximum strength from the mushrooms.

The strength of the elixir is equal to the product of the number of mushrooms in it and the minimum magic power among these mushrooms. To prepare the elixir, Kirill will sequentially pick one mushroom growing under the Oak. Kirill can gather mushrooms in any order.

However, it's not that simple. The Wise Oak informed Kirill of a permutation p of numbers from 1 to n. If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, …, p_{k-1} will become 0. Kirill will not use mushrooms with zero magic power to prepare the elixir.

Your task is to help Kirill gather mushrooms in such a way that he can brew the elixir of maximum possible strength. However, Kirill is a little scared to stay near the oak for too long, so out of all the suitable options for gathering mushrooms, he asks you to find the one with the minimum number of mushrooms."

So, the key point is that when Kirill picks k mushrooms, the first k-1 mushrooms in the permutation p have their magic power set to zero, and he cannot use them in the elixir.

Then, he prepares the elixir using k mushrooms that are not among p_1 to p_{k-1}.

Wait, but in the first sample, for k=2, p_1=3 and p_2=2 have v=0.

So, v[3]=0 and v[2]=0.

Then, he can only use p_3=1 (v=9), p_2=2 (v=0, cannot use), and p_1=3 (v=0, cannot use).

So, only p_3=1 is available.

But to pick k=2 mushrooms, he needs two mushrooms, but only one is available.

So, how is the strength 16 achieved?

Wait, perhaps I need to consider that when he picks k mushrooms, he can only use the mushrooms that are not among p_1 to p_{k-1}.

So, for k=2, p_1=3 and p_2=2 have v=0, so he cannot use p_3=1 and p_2=2.

Wait, but p_3=1 has v=9, which is not set to zero.

Wait, no, p_1=3 has v set to zero, so p_3=1 has v=0.

Wait, the permutation p indicates the order in which mushrooms lose their magic power.

Wait, perhaps p is the order in which he picks the mushrooms.

So, p_1 is the first mushroom he picks, p_2 is the second, and so on.

If he picks k mushrooms, then p_1 to p_{k-1} have their magic power set to zero, and he cannot use them in the elixir.

Then, he prepares the elixir using k mushrooms from the remaining ones, excluding those with zero magic power.

So, for k=2, p_1=3 and p_2=2 have v=0.

Then, the available mushrooms are p_3=1 (v=9), p_4 to p_n (if n > 3).

But in this case, n=3, so only p_3=1 is available with v=9.

But to pick k=2 mushrooms, he needs two mushrooms, but only one is available. So, he can't pick k=2 mushrooms.

But according to the sample