Alright, I've got this problem to solve. Let's see what it's asking for.

So, Kirill wants to pick some mushrooms to make an elixir. Each mushroom has a magic power, and the strength of the elixir is the product of the number of mushrooms used and the minimum magic power among them. That makes sense. But there's a catch: there's a specific order in which the mushrooms are picked, determined by a permutation p, and if he picks k mushrooms, the first k-1 mushrooms in this order have their magic power set to zero and can't be used in the elixir.

My task is to help Kirill maximize the elixir's strength, and among all options that give this maximum strength, choose the one with the minimum number of mushrooms.

First, I need to understand the permutation p. It's a rearrangement of numbers from 1 to n, indicating the order in which mushrooms are considered for having their magic power zeroed out.

Let me think about an example to grasp this better.

Suppose n = 3, v = [9, 8, 14], p = [3, 2, 1].

If Kirill picks k = 1 mushroom, then the first p_1 = 3rd mushroom has its magic power set to zero. So, mushroom 3 is zeroed out, and he can only use mushrooms 1 and 2, with magic powers 9 and 8 respectively. The minimum among them is 8, and since he's using 2 mushrooms, the elixir strength is 2 * 8 = 16.

If he picks k = 2 mushrooms, then the first p_1 = 3rd and p_2 = 2nd mushrooms are zeroed out. So, mushrooms 3 and 2 are zeroed out, and he can only use mushroom 1 with magic power 9. The elixir strength is 1 * 9 = 9.

If he picks k = 3 mushrooms, all mushrooms are zeroed out except the p_3 = 1st mushroom, which is mushroom 1 with magic power 9. So, elixir strength is 1 * 9 = 9.

So, the maximum elixir strength is 16, achieved when k = 1, and the number of mushrooms used is 2.

Wait, but according to the sample input, for this case, the output is "16 2", which matches what I just calculated.

Another sample: n = 5, v = [1,2,3,4,5], p = [1,2,3,4,5].

If k = 1, then p_1 = 1st mushroom is zeroed out. So, mushroom 1 is zeroed out, and he can use mushrooms 2-5 with magic powers 2,3,4,5. Minimum is 2, number is 4, so 4*2=8.

k = 2: p_1=1 and p_2=2 are zeroed out. So, mushrooms 1 and 2 are zeroed out, use mushrooms 3,4,5 with min=3, number=3, so 3*3=9.

k = 3: p_1=1, p_2=2, p_3=3 are zeroed out. Use mushrooms 4 and 5 with min=4, number=2, so 2*4=8.

k = 4: p_1=1, p_2=2, p_3=3, p_4=4 are zeroed out. Use only mushroom 5 with min=5, number=1, so 1*5=5.

k = 5: all are zeroed out except p_5=5, which is mushroom 5, so same as above, 1*5=5.

So, the maximum elixir strength is 9, achieved when k=2, using 3 mushrooms.

Again, matching the sample output "9 3".

Alright, so the task is to find, for each possible k from 1 to n, which mushrooms are available (not zeroed out), find the elixir strength, and choose the k that gives the maximum strength, and among those, the smallest k.

But iterating through all possible k from 1 to n for each test case would be too slow because n can be up to 2e5 and t up to 1e4, so total time would be O(t*n^2), which is way too slow.

I need a smarter way to compute this.

Let me try to model this better.

Given the permutation p, when Kirill picks k mushrooms, the first k-1 mushrooms in p have their magic power set to zero. So, the mushrooms that are not zeroed out are all mushrooms except the first k-1 in p.

Wait, no. The problem says: "the magic power of all mushrooms with indices p_1, p_2, ..., p_{k-1} will become 0". So, p_1 to p_{k-1} are zeroed out, and the remaining mushrooms (p_k to p_n) retain their original magic power.

So, for a given k, the available mushrooms are p_k, p_{k+1}, ..., p_n.

Kirill can choose any subset of these to make the elixir, but he wants to maximize the strength, which is the number of mushrooms times the minimum magic power among them.

To maximize this, he should choose the subset where the minimum magic power is as large as possible, and the number of mushrooms is as large as possible, but since he wants the minimum magic power to be large, he might have to choose fewer mushrooms.

Wait, but he also wants to minimize the number of mushrooms among all options that give the maximum strength.

This seems a bit tricky.

Wait, perhaps I can think differently.

For a given k, the available mushrooms are p_k to p_n, with their original magic powers.

I need to choose a subset of these mushrooms to make the elixir, aiming to maximize the product of the number of mushrooms and the minimum magic power among them.

To maximize this product, I should choose as many mushrooms as possible with as high a minimum magic power as possible.

So, for a given k, among the available mushrooms p_k to p_n, I can sort them in decreasing order of magic power and pick the first m mushrooms where the minimum magic power is maximized.

Wait, but that's not quite right.

Actually, to maximize the product m * min_v, where m is the number of mushrooms and min_v is the minimum magic power among them, I need to choose m such that min_v is as large as possible, and m is as large as possible.

This is similar to finding the maximum m * v for some v in the available mushrooms.

Wait, perhaps I can sort the available mushrooms in decreasing order of magic power and then iterate to find the maximum m * v.

Yes, that seems promising.

So, for each k from 1 to n, I can:

- Get the available mushrooms: p_k to p_n.

- Sort these mushrooms in decreasing order of magic power.

- Then, for m from 1 to number of available mushrooms, compute m * v_m, where v_m is the m-th smallest magic power in the sorted list.

- Find the maximum among these m * v_m.

But sorting for each k would be too slow, since k can be up to 2e5 and t up to 1e4.

I need a better way.

Let me think about this differently.

Suppose I sort all the mushrooms in decreasing order of their magic power.

Let's say I have v_sorted = sorted(v, reverse=True).

Then, for each k, the available mushrooms are p_k to p_n.

I need to consider the subset of v_sorted that are in p_k to p_n.

Wait, that might not be straightforward.

Maybe I should consider the positions in p.

Wait, perhaps I can iterate over k from n down to 1.

For each k, the available mushrooms are p_k to p_n.

I can maintain a data structure that keeps track of the magic powers of p_k to p_n, and efficiently compute the maximum m * v for some v.

Wait, perhaps I can use a sliding window approach.

Wait, maybe I can precompute for each k, the available mushrooms p_k to p_n, and find the maximum m * v among them.

But again, this seems inefficient.

Wait, perhaps I can precompute for each k, the maximum m * v, and then find the maximum among all k.

But I need to do this efficiently.

Let me consider the following approach:

- First, reverse the permutation p, so that p' = p_n, p_{n-1}, ..., p_1.

- Then, for each k, the available mushrooms are p_k to p_n in the original p, which are the first k elements in p'.

- So, I can maintain a data structure that adds elements in the order of p', and for each k, the available mushrooms are the first k elements in p'.

- Then, for each k, I need to choose some subset of these k elements to maximize m * v_min.

Wait, perhaps that's not the best way.

Let me think about another approach.

Suppose I fix the minimum value v, and then find the maximum number m of mushrooms with magic power >= v among the available mushrooms.

Then, the elixir strength is m * v.

I need to maximize m * v over all possible v and m.

But to maximize m * v, I can iterate over v and find the maximum m for each v, then compute m * v and take the maximum.

But I need to consider that for different k, the available mushrooms are different.

Wait, perhaps I can iterate over k from 1 to n, and for each k, find the available mushrooms p_k to p_n, then find the maximum m * v among them.

But again, this seems too slow.

I need a smarter way.

Let me consider the following observation:

For a fixed k, the available mushrooms are p_k to p_n.

I need to choose a subset of these mushrooms to maximize m * v_min.

This is equivalent to choosing m mushrooms with the highest magic powers among p_k to p_n, and setting v_min to the smallest among them.

Wait, no. To maximize m * v_min, I should choose m mushrooms with the highest magic powers, but v_min is the smallest among them.

Wait, actually, to maximize m * v_min, I should choose the m mushrooms with the highest magic powers, but v_min is the smallest among them.

Wait, no, that's not necessarily true.

Wait, suppose I have magic powers [5,4,3,2,1], and I choose m=2, then v_min=4, product=8.

If I choose m=3, v_min=3, product=9.

So, higher m doesn't always lead to higher m * v_min.

I need to find the m that maximizes m * v_min.

This seems similar to the problem of maximizing the product of the number of elements and the smallest element in a subset.

I recall that in such problems, it's often optimal to choose a subset where all elements are >= some threshold v, and then choose m such that m * v is maximized.

So, perhaps for each possible v, I can find the number of mushrooms with v_i >= v, and compute m * v, then take the maximum over v.

But in this problem, for each k, the available mushrooms are p_k to p_n.

So, for each k, I need to consider only those mushrooms.

So, perhaps I can sort the available mushrooms for each k and compute the maximum m * v.

But again, sorting for each k is too slow.

I need a better way.

Wait, perhaps I can sort all mushrooms in decreasing order of their magic power, and then for each k, find how many of them are in p_k to p_n.

Wait, that might work.

Let me try.

Suppose I sort all mushrooms in decreasing order of their magic power: v_sorted.

Then, for each k from 1 to n, the available mushrooms are p_k to p_n.

I need to find, for each k, how many of the top m mushrooms in v_sorted are in p_k to p_n.

Wait, perhaps I can precompute for each mushroom, its position in p.

Then, for each mushroom, I can know its p_index.

Then, for each k, the available mushrooms are those with p_index >= k.

So, for each mushroom, if p_index >= k, it's available.

Now, for each k, I can consider the available mushrooms and find the maximum m * v_min among them.

But I need to do this efficiently over all k.

Wait, perhaps I can iterate over k from n down to 1, and maintain a data structure of available mushrooms.

For example, start with k = n, available mushrooms are p_n.

Then, as k decreases, more mushrooms become available.

So, I can iterate k from n down to 1, adding mushrooms to the data structure, and keeping track of the maximum m * v_min.

Wait, that sounds promising.

Let me try to formalize this.

Initialize a data structure to store available mushrooms.

Start with k = n, available mushrooms are p_n.

Compute the maximum m * v_min for k = n.

Then, decrease k to n-1, add p_{n-1} to the available mushrooms.

Compute the maximum m * v_min for k = n-1.

Continue this way until k = 1.

At each step, add one mushroom to the available set, and compute the new maximum m * v_min.

Finally, among all these maximum m * v_min for each k, choose the overall maximum, and among those, choose the smallest k.

This seems feasible, but I need to efficiently compute the maximum m * v_min for the current available mushrooms.

How can I do that efficiently?

Let me think about how to compute the maximum m * v_min for a set of mushrooms.

One way is to sort the mushrooms in decreasing order of magic power, and then for each possible m, compute m * v_m, where v_m is the m-th smallest magic power, and find the maximum among these.

But sorting at each step would be too slow.

Is there a way to maintain a sorted structure of the available mushrooms and efficiently query the maximum m * v_min?

Yes, perhaps I can use a sorted multiset to store the available mushrooms.

In Python, I can use a sorted list, like the 'sortedcontainers' module, but since we can't import modules, I need to implement something similar.

Wait, in the code provided, there's a class SortedMultiset defined, which seems to implement operations like add, discard, bisect_left, bisect_right, etc.

So, I can use this SortedMultiset to store the available mushrooms in decreasing order of their magic power.

Wait, actually, looking at the code, it seems to be using a list of sorted lists, which allows for O(âˆšn) operations for add and discard, which might be acceptable since n is up to 2e5 and t is up to 1e4.

But let's see what the code is doing.

In the code:

- It reads t, the number of test cases.

- For each test case:

- Reads n, the number of mushrooms.

- Reads the list v of magic powers.

- Reads the permutation p.

- Then, it seems to rearrange v according to p, but I need to check.

Wait, in the code:

a = []

for i in range(n):

a.append(v[p[i] - 1])

So, a is v rearranged according to p, i.e., a[i] = v[p[i+1]], since p is 1-indexed.

Wait, no, p is 1-indexed, so p[1] to p[n] correspond to indices 1 to n.

But in Python, lists are 0-indexed, so p[0] is p_1.

Wait, in the code, p is read as p = list(map(int, input().split())), so p[0] is p_1.

Then, a[i] = v[p[i] - 1], so a[0] = v[p[1] - 1], which is v_{p_1}.

So, a is [v_{p_1}, v_{p_2}, ..., v_{p_n}].

Then, r = SortedMultiset(a)

So, r contains all a[i], i.e., all v_{p_i}, in sorted order.

Wait, but SortedMultiset seems to sort in ascending order.

But I need to work with magic powers in descending order.

Wait, in the problem, for a given k, the available mushrooms are p_k to p_n, which correspond to a[k-1] to a[n-1].

Wait, a[0] = v_{p_1}, a[1] = v_{p_2}, ..., a[n-1] = v_{p_n}.

So, for k, available mushrooms are a[k-1] to a[n-1].

Wait, but in the code, it's r = SortedMultiset(a), which sorts a in ascending order.

Then, in the loop:

for i in range(1, n):

if r.__len__() < i:

break

x = i * r[-i]

if x > ans:

ans = x

idx = i

r.discard(a[i - 1])

So, it's iterating i from 1 to n-1.

For each i, it checks if the length of r is at least i.

Then, x = i * r[-i], which is i * the i-th largest element in r.

Then, it updates ans and idx if x > ans.

Then, it discards a[i-1] from r.

Wait, r starts as SortedMultiset(a), which is sorted in ascending order.

r[-i] is the i-th largest element.

So, r[-1] is the largest, r[-2] is the second largest, etc.

So, x = i * r[-i] is i times the i-th largest element in the available mushrooms.

Then, it discards a[i-1], which is v_{p_i}.

Wait, but in the problem, for k mushrooms, the available mushrooms are p_k to p_n, i.e., a[k-1] to a[n-1].

In the loop, for i from 1 to n-1, it seems to be considering r as the available mushrooms, and updating r by discarding a[i-1].

Wait, perhaps the loop variable i corresponds to k.

Wait, maybe i corresponds to k.

Let's see.

For i=1, r contains all a[j], j from 0 to n-1.

x = 1 * r[-1], which is 1 times the largest a[j].

Then, discard a[0], which is v_{p_1}.

For i=2, r contains a[1] to a[n-1].

x = 2 * r[-2], which is 2 times the second largest in a[1:].

And so on.

So, it seems to be considering, for k=i, available mushrooms are a[k-1:] = p_k to p_n.

Then, x = i * the i-th largest in a[k-1:].

Wait, but in the code, r starts as a[0:] and discards a[0], then a[1], etc.

So, for i=1, r = a[0:], x = 1 * r[-1] = 1 * max(a[0:])

Then discard a[0], so r = a[1:]

For i=2, r = a[1:], x = 2 * r[-2] = 2 * second largest in a[1:]

Wait, but r[-2] is the second largest in a[1:], so x = 2 * second largest in a[1:]

Is this correct?

Wait, in the problem, for k=1, available mushrooms are p_1 to p_n, which are a[0:].

Then, Kirill can choose any subset of these, and the elixir strength is m * min_v among the chosen subset.

To maximize m * min_v, he should choose m mushrooms with the highest magic powers.

Then, the optimal m is the one that maximizes m * v_m, where v_m is the m-th highest magic power in a[0:].

But in the code, it's taking x = 1 * max(a[0:]), which is 1 * v_max.

Then, for i=2, x = 2 * second_max(a[1:]), but it's discarding a[0], which is v_{p_1}.

Wait, I think there's a confusion here.

I think the code is trying to iterate over k from 1 to n, and for each k, consider the available mushrooms as p_k to p_n, which are a[k-1:].

Then, it wants to choose m mushrooms from a[k-1:], with m * v_min.

To maximize m * v_min, it should choose m such that v_min is as large as possible, and m is as large as possible.

This is similar to choosing the top m elements from a[k-1:], and setting v_min to the m-th element.

Then, x = m * v_m.

But in the code, it's setting x = i * r[-i], where r is sorted(a[k-1:]), and r[-i] is the i-th largest in a[k-1:].

So, it's choosing m = i and v_min = i-th largest in a[k-1:].

But is this the optimal choice?

Wait, no.

Because in reality, to maximize m * v_min, I need to choose m and v_min such that m * v_min is maximized.

This is not necessarily choosing m = i and v_min = i-th largest.

I think the code is incorrect in this approach.

Let me consider a simple example.

Suppose n=3, v=[9,8,14], p=[3,2,1].

Then, a = [v[p[1]-1], v[p[2]-1], v[p[3]-1]] = [v[3], v[2], v[1]] = [14,8,9].

So, a = [14,8,9].

Then, r = SortedMultiset(a) = [8,9,14].

For i=1:

r has 3 elements: [8,9,14]

x = 1 * r[-1] = 1 * 14 = 14

ans = 14, idx=1

discard a[0]=14, r becomes [8,9]

For i=2:

r has 2 elements: [8,9]

x = 2 * r[-2] = 2 * 8 = 16

16 > 14, so ans=16, idx=2

discard a[1]=8, r becomes [9]

For i=3:

r has 1 element: [9]

x = 3 * r[-3]

But r has only 1 element, so len(r) < 3, break.

So, ans=16, idx=2.

But according to the first sample, it should be 16 2, which matches.

Another sample: n=5, v=[1,2,3,4,5], p=[1,2,3,4,5]

Then, a = [v[1],v[2],v[3],v[4],v[5]] = [1,2,3,4,5]

r = SortedMultiset(a) = [1,2,3,4,5]

For i=1:

x=1*5=5

ans=5, idx=1

discard a[0]=1, r=[2,3,4,5]

For i=2:

x=2*4=8 >5, ans=8, idx=2

discard a[1]=2, r=[3,4,5]

For i=3:

x=3*3=9 >8, ans=9, idx=3

discard a[2]=3, r=[4,5]

For i=4:

x=4*4=16 >9, ans=16, idx=4

discard a[3]=4, r=[5]

For i=5:

x=5*5=25 >16, ans=25, idx=5

discard a[4]=5, r=[]

But according to the sample, for n=5, v=[1,2,3,4,5], p=[1,2,3,4,5], the output should be "9 3".

But according to this, it would output 25 5, which is incorrect.

Wait, perhaps I misunderstood the problem.

Wait, in the problem, for k mushrooms picked, the first k-1 mushrooms in p have their magic power set to zero, and the available mushrooms are p_k to p_n.

Then, Kirill can choose any subset of these available mushrooms to make the elixir.

In the first sample, for k=1, available mushrooms are p_1 to p_n, which are all mushrooms, but p_1 is zeroed out, so v_{p_1}=14 becomes 0, so available mushrooms are p_2 and p_3, which are v_2=8 and v_3=9.

So, available mushrooms have v=8 and 9.

Then, Kirill can choose both, m