Alright, I've got this problem to solve. Let's see what it's asking for. There are n children in a class, and m pairs among them are friends with some friendship value. The teacher goes on k excursions, and for each excursion, she randomly chooses a pair of children equiprobably and independently. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0, which never changes.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, and this sum should be considered at the time each pair is chosen. Also, the answer should be expressed as a fraction p/q where p and q are coprime, and I need to compute p * q^{-1} mod (10^9 + 7).

First, I need to understand the process:

1. There are n children, and m pairs of friends with given friendship values.

2. For each excursion, a pair of children is chosen randomly and uniformly from all possible pairs (order doesn't matter, so it's combinations, not permutations).

3. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

4. The friendship value of non-friend pairs is always 0 and never changes.

5. I need the expected sum of the friendship values at the time each pair is chosen over k excursions.

Let me think about how to approach this.

First, I need to understand how the friendship values change over time.

- Initially, each friend pair has a certain friendship value f_i.

- Each time a friend pair is chosen, their f_i increases by 1 for all subsequent choices.

- Non-friend pairs always have f=0.

So, for each excursion, the chosen pair's f_i is added to the sum, and if they are friends, their f_i increases by 1 for future excursions.

But the problem says to consider the friendship value at the time of choice, meaning that for each excursion, whatever the current f_i of the chosen pair is, that gets added to the sum.

I need to find the expected value of the total sum over k excursions.

Let me consider the total sum S = sum_{t=1 to k} f_t, where f_t is the friendship value of the pair chosen at time t.

I need E[S] = sum_{t=1 to k} E[f_t].

So, if I can find E[f_t] for each t, then E[S] is just k * E[f_t], since each excursion is independent and identically distributed.

Wait, but the friendship values can change over time because choosing a friend pair increases their f_i for future excursions.

Hmm, that complicates things because the choices are not independent; choosing a pair affects future choices.

Wait, but the problem says to consider the friendship value at the time of being chosen, so the increase happens after that.

Let me think again.

- At each step, choose a pair uniformly at random from all possible pairs.

- If they are friends, their f_i increases by 1 for all subsequent steps.

- Non-friend pairs always have f=0.

So, for each step t, f_t is the friendship value of the pair chosen at time t.

Since the choice is uniform and independent each time, but the f_i of friend pairs increases by 1 each time they are chosen, this seems like a process where the friendship values are increasing over time.

But I need to find the expected sum of f_t over k steps.

I think I need to model this process more carefully.

Let me consider the total number of possible pairs: total_pairs = C(n,2) = n*(n-1)/2.

Out of these, m are friend pairs with initial friendship values f_i.

Non-friend pairs have f=0 permanently.

At each step:

- Choose a pair uniformly at random from all pairs.

- If it's a friend pair, add its current f_i to the sum and then increase f_i by 1 for future steps.

- If it's not a friend pair, add 0 to the sum and nothing changes.

Since the choices are independent, but the f_i of friend pairs increase over time, this seems like a stochastic process where the friendship values are increasing over time in a non-trivial way.

This seems complicated. Maybe there's a smarter way to compute the expected sum.

Let me think about the expected contribution of each friend pair to the total sum.

Let me denote the friend pairs as pairs (a_i, b_i) with initial friendship value f_i.

Let me think about the expected number of times each friend pair is chosen in the k excursions.

Since each pair is chosen uniformly at random, the probability of choosing any particular pair in one excursion is 2 / (n*(n-1)) if n>=2 (since C(n,2) = n*(n-1)/2).

Wait, actually, C(n,2) = n*(n-1)/2, so the probability of choosing any specific pair is 1 / C(n,2) = 2 / (n*(n-1)).

Wait, no, C(n,2) is n*(n-1)/2, so 1 / C(n,2) = 2 / (n*(n-1)).

Wait, actually, no. C(n,2) = n*(n-1)/2, so 1 / C(n,2) = 2 / (n*(n-1)).

But in programming terms, it's better to think in terms of C(n,2).

So, probability of choosing any specific pair in one excursion is p = 1 / C(n,2).

Now, for a friend pair, each time it's chosen, its f_i increases by 1 for future excursions.

So, the first time it's chosen, its f_i at the time of choice is f_i.

The second time it's chosen, its f_i would be f_i +1.

The third time, f_i +2, and so on.

So, for a friend pair, if it's chosen t times during the k excursions, its contribution to the total sum would be f_i + (f_i +1) + (f_i +2) + ... + (f_i + (t-1)) = t*f_i + t*(t-1)/2.

But since the choices are independent, modeling the number of times a specific pair is chosen follows a binomial distribution with parameters k and p = 1 / C(n,2).

But since k can be up to 2*10^5 and n up to 10^5, C(n,2) can be up to ~5*10^9, so p can be very small.

This seems computationally intensive to handle directly.

Maybe there's a better way to compute the expected sum.

Let me consider the linearity of expectation.

The total sum S is the sum over k excursions of f_t, where f_t is the friendship value of the pair chosen at time t.

By linearity of expectation, E[S] = sum_{t=1 to k} E[f_t].

Now, since each excursion is independent and identically distributed (i.i.d.), E[f_t] is the same for all t.

Therefore, E[S] = k * E[f], where E[f] is the expected friendship value of a randomly chosen pair.

But wait, the friendship value of a pair increases over time if it's a friend pair.

So, actually, E[f_t] changes over time because the friendship values are increasing each time a friend pair is chosen.

This complicates things because the expectations are not identical over time.

This seems like a dynamic process where the expected value changes based on past choices.

This seems quite involved.

Maybe I need to think differently.

Let me consider that at each step, the expected increase in the friendship value of a friend pair is dependent on how many times it has been chosen in the past.

But that seems too vague.

Perhaps I should think about the total expected sum in terms of the contributions from each friend pair over all possible choices.

Let me denote the set of friend pairs as F, with |F| = m.

Each friend pair has an initial friendship value f_i, and this increases by 1 each time the pair is chosen.

Non-friend pairs always contribute 0.

So, for each friend pair j, let X_j be the number of times it is chosen in the k excursions.

Then, the total sum S = sum_{j=1 to m} f_j * X_j + sum_{t=1 to X_j} (t-1), but that seems off.

Wait, more carefully:

For each friend pair j, each time it is chosen, its contribution to S is its current f_j plus the number of times it has been chosen so far minus one.

Wait, perhaps it's better to think in terms of the order of selections.

This seems complicated.

Maybe I need to model this as a process where at each step, the expected increase in the total sum is calculated based on the current friendship values.

But that seems too vague.

Let me try to compute E[S] directly.

Since S is the sum of k random variables, each corresponding to the friendship value of the pair chosen at that step, E[S] = sum_{t=1 to k} E[f_t].

But since the choices are independent, E[f_t] is the same for all t, assuming no dependency on previous choices.

However, the friendship values do depend on previous choices, so this might not hold.

Wait, but the problem says that the teacher chooses a pair equiprobably and independently, but the friendship values increase by 1 for all subsequent excursions if the pair is chosen and they are friends.

So, the friendship values can increase over time, making later E[f_t] higher than earlier ones.

This suggests that E[f_t] is not constant over t, so I cannot simply compute E[f] and multiply by k.

This seems tricky.

Maybe I need to think about the expected increase in friendship values over time.

Alternatively, perhaps I can model this as a Markov process, where the state is the current friendship values of all friend pairs, and transitions depend on which pair is chosen.

But with n up to 1e5 and m up to 1e5, this seems computationally infeasible.

There must be a smarter way to compute the expected sum.

Let me consider the following approach:

- At any point, the expected friendship value of the chosen pair is the sum over all friend pairs of their current friendship value multiplied by the probability of choosing that pair.

- Since pairs are chosen uniformly at random, the probability of choosing any specific pair is 1 / C(n,2).

- So, E[f_t] = sum_{j=1 to m} f_j(t) / C(n,2), where f_j(t) is the friendship value of pair j at time t.

But f_j(t) depends on how many times pair j has been chosen in the previous t-1 steps.

This seems too recursive.

Perhaps I need to think about the expected total sum differently.

Wait, maybe I can consider that each friend pair contributes to the total sum based on the number of times it is chosen, and each choice increases its f_j for future choices.

This seems complicated.

Let me try to think about small examples to see if I can find a pattern.

Take the second test case from the example:

n=2, m=1, k=10

friendship: pair (1,2) with f=1

So, there is only one friend pair, and C(2,2)=1 pair in total.

So, p = 1 / 1 = 1.

So, in each excursion, the pair (1,2) is always chosen.

Initially, f=1.

Each time it's chosen, its f increases by 1 for future excursions.

So, the sequence of f_t would be:

t=1: f=1, then f increases to 2 for t=2

t=2: f=2, then f increases to 3 for t=3

...

t=10: f=10, f increases to 11 for future (but there are no more excursions)

So, the sum S = 1 + 2 + 3 + ... + 10 = 55

And indeed, the output for this test case is 55.

Another test case:

n=100, m=0, k=24

No friend pairs, so all pairs have f=0.

So, S = 0 + 0 + ... + 0 = 0

Output is 0.

Third test case:

n=3, m=1, k=2

friendship: pair (2,1) with f=1

C(3,2)=3 pairs: (1,2), (1,3), (2,3)

Assuming (2,1) is the same as (1,2), so m=1.

So, p = 1 / 3

So, probability of choosing the friend pair in each excursion is 1/3, and non-friend pairs is 2/3.

Let's see what happens:

- At t=1:

Choose (1,2): probability 1/3, f=1, then f increases to 2 for t=2

Choose (1,3): probability 2/3, f=0

Choose (2,3): probability 2/3, f=0

- At t=2:

If (1,2) was chosen at t=1:

Choose (1,2): probability 1/3, f=2, then f increases to 3 for t=3

Choose (1,3): probability 2/3, f=0

Choose (2,3): probability 2/3, f=0

If (1,2) was not chosen at t=1:

Choose (1,2): probability 1/3, f=1, then f increases to 2 for t=3

Choose (1,3): probability 2/3, f=0

Choose (2,3): probability 2/3, f=0

This is getting complicated.

Let me try to compute E[S] for k=2.

E[S] = E[f_1 + f_2] = E[f_1] + E[f_2]

Compute E[f_1]:

At t=1, E[f_1] = (1/3)*1 + (2/3)*0 = 1/3

Compute E[f_2]:

At t=2, there are two scenarios:

- If (1,2) was chosen at t=1 (probability 1/3), then f_2 = 2 with probability (1/3), or 0 with probability (2/3)

- If (1,2) was not chosen at t=1 (probability 2/3), then f_2 = 1 with probability (1/3), or 0 with probability (2/3)

So, E[f_2] = (1/3) * [ (1/3)*2 + (2/3)*0 ] + (2/3) * [ (1/3)*1 + (2/3)*0 ] = (1/3)*(2/3) + (2/3)*(1/3) = (2/9 + 2/9) = 4/9

Therefore, E[S] = 1/3 + 4/9 = (3 + 4)/9 = 7/9

Now, 7/9 mod (10^9 + 7) is 7 * 9^{-1} mod (10^9 + 7)

But actually, since denominator can be up to C(n,2)^k, which is huge, and we need to compute p * q^{-1} mod (10^9 + 7), where p and q are coprime.

But in this case, 7 and 9 are not coprime? Wait, 7 and 9 are coprime, since gcd(7,9)=1.

So, p=7, q=9, and q^{-1} mod (10^9 + 7) is the modular inverse of 9 modulo (10^9 + 7).

Compute 9^{-1} mod (10^9 + 7):

Since 9 * 481481482 = 4333333338 ≡ 1 mod (10^9 + 7), because 4333333338 - 4 * (10^9 + 7) = 4333333338 - 4000000028 = 333333310, which is still larger than 10^9 + 7, so 4333333338 - 4*(10^9 + 7) = 4333333338 - 4000000028 = 333333310, and 333333310 - 3*(10^9 + 7) = 333333310 - 3000000021 = -266666711, which is negative. So, 9 * 481481482 ≡ 1 mod (10^9 + 7).

Therefore, 9^{-1} ≡ 481481482 mod (10^9 + 7)

So, p * q^{-1} = 7 * 481481482 mod (10^9 + 7) = 3370370374 mod (10^9 + 7) = 3370370374 - 3*(10^9 + 7) = 3370370374 - 3000000021 = 370370353

But according to the sample output, it's 777777784, which is likely 7 * 111111112 mod (10^9 + 7), but 111111112 is 9^{-1}.

Wait, perhaps I miscalculated 9^{-1}.

Actually, 9 * 111111112 = 9999999984, which is 9999999984 - 9*(10^9 + 7) = 9999999984 - 9000000063 = 999999921, which is still large, so 999999921 - 9*(10^9 + 7) = 999999921 - 9000000063 = -8000000142, which is negative. So, perhaps 9 * 111111112 ≡ 9999999984 - 9*(10^9 + 7) = 9999999984 - 9000000063 = 999999921, which is still larger than 10^9 + 7, so 999999921 - 1*(10^9 + 7) = 999999921 - 1000000007 = -86, which is not 1. So, perhaps I need to compute 9^{-1} properly.

Actually, 9 * 481481482 = 4333333338, and 4333333338 - 4*(10^9 + 7) = 4333333338 - 4000000028 = 333333310, which is still large, so 333333310 - 3*(10^9 + 7) = 333333310 - 3000000021 = -266666711, which is negative. So, perhaps 9 * 111111112 = 9999999984 - 9*(10^9 + 7) = 9999999984 - 9000000063 = 999999921, which is still large, so 999999921 - 1*(10^9 + 7) = 999999921 - 1000000007 = -86, which is not 1. So, perhaps 9^{-1} is not 111111112.

Wait, maybe I need to use the extended Euclidean algorithm to compute 9^{-1} mod (10^9 + 7).

Compute gcd(9, 10^9 + 7) = gcd(9, 1000000007):

1000000007 mod 9 = 1000000007 - 111111111*9 = 1000000007 - 999999999 = 8

8 mod 9 = 8

9 mod 8 = 1

8 mod 1 = 0

So, gcd is 1, and coefficients are such that 9*(-111111112) + (10^9 + 7)*1 = 1

Therefore, 9^{-1} ≡ -111111112 mod (10^9 + 7) ≡ 10^9 + 7 - 111111112 = 1000000007 - 111111112 = 888888895

Wait, but according to the sample output, it's 777777784, which is likely 7 * 111111112 mod (10^9 + 7), but according to the calculation above, 9^{-1} is actually 888888895.

Wait, perhaps I messed up the calculations.

Let me verify:

Compute 9 * 111111112 = 9999999984

9999999984 mod (10^9 + 7) = 9999999984 - 9*(10^9 + 7) = 9999999984 - 9000000063 = 999999921

999999921 - 1*(10^9 + 7) = 999999921 - 1000000007 = -86, which is not 1.

So, 111111112 is not the inverse.

Compute 9 * 888888895 = 8000000055

8000000055 mod (10^9 + 7) = 8000000055 - 8*(10^9 + 7) = 8000000055 - 8000000056 = -1, which is equivalent to 10^9 + 6 mod (10^9 + 7)

Not 1, so that's not right either.

Wait, perhaps I need to compute the inverse properly.

Use the formula for inverse: a^{-1} mod m = a^{m-2} mod m if m is prime.

Given that 10^9 + 7 is prime, 9^{-1} ≡ 9^{(10^9 + 5)} mod (10^9 + 7)

But that's computationally intensive without a fast exponentiation method.

Alternatively, use the extended Euclidean algorithm.

Let me try to compute 9^{-1} mod (10^9 + 7):

We have 10^9 + 7 = 1000000007

Divide 1000000007 by 9:

1000000007 / 9 = 111111111 with a remainder of 8, since 9*111111111 = 999999999, and 1000000007 - 999999999 = 8

Now, apply extended Euclidean:

9 = 9*1 + 0

8 = 9 - 1*8 = 9 - 1*(1000000007 - 