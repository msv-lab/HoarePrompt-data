Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual compared to standard stone-removal games. Let's try to understand the problem step by step.

First, the game setup: There are n piles of stones, and each pile has a certain number of stones, given by a_1, a_2, ..., a_n. Players take turns, and on each turn, a player chooses a positive integer k that is less than or equal to the smallest number of stones in any nonempty pile. Then, the player removes k stones from each nonempty pile. The player who can't make a move loses, which means when all piles are empty.

Alice goes first, and both players play optimally. I need to determine who wins each game for multiple test cases.

Looking at the input format: The first line is t, the number of test cases. Then, for each test case, there's n, the number of piles, followed by n integers representing the number of stones in each pile.

Constraints are important here: t can be up to 10^4, and n can be up to 2*10^5 per test case, with a_i up to 10^9. Also, the sum of n over all test cases doesn't exceed 2*10^5. So, efficiency is key to handle large inputs within time limits.

Let me think about the game mechanics. The interesting part is that on each turn, the player removes k stones from every nonempty pile, where k is at most the smallest pile's size. This is different from traditional Nim or other stone-removal games where stones are removed from one pile at a time.

I need to find a way to determine the winner without simulating the entire game, which would be too slow given the constraints.

First, I should look for a pattern or a mathematical property that can help determine the winner based on the initial configuration of the piles.

Let me consider some small examples to see if I can find a pattern.

Example 1:

n = 5

a = [3, 3, 3, 3, 3]

Alice can choose k=3 and remove 3 stones from each pile, emptying all piles at once. So, Alice wins.

Example 2:

n = 2

a = [1, 7]

Alice must choose k=1 (since the smallest pile has 1 stone), removing 1 stone from both piles. Now, piles are [0, 6]. Since one pile is empty, the smallest nonempty pile has 6 stones. Bob can choose k=1, removing 1 stone from the pile of 6, making it 5. Alice can choose k=1 again, and so on. It seems like Bob can force a win here.

Wait, but according to the sample output, Bob wins this case.

Example 3:

n = 7

a = [1, 3, 9, 7, 4, 2, 100]

This looks more complicated. I need a better approach.

I recall that in games like this, the concept of the "Nimber" or "xor" value is often used to determine the winner. Maybe I can model this game in terms of Nim heaps.

But first, I need to understand the game's state and how moves affect it.

Let me think differently. Each move consists of selecting a k and subtracting k from all nonempty piles. This is equivalent to removing k from each pile, but only from piles that still have stones.

Wait, actually, it's from each nonempty pile at the time of the move.

This seems similar to the game of Nim, but with a twist because k is subtracted from multiple piles at once.

I need to find the game's "Nim-equivalence" or something similar.

Another approach: Think about the number of moves required to empty all piles.

If the total number of moves is odd, Alice wins; if even, Bob wins.

But I need to verify if this is true.

In the first example, Alice makes one move to empty all piles. That's odd number of moves, so Alice wins.

In the second example, Alice makes the first move, removing 1 from both piles, making one pile empty. Then Bob makes a move, removing 1 from the remaining pile, and so on. It seems like it would take an even number of moves to empty all piles, so Bob wins.

Wait, but in the second example, Alice can keep removing 1 each time, and since the second pile has 6 stones, it would take 6 moves to empty it, with Alice making the 1st, 3rd, 5th moves, and Bob making the 2nd, 4th, 6th moves. So Bob makes the last move, meaning Bob wins.

So, in this case, even number of moves lead to Bob winning.

Wait, but if I think about it differently, maybe the number of moves is equal to the number of stones in the smallest pile, which is 1 in this case. But no, that doesn't seem right.

Wait, in the second example, after Alice's first move, one pile is empty, and the other has 6 stones. Then Bob can choose k=1 and remove 1 stone from the pile of 6, making it 5. Alice can choose k=1 again, and so on, until the pile is empty.

So, it's like the number of moves is equal to the number of stones in the largest pile after Alice's first move.

This seems too vague. I need a better way to model this.

Let me consider the game in terms of "invariant" or "game state symmetry."

Alternatively, maybe I can think of the game as a subtraction game where the subtraction is applied to multiple piles.

Wait, perhaps I can think of each pile as a separate game and combine them somehow.

I recall that in combinatorial game theory, games consisting of independent subgames can be analyzed using the "Nim-sum," which is the xor of the sizes of the Nim-heaps.

But in standard Nim, players choose one heap and remove any number of stones from it. Here, players choose a k and remove k stones from all nonempty piles.

So, it's different from standard Nim.

I need to find the "Nimber" or "xor" value for this game.

Alternatively, maybe there's a way to reduce this game to standard Nim.

Let me try to model this game.

Suppose we have piles with a_1, a_2, ..., a_n stones.

A move consists of selecting k >= 1, where k <= min(a_i for a_i > 0), and then subtracting k from each a_i that is greater than 0.

After the subtraction, any pile that becomes 0 is removed from consideration for choosing k in future moves, but it remains in the pile list.

Wait, no, the piles that become 0 are just empty, but they still count as piles for choosing k, but k can only be up to the smallest nonempty pile.

So, the game continues until all piles are empty.

I need to find a way to calculate the "Nimber" of this game.

Alternatively, perhaps there's a mathematical formula based on the sorted piles.

Wait, in the code provided, it sorts the unique pile sizes and checks if they form a consecutive sequence starting from 1.

Let me look at the provided code:

def func_1(arr):

A = False

if arr[0] != 1:

return 'Alice'

set_ = list(set(arr))

set_.sort()

not_c = True

for i in range(1, len(set_)):

if set_[i] - set_[i - 1] > 1:

not_c = False

break

A = not A

if not_c:

A = not A

return 'Alice' if A else 'Bob'

This code first checks if the smallest pile is not 1. If it's not 1, Alice wins. Otherwise, it checks if the unique pile sizes form a consecutive sequence starting from 1. If they do, it sets A to the negation of A, and if the sequence is consecutive, it negates A again.

This seems overly complicated and not clearly aligned with standard game theory concepts. I need to verify if this logic is correct.

Let me test this logic with the sample inputs.

Sample Input 1:

5

3 3 3 3 3

According to the code:

arr = [3,3,3,3,3]

set_ = [3]

set_.sort() = [3]

Since set_[i] - set_[i-1] >1 for i=1 (but there's only one element), not_c remains True.

A starts as False.

Since arr[0]==3 !=1, return 'Alice', which matches the sample output.

Sample Input 2:

2

1 7

arr = [1,7]

set_ = [1,7]

sorted: [1,7]

check i=1: 7-1=6 >1, so not_c = False

A = not A → A = True

since not_c = False, do nothing

return 'Alice' if A else 'Bob' → 'Bob', which matches the sample output.

Sample Input 3:

7

1 3 9 7 4 2 100

arr = [1,3,9,7,4,2,100]

set_ = [1,2,3,4,7,9,100]

sorted: [1,2,3,4,7,9,100]

check i from 1 to 6:

2-1=1 <=1

3-2=1 <=1

4-3=1 <=1

7-4=3 >1 → not_c = False

A = not A → A = True

since not_c = False, no further action

return 'Alice' if A else 'Bob' → 'Alice', matches sample output.

Another sample:

3

1 2 3

set_ = [1,2,3]

sorted: [1,2,3]

check i=1:2-1=1 <=1

i=2:3-2=1 <=1

not_c remains True

A = not A → A = True

since not_c = True, A = not A → A = False

return 'Alice' if A else 'Bob' → 'Bob', but according to sample output, it's 'Alice'.

Wait, sample output for this case is "Alice", so the code is wrong here.

Wait, let's check the sample input again.

Looking back at the sample input:

7

5

3 3 3 3 3

2

1 7

7

1 3 9 7 4 2 100

3

1 2 3

6

2 1 3 4 2 4

8

5 7 2 9 6 3 3 2

1

1000000000

Corresponding outputs:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

So, for n=3, a=[1,2,3], the code would set A=False, arr[0]=1==1, so proceed.

set_=[1,2,3], sorted=[1,2,3]

check i=1:2-1=1 <=1

i=2:3-2=1 <=1

not_c=True

A=not A → A=True

since not_c=True, A=not A → A=False

return 'Bob', but sample output is 'Alice'. So, the code is incorrect for this case.

Hence, the code is wrong.

Therefore, Correctness: False

**Final Answer**

\[\boxed{\text{False}}\]