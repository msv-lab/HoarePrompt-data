Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. If it's impossible to make it not beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if I can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ n-1) such that a[i-1] equals a[i+1], and replace a[i] with a[i-1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. This operation can be repeated as many times as I want.

My task is to remove the minimum number of elements from this array to make it not beautiful. That means, after removal, I should not be able to make all elements the same using the above operation.

Looking at the examples:

1. For n=3 and array [2,2,2], it's already all the same, and no matter how many elements I remove, it remains beautiful. So, output is -1.

2. For n=5 and array [1,2,1,2,1], removing one element can make it not beautiful.

3. For n=1, with a single element, it's already not beautiful because there are no indices i where 2 ≤ i ≤ n-1. So, output is -1.

4. For n=7 and array [3,3,3,5,3,3,3], removing the first three elements leaves [5,3,3,3], which is not beautiful.

From these examples, I need to find a pattern or a property that determines the minimum number of removals needed.

Let me think about the properties of a beautiful array. Since the operation allows me to change a[i] to a[i-1] if a[i-1] equals a[i+1], this seems like a way to propagate values through the array.

In fact, it looks similar to filling in gaps where the neighbors are the same. So, if there are sections of the array where elements are the same, and there are different elements in between, I might need to remove those different elements to prevent the array from becoming uniform.

Wait, but in the second example, [1,2,1,2,1], removing one element can break the beauty. If I remove the second element (2), I get [1,1,2,1], which might still be beautiful. Wait, according to the explanation, removing the fifth element makes it [1,2,1,2], which cannot be made uniform.

Let me try to understand why [1,2,1,2] is not beautiful. If I try to apply the operation:

- Choose i=2: a[1]=1, a[3]=1, so replace a[2]=2 with a[1]=1, resulting in [1,1,1,2]. From here, I can't make all elements 1 because a[4]=2 doesn't match.

- Or choose i=3: a[2]=1, a[4]=2, which are different, so no operation can be performed.

Thus, it's not possible to make all elements the same, so the array is not beautiful.

Another way to look at it is that after removal, there should be no way to propagate values to make all elements equal.

So, my goal is to remove elements in such a way that the remaining array cannot have all its elements made equal by applying the operation.

I need to find the minimum number of removals to achieve this.

First, I need to understand when an array cannot be made beautiful. That is, even after applying the operations any number of times, not all elements become the same.

One scenario is when there are at least two different elements that cannot be made the same through the operations.

But this seems a bit vague. Maybe I need to look for substrings or subsequences that prevent uniformity.

Wait, perhaps I should consider the run lengths of identical elements.

Let's consider runs of the same value. If there are multiple runs of different values, removing elements between these runs might prevent the array from becoming uniform.

Wait, but in the second example, [1,2,1,2,1], it has runs of 1,2,1,2,1. Removing one element can break this pattern.

Wait, perhaps the key is to have at least two different values that are separated in such a way that their runs cannot be merged by the operations.

But I'm not sure.

Let me consider the problem differently. Suppose the array is already uniform, like [2,2,2]. Then, no matter how many elements I remove, it remains uniform. So, output is -1.

If the array has multiple values but can be made uniform by operations, then I need to remove elements to prevent that.

Wait, the problem says that the given array is beautiful, so I don't need to check if it's beautiful or not, but to make it not beautiful by removing elements.

I need to find the minimal number of removals to make it not beautiful.

Wait, perhaps it's about making sure that after removal, there are at least two different values that cannot be made the same through operations.

But I need a more concrete approach.

Let me consider the frequency of the most frequent value.

If I can make the entire array consist of the most frequent value, then the array is beautiful.

Wait, but the operation allows changing some elements to make all elements equal to a certain value.

Actually, the operation allows changing a[i] to a[i-1] under certain conditions, but it's not directly about making all elements equal to the most frequent value.

Wait, perhaps I need to think in terms of the most frequent value and see how many changes are needed to make the array consist of only that value.

But I'm not sure.

Wait, perhaps I need to look at the runs of the most frequent value and see how many elements are separating these runs.

For example, in [1,2,1,2,1], if 1 is the most frequent value, I need to remove the 2's separating the runs of 1's.

But in this case, removing one 2 would leave [1,1,2,1], which is still beautiful because I can apply operations to make all 1's.

Wait, no, according to the explanation, [1,2,1,2] is not beautiful.

Wait, perhaps I need to remove enough elements so that the remaining array has at least two different values that cannot be made the same through operations.

This is getting confusing.

Let me look at the fourth example: [3,3,3,5,3,3,3]. If I remove the first three 3's, I get [5,3,3,3]. Now, in this array, I cannot make all elements 3 because there's a 5 in the middle, and I cannot change it using the operation.

Similarly, I cannot make all elements 5 because there are multiple 3's that cannot be changed to 5.

Thus, the array [5,3,3,3] is not beautiful.

So, in this case, removing three 3's achieves the goal.

I need to find the minimal number of removals to achieve such a state.

Wait, perhaps the minimal number of removals is related to the number of runs of the most frequent value.

Wait, in the second example, [1,2,1,2,1], the most frequent value is 1, with three runs: [1], [1], [1], separated by 2's.

To make the array not beautiful, I need to ensure that after removal, there are elements that cannot be made the same through operations.

In this case, removing one element might be sufficient, but according to the sample output, it's 1.

Wait, but in the explanation, removing the fifth element makes it [1,2,1,2], which is not beautiful.

Let me see why [1,2,1,2] is not beautiful.

- If I try to apply the operation on i=2 (a[1]=1, a[3]=1, so replace a[2]=2 with 1), resulting in [1,1,1,2]. From here, I cannot make all elements 1 because there's a 2 at the end that doesn't have a[i-1]=a[i+1] to change it.

- Alternatively, choosing i=3 (a[2]=1, a[4]=2, which are different, so no operation can be performed).

Thus, it's impossible to make all elements the same, so the array is not beautiful.

So, in this case, removing one element is sufficient.

In the fourth example, [3,3,3,5,3,3,3], removing the first three 3's leaves [5,3,3,3], which is not beautiful for similar reasons.

Now, I need a general approach to find the minimal number of removals.

Perhaps, the key is to find the minimal number of elements to remove so that the remaining array has at least two different values, and these values are separated in such a way that operations cannot make them uniform.

But this seems too vague.

Let me consider that if the array consists of only one unique value, it's impossible to make it not beautiful by removals, as any subset will still be uniform.

So, if all elements are the same, output is -1.

In other cases, where there are multiple values, I need to remove elements to prevent the array from becoming uniform.

Wait, but in the third example, n=1, with a single element, it's already not beautiful because there are no indices i where 2 ≤ i ≤ n-1. So, output is -1.

Wait, but according to the problem, for n=1, it's considered not beautiful, so output is -1.

For n=2, it's also not beautiful because there are no indices i where 2 ≤ i ≤ n-1. So, output is -1.

Wait, but n=2 is a special case. According to the operation definition, i must be between 2 and n-1, inclusive. For n=2, there are no such i's. So, no operations can be performed, meaning it's not beautiful.

So, for n ≤ 2, output is -1.

For n ≥ 3, I need to consider if the array can be made uniform by operations.

But the problem states that the given array is beautiful, so for n ≥ 3, the array is beautiful, and I need to find the minimal number of removals to make it not beautiful.

Wait, but in the first example, n=3 with all elements equal, it's beautiful, and output is -1, meaning it's impossible to make it not beautiful by removals.

In the second example, n=5 with [1,2,1,2,1], it's beautiful, and removing one element makes it not beautiful.

In the fourth example, n=7 with [3,3,3,5,3,3,3], removing three elements makes it not beautiful.

So, I need a general strategy.

Perhaps, the minimal number of removals is equal to the number of runs of the most frequent value minus one.

Wait, in the second example, the most frequent value is 1, with three runs: [1], [1], [1]. So, number of runs is 3, and 3-1=2, but the sample output is 1. So, that doesn't match.

Wait, maybe it's not exactly runs, but the number of times the value changes.

Wait, perhaps it's related to the number of times the most frequent value is separated by other values.

Wait, maybe it's the minimal number of elements to remove to break all possible paths of propagation.

This is getting too vague.

Let me look at the code provided and see if I can understand the logic.

The code is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().strip().split()))

tmp = a[0]

aa = set(a)

if len(aa) == 1:

print(-1)

cnt = 0

ans = n

for i in range(n):

if a[i] == tmp:

cnt += 1

else:

ans = min(ans, cnt)

cnt = 0

ans = min(ans, cnt)

print(ans)

So, the code checks if all elements are the same, in which case it prints -1.

Otherwise, it initializes tmp to a[0], and then iterates through the array, counting consecutive runs of tmp, and keeps track of the minimum count of such runs.

Wait, actually, it's keeping track of the minimum length of consecutive runs of tmp.

Wait, no. It's keeping track of the maximum run length of tmp, and then assigning ans as the minimum of ans and cnt whenever it encounters a different element.

Wait, let's see:

ans is initialized to n.

Then, for each i in 0 to n-1:

if a[i] == tmp:

cnt +=1

else:

ans = min(ans, cnt)

cnt = 0

After the loop, ans = min(ans, cnt)

So, it's finding the minimum run length of tmp.

Wait, no. It's finding the minimum run length of tmp in a way.

But actually, it's updating ans to be the minimum of ans and cnt each time it encounters a different element, and then resets cnt to 0.

Wait, let's take the second example: n=5, a=[1,2,1,2,1]

tmp = 1

aa = {1,2}, len(aa)=2 ≠1, so not -1

cnt = 0

ans = 5

i=0: a[0]=1 == tmp → cnt=1

i=1: a[1]=2 ≠ tmp → ans = min(5,1)=1, cnt=0

i=2: a[2]=1 == tmp → cnt=1

i=3: a[3]=2 ≠ tmp → ans = min(1,1)=1, cnt=0

i=4: a[4]=1 == tmp → cnt=1

After loop, ans = min(1,1)=1

So, output is 1, which matches the sample output.

Another example: n=7, a=[3,3,3,5,3,3,3]

tmp=3

aa={3,5}, len(aa)=2 ≠1, so not -1

cnt=0

ans=7

i=0: a[0]=3 == tmp → cnt=1

i=1: a[1]=3 == tmp → cnt=2

i=2: a[2]=3 == tmp → cnt=3

i=3: a[3]=5 ≠ tmp → ans=min(7,3)=3, cnt=0

i=4: a[4]=3 == tmp → cnt=1

i=5: a[5]=3 == tmp → cnt=2

i=6: a[6]=3 == tmp → cnt=3

After loop, ans=min(3,3)=3

So, output is 3, which matches the sample output.

Wait, but in the second example, it's outputting 1, which is the minimum run length of tmp.

But according to the explanation, removing one element can make it not beautiful.

Wait, but in this code, it's finding the minimum run length of tmp, and outputting that as the number of elements to remove.

Wait, but in the second example, tmp=1, and the minimum run length of 1 is 1, and removing one element is sufficient.

In the fourth example, tmp=3, minimum run length is 3, and removing three elements is sufficient.

So, perhaps the logic is that the minimal number of removals is equal to the minimum run length of the most frequent value.

But is this correct?

Wait, in the second example, tmp=1, and there are three runs of 1, each of length 1.

So, the minimum run length is 1, and removing one element can break the beauty.

In the fourth example, tmp=3, there are two runs of 3, one of length 3 and another of length 3.

The minimum run length is 3, and removing three elements can break the beauty.

So, perhaps the minimal number of removals is equal to the minimum run length of the most frequent value.

But is this always true?

Wait, in the first example, all elements are the same, so tmp=2, and the minimum run length is 3, but output is -1.

Wait, but according to the code, it would output 3, but actually, it should output -1 because it's impossible to make it not beautiful.

Wait, no, the code has a condition: if len(aa)==1, print -1.

So, in the first example, n=3, a=[2,2,2], aa={2}, len(aa)=1 → print -1.

In the second example, n=5, a=[1,2,1,2,1], aa={1,2}, len(aa)=2 ≠1 → proceed.

So, the code correctly handles the case when all elements are the same.

Now, in the third example, n=1, a=[1], aa={1}, len(aa)=1 → print -1, which is correct.

So, the code seems to be working correctly for the sample inputs.

But is this logic correct in general?

Let me think about another example.

Suppose n=4, a=[1,1,2,2]

tmp=1

aa={1,2}, len(aa)=2

cnt=0

ans=4

i=0: a[0]=1 == tmp → cnt=1

i=1: a[1]=1 == tmp → cnt=2

i=2: a[2]=2 ≠ tmp → ans=min(4,2)=2, cnt=0

i=3: a[3]=2 ≠ tmp → ans=min(2,0)=0, cnt=0

After loop, ans=min(0,0)=0

So, output is 0.

But according to the problem, the array is beautiful.

Wait, is [1,1,2,2] beautiful?

Let's see:

Can we make all elements the same by operations?

Suppose we choose i=2 (a[1]=1, a[3]=2), but a[1] ≠ a[3], so no operation can be performed.

So, it's not beautiful.

Wait, but according to the problem, the given array is beautiful, so this example might not be valid.

Wait, perhaps [1,1,2,2] is not beautiful, so in this case, the code outputs 0, meaning no removal is needed, which is correct because the array is already not beautiful.

But according to the problem, we need to output the minimal number of removals to make the array not beautiful, but in this case, the array is already not beautiful, so output should be 0.

Wait, but in the problem statement, if the array is already not beautiful, we should output the minimal number of removals needed to make it not beautiful, which in this case is 0.

But the problem says that the given array is beautiful, so in all test cases, the array is beautiful.

Wait, but in this example, [1,1,2,2], is it beautiful?

Let's check:

Can I make all elements the same?

Suppose I try to make all elements 1.

- Look for i where a[i-1] = a[i+1].

- i=2: a[1]=1, a[3]=2 ≠1, so no operation can be performed.

- i=3: a[2]=2, a[4]=out of bounds.

So, no operations can be performed, and the array is not uniform, so it's not beautiful.

Wait, but the problem states that the given array is beautiful, so this array shouldn't be considered in the test cases.

Wait, perhaps I need to assume that the given array is beautiful, as per the problem's assurance.

So, in this example, [1,1,2,2], it's not beautiful, so it shouldn't be in the test cases.

Therefore, the code would correctly handle it by outputting 0.

But in reality, since the problem guarantees that the array is beautiful, I don't need to consider arrays that are not beautiful.

Wait, but in the code, if the array is not beautiful, it would proceed and calculate the minimal run length, which might not make sense.

But since the problem guarantees that the array is beautiful, I don't need to worry about arrays that are not beautiful.

So, assuming the array is beautiful, and I need to find the minimal number of removals to make it not beautiful.

Now, in the code, it finds the minimum run length of the most frequent value.

Wait, actually, in the code, it uses tmp=a[0], and then counts runs of a[0].

But it's possible that a[0] is not the most frequent value.

Wait, in the second example, a=[1,2,1,2,1], a[0]=1, which is the most frequent value.

In the fourth example, a=[3,3,3,5,3,3,3], a[0]=3, which is the most frequent value.

So, in these cases, it works.

But what if a[0] is not the most frequent value?

For example, n=4, a=[2,1,1,1], tmp=2, aa={1,2}, len(aa)=2

cnt=0

ans=4

i=0: a[0]=2 == tmp → cnt=1

i=1: a[1]=1 ≠ tmp → ans=min(4,1)=1, cnt=0

i=2: a[2]=1 ≠ tmp → ans=min(1,0)=0, cnt=0

i=3: a[3]=1 ≠ tmp → ans=min(0,0)=0, cnt=0

After loop, ans=min(0,0)=0

But in this case, the array is beautiful, and the minimal number of removals should be something else.

Wait, is [2,1,1,1] beautiful?

Can I make all elements the same?

The most frequent value is 1.

Can I change a[0]=2 to 1?

Well, a[0] cannot be changed directly by the operation, since i must be between 2 and n-1.

So, in this array, I can't change a[0]=2 to 1, because there's no operation that allows me to do that.

So, it's not beautiful, because I can't make all elements 1.

But according to the problem, the given array is beautiful, so this array shouldn't be in the test cases.

Therefore, perhaps the code assumes that a[0] is the most frequent value.

Wait, but in the second example, a[0]=1 is the most frequent value.

In the fourth example, a[0]=3 is the most frequent value.

But in the third example, n=1, a=[1], which is not beautiful, but len(aa)=1, so it outputs -1 correctly.

So, perhaps the code is correct under the assumption that a[0] is the most frequent value.

But is this always the case?

Wait, the problem doesn't guarantee that a[0] is the most frequent value.

So, perhaps in some cases, a[0] is not the most frequent value.

Wait, in the second example, a[0]=1 is the most frequent value.

In the fourth example, a[0]=3 is the most frequent value.

In the first example, a[0]=2 is the only value.

In the third example, a[0]=1 is the only value.

So, in all sample inputs, a[0] is the most frequent value.

But in general, a[0] may not be the most frequent value.

So, perhaps the code is incorrect in using a[0] as the reference value.

Wait, but the problem says that the array is beautiful, which means it can be made uniform by operations.

So, in a beautiful array, all elements can be made equal to some value.

Therefore, the most frequent value in the array is the value that the array can be made uniform to.

Wait, no. The operation allows changing a[i] to a[i-1] if a[i-1] = a[i+1], and only for 2 ≤ i ≤ n-1.

So, it's possible that the array can be made uniform to a value that is not the most frequent value.

But in practice, it's likely that the array is made uniform to the most frequent value.

Wait, but in the second example, [1,2,1,2,1], it can be made uniform to 1 by changing the 2's to 1's.

Similarly, in the fourth example, [3,3,3,5,3,3,3], it can be made uniform to 3 by changing the 5 to 3.

So, in general, the array can be made uniform to the value that has the longest run or something like that.

Wait, perhaps to the value that has the maximum number of overlapping runs.

This is getting complicated.

Let me consider that in a beautiful array, there exists at least one value to which the entire array can be made uniform by operations.

My task is to remove the minimal number of elements so that no such value exists.

In other words, after removal, there is no value to which the entire array can be made uniform.

So, I need to ensure that for every value in the array, there is no way to make the entire array equal to that value using the operations.

To achieve this, I need to break the propagation for every possible value.

But this seems tricky.

An alternative approach is to note that if the array is already uniform, then it's impossible to make it not beautiful by removals, so output -1.

Otherwise, find the minimal number of removals to prevent the array from being made uniform to the most frequent value.

But in the second example, removing one element is sufficient.

In the fourth example, removing three elements is necessary.

So, perhaps the minimal number of removals is equal to the minimum run length of the most frequent value.

Wait, in the second example, the minimum run length is 1, and removing one element is sufficient.

In the fourth example, the minimum run length is 3, and removing three elements is sufficient.

But in another example, say n=6, a=[1,2,1,2,1,2], with tmp=1 and runs of 1 of length 1.

Then, according to the code, ans=1, meaning removing one element is sufficient.

Is that correct?

Let's see: [1,2,1,2,1,2]

Removing one element, say the second element, results in [1,1,2,1,2].

Now, can this be made uniform?

- Choose i=2: a[1]=1, a[3]=2 ≠1, so no operation.

- Choose i=3: a[2]=1, a[4]=1, so replace a[3]=2 with 1, resulting in [1,1,1,1,2].

- Then, choose i=4: a[3]=1, a[5]=2 ≠1, so no operation.

- Choose i=5: out of bounds.

So, the array becomes [1,1,1,1,2]. Now, can I change a[5]=2 to 1?

Yes, because a[4]=1 and a[6]=out of bounds.

Wait, no, i must be between 2 and n-1.

So, i=5 is n=5, which is n-1.

So, a[4]=1, a[6]=out of bounds, so no operation.

Wait, in this array, [1,1,1,1,2], I cannot change a[5]=2 to 1 because i=5, a[4]=1, a[6] doesn't exist, so operation cannot be applied.

Thus, the array cannot be made uniform to 1.

Therefore, [1,1,1,1,2] is not beautiful.

So, removing one element is sufficient, which matches the code's output.

Another example: n=6, a=[1,2,3,2,1,2]

tmp=1, runs of 1 at positions 0 and 3,4.

Minimum run length is 1.

So, ans=1.

Removing one element: say a[1]=2, resulting in [1,3,2,1,2]

Is this not beautiful?

Let's see:

Can I make all elements 1?

- Choose i=2: a[1]=3, a[3]=2 ≠, no operation.

- Choose i=3: a[2]=2, a[4]=1 ≠, no operation.

- Choose i=4: a[3]=1, a[5]=2 ≠, no operation.

So, cannot make all elements 1.

Can I make all elements 2?

- Choose i=2: a[1]=3, a[3]=2 ≠, no operation.

- Choose i=3: a[2]=2, a[4]=1 ≠, no operation.

- Choose i=4: a[3]=1, a[5]=2 ≠, no operation.

So, cannot make all elements 2.

Can I make all elements 3?

Only one 3, and cannot change others to 3.

So, the array is not beautiful.

Thus, removing one element is sufficient.

So, the code seems to be working correctly.

Another example: n=5, a=[1,1,2,2,2]

tmp=1

runs of 1: positions 0 and 1, run length=2

runs of 2: positions 2,3,4, run length=3

So, minimum run length of tmp=1 is 2.

According to the code, ans=2.

Is removing two elements sufficient to make it not beautiful?

Remove a[0] and a[1]: [2,2,2], which is beautiful.

Not sufficient.

Remove a[3] and a[4]: [1,1,2,2], which is not beautiful.

So, removing two elements is sufficient.

Thus, ans=2 is correct.

So, perhaps the code is correct.

But wait, in this case, tmp=1, and the minimum run length is 2, which matches the minimal number of removals.

But in the previous example, tmp=1, run length=1, and removing one element is sufficient.

So, it seems consistent.

But let's consider another example.

n=6, a=[1,1,2,1,2,2]

tmp=1

runs of 1: positions 0 and 1, positions 3, run lengths: 2 and 1

Minimum run length is 1

So, ans=1

Removing one element: say a[3]=1, resulting in [1,1,2,2,2]

Is this not beautiful?

Can I make all elements 1?

- Choose i=2: a[1]=1, a[3]=2 ≠, no operation.

- Choose i=3: a[2]=2, a[4]=2, so replace a[3]=2 with 2 (no change).

- Choose i=4: a[3]=2, a[5]=2, no change.

So, cannot make all elements 1.

Can I make all elements 2?

- Choose i=1: a[0]=1 ≠ a[2]=2, no operation.

- Choose i=2: a[1]=1 ≠ a[3]=2, no operation.

- Choose i=3: a[2]=2, a[4]=2, replace a[3]=2 with 2 (no change).

- Choose i=4: a[3]=2, a[5]=2, replace a[4]=2 with 2 (no change).

So, cannot make all elements 2.

Thus, the array is not beautiful.

Therefore, removing one element is sufficient.

Hence, the code seems correct.

Wait, but in the earlier example, n=5, a=[1,1,2,2,2], ans=2, which is correct.

So, perhaps the minimal number of removals is equal to the minimum run length of the most frequent value.

But why?

Let me think.

If I have runs of the most frequent value, to prevent the array from being made uniform to that value, I need to break all these runs by removing elements.

The minimal number of removals would be equal to the number of runs minus one, but in the code, it's taking the minimum run length.

Wait, no.

Wait, in the second example, runs of 1: three runs of length 1, so minimum run length is 1, and removing one element is sufficient.

In the fourth example, two runs of 3, each of length 3, so minimum run length is 3, and removing three elements is sufficient.

In the earlier example, n=5, a=[1,1,2,2,2], runs of 1: one run of length 2, runs of 2: one run of length 3.

tmp=1, minimum run length=2, and removing two elements is sufficient.

So, perhaps the minimal number of removals is equal to the minimum run length among all runs of the most frequent value.

But I need to confirm this.

Wait, in the second example, runs of 1 are all of length 1, so removing one element breaks one run, making it not beautiful.

In the fourth example, runs of 3 are of length 3, so removing three elements breaks one run completely.

So, perhaps the idea is to remove enough elements to break all runs of the most frequent value, making it impossible to propagate the value throughout the array.

But that doesn't make sense, because breaking one run might be sufficient.

Wait, perhaps the minimal number of removals is equal to the minimum run length of the most frequent value.

Because by removing that many elements from one run, I break that run, and if there are multiple runs, breaking one run might still allow other runs to propagate.

But in the second example, breaking one run is sufficient to make the array not beautiful.

In the fourth example, breaking one run by removing three elements is sufficient.

So, perhaps the minimal number of removals is indeed the minimum run length of the most frequent value.

But I need to confirm this with more examples.

Another example: n=7, a=[1,2,1,2,1,2,1]

tmp=1, runs of 1: positions 0,2,4,6, each of length 1

Minimum run length=1

So, ans=1

Removing one element: say a[0]=1, resulting in [2,1,2,1,2,1]

Is this not beautiful?

Can I make all elements 1?

- Choose i=2: a[1]=1, a[3]=2 ≠, no operation.

- Choose i=3: a[2]=2, a[4]=1 ≠, no operation.

- Choose i=4: a[3]=2, a[5]=1 ≠, no operation.

- Choose i=5: a[4]=1, a[6]=1, replace a[5]=1 with 1 (no change).

So, cannot make all elements 1.

Can I make all elements 2?

- Choose i=2: a[1]=1 ≠ a[3]=2, no operation.

- Choose i=3: a[2]=2, a[4]=1 ≠, no operation.

- Choose i=4: a[3]=2, a[5]=1 ≠, no operation.

- Choose i=5: a[4]=1, a[6]=1, no operation.

So, cannot make all elements 2.

Thus, the array is not beautiful.

Hence, removing one element is sufficient.

So, the code seems correct.

Another example: n=6, a=[3,3,3,4,4,3]

tmp=3, runs of 3: positions 0-2 and 5, run lengths: 3 and 1

Minimum run length=1

So, ans=1

Removing one element: say a[5]=3, resulting in [3,3,3,4,4]

Is this not beautiful?

Can I make all elements 3?

- Choose i=3: a[2]=3, a[4]=4 ≠, no operation.

- Choose i=4: a[3]=4, a[5]=4, replace a[4]=4 with 4 (no change).

So, cannot make all elements 3.

Can I make all elements 4?

- Choose i=2: a[1]=3 ≠ a[3]=3, no operation.

- Choose i=3: a[2]=3 ≠ a[4]=4, no operation.

- Choose i=4: a[3]=4, a[5]=4, replace a[4]=4 with 4 (no change).

So, cannot make all elements 4.

Thus, the array is not beautiful.

Hence, removing one element is sufficient.

Therefore, the code seems to be correct.

So, I conclude that the minimal number of removals is equal to the minimum run length of the most frequent value.

Hence, the code is correct.

**Final Solution**

To solve this problem, we need to determine the minimum number of elements to remove from a given beautiful array to make it no longer beautiful. If it is impossible to do so, we should output -1.

### Approach

1. **Understanding Beautiful Arrays**:
    - An array is beautiful if we can make all its elements the same by repeatedly replacing `a[i]` with `a[i-1]` (for `2 ≤ i ≤ n-1`) provided `a[i-1] = a[i+1]`.

2. **Key Insight**:
    - If the array consists of only one unique element, it remains beautiful no matter how many elements are removed, so we output -1.
    - For arrays with multiple unique elements, we focus on the most frequent element (let's call it `tmp`).
    - The minimal number of removals required to make the array not beautiful is equal to the length of the smallest run of `tmp`.

3. **Algorithm**:
    - Identify the most frequent element (`tmp`).
    - Count the lengths of consecutive runs of `tmp`.
    - Find the minimum run length of `tmp`.
    - If there is only one unique element, output -1; otherwise, output the minimum run length.

### Solution Code

```python
def func():
    import sys
    t = int(sys.stdin.readline())
    for _ in range(t):
        n = int(sys.stdin.readline())
        a = list(map(int, sys.stdin.readline().strip().split()))
        if len(set(a)) == 1:
            print(-1)
            continue
        tmp = a[0]
        ans = n
        cnt = 0
        for i in range(n):
            if a[i] == tmp:
                cnt += 1
            else:
                ans = min(ans, cnt)
                cnt = 0
        ans = min(ans, cnt)
        print(ans)

if __name__ == "__main__":
    func()
```

### Explanation

1. **Reading Input**:
    - Read the number of test cases `t`.
    - For each test case, read `n` (array size) and the array `a`.

2. **Handling Uniform Arrays**:
    - If all elements in `a` are the same, output -1 since it's impossible to make it not beautiful.

3. **Finding Minimum Runs**:
    - Initialize `tmp` to the first element of the array.
    - Traverse the array and count the lengths of consecutive runs of `tmp`.
    - Track the smallest run length in `ans`.

4. **Output the Result**:
    - Print the minimum run length `ans` for each test case.

This approach ensures that we efficiently determine the minimum removals needed to disrupt the beauty of the array, leveraging run-length counting for optimal performance.