Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if it's possible for Bob to set up the stalls and set the prices in such a way that Alice ends up buying exactly k jewels. If it is possible, I need to output "YES", followed by the number of stalls and their respective prices. If not, I should output "NO".

First, I need to understand the constraints and what exactly is being asked. Alice will always buy as many jewels as possible at each stall, given her current coins. So, for each stall, the number of jewels she buys is the floor division of her current coins by the price per jewel at that stall.

I need to ensure that the total number of jewels she buys from all stalls is exactly k.

Also, Bob can set up at most 60 stalls, which suggests that there might be a limit on the number of operations or the complexity of the solution.

Let me think about how to approach this.

One way is to consider that each stall can be used to buy a certain number of jewels, and the prices are set such that Alice buys the required number of jewels in total.

I need to find a sequence of stall prices such that when Alice buys jewels at each stall in sequence, the total jewels bought is exactly k.

Let me consider the simplest case: if k = 1, then no matter what n is (as long as n >= 1), Bob can set up a single stall with price n, so Alice buys one jewel and spends all her coins.

Another simple case: if k = n, and n >= 1, then Bob can set up a stall with price 1, so Alice buys n jewels.

But what if k > n? Well, since each jewel costs at least 1 coin, Alice can't buy more jewels than she has coins. So, if k > n, it's impossible. Wait, but in the problem statement, it says "1 <= n, k <= 10^18", so I need to make sure that k <= n, otherwise, it's impossible.

Wait, but in the sample input, there's a case where n = 7 and k = 3, which is possible, as shown in the sample output.

Another thing to note is that Alice doesn't have to spend all her coins, she just needs to buy exactly k jewels.

So, the condition k <= n must hold, because each jewel costs at least 1 coin.

Wait, but what if n < k? Can Alice still buy k jewels if each jewel costs less than or equal to n/k? Wait, no, because each jewel costs at least 1 coin, and if n < k, then Alice doesn't have enough coins to buy k jewels, since even if each jewel costs 1 coin, she needs k coins to buy k jewels. But if n < k, she has fewer coins than that.

Wait, but in the sample input, n = 7 and k = 3, which is fine because n >= k.

Wait, no, n = 7 and k = 3, which is n > k, but in the second sample input, n = 6 and k = 4, which is n < k, and the output is "NO", which makes sense because she can't buy more jewels than she has coins.

So, one condition is that n >= k.

But, is that the only condition? Wait, no, because even if n >= k, it might not be possible to set up the stalls in such a way that Alice buys exactly k jewels.

Wait, but in the first sample input, n = 7 and k = 3, and it's possible.

In the second sample input, n = 6 and k = 4, and it's impossible.

So, n >= k is necessary, but not sufficient.

I need to find a way to set up the stalls such that the total jewels bought is exactly k.

Let me think about how Alice buys the jewels.

She goes to each stall in order and buys as many jewels as possible with her current coins.

So, for stall 1, she buys floor(n / p1) jewels, where p1 is the price per jewel at stall 1.

Then, she has n - (floor(n / p1) * p1) coins left.

Then, she goes to stall 2 and buys floor(remaining coins / p2) jewels, and so on.

I need the sum of floor(n / pi) for each stall i to be exactly k.

Also, the number of stalls should be at most 60.

I need to find a sequence of at most 60 positive integers p1, p2, ..., ps, where s <= 60, such that the sum of floor(n / pi) over i from 1 to s is equal to k.

Moreover, the prices pi can be up to 10^18.

This seems tricky.

Let me think about it differently.

Suppose I set up s stalls with prices p1, p2, ..., ps.

I need to have sum(floor(n / pi)) = k.

I need to choose the pi's such that this sum is exactly k.

I need to find a way to decompose k into a sum of floor(n / pi) terms, with s <= 60.

This seems complicated.

Maybe there's a way to choose the pi's in a specific order, like decreasing or increasing.

Wait, in the sample input 1, n = 7 and k = 3, and the output is "YES" with 10 stalls, each with prices from 2 to 11.

But in that case, Alice buys 3 jewels from the first stall (7 / 2 = 3, with 1 coin left), and then she has less than 2 coins left, so she can't buy anything from the remaining stalls, so total jewels bought is 3, which is correct.

In the third sample input, n = 255 and k = 8, with 8 stalls priced 128, 64, 32, 16, 8, 4, 2, 1.

Alice buys:

- 1 jewel from the first stall (255 / 128 = 1, left with 127)

- 1 from the second (127 / 64 = 1, left with 63)

- 1 from the third (63 / 32 = 1, left with 31)

- 1 from the fourth (31 / 16 = 1, left with 15)

- 1 from the fifth (15 / 8 = 1, left with 7)

- 1 from the sixth (7 / 4 = 1, left with 3)

- 1 from the seventh (3 / 2 = 1, left with 1)

- 1 from the eighth (1 / 1 = 1, left with 0)

Total jewels bought: 8, which matches k.

So, in this case, it's possible.

But in the second sample input, n = 6 and k = 4.

Is it possible to set up stalls such that Alice buys exactly 4 jewels?

Let's try to see.

If I set up one stall with price 2, Alice buys 3 jewels (6 / 2 = 3), but that's more than k.

If I set up two stalls:

- First stall, price 3: Alice buys 2 jewels (6 / 3 = 2), left with 0 coins.

Total jewels: 2, which is less than k.

- First stall, price 2: Alice buys 3 jewels (6 / 2 = 3), left with 0 coins.

Total jewels: 3, which is still less than k.

- First stall, price 1: Alice buys 6 jewels (6 / 1 = 6), which is more than k.

So, with one stall, she buys either 6 jewels or less, but not exactly 4.

With two stalls:

- First stall, price 2: buys 3 jewels, left with 0.

Total: 3 < 4.

- First stall, price 3: buys 2 jewels, left with 0.

Total: 2 < 4.

- First stall, price 4: buys 1 jewel, left with 2.

Second stall, price 2: buys 1 jewel, left with 0.

Total: 2 < 4.

- First stall, price 5: buys 1 jewel, left with 1.

Second stall, price 1: buys 1 jewel, left with 0.

Total: 2 < 4.

- First stall, price 6: buys 1 jewel, left with 0.

Total: 1 < 4.

Seems like with two stalls, I can't reach exactly 4 jewels.

With three stalls:

- First stall, price 2: buys 3 jewels, left with 0.

Total: 3 < 4.

- First stall, price 3: buys 2 jewels, left with 0.

Second stall, price 1: buys 0 jewels (already 0 coins).

Total: 2 < 4.

- First stall, price 4: buys 1 jewel, left with 2.

Second stall, price 2: buys 1 jewel, left with 0.

Total: 2 < 4.

- First stall, price 5: buys 1 jewel, left with 1.

Second stall, price 1: buys 1 jewel, left with 0.

Total: 2 < 4.

- First stall, price 6: buys 1 jewel, left with 0.

Total: 1 < 4.

Still not enough.

It seems like no matter how I set up the stalls, I can't get Alice to buy exactly 4 jewels with 6 coins.

Hence, the answer is "NO", which matches the sample output.

So, now I need a general way to determine if it's possible to set up at most 60 stalls with prices such that Alice buys exactly k jewels.

I need to find a way to decompose k into a sum of floor(n / pi) for s <= 60.

This seems tricky.

Let me think about the minimal number of stalls required to make Alice buy exactly k jewels.

I need to maximize the number of jewels bought per stall to minimize the number of stalls.

Wait, but I need to make Alice buy exactly k jewels, so maybe I need to set up stalls in a way that she buys a certain number of jewels at each stall.

Let me consider that for each stall, the number of jewels bought is floor(n / pi).

I can think of this as dividing n into parts where each part is floor(n / pi), and the sum of these parts should be k.

This seems similar to partitioning n into k parts, but not exactly, because floor(n / pi) can be less than or equal to n, depending on pi.

Wait, maybe I need to find pi's such that sum(floor(n / pi)) = k.

This is not straightforward.

Let me consider the minimal possible pi, which is 1.

If I set all pi to 1, then sum(floor(n / 1)) = sum(n) over s stalls.

But s <= 60, and sum(n) would be s * n, which is way larger than k in most cases.

But in the third sample input, with n = 255 and k = 8, they set pi to be decreasing powers of 2, which allows Alice to buy one jewel at each stall.

This seems like a binary representation or something similar.

Wait, in the third sample input, the prices are 128, 64, 32, 16, 8, 4, 2, 1, which are powers of 2, starting from 128 down to 1.

Alice buys one jewel at each stall, totaling 8 jewels, which matches k.

This seems similar to binary representation, where each bit represents whether a particular power of 2 is included.

But in this case, since pi's are powers of 2, and Alice has 255 coins, which is 2^8 - 1, she can buy one jewel at each stall priced from 128 down to 1.

Similarly, if k is less than or equal to the number of bits in n, which is up to 60 bits for n up to 10^18, which is less than 2^60.

Wait, 10^18 is less than 2^60, since 2^60 is around 1.1529215e+18.

So, for n up to 10^18, k up to 10^18, but s is at most 60.

So, perhaps using powers of 2 for pi's is a way to make Alice buy exactly k jewels, by setting pi's accordingly.

But in the second sample input, n = 6 and k = 4, and using powers of 2, i.e., 4, 2, 1, would make Alice buy 1 + 1 + 1 = 3 jewels, which is less than k.

So, in that case, it's impossible.

Similarly, in the first sample input, n = 7 and k = 3, using prices from 2 to 11 makes Alice buy 3 jewels from the first stall and nothing from the rest, which sums to 3.

But in the third sample input, using prices as powers of 2 makes Alice buy one jewel from each stall, summing to 8.

So, perhaps a general approach is to use prices that are decreasing, starting from a price that allows Alice to buy as few jewels as possible from each stall.

Wait, in the first sample input, they used prices from 2 to 11, which are increasing, but in the third sample input, they used decreasing prices.

Wait, no, in the output, the prices are listed in order, but it's not specified whether the stalls are ordered in increasing or decreasing order.

Wait, in the problem statement, it says "Alice goes to stall 1, buys as many jewels as possible, then goes to stall 2, and so on."

So, the order of the stalls matters.

But in the sample inputs, the prices are listed in descending order, but it's not clear if that's necessary.

Wait, in the first sample input, prices are from 2 to 11, which is increasing, but Alice only buys from the first stall.

In the third sample input, prices are decreasing powers of 2.

So, perhaps the order doesn't matter, or maybe it does.

Wait, actually, the problem says "Alice goes to stall 1, buys as many jewels as possible, then goes to stall 2, and so on."

So, the order of the stalls matters.

But in the sample inputs, the prices are listed in a particular order, but it's not specified whether the order affects the buying process.

Wait, in the first sample input, with prices from 2 to 11, Alice buys 3 jewels from the first stall and is left with 1 coin, which is not enough to buy any jewels from the remaining stalls, so total jewels bought is 3.

In the third sample input, with prices 128 down to 1, Alice buys one jewel from each stall, totaling 8.

So, the order does matter.

If I reverse the order in the third sample input, i.e., prices from 1 to 128, Alice would buy 255 jewels from the first stall (n=255, p=1), and then stop, since she has no coins left.

So, in that case, total jewels bought would be 255, which is more than k=8.

Hence, the order of the stalls is important.

So, I need to set up the stalls in a specific order such that Alice buys a certain number of jewels at each stall, summing up to exactly k.

This seems tricky.

Let me think about it differently.

Suppose I set up s stalls with prices p1, p2, ..., ps.

I need to have sum(floor(n / pi)) = k.

I need to choose p1, p2, ..., ps such that this sum is exactly k.

I need a way to control how many jewels Alice buys at each stall.

One idea is to set the prices in such a way that at each stall, Alice buys a specific number of jewels, and then proceeds to the next stall with the remaining coins.

But, since floor(n / pi) is involved, it's not straightforward to set pi to get a specific number of jewels.

Wait, maybe I can set pi such that at each stall, Alice buys exactly one jewel, by setting pi to be just above half of the remaining n, or something like that.

Wait, that might not work.

Let me consider that at each stall, Alice buys floor(n / pi) jewels, and then proceeds with the remaining coins.

So, if I set pi to be just below n, she buys one jewel, and has n - pi coins left.

Then, at the next stall, I set p2 to be just below the remaining coins, so she buys one jewel again, and so on.

This way, I can make her buy one jewel at each stall, up to k stalls.

But, if k is large, say k=10^18, and s=60, it's impossible to make her buy one jewel at each of 60 stalls when k is that large.

Wait, but the constraint is s <= 60.

So, I need to make sure that the total number of stalls is at most 60.

In the third sample input, k=8, and they used s=8 stalls, each with prices being powers of 2, decreasing from 128 to 1.

Alice buys one jewel at each stall, totaling 8.

This works.

In the first sample input, k=3, and they used s=10 stalls with prices from 2 to 11.

Alice buys 3 jewels from the first stall and nothing from the rest.

Total: 3.

This also works.

In the second sample input, k=4, n=6, and it's impossible to set up stalls such that Alice buys exactly 4 jewels.

Hence, "NO".

So, I need a general approach to determine if it's possible to set up at most 60 stalls with prices such that Alice buys exactly k jewels.

One approach is to set up s stalls, where s is the minimum number of stalls needed to make Alice buy exactly k jewels.

I need to find a way to decompose k into a sum of floor(n / pi), with s <= 60.

This seems complicated.

Another way is to consider that at each stall, Alice buys a certain number of jewels, and I need to control the total number of jewels bought.

Perhaps I can set up stalls in such a way that Alice buys a specific number of jewels at each stall.

Wait, suppose I set up s stalls, and for each stall, I set pi such that floor(n / pi) is equal to a specific value.

But floor(n / pi) is not easily invertible to find pi.

Wait, for a given desired number of jewels m, I can set pi = ceil(n / m), because floor(n / pi) = m when pi is in a certain range.

Specifically, floor(n / pi) = m when ceil(n / (m + 1)) <= pi <= floor(n / m).

This is because:

- floor(n / pi) >= m requires pi <= floor(n / m)

- floor(n / pi) < m + 1 requires pi > ceil(n / (m + 1))

Hence, pi should be in the range ceil(n / (m + 1)) to floor(n / m).

So, for a desired m, I can choose pi in that range.

But in this problem, I need to decompose k into a sum of m_i's, where m_i = floor(n / pi), and s <= 60.

This seems too vague.

Let me think differently.

Suppose I set up s stalls with prices p1, p2, ..., ps.

I need sum(floor(n / pi)) = k.

I need to find a way to choose pi's such that this sum is exactly k.

One possible way is to set up stalls with decreasing pi's, starting from a high price.

For example, in the third sample input, they used decreasing powers of 2.

This allows Alice to buy one jewel at each stall, up to s = k, as long as n is at least the sum of the pi's.

Wait, in that case, n needs to be at least sum(pi's), but in the third sample input, n=255 and sum of pi's is 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255.

So, n is exactly equal to the sum of pi's.

In that case, Alice buys one jewel at each stall, spending exactly pi coins at each stall, and totaling k jewels.

So, in this specific case, sum(pi's) = n and sum(floor(n / pi)) = k.

This works.

Similarly, in the first sample input, n=7 and k=3.

They set up 10 stalls with prices from 2 to 11.

At the first stall, price 2, Alice buys floor(7 / 2) = 3 jewels, spending 6 coins, left with 1 coin.

At the remaining stalls, prices are higher than 1, so she can't buy anything.

Total jewels: 3.

Hence, it's possible.

So, in this case, sum(pi's) is much larger than n, but Alice only buys from the first stall.

So, in general, if I set up stalls with prices such that at the first stall, pi is set such that floor(n / pi) = m, where m is the number of jewels to buy at that stall, and then proceed with the remaining coins and k - m jewels for the remaining stalls.

This seems like a recursive approach.

I can set up stalls one by one, choosing pi such that floor(n / pi) = m, where m is the number of jewels to buy at that stall.

I need to choose m such that m <= k and m <= floor(n / pi).

But I need to ensure that the sum of m's over all stalls is exactly k.

This seems feasible.

So, the algorithm can be:

- While k > 0 and n > 0:

- Choose m, the number of jewels to buy at this stall, where 1 <= m <= k and m <= floor(n / pi)

- Choose pi such that floor(n / pi) >= m

- Set pi = floor(n / m)

- Buy m jewels, spending m * pi coins

- Update n = n - m * pi

- Update k = k - m

- Output the list of pi's used

But wait, floor(n / pi) >= m implies pi <= floor(n / m)

So, I can set pi = floor(n / m)

Then, floor(n / pi) >= m

But I need to ensure that floor(n / pi) = m

Wait, no, floor(n / pi) could be greater than m.

I need to make sure that floor(n / pi) = m

To achieve that, I need to set pi such that floor(n / pi) = m

Which requires that ceil(n / (m + 1)) <= pi <= floor(n / m)

So, I can choose pi = floor(n / m)

Then, floor(n / pi) = m, as required.

Hence, at each step, I can choose m, then set pi = floor(n / m), and buy m jewels.

Then, update n = n - m * pi

And k = k - m

This way, I can decompose k into a sum of m's, each corresponding to a stall.

I need to choose m at each step such that m <= k and m <= floor(n / pi), where pi = floor(n / m)

Wait, but m <= floor(n / pi), and pi = floor(n / m)

So, m <= floor(n / floor(n / m))

Now, floor(n / floor(n / m)) is at least m, so this inequality holds.

Hence, this approach should work.

Now, I need to decide how to choose m at each step.

I need to minimize the number of stalls, but the problem allows up to 60 stalls.

So, to minimize the number of stalls, I should maximize m at each step, i.e., choose the largest possible m that is <= k and <= floor(n / m)

Wait, but m <= floor(n / m)

This implies m^2 <= n

But m can be up to floor(sqrt(n)), but this seems too restrictive.

Wait, m <= floor(n / m) implies m^2 <= n

So, m <= sqrt(n)

But k could be larger than sqrt(n), so this might not work.

Wait, perhaps I need to choose m differently.

Let me consider choosing m as large as possible at each step, but ensuring that m <= k and m <= floor(n / m)

Wait, but m <= floor(n / m) implies m^2 <= n

So, m <= sqrt(n)

But if k > sqrt(n), I might need more than sqrt(n) stalls, but s is limited to 60.

Wait, but in the problem, s <= 60, so perhaps choosing m=1 each time is acceptable, but it might require up to k stalls, which could be up to 10^18, which is way more than 60.

Hence, I need a better way to choose m.

Wait, perhaps I can choose m to be as large as possible at each step, up to k, but ensuring that m <= floor(n / m)

So, find the maximum m such that m <= k and m <= floor(n / m)

This would allow me to maximize m at each step, thereby minimizing the number of stalls.

To find the maximum m such that m <= k and m <= floor(n / m), I can perform a binary search on m.

Set low = 1, high = min(k, floor(sqrt(n)))

Then, binary search to find the largest m such that m <= k and m <= floor(n / m)

Once I find such an m, set pi = floor(n / m)

Then, update n = n - m * pi

k = k - m

Repeat until k == 0 or n == 0 or some other stopping condition.

I need to ensure that the number of stalls doesn't exceed 60.

Hence, I can set a counter for the number of stalls, and stop if it reaches 60.

If after 60 stalls, k > 0, then it's impossible.

Otherwise, it's possible.

This seems like a viable approach.

Let me try to implement this logic.

First, read t, the number of test cases.

For each test case:

- Read n and k

- Initialize an empty list for pi's

- Initialize a stall counter, s = 0

- While k > 0 and n > 0 and s < 60:

- Find the maximum m such that m <= k and m <= floor(n / m)

- Perform a binary search for m in [1, min(k, floor(sqrt(n)))]

- Set pi = floor(n / m)

- Append pi to the list

- Update n = n - m * pi

- Update k = k - m

- Increment s

- If k == 0:

- Output "YES"

- Output the number of stalls s

- Output the list of pi's

- Else:

- Output "NO"

I need to implement the binary search for m.

Define a function to find the maximum m such that m <= k and m <= floor(n / m)

Initialize low = 1, high = min(k, floor(sqrt(n)))

While low < high:

mid = (low + high + 1) // 2

if mid <= floor(n / mid):

low = mid

else:

high = mid - 1

Then, m = low

Set pi = floor(n / m)

Then, update n = n - m * pi

k = k - m

s += 1

Continue until k == 0 or other conditions.

Wait, but floor(n / m) is pi, and m <= pi, which is always true since pi = floor(n / m).

Hence, m <= floor(n / m) is satisfied.

So, this should work.

I need to implement this logic.

Let me consider the first sample input:

n = 7, k = 3

First iteration:

Find m in [1, min(3, floor(sqrt(7))=2)]

Binary search for m in [1,2]

Check m=2:

2 <= floor(7 / 2) = 3, which is true.

Check m=3:

3 <= floor(7 / 3) = 2, which is false.

Hence, m=2 is the maximum m.

Set pi = floor(7 / 2) = 3

Buy m=2 jewels, spending 2*3=6 coins.

Update n = 7 - 6 = 1

k = 3 - 2 = 1

s = 1

Second iteration:

Find m in [1, min(1, floor(sqrt(1))=1)]

m=1

Set pi = floor(1 / 1) = 1

Buy m=1 jewel, spending 1*1=1 coins.

Update n = 1 - 1 = 0

k = 1 - 1 = 0

s = 2

Hence, total stalls: 2, with prices 3 and 1.

But in the sample input, they used 10 stalls with prices from 2 to 11, which also works.

So, multiple solutions are possible.

Hence, my approach seems valid.

Another test case: n=255, k=8

First iteration:

m in [1, min(8, floor(sqrt(255))=15)]

Binary search for m in [1,15]

Find the largest m such that m <= floor(255 / m)

Try m=15:

15 <= floor(255 / 15)=17, true.

m=16:

16 <= floor(255 / 16)=15, false.

Hence, m=15

Set pi=floor(255 / 15)=17

Buy 15 jewels, spending 15*17=255 coins.

Update n=255-255=0

k=8-15=-7, which is invalid.

Wait, k cannot become negative.

Hence, I need to ensure that m <= k.

In this case, m=15, but k=8, so m should be at most 8.

Hence, m should be min(15,8)=8

Set m=8

Set pi=floor(255 / 8)=31

Buy 8 jewels, spending 8*31=248 coins.

Update n=255-248=7

k=8-8=0

Hence, only one stall with price 31 would suffice.

But in the sample input, they used 8 stalls with prices as powers of 2, totaling 8 jewels.

So, my approach would use only one stall in this case, which is also correct.

But the sample input used 8 stalls, which is also correct.

Hence, multiple solutions are possible.

So, my approach seems valid.

Now, let's consider the second sample input: n=6, k=4

First iteration:

m in [1, min(4, floor(sqrt(6))=2)]

Binary search for m in [1,2]

Check m=2:

2 <= floor(6 / 2)=3, true.

Check m=3:

3 <= floor(6 / 3)=2, false.

Hence, m=2

Set pi=floor(6 / 2)=3

Buy 2 jewels, spending 2*3=6 coins.

Update n=6-6=0

k=4-2=2

s=1

Second iteration:

k=2, n=0

Cannot proceed further, since n=0

Hence, total jewels bought: 2 < 4

Hence, "NO"

Which matches the sample input.

Good.

Hence, this approach seems correct.

I need to implement this logic in code.

I need to handle multiple test cases, read t, then for each test case, read n and k, then perform the above procedure.

Also, ensure that the number of stalls s <= 60.

In the above examples, s was much less than 60, but in some cases, s could be up to 60.

Hence, set a counter for s, and stop when s reaches 60.

If k == 0, output "YES", else "NO"

Also, in the output, if "YES", output s and then the list of pi's.

Now, implement the binary search for m.

Define a function to find the maximum m such that m <= k and m <= floor(n / m)

def find_m(n, k):

low = 1

high = min(k, int(sqrt(n)))

while low < high:

mid = (low + high + 1) // 2

if mid <= n // mid:

low = mid

else:

high = mid - 1

return low

Then, set pi = n // m

Then, update n = n - m * pi

k = k - m

s += 1

Repeat until k == 0 or n == 0 or s >= 60

Finally, if k == 0, output "YES", else "NO"

Also, handle the case when k == 0 initially.

If k == 0, output "YES" and 0 stalls.

Similarly, if n < k, output "NO"

Wait, no, if n < k, it's impossible, since each jewel costs at least 1 coin.

Hence, add a condition at the beginning: if n < k, output "NO"

Else, proceed with the algorithm.

Wait, but in the sample input, n=7 and k=3, which is n >= k.

Hence, n >= k is a necessary condition.

Hence, add that condition.

Also, if k == 0, it's already handled by the algorithm, but to make it clearer, handle it separately.

Hence, in code:

for each test case:

read n, k

if n < k:

print("NO")

else:

proceed with the algorithm

Implement the algorithm as described.

Also, need to handle large n and k, up to 10^18, hence use integer division and handle large numbers properly.

Also, import math for sqrt function.

Now, proceed to write the code accordingly.

## Final Solution
To solve this problem, we need to determine if Bob can set up at most 60 stalls with integer prices per jewel such that Alice buys exactly \( k \) jewels using her \( n \) coins. Alice buys jewels greedily from each stall, purchasing as many jewels as possible with her remaining coins.

### Approach

1. **Initial Check**: If the number of jewels \( k \) exceeds the number of coins \( n \), it's impossible for Alice to buy more jewels than she has coins. Hence, output "NO".
2. **Binary Search for Maximum Jewels per Stall**: For each stall, determine the maximum number of jewels \( m \) Alice can buy such that:
   - \( m \leq k \)
   - \( m \leq \left\lfloor \frac{n}{m} \right\rfloor \)
   
   This is achieved using a binary search to find the optimal \( m \).
3. **Update Remaining Coins and Jewels**: After determining \( m \), calculate the price per jewel \( p \) as \( \left\lfloor \frac{n}{m} \right\rfloor \). Update the remaining coins \( n \) and the remaining jewels \( k \) accordingly.
4. **Repeat for Up to 60 Stalls**: Continue this process for up to 60 stalls. If \( k \) becomes zero, output "YES" along with the stall setup details; otherwise, output "NO".

### Solution Code

```python
import math
import sys

def find_m(n, k):
    low = 1
    high = min(k, int(math.isqrt(n)))
    while low < high:
        mid = (low + high + 1) // 2
        if mid <= n // mid:
            low = mid
        else:
            high = mid - 1
    return low

def main():
    t = int(sys.stdin.readline())
    for _ in range(t):
        n, k = map(int, sys.stdin.readline().split())
        if n < k:
            print("NO")
            continue
        stalls = []
        s = 0
        while k > 0 and n > 0 and s < 60:
            m = find_m(n, k)
            p = n // m
            stalls.append(p)
            n -= m * p
            k -= m
            s += 1
        if k == 0:
            print("YES")
            print(len(stalls))
            print(' '.join(map(str, stalls)))
        else:
            print("NO")

if __name__ == "__main__":
    main()
```

### Explanation

1. **Initial Check**: If \( k > n \), output "NO" immediately since it's impossible.
2. **Binary Search**: The function `find_m(n, k)` uses binary search to find the maximum \( m \) such that \( m \leq k \) and \( m \leq \left\lfloor \frac{n}{m} \right\rfloor \).
3. **Stall Setup**:
   - Calculate the price per jewel \( p \) as \( \left\lfloor \frac{n}{m} \right\rfloor \).
   - Update \( n \) to \( n - m \times p \).
   - Update \( k \) to \( k - m \).
4. **Loop Termination**: The loop runs for up to 60 iterations (stalls). If \( k \) is exhausted, output "YES" along with the stall details; otherwise, output "NO".

This approach ensures that Alice buys exactly \( k \) jewels using her \( n \) coins by optimally setting up the stalls and their prices.