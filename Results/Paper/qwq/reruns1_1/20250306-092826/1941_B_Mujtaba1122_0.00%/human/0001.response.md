Alright, I've got this problem to solve. Let's see what it's asking for. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (between 2 and n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to make all elements of the array zero using these operations.

First, I need to understand what this operation does. It seems like it's a way to reduce the values in the array, particularly targeting the center element among three consecutive elements. By subtracting 2 from the center and 1 from its neighbors, it's like spreading out some negative effect or adjusting values in a specific pattern.

I need to figure out if, by applying this operation multiple times (possibly on different indices each time), I can zero out the entire array.

Let me think about the constraints. The array has at least 3 elements, and the operations can only be performed on indices from 2 to n-1. Also, the values in the array are non-negative integers, ranging from 0 to 10^9, and there can be up to 10^4 test cases with a total of 2*10^5 elements across all test cases.

Given the large input sizes, I need an efficient solution, probably linear time per test case.

Now, let's consider small examples to build some intuition.

Take the first example from the problem:

n = 5

a = [1, 3, 5, 5, 2]

The solution shows a sequence of operations that lead to all zeros. So, it's possible in this case.

Another no-case:

n = 5

a = [2, 4, 4, 5, 1]

The output is "NO", meaning it's not possible to zero out the array with the given operations.

I need to find a general way to determine whether it's possible for any given array.

Let me think about the operation again. Each operation reduces the center element by 2 and its neighbors by 1. It's similar to subtracting a specific pattern from the array: [-1, -2, -1] at positions i-1, i, i+1.

So, if I can view this as subtracting a combination of these patterns across the array, I might be able to find a way to zero out the array.

This seems related to solving a system of equations where each operation corresponds to subtracting a specific vector from the array.

But with large n and a_i up to 10^9, I need a smarter approach.

Let me consider the differences between consecutive elements.

Define b_i = a_i - a_{i-1} for i from 1 to n, assuming a_0 = 0.

Wait, but a_0 is not defined. Maybe I should set a_0 = 0.

Wait, no, a_0 is not part of the array. Maybe differences between consecutive elements can give some insight.

Alternatively, maybe I can model this as a system where each operation affects specific elements, and find if the target (all zeros) is achievable.

But that might be too slow for the given constraints.

Let me look for an invariant, some property that remains unchanged no matter how many operations I perform.

An invariant could help me determine if reaching all zeros is possible.

Considering that each operation subtracts a total of 4 from the array (1 + 2 + 1), but that's not very helpful because the sum decreases by 4 each time, but that doesn't directly help me decide if I can reach zero.

Wait, but the sum doesn't have to be divisible by 4, because I can perform operations multiple times, and the initial sum doesn't necessarily need to be divisible by 4 to reach zero.

Looking back at the examples, in the first one, sum is 1+3+5+5+2=16, which is divisible by 4, and it's possible. In the second one, 2+4+4+5+1=16, also divisible by 4, but it's "NO". So, sum being divisible by 4 isn't sufficient.

Hmm.

Maybe I need to look at the array in a different way.

Let me consider that each operation reduces a_i-1, a_i, and a_i+1 by 1,1,1 respectively, but a_i is reduced by an extra 1.

Wait, no, it's -1, -2, -1.

Wait, perhaps I can think of this as a kind of smoothing operation, where I'm trying to even out the values.

Alternatively, maybe I can model this as assigning certain values to the elements and seeing if it balances out.

Wait, perhaps I can think of the operations as building up certain values and then seeing if I can counteract them.

Alternatively, maybe I can consider the second differences of the array.

In discrete mathematics, second differences can indicate the effect of certain operations.

Wait, let's try to think recursively.

Suppose I have the array [a1, a2, a3, ..., an].

If I perform an operation on i, it affects a_{i-1}, a_i, a_{i+1}.

I need to see if I can make all a_i = 0.

Perhaps I can start from one end and work my way to the other, adjusting as I go.

Let me try starting from the left.

Set a1 to 0 by some operations. Then move to a2, and so on.

Wait, but operations only affect from i-1 to i+1 for i from 2 to n-1.

So, I can't directly set a1 or an with these operations.

Wait, a1 can only be affected by operations on i=2, which would subtract 1 from a1.

Similarly, an can only be affected by operations on i=n-1, which would subtract 1 from an.

So, to make a1=0, if a1 > 0, I need to perform operations on i=2 as many times as a1.

Similarly, to make an=0, I need to perform operations on i=n-1 as many times as an.

But, each such operation also affects a_{n-1} and a_{n-2}, and so on.

This seems complicated.

Maybe I need to find a way to express the operations in terms of linear algebra or find a pattern in how the operations affect the array.

Alternatively, perhaps there's a way to accumulate the operations needed for each position.

Wait, maybe I can think of the operations as waves propagating through the array, where each operation creates a specific pattern of reductions.

This is getting too vague.

Let me look at the reference solution provided.

The reference solution defines two functions: func_1 and func_2.

func_1 checks if all elements in the list are zero.

func_2 seems to be the main function that tries to make the array zero by repeatedly applying the operation on indices from 1 to n-1 (Python indices, so 0 to n-2? Wait, in Python, indices start from 0, but in the problem, indices start from 1 to n.

Wait, in the code, n is the number of elements, and l is the input string of elements, which is then split into lst.

Then, func_2 is called with lst and n.

Inside func_2, there's a loop from 1 to n-1 (Python indices, so elements from index 1 to n-2).

Within this loop, there's a while loop that continues as long as list[i] > 1 and list[i-1] > 0 and list[i+1] > 0.

In each iteration of the while loop, it subtracts list[i-1] from list[i-1], 2*list[i-1] from list[i], and list[i-1] from list[i+1].

Wait, that seems odd.

Wait, list[i - 1] -= 1 * list[i - 1]

list[i] -= 2 * list[i - 1]

list[i + 1] -= 1 * list[i - 1]

This seems like it's trying to subtract multiples of list[i-1] from the neighboring elements.

But list[i-1] is being decremented by itself, which would set it to zero in one step.

Wait, list[i - 1] -= 1 * list[i - 1] is equivalent to list[i - 1] = 0

Similarly, list[i] -= 2 * list[i - 1]

list[i + 1] -= 1 * list[i - 1]

So, it's setting list[i-1] to zero and subtracting twice the original list[i-1] from list[i] and once the original list[i-1] from list[i+1].

This seems like an attempt to zero out list[i-1] while adjusting list[i] and list[i+1] accordingly.

But I'm not sure if this is the right approach.

Let me see what happens with the first example.

Initial array: [1, 3, 5, 5, 2]

First iteration, i=1 (Python index 1, which is second element, a2=3)

list[0] = 1, list[1]=3, list[2]=5

Since list[1]>1 and list[0]>0 and list[2]>0:

Set list[0] = 0

list[1] -= 2*list[0] = 3 - 0 = 3

list[2] -= 1*list[0] = 5 - 0 = 5

So, after this operation, the array becomes [0,3,5,5,2]

Next iteration, i=2 (a3=5)

list[1]=3, list[2]=5, list[3]=5

list[1]>1 and list[2]>1 and list[3]>0:

Set list[1] = 0

list[2] -= 2*list[1] = 5 - 0 = 5

list[3] -= 1*list[1] = 5 - 0 = 5

Array now: [0,0,5,5,2]

Next iteration, i=3 (a4=5)

list[2]=5, list[3]=5, list[4]=2

list[2]>1 and list[3]>1 and list[4]>0:

Set list[2] = 0

list[3] -= 2*list[2] = 5 - 0 = 5

list[4] -= 1*list[2] = 2 - 0 = 2

Array now: [0,0,0,5,2]

Next iteration, i=4 (a5=2)

list[3]=5, list[4]=2, list[5] doesn't exist.

Wait, in Python, list indices go from 0 to n-1.

In the loop, i ranges from 1 to n-1, which for n=5, i=1 to 3 (Python indices 1 to 3, corresponding to a2 to a4).

So, after the above steps, the array is [0,0,0,5,2]

Now, func_1 is called to check if all elements are zero. Clearly, not all are zero, so it prints "NO", but according to the first example, it should be "YES".

Wait, perhaps there's more to it.

Maybe after this initial pass, I need to repeat the process until no more operations can be performed.

But in the code, it only does one pass over the array.

That might not be sufficient.

In the example provided in the problem, multiple operations are performed in a specific sequence to reach all zeros.

In the code, it seems to do only one pass, which might not be enough.

Perhaps I need to repeat the operations until no more changes can be made.

Let me try to modify the code to iterate until no changes can be made.

But efficiency is a concern, as n can be up to 2e5.

I need a more efficient way.

Maybe I need to find a different approach.

Let me consider the problem differently.

Suppose I want to make all a_i = 0.

Each operation reduces a_{i-1}, a_i, a_{i+1} by 1,1,1 respectively, but a_i is reduced by an extra 1.

Wait, no, it's a_{i-1} -=1, a_i -=2, a_{i+1} -=1.

So, each operation reduces the sum of the array by 4.

But as I thought earlier, sum being divisible by 4 isn't sufficient, as per the second example.

Maybe I need to look at the differences between consecutive elements.

Let me define b_i = a_i - a_{i+1} for i from 1 to n-1.

But not sure.

Alternatively, perhaps I can model this as a system of equations.

Let me denote the number of times operation is applied at position i as x_i.

Then, for each position j from 1 to n:

- If j=1: a_j - x_2 = 0

- If j=2: a_j - 2*x_2 - x_3 = 0

- If j=3: a_j - x_2 - 2*x_3 - x_4 = 0

- ...

- If j=n-1: a_j - x_{n-2} - 2*x_{n-1} - x_n = 0

- If j=n: a_j - x_{n-1} = 0

Wait, no, operations are only on i from 2 to n-1, affecting i-1, i, i+1.

So, for each operation at position i, the changes are:

a_{i-1} -=1

a_i -=2

a_{i+1} -=1

So, in terms of equations:

For each j from 1 to n:

a_j - (number of operations at positions affecting j) = 0

Specifically:

- a1 - x2 = 0

- a2 - 2*x2 - x3 = 0

- a3 - x2 - 2*x3 - x4 = 0

- ...

- a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

- a_n - x_{n-1} = 0

Wait, but in the problem, operations can only be applied for i from 2 to n-1, so x_i for i from 2 to n-1.

Wait, x_i is the number of times operation is applied at position i (2 <= i <= n-1).

So, for each a_j:

- j=1: a1 - x2 = 0

- j=2: a2 - 2*x2 - x3 = 0

- j=3: a3 - x2 - 2*x3 - x4 = 0

- ...

- j=k: a_k - x_{k-1} - 2*x_k - x_{k+1} = 0

- ...

- j=n-1: a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

- j=n: a_n - x_{n-1} = 0

Wait, but x_n is not defined, since operations are only for i from 2 to n-1.

Wait, perhaps I need to adjust the equations.

Let me redefine:

Let x_i be the number of times operation is applied at position i (2 <= i <= n-1).

Then, for each position j from 1 to n:

- If j=1: a_j - x_2 = 0

- If j=2: a_j - 2*x_2 - x_3 = 0

- If j=3: a_j - x_2 - 2*x_3 - x_4 = 0

- ...

- If j=k (2 < k < n): a_k - x_{k-1} - 2*x_k - x_{k+1} = 0

- ...

- If j=n-1: a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

- If j=n: a_n - x_{n-1} = 0

Wait, but x_n is not defined, since operations are only for i from 2 to n-1.

Wait, perhaps I made a mistake in defining x_i.

Wait, operations are performed on i from 2 to n-1, affecting a_{i-1}, a_i, a_{i+1}.

So, x_i (for i from 2 to n-1) is the number of times operation is applied at position i.

Then, for each a_j:

- j=1: a1 - x_2 = 0

- j=2: a2 - 2*x_2 - x_3 = 0

- j=3: a3 - x_2 - 2*x_3 - x_4 = 0

- ...

- j=k: a_k - x_{k-1} - 2*x_k - x_{k+1} = 0

- ...

- j=n-1: a_{n-1} - x_{n-2} - 2*x_{n-1} - x_n = 0

- j=n: a_n - x_{n-1} = 0

Wait, but x_n is not defined, since operations are only for i from 2 to n-1.

Wait, perhaps I need to consider x_n as zero, or not use it.

Wait, no, in the equation for a_{n-1}, it should be a_{n-1} - x_{n-2} - 2*x_{n-1} = 0, since there is no x_n.

Wait, perhaps I miswrote it.

Let me try to write the equations again.

For j from 1 to n:

- j=1: a1 - x2 = 0

- j=2: a2 - 2*x2 - x3 = 0

- j=3: a3 - x2 - 2*x3 - x4 = 0

- ...

- j=k: a_k - x_{k-1} - 2*x_k - x_{k+1} = 0

- ...

- j=n-2: a_{n-2} - x_{n-3} - 2*x_{n-2} - x_{n-1} = 0

- j=n-1: a_{n-1} - x_{n-2} - 2*x_{n-1} = 0

- j=n: a_n - x_{n-1} = 0

So, for j from 1 to n:

- If j=1: a1 - x2 = 0

- If j=2: a2 - 2*x2 - x3 = 0

- If j=3 to n-2: a_j - x_{j-1} - 2*x_j - x_{j+1} = 0

- If j=n-1: a_{n-1} - x_{n-2} - 2*x_{n-1} = 0

- If j=n: a_n - x_{n-1} = 0

This gives us a system of n equations with n-2 variables (x2 to x_{n-1}).

Wait, n equations and n-2 variables.

This seems overconstrained, meaning there might be no solution unless certain conditions are met.

To solve this system, I need to see if there exists non-negative integers x2 to x_{n-1} satisfying all equations.

Given that, perhaps I can solve the system step by step.

Starting from j=1:

a1 - x2 = 0 => x2 = a1

Then, j=2:

a2 - 2*x2 - x3 = 0 => x3 = a2 - 2*x2 = a2 - 2*a1

Then, j=3:

a3 - x2 - 2*x3 - x4 = 0 => x4 = a3 - x2 - 2*x3 = a3 - a1 - 2*(a2 - 2*a1) = a3 - a1 - 2*a2 + 4*a1 = a3 + 3*a1 - 2*a2

And so on.

This seems tedious, but perhaps there's a pattern.

Alternatively, perhaps I can express x_i in terms of a_i and a_{i-1}.

Wait, maybe I can consider the differences between a_i.

Let me consider defining b_i = a_i - a_{i-1} for i from 2 to n.

But I'm not sure.

Alternatively, perhaps I can think of the operations as building up certain values and then see if I can balance them out.

This is getting too complicated.

Let me look for a different approach.

I recall that in some problems involving operations that affect multiple elements, it's possible to use a kind of "difference array" to efficiently compute the required operations.

In this case, perhaps I can model the operations in terms of differences.

Let me define a difference array d, where d[i] represents the number of operations performed at position i.

Then, the effect of d[i] operations at position i is:

- a[i-1] -= d[i]

- a[i] -= 2*d[i]

- a[i+1] -= d[i]

Our goal is to find d[i] for i from 2 to n-1 such that after applying these operations, all a[j] become zero.

So, for each a[j], the equation is:

- a[j] - d[j+1] - 2*d[j] - d[j-1] = 0

Wait, I need to be careful with the indices.

Wait, perhaps it's better to iterate through the array and greedily apply operations where needed.

Start from the left end, set d[2] to a[1], then update a[2] and a[3] accordingly, and proceed.

Let me try this with the first example.

Initial array: [1,3,5,5,2]

Set d[2] = a[1] = 1

Then, a[1] -= d[2] = 1 - 1 = 0

a[2] -= 2*d[2] = 3 - 2 = 1

a[3] -= d[2] = 5 - 1 = 4

Now, array is [0,1,4,5,2]

Next, set d[3] = a[2] = 1

a[2] -= d[3] = 1 - 1 = 0

a[3] -= 2*d[3] = 4 - 2 = 2

a[4] -= d[3] = 5 - 1 = 4

Array now: [0,0,2,4,2]

Next, set d[4] = a[3] = 2

a[3] -= d[4] = 2 - 2 = 0

a[4] -= 2*d[4] = 4 - 4 = 0

a[5] -= d[4] = 2 - 2 = 0

Array now: [0,0,0,0,0]

Success.

This seems to work for this example.

Let me try with the second example where the answer is "NO".

n=5, a=[2,4,4,5,1]

Set d[2]=a[1]=2

a[1]-=2 => 2-2=0

a[2]-=4 => 4-4=0

a[3]-=2 => 4-2=2

Array: [0,0,2,5,1]

Set d[3]=a[2]=0

a[2]-=0 => 0-0=0

a[3]-=0 => 2-0=2

a[4]-=0 => 5-0=5

Array: [0,0,2,5,1]

Set d[4]=a[3]=2

a[3]-=2 => 2-2=0

a[4]-=4 => 5-4=1

a[5]-=2 => 1-2=-1

Array: [0,0,0,1,-1]

We have negative values, which are invalid.

Hence, "NO"

This seems consistent with the expected output.

So, perhaps this greedy approach works: iterate from left to right, at each step set d[i] = a[i-1], then update a[i-1], a[i], and a[i+1] accordingly.

If at any