Alright, I've got this problem to solve. Let me read it carefully.

We are given two positive integers, n and m, and we need to find the number of ordered pairs (a, b) such that:

1. 1 ≤ a ≤ n and 1 ≤ b ≤ m

2. a + b is a multiple of b * gcd(a, b)

First, I need to understand what this condition means: a + b is a multiple of b * gcd(a, b). Let's denote gcd(a, b) as g. So, the condition becomes a + b is a multiple of b * g.

I know that gcd(a, b) divides both a and b, so g divides a and g divides b. That means a = g * a' and b = g * b', where a' and b' are coprime integers (gcd(a', b') = 1).

Substituting these into the condition:

a + b = g * a' + g * b' = g(a' + b')

And b * g = g * b'

So, the condition is that g(a' + b') is a multiple of g * b'. Simplifying, this means a' + b' is a multiple of b'.

So, a' + b' ≡ 0 mod b'

Which implies a' ≡ -b' mod b'

But since a' and b' are coprime, and b' divides a' + b', this seems like a specific condition that needs to be met.

Wait, a' and b' are coprime, and b' divides a' + b'. Since b' divides a' + b' and b' divides b', then b' divides a'. But a' and b' are coprime, so b' can only be 1.

Therefore, b' = 1.

So, b = g * b' = g * 1 = g.

And a = g * a', where a' is coprime with b' = 1, so a' can be any positive integer.

Wait, but b' = 1, so b = g.

And a = g * a', where a' is any positive integer such that a = g * a' ≤ n.

Also, b = g ≤ m.

So, for each g from 1 to m, since b = g, and g divides a, and a ≤ n.

So, for each g from 1 to m, number of a's such that a is a multiple of g and 1 ≤ a ≤ n.

Wait, a is a multiple of g, since a = g * a', where a' is integer ≥1.

So, for each g from 1 to m, number of multiples of g that are ≤ n.

Which is floor(n / g).

So, total number of pairs is sum over g from 1 to m of floor(n / g), where g divides b, but b = g.

Wait, but in the earlier analysis, b = g.

Wait, is that correct?

Let me double-check.

Given that b = g * b' and b' = 1, then b = g.

And a = g * a', where a' is any integer such that a ≤ n.

So, for each g from 1 to m, number of a's that are multiples of g and ≤ n is floor(n / g).

Therefore, the total number of pairs is sum over g from 1 to m of floor(n / g).

But wait, is this condition fully satisfied?

Let me verify with the first test case.

Test case 1: n=1, m=1.

So, sum over g=1 to 1 of floor(1 / 1) = 1.

Which matches the sample output of 1.

Test case 4: n=10, m=8.

Sum over g=1 to 8 of floor(10 / g).

Let's compute:

g=1: 10/1 = 10

g=2: 10/2 = 5

g=3: 10/3 = 3

g=4: 10/4 = 2

g=5: 10/5 = 2

g=6: 10/6 = 1

g=7: 10/7 = 1

g=8: 10/8 = 1

Total: 10 + 5 + 3 + 2 + 2 + 1 + 1 + 1 = 25

But the sample output for n=10, m=8 is 14, not 25.

Hmm, that doesn't match.

So, my earlier reasoning must be flawed.

Let me see where I went wrong.

I assumed that for each g from 1 to m, the number of a's that are multiples of g and ≤ n is floor(n / g).

But according to the sample, for n=10, m=8, the correct answer is 14, not 25.

So, I must have overcounted.

Let me look back at the condition: a + b is a multiple of b * gcd(a, b).

Let's denote gcd(a, b) as g.

Then, a = g * a', b = g * b', where a' and b' are coprime.

Then, a + b = g(a' + b').

And b * g = g * b'.

So, the condition is that g(a' + b') is a multiple of g * b', which simplifies to a' + b' being a multiple of b'.

Since a' and b' are coprime, and b' divides a' + b', then b' divides a'.

But a' and b' are coprime, so b' can only be 1.

Therefore, b' = 1, which implies b = g.

And a = g * a', where a' is any positive integer such that a ≤ n.

So, for each g from 1 to m, number of a's that are multiples of g and ≤ n is floor(n / g).

But in the sample, this gives 25, whereas the correct answer is 14.

Wait, perhaps not all g from 1 to m are valid.

Wait, in the sample explanation, it lists specific pairs:

(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)

That's 14 pairs.

But according to my earlier calculation, sum from g=1 to 8 of floor(10/g) is 25.

So, where is the discrepancy?

Looking at the pairs listed in the sample, for g=1, we have a=1,2,3,4,5,6,7,8,9,10 (all multiples of 1 up to 10), that's 10 pairs.

But in the sample, only (1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1) are listed, but actually, for g=1, b=1, and a can be from 1 to 10, so that's 10 pairs.

But in the sample, they have only (1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2), which is 14 pairs in total.

Wait, but for g=1, there are 10 pairs, but in the sample, there are only 10 pairs for g=1, but they have additional pairs for higher g.

Wait, no, wait:

Wait, in the sample, for g=1, b=1, a can be from 1 to 10, that's 10 pairs.

For g=2, b=2, a can be 2,4,6,8,10, that's 5 pairs.

But in the sample, they have only (2,1),(2,2),(6,1),(6,2),(6,3),(10,1),(10,2), which seems inconsistent with my earlier sum.

Wait, perhaps I miscounted.

Wait, no, I think I need a better approach.

Let me try to understand the condition again.

Given a and b, with gcd(a, b) = g.

Then, b * g = b * g.

And a + b should be a multiple of b * g.

Given that a = k * g for some integer k, since g is the gcd.

So, a + b = k * g + b.

We need k * g + b ≡ 0 mod (b * g)

Which means k * g + b is divisible by b * g.

Which implies that b * g divides k * g + b.

Let me see if I can write this as:

k * g + b ≡ 0 mod (b * g)

Which means k * g + b is divisible by b * g.

So, k * g + b = m * b * g for some integer m.

Divide both sides by g:

k + b / g = m * b

But g = gcd(a, b), so b / g is integer.

Let me set b' = b / g.

So, b' is integer, and gcd(k, b') = 1, since a' = k and b' are coprime.

So, the equation becomes:

k + b' = m * b' * g

Wait, no, wait:

Wait, b = b' * g, and a = k * g, with gcd(k, b') = 1.

So, a + b = k * g + b' * g = g(k + b')

And b * g = b' * g * g = b' * g^2.

So, the condition is that g(k + b') is a multiple of b' * g^2.

Simplify: k + b' is a multiple of b' * g.

So, k + b' ≡ 0 mod (b' * g)

Which means k ≡ -b' mod (b' * g)

Since k and b' are coprime, and k ≡ -b' mod (b' * g), I'm not sure how to proceed from here.

Maybe I need to think differently.

Let me consider fixing b and then finding a such that the condition holds.

Let's fix b, and find a such that a + b is a multiple of b * gcd(a, b).

Let’s denote d = gcd(a, b).

Then, d divides a and d divides b.

So, a = d * a', b = d * b', where gcd(a', b') = 1.

Then, a + b = d(a' + b').

And b * d = d * b'.

Wait, no, b = d * b', so b * d = d * (d * b'') if b is expressed in terms of d.

Wait, perhaps I need to express everything in terms of d.

Given a = d * a', b = d * b', with gcd(a', b') = 1.

Then, a + b = d(a' + b').

And b * d = d * b'.

So, the condition is that d(a' + b') is a multiple of d * b'.

Simplify by dividing both sides by d (since d >=1):

a' + b' is a multiple of b'.

But a' and b' are coprime.

So, a' + b' ≡ 0 mod b'.

Which implies a' ≡ -b' mod b'.

But since a' and b' are coprime, and b' divides a' + b', then b' divides a'.

But a' and b' are coprime, so b' must be 1.

Therefore, b' = 1.

So, b = d * 1 = d.

Therefore, for each b from 1 to m, set d = b, and a must be a multiple of d.

Wait, but d = b, and a must be a multiple of d.

So, a must be a multiple of b.

Wait, but in the sample, for n=10, m=8, the pairs are:

(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)

Looking at these pairs, for each b, a is a multiple of b.

For b=1: a can be any from 1 to 10, since all are multiples of 1.

For b=2: a can be 2,4,6,8,10.

For b=3: a can be 3,6,9.

For b=4: a can be 4,8.

For b=5: a can be 5,10.

For b=6: a can be 6.

For b=7: a can be 7.

For b=8: a can be 8.

But in the sample, for b=1: a=1,2,3,4,5,6,7,8,9,10 (10 pairs)

For b=2: a=2,6,10 (3 pairs)

Total: 10 + 3 = 13, but sample says 14. Wait, perhaps I miscounted.

Wait, in the sample explanation for n=10, m=8, it lists 14 pairs, but according to this, it should be 10 for b=1 and 3 for b=2, totaling 13, unless I'm missing something.

Wait, perhaps I need to consider that for b=2, a can be 2,4,6,8,10, but in the sample, only a=2,6,10 are considered. Why is that?

Wait, maybe my earlier conclusion is incorrect.

Wait, perhaps I need to revisit the condition.

Given that b = d, and a must be a multiple of d, which is b.

So, a must be a multiple of b.

But in the sample, for b=2, a can be 2,4,6,8,10, which are all multiples of 2.

But in the sample explanation, for b=2, only a=2,6,10 are considered, not a=4,8.

Wait, maybe there's an additional condition I'm missing.

Wait, perhaps because for b=2, a=4 and a=8 also satisfy the original condition.

Let me check for a=4, b=2:

a + b = 4 + 2 = 6

b * gcd(a,b) = 2 * 2 = 4

Is 6 a multiple of 4? 6 / 4 = 1.5, which is not an integer. So, no.

Wait, so a=4, b=2 does not satisfy the condition, because 6 is not a multiple of 4.

But according to my earlier reasoning, a must be a multiple of b and satisfy the condition.

So, perhaps my earlier conclusion is incomplete.

So, a must be a multiple of b, but also satisfy that a + b is a multiple of b * gcd(a,b).

Wait, but gcd(a,b) = gcd(k*b, b) = b, since a = k*b.

So, a + b = k*b + b = (k+1)*b

And b * gcd(a,b) = b * b = b^2

So, (k+1)*b must be a multiple of b^2, which implies that k+1 must be a multiple of b.

So, k >=1, and k+1 is a multiple of b.

So, for a = k*b, where k >=1 and k+1 is a multiple of b.

So, k ≡ -1 mod b.

Therefore, for each b, a must be of the form a = (m*b -1)*b for integer m.

Wait, let's see.

Given k ≡ -1 mod b, then k = m*b -1 for some integer m >=1.

Therefore, a = k*b = (m*b -1)*b = m*b^2 - b.

But a must be <= n.

So, m*b^2 - b <= n.

Solve for m: m <= (n + b)/ (b^2)

So, m_max = floor( (n + b) / (b^2) )

Therefore, for each b from 1 to m, number of a's is floor( (n + b) / (b^2) )

So, the total number of pairs is sum over b from 1 to m of floor( (n + b) / (b^2) )

Let me verify this with the sample input.

Sample input 4: n=10, m=8

Sum over b=1 to 8 of floor( (10 + b)/ (b^2) )

b=1: (10 +1)/1 = 11/1 = 11

b=2: (10 +2)/4 = 12/4 = 3

b=3: (10 +3)/9 = 13/9 = 1

b=4: (10 +4)/16 = 14/16 = 0

b=5: (10 +5)/25 = 15/25 = 0

b=6: (10 +6)/36 = 16/36 = 0

b=7: (10 +7)/49 = 17/49 = 0

b=8: (10 +8)/64 = 18/64 = 0

Total: 11 + 3 + 1 = 15, but the sample output is 14.

Wait, discrepancy again.

Looking back at the sample explanation for n=10, m=8, it lists 14 pairs.

But according to this formula, it should be 11 + 3 + 1 = 15.

So, perhaps there's an off-by-one error here.

Wait, perhaps b cannot exceed m, and for b=1, a can be up to floor( (10 +1)/1 ) = 11, but n is only 10, so a can be up to 10.

Wait, perhaps need to take min(floor( (n + b)/ (b^2) ), floor(n / b))

Wait, but in the earlier analysis, a must be <= n.

So, perhaps the formula should be min(floor( (n + b)/ (b^2) ), floor(n / b))

Let me check for n=10, m=8:

b=1: min(11,10)=10

b=2: min(3,5)=3

b=3: min(1,3)=1

b=4: min(0,2)=0

b=5: min(0,2)=0

b=6: min(0,1)=0

b=7: min(0,1)=0

b=8: min(0,1)=0

Total: 10 + 3 + 1 = 14, which matches the sample.

So, the correct formula is sum over b=1 to m of min(floor( (n + b)/ (b^2) ), floor(n / b))

But in the earlier analysis, I thought it was just floor( (n + b)/ (b^2) ), but that was incorrect.

There must be an additional constraint that a <=n, hence the min with floor(n / b)

Wait, but in the earlier step, a = m*b^2 - b <=n, solving for m <= (n + b)/b^2

So, m_max = floor( (n + b)/ (b^2) )

And a = m*b^2 - b

But a also must be <=n.

Wait, but with m <= floor( (n + b)/ (b^2) ), a = m*b^2 - b <= n

So, perhaps it's correct as is, but in the sample, it's 11 for b=1, but n=10, so a=11*1^2 -1 =10, which is <=10.

Wait, no, a = m*b^2 - b

For b=1, m<= (10 +1)/1 =11, so m=1 to 11, a=1*1 -1=0, which is <1, invalid.

Wait, a= m*b^2 - b

For b=1, a= m*1 -1 = m -1

So, m=1: a=0 (invalid)

m=2: a=1

m=3: a=2

...

m=11: a=10

So, a=1 to 10, which matches.

For b=2, m<= (10 +2)/4=12/4=3, so m=1 to 3

a=4*m -2

m=1: a=2

m=2: a=6

m=3: a=10

So, a=2,6,10 for b=2

Which matches the sample.

For b=3, m<= (10 +3)/9=13/9=1, so m=1

a=9*1 -3=6, which is <=10, valid.

For b=4, m<= (10 +4)/16=14/16=0, so no a's

Similarly for higher b's.

Total: 10 (b=1) + 3 (b=2) +1 (b=3) =14, matches the sample.

So, the formula is sum over b=1 to m of floor( (n + b)/ (b^2) )

But with the understanding that a = m*b^2 - b <=n

Wait, but in the earlier step, a = m*b^2 - b <=n

So, m <= (n + b)/b^2

Hence, m_max = floor( (n + b)/ (b^2) )

Therefore, for each b from 1 to m, number of a's is floor( (n + b)/ (b^2) )

But in practice, a must also be >=1, which requires m*b^2 - b >=1, i.e., m >= ceil( (b+1)/b^2 )

But since m is integer, and floor( (n + b)/ (b^2) ) gives the upper limit, and m starts from 1, we can just take floor( (n + b)/ (b^2) ), and ensure that a = m*b^2 - b >=1.

But in the sample, for b=1, m=1 gives a=0, which is invalid, so we need to adjust m_start.

Wait, this is getting complicated.

Perhaps a better way is to iterate over b from 1 to m, and for each b, iterate m from 1 to floor( (n + b)/ (b^2) ), and compute a = m*b^2 - b, and count only those a's that are >=1 and <=n.

But this would be too slow for the constraints, as t can be up to 10^4, and n and m up to 2*10^6, and sum of n and m over all test cases up to 2*10^6.

So, we need an optimized solution.

Let me see if we can optimize the sum.

We have sum over b=1 to m of floor( (n + b)/ (b^2) )

This can be rewritten as sum over b=1 to m of floor( n/b^2 + 1/b )

But 1/b is less than or equal to 1, so floor(n/b^2 + 1/b) = floor(n/b^2) + floor(1/b)

For b>=1, floor(1/b)=1 only for b=1, else 0.

So, for b>=2, floor( (n + b)/b^2 ) = floor(n/b^2 + 1/b) = floor(n/b^2) + 0 = floor(n/b^2)

For b=1, floor(n +1)/1 = n +1, but a= m*1 -1 = m -1, and m <= n +1, but a <=n, so m -1 <=n, m <=n +1

But for b=1, a= m -1, starting from m=1 (a=0, invalid), m=2 (a=1), ..., m=n+1 (a=n)

So, number of valid a's for b=1 is n.

Wait, but earlier I had 10 pairs for b=1 when n=10, which matches.

So, perhaps for b=1, the number of a's is n.

For b>=2, the number of a's is floor(n / b^2)

Wait, but in the sample, for b=1, a=1 to 10 (10 pairs)

For b=2, a=2,6,10 (3 pairs)

For b=3, a=6 (1 pair)

Total:10 +3 +1=14

Which matches sum over b=1 to m of floor( (n + b)/b^2 )

For b=1: floor(11/1)=11, but a=0 is invalid, so 10 pairs

For b=2: floor(12/4)=3, a=2,6,10

For b=3: floor(13/9)=1, a=6

For b>=4: floor(14/16)=0

So, total is 10 +3 +1=14

Hence, the formula is sum over b=1 to m of floor( (n + b)/b^2 ), but for b=1, subtract 1 because a=0 is invalid.

So, general formula is:

sum over b=1 to m of floor( (n + b)/b^2 ) - [b ==1]

Where [b ==1] is 1 if b=1, else 0.

Hence, for b=1: floor( (n +1)/1 ) -1 = n +1 -1 =n

For b>=2: floor( (n + b)/b^2 )

So, total is n + sum over b=2 to m of floor( (n + b)/b^2 )

This seems consistent with the sample.

Therefore, the correct approach is:

- For b=1, number of a's is n

- For b from 2 to m, number of a's is floor( (n + b)/b^2 )

- Sum them up to get the total number of pairs.

Now, considering the constraints, t can be up to 10^4, and sum of n and m over all test cases up to 2*10^6.

So, per test case, n and m are up to 2*10^6, but since t is up to 10^4, and sum of n and m over all test cases is up to 2*10^6, per test case, n and m can be up to 2*10^6, but across all test cases, the total n and m don't exceed 2*10^6.

Wait, no, it says "It is guaranteed that neither the sum of n nor the sum of m over all test cases exceeds 2*10^6."

So, sum of all n across test cases <=2*10^6, and sum of all m across test cases <=2*10^6.

Therefore, per test case, n and m can be up to 2*10^6, but across all test cases, the total n and total m are bounded by 2*10^6.

Hence, we need an efficient way to compute sum over b=1 to m of floor( (n + b)/b^2 )

For b=1: floor( (n +1)/1 ) -1 = n

For b>=2: floor( (n + b)/b^2 )

So, total is n + sum over b=2 to m of floor( (n + b)/b^2 )

We need to compute this efficiently.

Let me see.

For b from 2 to m, floor( (n + b)/b^2 )

Let me denote k = b^2

Then, floor( (n + b)/k ) = floor( (n + b)/b^2 )

But I'm not sure if that helps.

Alternatively, note that for b >=2, b^2 >=4, and floor( (n + b)/b^2 ) can be computed directly.

Given that m can be up to 2*10^6 per test case, and t up to 10^4, but sum of m over all test cases <=2*10^6, we can iterate over b for each test case efficiently.

But to make it faster, perhaps we can find a way to compute the sum over b=2 to m of floor( (n + b)/b^2 ) efficiently.

Let me see.

Let me consider that for b >=2, b^2 >=4, and b^2 increases as b increases.

So, for large b, floor( (n + b)/b^2 ) decreases.

Perhaps I can group terms where floor( (n + b)/b^2 ) is constant.

Similar to divisor summation techniques.

Let me think about it.

I can consider that for a fixed value of floor( (n + b)/b^2 ) = c, I can find the range of b where this c is constant.

Then, sum over c for the respective ranges.

This is similar to the method used in calculating sum of floor(n / k) over k.

But in this case, it's floor( (n + b)/b^2 )

Let me denote c = floor( (n + b)/b^2 )

I need to find the ranges of b where c is constant.

So, for each c, find the minimal and maximal b such that floor( (n + b)/b^2 ) = c.

Then, sum c * (number of b's where floor( (n + b)/b^2 ) = c)

This can be optimized similarly to how we optimize divisor sums.

Let me try to find, for a fixed c, the range of b where floor( (n + b)/b^2 ) = c.

So, c <= (n + b)/b^2 < c +1

Multiply both sides by b^2 (assuming b >=2, b positive):

c * b^2 <= n + b < (c +1) * b^2

So, c * b^2 - b <= n < (c +1) * b^2 - b

Wait, no:

From c <= (n + b)/b^2 < c +1

Multiply by b^2:

c * b^2 <= n + b < (c +1) * b^2

Subtract b:

c * b^2 - b <= n < (c +1) * b^2 - b

So, for each c, find b such that c * b^2 - b <= n < (c +1) * b^2 - b

This seems a bit messy.

Maybe there's a better way.

Alternatively, note that floor( (n + b)/b^2 ) = floor( n/b^2 + 1/b )

For b >=2, 1/b <1, so floor( n/b^2 + 1/b ) = floor(n/b^2) + floor(1/b) = floor(n/b^2) +0 = floor(n/b^2)

Hence, for b >=2, floor( (n + b)/b^2 ) = floor(n/b^2)

Therefore, the sum simplifies to:

n + sum over b=2 to m of floor(n / b^2 )

So, total pairs = n + sum over b=2 to m of floor(n / b^2 )

This seems simpler.

Let me verify with the sample input.

Sample input 4: n=10, m=8

sum = 10 + floor(10/4) + floor(10/9) + floor(10/16) + ... up to b=8

Which is 10 + 2 +1 +0 +0 +0 +0 +0 =13, but the sample output is 14.

Wait, discrepancy again.

Wait, according to earlier analysis, sum over b=2 to m of floor( (n + b)/b^2 )

For b=2: floor(12/4)=3

For b=3: floor(13/9)=1

For b=4: floor(14/16)=0

Total for b>=2: 3 +1 +0 +... =4

Plus n=10, total=14, which matches the sample.

So, earlier simplification was incorrect.

So, floor( (n + b)/b^2 ) is not equal to floor(n / b^2 ) for b >=2.

Hence, I cannot simplify it to floor(n / b^2 )

I need to stick with floor( (n + b)/b^2 )

So, total pairs = sum over b=1 to m of floor( (n + b)/b^2 ) - [b==1]

Where [b==1] is 1 if b=1 else 0.

Hence, for b=1: floor(n +1)/1 -1 =n

For b>=2: floor( (n + b)/b^2 )

So, total pairs = n + sum over b=2 to m of floor( (n + b)/b^2 )

Now, to compute this efficiently, I can precompute the sum over b=2 to m of floor( (n + b)/b^2 )

Given that m can be up to 2*10^6 per test case, and t up to 10^4, but sum of m over all test cases is up to 2*10^6, I can iterate over b from 2 to m for each test case individually.

But to optimize further, perhaps I can find a way to compute floor( (n + b)/b^2 ) efficiently in batches.

Alternatively, note that for large b, floor( (n + b)/b^2 ) decreases slowly.

So, I can group b's where floor( (n + b)/b^2 ) is constant.

This is similar to the method of hyperbola method or divisor summation optimization.

Let me attempt to implement this optimization.

First, for b=1, add n to the total.

Then, for b from 2 to m, add floor( (n + b)/b^2 )

Let me denote k = floor( (n + b)/b^2 )

I need to find the range of b where k is constant.

So, for each possible k, find the minimal and maximal b such that floor( (n + b)/b^2 ) =k

Then, add k * (number of b's where floor( (n + b)/b^2 ) =k)

This way, I can reduce the number of operations.

Let me try to find, for a given k, the range of b where floor( (n + b)/b^2 ) =k

So, k <= (n + b)/b^2 <k +1

Multiply all sides by b^2 (assuming b >=2):

k * b^2 <= n + b < (k +1) * b^2

Subtract b:

k * b^2 - b <= n < (k +1) * b^2 - b

This seems complicated.

Alternatively, solve for b in terms of k.

From k <= (n + b)/b^2, and (n + b)/b^2 <k +1

First inequality: k <= (n + b)/b^2 => k * b^2 <= n + b => k * b^2 - b <=n

Second inequality: (n + b)/b^2 <k +1 => n + b < (k +1) * b^2

So, n + b < (k +1) * b^2

Rearrange: (k +1) * b^2 - b >n

This is a quadratic inequality in terms of b.

Similarly, k * b^2 - b <=n

So, we have k * b^2 - b <=n < (k +1) * b^2 - b

This seems tricky to solve directly.

Maybe I need to consider a different approach.

Alternatively, since b^2 grows quadratically, perhaps I can iterate over possible b in groups where floor( (n + b)/b^2 ) remains constant.

In practice, for implementation, I can iterate b from 2 to m, compute floor( (n + b)/b^2 ), and sum them up.

Given that sum of m over all test cases is up to 2*10^6, this should be efficient enough.

Let me try to implement this in code.

But first, let's think about edge cases.

Edge case 1: n=1, m=1

According to sample, output is 1.

According to formula: n=1 + sum over b=2 to1 of floor( (1 + b)/b^2 ) =0

So, total=1, matches.

Edge case 2: n=2, m=3

Sample output:3

Compute: n=2 + sum over b=2 to3 of floor( (2 + b)/b^2 )

b=2: floor(4/4)=1

b=3: floor(5/9)=0

Total:2 +1 +0=3, matches.

Another test: n=3, m=5

Sum:3 + floor(5/4)=1 + floor(6/9)=0 + floor(7/16)=0 + floor(8/25)=0 + floor(9/36)=0

Total:3 +1=4, matches sample.

So, the formula seems correct.

Hence, proceed with implementing this approach.

Now, considering time constraints, since sum of m over all test cases is up to 2*10^6, and t up to 10^4, but individual m and n up to 2*10^6, iterating from b=2 to m for each test case is acceptable.

But to optimize further, perhaps I can find a way to compute the sum over b=2 to m of floor( (n + b)/b^2 ) more efficiently.

Let me see.

Let me consider that for large b, floor( (n + b)/b^2 ) decreases slowly.

So, I can group b's where floor( (n + b)/b^2 ) is constant.

This way, I can compute the sum in O(sqrt(n)) time per test case.

Let me attempt to implement this optimization.

Initialize b=2, and while b <=m:

Find the maximum b such that floor( (n + b)/b^2 ) = floor( (n + b)/b^2 )

Then, add k * (b_max - b +1)

Set b = b_max +1

Repeat until b >m

To find b_max, solve floor( (n + b)/b^2 ) =k

Which implies k <= (n + b)/b^2 <k +1

From k <= (n + b)/b^2, we have k * b^2 <=n +b

And from (n + b)/b^2 <k +1, we have n +b < (k +1) * b^2

So, n +b < (k +1) * b^2

Rearrange: (k +1) * b^2 -b >n

This is a quadratic inequality.

Similarly, k * b^2 -b <=n

So, for a given k, find b such that k * b^2 -b <=n < (k +1) * b^2 -b

To find b_max for a given k and b_min, solve (k +1) * b^2 -b >n

For b > (1 + sqrt(1 +4*(k +1)*(n +1)))/(2*(k +1))

And k * b^2 -b <=n => b^2 <= (n +b)/k

This seems complicated.

Perhaps it's easier to iterate b from 2 to m, compute floor( (n + b)/b^2 ), and sum them up directly.

Given the constraints, with sum of m over all test cases <=2*10^6, this should be efficient enough.

Now, proceed to implement this approach.

## Final Solution
To solve this problem, we need to count the number of ordered pairs \((a, b)\) that satisfy the given conditions. We need to ensure that \(1 \leq a \leq n\) and \(1 \leq b \leq m\), and that \(a + b\) is a multiple of \(b \cdot \gcd(a, b)\).

### Approach

1. **Insight into the Condition**:
   - By expressing \(a\) and \(b\) in terms of their greatest common divisor \(g = \gcd(a, b)\), we set \(a = g \cdot a'\) and \(b = g \cdot b'\), where \(a'\) and \(b'\) are coprime.
   - The condition \(a + b\) being a multiple of \(b \cdot \gcd(a, b)\) simplifies to \(a' + b' \equiv 0 \pmod{b'}\), which implies \(b' = 1\). Hence, \(b = g\), and \(a\) must be a multiple of \(g\).

2. **Counting Valid Pairs**:
   - For \(b = 1\), \(a\) can be any integer from 1 to \(n\), giving \(n\) valid pairs.
   - For \(b \geq 2\), the number of valid \(a\) is given by \(\left\lfloor \frac{n + b}{b^2} \right\rfloor\).

3. **Efficient Calculation**:
   - Sum the contributions for each \(b\) from 1 to \(m\):
     - For \(b = 1\): \(n\)
     - For \(b \geq 2\): \(\sum_{b=2}^{m} \left\lfloor \frac{n + b}{b^2} \right\rfloor\)

Given the constraints, this approach ensures efficiency as it avoids unnecessary computations and leverages mathematical insights to reduce complexity.

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        m = int(data[idx + 1])
        idx += 2
        total = n  # For b=1
        for b in range(2, m + 1):
            if b * b > n + b:
                break  # No more terms to add
            total += (n + b) // (b * b)
        results.append(str(total))
    sys.stdout.write('\n'.join(results))

if __name__ == '__main__':
    main()
```

### Explanation

1. **Reading Input**:
   - Read all input data at once for efficiency.
   - Parse the number of test cases \( t \).

2. **Processing Each Test Case**:
   - For each test case, read \( n \) and \( m \).
   - Initialize the total count with \( n \) (for \( b = 1 \)).
   - For \( b \) from 2 to \( m \), add \(\left\lfloor \frac{n + b}{b^2} \right\rfloor\) to the total.

3. **Output the Results**:
   - Collect results for all test cases and print them at once for efficiency.

This approach ensures that the solution is both correct and efficient, adhering to the problem constraints and handling large inputs effectively.