Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water lined up, each containing a certain amount of water. The goal is to make sure that all containers have the same amount of water, and I can only pour water from a container with a lower index to one with a higher index. Also, it's given that the total sum of water is divisible by n, so it's possible in theory to have equal amounts in each container.

First, I need to understand the operation allowed: pouring water from container i to j, where i < j. This means I can only move water forward in the line of containers, not backward. That seems like an important constraint.

Given that, I need to figure out if it's possible to make all containers have the same amount of water by only moving water forward.

Let me think about what the target amount of water should be in each container. Since the total sum is divisible by n, the target amount is sum(a)/n. Let's call this target.

So, for each container, I need to adjust its water amount to target by either adding or removing water. But, since I can only pour water forward, I can only add water to a container from the ones before it.

Wait, no. Actually, reading the problem again, it says: pour any amount of water from the i-th container to the j-th container, where i < j. So, I can only pour from earlier containers to later ones, not the other way around.

So, for a container at position i, I can only receive water from containers with indices less than i, not from those with higher indices.

Wait, no. Let's read carefully: "pour any amount of water from the i-th container to the j-th container, where i must be less than j (i.e., i < j)."

This means that water can only be moved from a container to a container that is further to the right in the line. So, water can only move from left to right, not from right to left.

Given that, for a container at position i, it can only receive water from containers to its left (lower indices), and it can give water to containers to its right (higher indices).

So, to make all containers have the target amount, I need to ensure that for each container, after all operations, its water amount equals target.

But since water can only flow from left to right, each container can only affect the containers to its right, and can only receive water from those to its left.

I need to find a sequence of such operations that results in all containers having the target amount.

Let me consider the first container. It can only give water to containers to its right, it cannot receive from any container since there is no container with a lower index than 1.

So, for the first container, if its initial amount is less than target, it's impossible to add more water to it because it can't receive from any container to its left. Similarly, if its initial amount is more than target, it can pour the excess to the right containers.

Wait, but the problem allows pouring any amount from i to j, where i < j, any number of times. So, perhaps I can model this as cumulative sums or something similar.

Let me think about the cumulative water up to each container.

Let's define the target as sum(a)/n, which is the desired amount in each container.

Let's consider the cumulative deficit or surplus from the target for each container.

Wait, maybe I should think in terms of prefix sums.

Let's compute the prefix sums of the array a:

prefix[i] = a[0] + a[1] + ... + a[i-1]

Similarly, the target prefix sum would be target * i.

For the water distribution to be possible, at each step, the actual prefix sum should be at least the target prefix sum because any deficit in the prefix sum up to i cannot be compensated by future operations since water can only flow forward, not backward.

Wait, let's think about it differently.

If I consider that water can only flow from left to right, then for each container, the total water in containers from 1 to i should be at least i*target because any deficit would require adding water from somewhere, which isn't possible since water can only come from left to right.

Wait, actually, since water can only move forward, the total water in the first i containers should be at least i*target, because if it's less, there's no way to make up for the deficit from the containers to the right.

Similarly, the total water in the first i containers should not be less than i*target.

Wait, let's formalize this.

Let me define target = sum(a)/n.

Then, for the distribution to be possible, for all i from 1 to n, prefix_sum[i] >= target * i.

Because if prefix_sum[i] < target * i, it means that the first i containers don't have enough water to reach the target for themselves, and since water can only be poured forward, there's no way to compensate for this deficit from the containers to the right.

Similarly, since the total sum is divisible by n, and we have the condition that prefix_sum[i] >= target * i for all i, then it should be possible to redistribute the water to reach the target in each container.

Wait, but I need to confirm if this condition is sufficient as well as necessary.

Let's see with an example.

Take the third test case from the example:

n = 5

a = [4, 5, 2, 1, 3]

sum(a) = 4+5+2+1+3 = 15

target = 15/5 = 3

Now, compute prefix sums:

prefix[1] = 4 >= 3*1 = 3 → OK

prefix[2] = 4+5 = 9 >= 3*2 = 6 → OK

prefix[3] = 4+5+2 = 11 >= 3*3 = 9 → OK

prefix[4] = 4+5+2+1 = 12 >= 3*4 = 12 → OK

prefix[5] = 15 >= 15 → OK

Since all prefix sums satisfy prefix[i] >= target*i, it's possible to reach the target distribution.

In the explanation, they show a sequence of operations to reach this.

Now, take the second test case:

n = 2

a = [1, 3]

sum(a) = 4

target = 2

prefix[1] = 1 >= 2? No.

Hence, it's not possible, which matches the "NO" in the output.

Another "NO" case is the fourth test case:

n = 3

a = [1, 2, 3]

sum(a) = 6

target = 2

prefix[1] = 1 >= 2? No.

Hence, "NO".

Another "NO" case is the fifth test case:

n = 7

a = [4,5,5,0,6,4,4]

sum(a) = 28

target = 4

Check prefix sums:

prefix[1] = 4 >= 4*1 = 4 → OK

prefix[2] = 4+5 = 9 >= 8 → OK

prefix[3] = 9+5 = 14 >= 12 → OK

prefix[4] = 14+0 = 14 >= 16? No.

Hence, "NO".

Finally, the sixth test case:

n = 7

a = [6,5,5,1,3,4,4]

sum(a) = 28

target = 4

prefix[1] = 6 >= 4 → OK

prefix[2] = 6+5 = 11 >= 8 → OK

prefix[3] = 11+5 = 16 >= 12 → OK

prefix[4] = 16+1 = 17 >= 16 → OK

prefix[5] = 17+3 = 20 >= 20 → OK

prefix[6] = 20+4 = 24 >= 24 → OK

prefix[7] = 24+4 = 28 >= 28 → OK

Hence, "YES".

So, this seems to be a correct criterion.

Hence, in code, I can compute the target, then compute the prefix sums and check if prefix[i] >= target*i for all i from 1 to n.

If yes, then "YES", else "NO".

Now, looking at the given program:

import sys

input = sys.stdin.read

data = input().split()

n = int(data[0])

a = list(map(int, data[1:]))

print(func_1(n, a))

def func_1(n, a):

total_water = sum(a)

if total_water % n != 0:

return 'No'

target = total_water // n

container = 0

for water in a:

container += water - target

if container < 0:

return 'No'

return 'Yes'

So, the function func_1 seems to be implementing something similar to what I thought.

It first checks if the total water is divisible by n, which is given in the problem, so it's always true.

Then, it computes the target.

Then, it initializes a variable "container" to 0.

Then, for each water in a, it adds water - target to container.

So, container is accumulating the difference between the current container's water and the target.

If at any point container < 0, it returns 'No'.

Otherwise, it returns 'Yes'.

Wait, this seems different from my earlier thought about prefix sums.

But let's see.

In the first test case:

n=1, a=[43]

target=43

container = 43 - 43 = 0

No problem, returns 'Yes'.

Second test case:

n=2, a=[1,3]

target=2

container = 1-2 = -1 < 0 → 'No'

Third test case:

n=5, a=[4,5,2,1,3]

target=3

container:

4-3=1

1 + (5-3)=1+2=3

3 + (2-3)=3-1=2

2 + (1-3)=2-2=0

0 + (3-3)=0+0=0

No negative values, so 'Yes'.

Fourth test case:

n=3, a=[1,2,3]

target=2

container:

1-2=-1 <0 → 'No'

Fifth test case:

n=7, a=[4,5,5,0,6,4,4]

target=4

container:

4-4=0

0 + (5-4)=1

1 + (5-4)=2

2 + (0-4)=2-4=-2 <0 → 'No'

Sixth test case:

n=7, a=[6,5,5,1,3,4,4]

target=4

container:

6-4=2

2 + (5-4)=2+1=3

3 + (5-4)=3+1=4

4 + (1-4)=4-3=1

1 + (3-4)=1-1=0

0 + (4-4)=0+0=0

0 + (4-4)=0+0=0

No negative values, so 'Yes'.

This matches the expected outputs.

So, how does this relate to the prefix sum condition I thought of earlier?

Wait, let's see.

If I look at the variable "container", it's accumulating the difference between the current container's water and the target.

So, container = sum(a[0..i] - target*(i+1))

Which is prefix_sum[i+1] - target*(i+1)

So, container is effectively prefix_sum[i+1] - target*(i+1)

And the condition is that container >=0 at each step.

Which is equivalent to prefix_sum[i+1] >= target*(i+1)

Which is exactly the condition I thought of earlier.

Hence, this implementation is correct.

So, the answer is Correctness: **True**

**Final Solution**
To solve this problem, we need to determine if it is possible to make the amount of water in each of the `n` containers equal by only pouring water from a container with a lower index to one with a higher index. Given that the total sum of water is divisible by `n`, we can proceed with the following approach.

## Approach

1. **Calculate the Target Amount:**
   - Compute the target amount of water each container should have, which is the total sum of water divided by `n`.

2. **Check Cumulative Water:**
   - Maintain a running sum of the differences between the current container's water and the target.
   - Ensure that this running sum never becomes negative, as that would mean we are trying to pour more water than is available.

## Solution Code

```python
def func_1(n, a):
    total_water = sum(a)
    if total_water % n != 0:
        return 'No'
    target = total_water // n
    container = 0
    for water in a:
        container += water - target
        if container < 0:
            return 'No'
    return 'Yes'

# Example usage:
# t = number of test cases
# For each test case:
# Read n and a, then print func_1(n, a)
```

## Explanation

- **Step 1:** Calculate the total sum of water and check if it is divisible by `n`. If not, return 'No' (though per problem, it's always divisible).
  
- **Step 2:** Compute the target amount of water each container should have.
  
- **Step 3:** Initialize a variable `container` to keep track of the cumulative difference from the target.
  
- **Step 4:** Iterate through each container:
  - Adjust `container` by adding the difference between the current container's water and the target.
  - If `container` becomes negative at any point, it means we don't have enough water to reach the target for the previous containers, so return 'No'.
  
- **Step 5:** If the loop completes without `container` becoming negative, return 'Yes'.

This approach ensures that we are always able to meet the target water level in each container by only moving water forward, adhering to the constraints provided.