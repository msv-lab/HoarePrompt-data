Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly X, where X can be up to 10^18. If it's not possible, I should output -1. There are multiple test cases, up to 1000 of them.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence obtained by removing some elements from the array without changing the order, and the remaining elements are strictly increasing. Also, different positions can have the same values, but they are considered different subsequences if their positions differ.

So, for example, in the array [1, 2, 3], the increasing subsequences are:

- Empty subsequence

- [1]

- [2]

- [3]

- [1,2]

- [1,3]

- [2,3]

- [1,2,3]

That's a total of 8 subsequences. But wait, the problem counts the empty subsequence as well, but in the example output for X=2, the array has only one element, which should have 2 increasing subsequences: the empty one and the one with the single element. So, [0] has 2 increasing subsequences: [] and [0].

Similarly, for X=5, the output is [0,1,0], which has the following increasing subsequences:

- []

- [0]

- [1]

- [0,1]

- [0] (the second zero)

So, that's 5 subsequences, which matches.

Now, I need a way to construct an array with exactly X increasing subsequences. Given that X can be up to 10^18, which is a very large number, I need an efficient way to handle this.

First, I should think about how the number of increasing subsequences is related to the array's structure.

Let me consider an array where all elements are distinct and it's sorted in increasing order. In this case, any subset of the elements is an increasing subsequence. So, for an array of length N, there are 2^N total subsets, including the empty one. So, the number of increasing subsequences is 2^N.

But in our problem, the array doesn't have to be sorted, and elements can be equal. So, the number of increasing subsequences can be less than 2^N.

Wait, but in the example, for [0,1,0], N=3, and the number of increasing subsequences is 5, which is less than 2^3=8.

So, the number of increasing subsequences can be less than 2^N.

I need to find an array where the number of increasing subsequences is exactly X.

Given that X can be up to 10^18, and N is at most 200, since 2^200 is way larger than 10^18, it's feasible to have N up to 200 to represent any X up to 10^18.

But I need to minimize N, and the problem allows N up to 200, so that should be sufficient.

Now, I need a strategy to construct such an array.

One approach is to think in terms of binary representation. Since 2^N can represent any number up to 2^N - 1, I can try to represent X in binary and construct the array accordingly.

But in this problem, X can be up to 10^18, which is within 60 bits (since 2^60 is about 1.15e18), so N=60 would be sufficient to represent any X up to 10^18.

But the problem allows N up to 200, so that's more than enough.

Wait, but in the example, for X=5, which is 101 in binary, the array is [0,1,0]. This seems like it's related to the binary representation.

Let me think about this.

If I have an array where each element is either small or large, I can think of small elements as 0 and large elements as 1 in binary representation.

Wait, perhaps I need to think differently.

Let me consider building the array step by step, deciding whether to add a small element or a large element based on whether X is odd or even.

Let me look at the reference solution provided.

The reference solution seems to be reading T test cases, then for each test case, reading X, initializing max and min to 10^9 and -10^9 respectively, then constructing an array ans, and keeping track of t, which is the length of the array.

Then, in a loop, while X !=1:

- If X is even, append max to ans, decrease max by 1, and set X = X // 2

- Else, append min to ans, increase min by 1, and set X = X -1

Then, it reverses the array and prints t and the array.

Hmm, this seems interesting.

Let me try to understand this logic.

First, it initializes max to 10^9 and min to -10^9, which are the upper and lower bounds for the array elements.

Then, it constructs the array ans, and keeps track of t, which is the length of the array.

In the loop, it processes X as follows:

- If X is even, it appends the current max to the array, decreases max by 1, and sets X to X // 2

- If X is odd, it appends the current min to the array, increases min by 1, and sets X to X -1

Then, it reverses the array and prints the length and the array.

Let me try to see how this works for X=5.

X=5, which is odd:

- Append min (-10^9), min becomes -10^9 +1, X=4

- X=4, even:

- Append max (10^9), max becomes 10^9 -1, X=2

- X=2, even:

- Append max (10^9 -1), max becomes 10^9 -2, X=1

- Now X=1, exit loop

- ans = [min, max, max] = [-10^9, 10^9, 10^9-1]

- Reverse ans: [10^9-1, 10^9, -10^9]

- Print t=3 and the array

Wait, but in the example, for X=5, the output is [0,1,0]. But according to this, it's something different.

Wait, maybe there's a different way to construct the array.

Let me think about the properties of increasing subsequences.

Suppose I have an array where all elements are equal, say [a,a,a,...,a]. Then, the only increasing subsequences are the empty one and the single element ones, since no pair of elements can form an increasing subsequence. So, the total number of increasing subsequences is N+1, where N is the length of the array.

But for X=2, the example output is [0], which has 2 increasing subsequences: empty and [0]. For X=5, it's [0,1,0], which has 5 increasing subsequences as I listed earlier.

I need a general way to construct the array for any X up to 10^18.

Let me consider the binary representation of X.

Suppose I can build the array such that the number of increasing subsequences is 2^k for some k, and then combine them in a way to get any X.

But I'm not sure.

Wait, maybe I can think of the array as consisting of segments where each segment contributes a certain number of increasing subsequences, and by choosing how to arrange these segments, I can achieve any X.

Alternatively, perhaps I can use the fact that the number of increasing subsequences in an array is the product of (number of increasing subsequences in its increasing runs).

Wait, perhaps inclusion-exclusion could be applied here.

But this seems complicated.

Let me look back at the reference solution.

It seems to be building the array by repeatedly dividing X by 2 when it's even, and subtracting 1 when it's odd, while appending either max or min to the array.

This resembles the binary representation of X, where each bit corresponds to whether we append min or max.

Wait, perhaps it's constructing the array in a way that the number of increasing subsequences is exactly X by building it bit by bit.

Let me consider how the number of increasing subsequences is affected by appending a new element.

Suppose I have an array A with N elements, and I append a new element X to it.

Then, the number of increasing subsequences in the new array is equal to the number in A plus the number of subsequences in A where the last element is less than X.

So, if X is larger than all elements in A, then the number of increasing subsequences increases by the number of increasing subsequences in A.

If X is smaller than some elements in A, then it only increases by the number of increasing subsequences in A that end with elements less than X.

This is getting complicated.

Let me try to see how the reference solution works for X=5.

Initialize:

max = 10^9

min = -10^9

ans = []

t = 0

X=5

Loop:

X=5, odd: append min (-10^9), min becomes -10^9 +1, X=4

ans = [-10^9], t=1

X=4, even: append max (10^9), max becomes 10^9 -1, X=2

ans = [-10^9, 10^9], t=2

X=2, even: append max (10^9 -1), max becomes 10^9 -2, X=1

ans = [-10^9, 10^9, 10^9 -1], t=3

X=1, exit loop

Reverse ans: [10^9 -1, 10^9, -10^9]

Print t=3 and the array [10^9 -1, 10^9, -10^9]

But in the example, for X=5, the output is [0,1,0].

So, perhaps there is a different approach.

Wait, maybe the reference solution is correct, but the example provided a different correct answer.

Since multiple correct arrays may exist for a given X, both [10^9 -1, 10^9, -10^9] and [0,1,0] could be valid for X=5.

I need to verify if [10^9 -1, 10^9, -10^9] indeed has exactly 5 increasing subsequences.

Let's list them:

- Empty subsequence

- [10^9 -1]

- [10^9]

- [10^9 -1, 10^9]

- [-10^9]

So, that's 4 subsequences. Wait, that's only 4, but X=5. So, perhaps I missed one.

Wait, is [10^9 -1, 10^9, -10^9] an increasing subsequence? No, because 10^9 > -10^9.

So, the increasing subsequences are:

- []

- [10^9 -1]

- [10^9]

- [10^9 -1, 10^9]

- [-10^9]

Yes, that's 5 subsequences.

Wait, but according to my earlier count, it's 5.

Wait, perhaps I miscounted earlier.

So, for [10^9 -1, 10^9, -10^9], the increasing subsequences are:

- []

- [10^9 -1]

- [10^9]

- [10^9 -1, 10^9]

- [-10^9]

Yes, that's 5.

Similarly, for [0,1,0], the increasing subsequences are:

- []

- [0]

- [1]

- [0,1]

- [0] (the second zero)

So, both arrays have exactly 5 increasing subsequences.

Thus, the reference solution seems to be correct for X=5.

Now, let's see for X=2.

X=2:

Loop:

X=2, even: append max (10^9), max becomes 10^9 -1, X=1

ans = [10^9], t=1

X=1, exit loop

Reverse ans: [10^9]

Print t=1 and the array [10^9]

But in the example, for X=2, it's [0].

Both [10^9] and [0] have exactly 2 increasing subsequences: [] and [10^9] or [] and [0].

So, again, both are correct.

Now, for X=13.

X=13:

Loop:

X=13, odd: append min (-10^9), min becomes -10^9 +1, X=12

ans = [-10^9], t=1

X=12, even: append max (10^9), max becomes 10^9 -1, X=6

ans = [-10^9, 10^9], t=2

X=6, even: append max (10^9 -1), max becomes 10^9 -2, X=3

ans = [-10^9, 10^9, 10^9 -1], t=3

X=3, odd: append min (-10^9 +1), min becomes -10^9 +2, X=2

ans = [-10^9, 10^9, 10^9 -1, -10^9 +1], t=4

X=2, even: append max (10^9 -2), max becomes 10^9 -3, X=1

ans = [-10^9, 10^9, 10^9 -1, -10^9 +1, 10^9 -2], t=5

X=1, exit loop

Reverse ans: [10^9 -2, -10^9 +1, 10^9 -1, 10^9, -10^9]

Print t=5 and the array [10^9 -2, -10^9 +1, 10^9 -1, 10^9, -10^9]

But in the example, for X=13, the output is [2,2,3,4,2], which also has 13 increasing subsequences.

So, again, multiple correct answers are possible.

Now, I need to understand why this approach works.

It seems that the algorithm is building the array by considering the binary representation of X.

Wait, but it's not exactly following binary representation, because in binary, we have powers of 2 corresponding to each bit.

Here, by appending max or min, it's controlling the number of increasing subsequences in a way that corresponds to adding or multiplying certain values.

Let me try to think in terms of binary representation.

If I can build an array that has 2^k increasing subsequences, then by combining such arrays, I can achieve any X by summing up appropriate 2^k.

But in this problem, since the subsequences are strictly increasing, it's not just a matter of summing, but of multiplying the possibilities.

Wait, perhaps it's better to think in terms of binary decomposition.

Let me consider that each time I append an element to the array, I double the number of increasing subsequences if the new element is larger than all previous elements, or add a certain number if it's smaller.

Wait, more carefully:

Suppose I have an array A with N elements, and I append a new element X.

Then, the number of increasing subsequences in the new array is equal to the number in A plus the number of subsequences in A that can be extended by X, i.e., those whose last element is less than X.

So, if X is larger than all elements in A, then the number of increasing subsequences doubles, because every subsequence can be extended by X or not.

Wait, actually, if X is larger than all elements in A, then the number of increasing subsequences in the new array is twice the number in A: one copy without X and one copy with X appended.

Yes, that makes sense.

If X is not larger than all elements in A, then the number of increasing subsequences is the number in A plus the number of subsequences in A that end with elements less than X.

This is getting complicated.

Let me see how the reference solution is building the array.

It seems to be building the array in a way that corresponds to the binary representation of X, but with max and min elements.

Wait, perhaps it's constructing the array such that the number of increasing subsequences is 2^k for some k, and then combining them appropriately.

But I'm not sure.

Let me try to see what happens when we append max or min.

Suppose I have an empty array, and I append max (10^9). Then, the array is [10^9], which has 2 increasing subsequences: [] and [10^9].

Now, X was 2, which matches.

For X=5, which is 101 in binary, the algorithm appends min, then max, then max.

So, starting with an empty array:

1. X=5, odd: append min (-10^9), min becomes -10^9 +1, X=4

Array: [-10^9], which has 2 subsequences: [] and [-10^9]

2. X=4, even: append max (10^9), max becomes 10^9 -1, X=2

Array: [-10^9, 10^9]

Increasing subsequences:

- []

- [-10^9]

- [10^9]

- [-10^9,10^9]

Total: 4

3. X=2, even: append max (10^9 -1), max becomes 10^9 -2, X=1

Array: [-10^9, 10^9, 10^9 -1]

Increasing subsequences:

- []

- [-10^9]

- [10^9]

- [-10^9,10^9]

- [10^9 -1]

Total: 5

Yes, that matches X=5.

So, by appending max or min elements in a specific order based on the binary representation of X, it's possible to build an array with exactly X increasing subsequences.

This seems to be the logic behind the reference solution.

Now, I need to verify if this approach always works for any X up to 10^18.

Let me try another example.

Take X=3.

Loop:

X=3, odd: append min (-10^9), min becomes -10^9 +1, X=2

ans = [-10^9], t=1

X=2, even: append max (10^9), max becomes 10^9 -1, X=1

ans = [-10^9,10^9], t=2

X=1, exit loop

Reverse ans: [10^9, -10^9]

Increasing subsequences:

- []

- [10^9]

- [-10^9]

Total: 3, which matches X=3.

Another example: X=6.

Loop:

X=6, even: append max (10^9), max becomes 10^9 -1, X=3

ans = [10^9], t=1

X=3, odd: append min (-10^9), min becomes -10^9 +1, X=2

ans = [10^9, -10^9], t=2

X=2, even: append max (10^9 -1), max becomes 10^9 -2, X=1

ans = [10^9, -10^9, 10^9 -1], t=3

X=1, exit loop

Reverse ans: [10^9 -1, -10^9, 10^9]

Increasing subsequences:

- []

- [10^9 -1]

- [-10^9]

- [10^9]

- [10^9 -1,10^9]

- [-10^9,10^9]

Total: 6, which matches X=6.

Seems correct.

Now, for X=1, the loop exits immediately, and it seems that the array is empty, which has only one increasing subsequence: the empty one. But X=1 is not in the input range (X >=2), so it's fine.

Now, I need to confirm if this approach always works.

I think it does, because at each step, by choosing to append either min or max, it's effectively controlling the number of increasing subsequences in a way that allows building any X up to 10^18.

Also, the array length is at most 60, since X can be up to 10^18, which is within the limit of 200.

But the reference solution allows up to 200 elements, which is more than sufficient.

Therefore, the reference solution seems correct.

**Final Solution**

To solve this problem, we need to construct an array of integers with at most 200 elements such that the number of increasing subsequences in the array is exactly equal to a given value X, where X can be up to 10^18. If such an array cannot be constructed, we should report that it is impossible.

### Approach

1. **Understanding Increasing Subsequences**:
   - An increasing subsequence is one where elements are strictly increasing.
   - The empty subsequence is also considered increasing.

2. **Binary Representation Insight**:
   - The number of increasing subsequences can be built using a method similar to binary decomposition.
   - By appending either the maximum or minimum values in a controlled manner, we can achieve the desired count of increasing subsequences.

3. **Construction of the Array**:
   - Start with an empty array.
   - While X is greater than 1, perform the following:
     - If X is even, append the current maximum value to the array, decrease the maximum value, and set X to X divided by 2.
     - If X is odd, append the current minimum value to the array, increase the minimum value, and decrement X by 1.
   - Reverse the constructed array to ensure the correct order of elements.

### Solution Code

```python
def func():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        x = int(data[index])
        index += 1
        if x == 1:
            print(-1)
            continue
        max_val = 1000000000
        min_val = -1000000000
        ans = []
        while x != 1:
            if x % 2 == 0:
                ans.append(max_val)
                max_val -= 1
                x = x // 2
            else:
                ans.append(min_val)
                min_val += 1
                x -= 1
        ans.reverse()
        print(len(ans))
        print(' '.join(map(str, ans)))

if __name__ == "__main__":
    func()
```

### Explanation

1. **Reading Input**:
   - Read the number of test cases and the values of X for each test case.

2. **Edge Case Handling**:
   - If X is 1, which is outside the specified range (X >= 2), output -1.

3. **Array Construction**:
   - Use a loop to construct the array based on whether X is even or odd.
   - Append either the current maximum or minimum value to the array and adjust the value accordingly.
   - Reverse the array to ensure the correct sequence of elements.

4. **Output the Result**:
   - Print the length of the array and the array itself for each test case.

This approach ensures that we can construct an array with the exact number of increasing subsequences equal to X efficiently and correctly.