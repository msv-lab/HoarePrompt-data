Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign occurs every a_i years. The signs have to occur sequentially, meaning that after the first sign occurs, we start waiting for the second sign in the next year, and so on.

First, I need to understand how the signs occur. Each sign i occurs in years that are multiples of a_i, like a_i, 2*a_i, 3*a_i, and so on. But they have to occur one after another in sequence.

So, for example, if n=2 and a=[2,3], meaning the first sign occurs every 2 years and the second every 3 years. If the first sign occurs in year 2, then we start waiting for the second sign from year 3 onwards. The second sign occurs in years 3 and 6 and 9, etc. So, the earliest year both conditions are satisfied is when the first sign occurs in year 2, and then the second sign occurs in year 3.

Wait, but according to the problem, after the first sign occurs in year x, we start waiting for the second sign from year x+1 onwards. So, if the first sign is in year 2, we look for the second sign in years 3,4,5,6, etc., and since 3 is a multiple of 3, it occurs in year 3. So, the apocalypse happens in year 3.

But let's check another example to make sure I understand. Suppose n=3 and a=[2,4,6]. The first sign occurs in years 2,4,6,8,... Let's say it occurs in year 2. Then we start looking for the second sign from year 3 onwards. The second sign occurs in years 4,8,12,... The earliest occurrence after year 3 is in year 4. So, the second sign occurs in year 4. Now, we start looking for the third sign from year 5 onwards. The third sign occurs in years 6,12,18,... The earliest after year 5 is year 6. So, the apocalypse happens in year 6.

Another way to think about it is that for each sign after the first, we need to find the smallest year that is greater than the year the previous sign occurred and is a multiple of a_i.

So, generalizing, for each sign i from 1 to n-1, we need to find the smallest year y_{i+1} such that y_{i+1} > y_i and y_{i+1} is a multiple of a_{i+1}.

Starting with y_1 = a_1, then finding y_2, y_3, ..., y_n sequentially.

Wait, but in the first example, y_1 could be a_1, but it could also be 2*a_1, 3*a_1, etc., as long as it's the earliest possible.

But to minimize the year when the apocalypse happens, we should choose the smallest possible y_1, y_2, ..., y_n.

So, y_1 = a_1.

Then, y_2 is the smallest multiple of a_2 that is greater than y_1.

Similarly, y_3 is the smallest multiple of a_3 that is greater than y_2, and so on.

Yes, that makes sense.

So, in code, for each sign from the second one to the nth one, we need to calculate the next y_i as the smallest multiple of a_i that is greater than the previous y_{i-1}.

To find the smallest multiple of a that is greater than x, we can use the formula:

next = ((x // a) + 1) * a

This formula finds the smallest multiple of a that is greater than or equal to x. Since we need it to be greater than x, we can adjust it slightly.

Wait, actually, to find the smallest multiple of a that is greater than x, we can do:

if x % a == 0:

next = x + a

else:

next = x - (x % a) + a

Or more concisely:

next = (x + a - 1) // a * a

This will give the smallest multiple of a that is greater than or equal to x. But since we need it to be greater than x, we need to make sure that if x is a multiple of a, then next should be x + a.

So, in code, we can write:

next = ((x + a - 1) // a) * a

This will cover both cases.

Okay, so in the code, we start with y = a[0], then for each subsequent a_i, we set y to be the smallest multiple of a_i that is greater than y.

Finally, y will be the year when the nth sign occurs.

Looking at the provided program:

if __name__ == '__main__':

func_1()

def func_1():

import sys

input = sys.stdin.read

data = input().split()

index = 0

T = int(data[index])

index += 1

results = []

for _ in range(T):

n = int(data[index])

index += 1

a = list(map(int, data[index:index + n]))

index += n

last_year = a[0]

for i in range(1, n):

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

last_year = next_year

results.append(str(last_year))

sys.stdout.write('\n'.join(results) + '\n')

So, it reads all input at once, splits it into tokens, and processes each test case one by one.

For each test case, it reads n, then reads n integers a_1 to a_n.

It sets last_year to a[0], which is correct.

Then, for each sign from the second one to the nth one, it calculates the next_year as ((last_year + 1) + a[i] - 1) // a[i] * a[i].

Wait, let's break this down.

(last_year + 1) is because we need to start looking for the next sign from the year immediately after last_year.

Then, (last_year + 1 + a[i] - 1) // a[i] * a[i] is equivalent to the smallest multiple of a[i] that is greater than last_year.

Yes, that matches the formula I derived earlier.

So, it correctly calculates the next year for each sign.

Finally, it collects all the results in a list and prints them joined by newlines.

This seems correct.

Let me verify with the first example in the problem.

Input:

4

6

3 2 4 5 9 18

5

1 2 3 4 5

5

1 1 1 1 1

6

50 30 711 200 503 1006

Output:

36

5

5

2012

Let's check the first test case:

n=6, a=[3,2,4,5,9,18]

y1 = 3

y2 = smallest multiple of 2 greater than 3, which is 4

y3 = smallest multiple of 4 greater than 4, which is 8

y4 = smallest multiple of 5 greater than 8, which is 10

y5 = smallest multiple of 9 greater than 10, which is 18

y6 = smallest multiple of 18 greater than 18, which is 36

So, y6=36, which matches the first output.

Second test case:

n=5, a=[1,2,3,4,5]

y1=1

y2=smallest multiple of 2 greater than 1, which is 2

y3=smallest multiple of 3 greater than 2, which is 3

y4=smallest multiple of 4 greater than 3, which is 4

y5=smallest multiple of 5 greater than 4, which is 5

So, y5=5, matches the second output.

Third test case:

n=5, a=[1,1,1,1,1]

y1=1

y2=smallest multiple of 1 greater than 1, which is 2

y3=smallest multiple of 1 greater than 2, which is 3

y4=smallest multiple of 1 greater than 3, which is 4

y5=smallest multiple of 1 greater than 4, which is 5

So, y5=5, matches the third output.

Fourth test case:

n=6, a=[50,30,711,200,503,1006]

y1=50

y2=smallest multiple of 30 greater than 50, which is 60

y3=smallest multiple of 711 greater than 60, which is 711

y4=smallest multiple of 200 greater than 711, which is 800

y5=smallest multiple of 503 greater than 800, which is 1006

y6=smallest multiple of 1006 greater than 1006, which is 2012

So, y6=2012, matches the fourth output.

Seems correct.

Edge cases to consider:

- n=1: Should just return a[0]

- All a_i=1: Should return n

- a_i=1 and n is large, up to 100

- a_i=10^6 and n=1: Should return 10^6

- a_i=1 and a_{i+1}>1

Let's test n=1, a=[10]: Should return 10

n=2, a=[1,2]: y1=1, y2=2: return 2

n=2, a=[2,1]: y1=2, y2=2 (since 2 is a multiple of 1 greater than 2): return 2

Wait, but according to the formula:

next_year = ((last_year + 1) + a[i] - 1) // a[i] * a[i]

So, last_year=2, a[i]=1

next_year = ((2 + 1) + 1 - 1) // 1 * 1 = 3 // 1 * 1 = 3*1=3

Wait, but 2 is already a multiple of 1, but since we need it to be greater than last_year, it should be 3.

But in reality, sign 2 occurs in years 1,2,3,... so the smallest year greater than 2 is 3.

So, y2=3

So, the function should return 3 in this case.

Wait, but in my earlier calculation, I thought y2=2, but according to the formula, it's 3.

So, my earlier thought was wrong.

Hence, the function is correct.

Another edge case: n=2, a=[2,3]

y1=2

y2=smallest multiple of 3 greater than 2, which is 3

So, y2=3

Another case: n=3, a=[2,4,6]

y1=2

y2=smallest multiple of 4 greater than 2, which is 4

y3=smallest multiple of 6 greater than 4, which is 6

So, y3=6

Seems correct.

Time constraints:

T can be up to 1000, n up to 100, a_i up to 10^6

But since the operations inside are O(1), overall time should be acceptable.

No issues there.

So, I think the program is correct.

**Final Answer**

\[\boxed{36}\]