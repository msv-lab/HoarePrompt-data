Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers i, j, and x, where 1 ≤ i ≤ j ≤ n, and setting all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is essentially the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I have to spend to achieve this. The problem guarantees that it's always possible to make all elements equal, which makes sense because I can always set the entire array to a single value if needed.

First, I need to understand the constraints and what operations I can perform. I can perform the operation at most once, meaning I can choose one segment of the array and set all its elements to a single value x. After this operation, the entire array should be equal.

Wait a minute, but the problem says "no more than once," which means I can choose to perform the operation zero or one time. So, I might not need to perform the operation at all if the array is already uniform.

Looking at the examples:

In the first test case:

6

1 2 3 4 5 1

If I set indices 2 to 4 to 1, the array becomes [1,1,1,1,5,1]. Then, I can set indices 4 to 4 to 1, but since I can only perform one operation, that's not allowed. Wait, but the sample output is 4, which suggests setting indices 2 to 5 to 1, resulting in [1,1,1,1,1,1], with a cost of 4 burles.

In the second test case:

7

1 1 1 1 1 1 1

The array is already uniform, so no operation is needed, and the cost is 0.

In the third test case:

8

8 8 8 1 2 8 8 8

If I set indices 4 to 5 to 8, the array becomes [8,8,8,8,8,8,8,8], with a cost of 2 burles.

From these examples, it seems like the strategy is to find the largest contiguous segments that already have the same value and try to minimize the cost by maximizing the length of these segments.

Wait, but in the third test case, setting indices 4 to 5 to 8 covers two elements, making the entire array 8's. So, the cost is 2 burles.

Another way to think about it is to find the longest segment of the array that has the same value and then calculate the cost based on that.

But, I need to generalize this for any array.

Let me consider that I can choose to set one segment of the array to a specific value, and then the rest of the array should already be equal to that value for the entire array to be uniform.

Wait, no. After setting the segment, all elements in that segment are set to x, and the elements outside remain as they are. So, to make the entire array equal, the elements outside the segment must already be equal to x.

So, I need to choose x such that the elements outside the segment are all equal to x, and then set the segment to x as well.

Wait, but in the first example, setting indices 2 to 5 to 1, the elements outside are already 1, so the whole array becomes 1's.

Similarly, in the third example, setting indices 4 to 5 to 8, the elements outside are already 8's.

So, in both cases, the elements outside the segment are already equal to x.

Therefore, the strategy is to choose a value x and a segment [i,j] such that all elements outside [i,j] are already equal to x, and then set the segment [i,j] to x.

The cost is (j - i + 1) burles.

To minimize the cost, I need to minimize the length of the segment [i,j].

Wait, but minimizing the segment length means minimizing (j - i + 1), which is the cost.

But in the first example, setting [2,5] with cost 4 is better than setting [2,4] with cost 3, because [2,5] covers more elements, but in terms of cost, it's higher. Wait, no, I need to minimize the cost, so choosing a smaller segment is better, but in that case, choosing a smaller segment might not cover all necessary elements.

Wait, perhaps I need to think differently.

Let me consider that I need to make the entire array equal to some value x.

I can choose to set one segment to x, and the rest of the array should already be x.

But in reality, the rest of the array may not be x, so I need to adjust my thinking.

Wait, perhaps it's better to find the value x that maximizes the number of elements already equal to x, and then set the remaining elements to x in one operation.

But, the operation allows me to set only a contiguous segment to x.

So, I can't set multiple disjoint segments in one operation.

Therefore, I need to find a contiguous segment such that, when set to x, the entire array becomes equal to x.

This means that, outside of this segment, all elements must already be equal to x.

So, I need to choose x and a segment [i,j] such that:

- All elements from 1 to i-1 are already x.

- All elements from j+1 to n are already x.

- I set the elements from i to j to x.

The cost is (j - i + 1) burles.

To minimize this cost, I need to maximize the length of the segment [i,j], but this would increase the cost.

Wait, no, to minimize the cost, I need to minimize (j - i + 1), which is the length of the segment being set.

But, if I minimize the segment, I might be covering fewer elements, which could mean that more elements outside the segment need to be equal to x.

Wait, but I can't change more than one segment in one operation.

I need to find a balance.

Wait, perhaps I need to find the smallest segment such that, when set to x, the entire array becomes equal to x.

This would involve finding x such that the left and right parts of the array outside this segment are already equal to x.

So, I need to find x, and then find the minimal segment [i,j] such that:

- For all positions k < i, a[k] == x.

- For all positions k > j, a[k] == x.

Then, set a[i] to a[j] to x.

The cost is (j - i + 1).

I need to choose x and [i,j] such that this cost is minimized.

To minimize the cost, I need to minimize (j - i + 1), which is the length of the segment being set.

But, I also need to ensure that the segments outside [i,j] are already equal to x.

So, for each possible x, I can find the minimal segment [i,j] that needs to be set to x to make the entire array equal to x.

Then, among all possible x, I choose the one that minimizes this segment length.

Wait, but how do I find the minimal segment for each x?

Let's consider that for a given x, I can find the smallest segment [i,j] such that:

- All elements to the left of i are already x.

- All elements to the right of j are already x.

Then, setting [i,j] to x will make the entire array equal to x.

To find i and j for a given x:

- Find the smallest i such that for all k < i, a[k] == x.

- Find the largest j such that for all k > j, a[k] == x.

Then, set [i,j] to x.

The cost is (j - i + 1).

I need to minimize this over all possible x.

So, for each possible x, compute the minimal segment [i,j] needed to set to x to make the entire array equal to x, and then choose the x that gives the smallest (j - i + 1).

Additionally, I need to consider the case where the entire array is already equal to x, in which case no operation is needed, and the cost is 0.

Wait, but the problem allows me to perform the operation at most once, meaning I can choose not to perform any operation if the array is already uniform.

So, for each x, I need to find the minimal segment [i,j] such that setting [i,j] to x makes the entire array equal to x.

Then, the minimal cost is the minimum over all x of (j - i + 1), and if the array is already uniform, the cost is 0.

Wait, but in the third test case, n=8, a=[8,8,8,1,2,8,8,8], and the output is 2.

If I choose x=8, then:

- All elements to the left of i=4 are 8.

- All elements to the right of j=5 are 8.

So, setting [4,5] to 8 costs 2 burles, which matches the sample output.

Similarly, in the first test case, n=6, a=[1,2,3,4,5,1], and the output is 4.

If I choose x=1, then:

- All elements to the left of i=2 are 1 (only a[1]=1).

- All elements to the right of j=5 are 1 (a[6]=1).

So, setting [2,5] to 1 costs 4 burles, which matches the sample output.

In the second test case, n=7, a=[1,1,1,1,1,1,1], output is 0, which is correct because no operation is needed.

In the fourth test case, n=1, a=[1], output is 0, which is correct.

In the fifth test case, n=2, a=[1,2], output is 1.

If I choose x=1, then:

- All elements to the left of i=2 are 1.

- All elements to the right of j=2 are nothing, which is fine.

So, set [2,2] to 1, cost is 1.

Alternatively, choose x=2:

- All elements to the left of i=1 are nothing, which is fine.

- All elements to the right of j=1 are 2.

So, set [1,1] to 2, cost is 1.

So, minimal cost is 1, which matches the sample output.

In the sixth test case, n=3, a=[1,2,3], output is 2.

If I choose x=1:

- All elements to the left of i=2 are 1.

- All elements to the right of j=2 are 3, which is not 1.

So, can't choose x=1.

If I choose x=2:

- All elements to the left of i=1 are nothing, which is fine.

- All elements to the right of j=3 are nothing, which is fine.

So, set [1,3] to 2, cost is 3.

If I choose x=3:

- All elements to the left of i=3 are 1 and 2, which are not 3.

So, can't choose x=3.

So, minimal cost is 3, but the sample output is 2, which suggests that choosing x=3 is possible with a cost of 2.

Wait, maybe I'm misunderstanding.

Wait, if I choose x=3, then:

- All elements to the left of i=3 are 1 and 2, which are not 3.

So, I can't choose x=3 because the elements to the left of i=3 are not all 3.

Wait, but according to the sample output, the minimal cost is 2, but I'm getting 3.

Wait, maybe I need to choose a different x.

Wait, perhaps choosing x=1 or x=2 isn't optimal.

Wait, let's see:

If I choose x=1:

- Set [2,3] to 1, making the array [1,1,1], cost is 2.

Similarly, choosing x=3:

- Set [1,2] to 3, making the array [3,3,3], cost is 2.

So, minimal cost is 2, which matches the sample output.

I see, so I need to consider all possible x and find the minimal cost among them.

So, the approach is:

- For each possible x (from 1 to n, since a_i <= n):

- Find the smallest i such that for all k < i, a[k] == x.

- Find the largest j such that for all k > j, a[k] == x.

- Then, the cost is (j - i + 1).

- Take the minimum over all x of these costs.

- Additionally, if the array is already uniform, the cost is 0.

Wait, but in the third test case, n=8, a=[8,8,8,1,2,8,8,8], choosing x=8:

- Smallest i: a[1]=8, a[2]=8, a[3]=8, so i=4.

- Largest j: a[6]=8, a[7]=8, a[8]=8, so j=5.

- Set [4,5] to 8, cost is 2.

Which matches the sample output.

In the sixth test case, n=3, a=[1,2,3]:

- Choosing x=1:

- Smallest i: a[1]=1, so i=2.

- Largest j: a[3]=3 !=1, so j=1.

- So, set [2,3] to 1, cost is 2.

- Choosing x=2:

- Smallest i: a[1]=1 !=2, so i=1.

- Largest j: a[3]=3 !=2, so j=2.

- Set [1,2] to 2, cost is 2.

- Choosing x=3:

- Smallest i: a[1]=1 !=3, so i=1.

- Largest j: a[3]=3, so j=2.

- Set [1,2] to 3, cost is 2.

So, minimal cost is 2.

Wait, but in the earlier thought, I had a cost of 3 for x=2, but actually, it's 2.

Wait, perhaps I miscalculated earlier.

So, the general approach is:

- For each possible x:

- Find the smallest i such that for all k < i, a[k] == x.

- Find the largest j such that for all k > j, a[k] == x.

- Then, the minimal segment to set is [i, j], with cost (j - i + 1).

- Take the minimal cost over all x.

- If the array is already uniform, the cost is 0.

Now, to implement this efficiently, considering that t can be up to 10^4 and n up to 2*10^5, with the sum of n over all test cases up to 2*10^5, I need an efficient algorithm.

A naive approach for each test case would be:

- Iterate over all possible x from 1 to n.

- For each x, find the smallest i such that for all k < i, a[k] == x.

- Find the largest j such that for all k > j, a[k] == x.

- Compute (j - i + 1).

- Take the minimum over all x.

But this would be O(t * n^2), which is too slow because t * n^2 = 10^4 * (2*10^5)^2 is way beyond time limits.

Wait, no, it's O(t * n), because for each x, finding i and j is O(n), and x can be up to n, so overall O(t * n^2), which is too slow.

I need a better approach.

Let me think differently.

Suppose I fix x and try to find the minimal segment [i,j] to set to x to make the entire array equal to x.

To minimize (j - i + 1), I need to maximize the lengths of the prefix and suffix that are already equal to x.

So, for each x, compute:

- The length of the longest prefix that is equal to x.

- The length of the longest suffix that is equal to x.

Then, the minimal segment to set is from (prefix_len + 1) to (n - suffix_len), and the cost is (n - (prefix_len + suffix_len)).

So, the cost for x is n - (prefix_len + suffix_len).

Then, the minimal cost over all x is the minimum n - (prefix_len + suffix_len) over all x.

This makes sense because prefix_len + suffix_len is the total number of elements already equal to x, and n - (prefix_len + suffix_len) is the number of elements that need to be set to x.

But, there's an overlap to consider: if the prefix and suffix overlap, meaning that some elements are counted in both prefix and suffix.

Wait, but in reality, the prefix and suffix might overlap if the array has a long sequence of x's in the middle.

But in this case, the segment [i,j] would be the part that's not in the prefix or suffix.

Wait, perhaps it's better to precompute the longest prefix and suffix for each x.

But this seems time-consuming.

Wait, perhaps I can precompute for each x:

- The length of the longest prefix consisting entirely of x.

- The length of the longest suffix consisting entirely of x.

Then, for each x, the minimal segment to set is n - (prefix_len + suffix_len).

Then, the minimal cost is the minimum over all x of n - (prefix_len + suffix_len).

This seems efficient because for each test case, I can compute the prefix and suffix lengths for each x in O(n) time.

Wait, but x can be up to n, and for each x, I need to compute prefix_len and suffix_len.

So, overall, it's O(n * n), which is still too slow for t=10^4.

Wait, no, x can be up to n, but in practice, n can be up to 2*10^5, and t up to 10^4, but the sum of n over all test cases is up to 2*10^5, so overall time should be acceptable.

But I need to optimize it.

Let me think about how to compute prefix_len and suffix_len for each x efficiently.

Wait, perhaps I can iterate through the array once and keep track of the current prefix and suffix for each x.

Wait, but that might still be too slow.

An alternative approach is to realize that the minimal cost is n minus the maximum of (prefix_len + suffix_len) over all x.

So, I need to maximize (prefix_len + suffix_len) for each x, and then the minimal cost is n minus that maximum.

Wait, but if the prefix and suffix overlap, their sum could be greater than n, but that's not possible because the total number of elements is n.

But in reality, if the prefix and suffix overlap, their combined length cannot exceed n.

Wait, but in practice, for each x, prefix_len + suffix_len <= n + overlap.

But to avoid double-counting the overlap, I need to ensure that prefix_len + suffix_len does not exceed n.

Wait, perhaps it's better to calculate for each x:

- prefix_len[x]: length of the longest prefix consisting entirely of x.

- suffix_len[x]: length of the longest suffix consisting entirely of x.

Then, the total number of elements already equal to x is at least prefix_len[x] + suffix_len[x] - overlap.

But to avoid dealing with overlap, perhaps I can consider that the minimal segment to set is n - (prefix_len[x] + suffix_len[x] - overlap), but I need to find a way to compute this correctly.

Wait, perhaps a better way is to observe that the minimal segment to set for x is n - (prefix_len[x] + suffix_len[x] - overlap), but since overlap can be up to min(prefix_len[x], suffix_len[x]), it's complicated.

Alternatively, perhaps I can iterate through the array and find the maximum prefix_len[x] + suffix_len[x] for any x, and then the minimal cost is n - max(prefix_len[x] + suffix_len[x] - overlap).

This seems messy.

Let me think differently.

Suppose I fix x and find the smallest i such that a[k] == x for all k < i.

Similarly, find the largest j such that a[k] == x for all k > j.

Then, the segment [i, j] needs to be set to x, and the cost is j - i + 1.

I need to minimize j - i + 1 over all x.

So, for each x, find the smallest i where a[k] != x for some k < i.

Similarly, find the largest j where a[k] != x for some k > j.

Wait, perhaps it's better to find the largest i where a[k] == x for all k < i.

Similarly, find the smallest j where a[k] == x for all k > j.

Wait, I need to clarify.

Let me try to formalize it.

For a given x, define:

- L[x]: the largest index i such that for all k < i, a[k] == x.

- R[x]: the smallest index j such that for all k > j, a[k] == x.

Then, the segment to set is from i to j, and the cost is j - i + 1.

I need to minimize j - i + 1 over all x.

Also, if L[x] >= R[x], meaning that the prefix and suffix overlap, then the array is already uniform with value x, and the cost is 0.

So, for each x, compute L[x] and R[x], and if L[x] >= R[x], cost is 0; else, cost is R[x] - L[x] + 1.

Then, take the minimal cost over all x.

This seems correct.

Now, to implement this efficiently, I need to compute L[x] and R[x] for each x.

Given that n can be up to 2*10^5 and t up to 10^4, but the sum of n over all test cases is up to 2*10^5, I need an efficient way to compute L[x] and R[x].

Here's how I can do it:

- For each x, find the largest i such that a[k] == x for all k < i.

- For each x, find the smallest j such that a[k] == x for all k > j.

To find L[x], iterate from the start of the array and keep track of the farthest index where a[k] == x for all k < i.

Similarly, for R[x], iterate from the end of the array and keep track of the closest index where a[k] == x for all k > j.

Once I have L[x] and R[x], compute the cost as R[x] - L[x] + 1 if L[x] < R[x], else 0.

Then, take the minimal cost over all x.

This should work.

Let me try this with the first test case:

n=6, a=[1,2,3,4,5,1]

For x=1:

- L[1]: largest i where a[k]==1 for all k < i. a[1]=1, a[2]=2 !=1, so L[1]=2.

- R[1]: smallest j where a[k]==1 for all k > j. a[6]=1, a[5]=5 !=1, so R[1]=5.

- Cost: 5 - 2 + 1 = 4.

For x=2:

- L[2]: a[1]=1 !=2, so L[2]=1.

- R[2]: a[2]=2, a[3]=3 !=2, so R[2]=3.

- Cost: 3 - 1 + 1 = 3.

For x=3:

- L[3]: a[1]=1 !=3, a[2]=2 !=3, a[3]=3, so L[3]=3.

- R[3]: a[3]=3, a[4]=4 !=3, so R[3]=4.

- Cost: 4 - 3 + 1 = 2.

For x=4:

- L[4]: a[1..3] !=4, so L[4]=4.

- R[4]: a[4]=4, a[5]=5 !=4, so R[4]=5.

- Cost: 5 - 4 + 1 = 2.

For x=5:

- L[5]: a[1..4] !=5, so L[5]=5.

- R[5]: a[5]=5, a[6]=1 !=5, so R[5]=6.

- Cost: 6 -