Alright, I have this problem to solve. Let's see what it's asking for. So, I'm given an integer n and three strings a, b, and c, each of length n. I need to determine if there exists a template string t of length n, consisting of lowercase and/or uppercase Latin letters, such that strings a and b match the template t, while string c does not match it.

First, I need to understand what it means for a string to match the template t. The problem describes two conditions:

1. If the i-th character of t is lowercase, then the i-th character of the string must be exactly the same as t's i-th character.

2. If the i-th character of t is uppercase, then the i-th character of the string must be different from the lowercase version of t's i-th character.

Also, for string c, it should not match the template t, meaning that at least one position i violates one of the above conditions.

My task is to check, for each test case, whether such a template t exists that satisfies these conditions for strings a, b, and c.

Let me try to rephrase the problem in my own words to make sure I understand it. I need to find a template t that, when applied to strings a and b, both a and b match the template, but c does not match it. The template can have mixed case letters, and the matching rules depend on whether the template's character at each position is lowercase or uppercase.

I should think about what constraints this imposes on the characters of a, b, and c at each position.

Let's consider each position i from 1 to n.

- If t[i] is lowercase, then:

  - a[i] must be equal to t[i]

  - b[i] must be equal to t[i]

  - c[i] must not be equal to t[i] (since if t[i] is lowercase, c must differ from t[i])

- If t[i] is uppercase, then:

  - a[i] must be different from the lowercase version of t[i]

  - b[i] must be different from the lowercase version of t[i]

  - c[i] must be equal to the lowercase version of t[i] (since for c to not match, it must violate the condition for uppercase t[i])

Wait, that seems a bit confusing. Let me think again.

Actually, for t[i] being uppercase, the condition is that s[i] must be different from the lowercase version of t[i]. So, for a and b to match t, their i-th characters must be different from the lowercase of t[i] if t[i] is uppercase. For c to not match t, it must be that c[i] is equal to the lowercase of t[i] when t[i] is uppercase.

Alternatively, if t[i] is lowercase, then a[i], b[i], and c[i] must all be equal to t[i], but c must not match, so this seems problematic because if t[i] is lowercase, both a and b must have a[i] == t[i] and b[i] == t[i], and c must have c[i] != t[i].

But wait, c is supposed to not match t, which means that there is at least one position where c does not satisfy the condition for t[i].

So, for t[i] being lowercase, c[i] must be different from t[i], and for t[i] being uppercase, c[i] must be equal to the lowercase of t[i].

But I need to ensure that a and b both match t, meaning:

- For each position i:

  - If t[i] is lowercase, then a[i] == t[i] and b[i] == t[i]

  - If t[i] is uppercase, then a[i] != lowercase(t[i]) and b[i] != lowercase(t[i])

And for c to not match t, there exists at least one position i where:

- If t[i] is lowercase, then c[i] != t[i]

- If t[i] is uppercase, then c[i] == lowercase(t[i])

I need to choose t in such a way that a and b both match t, and c does not match t.

Let me think about possible strategies to find such a template t.

One approach is to iterate through each position i and determine what t[i] should be based on the characters in a[i], b[i], and c[i].

For each position i, I need to decide whether to make t[i] lowercase or uppercase.

Let's consider the possibilities for t[i]:

1. Choose t[i] as lowercase:

   - Then, a[i] must equal t[i], and b[i] must equal t[i], and c[i] must not equal t[i].

   - So, for this choice to be valid, a[i] must equal b[i], and c[i] must be different from a[i].

2. Choose t[i] as uppercase:

   - Then, a[i] must be different from lowercase(t[i]), and b[i] must be different from lowercase(t[i]), and c[i] must equal lowercase(t[i]).

   - Since t[i] is uppercase, lowercase(t[i]) is the lowercase version of t[i].

   - So, for this choice to be valid, a[i] != lowercase(t[i]), b[i] != lowercase(t[i]), and c[i] == lowercase(t[i]).

Given these constraints, I need to choose for each position i whether to make t[i] lowercase or uppercase, such that all positions satisfy the conditions for a and b matching t, and c not matching t.

Let me consider the two cases for each position:

Case 1: t[i] is lowercase.

- a[i] == t[i]

- b[i] == t[i]

- c[i] != t[i]

- Therefore, a[i] == b[i], and c[i] != a[i]

Case 2: t[i] is uppercase.

- a[i] != lowercase(t[i])

- b[i] != lowercase(t[i])

- c[i] == lowercase(t[i])

- Therefore, a[i] != c[i], b[i] != c[i], and t[i] is the uppercase version of c[i]

Wait, but t[i] is uppercase, so lowercase(t[i]) is just the lowercase version of t[i]. So, t[i] is uppercase, and lowercase(t[i]) is the corresponding lowercase letter.

So, for uppercase t[i], we have:

- a[i] != lowercase(t[i])

- b[i] != lowercase(t[i])

- c[i] == lowercase(t[i])

Therefore, for each position i, if I choose t[i] to be lowercase, then a[i] and b[i] must be equal, and c[i] must be different from a[i].

If I choose t[i] to be uppercase, then a[i] and b[i] must both be different from c[i], and c[i] must be the lowercase version of t[i].

So, for each position i, I have these constraints based on the choice of t[i]'s case.

Now, I need to see if there exists a combination of choices for each position that satisfies all these constraints simultaneously for all positions.

This sounds like a problem where I need to check, for each position, whether the choices are consistent with each other.

Let me think about it step by step.

For each position i:

- If I choose t[i] to be lowercase:

  - a[i] == b[i]

  - c[i] != a[i]

- If I choose t[i] to be uppercase:

  - a[i] != c[i]

  - b[i] != c[i]

In the uppercase case, t[i] is uppercase, and its lowercase version is c[i].

Wait, no. In the uppercase case, c[i] == lowercase(t[i]), so t[i] must be the uppercase version of c[i].

So, for uppercase t[i], t[i] must be equal to c[i].upper(), and a[i] != c[i], and b[i] != c[i].

Therefore, for each position i, if I choose t[i] to be uppercase, then:

- t[i] = c[i].upper()

- a[i] != c[i]

- b[i] != c[i]

If I choose t[i] to be lowercase:

- t[i] = a[i] (which must equal b[i])

- c[i] != a[i]

So, in summary:

- For lowercase t[i]:

  - a[i] == b[i]

  - c[i] != a[i]

- For uppercase t[i]:

  - t[i] = c[i].upper()

  - a[i] != c[i]

  - b[i] != c[i]

Now, for the template t to exist, for each position i, I need to choose whether t[i] is lowercase or uppercase, with the constraints above.

Moreover, the choices for different positions are independent; each position can be chosen separately.

Wait, actually, the choices for different positions are independent because the template t is constructed position by position, and the choices at one position do not affect the choices at other positions.

Therefore, for each position i, I can decide independently whether to make t[i] lowercase or uppercase, as long as the constraints for that position are satisfied.

So, for each position i:

- If a[i] == b[i] and c[i] != a[i], then I can choose t[i] to be lowercase, set t[i] = a[i].

- If a[i] != c[i] and b[i] != c[i], then I can choose t[i] to be uppercase, set t[i] = c[i].upper().

- In addition, I must ensure that in the uppercase case, a[i] != c[i] and b[i] != c[i].

Now, to satisfy the overall condition, I need to choose for each position i either lowercase or uppercase, such that:

- For positions where I choose lowercase:

  - a[i] == b[i] and c[i] != a[i]

- For positions where I choose uppercase:

  - a[i] != c[i] and b[i] != c[i]

And, for the template t to exist, all these choices must be consistent across all positions.

But actually, since the choices are independent for each position, I just need to check for each position whether at least one of these two conditions can be satisfied.

Wait, but I need to ensure that there exists at least one position where c does not match t, meaning that c violates the template condition at that position.

But in the above, for c to not match t, there must be at least one position where:

- If t[i] is lowercase, c[i] != t[i]

- If t[i] is uppercase, c[i] == lowercase(t[i])

So, in other words, for c to not match t, there must be at least one position where one of the above holds.

But since I am choosing t to make a and b match, and c not match, I need to ensure that c does not match t, which requires that there is at least one position where c violates the template condition.

However, in my earlier approach, I am ensuring that for each position, if I choose t[i] to be lowercase, then c[i] != t[i], and if I choose t[i] to be uppercase, then c[i] == lowercase(t[i]).

Wait, no. Actually, for c to not match t, there must be at least one position where c violates the template condition.

But in the way I'm choosing t, I need to make sure that for a and b, they match t at all positions, and for c, there is at least one position where it violates the template condition.

Given that, perhaps I can choose t[i] in such a way that for a and b, they match t at all positions, and for c, there is at least one position where it does not match t.

So, perhaps I can choose t[i] to be lowercase when a[i] == b[i] and c[i] != a[i], and choose t[i] to be uppercase when a[i] != c[i] and b[i] != c[i].

But I need to ensure that in the template t, there is at least one position where c violates the template condition.

Wait, but if I choose t[i] to be uppercase, then for c, c[i] == lowercase(t[i]), which means c matches the template at that position, which is the opposite of what I want.

Wait, no. If t[i] is uppercase, then for c to not match t, c[i] must equal lowercase(t[i]), which means c matches the template at that position, but according to the problem, c should not match t, meaning that there must be at least one position where c violates the template condition.

Wait, I'm getting confused here.

Let me recall:

- For t[i] uppercase, the condition for c is that c[i] == lowercase(t[i]), which means c matches the template at that position.

- But for c to not match t, there must be at least one position where c violates the template condition.

Therefore, if I choose t[i] to be uppercase, then c matches at that position, which is not what I want. I need c to violate the template condition at least at one position.

So, perhaps I should choose t[i] to be lowercase at some positions to ensure that c violates the template condition there.

Wait, no. If I choose t[i] to be lowercase, then for c to violate the template condition, c[i] != t[i].

So, if I choose t[i] to be lowercase and set t[i] = a[i] (since a and b must match t, so a[i] == b[i] == t[i]), then c[i] != a[i], which satisfies the condition for c not matching t at that position.

Alternatively, if I choose t[i] to be uppercase, then t[i] = c[i].upper(), and a[i] != c[i], b[i] != c[i].

But in this case, c[i] == lowercase(t[i]), which means c matches the template at that position.

Wait, but I need c to not match t, meaning that there is at least one position where c violates the template condition.

So, perhaps I can choose some positions to be lowercase to ensure c violates the template there, and other positions to be uppercase as needed.

But actually, I need to make sure that c violates the template condition in at least one position, while a and b match the template in all positions.

So, perhaps the strategy is:

- For positions where a[i] == b[i] and c[i] != a[i], choose t[i] to be lowercase. This ensures that a and b match t, and c does not match t at that position.

- For positions where a[i] != b[i], it's impossible to choose t[i] to be lowercase because a[i] == b[i] is required for lowercase t[i]. So, in this case, I need to choose t[i] to be uppercase, with t[i] = c[i].upper(), provided that a[i] != c[i] and b[i] != c[i].

- If there are positions where a[i] != b[i], but a[i] == c[i] or b[i] == c[i], then I cannot choose t[i] to be uppercase, because for uppercase t[i], a[i] != c[i] and b[i] != c[i] must hold.

Therefore, in such cases, it's impossible to choose t[i] in a way that satisfies all conditions.

So, to summarize, the conditions for each position i are:

- If a[i] == b[i] and c[i] != a[i], then I can choose t[i] to be lowercase.

- If a[i] != b[i], then:

  - If a[i] != c[i] and b[i] != c[i], then I can choose t[i] to be uppercase.

  - Else, it's impossible to choose t[i] in a way that satisfies the conditions.

Moreover, I need to ensure that there is at least one position where c violates the template condition.

If I choose t[i] to be lowercase for some position where a[i] == b[i] and c[i] != a[i], then c violates the template condition at that position.

Alternatively, if I choose t[i] to be uppercase for some position where a[i] != c[i] and b[i] != c[i], then c matches the template at that position, which doesn't help in making c not match t.

Therefore, to ensure that c does not match t, I need at least one position where t[i] is lowercase and c[i] != t[i], or t[i] is uppercase and c[i] == lowercase(t[i]), but the latter means c matches the template, which is not what I want.

Wait, no. If t[i] is uppercase, and c[i] == lowercase(t[i]), then c matches the template at that position. But for c to not match t, there must be at least one position where c violates the template condition.

Therefore, to ensure c does not match t, I need at least one position where:

- If t[i] is lowercase, then c[i] != t[i]

- If t[i] is uppercase, then c[i] != lowercase(t[i])

Wait, no. For c to not match t, there must be at least one position where:

- If t[i] is lowercase, then c[i] != t[i]

- If t[i] is uppercase, then c[i] == lowercase(t[i])

Wait, I'm getting confused again.

Let me look back at the problem statement.

"The string s matches the template t if the following conditions hold for all i from 1 to n:

- if the i-th letter of the template is lowercase, then s_i must be the same as t_i;

- if the i-th letter of the template is uppercase, then s_i must be different from the lowercase version of t_i."

"Accordingly, the string doesn't match the template if the condition doesn't hold for at least one i."

So, for c to not match t, there must be at least one position i where:

- If t[i] is lowercase, then c[i] != t[i]

- If t[i] is uppercase, then c[i] == lowercase(t[i])

In other words, c violates the template condition at that position.

Therefore, to ensure that c does not match t, I need to have at least one position where:

- Either (t[i] is lowercase and c[i] != t[i]) or (t[i] is uppercase and c[i] == lowercase(t[i]))

But in my earlier approach, when I choose t[i] to be lowercase where a[i] == b[i] and c[i] != a[i], I ensure that c violates the template condition at that position.

When I choose t[i] to be uppercase where a[i] != c[i] and b[i] != c[i], c matches the template at that position.

Therefore, if I have at least one position where t[i] is lowercase and c[i] != t[i], then c does not match t.

So, my strategy should be:

- For positions where a[i] == b[i] and c[i] != a[i], choose t[i] to be lowercase. This ensures that a and b match t, and c does not match t at that position.

- For positions where a[i] != b[i], it's impossible to choose t[i] to be lowercase, so I must choose t[i] to be uppercase, provided that a[i] != c[i] and b[i] != c[i].

- Additionally, I need to ensure that there is at least one position where c violates the template condition. If I have at least one position where t[i] is lowercase and c[i] != t[i], that's sufficient.

Therefore, in the code, I need to iterate through each position and check these conditions.

If for all positions where a[i] == b[i] and c[i] != a[i], I can choose t[i] to be lowercase, and for positions where a[i] != b[i], I can choose t[i] to be uppercase only if a[i] != c[i] and b[i] != c[i], then it's possible.

Moreover, among all positions, at least one position must be chosen as lowercase where a[i] == b[i] and c[i] != a[i], to ensure that c violates the template condition.

Wait, no. Actually, to ensure that c does not match t, I need at least one position where c violates the template condition, which can be either:

- A position where t[i] is lowercase and c[i] != t[i]

- Or a position where t[i] is uppercase and c[i] == lowercase(t[i])

But in the uppercase case, c matches the template at that position, so it's only the lowercase positions where c[i] != t[i] that cause c to violate the template condition.

Therefore, to ensure that c does not match t, I need at least one position where t[i] is lowercase and c[i] != t[i].

So, in my earlier approach, choosing t[i] to be lowercase for positions where a[i] == b[i] and c[i] != a[i] ensures that c violates the template condition at those positions.

Additionally, for positions where a[i] != b[i], I must choose t[i] to be uppercase, provided that a[i] != c[i] and b[i] != c[i].

If there exists any position where a[i] != b[i] and (a[i] == c[i] or b[i] == c[i]), then it's impossible to choose t[i] in a way that satisfies the conditions.

Therefore, my plan is:

- For each position i:

  - If a[i] == b[i] and c[i] != a[i], mark this position as possible for t[i] being lowercase.

  - If a[i] != b[i], check if a[i] != c[i] and b[i] != c[i]. If so, mark this position as must be uppercase.

  - If a[i] != b[i] and (a[i] == c[i] or b[i] == c[i]), then it's impossible to choose t[i], so output "NO" for this test case.

- Additionally, ensure that there is at least one position where t[i] is lowercase and c[i] != t[i]. This is already satisfied if there is at least one position where a[i] == b[i] and c[i] != a[i].

Therefore, in the code, I need to:

- Iterate through each position i.

- If a[i] != b[i]:

  - If a[i] != c[i] and b[i] != c[i], then set t[i] to be uppercase.

  - Else, output "NO" for this test case.

- If a[i] == b[i] and c[i] != a[i], then set t[i] to be lowercase.

- If a[i] == b[i] and c[i] == a[i], then it's impossible to choose t[i] to make c not match t, so output "NO" for this test case.

- Finally, check if there is at least one position where t[i] is lowercase and c[i] != t[i]. If yes, then output "YES"; else, "NO".

Wait, no. Actually, if a[i] == b[i] and c[i] == a[i], then it's impossible to choose t[i] to make c not match t, because:

- If t[i] is lowercase, then t[i] = a[i], but c[i] == a[i], so c matches the template at that position.

- If t[i] is uppercase, then t[i] = c[i].upper(), but c[i] == a[i], so c matches the template at that position.

Therefore, in such a case, it's impossible to make c not match t, so output "NO".

Otherwise, if for all positions where a[i] == b[i], c[i] != a[i], then I can choose t[i] to be lowercase at those positions, ensuring that c violates the template condition at those positions.

If there are positions where a[i] != b[i], I must have a[i] != c[i] and b[i] != c[i] to choose t[i] as uppercase.

Finally, I need to ensure that there is at least one position where c violates the template condition, which is already satisfied if there is at least one position where a[i] == b[i] and c[i] != a[i].

Therefore, in the code, I can:

- For each position i:

  - If a[i] == b[i]:

    - If c[i] == a[i], output "NO"

    - Else, set t[i] to be lowercase.

  - Else (a[i] != b[i]):

    - If a[i] != c[i] and b[i] != c[i], set t[i] to be uppercase.

    - Else, output "NO"

- If there exists at least one position where t[i] is lowercase and c[i] != t[i], output "YES"

- Else, output "NO"

Wait, but if all positions where a[i] == b[i] have c[i] != a[i], then I can set t[i] to be lowercase there, ensuring that c violates the template condition at those positions, so output "YES".

If there are positions where a[i] != b[i], I must have a[i] != c[i] and b[i] != c[i] to set t[i] to uppercase.

If all positions are such that a[i] == b[i] and c[i] != a[i], then I can set all t[i] to lowercase, and c violates the template condition at all positions, which satisfies the requirement.

If there are positions where a[i] != b[i], then I must have a[i] != c[i] and b[i] != c[i] to set t[i] to uppercase.

If there exists any position where a[i] != b[i] and (a[i] == c[i] or b[i] == c[i]), then it's impossible, output "NO".

Otherwise, output "YES".

Wait, but I need to ensure that c does not match t, meaning that there is at least one position where c violates the template condition.

If I have positions where t[i] is lowercase and c[i] != t[i], that's sufficient.

So, in the case where a[i] == b[i] and c[i] != a[i], setting t[i] to lowercase ensures that c violates the template condition at that position.

Therefore, as long as there exists at least one position where a[i] == b[i] and c[i] != a[i], or positions where a[i] != b[i] and a[i] != c[i] and b[i] != c[i], I can construct such a template t.

Wait, no. Actually, positions where a[i] != b[i] require that a[i] != c[i] and b[i] != c[i] to set t[i] to uppercase.

But at these positions, c matches the template because c[i] == lowercase(t[i]).

So, to ensure that c does not match t, I need at least one position where t[i] is lowercase and c[i] != t[i].

Positions where t[i] is uppercase and c[i] == lowercase(t[i]) do not violate the template condition for c, they satisfy it.

Therefore, to ensure that c does not match t, I need at least one position where t[i] is lowercase and c[i] != t[i].

So, in the code, I can:

- Iterate through all positions i.

- If a[i] == b[i]:

  - If c[i] == a[i], output "NO"

  - Else, mark this position as possible for t[i] being lowercase.

- Else (a[i] != b[i]):

  - If a[i] != c[i] and b[i] != c[i], set t[i] to be uppercase.

  - Else, output "NO"

- After checking all positions, if there is at least one position where a[i] == b[i] and c[i] != a[i], output "YES"

- Else, output "NO"

Wait, but if all positions are such that a[i] != b[i] and a[i] != c[i] and b[i] != c[i], then I can set all t[i] to uppercase, but in this case, c matches the template at all positions, which means c matches t, which is not what I want.

Wait, no. For c to not match t, there must be at least one position where c violates the template condition.

If all t[i] are uppercase, then for c to not match t, there must be at least one position where c[i] == lowercase(t[i]), which is the same as t[i] being uppercase and c[i] == lowercase(t[i]).

Wait, no. If all t[i] are uppercase, then c matches the template at all positions where c[i] == lowercase(t[i]), and violates at positions where c[i] != lowercase(t[i]).

But in this case, since t[i] is uppercase, c must have c[i] == lowercase(t[i]) to match, so if c[i] == lowercase(t[i]) at all positions, then c matches t.

But I need c to not match t, which requires that there is at least one position where c[i] != lowercase(t[i]).

Wait, no. If t[i] is uppercase, then for c to match t, c[i] must be equal to lowercase(t[i]).

Therefore, if all t[i] are uppercase and c[i] == lowercase(t[i]) at all positions, then c matches t.

To make c not match t, there must be at least one position where c[i] != lowercase(t[i]).

But if I set all t[i] to uppercase with t[i] = some value such that a[i] != lowercase(t[i]) and b[i] != lowercase(t[i]), but c[i] == lowercase(t[i]), then c matches t at all positions, which is not what I want.

Wait, but according to the problem, I need c to not match t, meaning that there is at least one position where c violates the template condition.

So, if I set all t[i] to uppercase with t[i] = c[i].upper(), then c[i] == lowercase(t[i]) at all positions, meaning c matches t at all positions, which contradicts the requirement that c does not match t.

Therefore, it's impossible to have all t[i] as uppercase and satisfy that c does not match t.

Hence, I must have at least one position where t[i] is lowercase and c[i] != t[i].

Therefore, in the code, I need to ensure that there exists at least one position where a[i] == b[i] and c[i] != a[i], so that I can set t[i] to be lowercase, ensuring that c violates the template condition at that position.

If there is no such position, then it's impossible to make c not match t, so output "NO".

Therefore, the simplified condition is:

- For each position i:

  - If a[i] == b[i] and c[i] != a[i], mark this position as suitable for t[i] being lowercase.

  - If a[i] != b[i]:

    - If a[i] != c[i] and b[i] != c[i], set t[i] to be uppercase.

    - Else, output "NO"

- If there exists at least one position where a[i] == b[i] and c[i] != a[i], output "YES"

- Else, output "NO"

This seems to be a correct approach.

Now, looking at the given code:

def func():

    t = int(input())

    l = 'YES'

    for i in range(t):

        n = int(input())

        a = input()

        b = input()

        c = input()

        for i in range(n):

            if a[i] != c[i] and b[i] != c[i]:

                l = 'YES'

        else:

            l = 'NO'

        print(l)

This code seems too simplistic. It iterates through each character position and checks if a[i] != c[i] and b[i] != c[i]. If this condition holds for any position, it sets l to 'YES'; otherwise, it sets l to 'NO'.

But according to my earlier reasoning, this is not sufficient.

The code is checking if there exists at least one position where both a[i] != c[i] and b[i] != c[i]. If such a position exists, it sets l to 'YES'; otherwise, 'NO'.

However, from my earlier analysis, this is not enough because:

- I need to ensure that there exists at least one position where a[i] == b[i] and c[i] != a[i], or handle positions where a[i] != b[i] appropriately.

- The code doesn't account for the necessity of having positions where a[i] == b[i] and c[i] != a[i].

- Additionally, the code doesn't handle the case where a[i] != b[i] but a[i] != c[i] and b[i] != c[i].

Therefore, the given code is incorrect because it doesn't capture the full logic required to determine if such a template t exists.

Hence, Correctness: **False**

**Final Solution**

To solve this problem, we need to determine if there exists a template string `t` such that strings `a` and `b` match the template, while string `c` does not match it. 

## Approach

1. **Understanding Matching Rules**:
    - If `t[i]` is lowercase, `s[i]` must be equal to `t[i]`.
    - If `t[i]` is uppercase, `s[i]` must be different from the lowercase version of `t[i]`.

2. **Conditions for Template `t`**:
    - For positions where `a[i] == b[i]` and `c[i] != a[i]`, set `t[i]` to be lowercase.
    - For positions where `a[i] != b[i]`, ensure `a[i] != c[i]` and `b[i] != c[i]` to set `t[i]` to uppercase.
    - If any position has `a[i] != b[i]` but `a[i] == c[i]` or `b[i] == c[i]`, it's impossible to create such a template.
    - Ensure there is at least one position where `t[i]` is lowercase and `c[i] != t[i]` to make sure `c` does not match the template.

3. **Algorithm**:
    - For each test case:
        - Read `n`, `a`, `b`, and `c`.
        - Check each position:
            - If `a[i] == b[i]` and `c[i] != a[i]`, mark this position as suitable for lowercase `t[i]`.
            - If `a[i] != b[i]`:
                - Ensure `a[i] != c[i]` and `b[i] != c[i]` to set `t[i]` to uppercase.
                - If not, output "NO".
        - If there exists at least one position where `a[i] == b[i]` and `c[i] != a[i]`, output "YES".
        - Otherwise, output "NO".

## Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        a = data[idx]
        idx += 1
        b = data[idx]
        idx += 1
        c = data[idx]
        idx += 1
        has_lowercase_mismatch = False
        possible = True
        for i in range(n):
            if a[i] == b[i]:
                if c[i] != a[i]:
                    has_lowercase_mismatch = True
                else:
                    possible = False
                    break
            else:
                if a[i] != c[i] and b[i] != c[i]:
                    continue
                else:
                    possible = False
                    break
        if possible and has_lowercase_mismatch:
            print("YES")
        else:
            print("NO")

if __name__ == "__main__":
    main()
```

## Explanation

- **Reading Input**: Read all input data at once and split into lines for easier access.
- **Processing Each Test Case**:
  - Read `n`, the length of strings.
  - Read strings `a`, `b`, and `c`.
  - For each position `i` from `0` to `n-1`:
    - If `a[i] == b[i]` and `c[i] != a[i]`, set `has_lowercase_mismatch` to `True`.
    - If `a[i] == b[i]` and `c[i] == a[i]`, set `possible` to `False`.
    - If `a[i] != b[i]`:
      - Ensure `a[i] != c[i]` and `b[i] != c[i]`; otherwise, set `possible` to `False`.
- **Output Result**:
  - If `possible` is `True` and `has_lowercase_mismatch` is `True`, print "YES".
  - Otherwise, print "NO".