Alright, I have this problem to solve. Let's read it carefully.

We have a problem with difficulty x, and we need to break it into n sub-problems, each with a positive integer difficulty. The sum of these sub-problems' difficulties should equal x. Now, the balance of the problemset is defined as the GCD (Greatest Common Divisor) of all the sub-problems' difficulties. I need to maximize this balance.

First, I need to understand what GCD is. GCD of a set of numbers is the largest number that divides all of them without leaving a remainder. So, if all sub-problems have difficulties that are multiples of some number d, then d is a possible balance. And I need to make d as large as possible.

Given that, I need to choose n positive integers whose sum is x and whose GCD is as large as possible.

Let me think about the constraints:

- x can be up to 10^8, which is 100 million.

- n can be up to x, which means up to 100 million in the worst case.

But in practical terms, n is up to x, but x is up to 10^8, so n can be up to 10^8.

But in the example, n is up to 5, so maybe n is small in some cases.

But I need to consider the worst case.

Wait, in the problem statement, it says "1 ≤ n ≤ x", so n can be up to x, which is up to 10^8.

But handling n up to 10^8 might be tricky in terms of time constraints.

But let's see.

I need to maximize the GCD of n numbers that sum up to x.

Let me consider what the GCD represents.

If the GCD is d, then each of the n sub-problems must be a multiple of d.

So, if I denote the sub-problems as a1, a2, ..., an, then:

a1 = d * k1

a2 = d * k2

...

an = d * kn

And their sum is x:

d*(k1 + k2 + ... + kn) = x

So, d must be a divisor of x.

Moreover, since all ai are positive integers, ki are also positive integers, meaning that each ki >=1.

Therefore, the sum k1 + k2 + ... + kn >= n.

Because each ki >=1.

So, k1 + k2 + ... + kn >= n.

But we have d*(k1 + k2 + ... + kn) = x.

Therefore, d * (something >= n) = x.

So, d <= x / n.

Because d <= x / n.

But d must be an integer, so d <= floor(x / n).

But d also has to be a divisor of x.

So, to maximize d, I need to find the largest divisor of x that is less than or equal to floor(x / n).

In other words, find the largest d such that:

- d divides x (x % d == 0)

- d <= floor(x / n)

So, the approach is:

- Find all divisors of x.

- Find the largest divisor d such that d <= floor(x / n).

That should be the answer.

Let me verify this with the examples.

First example:

x = 10, n = 3

Divisors of 10: 1, 2, 5, 10

Floor(x / n) = floor(10 / 3) = 3

So, find the largest d <= 3 that divides 10.

Possible d: 1, 2

Largest is 2.

Which matches the example.

Second example:

x = 5, n = 5

Divisors of 5: 1, 5

Floor(x / n) = floor(5 / 5) = 1

So, find d <=1 that divides 5.

Only d=1.

Which matches the example.

Third example:

x=420, n=69

Divisors of 420: 1, 2, 3, 4, 5, 6, 7, 10, 12, 14, 15, 20, 21, 28, 30, 35, 42, 60, 70, 84, 105, 140, 210, 420

Floor(x / n) = floor(420 / 69) = floor(6.087) = 6

So, find the largest d <=6 that divides 420.

Possible d: 1,2,3,4,5,6

Largest is 6.

Which matches the example.

So, this approach seems correct.

Now, to implement this efficiently, especially since x can be up to 10^8 and t can be up to 10^3, I need an efficient way to find all divisors of x up to floor(x/n).

A naive way would be to iterate from 1 to sqrt(x), find divisors, and then select the largest d <= floor(x/n).

But since x is up to 10^8, and t is up to 10^3, I need an efficient way.

Let's think about how to find all divisors of x efficiently.

I can iterate from 1 to sqrt(x), for each i, if i divides x, then both i and x/i are divisors.

Then, among these divisors, I need to find the largest d such that d <= floor(x/n).

So, for each test case, I can:

- Compute floor(x/n)

- Find all divisors of x

- Among those divisors, find the largest one that is <= floor(x/n)

- Output that d

Now, to optimize, since for each x, finding its divisors takes O(sqrt(x)) time, and with t=10^3 and x=10^8, total time would be around 10^3 * 10^4 = 10^7 operations, which should be acceptable.

But I need to make sure that it's optimized.

Let's see the given program and see if it does this correctly.

Looking at the code:

from math import *

tc = int(input())

for _ in range(tc):

func_1()

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

print(ans)

So, it reads t test cases, and for each, calls func_1().

In func_1(), it reads x and n, initializes ans to 0.

Then, it loops from i=1 to sqrt(x) (using isqrt(x)), inclusive.

For each i, if i divides x (x % i == 0), then:

- If n <= x // i, set ans to max(ans, i)

- If n <= i, set ans to max(ans, x // i)

Then, print ans.

Wait, is this correctly implementing what we discussed?

Let me verify.

We need to find the largest d <= floor(x/n), where d divides x.

But in the code:

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

Is this finding the largest d <= floor(x/n)?

Wait, floor(x/n) is floor(x divided by n), which is x//n in integer division.

So, floor(x/n) = x // n

So, we need d <= x // n, and d divides x.

In the code, for each i from 1 to sqrt(x):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

Wait, is this correctly finding the largest d <= x//n that divides x?

Let me think.

For each i where i divides x, it checks:

- If n <= x // i, then ans = max(ans, i)

- If n <= i, then ans = max(ans, x // i)

Wait, in our earlier reasoning, we decided that d <= x//n, and d divides x.

So, among all divisors d of x, find the largest d <= x//n.

But in this code, it's not directly selecting d <= x//n.

Wait, let's see.

For each i where i divides x:

- If n <= x // i, set ans = max(ans, i)

- If n <= i, set ans = max(ans, x // i)

Wait, perhaps the logic is:

- For each divisor i:

- Consider d = i

- Check if n <= x // d, which is n <= x // i

- If yes, then d is a candidate, set ans = max(ans, d)

Similarly, since x // i is also a divisor:

- Consider d = x // i

- Check if n <= d, which is n <= x // i

- If yes, set ans = max(ans, d)

Wait, this seems a bit convoluted.

Let me try to rephrase.

For each i where i divides x:

- Consider d = i

- Check if n <= x // d, which is n <= x // i

- If yes, set ans = max(ans, d)

- Also, consider d = x // i

- Check if n <= d, which is n <= x // i

- If yes, set ans = max(ans, d)

Wait, but in code, it's:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

Hmm, there might be a mistake here.

Wait, let's think differently.

We need d <= x // n.

But in the code, it's checking n <= x // i.

Wait, n <= x // i is equivalent to n <= x / i, which is i <= x / n.

Wait, x // i <= x / i, since it's floor division.

Wait, but n <= x // i implies n <= floor(x / i).

But I'm getting confused.

Let me think differently.

We need d <= floor(x / n).

In the code, for each divisor i:

- If n <= x // i, set ans = max(ans, i)

- If n <= i, set ans = max(ans, x // i)

Wait, perhaps the intention is to consider both i and x//i as possible d values, and select the one that satisfies d <= floor(x / n).

But I'm not sure if this logic correctly captures that.

Let me try with the first example:

x=10, n=3

floor(x / n) = 3

Divisors:

i=1, x//1=10

Check n=3 <= x//1=10, set ans=max(0,1)=1

Also, n=3 <= i=1? No

So ans=1

i=2, x//2=5

n=3 <= x//2=5, set ans=max(1,2)=2

n=3 <= i=2? No

i=3, x//3=3

n=3 <= x//3=3, set ans=max(2,3)=3

n=3 <= i=3, set ans=max(3, x//3=3)=3

i=4, x//4=2

n=3 <= x//4=2? 3 <=2? No

i=5, x//5=2

n=3 <=2? No

So, ans=3, but in the example, it's 2.

Wait, but in the example, it's 2, but according to this, it's 3.

But according to our earlier reasoning, d should be <= floor(x/n)=3, and d should divide x=10.

Divisors of 10 are 1,2,5,10.

Among them, d <=3 are 1,2.

So, the answer should be 2, not 3.

Wait, but according to the code, it would set ans=3.

But 3 does not divide 10, since 10 % 3 !=0.

Wait, but in the code, it only checks if i divides x, which is correct.

Wait, but in this case, i=3 divides x=10? 10 % 3 ==1, which is not zero.

Wait, but in the code, it checks if x % i ==0 before considering it.

So, for i=3, x % 3 ==1 !=0, so it shouldn't consider i=3.

Wait, but in my earlier step-by-step, I said:

i=3, x//3=3

n=3 <= x//3=3, set ans=max(2,3)=3

But wait, before that, it checks if x % i ==0.

Wait, x=10, i=3, 10 % 3 ==1 !=0, so it shouldn't consider i=3 at all.

Wait, perhaps I missed the condition x % i ==0.

Let me correct that.

For i=1:

x %1 ==0, n=3 <= x//1=10, set ans=max(0,1)=1

n=3 <=i=1? No

i=2:

x%2==0, n=3 <= x//2=5, set ans=max(1,2)=2

n=3 <=i=2? No

i=3:

x%3==1 !=0, skip

i=4:

x%4==2 !=0, skip

i=5:

x%5==0, n=3 <= x//5=2? 3 <=2? No

So, ans=2, which matches the example.

Wait, but earlier I thought it would set ans=3, but actually, i=3 is skipped because x%3 !=0.

So, in this case, it correctly sets ans=2.

Another example:

x=5, n=5

floor(x/n)=1

Divisors:

i=1, x//1=5

n=5 <=5, set ans=max(0,1)=1

n=5 <=i=1? No

i=5, x//5=1

n=5 <=1? No

So, ans=1, which matches the example.

Third example:

x=420, n=69

floor(x/n)=floor(420/69)=6

Divisors:

i from 1 to sqrt(420)=20.49, so i from 1 to 20

i=1: x%1==0, n=69 <=420, set ans=1

n=69 <=1? No

i=2: x%2==0, n=69 <=210, set ans=2

n=69 <=2? No

i=3: x%3==0, n=69 <=140, set ans=3

n=69 <=3? No

i=4: x%4==0, n=69 <=105, set ans=4

n=69 <=4? No

i=5: x%5==0, n=69 <=84, set ans=5

n=69 <=5? No

i=6: x%6==0, n=69 <=70, set ans=6

n=69 <=6? No

i=7: x%7==0, n=69 <=60, set ans=7

n=69 <=7? No

i=10: x%10==0, n=69 <=42, set ans=10

n=69 <=10? No

i=12: x%12==0, n=69 <=35, set ans=12

n=69 <=12? No

i=14: x%14==0, n=69 <=30, set ans=14

n=69 <=14? No

i=15: x%15==0, n=69 <=28, set ans=15

n=69 <=15? No

i=20: x%20==0, n=69 <=21, set ans=20

n=69 <=20? No

So, ans=20

But according to the example, it should be 6.

Wait, but 20 > floor(x/n)=6, so why is it accepting 20?

Wait, perhaps there's a mistake in the code.

Wait, in the code, it sets ans = max(ans, i) if n <= x//i

But in this case, x=420, n=69, x//i for i=20: x//20=21, n=69 <=21? 69 <=21? No.

Wait, 69 <=21 is False, so it doesn't set ans=20.

Wait, x//20=21, n=69 <=21? 69 <=21? False.

So, it doesn't set ans=20.

Wait, but in my earlier step, I thought it would set ans=20, but actually, n=69 <= x//20=21 is False, so it doesn't set ans=20.

So, in this case, it would set ans=12, because for i=12, x//12=35, n=69 <=35? 69 <=35? No.

Wait, no, for i=12, x//12=35, n=69 <=35? 69 <=35? No.

So, it doesn't set ans=12.

Wait, then what is the ans?

Let's list all i where x%i==0 and n <= x//i.

i=1: x//1=420, n=69 <=420, set ans=1

i=2: x//2=210, n=69 <=210, set ans=2

i=3: x//3=140, n=69 <=140, set ans=3

i=4: x//4=105, n=69 <=105, set ans=4

i=5: x//5=84, n=69 <=84, set ans=5

i=6: x//6=70, n=69 <=70, set ans=6

i=7: x//7=60, n=69 <=60? No

i=10: x//10=42, n=69 <=42? No

i=12: x//12=35, n=69 <=35? No

i=14: x//14=30, n=69 <=30? No

i=15: x//15=28, n=69 <=28? No

i=20: x//20=21, n=69 <=21? No

i=21: x//21=20, n=69 <=20? No

i=28: x//28=15, n=69 <=15? No

i=30: x//30=14, n=69 <=14? No

i=35: x//35=12, n=69 <=12? No

i=42: x//42=10, n=69 <=10? No

i=60: x//60=7, n=69 <=7? No

i=70: x//70=6, n=69 <=6? No

i=84: x//84=5, n=69 <=5? No

i=105: x//105=4, n=69 <=4? No

i=140: x//140=3, n=69 <=3? No

i=210: x//210=2, n=69 <=2? No

i=420: x//420=1, n=69 <=1? No

So, the maximum ans is 6, which matches the example.

Wait, but earlier I thought it would set ans=20, but actually, it doesn't because n=69 <= x//20=21 is False.

So, in this case, ans=6, which is correct.

So, perhaps the code is correct.

Wait, but in the first example, with x=10 and n=3, it correctly sets ans=2.

In the second example, x=5 and n=5, ans=1.

In the third example, x=420 and n=69, ans=6.

So, it seems correct.

But earlier, I thought it set ans=3 for x=10 and n=3, but actually, since x%3 !=0, it skips i=3.

Wait, but x=10, i=3, 10%3=1 !=0, so it skips i=3.

So, ans=2, which is correct.

Hence, the code seems correct.

But to be thorough, let's consider another test case.

Suppose x=9, n=2.

floor(x/n)=4.

Divisors of 9:1,3,9

Possible d <=4 are 1 and 3.

So, ans should be 3.

According to the code:

i=1: x%1==0, n=2 <=9, set ans=1

i=3: x%3==0, n=2 <=3, set ans=3

i=9: x%9==0, n=2 <=1? No

So, ans=3, which is correct.

Another test case:

x=7, n=1

floor(x/n)=7

Divisors of 7:1,7

d <=7:1,7

So, ans=7

According to the code:

i=1: x%1==0, n=1 <=7, set ans=1

i=7: x%7==0, n=1 <=7, set ans=7

So, ans=7, correct.

Another test case:

x=1, n=1

floor(x/n)=1

Divisors of 1:1

d <=1:1

ans=1, which is correct.

Edge case:

x=1, n=1, ans=1

x=