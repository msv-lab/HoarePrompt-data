Alright, I've got this problem to solve. Let's see what it's asking for.

So, Jay created a problem of difficulty x and wants to make it the second problem for Codeforces Round #921. But Yash is worried that this might make the contest unbalanced, so he decides to break this problem into n sub-problems. Each sub-problem should have a positive integer difficulty, and the sum of all these sub-problems should equal x.

Now, the coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems. Yash wants to maximize this balance.

My task is to find the maximum balance Yash can achieve by optimally choosing the difficulties of the sub-problems.

First, I need to understand what GCD is. GCD of a set of numbers is the largest number that divides all of them without leaving a remainder.

So, if Yash breaks down the problem into n sub-problems with difficulties a1, a2, ..., an, such that a1 + a2 + ... + an = x, I need to maximize the GCD of a1, a2, ..., an.

I need to think about how to maximize this GCD.

Let me consider an example to get a better understanding.

Take the first example from the problem:

x = 10, n = 3

One possible way is to have sub-problems with difficulties 4, 2, and 4. The GCD of these is 2.

Is there a way to get a higher GCD? Let's see.

If I choose 3, 3, and 4, the GCD is 1.

Or 2, 2, and 6, GCD is 2.

Or 5, 2, and 3, GCD is 1.

Seems like 2 is the maximum achievable GCD for this case.

Another example:

x = 5, n = 5

Only possible way is to have all sub-problems with difficulty 1, so GCD is 1.

Third example:

x = 420, n = 69

The answer is 6.

I need to find a general approach to calculate this for any given x and n.

Let me think about the properties of GCD.

If all ai are multiples of some number d, then d divides x because x is the sum of ai.

So, d must be a divisor of x.

Moreover, since there are n sub-problems, and each ai >=1, then x >= n.

Wait, no, in the second example, x=5 and n=5, which is fine, because each ai=1.

But in the first example, x=10 and n=3, which satisfies 10 >= 3.

Wait, actually, in the problem constraints, it says 1 <= x <= 1e8 and 1 <= n <= x, so n can be up to x.

So, for any n <= x, there exists a way to break x into n positive integers.

Now, to maximize the GCD, I need to find the largest d such that d divides x and it's possible to have n integers, each divisible by d, summing up to x.

Since each ai must be at least 1, and they must sum to x, and each ai is a multiple of d, then the smallest possible sum is n*d.

So, n*d <= x, because each ai >= d.

Therefore, d <= x / n.

So, d must be less than or equal to floor(x / n).

But d also must divide x.

So, the largest possible d is the largest divisor of x that is less than or equal to floor(x / n).

So, to find the maximum d, I need to find the largest divisor of x that is <= floor(x / n).

So, the approach is:

1. For a given x and n, compute floor(x / n).

2. Find all divisors of x that are <= floor(x / n).

3. Choose the largest among them.

That should be the maximum balance achievable.

Let me verify this with the examples.

First example:

x=10, n=3

floor(10/3)=3

Divisors of 10 are 1,2,5,10

Divisors <=3 are 1,2

Largest is 2, which matches the sample output.

Second example:

x=5, n=5

floor(5/5)=1

Divisors of 5 are 1,5

Divisors <=1 are only 1

So, the answer is 1, which matches the sample.

Third example:

x=420, n=69

floor(420/69)=6 (since 69*6=414, 420-414=6, so floor(420/69)=6)

Divisors of 420 <=6 are 1,2,3,4,5,6

Largest is 6, which matches the sample.

Perfect, this seems correct.

So, the algorithm is:

- For each test case, read x and n.

- Compute floor(x / n).

- Find all divisors of x that are <= floor(x / n).

- Choose the largest among them.

Now, to implement this efficiently, especially since x can be up to 1e8 and t can be up to 1e3, I need an efficient way to find the divisors of x up to floor(x / n).

Finding all divisors of a number up to a certain limit can be done by iterating up to the square root of x and collecting divisors.

Let me think about how to implement this efficiently.

I can write a function to find all divisors of x up to a given limit.

Here's how I can do it:

- Initialize an empty list to store the divisors.

- Iterate from 1 to sqrt(x).

- For each i, if i divides x, add i to the list if i <= limit.

- Also, add x/i to the list if x/i <= limit and x/i != i.

- Then, among these divisors, select the largest one.

This should work efficiently since iterating up to sqrt(x) is acceptable for x up to 1e8, as sqrt(1e8) is 1e4, which is manageable.

Let me see the given program and see if it matches this logic.

The given program is:

from math import *

tc = int(input())

for _ in range(tc):

func_1()

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

print(ans)

So, it defines a function func_1() that reads x and n, then iterates from 1 to sqrt(x), checks if i is a divisor, and if n <= x//i, it updates ans with i, and if n <= i, it updates ans with x//i.

Wait, this seems a bit confusing.

Let me re-express the condition.

In the code:

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

Wait, n <= x//i implies that x//i is >= n, but x//i is floor(x/i), which is the maximum possible value for the sum of n divisors.

Wait, I think there's a confusion here.

Let me think differently.

I need d to be a divisor of x, and d <= floor(x/n).

So, in the loop, for each i from 1 to sqrt(x):

- If i divides x:

- If i <= floor(x/n), consider i.

- If x/i <= floor(x/n), consider x/i.

Wait, but in the code, it's checking if n <= x//i and n <= i, which seems inverted.

Wait, perhaps it's a mistake.

Let me calculate floor(x/n) and find the largest divisor of x that is <= floor(x/n).

So, I need to collect all divisors <= floor(x/n) and take the maximum.

In the code, it seems to be trying to do this, but the conditions are not clear to me.

Let me take an example to see if it works.

Take x=10, n=3

floor(x/n)=3

Divisors of 10 are 1,2,5,10

Divisors <=3 are 1,2

So, the answer should be 2.

In the code:

for i in range(1, isqrt(10)+1)=1 to 3:

i=1:

x%1==0 -> n=3 <= x//i=10//1=10 -> ans=max(0,1)=1

n=3 <=i=1? No.

i=2:

x%2==0 -> n=3 <= x//2=5 -> ans=max(1,2)=2

n=3 <=2? No.

i=3:

x%3 !=0 -> skip

So, ans=2, which is correct.

Another example: x=5, n=5

floor(x/n)=1

Divisors of 5 are 1,5

Divisors <=1 are only 1

So, ans=1

In the code:

for i in range(1, isqrt(5)+1)=1 to 2:

i=1:

x%1==0 -> n=5 <= x//1=5 -> ans=max(0,1)=1

n=5 <=1? No.

i=2:

x%2 !=0 -> skip

So, ans=1, correct.

Third example: x=420, n=69

floor(x/n)=69*6=414, 420-414=6, so floor=6

Divisors of 420 are 1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420

Divisors <=6 are 1,2,3,4,5,6

So, ans=6

In the code:

for i in range(1, isqrt(420)+1)=1 to 20:

i=1:

x%1==0 -> n=69 <= x//1=420 -> ans=1

n=69 <=1? No.

i=2:

x%2==0 -> n=69 <= x//2=210 -> ans=2

n=69 <=2? No.

i=3:

x%3==0 -> n=69 <= x//3=140 -> ans=3

n=69 <=3? No.

i=4:

x%4==0 -> n=69 <= x//4=105 -> ans=4

n=69 <=4? No.

i=5:

x%5==0 -> n=69 <= x//5=84 -> ans=5

n=69 <=5? No.

i=6:

x%6==0 -> n=69 <= x//6=70 -> ans=6

n=69 <=6? No.

i=7:

x%7==0 -> but 7>sqrt(420)=20.49, so stops.

So, ans=6, correct.

Seems like the code is working correctly for these examples.

Wait, but in the code, it's using isqrt(x), which is correct, and iterating up to isqrt(x)+1.

Inside the loop, for each i that divides x, it checks if n <= x//i, then ans = max(ans, i)

Also, if n <= i, then ans = max(ans, x//i)

Wait, why is it checking n <= i?

Wait, in the third example, n=69 and i=6, x//i=70, so n=69 <=70, so ans=6

Also, n=69 <=i=6? No.

So, it's correctly picking ans=6

In the first example, n=3, x=10

floor(x/n)=3

Divisors <=3 are 1,2

The code correctly picks 2

In the second example, n=5, x=5

floor(x/n)=1

Divisors <=1 is 1

Code picks 1

Seems correct.

But I'm still a bit confused about the condition.

Let me think differently.

I need to find the largest d such that d divides x and d <= floor(x/n)

So, in the loop, for each i from 1 to sqrt(x):

- If i divides x:

- If i <= floor(x/n), consider i

- If x/i <= floor(x/n), consider x/i

Wait, but in the code, it's checking n <= x//i and n <=i, which seems opposite.

Wait, perhaps there's a better way to write this.

Let me think about how to collect all divisors <= floor(x/n)

I can collect all i from 1 to sqrt(x), if i divides x and i <= floor(x/n), add i

Also, if x/i <= floor(x/n) and x/i != i, add x/i

Then, take the maximum among them.

So, in the code, it's iterating i from 1 to sqrt(x)

If i divides x:

if n <= x//i, ans = max(ans, i)

if n <=i, ans = max(ans, x//i)

Wait, n <= x//i is equivalent to n <= floor(x/i), which is equivalent to n <= floor(x/n)

Wait, no, x//i is floor(x/i), but I need d <= floor(x/n)

Wait, perhaps it's a mistake in the code.

Let me define limit = floor(x/n)

Then, I need to collect all divisors d of x such that d <= limit

So, in the loop:

for i in range(1, isqrt(x)+1):

if x % i ==0:

if i <= limit:

ans = max(ans, i)

if x//i <= limit and x//i !=i:

ans = max(ans, x//i)

This seems correct.

But in the code, it's checking if n <= x//i, which is equivalent to n <= floor(x/i)

Wait, no, x//i is floor(x/i), so n <= floor(x/i)

But I need d <= floor(x/n)

Wait, I'm getting confused.

Let me try to rewrite the condition correctly.

Define limit = floor(x/n)

Then, for each divisor d of x:

if d <= limit:

consider d

So, the maximum d <= limit among the divisors of x.

So, in the loop:

for i in range(1, isqrt(x)+1):

if x % i ==0:

if i <= limit:

ans = max(ans, i)

if x//i <= limit and x//i !=i:

ans = max(ans, x//i)

This seems correct.

But in the given code, it's:

if x % i ==0:

if n <= x//i:

ans = max(ans, i)

if n <=i:

ans = max(ans, x//i)

This seems incorrect.

Wait, perhaps there's a relation between n and x//i.

Wait, x//i is floor(x/i), which is the maximum possible sum per sub-problem if d=i.

Wait, I'm getting tangled.

Let me think differently.

I need d to be a divisor of x, and d <= floor(x/n)

So, d <= floor(x/n)

So, in the loop, for each i from 1 to sqrt(x):

if x % i ==0:

if i <= floor(x/n):

ans = max(ans, i)

if x//i <= floor(x/n):

ans = max(ans, x//i)

This seems correct.

But in the given code, it's checking n <= x//i for i, and n <=i for x//i

This seems wrong.

Wait, perhaps the person who wrote the code thought that n <= x//i implies i <= floor(x/n)

Wait, no, x//i is floor(x/i), and floor(x/i) >= d, but I'm not sure.

Wait, maybe it's a mistake in the code.

Let me check with an example.

Take x=10, n=3

floor(x/n)=3

Divisors <=3 are 1,2

In the code:

for i in 1 to 3:

i=1:

x%1==0 -> n=3 <= x//1=10 -> ans=1

n=3 <=1? No.

i=2:

x%2==0 -> n=3 <= x//2=5 -> ans=2

n=3 <=2? No.

i=3:

x%3 !=0 -> skip

So, ans=2, correct.

Another example: x=5, n=5

floor(x/n)=1

Divisors <=1:1

In the code:

i=1:

x%1==0 -> n=5 <= x//1=5 -> ans=1

n=5 <=1? Yes, ans=max(1,5//1)=5, but wait, x//1=5, n=5 <=5, so ans=max(1,5)=5

But in the earlier run, it seemed to work correctly as 1.

Wait, perhaps there's a mistake.

Wait, in the code, it's:

if n <= x//i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x//i)

So, in this case:

i=1:

x%1==0:

n=5 <= x//1=5 -> ans=max(0,1)=1

n=5 <=1? Yes -> ans=max(1,5)=5

Wait, so ans=5, but the correct answer is 1.

Wait, but in the earlier run, it seemed to work correctly.

Wait, perhaps I need to set ans=0 initially and then take the maximum.

Wait, in the code, ans=0

Then, for x=5, n=5:

i=1:

x%1==0:

n=5 <= x//1=5 -> ans=max(0,1)=1

n=5 <=1? Yes -> ans=max(1,5)=5

But the correct answer is 1, but the code outputs 5, which is wrong.

Wait, but in the sample input, for x=5, n=5, the output is 1.

So, perhaps the code is incorrect.

Wait, perhaps I misread the code.

Wait, in the code, it's:

if x % i ==0:

if n <= x//i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x//i)

So, for x=5, n=5:

i=1:

x%1==0:

n=5 <= x//1=5 -> ans=max(0,1)=1

n=5 <=1? Yes -> ans=max(1,5)=5

But 5 is not a divisor of 5 that is <= floor(5/5)=1, so it should not consider 5.

Wait, perhaps the condition is wrong.

Wait, in this case, the code would set ans=5, but 5 > floor(5/5)=1, so it's incorrect.

Wait, but in the sample input, for x=5, n=5, the output is 1, which suggests that the code is working correctly, but according to my earlier reasoning, it should output 5, which is wrong.

Wait, maybe I'm missing something.

Wait, perhaps the condition should be d <= floor(x/n), which is i <= floor(x/n) or x/i <= floor(x/n)

So, in the code, it should be:

if i <= floor(x/n):

ans = max(ans, i)

if x/i <= floor(x/n):

ans = max(ans, x/i)

But in the given code, it's:

if n <= x//i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x//i)

Which seems incorrect.

Wait, perhaps there's a relationship between n and x//i that I'm missing.

Wait, let's see:

n <= x//i is equivalent to n <= floor(x/i)

But I need d <= floor(x/n)

I'm getting confused.

Let me try to derive the condition properly.

Given that d is a divisor of x, and d <= floor(x/n), I need to find the maximum such d.

So, in the loop, for each i from 1 to sqrt(x):

if x % i ==0:

if i <= floor(x/n):

ans = max(ans, i)

if x//i <= floor(x/n):

ans = max(ans, x//i)

This seems correct.

But in the code, it's:

if x % i ==0:

if n <= x//i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x//i)

This seems incorrect.

Wait, perhaps the person who wrote the code intended to write the condition correctly but messed up the logic.

In the first example, x=10, n=3, floor(x/n)=3, and the code outputs 2, which is correct.

In the second example, x=5, n=5, floor(x/n)=1, but the code outputs 5, which is incorrect because 5 >1.

Wait, but in the sample output, it's 1, so perhaps there's something wrong with my understanding.

Wait, perhaps the code is correct, and my earlier manual simulation was wrong.

Wait, in the second example, x=5, n=5:

floor(x/n)=1

Divisors of 5 are 1 and 5

Only 1 <=1, so ans=1

In the code:

i=1:

x%1==0:

n=5 <= x//1=5 -> ans=max(0,1)=1

n=5 <=1? Yes -> ans=max(1,5)=5

But 5 > floor(x/n)=1, so it should not consider 5.

But the code sets ans=5, which is wrong.

Wait, perhaps after setting ans=5, it's invalid, but the code doesn't check if x//i <= floor(x/n)

Wait, maybe I need to adjust the conditions.

Wait, perhaps the condition should be:

if i <= floor(x/n):

ans = max(ans, i)

if x//i <= floor(x/n):

ans = max(ans, x//i)

But in the code, it's:

if n <= x//i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x//i)

This seems incorrect.

Wait, perhaps there's a mathematical relation that justifies this.

Let me try to find such a relation.

We have d <= floor(x/n)

And d divides x.

We need to maximize d.

So, in the code, it's trying to find the largest d such that d divides x and d <= floor(x/n)

So, perhaps the conditions in the code are equivalent to this, but I'm not seeing it right now.

Alternatively, maybe there's a better way to think about this.

Wait, perhaps I can iterate through all possible d from floor(x/n) downto 1, check if d divides x, and take the first d that divides x.

This would be more efficient.

So, compute limit = floor(x/n)

Then, iterate d from limit downto 1:

if x % d ==0:

return d

This would work and be more efficient.

In the code, it's iterating up to sqrt(x) and checking conditions.

But given that t can be up to 1e3 and x up to 1e8, iterating up to sqrt(x) is acceptable.

But I'm still confused about the conditions in the code.

Alternatively, perhaps I can precompute all divisors of x sorted in descending order and pick the largest one that is <= floor(x/n)

But that would require storing all divisors, which could be up to O(sqrt(x)) per test case, which is acceptable.

But I need to think about the time complexity.

Given t=1e3 and x=1e8, iterating up to sqrt(x)=1e4 per test case would be 1e7 operations, which is acceptable.

But I need to implement it efficiently.

In the given code, it's using a loop up to sqrt(x) and checking conditions.

But I'm not fully convinced about the conditions.

Alternatively, perhaps there's a formula to compute this directly.

Wait, let's think about it.

If d is the greatest divisor of x that is <= floor(x/n), then d = gcd(x, floor(x/n))

Wait, not sure about that.

Wait, perhaps d = gcd(x, floor(x/n))

But no, for x=10, n=3, floor(x/n)=3, gcd(10,3)=1, but the correct answer is 2.

So, that doesn't work.

Alternatively, perhaps d = gcd(x, n)

But for x=10, n=3, gcd(10,3)=1, which is not the correct answer.

Wait, no.

Wait, perhaps d = gcd(x, n)

But in the first example, gcd(10,3)=1, which is not correct.

In the second example, gcd(5,5)=5, which is incorrect, since the answer should be 1.

Wait, no, in the second example, the answer is 1, which is equal to gcd(5,5)=1.

Wait, no, gcd(5,5)=5, which is incorrect.

Wait, 5 is not <= floor(5/5)=1, so it should be 1.

Wait, perhaps d = min(gcd(x, n), floor(x/n))

But in the first example, gcd(10,3)=1, min(1,3)=1, but the correct answer is 2.

Wait, not correct.

Alternatively, perhaps d = gcd(x, n)

But in the first example, gcd(10