Alright, I have this interactive problem to solve. Let's try to understand what's being asked here.

So, there's a secret permutation p of numbers from 0 to n-1, and I need to find two indices i and j such that p_i XOR p_j is maximized. I can ask up to 3n queries, where each query compares the OR of two elements with the OR of another two elements.

First, I need to think about what information I can get from these queries. Each query gives me a comparison between (p_a OR p_b) and (p_c OR p_d). I need to use these comparisons to figure out which elements of the permutation are larger or have certain bit patterns, since XOR depends on the bits differing.

One approach is to try to find the maximum and second maximum elements in the permutation, because the maximum XOR would likely be between these two. However, since XOR is not directly related to the magnitude of numbers, but rather to the differences in their binary representations, this might not be straightforward.

Let me think differently. Maybe I can determine the binary representation of each p_i bit by bit, starting from the most significant bit to the least significant bit. Since the numbers are from 0 to n-1, the number of bits required to represent them is logarithmic in n.

For example, if n=4, numbers are 0 to 3, which in binary are 00, 01, 10, 11. So, 2 bits are needed.

I can try to find out for each bit position, which elements have that bit set or not, and use that information to compute the XOR.

But asking queries about OR operations seems a bit tricky to relate directly to bit positions. Maybe I can find a way to compare elements based on their OR values to infer their bit patterns.

Wait, perhaps I can find the maximum element in the permutation by comparing ORs of pairs. Since OR combines the bits of two numbers, the maximum OR would be the maximum value in the permutation if I OR a number with itself.

Wait, no. ORing a number with itself just gives the number itself. But ORing two different numbers could give a larger value if their bits complement each other.

Actually, the maximum OR would be the maximum value in the permutation, since ORing any two numbers can't give a larger value than the maximum of the two.

Wait, that's not true. For example, if p_a=3 (11 in binary) and p_b=5 (101), then p_a OR p_b = 7 (111), which is larger than both. But in the permutation, all values are from 0 to n-1, so the OR can't exceed n-1 if n-1 is the maximum.

Wait, actually, in the problem, p is a permutation of 0 to n-1, so all p_i are unique and within 0 to n-1. So, ORing two p_i's can result in a value up to n-1, but it might not be present in the permutation.

But in any case, I need to find the pair with the maximum XOR.

Let me think about the properties of XOR. XOR is maximized when the bit patterns of the two numbers differ as much as possible. So, for example, if one number has a bit set, and the other has it unset, that contributes a 1 to the XOR in that bit position.

So, to maximize XOR, I need to find two numbers that differ in as many bit positions as possible.

Given that, perhaps I can find the minimum and maximum values in the permutation and take their XOR, but that might not always give the maximum XOR.

Wait, for example, with n=4, permutation [0,1,2,3], the maximum XOR is between 1 (01) and 2 (10), which is 3 (11). While 0 XOR 3 is also 3.

So, in this case, it's not necessarily between the minimum and maximum.

Maybe I need a better strategy.

Let me consider the binary representation of the numbers. Suppose I have k bits to represent the numbers, where k is the smallest integer such that 2^k >= n.

I can try to determine, for each bit position, which numbers have that bit set.

If I can sort the numbers based on their bit values, I might be able to group them and find the pair with the maximum XOR.

But how can I do that using the queries allowed?

Each query lets me compare (p_a OR p_b) with (p_c OR p_d).

I need to find a way to use these comparisons to gather information about the bit patterns of the p_i's.

Maybe I can use the queries to find which p_i's have certain bits set or not.

Wait, perhaps I can fix some indices and compare with others to find relative ordering or bit patterns.

This seems complicated. Maybe there's a smarter way.

Let me look at the reference solution provided.

In the reference solution, the approach seems to be:

1. Find the index 'mak' that has the maximum p_i.

2. Then, find all p_i such that p_i OR p_mak > p_mak OR p_mak.

3. Among these p_i, find the one with the maximum p_i.

4. Finally, output the pair (mak2, mak), where mak2 is the initial maximum index, and mak is the index found in step 3.

Wait, let's trace this with the example given.

In the first test case, n=4, p=[0,3,1,2].

First, it sets mak=0.

Then, it compares p_0 OR p_0 with p_i OR p_i for i=1 to 3.

So, for i=1:

? 0 2 3 1

But wait, in the code, it's:

for i in range(1, n):

print('?', mak, mak, i, i)

So, for i=1, it's ? 0 0 1 1

Which corresponds to (p_0 OR p_0) vs (p_1 OR p_1), which is 0 vs 3.

So, 0 < 3, so it sets mak=1.

Then, for i=2:

? 1 1 2 2

Comparing 3 vs 1, which is >, so mak remains 1.

For i=3:

? 1 1 3 3

Comparing 3 vs 2, which is >, so mak remains 1.

So, mak=1, which corresponds to p_1=3, which is indeed the maximum in the permutation.

Then, it sets mak2=mak, which is 1.

Then, it finds all i such that (p_mak OR p_mak2) vs (p_i OR p_mak2).

Wait, in the code:

for i in range(n):

print('?', mak, mak2, i, mak2)

So, it's comparing (p_mak OR p_mak2) vs (p_i OR p_mak2)

But mak and mak2 are both 1, so it's comparing (p_1 OR p_1) vs (p_i OR p_1)

Which is 3 vs (p_i OR 3)

In the first test case:

For i=0:

? 1 1 0 1

Which is 3 vs (0 OR 3)=3, so "="

So, pans=[] (since it's not "<")

For i=1:

? 1 1 1 1

Which is 3 vs 3, so "="

So, pans=[]

For i=2:

? 1 1 2 1

Which is 3 vs (1 OR 3)=3, so "="

pans=[]

For i=3:

? 1 1 3 1

Which is 3 vs (2 OR 3)=3, so "="

pans=[]

So, pans remains []

Then, it sets mak=0, and loops over i from 1 to len(pans)-1, but len(pans)=0, so nothing happens.

Then, it prints ! mak2 mak, which is ! 1 0

But in the sample output, it's ! 3 2

Hmm, so maybe I'm misunderstanding something.

Wait, in the sample input, the output is:

? 0 2 3 1

<

? 1 1 2 3

=

? 1 2 0 3

>

! 3 2

Wait, but according to the code, it should be ? 0 0 1 1, etc.

So perhaps the code provided is not matching the sample input.

Wait, maybe the code is different from what I thought.

Looking back, the code is:

for _ in range(int(input())):

n = int(input())

mak = 0

for i in range(1, n):

print('?', mak, mak, i, i)

sys.stdout.flush()

if str(input()) == '<':

mak = i

mak2 = mak

pans = []

for i in range(n):

print('?', mak, mak2, i, mak2)

sys.stdout.flush()

s = str(input())

if s == '<':

mak = i

pans = [i]

elif s == '=':

pans.append(i)

mak = 0

for i in range(1, len(pans)):

print('?', pans[mak], pans[mak], pans[i], pans[i])

sys.stdout.flush()

if str(input()) == '>':

mak = i

print('!', mak2, mak)

sys.stdout.flush()

But in the sample input, the queries are:

? 0 2 3 1

? 1 1 2 3

? 1 2 0 3

! 3 2

Which doesn't match the pattern of the code.

Wait, perhaps the code is different from the explanation.

Let me try to understand the code.

First, it initializes mak=0.

Then, it loops from i=1 to n-1, and for each i, it asks ? mak mak i i

So, it's comparing p_mak OR p_mak with p_i OR p_i, which is p_mak vs p_i, since p_mak OR p_mak is p_mak, and p_i OR p_i is p_i.

So, it's effectively comparing p_mak with p_i.

If p_mak < p_i, it sets mak=i.

So, at the end of this loop, mak should be the index of the maximum p_i.

Then, it sets mak2=mak.

Then, it loops through all i from 0 to n-1, and asks ? mak mak2 i mak2

Which is (p_mak OR mak2) vs (p_i OR mak2)

But mak2 is equal to mak, which is the index of the maximum p_i.

So, p_mak OR p_mak2 is p_mak OR p_mak, which is p_mak.

And p_i OR p_mak2 is p_i OR p_mak.

So, it's comparing p_mak vs p_i OR p_mak.

If p_mak < p_i OR p_mak, then it sets mak=i and pans=[i]

Else if p_mak == p_i OR p_mak, it appends i to pans.

Wait, but p_mak OR p_i >= p_mak, since ORing with p_mak can only keep it the same or increase it.

So, if p_mak < p_i OR p_mak, that means p_i has some bit set that p_mak doesn't.

Otherwise, p_i OR p_mak == p_mak, meaning p_i is a subset in terms of bits of p_mak.

So, pans collects all i where p_i OR p_mak > p_mak.

Then, it sets mak=0, and loops from i=1 to len(pans)-1, asking ? pans[mak] pans[mak] pans[i] pans[i]

Which is comparing p_pans[mak] vs p_pans[i]

And if p_pans[mak] > p_pans[i], it sets mak=i.

Wait, but it's checking if p_pans[mak] < p_pans[i], because if the comparison is '<', but in the code, it's checking if the input is '>', which would mean p_pans[mak] > p_pans[i]

Wait, in the code:

if str(input()) == '>':

mak = i

So, if p_pans[mak] > p_pans[i], it sets mak=i.

Wait, but '>' means (p_pans[mak] OR p_pans[mak]) > (p_pans[i] OR p_pans[i]), which is p_pans[mak] > p_pans[i]

So, if p_pans[mak] > p_pans[i], it sets mak=i.

So, it's finding the minimum in pans.

But pans contains all i where p_i OR p_mak > p_mak.

Wait, but p_i OR p_mak > p_mak means that p_i has some bit not in p_mak.

So, these are the elements that have at least one bit not present in p_mak.

Then, among these, it's finding the smallest one.

Finally, it outputs ! mak2 mak, which is the original mak (maximum p_i) and this smallest among the pans.

Wait, but in the sample input, it outputs ! 3 2, which corresponds to p_3=2 and p_2=1, whose XOR is 3.

But in the permutation [0,3,1,2], the maximum XOR is between p_1=3 and p_2=1, which is 2 XOR 1 = 3.

Wait, p_3=2 and p_2=1, XOR is 3.

Also, p_0=0 and p_1=3, XOR is 3.

So, both pairs give the maximum XOR of 3.

So, in this case, it's outputting one of the possible pairs.

But according to the code, it's outputting mak2 and mak, where mak2 is the original maximum index, and mak is the smallest index in pans.

Wait, but in the second part, it's finding the maximum in pans, not the smallest.

Wait, in the code:

mak = 0

for i in range(1, len(pans)):

print('?', pans[mak], pans[mak], pans[i], pans[i])

sys.stdout.flush()

if str(input()) == '>':

mak = i

So, it's comparing p_pans[mak] with p_pans[i], and if p_pans[mak] > p_pans[i], it sets mak=i.

Wait, but '>' means p_pans[mak] > p_pans[i], so it's setting mak to i if p_pans[mak] > p_pans[i], meaning it's trying to find the smallest p_pans[i].

Wait, but to maximize XOR, maybe we need the largest p_pans[i].

Wait, perhaps I'm misunderstanding.

Wait, in the sample input, it outputs ! 3 2, which corresponds to p_3=2 and p_2=1, XOR=3.

But in the code, mak2 is the original mak, which is 1 (p_1=3), and mak is 3.

So, it's outputting ! 1 3, but in the sample output, it's ! 3 2.

Hmm, maybe there's a confusion in indexing.

Wait, in the sample input, the output is ! 3 2, but according to the code, it should be ! mak2 mak, which is ! 1 3.

So, perhaps there's a mistake in the code or in the explanation.

Wait, perhaps mak2 is initially set to mak, which is 1, and then mak is updated to 3 in the second loop.

So, ! mak2 mak is ! 1 3, but in the sample output, it's ! 3 2.

Maybe it's a misprint in the explanation.

Anyway, moving on.

I need to verify if this code is correct.

So, the strategy seems to be:

1. Find the index mak with the maximum p_mak.

2. Find all i where p_i OR p_mak > p_mak, which are the elements that have at least one bit not in p_mak.

3. Among these i, find the one with the maximum p_i.

4. Output the pair (mak2, mak), where mak2 is the initial mak, and mak is the index found in step 3.

Wait, but in step 3, it seems to be finding the minimum p_i in pans, not the maximum.

Wait, in the code, it's setting mak=0, and then looping through i from 1 to len(pans)-1, and if p_pans[mak] > p_pans[i], it sets mak=i.

So, it's finding the smallest p_pans[i].

But to maximize XOR, perhaps we need the one that differs the most from p_mak, which might be the one with the highest p_i among those that have bits not in p_mak.

So, maybe the code is incorrect in step 3.

Wait, perhaps it's a mistake in the code.

Let me think about what we need.

We have p_mak as the maximum in the permutation.

Then, to maximize XOR, we need to find p_j such that p_j differs from p_mak in as many bits as possible.

Among the elements that have at least one bit not in p_mak, we need to choose the one that maximizes the XOR with p_mak.

So, probably, we need to choose p_j with the highest possible value that differs the most from p_mak.

But in the code, it's choosing the smallest p_j in pans.

That seems incorrect.

Perhaps it should be choosing the maximum p_j in pans.

Wait, in the code, it's setting mak=0, and then looping through i from 1 to len(pans)-1, and if p_pans[mak] > p_pans[i], it sets mak=i.

This is effectively finding the smallest p_pans[i].

But maybe to maximize XOR with p_mak, we need the p_j that has the most bits different from p_mak, which would be the one that has as many bits set that are not in p_mak.

So, perhaps choosing the maximum p_j in pans would be better.

Wait, but in the sample input, it worked because p_3=2 and p_1=3, and 2 XOR 3=1, which is 3.

Wait, 2 XOR 3 is actually 1.

Wait, 2 is 10, 3 is 11, XOR is 01, which is 1.

Wait, no, 2 XOR 3 is 1.

But in the sample explanation, it says the XOR is 3.

Wait, perhaps I miscalculated.

Wait, 1 XOR 2 is 3.

Because 1 is 01, 2 is 10, XOR is 11, which is 3.

So, p_1=3 and p_2=1, XOR is 2 XOR 1, which is 3.

Wait, no, p_3=2 and p_2=1, XOR is 3.

Wait, perhaps I need to be careful with indexing.

In zero-based indexing, p_0=0, p_1=3, p_2=1, p_3=2.

So, p_1=3, p_2=1, XOR is 3 XOR 1 = 2.

Wait, 3 is 11, 1 is 01, XOR is 10, which is 2.

But in the explanation, it says p_3=2 and p_2=1, XOR is 3.

Wait, 2 is 10, 1 is 01, XOR is 11, which is 3.

So, the code is outputting ! 1 3, which is p_1=3 and p_3=2, XOR=3.

So, it's correct in this case.

But according to the code, it's choosing mak2=1 and mak=3.

So, in this case, it worked.

But is this generalizable?

Let me think about another example.

Suppose n=3, p=[0,1,2].

Step 1: Find mak with maximum p_mak.

Start with mak=0.

Compare p_0 OR p_0 = 0 with p_1 OR p_1 = 1 -> 0 < 1, so mak=1.

Compare p_1 OR p_1 = 1 with p_2 OR p_2 = 2 -> 1 < 2, so mak=2.

So, mak=2, p_mak=2.

Set mak2=2.

Step 2: Find all i where p_i OR p_mak > p_mak.

p_mak=2.

p_i OR 2 > 2.

For i=0: p_0=0 OR 2 = 2 == 2 -> not >

For i=1: p_1=1 OR 2 = 3 > 2 -> add to pans

For i=2: p_2=2 OR 2 = 2 == 2 -> not >

So, pans=[1]

Then, set mak=0.

Since len(pans)=1, no loop happens.

Output ! mak2 mak -> ! 2 0

Which corresponds to p_2=2 and p_0=0, XOR=2.

But the maximum XOR in this case is between p_1=1 and p_2=2, which is 3.

So, in this case, it's outputting ! 2 0, which gives XOR=2, but the maximum is 3.

So, it's incorrect.

Therefore, the code is flawed.

It doesn't always find the pair with the maximum XOR.

In this example, it outputs a pair with XOR=2, while the maximum possible is 3.

Hence, the correctness is False.

## Final Solution
To solve this problem, we need to find two indices \(i\) and \(j\) such that the bitwise XOR of \(p_i\) and \(p_j\) is maximized, using at most \(3n\) queries. The secret sequence \(p\) is a permutation of \(\{0, 1, \ldots, n-1\}\), and we can interact with the jury to compare the bitwise OR of selected elements.

### Approach

1. **Finding the Maximum Element:**
   - Identify the index `mak` with the maximum value in the permutation by comparing \(p_a \mid p_b\) with \(p_c \mid p_d\) for pairs where \(a = b = \text{mak}\) and \(c