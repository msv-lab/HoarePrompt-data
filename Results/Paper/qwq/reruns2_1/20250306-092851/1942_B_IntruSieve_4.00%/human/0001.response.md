Alright, I have this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "Minimum EXcluded" number, which is the smallest non-negative integer not present in the given array. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the array. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is missing.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once. Also, MEX of the first i elements of p will be influenced by what numbers have appeared so far.

Maybe I can try to build p step by step, determining p_i based on a_i and the MEX up to that point.

Let me consider the first element p_1. The MEX of just p_1 is the smallest non-negative integer not equal to p_1. If p_1 is 0, then MEX is 1; if p_1 is 1, MEX is 0; if p_1 is 2, MEX is 0, and so on.

Wait, no. MEX of a single element p_1 is 0 if 0 is not in p_1, otherwise it's 1 if 0 is present but 1 is not, and so on.

Wait, actually, MEX of [p_1] is the smallest non-negative integer not equal to p_1. So if p_1 is 0, MEX is 1; if p_1 is 1, MEX is 0; if p_1 is 2, MEX is 0, etc.

But in general, for any p_1, MEX(p_1) is 0 if 0 is not p_1, otherwise it's 1.

Wait, no. If p_1 is 0, MEX is 1. If p_1 is 1, MEX is 0. If p_1 is 2, MEX is 0. If p_1 is 3, MEX is 0, and so on.

So, in general, MEX(p_1) = 1 if p_1 = 0, else 0.

Wait, no, that's not correct. MEX of [p_1] is the smallest non-negative integer not equal to p_1.

So, if p_1 is 0, MEX is 1.

If p_1 is 1, MEX is 0.

If p_1 is 2, MEX is 0.

Wait, but in the example given in the problem, for n=5 and a=[1,1,-2,1,2], one possible p is [0,1,4,2,3].

Let's verify that:

For i=1: p_1=0, MEX(0)=1, a_1=1-0=1. Correct.

i=2: p_1=0, p_2=1; MEX(0,1)=2, a_2=2-1=1. Correct.

i=3: p_1=0, p_2=1, p_3=4; MEX(0,1,4)=2, a_3=2-4=-2. Correct.

i=4: p_1=0, p_2=1, p_3=4, p_4=2; MEX(0,1,4,2)=3, a_4=3-2=1. Correct.

i=5: p_1=0, p_2=1, p_3=4, p_4=2, p_5=3; MEX(0,1,4,2,3)=5, a_5=5-3=2. Correct.

So, in this case, it works.

Now, I need a general way to reconstruct p from a.

Let me think about the relationship between a_i and p_i.

Given a_i = MEX(p_1 to p_i) - p_i, I can write p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

This seems a bit tricky to work with directly. Maybe I can think about the MEX values progressively.

Let me consider building up the permutation step by step, keeping track of the MEX at each step.

I need to maintain a set of numbers that have appeared so far, and from that, find the MEX.

Wait, but since p is a permutation of 0 to n-1, all numbers from 0 to n-1 will appear exactly once in p.

But I need to reconstruct p from a.

Let me consider iterating through the array a from left to right, and for each a_i, determine what p_i should be based on the MEX up to that point.

I need to keep track of the MEX up to each step, and use the relationship a_i = MEX - p_i to find p_i.

Let me try to formalize this.

Let me denote MEX_i = MEX(p_1, p_2, ..., p_i).

Then, a_i = MEX_i - p_i, so p_i = MEX_i - a_i.

Now, MEX_i is the smallest non-negative integer not in p_1 to p_i.

Since p is a permutation of 0 to n-1, the MEX at each step should be the smallest number from 0 to n-1 that hasn't appeared yet in p_1 to p_i.

Wait, but MEX can be larger than n-1 if some numbers beyond n-1 are missing, but since p only contains 0 to n-1, MEX can be up to n.

Wait, but in the problem, a_i can be from -n to n, and p_i is from 0 to n-1.

Given that, MEX_i can be from 0 to n.

Wait, no, MEX is the smallest non-negative integer not in the array, so it can be from 0 to n.

But p_i is from 0 to n-1, so a_i can be from - (n-1) to n.

Wait, in the problem, it's given that -n <= a_i <= n, which covers the possible range.

Now, to find p_i, I need to find MEX_i, and then p_i = MEX_i - a_i.

But MEX_i depends on p_1 to p_i, which includes p_i, which I'm trying to find.

This seems circular.

So, perhaps I need to find a way to compute MEX_i without knowing p_i yet.

Alternatively, maybe I can find p_i in terms of a_i and the previous MEX values.

Let me think differently.

Suppose I maintain a set of numbers that have appeared so far.

At each step i, I can compute MEX_i as the smallest number not in that set.

But to compute MEX_i, I need to know p_i, which is what I'm trying to find.

This seems tricky.

Wait, perhaps I can iterate through the array a, and for each a_i, use the relationship p_i = MEX_i - a_i, and keep track of the numbers that have appeared.

But I still need a way to compute MEX_i without knowing p_i.

Let me consider that MEX_i is the smallest number not yet used up to step i.

So, I can keep a list of used numbers, and find the smallest number not in that list.

But to find p_i, I need MEX_i, which depends on p_i.

This seems recursive.

Maybe I can iterate through a, and for each a_i, calculate p_i based on the current MEX.

Let me try with the first example:

n=5, a=[1,1,-2,1,2]

I need to find p=[0,1,4,2,3]

Let's see:

For i=1:

a_1=1

p_1 = MEX_1 - a_1

MEX_1 is the smallest non-negative integer not in p_1.

If p_1=0, MEX_1=1

If p_1=1, MEX_1=0

If p_1=2, MEX_1=0

But a_1=1, so p_1 = MEX_1 - 1

If p_1=0, MEX_1=1, p_1=1-1=0: matches.

If p_1=1, MEX_1=0, p_1=0-1=-1: invalid, p_i must be between 0 and n-1.

If p_1=2, MEX_1=0, p_1=0-1=-1: invalid.

So, p_1 must be 0.

That makes sense.

For i=2:

a_2=1

p_2 = MEX_2 - 1

MEX_2 is the smallest number not in p_1 and p_2.

We have p_1=0, p_2=?

If p_2=1, MEX_2=2

Then p_2=2-1=1: matches.

If p_2=2, MEX_2=1, p_2=1-1=0: but 0 is already used.

If p_2=3, MEX_2=1, p_2=1-1=0: invalid.

If p_2=4, MEX_2=1, p_2=1-1=0: invalid.

So, only p_2=1 is valid.

For i=3:

a_3=-2

p_3 = MEX_3 - (-2) = MEX_3 + 2

p_3 must be from 2 to 4, since 0 and 1 are already used.

Possible p_3=2,3,4

MEX_3 is the smallest number not in p_1,p_2,p_3.

p_1=0, p_2=1, p_3=?

If p_3=2, MEX_3=3, p_3=3+2=5: invalid, since p_i must be <5.

If p_3=3, MEX_3=2, p_3=2+2=4: valid.

If p_3=4, MEX_3=2, p_3=2+2=4: valid.

Wait, but in the example, p_3=4.

Let's see:

p_1=0, p_2=1, p_3=4

MEX_3=2 (since 0 and 1 are used, 2 is missing)

a_3=2 - 4 = -2: matches.

Similarly, p_3=3 would also give MEX_3=2, p_3=2+2=4, which is different from p_3=3.

So, p_3=4 is the correct choice.

For i=4:

a_4=1

p_4 = MEX_4 -1

p_4 must be from 2 or 3, since 0,1,4 are used.

p_1=0, p_2=1, p_3=4, p_4=?

MEX_4 is the smallest number not in p_1,p_2,p_3,p_4.

If p_4=2, MEX_4=3, p_4=3-1=2: matches.

If p_4=3, MEX_4=2, p_4=2-1=1: already used.

So, p_4=2.

But in the example, p_4=2.

For i=5:

a_5=2

p_5 = MEX_5 -2

p_5 must be 3, since 0,1,2,4 are used.

p_1=0, p_2=1, p_3=4, p_4=2, p_5=3

MEX_5=5 (since 0,1,2,3,4 are used), p_5=5-2=3: matches.

So, in this case, it works.

From this, I can try to generalize a way to find p_i from a_i and previous p_j's.

Let me try to formalize an algorithm.

Initialize an empty set used to keep track of the numbers used so far.

Initialize MEX as 0.

For each i from 1 to n:

- Compute p_i = MEX - a_i

- Add p_i to the used set

- Update MEX to the smallest number not in used

But wait, MEX is the smallest number not in used, which is the same as the smallest number from 0 to n-1 not in used.

This seems straightforward.

But in the above step, p_i = MEX - a_i, and then add p_i to used.

Then, MEX is updated to the smallest number not in used.

Let me check this with the first example.

i=1:

used={}

MEX=0

p_1=0 -1= -1: invalid.

Wait, that can't be right.

Wait, maybe I need to compute MEX before calculating p_i.

Wait, but MEX is based on p_1 to p_i, so it depends on p_i.

This is tricky.

Perhaps I need to find MEX after adding p_i.

Wait, maybe I need to find p_i such that when added to used, the MEX is as per the formula.

This seems too circular.

Let me try another approach.

Let me consider that at each step i, MEX_i is the smallest number not yet used.

So, MEX_i can be determined by looking at the set of used numbers up to step i.

But p_i is MEX_i - a_i.

So, perhaps I can iterate through a, and for each a_i, calculate p_i = MEX_i - a_i, where MEX_i is the smallest number not in the set of p_1 to p_i.

Wait, but p_i is part of that set.

This seems tricky.

Maybe I can iterate through a, keep track of used numbers, and for each a_i, try to find p_i such that p_i = MEX_i - a_i, where MEX_i is the smallest number not in used.

But p_i must not be in used.

Wait, perhaps I can iterate through a, keep track of used numbers, find for each a_i, p_i = MEX - a_i, ensure p_i is not used yet, and then update used and MEX accordingly.

Let me try this with the first example.

Initialize:

used = set()

MEX = 0

i=1:

a_1=1

p_1 = MEX - a_1 = 0 -1 = -1: invalid.

Wait, that doesn't make sense.

Alternatively, perhaps MEX should be the smallest number not in used.

So, initially, used is empty, so MEX=0.

But p_1=0 -1=-1: invalid.

Wait, maybe I need to adjust how I calculate MEX.

Wait, perhaps MEX should be the smallest number not yet used, but considering that p_i will be added to used.

This is getting complicated.

Let me think differently.

Let me consider that MEX_i is the smallest number not in p_1 to p_i.

But p_i is part of p_1 to p_i.

Wait, perhaps I can find MEX_i by finding the smallest number not in the set of p_1 to p_i.

But p_i is unknown, so I need another way.

Maybe I can iterate through a, and for each a_i, calculate p_i = MEX_i - a_i, and then update the used set and MEX accordingly.

But I need a way to compute MEX_i without knowing p_i.

Perhaps I can keep track of the used numbers and find the smallest number not in used.

But p_i depends on MEX_i, which depends on p_i.

This seems recursive.

Let me try to find another way.

I recall that in some problems involving MEX, we can keep track of the available numbers and assign them accordingly.

Let me try to think in terms of available numbers.

Initialize a list of available numbers from 0 to n-1.

For each position i from 1 to n:

- Compute MEX_i as the smallest number not in p_1 to p_i.

- Then p_i = MEX_i - a_i.

- Ensure that p_i is in the available numbers.

- Remove p_i from available numbers.

But again, MEX_i depends on p_i.

This seems too circular.

Maybe I need to find a different approach.

Let me consider that p_i = MEX_i - a_i.

So, MEX_i = p_i + a_i.

But MEX_i is the smallest number not in p_1 to p_i.

So, perhaps I can iterate through a, and for each a_i, try to find p_i such that p_i + a_i is the smallest number not in p_1 to p_i.

This seems complex, but maybe I can implement it.

Let me try with the first example again.

n=5, a=[1,1,-2,1,2]

Initialize used=set(), MEX=0

i=1:

a_1=1

p_1 = MEX - a_1 = 0 -1 = -1: invalid.

Wait, that doesn't make sense.

Alternatively, perhaps MEX should be updated after adding p_i.

Wait, perhaps I should find p_i such that p_i + a_i is the MEX before adding p_i.

This is getting too convoluted.

Let me look for another strategy.

I recall that in some MEX problems, we can use a priority queue or sort the available numbers and assign them accordingly.

But here, since p is a permutation, and we have to satisfy the condition a_i = MEX(p_1 to p_i) - p_i, it's tricky.

Let me consider that MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

So, MEX(p_1 to p_i) is the smallest k such that k is not in p_1 to p_i.

Given that, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) depends on p_i.

This seems too recursive.

Maybe I need to find a way to compute MEX(p_1 to p_{i-1}) and see how p_i affects it.

Wait, perhaps I can keep track of the MEX up to i-1, and see how adding p_i affects the MEX.

Let me denote MEX_{i-1} as the MEX of p_1 to p_{i-1}.

When I add p_i, the new MEX_i depends on whether p_i is less than MEX_{i-1} or not.

If p_i < MEX_{i-1}, then MEX_i remains MEX_{i-1}.

If p_i >= MEX_{i-1}, then MEX_i = MEX_{i-1} + 1 (since MEX_{i-1} was not in p_1 to p_{i-1}, and p_i >= MEX_{i-1}, so MEX_i is MEX_{i-1} + 1).

Wait, this seems promising.

So, I can keep track of MEX_{i-1}, and based on p_i, determine MEX_i.

But I need to find p_i based on a_i and MEX_i.

Let me try to express MEX_i in terms of MEX_{i-1} and p_i.

MEX_i = MEX_{i-1} if p_i >= MEX_{i-1}, else MEX_i = MEX_{i-1}.

Wait, no.

Actually, if p_i < MEX_{i-1}, then MEX_i remains MEX_{i-1}, because MEX_{i-1} was not in p_1 to p_{i-1}, and if p_i < MEX_{i-1}, it doesn't affect MEX_i.

If p_i >= MEX_{i-1}, then MEX_i = MEX_{i-1} + 1 (since MEX_{i-1} was not in p_1 to p_{i-1}, and p_i >= MEX_{i-1}, so MEX_i is MEX_{i-1} + 1).

Wait, no. If p_i == MEX_{i-1}, then MEX_i = MEX_{i-1} + 1.

If p_i > MEX_{i-1}, and p_i hasn't been used yet, then MEX_i could be MEX_{i-1} + 1, but only if MEX_{i-1} is not in p_1 to p_i.

Wait, this is getting too complicated.

Let me try to think differently.

I have p_i = MEX_i - a_i.

I need to find p_i such that p_i is not in p_1 to p_{i-1}, and MEX_i is the smallest number not in p_1 to p_i.

This seems too recursive.

Maybe I need to iterate through a and assign p_i accordingly, ensuring that p_i is unique and satisfies the equation.

Let me consider that for each i, p_i must be equal to MEX_i - a_i, and MEX_i is the smallest number not in p_1 to p_i.

So, perhaps I can iterate through a, keep track of used numbers, and for each a_i, calculate p_i = MEX_i - a_i, where MEX_i is the smallest number not in used.

Then, add p_i to used.

But I need to ensure that p_i is not already used.

Wait, perhaps I can iterate through a, keep track of used numbers, compute p_i = MEX_i - a_i, check if p_i is not used yet, then add it to used.

If p_i is already used, then perhaps choose another possible p_i.

But this seems inefficient, especially since n can be up to 2e5.

I need a more efficient way.

Let me think about the properties of MEX.

Since p is a permutation of 0 to n-1, the MEX at each step i is the smallest number from 0 to n-1 not yet in p_1 to p_i.

Wait, but MEX can also be n if all numbers from 0 to n-1 are used.

But in this problem, since p is a permutation of 0 to n-1, MEX_i can be up to n.

But a_i can be from -n to n, so p_i can be from 0 to n.

Wait, but p_i is from 0 to n-1.

So, MEX_i - a_i should be from 0 to n-1.

Given that, perhaps I can iterate through a, keep track of used numbers, compute p_i = MEX_i - a_i, ensure p_i is within 0 to n-1 and not used yet.

If it is, use it; otherwise, find the next available p_i that satisfies the condition.

But this seems too time-consuming for the constraints.

I need a better way.

Let me consider that at each step, MEX_i is the smallest number not yet used.

So, I can keep track of used numbers, find the smallest number not used, which is MEX_i.

Then, p_i = MEX_i - a_i.

Then, I need to ensure that p_i is not already used, and is within 0 to n-1.

If it is, use it; otherwise, find the smallest number greater than MEX_i that is not used, set p_i = that number - a_i, and so on.

But this seems too involved.

Wait, maybe I can precompute the MEX values based on the used set.

Let me try to implement an algorithm:

Initialize used = set()

Initialize MEX = 0

For each i from 1 to n:

While