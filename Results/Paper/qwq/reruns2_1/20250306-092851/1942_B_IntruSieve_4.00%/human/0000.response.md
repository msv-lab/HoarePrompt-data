Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in the given array up to that point. For example, MEX of [0, 1, 4] is 2 because 0 and 1 are present, but 2 is missing.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. I need to find which number goes in each position based on the a array.

Maybe I can try to build p step by step, from p_1 to p_n, using the information from a.

Let's consider the first element p_1. The MEX of just p_1 is the smallest non-negative integer not equal to p_1. If p_1 is 0, MEX is 1; if p_1 is 1, MEX is 0; and so on.

Wait, actually, MEX of a single element p_1 is 0 if p_1 is not 0, otherwise it's 1. No, actually, MEX is the smallest non-negative integer not in the set. So if p_1 is 0, MEX is 1; if p_1 is 1, MEX is 0; if p_1 is 2, MEX is 0, etc.

Wait, no. MEX of [2] is 0, because 0 is the smallest non-negative integer not in the set {2}.

Wait, but in the example, MEX(1,2,3) is 0, and MEX(3,1,0) is 2.

Wait, no, MEX is the smallest non-negative integer not present in the set.

So, MEX of [2] is 0, since 0 is not in [2].

MEX of [0] is 1, since 0 is present, so 1 is the smallest missing.

MEX of [1] is 0, since 0 is not in [1].

MEX of [0,1] is 2, since 0 and 1 are present.

Wait, no, MEX of [0,1] is 2, because 0 and 1 are present, so the smallest missing is 2.

Wait, but in the problem statement, it says MEX(0,1,4) is 2, which matches.

Wait, but earlier I thought MEX of [2] is 0, but actually, MEX of [2] should be 0, because 0 is not in [2].

Wait, no, hold on, MEX is the smallest non-negative integer not in the set.

So, for [2], 0 is not in [2], so MEX is 0.

For [0], 0 is present, so MEX is 1.

For [0,1], 0 and 1 are present, so MEX is 2.

For [1], 0 is not present, so MEX is 0.

Okay, got it.

So, for p_1, MEX is the smallest non-negative integer not equal to p_1.

Then, a_1 = MEX(p_1) - p_1.

Similarly, for p_2, MEX is the smallest non-negative integer not in {p_1, p_2}, and a_2 = MEX(p_1, p_2) - p_2.

I need to find p_i for all i based on a_i.

This seems a bit tricky. Maybe I can try to find a way to reconstruct p step by step.

Let me consider that p is a permutation of 0 to n-1, and I need to assign each p_i such that the MEX condition is satisfied.

One approach could be to keep track of the numbers that have been used in p so far and the MEX at each step.

Wait, but MEX depends on the current set of p_1 to p_i.

I need to find p_i such that MEX(p_1 to p_i) - p_i = a_i.

So, MEX(p_1 to p_i) = a_i + p_i.

But MEX is always a non-negative integer.

So, a_i + p_i must be a non-negative integer.

Given that a_i can be from -n to n, and p_i is from 0 to n-1, their sum can range from -n + 0 to n + (n-1) = 2n - 1.

But MEX is at least 0 and at most n, since in the worst case, p_1 to p_i contain all numbers from 0 to i-1, so MEX would be i.

Wait, no, MEX can be larger than n if n is less than some number.

Wait, but p contains only numbers from 0 to n-1, so MEX can be at least 0 and at most n, because if all numbers from 0 to n-1 are present in p_1 to p_i, then MEX is n.

But in practice, MEX can be less than n, depending on which numbers are missing.

So, MEX is in [0, n].

Given that, a_i + p_i must be in [0, n].

Given that, and knowing that p_i is in [0, n-1], and a_i is in [-n, n], their sum can be in [-n, 2n - 1], but constrained to [0, n].

So, perhaps I can use this to find p_i.

Let me think about the first element.

For i=1:

a_1 = MEX(p_1) - p_1.

But MEX(p_1) is the smallest non-negative integer not equal to p_1.

So, if p_1 = 0, MEX(p_1) = 1.

If p_1 = 1, MEX(p_1) = 0.

If p_1 = 2, MEX(p_1) = 0.

Wait, but in the first case, p_1 = 0, MEX is 1; p_1 = 1, MEX is 0; p_1 = 2, MEX is 0.

So, a_1 = MEX(p_1) - p_1.

So, if p_1 = 0, a_1 = 1 - 0 = 1.

If p_1 = 1, a_1 = 0 - 1 = -1.

If p_1 = 2, a_1 = 0 - 2 = -2.

So, for i=1, a_1 can be 1 or -ve based on p_1.

Similarly, for i=2:

a_2 = MEX(p_1, p_2) - p_2.

MEX(p_1, p_2) is the smallest non-negative integer not in {p_1, p_2}.

So, depending on what p_1 and p_2 are, MEX is determined.

This seems complicated.

Maybe I can try to build p step by step, choosing p_i such that a_i = MEX(p_1 to p_i) - p_i.

Given that, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is unknown, so this seems circular.

Wait, but I can express MEX in terms of a_i and p_i.

Wait, perhaps I can iterate through the array and try to assign p_i accordingly.

Let me consider that I have to choose p_i such that p_i = MEX(p_1 to p_i) - a_i.

But MEX is the smallest non-negative integer not in p_1 to p_i.

This seems tricky.

Maybe I can keep track of the numbers used so far and find which number, when assigned to p_i, satisfies the equation.

Let me think differently.

Suppose I maintain a set of used numbers.

At each step, for i from 1 to n:

- I have p_1 to p_{i-1}.

- I need to choose p_i from the remaining numbers.

- I need to ensure that MEX(p_1 to p_i) - p_i = a_i.

So, for each p_i, I can iterate through the remaining numbers and see which one satisfies the equation.

But this seems too slow for n up to 2e5.

I need a more efficient approach.

Let me try to find a pattern or a formula to directly compute p_i.

Let me consider the MEX calculation.

MEX is the smallest non-negative integer not in p_1 to p_i.

Suppose I have p_1 to p_{i-1}, and I'm choosing p_i.

The MEX of p_1 to p_i will be the smallest non-negative integer not in p_1 to p_i.

Given that, and given a_i = MEX(p_1 to p_i) - p_i, I can write p_i = MEX(p_1 to p_i) - a_i.

But I don't know MEX yet.

Wait, maybe I can think in terms of available numbers.

Let me consider that at each step, the MEX is the smallest non-negative integer not yet used in p_1 to p_i.

Wait, but it's not necessarily the smallest not used; it's the smallest not in p_1 to p_i.

Wait, it's the smallest non-negative integer not in p_1 to p_i.

Given that, perhaps I can keep track of which numbers are used up to each step.

Wait, perhaps I can maintain a list of available numbers and determine which one to pick for p_i based on a_i.

Let me consider the first test case from the example:

n=5

a = [1,1,-2,1,2]

The corresponding p is [0,1,4,2,3]

Let's verify:

p_1=0, MEX([0])=1, a_1=1-0=1

p_2=1, MEX([0,1])=2, a_2=2-1=1

p_3=4, MEX([0,1,4])=2, a_3=2-4=-2

p_4=2, MEX([0,1,4,2])=3, a_4=3-2=1

p_5=3, MEX([0,1,4,2,3])=5, a_5=5-3=2

Yes, that matches.

Another test case:

n=5

a = [1,1,1,1,1]

p = [0,1,2,3,4]

Check:

p_1=0, MEX([0])=1, a_1=1-0=1

p_2=1, MEX([0,1])=2, a_2=2-1=1

p_3=2, MEX([0,1,2])=3, a_3=3-2=1

p_4=3, MEX([0,1,2,3])=4, a_4=4-3=1

p_5=4, MEX([0,1,2,3,4])=5, a_5=5-4=1

Perfect.

Another test case:

n=3

a = [-2,1,2]

p = [2,0,1]

Check:

p_1=2, MEX([2])=0, a_1=0-2=-2

p_2=0, MEX([2,0])=1, a_2=1-0=1

p_3=1, MEX([2,0,1])=3, a_3=3-1=2

Correct.

From these examples, perhaps I can see a pattern.

In the first test case, a has a mix of positive and negative values, and p has numbers in a shuffled order.

In the second test case, a has all 1's, and p is the identity permutation.

In the third test case, a has -2,1,2 and p is [2,0,1].

I need to find a general way to construct p from a.

Let me think about the relationship between a_i and p_i.

From a_i = MEX(p_1 to p_i) - p_i, I can write p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is unknown, so I need another way.

Wait, perhaps I can iterate through the array and keep track of the MEX at each step.

Let me try to simulate the process.

Initialize an empty list for p and a set of used numbers.

Start with i=1:

- I need to choose p_1 such that a_1 = MEX(p_1) - p_1.

- MEX(p_1) is the smallest non-negative integer not equal to p_1.

- So, if I choose p_1, a_1 should be equal to (smallest not in p_1) - p_1.

- For example, if p_1=0, a_1=1-0=1; if p_1=1, a_1=0-1=-1; if p_1=2, a_1=0-2=-2, etc.

- So, for a given a_1, there might be multiple possible p_1, or a specific one.

Wait, but since p is a permutation, each number can only be used once.

Perhaps I can iterate through possible p_1 and see which one fits.

But that's not efficient for large n.

Let me think differently.

Suppose I consider the MEX at each step.

At step i, MEX is the smallest non-negative integer not in p_1 to p_i.

Let me denote MEX_i = MEX(p_1 to p_i).

Then, a_i = MEX_i - p_i, so p_i = MEX_i - a_i.

But MEX_i depends on p_1 to p_i, which includes p_i.

This seems circular.

Wait, but perhaps I can find a way to compute MEX_i based on previous MEX and the new p_i.

Wait, perhaps I can keep track of which numbers are present in p_1 to p_i.

Let me try to maintain a list of used numbers and find the MEX accordingly.

But this still seems too slow for n up to 2e5.

I need a smarter approach.

Let me consider that in a permutation, each number from 0 to n-1 appears exactly once.

Also, MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

Given that, MEX_i is at least 0 and at most n, as discussed earlier.

Given a_i = MEX_i - p_i, I can write p_i = MEX_i - a_i.

If I can find MEX_i, then p_i is determined.

But how to find MEX_i?

Wait, perhaps I can find p_i directly based on a_i.

Let me consider that.

Suppose I have a_i = MEX_i - p_i.

Then p_i = MEX_i - a_i.

But MEX_i is the smallest non-negative integer not in p_1 to p_i.

This seems tricky.

Maybe I can iterate through the array and assign p_i accordingly.

Let me try with the first test case.

n=5

a=[1,1,-2,1,2]

From the example, p=[0,1,4,2,3]

Let's see:

For i=1:

a_1=1

p_1 = MEX(p_1) - a_1

But p_1 is part of the MEX calculation.

Wait, perhaps I can consider that MEX(p_1) is 1 when p_1=0, which fits a_1=1.

Similarly, for i=2:

a_2=1

p_2=1

MEX(p_1,p_2)=2

So, 2 - 1 =1, which matches a_2=1.

For i=3:

a_3=-2

p_3=4

MEX(p_1,p_2,p_3)=2

2 - 4 = -2, which matches a_3=-2.

Wait, so perhaps I can choose p_i based on a_i and the current MEX.

But how to compute MEX dynamically?

Let me consider that at each step, MEX_i is the smallest non-negative integer not in p_1 to p_i.

So, I can keep track of the used numbers and find the smallest missing one.

But in practice, for large n, I need an efficient way to do this.

Let me think about the properties of MEX.

MEX is the smallest non-negative integer not present in the set.

So, if I have a set of used numbers, MEX is the smallest non-negative integer not in that set.

I can maintain a variable to track the current MEX.

Initially, for i=1, p_1 is chosen such that a_1 = MEX(p_1) - p_1.

So, p_1 = MEX(p_1) - a_1.

But MEX(p_1) is the smallest non-negative integer not equal to p_1.

Wait, perhaps I can consider that MEX(p_1) is the smallest non-negative integer not in p_1.

So, if p_1 = 0, MEX(p_1) =1; if p_1 =1, MEX(p_1)=0; if p_1=2, MEX(p_1)=0, etc.

Wait, but in the first case, p_1=0, MEX=1; p_1=1, MEX=0; p_1=2, MEX=0.

So, p_1 = MEX(p_1) - a_1.

So, for p_1=0, 0 =1 - a_1 ⇒ a_1=1, which matches.

For p_1=1,1=0 - a_1 ⇒ a_1=-1.

For p_1=2,2=0 - a_1 ⇒ a_1=-2.

So, for a given a_1, there might be multiple possible p_1, but since p is a permutation, each number is used only once.

Wait, but in the first test case, a_1=1, which corresponds to p_1=0.

In the second test case, a_1=1, which again corresponds to p_1=0.

In the third test case, a_1=-2, which corresponds to p_1=2.

So, perhaps for a_1=1, p_1=0; for a_1=-1, p_1=1; for a_1=-2, p_1=2; and so on.

So, perhaps p_1 = -a_1.

Wait, in the first test case, p_1=0, a_1=1 ⇒ p_1 = -a_1.

In the second test case, p_1=0, a_1=1 ⇒ p_1 = -a_1.

In the third test case, p_1=2, a_1=-2 ⇒ p_1 = -a_1.

Yes, so p_1 = -a_1.

Wait, but in the second test case, p_1=0, a_1=1, which is p_1 = -a_1.

In the third test case, p_1=2, a_1=-2, which is p_1 = -a_1.

So, p_1 = -a_1.

Is this always true?

Wait, in the first test case, p_1=0, a_1=1 ⇒ p_1 = -a_1.

Yes.

So, perhaps p_i = -a_i for all i.

Wait, but in the first test case, p_2=1, a_2=1 ⇒ p_2 ≠ -a_2.

Wait, p_2=1, a_2=1 ⇒ p_2 = MEX(p_1,p_2) - a_2.

Wait, no, a_2 = MEX(p_1,p_2) - p_2 ⇒ p_2 = MEX(p_1,p_2) - a_2.

But MEX(p_1,p_2) is the smallest non-negative integer not in {p_1,p_2}.

So, p_2 = MEX(p_1,p_2) - a_2.

But I don't know MEX(p_1,p_2).

Wait, perhaps I can consider that MEX(p_1,p_2) is greater than p_1 and p_2.

Wait, no, MEX is the smallest non-negative integer not in {p_1,p_2}.

So, if p_1 and p_2 are both greater than 0, then MEX could be 0.

Wait, in the first test case, p_1=0, p_2=1 ⇒ MEX=2.

So, p_2 = 2 - a_2 ⇒ p_2 = 2 -1 =1, which matches.

In the second test case, p_1=0, p_2=1 ⇒ MEX=2 ⇒ p_2=2 -1=1.

Wait, but a_2=1, so p_2=2 -1=1, which matches.

In the third test case, p_1=2, p_2=0 ⇒ MEX=1 ⇒ p_2=1 -1=0, which matches a_2=1.

Wait, a_2=1, p_2=0, MEX=1 ⇒ 1 -0=1, which matches.

So, in general, p_i = MEX(p_1 to p_i) - a_i.

But I don't know MEX(p_1 to p_i).

Wait, perhaps I can find MEX(p_1 to p_i) based on the previous MEX and the new p_i.

Let me think about how MEX changes when a new p_i is added.

Suppose I have MEX_{i-1}, which is the MEX of p_1 to p_{i-1}.

When I add p_i, if p_i < MEX_{i-1}, then MEX_i remains MEX_{i-1}, because MEX_{i-1} is still not in p_1 to p_i.

If p_i >= MEX_{i-1}, then MEX_i = MEX_{i-1} + 1.

This is a property of MEX.

Wait, no.

Actually, when you add p_i, if p_i == MEX_{i-1}, then MEX_i = MEX_{i-1} +1.

If p_i < MEX_{i-1}, then MEX_i remains MEX_{i-1}.

If p_i > MEX_{i-1}, then MEX_i remains MEX_{i-1}, unless p_i == MEX_{i-1}.

Wait, let's think carefully.

Suppose MEX_{i-1} is the smallest non-negative integer not in p_1 to p_{i-1}.

When you add p_i:

- If p_i < MEX_{i-1}, then MEX_i remains MEX_{i-1}, because p_i doesn't affect the smallest missing integer.

- If p_i == MEX_{i-1}, then MEX_i = MEX_{i-1} +1, because p_i is now present, so the next missing integer is MEX_{i-1} +1.

- If p_i > MEX_{i-1}, then MEX_i remains MEX_{i-1}, because p_i is larger and doesn't affect the smallest missing integer.

So, MEX_i = MEX_{i-1} if p_i != MEX_{i-1}, else MEX_i = MEX_{i-1} +1.

Given that, perhaps I can iterate through the array, keeping track of the current MEX and choosing p_i accordingly.

Let me try to formalize this.

Initialize MEX_0 =0.

Then, for i=1 to n:

- p_i = MEX_{i-1} - a_i.

- Then, MEX_i = MEX_{i-1} if p_i != MEX_{i-1}, else MEX_i = MEX_{i-1} +1.

Wait, but p_i might not be equal to MEX_{i-1} - a_i, because MEX_{i-1} is based on p_1 to p_{i-1}.

Wait, perhaps I need to adjust this.

Wait, from a_i = MEX(p_1 to p_i) - p_i, so p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) depends on p_i.

This seems tricky.

Wait, perhaps I can consider that MEX(p_1 to p_i) is MEX_{i-1} if p_i != MEX_{i-1}, else MEX_{i-1} +1.

Given that, perhaps I can express p_i in terms of MEX_{i-1} and a_i.

Let me try to write p_i in terms of MEX_{i-1}.

Given that MEX(p_1 to p_i) = MEX_{i-1} if p_i != MEX_{i-1}, else MEX_{i-1} +1.

And a_i = MEX(p_1 to p_i) - p_i.

So, a_i = MEX_{i-1} - p_i, if p_i != MEX_{i-1}, else a_i = MEX_{i-1} +1 - p_i.

So, in the first case, p_i = MEX_{i-1} - a_i.

In the second case, p_i = MEX_{i-1} +1 - a_i.

But in the second case, p_i = MEX_{i-1} +1 - a_i, but p_i == MEX_{i-1}, so:

MEX_{i-1} = MEX_{i-1} +1 - a_i ⇒ a_i =1.

So, when a_i =1, p_i = MEX_{i-1}.

Otherwise, p_i = MEX_{i-1} - a_i.

Wait, perhaps I can generalize this.

Let me consider that p_i = MEX_{i-1} - a_i, and then adjust MEX_i accordingly.

Let me try with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize MEX_0=0

i=1:

p_1 = MEX_0 - a_1 =0 -1 = -1

But p_i must be in [0,4], so this can't be.

Wait, perhaps I need to choose p_i such that p_i = MEX_{i-1} - a_i, but ensure p_i is in [0,n-1] and not already used.

In the first test case, p_1=0, a_1=1.

So, p_1 = MEX_0 - a_1 =0 -1=-1, which is invalid.

Wait, perhaps I need to choose p_i such that p_i = MEX_{i-1} - a_i, but adjust for validity.

Wait, maybe I need to consider that MEX(p_1 to p_i) is MEX_i.

So, a_i = MEX_i - p_i ⇒ p_i = MEX_i - a_i.

But MEX_i depends on p_i.

This seems circular.

Perhaps I need to iterate and keep track of used numbers and find p_i that fits.

Let me try to implement this idea.

Initialize used = empty set

Initialize MEX =0

For each i from 1 to n:

- Find p_i such that p_i = MEX - a_i, and p_i not in used.

- If such p_i exists, assign it and update used and MEX.

- If not, try p_i = MEX + k - a_i for some k.

This seems vague.

Wait, perhaps I can iterate and for each i, choose p_i as MEX - a_i, and update MEX accordingly.

Let me try with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize MEX=0

used={}

i=1:

p_1 = MEX - a_1 =0 -1=-1, which is invalid.

Wait, maybe I need to choose p_i such that p_i = MEX - a_i, and adjust MEX based on whether p_i == MEX.

But in this case, p_i=-1 is invalid.

Wait, perhaps I need to choose p_i as MEX - a_i, and if it's invalid, choose the next available number.

This is getting too complicated.

Let me consider another approach.

Since p is a permutation, each number from 0 to n-1 appears exactly once.

I can consider that for each i, p_i is assigned a unique number from 0 to n-1, and a_i is determined based on MEX up to that point.

Given that, perhaps I can iterate through i from 1 to n, and for each i, choose the smallest available number that satisfies the condition a_i = MEX(p_1 to p_i) - p_i.

Let me try that.

Initialize a list of available numbers: [0,1,2,3,4]

Initialize MEX=0

For each i from 1 to n:

- For each available p_i in sorted order:

- Assign p_i

- Calculate MEX(p_1 to p_i)

- Check if a_i = MEX - p_i

- If yes, keep this p_i, remove it from available, and proceed to next i.

- If not, try the next available p_i.

This could work, but it's O(n^2), which is too slow for n=2e5.

I need a faster way.

Let me think about the properties of a_i.

From the examples:

- When a_i=1, it seems that p_i is often MEX -1.

- When a_i=-ve, p_i is larger than MEX.

Wait, in the first test case, a_1=1, p_1=0; a_2=1, p_2=1; a_3=-2, p_3=4; a_4=1, p_4=2; a_5=2, p_5=3.

So, for a_i=1, p_i=MEX-1; for a_i=-2, p_i=MEX+2.

Wait, but MEX is changing based on previous p_i.

This is getting too tangled.

Let me try to look for a different approach.

Perhaps I can consider that MEX(p_1 to p_i) is equal to the number of elements in p_1 to p_i that are less than MEX_{i-1}, plus MEX_{i-1}.

Wait, that might not help.

Let me consider that in a permutation, the numbers are from 0 to n-1, each appearing once.

So, perhaps I can consider that the MEX at each step is related to the number of elements used so far.

Wait, but MEX is the smallest missing number, not necessarily related to the count.

Wait, perhaps I can consider that MEX is equal to the number of elements used so far plus some offset.

No, that doesn't seem right.

Let me think differently.

Suppose I have the array a, and I need to find p such that for each i, a_i = MEX(p_1 to p_i) - p_i.

Given that, perhaps I can iterate through i from 1 to n, keep track of the used numbers, compute MEX as the smallest non-negative integer not in used, and then set p_i = MEX - a_i, ensuring that p_i is unique and within [0,n-1].

Wait, but in the first test case, when i=1, MEX=0, a_1=1, p_1=0-1=-1, which is invalid.

Wait, perhaps I need to adjust MEX based on a_i and p_i.

This seems too vague.

Let me consider that MEX is always greater than or equal to the number of elements used so far.

Wait, no, MEX can be less than the number of elements used so far, depending on the permutation.

For example, if p_1 to p_i contain all numbers from 0 to i-1, then MEX=i.

But if some smaller numbers are missing, MEX would be less.

Wait, perhaps I can iterate through a and find p that satisfies the condition.

But time is limited, and I need an efficient solution.

Looking back at the code provided, it seems to attempt to compute p based on a.

Let me see what the code is doing.

It reads t test cases.

For each test case:

- Read n

- Read array a of length n

- Initialize mex as an empty list

- Initialize minn=0 and maxx=0

- For each i from 0 to n-1:

- If a[i] >0:

- Append minn to mex

- Increment minn by 1

- If minn == maxx, set minn = maxx +1

- Else:

- Append abs(a[i] - minn) to mex

- If abs(a[i] - minn) > maxx, set maxx = abs(a[i] - minn)

- Print the mex list.

Wait, this seems different from what I thought.

Let me see what this code is doing.

It's constructing a list mex, which seems to be the permutation p.

For each element in a:

- If a[i] >0, it appends minn to mex, increments minn, and adjusts minn if minn == maxx.

- Else, it appends abs(a[i] - minn) to mex and updates maxx if necessary.

Then, it prints the mex list.

Wait, I need to verify if this code correctly reconstructs p from a.

Let's test it with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize mex=[]

minn=0, maxx=0

i=0:

a[0]=1 >0:

append minn=0 to mex

minn +=1 ⇒ minn=1

since minn==maxx (1==0)? No.

mex=[0]

i=1:

a[1]=1 >0:

append minn=1 to mex

minn +=1 ⇒ minn=2

since minn==maxx (2==0)? No.

mex=[0,1]

i=2:

a[2]=-2 <=0:

append abs(-2 -1)=3 to mex

if 3 > maxx (3>0), set maxx=3

mex=[0,1,3]

i=3:

a[3]=1 >0:

append minn=2 to mex

minn +=1 ⇒ minn=3

since minn==maxx (3==3), set minn=3+1=4

mex=[0,1,3,2]

i=4:

a[4]=2 >0:

append minn=4 to mex

minn +=1 ⇒ minn=5

since minn==maxx (5==3)? No.

mex=[0,1,3,2,4]

Wait, but in the example, p=[0,1,4,2,3]

But the code outputs [0,1,3,2,4], which is different from the example.

Wait, but is it a valid permutation satisfying a?

Let's check:

p=[0,1,3,2,4]

Compute a_i = MEX(p_1 to p_i) - p_i for each i.

i=1:

p_1=0, MEX([0])=1, a_1=1-0=1

i=2:

p_1=0,p_2=1, MEX([0,1])=2, a_2=2-1=1

i=3:

p_1=0,p_2=1,p_3=3, MEX([0,1,3])=2, a_3=2-3=-1

i=4:

p_1=0,p_2=1,p_3=3,p_4=2, MEX([0,1,3,2])=4, a_4=4-2=2

i=5:

p_1=0,p_2=1,p_3=3,p_4=2,p_5=4, MEX([0,1,3,2,4])=5, a_5=5-4=1

So, a=[1,1,-1,2,1], but the input a was [1,1,-2,1,2].

So, it's different.

Wait, the example provided p=[0,1,4,2,3], which gives a=[1,1,-2,1,2], matching the input.

But the code outputs p=[0,1,3,2,4], which gives a=[1,1,-1,2,1], which is different from the input a.

So, the code is incorrect for this test case.

Wait, but the problem says that there may be multiple p satisfying a, and any one is acceptable, as long as it matches a.

But in this case, the code outputs p=[0,1,3,2,4], which gives a=[1,1,-1,2,1], but the input a is [1,1,-2,1,2], which is different.

So, this p does not match the input a.

Hence, the code is incorrect.

Wait, but the problem says that at least one valid p exists, so I need to output any p that satisfies the given a.

In this case, the code outputs p=[0,1,3,2,4], which does not satisfy the given a, so it's incorrect.

Hence, Correctness: False.

## Final Solution
To solve this problem, we need to reconstruct the permutation \( p \) from the given array \( a \), where each element \( a_i \) is calculated based on the MEX of the prefix of \( p \) up to index \( i \), minus the element \( p_i \).

### Approach

1. **Understanding MEX**:
   - MEX of a list is the smallest non-negative integer not present in the list.
   
2. **Reconstructing Permutation**:
   - We need to find the permutation \( p \) such that for each \( i \), \( a_i = \text{MEX}(p_1, p_2, \ldots, p_i) - p_i \).
   - We will iterate through the array \( a \) and determine \( p_i \) based on the MEX of the prefix and the value of \( a_i \).

3. **Efficient Calculation**:
   - Track the MEX value as we build the permutation.
   - Use a set to keep track of used numbers to ensure each number from 0 to n-1 is used exactly once.

### Solution Code

```python
def find_permutation(n, a):
    p = [-1] * n
    used = [False] * n
    mex = 0
    for i in range(n):
        # Calculate p_i based on a_i and current mex
        if a[i] > 0:
            p_i = mex - a[i]
            # Ensure p_i is within bounds and not used
            if 0 <= p_i < n and not used[p_i]:
                p[i] = p_i
                used[p_i] = True
                # Update mex
                while used[mex]:
                    mex += 1
            else:
                return None  # Invalid permutation
        else:
            # a_i <= 0, so p_i = mex - a_i
            p_i = mex - a[i]
           