Alright, I've got this problem to solve. Let's see what it's asking for. So, we have an array, and we need to determine if a given subarray is "interesting." An interesting array is one that can be divided into K parts, where K is greater than 1, and the bitwise XOR of each part is equal.

First, I need to understand what bitwise XOR means. XOR is a bitwise operation where the bits of the numbers are compared, and the result is 1 if the bits are different and 0 if they are the same. So, for example, 1 XOR 1 is 0, and 1 XOR 0 is 1.

Now, the problem is about subarrays. Given a subarray from index L to R, I need to check if it can be split into at least two parts where the XOR of each part is the same.

Let me think about how to approach this. One way to handle XOR problems is to use prefix XORs. If I compute the prefix XOR up to each index, then the XOR of any subarray from L to R can be found by XORing the prefix XOR at R with the prefix XOR at L-1.

So, let's define prefix XOR array, say X, where X[0] = 0, and X[i] = X[i-1] ^ A[i-1] for i from 1 to N.

Now, for a subarray from L to R, its XOR is X[R] ^ X[L-1].

But the problem is not just about the XOR of the entire subarray; it's about splitting the subarray into K parts with equal XOR.

I need to find if there exists a way to split the subarray into K parts where K > 1, and each part has the same XOR value.

Let me consider the XOR of the entire subarray from L to R, which is X[R] ^ X[L-1]. If I can split this subarray into K parts with equal XOR, then the XOR of each part should be equal to (X[R] ^ X[L-1]) / K. But since we're dealing with XOR, which is not directly divisible, I need to think differently.

Wait, actually, in XOR, if all parts have the same XOR value, say Y, then the total XOR of the subarray would be Y XOR Y XOR ... XOR Y (K times). If K is even, this would be 0, and if K is odd, this would be Y.

But wait, that doesn't seem right. Let's take an example.

Suppose we have a subarray with XOR Y, and we split it into K parts with each part having XOR Y. Then, the total XOR would be Y XOR Y XOR ... XOR Y, which is 0 if K is even, and Y if K is odd.

But in the problem, we need the entire subarray to be split into K parts with equal XOR, and K > 1.

So, if K is even, the total XOR would be 0, which means X[R] ^ X[L-1] should be 0.

If K is odd, the total XOR would be Y, which is the same as the XOR of each part.

But we don't know K in advance; we just need to check if such a K exists and is greater than 1.

Wait, maybe I need to think in terms of the number of times a particular XOR value appears in the prefix XOR array.

Let me consider that for a subarray from L to R, the XOR is X[R] ^ X[L-1]. If I can split this subarray into K parts with equal XOR, then there should be intermediate points where the cumulative XOR matches certain values.

This seems a bit complicated. Maybe there's a better way.

I recall that in problems involving splitting arrays into parts with equal sum or other properties, sometimes it's useful to look for repeating patterns or specific counts of prefix values.

Let me consider that for the subarray from L to R, I need to find if there are at least two points in between where the cumulative XOR matches.

Wait, perhaps I can look for the number of times a particular XOR value appears within the subarray.

Let me think differently. Suppose I fix L and R, and I compute the XOR from L to R. If this XOR is 0, then it's possible to split it into an even number of parts with equal XOR.

But that might not always be the case. Let's see an example.

In the first sample input:

5 5

1 1 2 3 0

Queries:

1 5: the entire array, which is [1,1,2,3,0]. XOR is 1^1^2^3^0 = 0^2^3^0 = 2^3^0 = 1^0 = 1. Wait, but in the explanation, it's split into [1], [1], [2,3,0], and 1=1=2^3^0=1, so it's possible.

Wait, but according to my earlier thought, if the total XOR is 1, and K is odd, then the total XOR should be Y, which is 1, but in this case, K=3, which is odd, and total XOR is 1, which matches.

In the second query, 2 4: [1,2,3]. XOR is 1^2^3=0. It's split into [1,2],[3], both with XOR 3 and 3, but wait, 1^2=3, and 3=3, so it's possible.

Wait, but according to my earlier thought, if the total XOR is 0, then K should be even, which in this case, K=2.

So, it seems that:

- If the total XOR from L to R is 0, then it's possible to split into an even number of parts with equal XOR.

- If the total XOR from L to R is Y != 0, then it's possible to split into an odd number of parts with each part having XOR Y.

But how do I check if such a split exists?

I need a way to verify if there are enough points within the subarray where the cumulative XOR allows for such a split.

Maybe I can look at the frequency of prefix XOR values within the subarray.

Let me consider that the prefix XOR array X, and for a subarray from L to R, I need to look at X[L-1] and X[R], and see if there are points in between where X[i] equals X[L-1] XOR some multiple of Y.

This seems too vague. Maybe I need to think about the difference between prefix XOR values.

Wait, perhaps I can use the fact that for the subarray from L to R to be split into K parts with equal XOR, the XOR of each part is Y, and the total XOR is K*Y (with the XOR operation).

But since XOR is not directly multiplicative, I need to think differently.

Let me look at the sample input again.

In the first query, L=1, R=5, subarray [1,1,2,3,0], total XOR is 1^1^2^3^0=1.

We can split it into [1], [1], [2,3,0], each with XOR 1.

So, the total XOR is 1 XOR 1 XOR 1 = 1, which matches the total XOR.

In the second query, L=2, R=4, subarray [1,2,3], total XOR is 1^2^3=0.

We can split it into [1,2],[3], each with XOR 3 and 3, but 3 XOR 3=0, which matches the total XOR.

In the third query, L=3, R=5, subarray [2,3,0], total XOR is 2^3^0=1.

If I split it into [2,3,0], which is only one part, but K must be greater than 1, so it's not possible.

In the fourth query, L=1, R=3, subarray [1,1,2], total XOR is 1^1^2=2.

Possible splits: [1],[1,2], which are 1 and 1^2=3, which are not equal.

Or [1,1],[2], which are 1^1=0 and 2, not equal.

So, not possible.

In the fifth query, L=3, R=4, subarray [2,3], total XOR is 2^3=1.

Possible splits: [2],[3], which are 2 and 3, not equal.

So, not possible.

From these examples, it seems that when the total XOR is 0, it's possible to split into an even number of parts with equal XOR, and when the total XOR is not 0, it's possible to split into an odd number of parts with each part having that XOR.

But I need a way to check if such a split exists efficiently.

Let me consider that for a subarray from L to R, with total XOR S = X[R] ^ X[L-1].

If S == 0, then it's possible to split into an even number of parts with each part having XOR 0.

But in the first sample input, for L=1 to R=5, S=1, which is not 0, and it was split into 3 parts, each with XOR 1.

Similarly, for L=2 to R=4, S=0, split into 2 parts, each with XOR 3.

Wait, but 3 XOR 3 = 0, which matches S=0.

So, in general, if S=0, we can split into even K parts with each part having XOR 0.

But in the first query, S=1, and it was split into 3 parts with each part having XOR 1.

So, perhaps the condition is that there exists at least one way to split the subarray into K parts (K>1) where the XOR of each part is equal.

I need to find a way to check this efficiently, especially since N and Q can be up to 2e5, so O(N + Q) time is required.

Let me think about the properties of XOR and how it behaves when splitting arrays.

Suppose I have a subarray from L to R, and I want to split it into K parts with equal XOR.

Let me denote the XOR of the entire subarray as S = X[R] ^ X[L-1].

If I can find K-1 splitting points between L and R such that the XOR of each segment between the splitting points is equal, then the subarray is interesting.

So, I need to find K-1 points where the cumulative XOR up to that point is equal to some multiple of the XOR value Y.

But since XOR is not additive, I need to think differently.

Wait, maybe I can look for the number of times a particular XOR value appears within the subarray.

Let me consider that for a subarray from L to R, with total XOR S.

If S == 0, then it's possible to split into an even number of parts with each part having XOR 0.

If S != 0, then it's possible to split into an odd number of parts with each part having XOR S.

But I need to confirm this.

In the first sample input, for L=1 to R=5, S=1, and it was split into 3 parts, each with XOR 1.

For L=2 to R=4, S=0, split into 2 parts, each with XOR 3.

So, it seems that when S=0, we can split into any even number of parts with XOR 0.

But how do I check if such a split exists?

I need a way to count the number of times a particular XOR value appears within the subarray.

Let me consider that for a subarray from L to R, I need to find if there exists at least one way to split it into K parts with equal XOR.

I can think of it in terms of the frequency of prefix XOR values.

Let me consider the prefix XOR array X.

For a subarray from L to R, its XOR is X[R] ^ X[L-1].

If I can split this subarray into K parts with each part having XOR Y, then Y XOR Y XOR ... XOR Y (K times) should equal S.

If K is even, Y XOR Y XOR ... XOR Y = 0, so S must be 0.

If K is odd, Y XOR Y XOR ... XOR Y = Y, so Y should equal S.

Therefore:

- If S == 0, then it's possible to split into any even K with each part having XOR 0.

- If S != 0, then it's possible to split into any odd K with each part having XOR S.

But I need to check if such a split exists, meaning that there are enough splitting points within the subarray to achieve this.

Wait, perhaps I can check if there are at least K-1 splitting points where the cumulative XOR matches the required value.

But I need to do this efficiently for multiple queries.

Let me consider precomputing the prefix XOR array and storing the indices where each XOR value appears.

Then, for each query from L to R, with S = X[R] ^ X[L-1], I can:

- If S == 0, check if there is at least one index in between L and R where X[i] == X[L-1].

If there is, then I can split the subarray into two parts: from L to i and from i+1 to R, each with XOR 0.

- If S != 0, check if there is at least one index in between L and R where X[i] == X[L-1] ^ S.

If there is, then I can split the subarray into two parts: from L to i with XOR S and from i+1 to R with XOR S.

But I need to ensure that K > 1.

Wait, actually, for S == 0, I need to split into even number of parts, each with XOR 0.

So, I need at least one splitting point where X[i] == X[L-1], meaning that the subarray from L to i has XOR 0.

Similarly, for S != 0, I need at least one splitting point where X[i] == X[L-1] ^ S, meaning that the subarray from L to i has XOR S, and the remaining part from i+1 to R also has XOR S.

So, in both cases, I need to check if there exists at least one index i in [L, R) where:

- If S == 0: X[i] == X[L-1]

- If S != 0: X[i] == X[L-1] ^ S

And i >= L.

Moreover, to ensure that K > 1, I need at least one splitting point.

But in the first sample input, for L=1 to R=5, S=1, and X[L-1]=0, so I need X[i]=0^1=1.

Looking at the prefix XOR array:

X[0]=0

X[1]=0^1=1

X[2]=1^1=0

X[3]=0^2=2

X[4]=2^3=1

X[5]=1^0=1

So, for S=1, I need X[i]=1, which is at indices 1,4,5.

Since L=1, R=5, I can choose i=1 or i=4.

If I choose i=1, then the parts are [1], [2,3,0], both with XOR 1.

If I choose i=4, then [1,1,2,3], [0], which are 1^1^2^3=1 and 0=0, which are not equal.

Wait, but according to the problem, K must be greater than 1, and the XOR of each part must be equal.

So, in this case, choosing i=1 gives two parts: [1] and [2,3,0], both with XOR 1.

Choosing i=4 gives [1,1,2,3] with XOR 1 and [0] with XOR 0, which are not equal.

So, only i=1 is a valid splitting point.

Hence, for S != 0, I need to ensure that there exists at least one i in [L, R) where X[i] == X[L-1] ^ S, and that the remaining part from i+1 to R also has XOR S.

But how do I check if the remaining part has XOR S?

Well, since the total XOR is S, and the first part from L to i has XOR S, then the remaining part from i+1 to R should have XOR S if and only if X[R] ^ X[i] == S.

Given that X[R] ^ X[L-1] == S, and X[i] ^ X[L-1] == S, then X[i] == X[L-1] ^ S.

And X[R] ^ X[i] == X[R] ^ (X[L-1] ^ S) == (X[R] ^ X[L-1]) ^ S == S ^ S == 0.

Wait, that doesn't make sense.

Wait, X[R] ^ X[i] should be equal to S if the remaining part from i+1 to R has XOR S.

But X[R] ^ X[i] is the XOR of the subarray from i+1 to R.

We want X[R] ^ X[i] == S.

Given that X[R] ^ X[L-1] == S, and X[i] ^ X[L-1] == S, then X[i] == X[L-1] ^ S.

Then, X[R] ^ X[i] == X[R] ^ (X[L-1] ^ S) == (X[R] ^ X[L-1]) ^ S == S ^ S == 0.

So, unless S == 0, X[R] ^ X[i] != S.

Wait, that can't be right.

Let me re-express this.

Given that X[R] ^ X[L-1] == S.

And for a splitting point i, X[i] ^ X[L-1] == Y, where Y is the XOR of the first part.

Then, the XOR of the remaining part from i+1 to R is X[R] ^ X[i].

We want X[i] ^ X[L-1] == Y and X[R] ^ X[i] == Y, so that both parts have XOR Y.

Therefore, X[R] ^ X[i] == X[i] ^ X[L-1], which implies X[R] ^ X[L-1] == 2*(X[i] ^ X[L-1]).

But XOR is not linear in that way.

Wait, maybe I need to think differently.

Let me consider that for the splitting point i, the XOR from L to i is Y, and the XOR from i+1 to R is also Y.

Given that the total XOR is S = Y XOR Y = S.

If S == 0, then Y XOR Y == 0, which is correct.

If S != 0, then Y XOR Y == S, which implies S == 0, but that's only possible if S == 0.

Wait, this seems contradictory.

I must be missing something.

Let me look back at the properties of XOR.

XOR is associative and commutative.

XOR of a segment from L to R is X[R] ^ X[L-1].

If I split the segment into two parts, from L to i and i+1 to R, then:

XOR_L_to_i = X[i] ^ X[L-1]

XOR_i1_to_R = X[R] ^ X[i]

I want both to be equal to Y.

So, X[i] ^ X[L-1] == Y and X[R] ^ X[i] == Y.

From the first equation, X[i] == Y ^ X[L-1]

Substitute into the second equation:

X[R] ^ (Y ^ X[L-1]) == Y

Which simplifies to X[R] ^ Y ^ X[L-1] == Y

Then, X[R] ^ X[L-1] == Y ^ Y == 0

So, X[R] ^ X[L-1] == 0, which implies that S == 0.

But in the first sample input, S == 1, which is not 0, and yet it's possible to split into parts with equal XOR.

Wait, that contradicts my earlier conclusion.

What's wrong here?

Let me recast this.

If I have two parts, each with XOR Y, then the total XOR is Y ^ Y = 0.

But in the first sample input, S == 1, which is not 0, so K cannot be 2.

In the first sample input, it's split into three parts, K=3, which is odd, and total XOR is Y ^ Y ^ Y = Y, which matches S == 1.

So, for K odd, total XOR is Y, and for K even, total XOR is 0.

Hence, when S == 0, K must be even, and when S != 0, K must be odd.

Now, to check if such a split exists, I need to ensure that:

- If S == 0, there exists at least one splitting point where the XOR of the first part is 0, and the remaining part also has XOR 0.

- If S != 0, there exists at least one splitting point where the XOR of the first part is S, and the remaining part also has XOR S.

But from the earlier derivation, if S == 0, then for a splitting point i, X[i] == X[L-1], and X[R] ^ X[i] == 0.

Given X[i] == X[L-1], then X[R] ^ X[L-1] == 0, which matches S == 0.

Similarly, if S != 0, for a splitting point i, X[i] == X[L-1] ^ S, and X[R] ^ X[i] == S.

Given X[i] == X[L-1] ^ S, then X[R] ^ X[i] == X[R] ^ (X[L-1] ^ S) == (X[R] ^ X[L-1]) ^ S == S ^ S == 0, which should equal S.

But S ^ S == 0, which should equal S only if S == 0.

This is a contradiction.

Hence, my earlier assumption must be incorrect.

I need to think differently.

Let me consider that for S != 0, to split into K parts with each part having XOR Y, where K is odd and Y == S.

Then, the total XOR is Y ^ Y ^ ... ^ Y (K times) == Y, which matches S.

For S == 0, to split into K parts with each part having XOR Y, where K is even and Y == 0.

Then, the total XOR is 0 ^ 0 ^ ... ^ 0 == 0, which matches S == 0.

But in practice, for S != 0, I need to check if there exists at least one splitting point where the XOR of the first part is S, and the remaining part also has XOR S.

But according to the earlier derivation, that's only possible if S == 0.

This seems problematic.

Let me consider another approach.

Suppose I fix L and R, and compute S = X[R] ^ X[L-1].

If S == 0, then I need to split the subarray into an even number