Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a string consisting of lowercase Latin letters, and I need to partition this string into some substrings such that none of these substrings is a palindrome. A palindrome is a string that reads the same forwards and backwards, like "racecar" or "abccba".

First, I need to understand what a partition is. It's an ordered sequence of strings that, when concatenated, form the original string. So, for example, if I have the string "abc", possible partitions could be ["a", "b", "c"], ["ab", "c"], or ["a", "bc"], etc.

My task is to find at least one way to partition the string into substrings where none of them is a palindrome. If such a partition exists, I should print "YES", followed by the number of parts in the partition, and then the parts themselves. If no such partition exists, I should print "NO".

Looking at the examples provided:

1. For "sinktheyacht", which is not a palindrome, so I can just take the whole string as one part since it's not a palindrome. So, "YES" followed by 1 and then the string itself.

2. For "lllllllll", every possible substring is a palindrome (since all characters are 'l'), so there's no way to partition it into non-palindromic substrings. Hence, "NO".

3. For "uwuowouwu", it's a bit trickier. The whole string is not a palindrome, so I could take it as one part, but in the example, it's partitioned into three parts: "uw", "uow", and "ouwu". Each of these is not a palindrome, so it's a valid partition.

From this, I can see that sometimes taking the whole string as one part works if it's not a palindrome, but when the whole string is a palindrome or consists of repeated characters, I need to find a way to split it into non-palindromic substrings.

Now, I need to think about the conditions under which such a partition exists.

First, if the entire string is not a palindrome, I can simply take it as one part. So, the easy case is when the string is not a palindrome.

However, if the entire string is a palindrome, I need to see if I can split it into smaller substrings that are not palindromes.

But, if all possible substrings are palindromes, which would only happen if all characters are the same, like in the second example, then it's impossible to partition it into non-palindromic substrings.

Wait, is that always true? Let's think about a string like "aaa". The whole string is a palindrome, any substring is a palindrome. So, in this case, it's impossible to partition it into non-palindromic substrings.

Another example: "aabaa". This is a palindrome, but if I split it into "a", "ab", "aa", then "a" is a palindrome, so this partition is invalid. Alternatively, "aab", "aa" – "aab" is not a palindrome, but "aa" is a palindrome, so still invalid. Another way: "a", "a", "b", "a", "a" – but each "a" is a palindrome, so invalid.

So, for strings where all characters are the same, it's impossible to partition them into non-palindromes.

What about strings like "abba"? It's a palindrome, but if I split it into "ab", "b", "a", then "ab" is not a palindrome, "b" is a palindrome, "a" is a palindrome, so invalid.

Another split: "abb", "a" – "abb" is not a palindrome, "a" is a palindrome, so invalid.

Is there any way to split "abba" into non-palindromic substrings? Let's try "ab", "ba" – both are not palindromes, so this would be a valid partition.

Ah, so in this case, it's possible.

So, for some palindromic strings, it's possible to partition them into non-palindromic substrings, and for others, it's not.

I need to find a general way to determine when such a partition exists and how to find it.

Let me think about the properties of the string.

If the string has at least two different characters, perhaps I can use that to my advantage.

For example, in "abba", I can split it into "ab" and "ba", both of which are not palindromes.

In "aabb", I can split it into "aa" and "bb", but "aa" and "bb" are palindromes, so invalid.

Alternatively, "aab", "b" – "aab" is not a palindrome, "b" is a palindrome, invalid.

"aa", "b", "b" – all "aa" and "b"s are palindromes, invalid.

Wait, "aab", "b" – "aab" is not a palindrome, "b" is a palindrome, so invalid.

Is there any way to split "aabb" into non-palindromic substrings?

How about "a", "ab", "b" – "a" is a palindrome, invalid.

"a", "abb" – "a" is a palindrome, invalid.

"aa", "bb" – both are palindromes, invalid.

"aab", "b" – "aab" is not a palindrome, "b" is a palindrome, invalid.

"a", "a", "b", "b" – all are palindromes, invalid.

Seems like it's impossible for "aabb".

But why is that? Because all 'a's and 'b's are in pairs, and any substring that includes only 'a's or only 'b's is a palindrome.

So, perhaps, if the string consists of repeated blocks of the same character, it's impossible to partition into non-palindromic substrings.

On the other hand, if there's a mix of characters in a way that allows creating substrings that are not palindromes, then it's possible.

So, maybe the key is to check if the string contains at least two different characters.

If it does, then it's possible to create substrings that are not palindromes by ensuring that the substring has different characters in corresponding positions.

Wait, but that might not always be sufficient.

Wait, in the earlier example, "abba" has different characters and can be partitioned into "ab" and "ba", which are not palindromes.

While "aabb" has different characters but seems impossible to partition into non-palindromic substrings.

Wait, perhaps it's about the frequency of characters.

Wait, no, "aabb" has 'a' twice and 'b' twice.

Is there a general rule here?

Let me think differently.

Suppose the string has all characters identical. Then, any substring is a palindrome, so it's impossible to partition into non-palindromic substrings.

If the string has at least two different characters, maybe it's always possible to partition into non-palindromic substrings.

Wait, is that true?

Take "ab": it's not a palindrome, so I can take it as one part.

Take "aab": split into "aab" (not palindrome) and "b" (palindrome), which is invalid.

Wait, "aab" is not a palindrome, but if I take it as one part, it's fine.

Wait, no, in "aab", "aab" is not a palindrome, so it's acceptable.

Wait, "aab" reversed is "baa", which is different from "aab", so yes, it's not a palindrome.

So, in this case, taking the whole string as one part is acceptable.

But in "aabb", "aabb" is not a palindrome ("baab" is the reverse), so taking the whole string as one part is acceptable.

Wait, is "aabb" a palindrome? Wait, "aabb" reversed is "bbaa", which is different, so "aabb" is not a palindrome.

So, in this case, taking the whole string as one part is acceptable.

Wait, but earlier I thought it was impossible, but actually, "aabb" is not a palindrome, so taking it as one part is fine.

Wait, perhaps I made a mistake there.

So, "aabb" is not a palindrome, so I can take it as one part and satisfy the condition.

Similarly, "aa" is a palindrome, so I cannot take it as one part.

But if I have "aaa", it's a palindrome, and any substring is a palindrome, so it's impossible to partition it into non-palindromic substrings.

Wait, but "aabb" is not a palindrome, so it's acceptable as one part.

So, perhaps the general rule is:

- If the entire string is not a palindrome, then take it as one part.

- If the entire string is a palindrome, then check if it's possible to split it into smaller non-palindromic substrings.

And to check if it's possible to split a palindromic string into non-palindromic substrings, perhaps I need to ensure that at least one of the substrings is not a palindrome.

But, if the string is palindromic and consists of repeated characters, like "aaa", then any split will have palindromic substrings.

So, maybe the condition is that if the string is palindromic and consists of more than one distinct character, it might be possible to split it into non-palindromic substrings.

Wait, but in "abba", which is palindromic and has two distinct characters, I can split it into "ab" and "ba", both of which are not palindromes.

So, perhaps, for palindromic strings with at least two distinct characters, it's possible to split them into non-palindromic substrings.

While for palindromic strings with only one distinct character, it's impossible.

Is that the general rule?

Let me test this with some examples.

Example 1: "abba" – palindromic, two distinct characters – possible to split into "ab" and "ba".

Example 2: "aabb" – not palindromic, two distinct characters – can take the whole string.

Example 3: "aaa" – palindromic, one distinct character – impossible to split into non-palindromic substrings.

Example 4: "abcba" – palindromic, three distinct characters – can split into "abc" and "ba".

"abc" is not a palindrome, "ba" is not a palindrome.

Example 5: "racecar" – palindromic, multiple distinct characters – can split into "rac" and "ecar".

"rac" is not a palindrome, "ecar" is not a palindrome.

So, in all these cases, if the string is palindromic and has more than one distinct character, I can split it into non-palindromic substrings.

But how?

Is there a general way to do this?

One approach could be to split the string into two parts: one that is not a palindrome and the remaining part.

But I need to ensure that both parts are not palindromes.

Wait, in "abba", splitting into "ab" and "ba" works.

In "abcba", splitting into "abc" and "ba" works.

In "racecar", splitting into "rac" and "ecar" works.

So, perhaps, for a palindromic string with multiple distinct characters, I can always split it into two parts, each of which is not a palindrome.

But is this always possible?

Let me consider a string like "abcdcba". It's palindromic, with multiple distinct characters.

Splitting into "abc" and "dcba":

"abc" is not a palindrome, "dcba" is not a palindrome.

So, this works.

Another example: "aabbccbaa".

It's palindromic, with multiple distinct characters.

Splitting into "aabbcc" and "baa":

"aabbcc" is not a palindrome, "baa" is not a palindrome.

Wait, "baa" reversed is "aab", which is different from "baa", so yes, it's not a palindrome.

So, seems like splitting into two parts works in these cases.

But, is there a case where splitting into two parts doesn't work, but splitting into more parts does?

Let's consider "abccba".

It's palindromic, with multiple distinct characters.

Splitting into "abc" and "cba":

"abc" is not a palindrome, "cba" is not a palindrome.

So, this works.

Another way: "ab", "cc", "ba".

But "cc" is a palindrome, so invalid.

So, splitting into two parts seems safer.

Wait, in the third example in the problem statement, "uwuowouwu", which is palindromic, split into "uw", "uow", "ouwu".

"uw" is not a palindrome, "uow" is not a palindrome, "ouwu" is not a palindrome.

So, it's possible to split into multiple parts.

But in practice, splitting into two parts seems sufficient.

So, perhaps, for palindromic strings with multiple distinct characters, splitting into two parts, each of which is not a palindrome, is possible.

But I need to ensure that both parts are not palindromes.

How can I ensure that?

Well, in the case of "abba", splitting into "ab" and "ba" works.

In "aabbccbaa", splitting into "aabbcc" and "baa" works.

So, perhaps, splitting at a position where the two parts are not palindromes.

But how do I choose where to split?

One approach could be to split the string into two parts where the first part starts with one character and ends with a different one, and the second part starts with a different character than the first part ends with.

Wait, that might be too vague.

Let me think differently.

Suppose I have a palindromic string with at least two distinct characters.

Then, there must be at least two positions where the characters are different.

Because if all characters were the same, it would consist of only one distinct character.

So, in a palindromic string with multiple distinct characters, I can find positions where the characters differ.

Using this, perhaps I can split the string into two parts where each part is not a palindrome.

How?

Well, if I can ensure that in each part, there is at least one pair of characters that are not equal when compared symmetrically, then the part is not a palindrome.

Wait, that might be too complicated.

Maybe a simpler approach is to choose a split point where the two parts are not equal to their reverses.

But how do I find such a split point?

Alternatively, perhaps I can always split the string into two parts where each part has at least two characters, and they are not palindromes.

Wait, but even a two-character string can be a palindrome, like "aa".

So, that doesn't help.

Wait, if I split the string into two parts where each part has at least two different characters, then each part is not a palindrome.

But, in some cases, even if a part has two different characters, it could still be a palindrome, like "abba".

So, that's not sufficient.

Wait, perhaps if I split the string into two parts where each part contains at least one pair of characters that are different when compared symmetrically.

But this seems too involved.

Maybe there's a simpler way.

Let me consider that for a palindromic string with multiple distinct characters, I can always find a split point such that neither part is a palindrome.

But how do I find that split point?

Alternatively, perhaps I can split the string into two parts where one part is not a palindrome, and the other part can be handled separately.

Wait, but I need both parts to not be palindromes.

So, maybe I can first check if the string is a palindrome.

If it's not, then take the whole string as one part.

If it is a palindrome, then check if it consists of only one distinct character.

If it does, then it's impossible to partition into non-palindromic substrings.

If it has at least two distinct characters, then it's possible to split it into two parts that are not palindromes.

But, is this always true?

Let me try to find a counterexample.

Consider the string "abba".

It's a palindrome with two distinct characters.

Splitting into "ab" and "ba" works, as neither is a palindrome.

Another example: "abcba".

Splitting into "abc" and "ba" works.

Another example: "aabbccbaa".

Splitting into "aabbcc" and "baa" works.

Seems fine.

Another example: "abcdcba".

Splitting into "abcd" and "cba" works.

Both are not palindromes.

Seems good.

Now, what about a string like "abccba"?

Splitting into "abc" and "cba" works.

Another split: "ab", "cc", "ba" – but "cc" is a palindrome, so invalid.

So, splitting into two parts seems better.

What about "abracadabra"?

Wait, "abracadabra" is not a palindrome, so I can take the whole string as one part.

Wait, is "abracadabra" a palindrome? No, because reversing it gives "arabbadacarba", which is different.

So, I can take it as one part.

Ok, so the general approach seems to be:

- If the string is not a palindrome, output "YES" and print the whole string as one part.

- If the string is a palindrome:

- If it consists of only one distinct character, output "NO".

- If it consists of at least two distinct characters, output "YES" and split it into two parts, each of which is not a palindrome.

But, how do I ensure that both parts are not palindromes?

Well, in practice, for palindromic strings with multiple distinct characters, splitting into two parts where each part has at least two characters seems to work, as in the examples above.

But, to be safe, I should choose split points where the parts are not palindromes.

How can I do that?

One way is to iterate through possible split points and check if both parts are not palindromes.

But, since the string can be up to 10^6 characters, and there are up to 10^4 test cases, I need an efficient solution.

Iterating through all possible split points for each test case would be too slow.

So, I need a smarter way.

Let me think about the properties of palindromes.

In a palindromic string, characters are symmetric around the center.

So, if I split the string into two parts, say at position k, then the first part is s[0:k] and the second part is s[k:n], where n is the length of the string.

For these parts to not be palindromes, their reverses should not match themselves.

Now, in a palindromic string, s[0:k] is the reverse of s[n-k:n], because of the palindrome property.

So, s[0:k] == s[n-k:n][::-1].

Wait, but s is a palindrome, so s == s[::-1].

So, s[0:k] == s[n-k-1:n-1], which is s[n-k:n][::-1].

Wait, perhaps I need to think differently.

Let me consider that in a palindrome, the first half mirrors the second half.

So, if I split the string into two parts, each part will have a mirror image in the other part.

But, I need to ensure that neither part is a palindrome on its own.

Given that, perhaps splitting at the midpoint would work.

For example, in "abba", splitting into "ab" and "ba" works.

In "abcba", splitting into "abc" and "ba" works.

In "aabbccbaa", splitting into "aabbcc" and "baa" works.

So, splitting at or around the midpoint seems to work.

But, in the case of "abccba", splitting into "abc" and "cba" works.

Wait, "cba" is not a palindrome, and "abc" is not a palindrome.

So, seems fine.

But, is there a general rule for choosing the split point?

Perhaps splitting the string into two almost equal parts would work, as long as neither part is a palindrome.

Given that the string is a palindrome and has multiple distinct characters, it's likely that splitting it into two parts where each part has a mix of characters will result in non-palindromic parts.

But, to be sure, maybe I can choose a split point where the first part has at least one pair of characters that are different when compared symmetrically within that part.

But, this seems complicated.

Alternatively, perhaps I can always split the string into two parts where each part has a length of at least 2 and is not a palindrome.

But, as mentioned earlier, even a two-character string like "aa" is a palindrome.

So, that doesn't help.

Wait, but in "abba", splitting into "ab" and "ba" works, and both have length 2 and are not palindromes.

In "abcba", splitting into "abc" and "ba" works, where "abc" has length 3 and "ba" has length 2.

So, perhaps, for palindromic strings with multiple distinct characters, splitting into two parts where one part has length at least 3 and the other has length at least 2 works.

But, is this always true?

Let's consider "abccba".

Splitting into "abc" and "cba" works, both have length 3.

Alternatively, splitting into "ab" and "ccba" – "ab" is not a palindrome, "ccba" is not a palindrome.

So, that works too.

So, perhaps, splitting into two parts where one part has length at least 2 and the other has length at least the remaining characters works.

But, I need to ensure that neither part is a palindrome.

Given that the whole string is a palindrome, and I'm splitting it into two parts, is there a general way to choose the split point to ensure both parts are not palindromes?

Let me consider that if I split the string into two parts where one part is not a palindrome, and the other part is also not a palindrome.

Given that the whole string is a palindrome, and I'm splitting it into two parts, I need to choose the split point such that neither part is a palindrome.

But, in practice, for strings with multiple distinct characters, this seems possible.

But, to generalize, perhaps I can always split the string into two parts where one part has a length that is not a multiple of the period of the palindrome.

Wait, that might be too complicated.

Alternatively, perhaps I can use the fact that in a palindrome with multiple distinct characters, there must be at least one position where the character changes, and use that to choose the split point.

Wait, for example, in "abba", the characters change from 'a' to 'b', so I can split it into "ab" and "ba", both of which have the characters changing, hence not palindromes.

Similarly, in "abcba", the characters change from 'a' to 'b' to 'c', so splitting into "abc" and "ba" works.

In "aabbccbaa", splitting into "aabbcc" and "baa" works.

" a a b b c c b a a "

" a a b b c c " and " b a a "

" a a b b c c " reversed is " c c b b a a ", which is different from " a a b b c c ", so " a a b b c c " is not a palindrome.

" b a a " reversed is " a a b ", which is different from " b a a ", so it's not a palindrome.

So, both parts are not palindromes.

Seems fine.

So, perhaps, for palindromic strings with multiple distinct characters, splitting into two parts where one part has a length that is not a multiple of the palindrome's period ensures that it's not a palindrome.

But, I'm not sure about that.

Alternatively, perhaps I can always split the string into two parts where one part is not a palindrome by ensuring that the first character and the last character of that part are different.

Wait, in "abba", splitting into "ab" and "ba", the first part "ab" has 'a' and 'b' different, and the second part "ba" has 'b' and 'a' different.

Similarly, in "abcba", splitting into "abc" and "ba", "abc" has 'a' and 'a' (first and last characters), but "ba" has 'b' and 'a' different.

Wait, but "abc" has 'a' and 'c' as first and last characters, which are different.

So, in both parts, the first and last characters are different, which makes them not palindromes.

Is that a general rule?

That is, if the first and last characters of a string are different, then it's not a palindrome.

Yes, that's true because for a string to be a palindrome, the first and last characters must be the same, and so on for the inner characters.

So, if the first and last characters are different, it's definitely not a palindrome.

Therefore, if I can split the palindromic string into two parts where both parts have different first and last characters, then both parts are not palindromes.

So, how can I ensure that both parts have different first and last characters?

Given that the whole string is a palindrome, the first and last characters are the same.

So, if I split the string into two parts, say s1 and s2, where s1 = s[0:k] and s2 = s[k:n], then:

- The first character of s1 is s[0], and the last character is s[k-1].

- The first character of s2 is s[k], and the last character is s[n-1].

Given that s is a palindrome, s[0] == s[n-1], s[1] == s[n-2], and so on.

So, in s1, s[0] == s[n-1] == s[k], and s[k-1] == s[n-k].

Wait, but s[k-1] should be equal to s[n-k], because s is a palindrome.

Wait, let's see:

s[k-1] == s[n - k]

Because s is a palindrome, s[i] == s[n - i - 1].

So, s[k-1] == s[n - k]

Therefore, in s1, first character is s[0], last is s[k-1].

In s2, first character is s[k], last is s[n-1].

But s[0] == s[n-1], and s[k] == s[n - k - 1].

Wait, this is getting complicated.

Let me think differently.

If I choose k such that s[0] != s[k-1], then s1 is not a palindrome because its first and last characters are different.

Similarly, if s[k] != s[n-1], then s2 is not a palindrome.

But, since s is a palindrome, s[0] == s[n-1] == s[k], and s[k-1] == s[n - k].

Wait, this seems messy.

Is there a better way to choose k?

Let me consider that in a palindromic string with multiple distinct characters, there must be at least one position where s[i] != s[0].

Because if all characters were the same, it would consist of only one distinct character.

So, I can find the smallest k such that s[k] != s[0], and split the string into s[0:k+1] and s[k+1:n].

Now, in s[0:k+1], the first character is s[0], and the last character is s[k], which is different from s[0], so s[0:k+1] is not a palindrome.

In s[k+1:n], the first character is s[k+1], and the last character is s[n-1] == s[0].

If s[k+1] != s[0], then s[k+1:n] is not a palindrome.

But, in a palindrome, s[k+1] == s[n - k - 2].

Wait, this is getting too tangled.

Perhaps I should look for a different approach.

Let me consider that for palindromic strings with multiple distinct characters, I can always find a split point where both parts are not palindromes.

Given that, perhaps I can just choose to split the string into two parts where one part has a length that is not a multiple of some factor that would make it a smaller palindrome.

But, this seems too vague.

Alternatively, perhaps I can always split the string into two parts where one part is known to be not a palindrome based on the positions of different characters.

But, this seems too involved.

Let me consider that in a palindromic string with multiple distinct characters, there must be at least two positions where the characters differ.

Using this, perhaps I can choose a split point between these positions.

Wait, for example, in "abba", positions 0 and 1 have different characters.

Splitting between positions 1 and 2 gives "abb" and "a".

"abb" is not a palindrome, "a" is a palindrome, which is invalid.

Alternatively, splitting between positions 0 and 1 gives "a" and "bba", which is invalid because "a" is a palindrome.

So, that doesn't work.

Wait, perhaps I need to choose a different split point.

In "abba", splitting between positions 2 and 3 gives "abb" and "a", which is invalid.

Wait, earlier I thought splitting into "ab" and "ba" works, but according to this approach, splitting at k=2 gives "abb" and "a", which is invalid.

So, perhaps this approach isn't perfect.

Alternatively, maybe I should choose k such that s[k] != s[0].

In "abba", s[0] = 'a', s[1] = 'b' != 'a', so k=1.

Then, s[0:1] = "a", which is a palindrome.

So, that doesn't work.

Wait, perhaps I need to choose k such that s[k] != s[0], and then take s[0:k+1] and s[k+1:n].

In "abba", k=1, s[0:2] = "ab", which is not a palindrome, and s[2:4] = "ba", which is not a palindrome.

So, that works.

Wait, but earlier I thought s[0:1] = "a", which is a palindrome, but actually, with k=1, s[0:2] = "ab", which is not a palindrome.

Yes, that's correct.

So, perhaps, for palindromic strings with multiple distinct characters, I can find the smallest k such that s[k] != s[0], and then split into s[0:k+1] and s[k+1:n].

Then, check if both parts are not palindromes.

If they are, then this is a valid partition.

But, is this always true?

Let's see.

Take "abcba".

s[0] = 'a', s[1] = 'b' != 'a', so k=1.

Then, s[0:2] = "ab", which is not a palindrome, and s[2:5] = "cba", which is not a palindrome.

So, this works.

Another example: "abccba".

s[0] = 'a', s[1] = 'b' != 'a', so k=1.

s[0:2] = "ab", not a palindrome, s[2:6] = "ccba", not a palindrome.

Good.

Another example: "aabbccbaa".

s[0] = 'a', s[1] = 'a' == 'a', s[2] = 'b' != 'a', so k=2.

s[0:3] = "aab", not a palindrome, s[3:10] = "bccbaa", not a palindrome.

Good.

Another example: "abacaba".

s[0] = 'a', s[1] = 'b' != 'a', so k=1.

s[0:2] = "ab", not a palindrome, s[2:7] = "acaba", which is a palindrome.

Wait, "acaba" is a palindrome.

So, in this case, s[2:7] = "acaba", which is a palindrome.

So, this approach fails here.

So, what to do in this case?

I need to find a different split point.

Is there another k where s[k] != s[0], and splitting there results in both parts not being palindromes.

In "abacaba", s[0] = 'a', s[1] = 'b' != 'a', so k=1.

s[0:2] = "ab", not a palindrome, s[2:7] = "acaba", which is a palindrome.

Not good.

Another k where s[k] != s[0] is k=1, which we already tried.

Another is k=3, s[3] = 'c' != 'a'.

So, split into s[0:4] = "abac" and s[4:7] = "aba".

"abac" is not a palindrome, "aba" is a palindrome.

Still invalid.

Another k is k=5, s[5] = 'c' != 'a'.

Split into s[0:6] = "abacab" and s[6:7] = "a".

"abacab" is not a palindrome, "a" is a palindrome.

Invalid.

Another k is k=1, which we already tried.

So, it seems that in this case, splitting into two parts where both are not palindromes is not possible.

But, according to my earlier assumption, it should be possible.

Wait, maybe I need to split into more than two parts.

For "abacaba", which is a palindrome with multiple distinct characters, perhaps splitting into two parts isn't sufficient, and I need to split into three parts.

For example, split into "aba", "c", "aba".

But "aba" is a palindrome, and "c" is a palindrome, so invalid.

Another split: "ab", "a", "c", "aba".

All of these have "ab" and "c" are not palindromes, but "aba" is a palindrome, so invalid.

Another split: "ab", "aca", "ba".

"ab" is not a palindrome, "aca" is a palindrome, invalid.

Another split: "a", "bac", "aba".

"a" is a palindrome, invalid.

Seems tricky.

Is there any way to split "abacaba" into non-palindromic substrings?

Let's try splitting into "aba", "c", "a", "b", "a".

But "aba", "c", "a", "b", "a" all have palindromic parts.

Another split: "ab", "ac", "aba".

"ab" is not a palindrome, "ac" is not a palindrome, "aba" is a palindrome, invalid.

Another split: "ab", "aca", "ba".

"ab" not palindrome, "aca" palindrome, invalid.

Another split: "abc", "a", "ba".

"abc" not palindrome, "a" palindrome, invalid.

Another split: "abac", "aba".

"abac" not palindrome, "aba" palindrome, invalid.

Another split: "abaca", "ba".

"abaca" is a palindrome ("a c a b a", which is not a palindrome? Wait, "abaca" reversed is "acaba", which is different, so "abaca" is not a palindrome.

Wait, is "abaca" a palindrome?

"abaca" reversed is "acaba", which is different from "abaca", so it's not a palindrome.

Similarly, "ba" is not a palindrome.

So, splitting into "abaca" and "ba" works.

Both are not palindromes.

Great, so in this case, splitting at k=5 works.

s[0:5] = "abaca", not a palindrome, s[5:7] = "ba", not a palindrome.

So, it's possible.

Earlier, I mistakenly thought that s[2:7] = "acaba" is a palindrome, which it is.

But, by choosing a different split point, I can make both parts not palindromes.

So, perhaps, in cases where splitting at the first possible k doesn't work, I can look for a different k.

But, in practice, for strings with multiple distinct characters, there should always be a way to split them into two non-palindromic parts.

But, to implement this efficiently, I need a way to choose a suitable k.

In the previous example, k=5 worked, but k=2 didn't.

So, perhaps, choosing k to be the position where s[k] != s[0], and ensuring that s[k+1:n] is not a palindrome.

But, checking whether s[k+1:n] is a palindrome would require additional computations, which might be too slow for large strings.

Alternatively, perhaps I can choose k to be the position where s[k] != s[0], and s[k] != s[n-1].

But, since s is a palindrome, s[k] == s[n - k - 1].

Wait, s[k] != s[0], but s[n - k - 1] == s[k].

So, it's getting complicated.

Maybe I need to accept that finding such a k isn't straightforward and think of a different approach.

Let me consider that for palindromic strings with multiple distinct characters, I can always split the string into two parts where each part contains at least one pair of characters that are different when compared symmetrically within that part.

But, implementing this check is non-trivial and inefficient for large strings.

Alternatively, perhaps I can always split the string into two parts where one part has an odd length and the other has an even length, ensuring that neither is a palindrome.

But, palindromes can have both odd and even lengths.

So, that doesn't help.

Wait, perhaps I can use the fact that a string with all characters the same is the only case where it's impossible to split into non-palindromic substrings.

In other words, if the string consists of only one distinct character, then it's impossible.

Otherwise, it's possible.

But, earlier, in "abacaba", it was tricky, but eventually, I found a way to split it into two parts that are not palindromes.

So, perhaps, the general rule is:

- If the string is not a palindrome, output "YES" and take the whole string as one part.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Otherwise, output "YES" and split the string into two parts where each part is not a palindrome.

And to implement this efficiently, I can:

- Check if the string is a palindrome.

- If it's not, output "YES" and the whole string.

- If it is a palindrome, check if all characters are the same.

- If they are, output "NO".

- If they aren't, find the smallest k such that s[k] != s[0], and split into s[0:k+1] and s[k+1:n].

- Check if both parts are not palindromes.

- If they are, output them.

- If not, try a different k.

But, iterating over possible k values is inefficient for large strings.

Is there a way to choose k such that both parts are not palindromes in constant time or O(n) time?

Let me think about the properties of palindromes.

In a palindromic string, s[i] == s[n - i - 1] for all i.

So, if I split the string into two parts, s1 = s[0:k] and s2 = s[k:n], then s1 is not a palindrome if s[0] != s[k-1], and s2 is not a palindrome if s[k] != s[n-1].

But, since s is a palindrome, s[k] == s[n - k - 1], and s[0] == s[n-1].

So, s[k] == s[n - k - 1] == s[k], which is always true.

Wait, this isn't helping.

Alternatively, perhaps I can choose k such that s[k] != s[0], and s[k+1] != s[n - k - 2].

But, this is getting too involved.

Maybe I need to accept that for palindromic strings with multiple distinct characters, splitting into two parts where one part includes the differing characters ensures that both parts are not palindromes.

Given that, perhaps I can choose k to be the position of the first character that