Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an integer n and three strings a, b, and c, each of length n. I need to determine if there exists a template t, which is also a string of length n, consisting of lowercase and/or uppercase Latin letters, such that strings a and b match the template t, while string c does not match it.

First, I need to understand what it means for a string to match the template t. The problem explains that:

- If the i-th letter of the template is lowercase, then the i-th character of the string must be exactly the same as the i-th character of the template.

- If the i-th letter of the template is uppercase, then the i-th character of the string must be different from the lowercase version of the i-th character of the template.

Also, for string c, it should not match the template t, meaning that there should be at least one position where the matching condition fails.

My task is to find if such a template t exists for the given a, b, and c.

Let me try to rephrase the problem in my own words to make sure I understand it correctly. I need to create a template t where:

- For each position i, if t[i] is lowercase, then a[i] and b[i] must be equal to t[i], while c[i] must not be equal to t[i].

- If t[i] is uppercase, then a[i] and b[i] must be different from the lowercase version of t[i], while c[i] must either be equal to the lowercase version of t[i] or not satisfy the condition, meaning c doesn't match the template.

Wait, actually, for c to not match the template, at least one position must fail the condition, whether it's because t[i] is lowercase and c[i] doesn't match, or t[i] is uppercase and c[i] equals the lowercase version of t[i].

But I need to find a single template t that makes a and b match, and c not match.

I need to find if there's a way to set t such that:

- For a and b, they both match t.

- For c, it does not match t.

I need to check for each position i from 1 to n, and decide whether to make t[i] lowercase or uppercase, based on the characters in a, b, and c at position i.

Let me consider each position independently.

For each position i:

- If I choose t[i] to be lowercase, then:

  - a[i] must equal t[i].

  - b[i] must equal t[i].

  - c[i] must not equal t[i].

  So, for t[i] to be lowercase, a[i] and b[i] must be equal, and c[i] must be different from a[i].

  Wait, since a[i] and b[i] must both equal t[i], they must be equal to each other. And c[i] must not equal t[i], which is a[i] (since t[i] = a[i] = b[i]).

  So, in this case, if a[i] == b[i], and c[i] != a[i], then I can choose t[i] to be a[i] in lowercase.

- If I choose t[i] to be uppercase, then:

  - a[i] must not equal the lowercase version of t[i].

  - b[i] must not equal the lowercase version of t[i].

  - c[i] must equal the lowercase version of t[i].

  Wait, no. For t[i] uppercase:

  - a[i] must not equal t[i].lowercase.

  - b[i] must not equal t[i].lowercase.

  - For c to not match, c[i] must equal t[i].lowercase.

  Wait, actually, for c to not match, it must fail the condition for uppercase t[i], which means c[i] equals t[i].lowercase.

  So, for t[i] uppercase:

  - a[i] != t[i].lowercase.

  - b[i] != t[i].lowercase.

  - c[i] == t[i].lowercase.

  Therefore, t[i] can be any uppercase letter whose lowercase version is not equal to a[i] and b[i], and c[i] equals that lowercase version.

This seems a bit complicated. Maybe I can think of it differently.

I need to ensure that for a and b, they both match t, and c does not match t.

So, for each position i:

- If a[i] and b[i] are equal:

  - If c[i] is different from a[i], then I can set t[i] to be a[i] in lowercase, and c[i] != t[i], so c doesn't match.

  - If c[i] is equal to a[i], then I cannot set t[i] to lowercase because c would match, which is not what I want. So, in this case, I need to set t[i] to uppercase.

    - For t[i] uppercase, a[i] and b[i] must not equal t[i].lowercase.

    - But since a[i] == b[i], and c[i] == a[i], setting t[i] uppercase would require that a[i] != t[i].lowercase, and c[i] == t[i].lowercase.

    - Wait, but c[i] == a[i], so if a[i] != t[i].lowercase, and c[i] == t[i].lowercase, that would mean a[i] != c[i], but c[i] == a[i], which is a contradiction.

    - Therefore, if a[i] == b[i] == c[i], I cannot set t[i] to uppercase because a[i] != t[i].lowercase would require t[i].lowercase != a[i], but c[i] == a[i] == t[i].lowercase, which contradicts a[i] != t[i].lowercase.

    - So, in this case, it's impossible to find such a t for this position.

- If a[i] and b[i] are different:

  - I need to find a t[i] such that both a[i] and b[i] match the template t[i], while c[i] does not match.

  - If t[i] is lowercase, then a[i] must equal t[i], and b[i] must equal t[i], which is only possible if a[i] == b[i], but in this case, they are different. So, t[i] cannot be lowercase.

  - Therefore, t[i] must be uppercase.

  - For t[i] uppercase, a[i] must not equal t[i].lowercase, and b[i] must not equal t[i].lowercase.

  - Additionally, for c to not match, c[i] must equal t[i].lowercase.

  - So, t[i] must be chosen such that t[i].lowercase is different from both a[i] and b[i], and c[i] equals t[i].lowercase.

  - Therefore, t[i].lowercase must be equal to c[i], and c[i] must be different from both a[i] and b[i].

  - So, if c[i] != a[i] and c[i] != b[i], then I can set t[i] to be c[i].upper(), which makes t[i].lowercase == c[i], and since a[i] != c[i] and b[i] != c[i], a and b do not match, but c matches.

  - Wait, but I want c to not match, so if t[i] is uppercase, and c[i] == t[i].lowercase, then c matches, which is not what I want.

  - Wait, no. For c to not match, it must fail the condition, which for uppercase t[i] means c[i] == t[i].lowercase.

  - Wait, actually, for uppercase t[i], c must not match, meaning c[i] must not equal t[i].lowercase.

  - Wait, I'm getting confused.

  - Let me look back at the problem statement.

  - If t[i] is uppercase, then s[i] must be different from the lowercase version of t[i].

  - So, for c to not match, c[i] must equal t[i].lowercase.

  - Therefore, to make c not match, I need to set t[i] such that c[i] == t[i].lowercase.

  - But also, for a and b to match, they must have a[i] != t[i].lowercase and b[i] != t[i].lowercase.

  - So, t[i].lowercase must be different from both a[i] and b[i].

  - Therefore, c[i] must equal t[i].lowercase, which is different from both a[i] and b[i].

  - So, in this case, if c[i] != a[i] and c[i] != b[i], then I can set t[i] to be c[i].upper(), and it satisfies the conditions.

  - If c[i] == a[i] or c[i] == b[i], then I cannot set t[i] to make c not match, because c[i] would equal t[i].lowercase, but a or b would also equal t[i].lowercase, which they shouldn't.

Wait, no. Let's think carefully.

For t[i] uppercase:

- a[i] != t[i].lowercase

- b[i] != t[i].lowercase

- c[i] == t[i].lowercase

So, t[i].lowercase must be different from a[i] and b[i], and equal to c[i].

Therefore, c[i] must be different from both a[i] and b[i].

If c[i] == a[i] or c[i] == b[i], then it's impossible to set t[i] uppercase because t[i].lowercase would have to be c[i], but a[i] or b[i] would equal c[i], violating a[i] != t[i].lowercase and b[i] != t[i].lowercase.

So, in summary:

- If a[i] == b[i]:

  - If c[i] != a[i], then set t[i] to a[i] lowercase.

  - If c[i] == a[i], then set t[i] to uppercase, with t[i].lowercase != a[i], but c[i] == t[i].lowercase, which is impossible because c[i] == a[i], and t[i].lowercase != a[i].

  - Therefore, if a[i] == b[i] == c[i], it's impossible to find such a t.

- If a[i] != b[i]:

  - Set t[i] to uppercase, with t[i].lowercase != a[i] and t[i].lowercase != b[i], and c[i] == t[i].lowercase.

  - Therefore, c[i] must be different from both a[i] and b[i].

  - If c[i] == a[i] or c[i] == b[i], it's impossible.

So, for each position i:

- If a[i] == b[i]:

  - If c[i] != a[i], then it's fine to set t[i] to a[i] lowercase.

  - If c[i] == a[i], then it's impossible.

- If a[i] != b[i]:

  - If c[i] != a[i] and c[i] != b[i], then set t[i] to c[i].upper().

  - If c[i] == a[i] or c[i] == b[i], then it's impossible.

Wait, but in the case where a[i] != b[i], and c[i] != a[i] and c[i] != b[i], I can set t[i] to c[i].upper(), which makes t[i].lowercase == c[i], and since a[i] != c[i] and b[i] != c[i], a and b do not match, while c matches, which is what I want.

Wait, but the problem wants c to not match the template. So, if I set t[i] to c[i].upper(), then for c, c[i] == t[i].lowercase, which means c does not match the template, because for uppercase t[i], s[i] must be different from t[i].lowercase. So, c would fail to match at this position.

Wait, no. Let me re-read the conditions.

For uppercase t[i]:

- s[i] must be different from t[i].lowercase.

So, if c[i] == t[i].lowercase, then c does not match the template.

Wait, but according to the condition, if t[i] is uppercase, s[i] must be different from t[i].lowercase. So, if c[i] == t[i].lowercase, then c does not match the template.

Wait, but in the earlier step, I thought that setting t[i] to c[i].upper() would make t[i].lowercase == c[i], which would mean c[i] == t[i].lowercase, hence c does not match the template because it should be different.

Wait, but according to the condition, s[i] must be different from t[i].lowercase for uppercase t[i]. So, if c[i] == t[i].lowercase, then c does not match the template.

Wait, no, if c[i] == t[i].lowercase, then c does not match the template because it violates the condition that s[i] must be different from t[i].lowercase.

Wait, but in the problem statement, it says that for uppercase t[i], s[i] must be different from t[i].lowercase. So, if c[i] == t[i].lowercase, then c does not match the template, which is what I want.

So, in this case, setting t[i] to c[i].upper() makes t[i].lowercase == c[i], and since c[i] == c[i], c does not match the template.

Wait, but I'm getting confused.

Let me try with an example.

Take the third test case from the example:

n = 10

a = mathforces

b = luckforces

c = adhoccoder

Let's consider position 1:

a[1] = m

b[1] = l

c[1] = a

Since a[1] != b[1], I need to set t[1] to uppercase, with t[1].lowercase != m and != l, and c[1] == t[1].lowercase.

So, t[1].lowercase must be 'a', which is different from 'm' and 'l'. So, t[1] can be 'A'.

Similarly, for position 2:

a[2] = a

b[2] = u

c[2] = d

a[2] != b[2], so set t[2] to 'D' uppercase.

And so on.

Finally, the template could be "CODEFORCES", where:

- C (uppercase): a='m' != 'c', b='l' != 'c', c='a' == 'c' -> c does not match.

- O (uppercase): a='a' != 'o', b='u' != 'o', c='d' == 'd' != 'o' -> wait, c='d' != 'o', so c matches? Wait, no.

Wait, for t[i] uppercase, s[i] must be different from t[i].lowercase.

So, for t[2] = 'O' (uppercase), s[i] must != 'o'.

a[2] = 'a' != 'o', matches.

b[2] = 'u' != 'o', matches.

c[2] = 'd' != 'o', matches.

Wait, but I want c to not match.

Wait, maybe I messed up.

Wait, in this case, c matches, which is not what I want.

So, perhaps this choice is incorrect.

Wait, perhaps I need to set t[i] such that c[i] == t[i].lowercase, so that c does not match.

Wait, no, for uppercase t[i], c[i] must be different from t[i].lowercase for c to match, but I want c to not match, so c[i] == t[i].lowercase.

Wait, it's getting too confusing.

Maybe I need to approach this differently.

Let me think in terms of possibilities for each position.

For each position i:

- Case 1: a[i] == b[i]

  - Subcase 1: c[i] != a[i]

    - Set t[i] to a[i] lowercase. Then a and b match, c does not match.

  - Subcase 2: c[i] == a[i]

    - Cannot set t[i] to lowercase because c would match.

    - Try to set t[i] to uppercase.

      - For t[i] uppercase, a[i] != t[i].lowercase, b[i] != t[i].lowercase, c[i] == t[i].lowercase.

      - So, t[i].lowercase must be different from a[i] and b[i], and equal to c[i].

      - Since a[i] == b[i] == c[i], this is impossible because t[i].lowercase cannot be equal to c[i] and different from a[i] (which is equal to c[i]).

    - Therefore, if a[i] == b[i] == c[i], it's impossible to find such a t.

- Case 2: a[i] != b[i]

  - Subcase 1: c[i] != a[i] and c[i] != b[i]

    - Set t[i] to c[i].upper(). Then:

      - a[i] != c[i] == t[i].lowercase, so a matches.

      - b[i] != c[i] == t[i].lowercase, so b matches.

      - c[i] == t[i].lowercase, so c does not match.

  - Subcase 2: c[i] == a[i] or c[i] == b[i]

    - If c[i] == a[i], then set t[i] to uppercase with t[i].lowercase != a[i] and != b[i].

      - But c[i] == a[i], and t[i].lowercase != a[i], so c[i] != t[i].lowercase, meaning c matches, which is not what I want.

    - Similarly, if c[i] == b[i], setting t[i] to uppercase with t[i].lowercase != b[i], then c[i] != t[i].lowercase, meaning c matches.

    - Therefore, in these subcases, it's impossible to find such a t.

So, summarizing:

- For positions where a[i] == b[i]:

  - If c[i] != a[i], then it's possible to set t[i] to a[i] lowercase.

  - If c[i] == a[i], it's impossible.

- For positions where a[i] != b[i]:

  - If c[i] != a[i] and c[i] != b[i], then it's possible to set t[i] to c[i].upper().

  - If c[i] == a[i] or c[i] == b[i], it's impossible.

Therefore, to have such a template t, for all positions where a[i] == b[i], c[i] must not equal a[i]. And for positions where a[i] != b[i], c[i] must not equal a[i] and not equal b[i].

Wait, no. For positions where a[i] != b[i], c[i] must be different from both a[i] and b[i].

And for positions where a[i] == b[i], c[i] must be different from a[i].

So, in other words, for all positions i:

- If a[i] == b[i], then c[i] != a[i].

- If a[i] != b[i], then c[i] != a[i] and c[i] != b[i].

If these conditions hold for all positions, then such a template t exists.

Otherwise, it does not.

Wait, but in the third test case:

n=10

a=mathforces

b=luckforces

c=adhoccoder

Let's check position by position:

Pos 1: a='m', b='l', c='a'

a != b, so c != a and c != b => 'a' != 'm' and 'a' != 'l' => True

Pos 2: a='a', b='u', c='d'

a != b, c != a and c != b => 'd' != 'a' and 'd' != 'u' => True

Pos 3: a='t', b='c', c='h'

a != b, c != a and c != b => 'h' != 't' and 'h' != 'c' => True

Pos 4: a='h', b='k', c='o'

a != b, c != a and c != b => 'o' != 'h' and 'o' != 'k' => True

Pos 5: a='f', b='f', c='c'

a == b, c != a => 'c' != 'f' => True

Pos 6: a='o', b='o', c='o'

a == b, c != a => 'o' != 'o' => False

Wait, position 6 fails because a == b and c == a.

Therefore, according to my earlier logic, it should be "NO", but in the sample output, it's "YES".

Wait, perhaps I made a mistake.

Wait, looking back at the sample input and output:

Input:

4

1

a

b

c

2

aa

bb

aa

10

mathforces

luckforces

adhoccoder

3

acc

abd

abc

Output:

YES

NO

YES

NO

Wait, in the third test case, n=10, a=mathforces, b=luckforces, c=adhoccoder, output is YES, but according to my earlier logic, position 6 fails because a == b and c == a, which should make it "NO", but the sample output is "YES".

So, perhaps my earlier logic is incomplete.

Let me re-examine.

Wait, in position 6: a='o', b='o', c='o'

According to the sample, it's "YES", meaning there exists a template t where a and b match, and c does not.

But according to my earlier reasoning, it's impossible because a == b == c.

Wait, maybe I missed something.

Wait, perhaps I need to consider that for positions where a == b == c, I cannot have such a position because there's no way to make c not match the template.

But in the sample, it's "YES", so there must be a way.

Wait, perhaps I need to look for at least one position where the conditions allow making c not match, while ensuring that a and b match the template in all positions.

Wait, maybe I need to ensure that there exists at least one position where c does not match, while a and b match in all positions.

So, for positions where a == b:

- If c != a, then I can set t[i] to a[i] lowercase, and c does not match.

- If c == a, then it's impossible to make c not match.

For positions where a != b:

- If c != a and c != b, then I can set t[i] to c[i].upper(), and c does not match.

- If c == a or c == b, then it's impossible.

But in the third sample, position 6 has a == b == c, which according to this is impossible, but the output is "YES".

Wait, perhaps I need to set t[i] in such a way that c does not match in at least one position, while a and b match in all positions.

So, for positions where a == b:

- If c != a, then setting t[i] to a[i] lowercase makes c not match at this position, which is sufficient for c to not match the entire template.

- If c == a, then I cannot make c not match at this position.

For positions where a != b:

- If c != a and c != b, then setting t[i] to c[i].upper() makes c not match at this position.

- If c == a or c == b, then I cannot make c not match at this position.

So, for the entire template, I need to ensure that:

- For all positions where a == b == c, I cannot make c not match at that position.

- But if there exists at least one position where a == b and c != a, or a != b and c != a and c != b, then I can make c not match at that position, while making a and b match in all positions.

However, in the third sample, position 6 has a == b == c, which seems problematic, but the output is "YES".

Wait, looking back at the third sample:

n=10

a=mathforces

b=luckforces

c=adhoccoder

Position 5: a='f', b='f', c='c' => a == b and c != a => can set t[5] to 'f' lowercase, making c not match at position 5.

Position 6: a='o', b='o', c='o' => a == b and c == a => cannot make c not match at this position.

But since I can make c not match at position 5, and a and b match at all positions, then overall, c does not match the template because it fails at position 5.

So, in this case, it's "YES".

Wait, but according to my earlier flawed logic, I thought that position 6 being a == b == c makes it impossible, but actually, if there's at least one position where a == b and c != a, then I can make c not match at that position, even if other positions have a == b == c.

Wait, but in position 6, if I set t[6] to 'o' lowercase, then a and b match, but c also matches, which is not desired.

But if I set t[6] to uppercase, with t[6].lowercase != 'o', but c[6] == 'o' != t[6].lowercase, so c matches.

Wait, no, for t[6] uppercase, c[6] must equal t[6].lowercase for c to not match.

So, if I set t[6] to any uppercase letter whose lowercase is not 'o', then c[6] == 'o' != t[6].lowercase, so c matches.

Which is not what I want.

So, for position 6, I cannot make c not match, but since I have position 5 where a == b and c != a, I can set t[5] to 'f' lowercase, making c not match at position 5.

For position 6, I set t[6] to uppercase with t[6].lowercase != 'o', so that c[6] != t[6].lowercase, meaning c matches at position 6.

But since c does not match at position 5, overall, c does not match the template.

Therefore, it's possible to have such a template.

So, my earlier logic was incomplete.

Therefore, the correct condition is:

- There must exist at least one position i where:

  - (a[i] == b[i] and c[i] != a[i]) OR

  - (a[i] != b[i] and c[i] != a[i] and c[i] != b[i])

- And for all other positions:

  - If a[i] == b[i], set t[i] to a[i] lowercase.

  - If a[i] != b[i], set t[i] to any uppercase letter whose lowercase is not equal to a[i] or b[i], provided that for positions where a != b and c == a or c == b, it's impossible.

Wait, no. Actually, for positions where a != b and c == a or c == b, I cannot make c not match at that position.

But if there exists at least one position where a == b and c != a, or a != b and c != a and c != b, then I can make c not match at that position, and for other positions, set t[i] accordingly.

But if there are positions where a == b == c, I cannot make c not match at those positions, but if there are other positions where a == b and c != a, or a != b and c != a and c != b, then I can make c not match at those positions.

Therefore, the overall condition is that there exists at least one position i where:

- (a[i] == b[i] and c[i] != a[i]) OR

- (a[i] != b[i] and c[i] != a[i] and c[i] != b[i])

If this condition holds for at least one position, and for all other positions, I can set t[i] in a way that a and b match, then the answer is "YES".

Otherwise, it's "NO".

But in the third sample, position 5 satisfies (a[i] == b[i] and c[i] != a[i}), so it's "YES", even though position 6 has a == b == c.

Similarly, in the first sample:

n=1

a=a

b=b

c=c

Here, position 1: a != b and c != a and c != b, so "YES".

In the second sample:

n=2

a=aa

b=bb

c=aa

Position 1: a == b == c => cannot make c not match.

Position 2: a == b == c => cannot make c not match.

No position where a == b and c != a, or a != b and c != a and c != b.

Therefore, "NO".

In the fourth sample:

n=3

a=acc

b=abd

c=abc

Position 1: a != b, c != a and c != b => can set t[1] to c[i].upper().

Position 2: a == b == c => cannot make c not match.

Position 3: a == b != c => can set t[3] to a[i] lowercase.

Wait, but in position 2, a == b == c, which is problematic.

But since position 1 and position 3 can make c not match, but position 2 cannot, does that mean "YES" or "NO"?

Wait, in position 1, I can make c not match, but in position 2, I cannot make c not match.

But since c matches at position 2, and does not match at position 1, does that make c overall not match the template?

Wait, the problem says that for c to not match the template, it must fail at least one position.

But in position 1, c does not match, and in position 2, c matches.

Does that mean c does not match the template overall?

Wait, the problem says:

"Determine whether there exists a template t such that the strings a and b match it, while the string c does not."

For c to not match the template, it must not satisfy the condition for at least one position.

So, if there exists at least one position where c does not match, and a and b match in all positions, then it's "YES".

In the fourth sample, position 1 can be set to make c not match, and positions where a == b == c, c matches, but since there's at least one position where c does not match, it should be "YES".

But in the sample output, it's "NO", which contradicts this.

Wait, perhaps I'm missing something.

Looking back at the fourth sample:

n=3

a=acc

b=abd

c=abc

Position 1: a='a', b='a', c='a' => a == b == c => cannot make c not match.

Wait, a='a', b='a', c='a' => a == b == c => cannot make c not match at this position.

Position 2: a='c', b='b', c='b' => a != b, c == b => cannot make c not match.

Position 3: a='c', b='d', c='c' => a != b, c == a => cannot make c not match.

So, in all positions, I cannot make c not match.

Therefore, it's "NO".

I see, I made a mistake in my earlier assumption.

Therefore, the correct condition is:

There must exist at least one position i where:

- (a[i] == b[i] and c[i] != a[i]) OR

- (a[i] != b[i] and c[i] != a[i] and c[i] != b[i])

And, for all other positions:

- If a[i] == b[i], set t[i] to a[i] lowercase.

- If a[i] != b[i], set t[i] to uppercase with t[i].lowercase != a[i] and != b[i].

But in positions where a == b == c, I cannot make c not match, and if there's no position where I can make c not match, then it's "NO".

Hence, in the fourth sample, there is no position where I can make c not match, so it's "NO".

In the third sample, position 5 allows making c not match, even though position 6 cannot make c not match, but since c does not match at position 5, overall c does not match the template.

Therefore, the condition is:

There exists at least one position i where:

- (a[i] == b[i] and c[i] != a[i]) OR

- (a[i] != b[i] and c[i] != a[i] and c[i] != b[i])

If this condition holds for at least one position, and for all other positions, a and b can match the template, then "YES".

Otherwise, "NO".

But in the code provided, it seems to check if there exists at least one position where the above condition holds, and if so, print "YES", else "NO".

Looking at the code:

def func_1():

    t = int(input())

    for _ in range(t):

        n = int(input())

        a = input().strip()

        b = input().strip()

        c = input().strip()

        possible = False

        for i in range(n):

            if a[i] == b[i]:

                if c[i] != a[i]:

                    possible = True

                    break

            elif c[i] != a[i] and c[i] != b[i]:

                possible = True

                break

        if possible:

            print('YES')

        else:

            print('NO')

It iterates through each position and checks:

- If a[i] == b[i] and c[i] != a[i], set possible to True.

- Else if a[i] != b[i] and c[i] != a[i] and c[i] != b[i], set possible to True.

- If such a position exists, print "YES", else "NO".

This seems to align with the condition I derived.

Therefore, the code is correct.

**Final Solution**
To solve this problem, we need to determine if there exists a template string `t` such that two given strings `a` and `b` match the template, while another string `c` does not match it. 

## Approach
1. **Understanding Matching Rules**:
    - If the i-th character of the template `t` is lowercase, the corresponding character in strings `a`, `b`, and `c` must match it exactly.
    - If the i-th character of the template `t` is uppercase, the corresponding character in strings `a`, `b`, and `c` must be different from the lowercase version of the template character.

2. **Conditions for Matching**:
    - For positions where `a[i]` equals `b[i]`:
        - If `c[i]` is different from `a[i]`, we can set `t[i]` to `a[i]` in lowercase, making `a` and `b` match, and `c` not match.
    - For positions where `a[i]` is different from `b[i]`:
        - If `c[i]` is different from both `a[i]` and `b[i]`, we can set `t[i]` to `c[i]` in uppercase, making `a` and `b` not match (since they are different from `c[i]`), and `c` match (since it's equal to `t[i].lowercase`), but this is not desired. Hence, we need to ensure that `c` does not match in at least one position.

3. **Algorithm**:
    - Iterate through each position `i` from 0 to `n-1`:
        - If `a[i]` equals `b[i]` and `c[i]` is different from `a[i]`, set `possible` to True.
        - Else if `a[i]` is different from `b[i]` and `c[i]` is different from both `a[i]` and `b[i]`, set `possible` to True.
    - If such a position exists, print "YES"; otherwise, print "NO".

## Solution Code
```python
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = input().strip()
        b = input().strip()
        c = input().strip()
        possible = False
        for i in range(n):
            if a[i] == b[i]:
                if c[i] != a[i]:
                    possible = True
                    break
            elif c[i] != a[i] and c[i] != b[i]:
                possible = True
                break
        if possible:
            print('YES')
        else:
            print('NO')

# Example usage
func_1()
```

## Explanation
- **Step-by-step breakdown**:
    - Read the number of test cases `t`.
    - For each test case, read `n` (length of strings), and strings `a`, `b`, and `c`.
    - Check for each position `i`:
        - If `a[i]` equals `b[i]` and `c[i]` is different from `a[i]`, set `possible` to True.
        - Else if `a[i]` is different from `b[i]` and `c[i]` is different from both `a[i]` and `b[i]`, set `possible` to True.
    - Print "YES" if such a position exists, otherwise print "NO".

This approach ensures that we find a template `t` where `a` and `b` match, and `c` does not, by leveraging the conditions provided in the problem statement.