Alright, I have this problem here about Alice and Bob playing a game with their wallets. Alice starts with 'a' coins and Bob with 'b' coins. They take turns, starting with Alice, and in each turn, the player can choose to exchange wallets with the opponent or keep their current wallets, and then remove one coin from their current wallet. The player who can't make a valid move loses. I need to determine who wins if both play optimally.

First, I need to understand the game mechanics thoroughly. Each turn consists of two steps: choosing to swap wallets or not, and then removing one coin from the current wallet. Importantly, the wallet can't have zero coins before removing a coin. So, if a player has zero coins, they can't remove a coin and thus lose.

Let me consider some simple cases to get a feel for the game.

**Case 1: a = 1, b = 1**

- Alice's turn: She has 1 coin. She can choose to swap or not.

- If she swaps: a becomes 1, b becomes 1. She removes 1 coin, so a = 0, b = 1.

- Now it's Bob's turn: He has 1 coin. He can choose to swap or not.

- If he swaps: a = 1, b = 0. But b = 0, so he can't remove a coin. So, he loses.

- Wait, but according to the example, Bob wins in this case. So, maybe I'm missing something.

Wait, in the example, it says:

Input:

10

1 1

1 4

5 3

4 5

11 9

83 91

1032 9307

839204 7281

1000000000 1000000000

53110 2024

Output:

Bob

Alice

Bob

Alice

Bob

Bob

Alice

Alice

Bob

Bob

So, for a=1, b=1, output is Bob.

But in my earlier thought, I concluded Alice wins, but according to the example, Bob wins. So, maybe my understanding is incorrect.

Let me think again.

In the first move, Alice has a=1, b=1.

- If she chooses to swap: a=1, b=1. She removes 1 coin, so a=0, b=1.

- Now, Bob has b=1. He can choose to swap or not.

- If he chooses to swap: a=1, b=0. But b=0, so he can't remove a coin. So, he loses.

- If he chooses not to swap: a=0, b=1. He removes 1 coin, so a=0, b=0.

- Now, it's Alice's turn again. a=0, b=0. She can't remove a coin, so she loses.

Wait, in this case, if Alice chooses to swap, Bob can choose not to swap, leading to both wallets being empty, and Alice loses. But if Bob chooses to swap, he loses immediately. So, Bob, playing optimally, would choose not to swap, leading to Alice losing. So, Bob wins.

Hence, Bob wins in this case.

Another way to look at it: Alice has no good move. If she swaps, Bob can choose not to swap, leading to Alice's loss. If she doesn't swap, she removes from her wallet, a=0, b=1, and again, Bob can choose to swap or not.

If she doesn't swap: a=0, b=1.

- Bob chooses to swap: a=0, b=0. Alice can't move, so Bob wins.

- Bob chooses not to swap: a=0, b=0. Same result.

So, either way, Bob wins.

Hence, in this case, Bob wins.

**Case 2: a=1, b=4**

According to the example, output is Alice.

Let's see.

- Alice's turn: a=1, b=4.

- She can choose to swap or not.

- If she doesn't swap: a=0, b=4. Now, Bob has b=4.

- Bob chooses to swap or not.

- If he swaps: a=4, b=0. Alice's turn next.

- Alice has a=4, b=0. She can choose to swap or not.

- If she swaps: a=0, b=3. Now, Bob has b=3.

- Bob chooses to swap or not.

- If he swaps: a=3, b=0. Alice's turn.

- Alice swaps: a=0, b=2. Bob's turn.

- Bob swaps: a=2, b=0. Alice's turn.

- Alice swaps: a=0, b=1. Bob's turn.

- Bob swaps: a=1, b=0. Alice's turn.

- Alice swaps: a=0, b=0. Bob can't move, so Alice wins.

- Alternatively, at some point, Bob might choose not to swap, but it seems that Alice can force the game to a position where Bob has to make the last move and lose.

Hence, Alice wins in this case.

From these examples, it seems that the winner depends on some property of a and b.

Let me look for a general strategy.

First, note that the game is deterministic and both players play optimally. So, the outcome depends only on the initial positions a and b.

Let me consider the parity of a + b.

In the first case, a=1, b=1: a+b=2, which is even. Bob wins.

In the second case, a=1, b=4: a+b=5, which is odd. Alice wins.

Looking at the example outputs:

1 1 -> Bob

1 4 -> Alice

5 3 -> Bob

4 5 -> Alice

11 9 -> Bob

83 91 -> Bob

1032 9307 -> Alice

839204 7281 -> Alice

1000000000 1000000000 -> Bob

53110 2024 -> Bob

Looking at a+b:

1+1=2 (even) -> Bob

1+4=5 (odd) -> Alice

5+3=8 (even) -> Bob

4+5=9 (odd) -> Alice

11+9=20 (even) -> Bob

83+91=174 (even) -> Bob

1032+9307=10339 (odd) -> Alice

839204+7281=846485 (odd) -> Alice

1000000000+1000000000=2000000000 (even) -> Bob

53110+2024=55134 (even) -> Bob

So, it seems that if a+b is even, Bob wins; if a+b is odd, Alice wins.

Is this always true?

Let me try to see if this pattern holds for more cases.

**Case 3: a=2, b=2**

a+b=4 (even) -> Bob wins.

Let's simulate:

- Alice's turn: a=2, b=2.

- She chooses to swap or not.

- If she swaps: a=2, b=2. She removes 1 coin, a=1, b=2.

- Bob's turn: a=1, b=2.

- He chooses to swap or not.

- If he swaps: a=2, b=1. He removes 1 coin, a=2, b=0.

- Alice's turn: a=2, b=0.

- She chooses to swap or not.

- If she swaps: a=0, b=1. Bob's turn.

- Bob removes 1 coin, a=0, b=0. Alice can't move, so Bob wins.

- If she doesn't swap: a=1, b=0. Bob's turn.

- Bob swaps: a=0, b=0. Alice can't move, so Bob wins.

- If Bob chooses not to swap: a=2, b=0. He removes 1 coin, a=1, b=0.

- Alice's turn: a=1, b=0.

- She chooses to swap: a=0, b=0. Bob can't move, so Alice wins.

Wait, in this path, Alice wins.

But according to the pattern, Bob should win since a+b is even.

Hmm, maybe the pattern isn't so straightforward.

Wait, in this case, a=2, b=2, a+b=4 (even). According to the pattern, Bob should win.

But in the simulation above, depending on the choices, Alice can win in some paths.

Wait, but both players play optimally. So, Bob should play in a way that ensures his victory.

Let me try again.

- Alice's turn: a=2, b=2.

- She can choose to swap or not.

- If she swaps: a=2, b=2. She removes 1 coin, a=1, b=2.

- Bob's turn: a=1, b=2.

- He can choose to swap or not.

- If he swaps: a=2, b=1. He removes 1 coin, a=2, b=0.

- Alice's turn: a=2, b=0.

- She can choose to swap or not.

- If she swaps: a=0, b=1. Bob's turn.

- Bob removes 1 coin, a=0, b=0. Alice can't move, so Bob wins.

- If she doesn't swap: a=1, b=0. Bob's turn.

- Bob can choose to swap or not.

- If he swaps: a=0, b=0. Alice can't move, so Bob wins.

- If he doesn't swap: a=1, b=0. He removes 1 coin, a=0, b=0. Alice can't move, so Bob wins.

- If Bob chooses not to swap initially: a=1, b=2.

- He removes 1 coin, a=1, b=1.

- Alice's turn: a=1, b=1.

- She chooses to swap or not.

- If she swaps: a=1, b=1. She removes 1 coin, a=0, b=1.

- Bob's turn: a=0, b=1.

- He chooses to swap or not.

- If he swaps: a=1, b=0. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If he doesn't swap: a=0, b=0. Alice can't move, so Bob wins.

- So, Bob can choose to swap or not, leading to either Alice winning or Bob winning.

- Since Bob plays optimally, he would choose the option where he wins.

Hence, in this path, Bob wins.

Therefore, in a=2, b=2, Bob wins, which matches the pattern.

Another case: a=1, b=2.

a+b=3 (odd) -> Alice wins.

Let's simulate.

- Alice's turn: a=1, b=2.

- She chooses to swap or not.

- If she swaps: a=2, b=1. She removes 1 coin, a=1, b=1.

- Bob's turn: a=1, b=1.

- He chooses to swap or not.

- If he swaps: a=1, b=1. He removes 1 coin, a=0, b=1.

- Alice's turn: a=0, b=1.

- She chooses to swap or not.

- If she swaps: a=0, b=0. Bob can't move, so Alice wins.

- If she doesn't swap: a=0, b=0. Same result.

- If Bob doesn't swap initially: a=1, b=1.

- He removes 1 coin, a=0, b=1.

- Alice's turn: a=0, b=1.

- She chooses to swap or not.

- Either way, a=0, b=0. Bob can't move, so Alice wins.

Hence, Alice wins in this case.

So, the pattern seems to hold.

But in the earlier simulation with a=2, b=2, it seemed like there were multiple paths, and Bob could choose a path where he wins.

Hence, the pattern might still hold.

But I need to confirm this for general a and b.

Let me consider that the game is equivalent to some standard game like Nim or another impartial game.

But in this game, the ability to swap adds a twist.

Let me think in terms of game theory.

Let me define the game state as (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

The game is impartial because both players have the same moves available to them in their own turns.

But in combinatorial game theory, games can be analyzed using the concept of Nimbers or mex function.

However, given the constraints (a and b can be up to 10^9), I need an efficient way to determine the winner without simulating the game.

From the pattern observed, it seems that if a + b is even, Bob wins; otherwise, Alice wins.

But in the a=2, b=2 case, it's possible for Alice to force a win in some paths, but Bob can prevent that by choosing correctly.

Wait, but in the a=2, b=2 case, according to the pattern, Bob wins.

Let me see if I can find a counterexample where a + b is even, but Alice wins.

I couldn't find one yet.

Let me consider a=3, b=1.

a + b = 4 (even) -> Bob wins.

Simulate:

- Alice's turn: a=3, b=1.

- She chooses to swap or not.

- If she swaps: a=1, b=3. She removes 1 coin, a=0, b=3.

- Bob's turn: a=0, b=3.

- He chooses to swap or not.

- If he swaps: a=3, b=0. Alice's turn.

- Alice removes 1 coin, a=2, b=0.

- Bob's turn: a=2, b=0.

- He chooses to swap or not.

- If he swaps: a=0, b=1. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If he doesn't swap: a=1, b=0. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If Bob doesn't swap initially: a=0, b=3.

- He removes 1 coin, a=0, b=2.

- Alice's turn: a=0, b=2.

- She chooses to swap or not.

- If she swaps: a=2, b=0. Bob's turn.

- Bob removes 1 coin, a=1, b=0.

- Alice's turn: a=1, b=0.

- She chooses to swap or not.

- If she swaps: a=0, b=0. Bob can't move, so Alice wins.

- If she doesn't swap: a=0, b=0. Same result.

- So, in all paths, Alice wins.

But according to the pattern, a + b = 4 (even), so Bob should win, but in this simulation, Alice wins.

Wait, maybe I made a mistake.

Wait, in the a=3, b=1 case, a + b = 4 (even). According to the pattern, Bob should win, but in this simulation, Alice wins.

Hmm, this contradicts the pattern.

So, perhaps the pattern isn't simply based on the parity of a + b.

Let me check another case.

**Case 4: a=3, b=1**

a + b = 4 (even) -> Bob should win, but simulation shows Alice wins.

Hence, the pattern might be more complex.

Let me consider the game in terms of the number of coins each player has.

Perhaps, the player who faces the situation where both a and b are odd loses, or something like that.

Wait, in the a=1, b=1 case, Bob wins, which is a + b even.

In a=3,1, a + b even, but Alice wins.

Wait, maybe it's about the difference between a and b.

Let me check the difference in the examples.

In a=1, b=1, difference is 0 (even), Bob wins.

In a=1, b=4, difference is 3 (odd), Alice wins.

In a=5, b=3, difference is 2 (even), Bob wins.

In a=4, b=5, difference is 1 (odd), Alice wins.

In a=11, b=9, difference is 2 (even), Bob wins.

In a=83, b=91, difference is 8 (even), Bob wins.

In a=1032, b=9307, difference is 8275 (odd), Alice wins.

In a=839204, b=7281, difference is 831923 (odd), Alice wins.

In a=1000000000, b=1000000000, difference is 0 (even), Bob wins.

In a=53110, b=2024, difference is 51086 (even), Bob wins.

So, it seems that when the difference is even, Bob wins; when odd, Alice wins.

Wait, but a + b being even or odd seems to correlate with the difference being even or odd because:

(a + b) even implies both a and b are even or both are odd.

(a - b) = a + (-b). If a and b are both even or both odd, then a - b is even.

If one is even and one is odd, a - b is odd.

Wait, no. a - b is even if a and b are both even or both odd; a - b is odd if one is even and one is odd.

Wait, but a + b even implies a and b both even or both odd.

a - b even if a and b both even or both odd.

Similarly, a + b odd if one is even and one is odd.

a - b odd if one is even and one is odd.

Hence, a + b even implies a - b even.

a + b odd implies a - b odd.

Hence, the parity of a + b is the same as the parity of a - b.

Therefore, saying a + b even is equivalent to saying a - b even, and similarly for odd.

Hence, the pattern observed earlier is consistent.

But in the a=3, b=1 case, a + b = 4 (even), but Alice wins, which contradicts the initial pattern.

Wait, perhaps there is more to it.

Let me consider the binary representations or some other properties.

Alternatively, maybe it's about the parity of the number of coins.

Wait, perhaps it's about the mex or something in game theory.

Alternatively, maybe it's about the Nim-sum.

But in this game, the ability to swap adds complexity.

Let me consider that swapping allows the player to choose between two options: keep the current state or switch to the opponent's state.

This seems similar to having two parallel games, and the player can choose which one to play in each turn.

But I'm not sure.

Alternatively, perhaps the game can be modeled as a subtraction game, where the subtraction is 1, but with an additional option to swap.

This seems complicated.

Let me try to find a general strategy.

Suppose that in some state (a, b), the player can force a win.

I need to find such states.

From the earlier cases:

- (1,1): Bob wins.

- (1,4): Alice wins.

- (3,1): Alice wins.

- (2,2): Bob wins.

- (5,3): Bob wins.

- (4,5): Alice wins.

- (11,9): Bob wins.

- (83,91): Bob wins.

- (1032,9307): Alice wins.

- (839204,7281): Alice wins.

- (1000000000,1000000000): Bob wins.

- (53110,2024): Bob wins.

Looking for a pattern:

If a + b is even, Bob wins; else, Alice wins.

But as seen in (3,1), a + b even, but Alice wins.

This contradicts the pattern.

Wait, perhaps it's about the parity of a and b individually.

Let me see:

In (1,1): both odd -> Bob wins.

(1,4): one odd, one even -> Alice wins.

(3,1): one odd, one even -> Alice wins.

(2,2): both even -> Bob wins.

(5,3): both odd -> Bob wins.

(4,5): one even, one odd -> Alice wins.

(11,9): both odd -> Bob wins.

(83,91): both odd -> Bob wins.

(1032,9307): one even, one odd -> Alice wins.

(839204,7281): one even, one odd -> Alice wins.

(1000000000,1000000000): both even -> Bob wins.

(53110,2024): both even -> Bob wins.

So, when both a and b are odd, Bob wins; when one is even and one is odd, Alice wins; when both are even, Bob wins.

Wait, but in (3,1), both odd, Alice wins, which contradicts.

Wait, no, in (3,1), a + b = 4 (even), but according to the simulation, Alice wins.

Wait, perhaps I made a mistake in the simulation.

Let me simulate again.

- Alice's turn: a=3, b=1.

- She chooses to swap or not.

- If she swaps: a=1, b=3. She removes 1 coin, a=0, b=3.

- Bob's turn: a=0, b=3.

- He chooses to swap or not.

- If he swaps: a=3, b=0. Alice's turn.

- Alice removes 1 coin, a=2, b=0.

- Bob's turn: a=2, b=0.

- He chooses to swap or not.

- If he swaps: a=0, b=1. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If he doesn't swap: a=1, b=0. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If Bob doesn't swap initially: a=0, b=3.

- He removes 1 coin, a=0, b=2.

- Alice's turn: a=0, b=2.

- She chooses to swap or not.

- If she swaps: a=2, b=0. Bob's turn.

- Bob removes 1 coin, a=1, b=0.

- Alice's turn: a=1, b=0.

- She chooses to swap or not.

- If she swaps: a=0, b=0. Bob can't move, so Alice wins.

- If she doesn't swap: a=0, b=0. Same result.

- So, in all paths, Alice wins.

Hence, Alice wins in this case, which contradicts the initial pattern that Bob wins when a + b is even.

Wait, perhaps there's another way to look at it.

Let me consider the binary operations or something else.

Alternatively, maybe it's about the difference between a and b.

Wait, in the simulation, Alice wins when a and b are both odd, which is a + b even, but in some cases, like (1,1), Bob wins, and in (3,1), Alice wins.

This inconsistency suggests that the pattern is not solely based on the parity of a + b.

Perhaps I need to look for another property.

Let me consider the game in terms of the number of coins each player has and the options available to them.

Each player can choose to swap or not, and then remove one coin from their current wallet.

This is similar to choosing between two options: keep your current wallet and remove one coin, or swap wallets and then remove one coin.

Hence, each move, a player effectively chooses between two possible next states.

This branching makes it similar to a graph where each node has two outgoing edges.

In such a game, the winning strategy depends on the structure of this graph.

Given the large possible values of a and b (up to 10^9), I need an efficient way to determine the winner without simulating the entire game.

Perhaps there is a mathematical formula or a pattern that can be exploited.

Looking back at the initial code provided:

def func():

test = int(input())

for t in range(test):

(a, b) = map(int, input().split())

if a + b & 1 == 0:

print('Bob')

else:

print('Alice')

This code checks if a + b is even. If it is, it prints 'Bob'; else, 'Alice'.

But as seen in the simulation of a=3, b=1, a + b is even, but Alice wins.

Hence, this code is incorrect.

Wait, but according to the example outputs, in a=1, b=1, Bob wins; a=1, b=4, Alice wins; a=5, b=3, Bob wins; a=4, b=5, Alice wins; etc.

Looking at a + b:

1+1=2 (even) -> Bob

1+4=5 (odd) -> Alice

5+3=8 (even) -> Bob

4+5=9 (odd) -> Alice

11+9=20 (even) -> Bob

83+91=174 (even) -> Bob

1032+9307=10339 (odd) -> Alice

839204+7281=846485 (odd) -> Alice

1000000000+1000000000=2000000000 (even) -> Bob

53110+2024=55134 (even) -> Bob

So, in all these cases, the pattern holds: if a + b is even, Bob wins; else, Alice wins.

Wait, but in my simulation of a=3, b=1, a + b =4 (even), but Alice wins.

But according to the pattern, it should be Bob wins.

Hence, perhaps my simulation is incorrect.

Let me try simulating again.

- Alice's turn: a=3, b=1.

- She chooses to swap or not.

- If she doesn't swap: a=2, b=1.

- Bob's turn: a=2, b=1.

- He chooses to swap or not.

- If he swaps: a=1, b=2. He removes 1 coin, a=1, b=1.

- Alice's turn: a=1, b=1.

- She chooses to swap or not.

- If she swaps: a=1, b=1. She removes 1 coin, a=0, b=1.

- Bob's turn: a=0, b=1.

- He chooses to swap or not.

- If he swaps: a=1, b=0. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If he doesn't swap: a=0, b=0. Alice can't move, so Bob wins.

- So, Bob can choose to swap or not, leading to either Alice winning or Bob winning.

- Since Bob plays optimally, he would choose to swap, leading to Bob's win.

Hence, in this path, Bob can win.

Alternatively, if Bob chooses not to swap initially: a=2, b=1.

- Bob doesn't swap: a=1, b=1.

- Alice's turn: a=1, b=1.

- She chooses to swap or not.

- If she swaps: a=1, b=1. She removes 1 coin, a=0, b=1.

- Bob's turn: a=0, b=1.

- He chooses to swap or not.

- If he swaps: a=1, b=0. Alice's turn.

- Alice removes 1 coin, a=0, b=0. Bob can't move, so Alice wins.

- If he doesn't swap: a=0, b=0. Alice can't move, so Bob wins.

- So, Bob can choose to swap or not, leading to either Alice winning or Bob winning.

- Optimal play would have Bob choose to swap, leading to Bob's win.

Hence, in this case, Bob can win.

Wait, but earlier, I thought Alice wins.

Maybe I made a mistake.

So, in a=3, b=1, Bob can win by choosing correctly.

Hence, the initial pattern holds: if a + b is even, Bob wins; else, Alice wins.

Therefore, the given program is correct.

**Final Solution**

To solve this problem, we need to determine the winner of a game between Alice and Bob based on the number of coins they each have in their wallets, assuming both play optimally.

### Approach

1. **Problem Analysis**:
   - Alice and Bob take turns with Alice starting first.
   - Each player can choose to swap wallets or keep their current wallet and then remove one coin from their chosen wallet.
   - The player who cannot make a valid move loses.

2. **Insight**:
   - By analyzing several test cases, we observe a pattern based on the sum of coins in both wallets.
   - If the sum of coins `(a + b)` is even, Bob wins; otherwise, Alice wins.

3. **Optimal Solution**:
   - We check the parity (even or odd) of the sum of coins in Alice's and Bob's wallets.
   - If `a + b` is even, print "Bob"; otherwise, print "Alice".

### Solution Code

```python
def func():
    test = int(input())
    for t in range(test):
        (a, b) = map(int, input().split())
        if (a + b) & 1 == 0:
            print('Bob')
        else:
            print('Alice')

func()
```

### Explanation

1. **Parity Check**:
   - The expression `(a + b) & 1` checks if the sum of `a` and `b` is even.
   - If `(a + b) & 1` equals 0, the sum is even, and Bob wins.
   - Otherwise, the sum is odd, and Alice wins.

2. **Efficiency**:
   - This approach runs in constant time O(1) for each test case, making it highly efficient even for large inputs.

By leveraging this simple parity check, we can determine the winner efficiently and correctly for all test cases.