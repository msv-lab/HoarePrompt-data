Alright, I've got this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices <i, j> (where i < j) beautiful if two conditions are met:

1. The sum of the elements at positions i and j is divisible by x.

2. The difference of the elements at positions i and j is divisible by y.

My task is to find out how many such beautiful pairs exist in the array for each test case.

First, I need to understand what it means for a sum or difference to be divisible by certain numbers. Let's recall that if a number a is divisible by another number b, it means that a mod b equals zero.

So, for the sum a_i + a_j to be divisible by x, (a_i + a_j) mod x should be 0.

Similarly, for the difference a_i - a_j to be divisible by y, (a_i - a_j) mod y should be 0.

I need to find pairs where both these conditions hold true.

Let me think about how to approach this efficiently, especially since the constraints mention that n can be up to 2*10^5 and t up to 10^4, but the total sum of n across all test cases is 2*10^5. So, I need an algorithm that's linear or linearithmic in n.

Let me consider the properties of modulo operations here.

For the sum:

(a_i + a_j) mod x == 0

This implies that a_j == (-a_i) mod x

Similarly, for the difference:

(a_i - a_j) mod y == 0

This implies that a_j == a_i mod y

So, for each a_i, I need to find a_j such that:

a_j ≡ -a_i mod x

and

a_j ≡ a_i mod y

Wait, but a_j can't satisfy both conditions simultaneously unless there's some relationship between x and y.

Hmm.

Maybe I need to find a way to count the number of a_j that satisfy both congruences.

This seems like a system of congruences.

Let me recall the Chinese Remainder Theorem, but I'm not sure if it directly applies here because x and y may not be coprime.

Moreover, in this problem, x and y can be any integers >=1, so they might or might not be coprime.

I need to find a_j such that:

a_j ≡ -a_i mod x

and

a_j ≡ a_i mod y

So, for each a_i, I need to find a_j that satisfy both of these conditions.

This seems a bit tricky.

Let me think differently.

Maybe I can group the elements based on their remainders when divided by x and y.

But keeping track of two different moduli for each element might be complicated.

Wait, perhaps I can store the frequencies of a_j's modulo x and modulo y separately.

Let me think about maintaining two frequency maps: one for a_j mod x and one for a_j mod y.

Then, for each a_i, I can compute -a_i mod x and a_i mod y.

Then, the number of a_j that satisfy a_j ≡ -a_i mod x is frequency_map_x[-a_i mod x], and similarly, the number of a_j that satisfy a_j ≡ a_i mod y is frequency_map_y[a_i mod y].

But if I just add these two frequencies, it won't give me the pairs that satisfy both conditions simultaneously.

I need to find the intersection of these two sets.

How can I efficiently compute the number of a_j that satisfy both conditions?

This seems like a problem that requires some mathematical insight.

Let me consider specific examples to see if there's a pattern.

Take the first example:

n=6, x=5, y=2, a=[1,2,7,4,9,6]

Beautiful pairs are <1,5> and <4,6>.

Let's verify:

<1,5>: a1=1, a5=9

sum=10, which is divisible by 5

difference=1-9=-8, which is divisible by 2

Similarly, <4,6>: a4=4, a6=6

sum=10, divisible by 5

difference=4-6=-2, divisible by 2

So, these are the only pairs that satisfy both conditions.

Now, let's try to see if there's a pattern.

Let me compute for each a_i:

For a1=1:

I need a_j such that a_j ≡ -1 mod 5 (which is 4 mod 5) and a_j ≡ 1 mod 2

Looking at the array:

a2=2: 2 mod 5=2, 2 mod 2=0 → no

a3=7:7 mod 5=2, 7 mod 2=1 → no

a4=4:4 mod 5=4, 4 mod 2=0 → no

a5=9:9 mod 5=4, 9 mod 2=1 → yes

a6=6:6 mod 5=1, 6 mod 2=0 → no

So, only a5 satisfies both conditions for a1.

Similarly, for a4=4:

a5=9:9 mod 5=4, 9 mod 2=1 → no

a6=6:6 mod 5=1, 6 mod 2=0 → no

Wait, but according to the example, <4,6> is a beautiful pair.

Wait, a6=6:6 mod 5=1, which is not equal to -4 mod 5, which is 1 mod 5.

Wait, -4 mod 5 is 1, since 5-4=1.

So, a_j needs to be ≡1 mod 5 and ≡4 mod 2.

Wait, 6 mod 5=1, and 6 mod 2=0, which is not equal to 4 mod 2.

Wait, 4 mod 2=0, so it should be ≡0 mod 2.

Wait, perhaps I miscalculated.

Wait, a_i=4, so -a_i=-4 mod 5=1

and a_i=4 mod y=2=0

So, I need a_j such that a_j ≡1 mod 5 and a_j ≡0 mod 2

Looking at a6=6:6 mod 5=1, 6 mod 2=0 → yes

So, <4,6> is a beautiful pair.

Wait, earlier I thought a_j needs to be ≡ -a_i mod x and ≡a_i mod y.

But in this case, for a_i=4:

-a_i mod x=-4 mod 5=1

and a_i mod y=4 mod 2=0

So, a_j needs to be ≡1 mod 5 and ≡0 mod 2

Which a6 satisfies.

So, why did I think earlier that for a4=4, a6 doesn't satisfy?

I must have made a mistake in calculation.

So, the approach seems valid.

Now, how to generalize this.

I need, for each a_i, find the number of a_j that satisfy:

a_j ≡ -a_i mod x

and

a_j ≡ a_i mod y

And since i < j, I need to make sure I don't count pairs where j <= i.

So, perhaps I can iterate through the array, and maintain frequency maps for a_j mod x and a_j mod y, but in a way that for each a_i, I can query the number of a_j that satisfy both conditions and have j > i.

This sounds like I need to process the array in order, and for each a_i, query the frequency of a_j that satisfy both conditions for j > i.

Then, after processing a_i, I update the frequency maps with a_i's mod x and mod y.

This way, I can ensure that I only count pairs where i < j.

So, I need to maintain two frequency maps: one for mod x and one for mod y.

For each a_i, I can compute:

target_mod_x = (-a_i) mod x

target_mod_y = a_i mod y

Then, the number of a_j that satisfy both conditions is the number of a_j where a_j mod x == target_mod_x and a_j mod y == target_mod_y.

But how do I efficiently query for the number of a_j that satisfy both conditions?

If I maintain a frequency map for each mod x and mod y separately, I can't directly get the count of a_j that satisfy both conditions, because these are two different groupings.

Wait, perhaps I need to maintain a frequency map where the key is a tuple of (mod_x, mod_y).

So, for each a_j, I compute (a_j mod x, a_j mod y), and keep a frequency map for these tuples.

Then, for each a_i, I can compute the target tuple as ((-a_i) mod x, (a_i mod y)), and look up the frequency of that tuple in the frequency map for a_j with j > i.

This seems feasible.

Let me think about the implementation.

I'll need to iterate through the array from left to right.

For each a_i, compute the target tuple and query the frequency map to get the count of a_j that match the target tuple for j > i.

Then, after processing a_i, I need to update the frequency map with the tuple (a_i mod x, a_i mod y).

This way, as I iterate through the array, the frequency map always contains the tuples for a_j with j > i.

Wait, actually, to have j > i, I should update the frequency map after processing a_i.

Wait, no, if I iterate through the array, and for each a_i, I query the frequency map for the target tuple, and then add the tuple of a_i to the frequency map after querying.

This way, when processing a_i, the frequency map contains a_j with j > i.

Yes, that makes sense.

Let me try this with the first test case.

n=6, x=5, y=2, a=[1,2,7,4,9,6]

Initialize frequency map empty.

Process a1=1:

target_mod_x = (-1) mod 5 = 4

target_mod_y = 1 mod 2 = 1

target tuple: (4,1)

Frequency map is empty, so count +=0

Then, add (1 mod 5, 1 mod 2)=(1,1) to frequency map.

Frequency map: {(1,1):1}

Process a2=2:

target_mod_x = (-2) mod 5 = 3

target_mod_y = 2 mod 2 = 0

target tuple: (3,0)

Frequency map: {(1,1):1}

No match, count +=0

Add (2 mod 5, 2 mod 2)=(2,0) to frequency map.

Frequency map: {(1,1):1, (2,0):1}

Process a3=7:

target_mod_x = (-7) mod 5 = (-7) + 10 = 3 mod 5

target_mod_y = 7 mod 2 = 1

target tuple: (3,1)

Frequency map: {(1,1):1, (2,0):1}

No match, count +=0

Add (7 mod 5, 7 mod 2)=(2,1) to frequency map.

Frequency map: {(1,1):1, (2,0):1, (2,1):1}

Process a4=4:

target_mod_x = (-4) mod 5 = 1

target_mod_y = 4 mod 2 = 0

target tuple: (1,0)

Frequency map: {(1,1):1, (2,0):1, (2,1):1}

No match, count +=0

Add (4 mod 5, 4 mod 2)=(4,0) to frequency map.

Frequency map: {(1,1):1, (2,0):1, (2,1):1, (4,0):1}

Process a5=9:

target_mod_x = (-9) mod 5 = (-9) + 10 = 1 mod 5

target_mod_y = 9 mod 2 = 1

target tuple: (1,1)

Frequency map: {(2,0):1, (2,1):1, (4,0):1}

Match: (1,1):1

count +=1

Add (9 mod 5, 9 mod 2)=(4,1) to frequency map.

Frequency map: {(2,0):1, (2,1):1, (4,0):1, (4,1):1}

Process a6=6:

target_mod_x = (-6) mod 5 = (-6) + 10 = 4 mod 5

target_mod_y = 6 mod 2 = 0

target tuple: (4,0)

Frequency map: {(2,0):1, (2,1):1, (4,0):1, (4,1):1}

Match: (4,0):1

count +=1

Total count: 2

Which matches the example.

Great, seems correct.

Now, considering the constraints, n can be up to 2e5, and t up to 1e4, but the total sum of n is 2e5.

So, overall time complexity should be O(sum of n over all test cases), which is O(2e5).

In each test case, for each element, I perform constant time operations (computing mods, tuple lookups and updates in dictionaries), so it should be efficient enough.

Now, about the implementation.

In Python, dictionaries can be used to store the frequency maps.

I need to process each test case one by one.

Given that there can be up to 1e4 test cases, but the total n is 2e5, I need to make sure that my code is optimized and doesn't have any unnecessary loops or operations.

Also, reading the input efficiently is important.

In the given code, it reads all input at once, splits it into a list, and then processes the test cases.

This is efficient in terms of input reading.

Now, in the func_1 function, it iterates through each test case and for each test case, it iterates through the array once.

Inside the loop, it performs dictionary lookups and updates, which are O(1) operations.

So, overall, the time complexity should be acceptable.

Now, let's look at the code provided.

def func_1(test_cases):

results = []

for (n, x, y, arr) in test_cases:

count = 0

mod_x_map = {}

mod_y_map = {}

for num in arr:

mod_x = -num % x

mod_y = num % y

count += mod_x_map.get(mod_x, 0) + mod_y_map.get(mod_y, 0)

mod_x_key = num % x

mod_y_key = num % y

mod_x_map[mod_x_key] = mod_x_map.get(mod_x_key, 0) + 1

mod_y_map[mod_y_key] = mod_y_map.get(mod_y_key, 0) + 1

results.append(count)

return results

Wait a minute.

This code seems different from what I was thinking.

In my approach, I was thinking of maintaining two separate frequency maps: one for mod x and one for mod y.

But in this code, it's maintaining two frequency maps: mod_x_map and mod_y_map.

Then, for each num, it computes mod_x = -num % x and mod_y = num % y.

Then, it adds the frequency of mod_x in mod_x_map and the frequency of mod_y in mod_y_map to the count.

Wait, but in my earlier reasoning, I thought I needed to find pairs where a_j satisfies both conditions simultaneously.

But in this code, it's adding the frequencies from both maps separately.

That would count pairs that satisfy either condition, not both.

Wait, that can't be right.

Let me check again.

In the code:

count += mod_x_map.get(mod_x, 0) + mod_y_map.get(mod_y, 0)

This adds the count of a_j that satisfy a_j ≡ -num mod x and a_j ≡ num mod y separately.

But we need pairs that satisfy both conditions simultaneously.

This seems incorrect.

Wait, perhaps I misread the code.

Wait, no, it's clearly adding both frequencies separately.

This can't be right.

Let me think again.

In my earlier reasoning, I thought of maintaining a frequency map of tuples (mod_x, mod_y).

But in this code, it's maintaining two separate frequency maps for mod_x and mod_y.

This won't correctly count the pairs that satisfy both conditions simultaneously.

So, this code seems incorrect.

Wait, but according to the problem statement, the expected output for the sample input is given, and I need to verify if this code produces the correct output.

Wait, the code is given, and I need to determine if it's correct based on the problem description.

So, I need to verify if this code correctly solves the problem.

From my analysis, it seems that the code is incorrect because it adds the frequencies from two separate maps, which counts pairs that satisfy either condition, not both.

Let me check with the first test case.

n=6, x=5, y=2, a=[1,2,7,4,9,6]

According to the correct approach, there are 2 beautiful pairs.

But according to this code, let's see what it would do.

Initialize mod_x_map and mod_y_map as empty.

Initialize count=0.

Iterate through arr:

num=1:

mod_x = -1 % 5 = 4

mod_y = 1 % 2 = 1

count += mod_x_map.get(4,0) + mod_y_map.get(1,0) = 0 + 0 = 0

mod_x_key = 1 % 5 =1

mod_y_key=1 % 2=1

mod_x_map={1:1}

mod_y_map={1:1}

num=2:

mod_x = -2 % 5=3

mod_y=2%2=0

count += mod_x_map.get(3,0) + mod_y_map.get(0,0) = 0 + 0 =0

mod_x_key=2%5=2

mod_y_key=2%2=0

mod_x_map={1:1,2:1}

mod_y_map={1:1,0:1}

num=7:

mod_x=-7%5=3

mod_y=7%2=1

count += mod_x_map.get(3,0) + mod_y_map.get(1,0)=0 +1=1

mod_x_key=7%5=2

mod_y_key=7%2=1

mod_x_map={1:1,2:2}

mod_y_map={1:2,0:1}

num=4:

mod_x=-4%5=1

mod_y=4%2=0

count += mod_x_map.get(1,0) + mod_y_map.get(0,0)=1 +1=2

mod_x_key=4%5=4

mod_y_key=4%2=0

mod_x_map={1:1,2:2,4:1}

mod_y_map={1:2,0:2}

num=9:

mod_x=-9%5=1

mod_y=9%2=1

count += mod_x_map.get(1,0) + mod_y_map.get(1,0)=1 +2=3

mod_x_key=9%5=4

mod_y_key=9%2=1

mod_x_map={1:1,2:2,4:2}

mod_y_map={1:3,0:2}

num=6:

mod_x=-6%5=4

mod_y=6%2=0

count += mod_x_map.get(4,0) + mod_y_map.get(0,0)=2 +2=4

mod_x_key=6%5=1

mod_y_key=6%2=0

mod_x_map={1:2,2:2,4:2}

mod_y_map={1:3,0:3}

Total count=0+0+1+2+3+4=10

But according to the sample input, the expected output is 2 for this test case.

So, this code outputs 10, which is incorrect.

Hence, the code is incorrect.

Therefore, Correctness: False

**Final Answer**

\[\boxed{\text{False}}\]