Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a certain number, specifically 2^{a_i} for each stick i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which in terms of side lengths translates to the triangle inequality holding: the sum of any two sides must be greater than the third side.

So, my task is to count how many ways I can choose 3 sticks such that they satisfy the triangle inequality.

First, I need to understand the properties of the lengths given. Since the lengths are of the form 2^{a_i}, and exponents a_i can range from 0 to n, I should consider the properties of powers of 2.

One important property of powers of 2 is that they are distinct and double each time. So, 2^0 = 1, 2^1 = 2, 2^2 = 4, and so on. This means that each stick has a unique length in terms of powers of 2, except if there are duplicates in the a_i values.

Wait, but the problem states that a_i can be from 0 to n, and n can be up to 3*10^5, so a_i can be quite large, but since 2^{a_i} grows exponentially, the actual lengths can be very large numbers. But in Python, integers can handle arbitrary sizes, so that's not a problem.

But maybe there's a smarter way to handle this without dealing with huge numbers directly.

Let me think about the triangle inequality again. For three lengths to form a triangle, the sum of any two must be greater than the third. Given that the lengths are powers of 2, maybe there's a pattern or a property I can exploit.

Let's consider three lengths: 2^a, 2^b, and 2^c, where a <= b <= c. To form a triangle, we need 2^a + 2^b > 2^c.

Given that a <= b <= c, 2^a <= 2^b <= 2^c, so the largest side is 2^c. So, the condition simplifies to 2^a + 2^b > 2^c.

Now, since 2^a + 2^b is at most 2^{b} + 2^{b} = 2^{b+1} if a = b. But since a <= b, 2^a + 2^b is at most 2^{b+1}.

So, for 2^a + 2^b > 2^c to hold, we need 2^{b+1} > 2^c, which implies b+1 > c, or c < b+1.

But since a <= b <= c, and c is at least b, the condition c < b+1 means that c <= b.

Wait, but c >= b, so c <= b implies c = b.

So, if c = b, then 2^a + 2^b > 2^b, which simplifies to 2^a > 0, which is always true since a >= 0.

Therefore, whenever a <= b = c, the triangle inequality holds.

So, one case is when two or more sticks have the same a_i value.

Moreover, what if c > b? Then, c >= b+1, but we have 2^a + 2^b <= 2^b + 2^b = 2^{b+1}, which is equal to 2^c if c = b+1, or less if c > b+1.

So, if c = b+1, then 2^a + 2^b = 2^{b+1} = 2^c, which means 2^a + 2^b = 2^c, so the sum is equal to the third side, which does not satisfy the strict inequality required for a non-degenerate triangle.

If c > b+1, then 2^a + 2^b < 2^c, so the triangle inequality is not satisfied.

Therefore, the only way to form a triangle is when the three sticks have a_i values where at least two of them are equal.

In other words, if we have at least two sticks with the same a_i, then any combination of those two with a third stick having a_i <= that value will form a triangle.

Wait, no. From above, the only way to have a triangle is when the maximum a_i among the three sticks is equal to one of the other a_i's.

Wait, let's rephrase.

From earlier, for three sticks with a_i values a, b, c where a <= b <= c:

- If c = b, then 2^a + 2^b > 2^c since c = b, so 2^a + 2^b > 2^b, which simplifies to 2^a > 0, which is always true.

- If c > b, then 2^a + 2^b <= 2^b + 2^b = 2^{b+1}. If c >= b+1, then 2^{b+1} <= 2^c, so 2^a + 2^b <= 2^c, which does not satisfy the strict inequality required for a triangle.

Therefore, triangles can only be formed when the three sticks have a_i values where the largest a_i is equal to one of the other a_i's.

So, in other words, at least two of the a_i's must be equal.

Wait, but is that sufficient?

Wait, no. Consider three sticks with a_i = a, a, b where b <= a.

If b < a, then the lengths are 2^a, 2^a, and 2^b.

We need to check if 2^a + 2^b > 2^a, which simplifies to 2^b > 0, which is always true.

Similarly, 2^a + 2^a > 2^b, which is 2^{a+1} > 2^b, which holds since a+1 > b (because b <= a).

And 2^a + 2^b > 2^a, which we already have.

Therefore, as long as at least two a_i's are equal or all three a_i's are equal, the triangle inequality holds.

Wait, no. From above, as long as the maximum a_i is equal to at least one of the other a_i's, the triangle inequality holds.

So, in terms of counts, for three sticks, if the maximum a_i is equal to at least one of the other a_i's, it's a valid triangle.

Otherwise, if all three a_i's are distinct and the maximum is greater than the other two, it's invalid.

So, to count the number of valid triangles, I need to count the number of triplets where the maximum a_i is equal to at least one of the other a_i's.

Let me think about how to compute this efficiently.

Given that n can be up to 3*10^5 and t up to 10^4, but the total sum of n over all test cases is up to 3*10^5, I need an efficient way to process each test case.

First, I can group the sticks by their a_i values. Let's say I have a frequency count of how many sticks have each a_i value.

Letâ€™s denote freq[x] as the number of sticks with a_i = x.

Given that a_i can be from 0 to n, and n can be up to 3*10^5, the possible a_i values are up to n.

But since a_i can be up to n, which is up to 3*10^5, I need to handle frequencies up to that.

Now, to count the number of valid triplets, I need to consider the cases where at least two a_i's are equal in the triplet.

So, total number of ways to choose any 3 sticks is C(n, 3) = n*(n-1)*(n-2)/6.

From this, I need to subtract the number of invalid triplets, which are the ones where all three a_i's are distinct and the maximum a_i is greater than the other two.

Wait, but from earlier, the invalid triplets are those where all three a_i's are distinct and the maximum a_i is strictly greater than the sum of the other two a_i's.

Wait, no. Actually, in terms of a_i's, since the lengths are 2^{a_i}, and we have the condition that the sum of any two must be greater than the third, which translates to the condition on a_i's as described earlier.

Wait, perhaps there's a better way.

Let me consider that for three sticks with a_i values a, b, c where a <= b <= c:

- If c = b, then it's valid.

- If c > b, it's invalid.

Therefore, the valid triplets are those where the largest a_i is equal to one of the other a_i's.

So, to count the number of such triplets, I can iterate over all possible a_i values and count the number of ways to choose at least two sticks with the same a_i.

Let me think about it differently.

The total number of ways to choose any 3 sticks is C(n, 3).

From this, subtract the number of triplets where all three a_i's are distinct and the largest a_i is greater than the other two.

But this might be complicated to compute directly.

An alternative approach is to iterate over all possible a_i values and count the number of triplets where at least two sticks have that a_i.

Wait, perhaps it's better to fix the a_i value that is repeated and count the triplets accordingly.

Let me consider that.

Suppose I fix an a_i value, say x, and I have freq[x] sticks with a_i = x.

Then, the number of ways to choose exactly two sticks with a_i = x and one stick with a_i != x is C(freq[x], 2) * (n - freq[x]).

Additionally, the number of ways to choose all three sticks with a_i = x is C(freq[x], 3).

So, the total number of valid triplets would be the sum over all x of [C(freq[x], 2) * (n - freq[x]) + C(freq[x], 3)].

Wait, but I need to ensure that in the case where I choose two sticks with a_i = x and one with a_i < x, it's valid, as per the earlier condition.

Wait, no. From earlier, if I have two sticks with a_i = x and one with a_i <= x, it's valid.

Wait, more precisely, if I have two sticks with a_i = x and one with a_i <= x, it's valid.

Because in that case, the largest a_i is x, and since there are two sticks with a_i = x, the sum of any two will be greater than the third.

Wait, but if I have two sticks with a_i = x and one with a_i < x, then 2^{a_i} + 2^{a_i} = 2^{x+1}, which is greater than 2^{a_i} where a_i < x, since 2^{x+1} > 2^{a_i}.

Wait, no, if a_i < x, then 2^{a_i} + 2^{x} could be less than or equal to 2^{x}, depending on a_i.

Wait, no.

Wait, if I have two sticks with a_i = x and one with a_i < x, then the sum of the two larger sticks is 2^{x} + 2^{x} = 2^{x+1}, which is greater than 2^{a_i} where a_i < x, since 2^{x+1} > 2^{a_i} for a_i < x.

Wait, but actually, 2^{x} + 2^{x} = 2^{x+1}, which is greater than 2^{x}, but in this case, the third stick has a_i < x, so 2^{a_i} < 2^{x}.

So, 2^{x} + 2^{a_i} > 2^{x} is always true, since 2^{a_i} > 0.

Similarly, 2^{x} + 2^{x} > 2^{a_i} is true.

And 2^{x} + 2^{a_i} > 2^{x} is true.

Therefore, any triplet with at least two sticks having the same a_i is valid.

Therefore, the total number of valid triplets is the sum over all x of [C(freq[x], 2) * (n - freq[x]) + C(freq[x], 3)].

Wait, but I need to make sure that when I choose two sticks with a_i = x and one with a_i < x, it's valid.

Wait, actually, from earlier, it's valid as long as the largest a_i is equal to at least one of the other a_i's.

So, if I have two sticks with a_i = x and one with a_i < x, it's valid.

But if I have two sticks with a_i = x and one with a_i > x, then it's invalid, because the largest a_i is greater than x, and the other two are x, so 2^{x} + 2^{x} = 2^{x+1}, which may or may not be greater than 2^{a_i} where a_i > x.

Wait, if a_i > x, then 2^{a_i} > 2^{x+1}, so 2^{x} + 2^{x} = 2^{x+1} may be less than or equal to 2^{a_i}.

Wait, 2^{x+1} < 2^{a_i} if a_i > x+1.

So, if a_i = x+1, then 2^{x} + 2^{x} = 2^{x+1} = 2^{a_i}, which is equal, but the triangle inequality requires strict inequality.

So, if a_i = x+1, then 2^{x} + 2^{x} = 2^{x+1} = 2^{a_i}, which does not satisfy the strict inequality.

If a_i > x+1, then 2^{x} + 2^{x} = 2^{x+1} < 2^{a_i}, which does not satisfy the inequality.

Therefore, choosing two sticks with a_i = x and one stick with a_i > x is invalid.

Therefore, when choosing two sticks with a_i = x, the third stick must have a_i <= x to form a valid triangle.

So, in the earlier expression, it's correct to have C(freq[x], 2) * (freq[x]) for choosing two sticks with a_i = x and one with a_i <= x.

Wait, no. freq[x] includes sticks with a_i = x.

Wait, actually, if I have freq[x], and I choose two sticks with a_i = x, and one stick with a_i <= x, then the number of such triplets is C(freq[x], 2) * (freq[x]).

Wait, no, freq[x] is the count of sticks with a_i = x.

If I want to choose two sticks with a_i = x and one stick with a_i <= x, but the sticks with a_i < x are separate.

Wait, perhaps I need to accumulate the frequencies in a certain way.

Let me consider sorting the a_i values and then accumulating the counts.

Suppose I sort the a_i values in increasing order.

Letâ€™s sort the a_i values: a1 <= a2 <= ... <= an.

Then, for each a_i, I can keep track of how many sticks have a_j <= a_i.

Letâ€™s denote prefix[i] = number of sticks with a_j <= a_i.

Then, for each a_i, the number of ways to choose two sticks with a_j = a_i and one stick with a_j <= a_i is C(freq[a_i], 2) * prefix[i].

Wait, but I need to be careful not to double-count.

Alternatively, perhaps it's better to iterate over all possible a_i values and sum the combinations accordingly.

Wait, perhaps there's a better mathematical approach.

Let me consider that the total number of valid triplets is the sum over all x of [C(freq[x], 3) + C(freq[x], 2) * (prefix[x] - freq[x])], where prefix[x] is the total number of sticks with a_j <= x.

Wait, prefix[x] would be the sum of freq[y] for all y <= x.

So, for each x, C(freq[x], 3) counts the triplets where all three sticks have a_i = x.

And C(freq[x], 2) * (prefix[x] - freq[x]) counts the triplets where two sticks have a_i = x and one stick has a_i < x.

This seems correct.

But perhaps there's a smarter way to compute this efficiently.

Given that n can be up to 3*10^5 and t up to 10^4, but the sum of n over all test cases is up to 3*10^5, I need an O(n log n) solution per test case.

So, here's a plan:

- For each test case:

- Read n and the list a1, a2, ..., an.

- Sort the a_i values in increasing order.

- Compute prefix[x] for each x, which is the cumulative sum up to x.

- Then, iterate over each x and compute C(freq[x], 3) + C(freq[x], 2) * (prefix[x] - freq[x]).

- Sum these up for all x to get the total number of valid triplets.

Wait, but computing prefix[x] for each x up to n could be time-consuming if done naively.

Alternatively, since a_i can be up to n (3*10^5), I can use a frequency array of size n+1 to store freq[x].

Then, compute prefix[x] as the cumulative sum of freq[0 to x].

Then, for each x, compute C(freq[x], 3) + C(freq[x], 2) * prefix[x-1], because prefix[x-1] gives the number of sticks with a_j < x.

Wait, yes, that makes sense.

So, here's the step-by-step plan:

1. Read the number of test cases t.

2. For each test case:

a. Read n.

b. Read the list of a1, a2, ..., an.

c. Initialize a frequency array freq of size (max_a + 1), where max_a is the maximum a_i in the list or n, whichever is larger.

d. Count the frequency of each a_i in the list and store it in freq.

e. Compute the prefix sum array prefix, where prefix[x] = sum of freq[0 to x].

f. Initialize ans = 0.

g. For each x from 0 to max_a:

- If freq[x] >= 3, add C(freq[x], 3) to ans.

- If freq[x] >= 2, add C(freq[x], 2) * prefix[x-1] to ans.

h. Print ans.

Now, to optimize this, I need to make sure that the frequency array and prefix sums are computed efficiently.

Given that a_i can be up to n and n can be up to 3*10^5, using a frequency array of size 3*10^5 + 1 is feasible.

Also, since the sum of n over all test cases is up to 3*10^5, this should be efficient enough.

I need to implement this efficiently in Python.

Let me think about how to implement the combination functions C(n, k).

I can precompute factorial up to n and use that to compute C(n, k) = factorial[n] / (factorial[k] * factorial[n - k]).

But given that n can be up to 3*10^5, storing factorial up to 3*10^5 might be too memory-intensive, as factorial values can be very large.

But in Python, integers can handle arbitrary sizes, so it's not a problem, but computing factorial for each test case would be time-consuming.

Alternatively, I can compute C(n, k) on the fly using a function that computes C(n, k) directly.

Given that I only need C(n, 2) and C(n, 3), I can use the formulas:

C(n, 2) = n * (n - 1) / 2

C(n, 3) = n * (n - 1) * (n - 2) / 6

I can implement these directly in the code.

Now, considering that, here's how I can structure the code:

- Read all input data at once for efficiency.

- For each test case:

- Read n.

- Read the list of a1, a2, ..., an.

- Find the maximum a_i in the list.

- Initialize freq array of size max_a + 1 with zeros.

- Count the frequency of each a_i.

- Compute the prefix sum array.

- Initialize ans = 0.

- Iterate over each x from 0 to max_a:

- If freq[x] >= 3, add C(freq[x], 3) to ans.

- If freq[x] >= 2, add C(freq[x], 2) * prefix[x-1] to ans.

- Print ans.

Wait, but in the code provided, it seems to be doing something similar.

Let me look at the provided program and see if it matches this logic.

Looking at the provided program:

- It reads all input at once.

- Parses the input into data list.

- Initializes idx = 0.

- Reads t from data[idx].

- For each test case:

- Reads n from data[idx].

- Reads the list of a1 to an from data[idx].

- Initializes v as a list of size n+1 with zeros.

- Counts the frequency of each a_i in v.

- Initializes cnt = 0 and ans = 0.

- Iterates over i from 0 to n:

- If v[i] >= 2, ans += cnt * v[i] * (v[i] - 1) // 2

- If v[i] >= 3, ans += v[i] * (v[i] - 1) * (v[i] - 2) // 6

- cnt += v[i]

- Appends ans to results.

- Prints all results joined by newline.

Now, comparing this to my planned approach:

- The frequency count is done in v, which is of size n+1.

- It then iterates over i from 0 to n:

- If v[i] >= 2, it adds cnt * v[i] * (v[i] - 1) // 2 to ans.

- If v[i] >= 3, it adds v[i] * (v[i] - 1) * (v[i] - 2) // 6 to ans.

- cnt += v[i]

- Finally, it prints the ans for each test case.

Now, I need to verify if this implementation matches my logic.

In my logic, for each x, I would add:

- C(freq[x], 3) if freq[x] >= 3

- C(freq[x], 2) * prefix[x-1] if freq[x] >= 2

Where prefix[x-1] is the number of sticks with a_j < x.

In the provided code, it's using cnt to accumulate the prefix sum.

At each step, cnt represents the sum of v[0 to i-1], which is prefix[i-1].

So, when v[i] >= 2, it adds cnt * v[i] * (v[i] - 1) // 2 to ans.

This corresponds to C(freq[i], 2) * prefix[i-1], which is correct.

And when v[i] >= 3, it adds v[i] * (v[i] - 1) * (v[i] - 2) // 6 to ans, which is C(freq[i], 3).

So, yes, this matches my planned approach.

Therefore, the provided program is correct.

**Final Answer**

\boxed{\text{The given program is correct.}}