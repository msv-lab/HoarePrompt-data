Alright, I've got this problem to solve. Let's see what it's about. There are two players, Alice and Bob, playing a game on an array of integers. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from the original array a, appends it to c, and deletes it from a. On Bob's turn, he picks an element from a, and just deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not present in c. Alice wants to maximize the score, while Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, the goal is to find the MEX of array c, which is built by Alice picking elements and adding them to c, while Bob tries to interfere by deleting elements without adding to c.

Let me think about how Alice and Bob can play optimally.

Alice wants to maximize the MEX, which means she wants c to have as many of the smaller non-negative integers as possible. Bob, on the other hand, wants to minimize the MEX, so he wants to prevent Alice from having those smaller integers in c.

Let's consider the total number of moves. Since Alice starts and they alternate turns, if n is odd, Alice makes one more move than Bob. Specifically, if n is even, both make n/2 moves. If n is odd, Alice makes (n+1)/2 moves, and Bob makes (n-1)/2 moves.

But in this game, Alice not only picks elements but also adds them to c, while Bob just deletes elements. So, the composition of c depends on Alice's choices.

Wait, actually, c is built only from the elements Alice picks and adds to it. Bob's actions only affect what's left in a for Alice to choose from, by deleting elements that Alice didn't pick.

Wait, no. Let's read the problem again carefully.

" On Alice's turn, she picks one element from a, appends that element to c, and then deletes it from a.

On Bob's turn, he picks one element from a, and then deletes it from a.

"

So, Alice picks an element, adds it to c, and deletes it from a. Bob picks an element, deletes it from a, but does not add it to c.

So, c consists only of the elements Alice chose to add to it.

The game ends when a is empty.

The score is the MEX of c, which is the smallest non-negative integer not present in c.

Alice wants to maximize the MEX, which is counterintuitive because higher MEX means that some smaller numbers are missing from c. Actually, higher MEX implies that more smaller numbers are present in c, because the first missing one is larger.

Wait, no. If c contains [0,1,2,3], MEX is 4. If c contains [0,1,3], MEX is 2. So, to have a higher MEX, Alice needs to have more of the smaller numbers in c.

But Alice wants to maximize the MEX, which means she wants the highest possible MEX, meaning that she wants c to miss the smallest possible number.

Wait, this is confusing. Let's think differently.

The MEX is the smallest non-negative integer not present in c. So, if c contains all numbers from 0 to k-1, but not k, then MEX is k.

Alice wants this k to be as large as possible, meaning she wants c to contain as many of the smaller numbers as possible.

Bob wants to minimize k, meaning he wants to prevent Alice from having those smaller numbers in c.

So, Alice will try to pick the smaller numbers to include in c, while Bob will try to remove those smaller numbers so that Alice can't include them.

But Alice can choose which elements to add to c, and Bob can choose which to remove.

Wait, but Bob can only delete elements on his turn, not add them to c.

So, Alice can select elements to add to c, and both players delete elements from a.

But Alice decides which elements go into c.

Wait, but in Alice's turn, she picks an element, adds it to c, and deletes it from a.

Bob picks an element, deletes it from a, but does not add it to c.

So, the elements in c are only those that Alice chose to add.

So, the question is, given that Alice and Bob play optimally, what will be the MEX of c.

I need to find, for each test case, the final MEX of c.

Constraints are t up to 2*10^4, n up to 2*10^5, sum of n over all t is up to 2*10^5, so I need an efficient solution, O(n) per test case or better.

Let me try to think of small examples to understand the game.

Example 1:

n=4

a=[0,0,1,1]

One possible game:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 0, a=[0,1]

- Alice picks 0, c=[1,0], a=[1]

- Bob picks 1, a=[]

c=[1,0], MEX is 2.

Another possible game:

- Alice picks 0, c=[0], a=[0,1,1]

- Bob picks 1, a=[0,1]

- Alice picks 1, c=[0,1], a=[0]

- Bob picks 0, a=[]

c=[0,1], MEX is 2.

Another possible game:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 1, a=[0,0]

- Alice picks 0, c=[1,0], a=[0]

- Bob picks 0, a=[]

c=[1,0], MEX is 2.

Seems like MEX is 2 in all these scenarios.

Example 2:

n=4

a=[0,1,2,3]

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

c=[0,2], MEX is 1.

Another possible game:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob picks 3, a=[]

c=[1,2], MEX is 0.

Another possible game:

- Alice picks 2, c=[2], a=[0,1,3]

- Bob picks 1, a=[0,3]

- Alice picks 0, c=[2,0], a=[3]

- Bob picks 3, a=[]

c=[2,0], MEX is 1.

It seems like MEX can be 0 or 1 in this case, and the answer is 1, which is the minimal possible MEX that Alice can achieve despite Bob's attempts to minimize it.

Wait, no. Alice wants to maximize the MEX, Bob wants to minimize it. So, the final score is the MEX that Alice achieves against Bob's opposition.

In the first test case, MEX is 2.

In the second test case, MEX is 1.

In the third test case, n=2, a=[1,1]

Possible game:

- Alice picks 1, c=[1], a=[1]

- Bob picks 1, a=[]

c=[1], MEX is 0.

Another possible game:

- Alice picks 1, c=[1], a=[1]

- Bob picks 1, a=[]

c=[1], MEX is 0.

So, MEX is always 0 in this case.

Okay, now I need to find a general strategy for Alice and Bob.

Let me think about the game in terms of available numbers and their frequencies.

Suppose I count the frequency of each number in a.

Let freq[i] be the number of times i appears in a.

Alice wants to include as many smaller i's in c as possible, while Bob wants to prevent that.

Since Alice starts first, she can pick the smallest available i each time, but Bob can interfere by deleting elements.

I need to model their optimal play.

Let me consider that the game is turn-based, with Alice and Bob alternately making moves.

Total number of moves is n, with Alice making ceil(n/2) moves and Bob making floor(n/2) moves, since Alice starts.

But more importantly, Alice gets to choose which elements to include in c.

Wait, but Bob can delete elements that Alice might want to include.

Wait, no. Bob deletes elements from a, which might be the elements Alice wants to include.

But Alice chooses which elements to include in c when she picks them.

Wait, perhaps I need to think in terms of available elements at each turn.

This seems complicated. Maybe I can think in terms of frequencies.

Suppose I have freq[i], the count of i in a.

Alice wants to maximize the MEX, which means she wants to include as many smaller i's in c as possible.

Bob wants to minimize the MEX, meaning he wants to prevent Alice from including smaller i's in c.

So, for each i from 0 to n, if freq[i] > 0, Alice can try to include it in c, and Bob can try to delete it.

I need to determine, for each i, whether Alice can include it in c, considering Bob's opposition.

Let me consider that for each i, the number of times it appears in a is freq[i].

Alice wants to include as many copies of i as possible in c, but Bob can delete some of them.

Since Alice moves first, she can choose to pick an i and add it to c, or pick some other j.

Bob can delete elements, potentially removing i's that Alice hasn't picked yet.

This seems complex. Maybe I can think in terms of the number of times Alice can include each i in c.

Wait, perhaps I can think in terms of the number of times Alice can include i in c, given that Bob can delete some of them.

Let me consider that for each i, if freq[i] is the count in a, then the number of times Alice can include i in c is ceil(freq[i]/2), assuming she gets to choose to include every second one, while Bob deletes the others.

Wait, but Bob can choose which elements to delete, not necessarily the ones Alice wants to include.

Wait, perhaps it's better to think in terms of the total number of times Alice can include elements in c.

Since Alice makes ceil(n/2) moves, she can include up to ceil(n/2) elements in c.

But she needs to choose which elements to include to maximize the MEX.

But she has to include smaller elements to maximize the MEX.

Wait, no. To maximize the MEX, she needs to include as many smaller elements as possible in c.

So, she should try to include as many 0's, then 1's, etc., up to the point where she can't include any more of a particular i.

But Bob is trying to prevent her from including them.

I need to find out, for each i from 0 to n, whether Alice can include at least one i in c.

If she can include all i from 0 to k-1, but not k, then MEX is k.

So, I need to find the smallest k such that Alice cannot include k in c, despite Bob's deletions.

Let me try to model this.

For each i from 0 to n:

If freq[i] >= 2, then Alice can include one instance of i in c, because even if Bob deletes one, there's still one left for Alice to include.

If freq[i] == 1, then Alice can include it in c only if she picks it before Bob deletes it.

If freq[i] == 0, then Alice cannot include i in c.

So, for freq[i] >= 2, Alice can include one in c.

For freq[i] == 1, Alice can include it only if she picks it before Bob deletes it.

Wait, but the game is sequential, and they take turns.

This seems tricky.

Maybe I can think in terms of the number of times Alice gets to pick elements.

Total moves: n, Alice makes ceil(n/2) moves, Bob makes floor(n/2) moves.

But it's not just about the number of moves, but also the choices they make.

Wait, perhaps I can think in terms of the minimal i that Alice cannot include in c, despite her best efforts.

So, for each i, starting from 0, check if Alice can include i in c.

If she can include all i from 0 to k-1, but not k, then MEX is k.

So, for freq[i] >=2, Alice can include one in c.

For freq[i] ==1, Alice can include it only if she picks it before Bob deletes it.

Wait, but Bob can delete any element, not necessarily i.

So, if freq[i] ==1, Alice can include it only if she picks it before Bob deletes it.

But Bob might delete something else, allowing Alice to pick i later.

This seems complicated.

Maybe I need to think in terms of the number of times Alice can pick i before Bob can delete it.

Wait, perhaps it's simpler.

Suppose I have freq[i], the count of i in a.

If freq[i] >=2, Alice can include one in c, because even if Bob deletes one, Alice can pick the other.

If freq[i] ==1, Alice can include it only if she picks it before Bob deletes it.

If freq[i] ==0, Alice cannot include it.

So, for each i from 0 to n:

If freq[i] >=2, Alice can include one in c.

If freq[i] ==1, Alice can include it only if she gets to pick it before Bob deletes it.

But Bob has floor(n/2) moves, and Alice has ceil(n/2) moves.

So, if freq[i] ==1, Alice can include it if she picks it before Bob's floor(n/2) deletions.

Wait, but Bob can delete any elements, not necessarily i.

So, if freq[i] ==1, Alice can include it unless Bob deletes it before Alice picks it.

But Bob can choose to delete i if he wants to prevent Alice from including it.

So, for freq[i] ==1, Alice can include i only if she picks it before Bob deletes it.

But Bob can choose to delete i if he wants to.

So, for freq[i] ==1, Alice can include i only if she picks it on her first move, before Bob gets a chance to delete it.

Wait, no. Bob gets to delete one element per turn, but Alice picks first.

So, in the first turn, Alice picks an element and adds it to c, deleting it from a.

Then Bob picks an element and deletes it from a.

And so on.

So, for freq[i] ==1:

- If Alice picks it on her first turn, it goes to c.

- If Alice doesn't pick it on her first turn, Bob can delete it on his turn.

So, for freq[i] ==1, Alice can include it in c only if she picks it on her first turn.

If she waits, Bob can delete it.

Therefore, for freq[i] ==1, Alice can include it in c only if she picks it on her first turn.

Similarly, for freq[i] >=2, Alice can include one in c, because even if Bob deletes one, there's still one left for Alice to pick.

Wait, but if freq[i] >=2, Alice can include one in c, because Bob can delete one, but Alice can pick the other.

Wait, but Bob can delete any element, not necessarily i.

So, if freq[i] >=2, Alice can include one in c, because even if Bob deletes one i, there's still one left for Alice to pick.

Similarly, if freq[i] ==1, Alice can include it only if she picks it before Bob deletes it.

But Bob can choose to delete i if he wants to prevent Alice from including it.

So, for freq[i] ==1, Alice can include it only if she picks it on her first turn.

Because if she waits, Bob can delete it on his turn.

Wait, but Alice has multiple turns.

Let me think carefully.

Suppose freq[i] ==1.

Alice can pick it on her first turn, adding it to c and deleting it from a.

Or, she can wait and pick something else, but then Bob can delete it.

So, to ensure she includes it in c, she needs to pick it on her first turn.

But, she might have other priorities on her first turn.

Wait, but to maximize the MEX, she might want to pick higher i's first.

But no, to maximize MEX, she wants to include smaller i's in c.

So, she should pick the smallest available i's first.

But Bob wants to minimize the MEX, so he would try to prevent Alice from including smaller i's.

So, for each i from 0 to n:

- If freq[i] >=2, Alice can include one in c.

- If freq[i] ==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But Bob can choose to delete i if he wants to prevent Alice from including it.

So, for freq[i] ==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But Bob can choose to delete i if he wants to.

So, for freq[i] ==1, Alice can include it only if she picks it on her first turn.

Because after her first turn, Bob can delete it.

Wait, but Bob deletes on his turn, which is after Alice's pick.

So, if Alice picks something else on her first turn, Bob can delete i, preventing Alice from including it.

Wait, but if Alice picks i on her first turn, she includes it in c.

If she picks something else on her first turn, Bob can delete i, preventing Alice from including it.

So, for freq[i] ==1, Alice can include it in c only if she picks it on her first turn.

Similarly, for freq[i] >=2, she can include one in c, because even if Bob deletes one, there's still one left for Alice to pick.

Wait, but Bob can delete any element, not necessarily i.

So, for freq[i] >=2, Alice can include one in c, because Bob can delete one i, but Alice can pick the other.

Wait, but Bob might delete something else, allowing Alice to pick i later.

But in any case, with freq[i] >=2, Alice can ensure that at least one i is left for her to pick and include in c.

Wait, but what if Bob deletes other elements, allowing Alice to pick i multiple times?

Actually, with freq[i] >=2, Alice can include one i in c, because even if Bob deletes one i, Alice can pick the remaining one.

So, for freq[i] >=2, Alice can include one in c.

For freq[i] ==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But Bob can choose to delete it if he wants to prevent Alice from including it.

So, for freq[i] ==1, Alice can include it only if she picks it on her first turn.

Because after her first turn, Bob can delete it on his turn.

Wait, but Alice has multiple turns. Suppose n is even, so Alice has n/2 turns, Bob has n/2 turns.

Alice can pick i on her second turn, but Bob can delete it on his first turn.

Wait, no. Alice picks first, then Bob picks, then Alice picks again, and so on.

So, on Alice's first pick, she can pick i and include it in c, deleting it from a.

If she doesn't, Bob can delete it on his turn.

So, for freq[i] ==1, Alice can include it in c only if she picks it on one of her turns before Bob deletes it.

But Bob can delete it on his turn if it's still available.

So, for freq[i] ==1, Alice can include it only if she picks it on her first turn.

Because if she waits, Bob can delete it on his turn.

Wait, but suppose n=4, freq[i]=1.

Alice picks something on her first turn, Bob deletes something on his turn, Alice picks i on her second turn, includes it in c.

But in this case, Bob could have deleted i on his first turn if he wanted to.

So, for freq[i]==1, Alice can include it only if she picks it on her first turn.

Similarly, for freq[i]>=2, she can include one in c.

So, the strategy is:

- For each i from 0 to n:

- If freq[i] >=2, Alice can include one in c.

- If freq[i] ==1, Alice can include it only if she picks it on her first turn.

But she has only ceil(n/2) turns, and she needs to choose which elements to include in c.

Wait, perhaps I need to think differently.

Let me consider that Alice can include in c all elements with freq[i] >=2, plus some elements with freq[i]==1, depending on her first move.

But I need to find the smallest k such that Alice cannot include k in c.

So, I can iterate k from 0 to n:

- If freq[k] >=2, Alice can include it.

- If freq[k] ==1, Alice can include it only if she picks it on her first turn.

But she has only ceil(n/2) turns, and she needs to choose which elements to include.

Wait, perhaps I need to count the number of elements that Alice can include.

But the MEX is determined by the smallest missing integer in c.

So, it's not just about how many elements she can include, but which specific elements she can include.

This seems tricky.

Let me try to think of another approach.

Suppose I sort the elements that Alice can include in c.

I need to include as many small i's as possible.

So, I should include all i's with freq[i] >=2, and as many i's with freq[i]==1 as possible, prioritizing smaller i's.

But Bob can interfere by deleting some elements.

Wait, perhaps I can think in terms of the number of times Alice can include elements with freq[i]>=2, and how many with freq[i]==1 she can include based on her first move.

But I'm getting stuck.

Let me look back at the examples.

First test case:

n=4

a=[0,0,1,1]

freq[0]=2, freq[1]=2

So, for i=0, freq[0]>=2, Alice can include it.

Similarly, for i=1, freq[1]>=2, Alice can include it.

So, c can have both 0 and 1, so MEX is 2.

Second test case:

n=4

a=[0,1,2,3]

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

For each i from 0 to 3, freq[i]==1

So, Alice can include one of them on her first turn.

But she has ceil(4/2)=2 turns.

So, she can include one on her first turn, and another on her second turn.

But Bob has floor(4/2)=2 turns, and can delete two elements.

If Alice includes 0 on her first turn, Bob can delete 1 on his turn.

Then Alice can include 2 on her second turn.

So, c=[0,2], MEX=1.

Alternatively, Alice can include 1 on her first turn, Bob deletes 0, Alice includes 2 on her second turn, c=[1,2], MEX=0.

Wait, in the example, the output is 1, which seems to be the minimal possible MEX.

But according to the problem, Alice wants to maximize the MEX, Bob wants to minimize it.

So, the final score is the MEX that Alice achieves against Bob's opposition.

In this case, it's 1.

Wait, but in the second test case, the output is 1.

In the first test case, it's 2.

In the third test case, n=2, a=[1,1], output=0.

Wait, perhaps I need to think in terms of how many elements Alice can include.

Wait, perhaps I need to find the minimal k such that Alice cannot include k in c.

So, for each k from 0 to n:

- If freq[k] >=2, Alice can include it.

- If freq[k] ==1, Alice can include it only if she picks it on her first turn.

But she has ceil(n/2) turns.

Wait, perhaps I need to count the number of elements that Alice can include, considering that for freq[i]==1, she can include it only if she picks it on one of her turns before Bob deletes it.

This is getting too complicated.

Maybe I need to look for a different approach.

Let me consider that Alice can include in c all elements with freq[i] >=2, plus up to ceil(n/2) - number of i with freq[i]>=2 elements with freq[i]==1.

Wait, perhaps.

Let me define:

- Let A be the number of i with freq[i] >=2.

- Let B be the number of i with freq[i]==1.

Then, Alice can include A elements with freq[i]>=2, and up to ceil(n/2) - A elements with freq[i]==1.

But I need to verify this.

Total moves: n.

Alice makes ceil(n/2) moves, each time picking an element to include in c and deleting it.

Bob makes floor(n/2) moves, each time deleting an element.

So, total elements included in c is ceil(n/2).

Now, among these ceil(n/2) elements, Alice can choose which ones to include.

She wants to include as many small i's as possible.

So, she should include the smallest i's first.

So, sort the i's in ascending order, and include the smallest ones possible.

But Bob can interfere by deleting elements that Alice wants to include.

Wait, perhaps I can think in terms of available moves.

Alice has ceil(n/2) moves to include elements in c.

She needs to choose which elements to include to maximize the MEX.

To maximize the MEX, she needs to include as many small i's as possible.

So, she should try to include i=0, then i=1, and so on, up to the point where she can't include a particular i.

But Bob can delete elements to prevent her from including them.

So, for each i from 0 to n:

- If freq[i] >=2, Alice can include it, regardless of Bob's actions.

- If freq[i] ==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

So, the number of i's with freq[i]>=2 is A.

The number of i's with freq[i]==1 is B.

Alice has ceil(n/2) moves to include elements in c.

She should include the smallest A i's with freq[i]>=2, and then the smallest B i's with freq[i]==1, up to ceil(n/2) elements.

Wait, but if A + B < ceil(n/2), she can include all of them, and fill the remaining moves with any other elements.

But in this problem, since a contains only elements from 0 to n-1, and c is built from a, I need to make sure that the elements she includes are the smallest possible i's.

Wait, perhaps I need to think in terms of selecting the smallest possible i's that she can include in c.

So, sort the i's based on their frequency and choose the smallest i's that she can include.

Wait, perhaps it's better to iterate from i=0 to n:

- If freq[i] >=2, Alice can include it.

- If freq[i] ==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But Bob can choose to delete it on his turn if he wants to.

So, for freq[i]==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But Alice has ceil(n/2) turns, and Bob has floor(n/2) turns.

So, for each i with freq[i]==1, Alice can include it if she picks it on one of her first ceil(n/2) - A turns, where A is the number of i with freq[i]>=2.

Wait, perhaps.

Let me formalize this.

Let A be the number of i with freq[i]>=2.

Let B be the number of i with freq[i]==1.

Alice has ceil(n/2) moves to include elements in c.

She should include all A i's with freq[i]>=2, and then include as many i's with freq[i]==1 as possible.

But she can include up to ceil(n/2) - A i's with freq[i]==1.

But she needs to include the smallest possible i's.

So, sort the i's with freq[i]==1 in ascending order, and include the smallest ceil(n/2) - A of them.

Then, the MEX is the smallest i not included in c.

Wait, but this might not be correct, because Bob can delete some of the i's with freq[i]==1, preventing Alice from including them.

Wait, perhaps I need to consider that for freq[i]==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But with ceil(n/2) Alice's turns and floor(n/2) Bob's turns, Alice can include up to ceil(n/2) elements in c.

Among these, she can include all i with freq[i]>=2, and some with freq[i]==1.

But Bob can delete some i with freq[i]==1 to prevent Alice from including them.

Wait, perhaps I need to calculate the number of i with freq[i]>=2, and see if that's enough to reach the desired MEX.

Wait, maybe I should iterate k from 0 to n:

- Count the number of i from 0 to k-1 with freq[i]>=2.

- For those with freq[i]==1, Alice can include them only if she picks them on her first turn.

But this seems too vague.

Let me look for a different approach.

I found that in the first test case, MEX is 2.

In the second test case, MEX is 1.

In the third test case, MEX is 0.

Looking at the frequencies:

First test case: n=4, a=[0,0,1,1], freq[0]=2, freq[1]=2, so A=2, B=0.

Alice can include both 0 and 1 in c, so MEX is 2.

Second test case: n=4, a=[0,1,2,3], freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1, A=0, B=4.

Alice has ceil(4/2)=2 moves.

She can include two i's with freq[i]==1.

She should choose the smallest ones, i=0 and i=1.

So, c=[0,1], MEX=2.

But the output is 1, so this can't be right.

Wait, perhaps I'm missing something.

Wait, maybe she can include only one i with freq[i]==1.

Wait, no, she has two moves.

But Bob also has two moves, and can delete elements.

Wait, perhaps Bob can prevent Alice from including both 0 and 1.

For example:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob deletes 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob deletes 3, a=[]

c=[0,2], MEX=1.

Alternatively:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob deletes 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob deletes 3, a=[]

c=[1,2], MEX=0.

But the output is 1, which is the minimal MEX among possible games.

Wait, but the problem says that Alice wants to maximize the score (MEX), Bob wants to minimize it.

So, the final score is the MEX that Alice achieves against Bob's opposition.

In this case, it's 1.

So, perhaps the way to calculate it is:

- Count the number of i with freq[i]>=2, say A.

- Count the number of i with freq[i]==1, say B.

- Alice has ceil(n/2) moves to include elements in c.

- She should include the smallest A i's with freq[i]>=2, and then the smallest B i's with freq[i]==1, up to ceil(n/2) elements.

- The MEX is the smallest i not included in c.

But in the second test case, A=0, B=4, ceil(n/2)=2.

So, she includes the smallest two i's with freq[i]==1, say 0 and 1.

Then, MEX is 2.

But the output is 1.

So, this approach is incorrect.

Wait, perhaps I need to consider that Bob can delete elements that Alice wants to include.

So, for i with freq[i]==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But with ceil(n/2) Alice's turns and floor(n/2) Bob's turns, Alice can include up to ceil(n/2) elements in c.

But Bob can delete up to floor(n/2) elements.

So, for i with freq[i]==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

Wait, perhaps I can think in terms of the number of times Alice can include i with freq[i]==1.

If freq[i]==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

Given that Alice has ceil(n/2) turns, and Bob has floor(n/2) turns.

So, for each i with freq[i]==1, Alice can include it if she picks it on one of her first t turns, where t is ceil(n/2).

But Bob can delete it on his turn if it's still available.

Wait, perhaps I need to think in terms of the order of picking.

This seems too involved.

Let me look for a pattern in the sample inputs.

First test case:

n=4, a=[0,0,1,1], output=2.

Second test case:

n=4, a=[0,1,2,3], output=1.

Third test case:

n=2, a=[1,1], output=0.

Looking at these, perhaps the MEX is equal to the smallest i such that freq[i] < ceil((n - i)/2).

Wait, that seems arbitrary.

Alternatively, perhaps it's the smallest i such that freq[i] <= floor((n - i)/2).

But in the first test case, n=4, a=[0,0,1,1]:

freq[0]=2, freq[1]=2.

For i=0, freq[0]=2 >= ceil((4-0)/2)=2

For i=1, freq[1]=2 >= ceil((4-1)/2)=2

For i=2, freq[2]=0 < ceil((4-2)/2)=1

So, MEX=2, which matches.

Second test case:

n=4, a=[0,1,2,3]:

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

For i=0, freq[0]=1 >= ceil((4-0)/2)=2? No, 1 < 2, so MEX=0?

But the output is 1.

Wait, doesn't match.

Hmm.

Wait, perhaps it's the smallest i such that freq[i] < ceil((n - i)/2).

In the first test case:

For i=0, freq[0]=2 >= ceil((4-0)/2)=2

For i=1, freq[1]=2 >= ceil((4-1)/2)=2

For i=2, freq[2]=0 < ceil((4-2)/2)=1

So, MEX=2.

In the second test case:

For i=0, freq[0]=1 < ceil((4-0)/2)=2

So, MEX=0, but the output is 1.

Doesn't match.

Wait, perhaps it's the smallest i such that freq[i] < ceil((n - i)/2).

Wait, in the third test case:

n=2, a=[1,1]

freq[0]=0, freq[1]=2

For i=0, freq[0]=0 < ceil((2-0)/2)=1, so MEX=0, which matches the output.

But in the second test case, for i=0, freq[0]=1 < ceil((4-0)/2)=2, so MEX=0, but output is 1.

Hmm.

This approach is incorrect.

Let me try another idea.

Suppose I sort the i's in ascending order and try to include them in c.

I need to include as many small i's as possible.

So, iterate through i from 0 to n:

- If freq[i] >=2, include it.

- If freq[i]==1, include it only if Alice can pick it before Bob deletes it.

But I need to model this properly.

Wait, perhaps I can think in terms of the number of available i's with freq[i]>=2 and freq[i]==1.

Let me try to simulate the process.

Initialize a counter for each i from 0 to n with their frequencies.

Initialize c as empty.

Simulate the game:

- While a is not empty:

- Alice picks the smallest available i with freq[i]>=1, includes it in c, and deletes it from a.

- If a is not empty, Bob picks any element and deletes it from a.

- Repeat until a is empty.

But this doesn't account for Bob's optimal play to minimize the MEX.

Bob can choose to delete elements to prevent Alice from including certain i's.

Wait, perhaps I need to model the game more carefully.

Let me consider that Alice will try to include the smallest possible i's, and Bob will try to prevent that.

So, perhaps I can iterate through i from 0 to n, and check if Alice can include i in c.

To include i in c, either:

- freq[i] >=2, so even if Bob deletes one, Alice can pick the other.

- freq[i]==1, and Alice picks it on one of her turns before Bob deletes it.

Given that Alice starts first, she can pick i on her first turn, including it in c.

If freq[i]==1, and Alice doesn't pick it on her first turn, Bob can delete it on his first turn.

So, for freq[i]==1, Alice can include it only if she picks it on one of her turns before Bob deletes it.

But Alice has multiple turns.

Wait, suppose n=4, freq[i]==1 for i=0,1,2,3.

Alice has 2 turns, Bob has 2 turns.

If Alice picks i=0 on her first turn, includes it in c, deletes it from a.

Then, Bob can delete i=1.

Then, Alice picks i=2, includes it in c, deletes it from a.

Then, Bob deletes i=3.

So, c=[0,2], MEX=1.

Alternatively, Alice picks i=1 first, then Bob deletes i=0, then Alice picks i=2, c=[1,2], MEX=0.

So, in this case, the minimal MEX is 0, but the sample output is 1.

Wait, but in the second test case, n=4, a=[0,1,2,3], output=1.

So, perhaps my simulation is incorrect.

Wait, maybe I need to consider that Alice can choose to pick higher i's to maximize the MEX.

Wait, but Alice wants to maximize the MEX, so she should include as many small i's as possible.

But in this case, she can include two i's, so she can include 0 and 1, giving MEX=2.

But the output is 1, which is less than 2.

So, perhaps in some games, the MEX is 1, and in others, it's 2, and the minimal possible MEX is 1.

Wait, but the problem says that Alice wants to maximize the score (MEX), Bob wants to minimize it.

So, the final score is the MEX that Alice achieves against Bob's opposition.

In this case, it's 1.

But I don't understand why.

Wait, perhaps I need to think in terms of the minimal MEX that Alice can achieve despite Bob's attempts to minimize it.

So, in the second test case, Alice can achieve MEX=1, but not higher, because Bob can force it to be 1.

Wait, but in one of the simulations, c=[1,2], MEX=0.

But the output is 1, which is higher than 0.

Wait, perhaps I'm misunderstanding the problem.

Wait, the problem says that Alice wants to maximize the score (MEX), Bob wants to minimize it.

So, the final score is the MEX that Alice achieves against Bob's opposition.

In the second test case, the minimal MEX that Alice can achieve despite Bob's attempts to minimize it is 1.

So, in some games, Bob can force the MEX to be 1, and Alice cannot do better.

Hence, the output is 1.

In the first test case, Alice can achieve MEX=2, and Bob cannot prevent it.

In the third test case, Alice can achieve MEX=0, and Bob cannot prevent it.

So, I need to find, for each test case, the minimal MEX that Alice can achieve despite Bob's attempts to minimize it.

Wait, but the problem says that Alice wants to maximize the score, Bob wants to minimize it.

So, the final score is the MEX that Alice achieves against Bob's opposition.

In game theory terms, this is like finding the minimal MEX that Alice can guarantee.

Wait, no. Actually, in game theory, the minimax theorem says that the maximal value that Alice can guarantee is the minimal value that Bob can force.

Wait, perhaps I need to think in terms of game theory.

Let me consider that Alice wants to maximize the MEX, and Bob wants to minimize it.

So, the final MEX is determined by their optimal play.

To find the minimal MEX that Alice can guarantee despite Bob's attempts to minimize it.

Wait, but in the first test case, Alice can guarantee MEX=2.

In the second test case, Alice can guarantee MEX=1.

In the third test case, Alice can guarantee MEX=0.

So, perhaps the way to calculate it is:

- Count the number of i with freq[i]>=2, say A.

- Count the number of i with freq[i]==1, say B.

- Alice has ceil(n/2) moves to include elements in c.

- She should include the smallest A i's with freq[i]>=2, and then the smallest B i's with freq[i]==1, up to ceil(n/2) elements.

- The MEX is the smallest i not included in c.

