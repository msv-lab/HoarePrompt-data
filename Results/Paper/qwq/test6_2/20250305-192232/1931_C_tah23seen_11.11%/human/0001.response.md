Alright, I have this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers i, j, and x, where 1 ≤ i ≤ j ≤ n, and then setting all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is essentially the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I need to spend to achieve this. It's guaranteed that it can always be done, so I don't have to worry about cases where it's impossible.

First, I need to understand the operation clearly. I can choose a subarray defined by indices i and j, and set all elements in that subarray to a value x, and this costs (j - i + 1) burles. I can do this operation at most once.

Given that I can only perform this operation once, I need to think about how to use this operation to make the entire array equal in the most cost-effective way.

Let's consider some examples to get a better understanding.

Example 1:

Input:

6

1 2 3 4 5 1

Output:

4

Explanation:

If I choose i=2, j=4, x=8, the array becomes [1,8,8,8,5,1]. Then, I need to make the entire array equal. Maybe set the whole array to 8, which would cost 6 burles, but that's more than 4. Wait, the output is 4, so there must be a better way.

Wait, perhaps the operation is used to set a certain part, and then the rest is adjusted accordingly. But the problem says I can perform the operation at most once, meaning I can either perform it once or not at all. If I don't perform the operation, the array remains as it is, and I need to make all elements equal by some other means, but the problem states that the operation can be used to set elements to make them equal.

Wait, but the problem says "no more than once," which means I can choose to perform the operation zero or one time. If I perform it zero times, I need to make all elements equal without changing any elements, which is only possible if all elements are already equal. If they are not, I need to perform the operation once to make some elements equal to a certain value, and possibly leave some elements unchanged, such that the entire array becomes equal.

Wait, but in the first example, the array is [1,2,3,4,5,1]. If I set indices 2 to 4 to 1, the array becomes [1,1,1,1,5,1]. Then, I need to set the 5 to 1, which would cost 1 burle, but the total cost is 4 burles for setting indices 2 to 4 to 1, plus 1 burle for setting index 5 to 1, but the output is 4. Hmm, maybe I'm misunderstanding.

Wait, perhaps the operation can be used in a way that, by setting a certain subarray, the entire array becomes equal with minimal cost.

Let me look at the problem again. It says "no more than once," meaning I can perform the operation zero or one time. But in the example, the output is 4, which seems to suggest that setting indices 2 to 4 to 1 costs 3 burles, and then setting index 5 to 1 costs 1 burle, totaling 4 burles. But the problem says that the operation can be used at most once, so perhaps there's a different way to interpret it.

Wait, maybe the operation is used to set multiple subarrays in a single operation, but that seems unlikely given the problem statement. Let's read the problem statement again carefully.

"select three integers i, j, x (1 ≤ i ≤ j ≤ n) and assign all elements of the array with indexes from i to j the value x. The price of this operation depends on the selected indices and is equal to (j - i + 1) burles."

So, I can choose one subarray and set all its elements to one value x, and the cost is the number of elements in that subarray. I can do this operation at most once.

After performing this operation, the array will have all elements in the subarray set to x, and the rest remain as they are. Then, I need to make sure that the entire array is equal to some value, possibly x or another value, but with only this one operation.

Wait, but the problem says "make all the elements of the array equal," meaning that after performing this operation (if I choose to perform it), the entire array should have all elements equal to the same value.

So, in the first example, [1,2,3,4,5,1], if I set indices 2 to 4 to 1, the array becomes [1,1,1,1,5,1]. Then, I need to set the 5 to 1, which would cost 1 burle, but since I can perform the operation only once, perhaps I need to find a way to set a subarray that covers all unequal elements in one go.

Wait, but the operation can only be performed once. So, I need to choose a subarray such that, after setting it to x, the entire array becomes equal to x, possibly with some elements already equal to x.

Wait, maybe I need to find the minimum cost to set a subarray that, when set to x, makes the entire array equal to x.

So, perhaps I need to find the smallest subarray that, when set to x, makes the entire array equal to x.

Wait, but in the first example, setting indices 2 to 5 to 1 would make the array [1,1,1,1,1,1], which costs 4 burles, which matches the output.

Yes, that makes sense. So, in this case, by setting indices 2 to 5 to 1, the array becomes all 1s, and the cost is 4 burles.

Alternatively, I could set indices 1 to 6 to 1, which would also make the array all 1s, but that would cost 6 burles, which is more than 4.

So, the minimal cost is 4 burles.

Another way is to set indices 2 to 4 to 1, as in the initial thought, but that still requires an additional operation to set index 5 to 1, but since I can perform only one operation, that approach won't work.

Therefore, I need to find a single subarray to set to x such that, after setting, the entire array is equal to x, and the cost is minimized.

Wait, but in the second example:

7

1 1 1 1 1 1 1

Output:

0

Which makes sense because all elements are already equal, so no operation is needed.

Third example:

8

8 8 8 1 2 8 8 8

Output:

2

So, in this case, setting indices 4 and 5 to 8 would cost 2 burles, and the array becomes all 8s.

Fourth example:

1

1

Output:

0

Only one element, already equal.

Fifth example:

2

1 2

Output:

1

So, setting either element to the other's value would cost 1 burle.

Sixth example:

3

1 2 3

Output:

2

Setting indices 1 and 2 to 3, costing 2 burles, and the array becomes [3,3,3].

Alternatively, setting indices 2 and 3 to 1, costing 2 burles, resulting in [1,1,1].

Seventh example:

7

4 3 2 7 1 1 3

Output:

6

Setting indices 1 to 6 to 3, costing 6 burles, and the array becomes [3,3,3,3,3,3,3].

Eighth example:

9

9 9 2 9 2 5 5 5 3

Output:

7

Setting indices 3 to 9 to 5, costing 7 burles, and the array becomes [9,9,5,5,5,5,5,5,5]. Then, set indices 1 and 2 to 5, but since I can perform only one operation, this approach won't work. Wait, so perhaps setting indices 1 to 9 to 5, costing 9 burles, but that's more than 7. Maybe there's a better way.

Wait, perhaps setting indices 3 to 5 to 9, costing 3 burles, but that would make the array [9,9,9,9,9,5,5,5,3], still not all equal.

Alternatively, setting indices 6 to 9 to 9, costing 4 burles, making the array [9,9,2,9,2,9,9,9,9]. Still, indices 3 and 5 are 2, so I need to set them to 9, but that would require another operation, which I can't perform.

So, perhaps setting indices 3 to 9 to 9, costing 7 burles, resulting in [9,9,9,9,9,9,9,9,9], which matches the output.

Okay, so the strategy seems to be: find the minimal subarray to set to x such that, after setting, all elements in the array are equal to x.

Now, to generalize this, I need to find the smallest subarray to set to x so that all elements outside this subarray are already equal to x.

Wait, but in the first example, setting indices 2 to 5 to 1 makes the array all 1s, and indices 1 and 6 are already 1, so no need to change them.

Similarly, in the third example, setting indices 4 and 5 to 8 makes the array all 8s, as indices 1 to 3 and 6 to 8 are already 8.

In the fifth example, setting one element to match the other costs 1 burle.

In the sixth example, setting two elements to match the third costs 2 burles.

So, the general approach seems to be: find the value x that will be the final value of all elements, and find the minimal subarray that needs to be set to x so that the remaining elements are already x.

Wait, but in the sixth example, if I choose x=3, I need to set indices 1 and 2 to 3, costing 2 burles.

Alternatively, if I choose x=1, I need to set indices 2 and 3 to 1, costing 2 burles.

So, in both cases, the cost is 2 burles.

Similarly, in the first example, choosing x=1, I need to set indices 2 to 5 to 1, costing 4 burles.

Alternatively, choosing x=5, I need to set indices 1 to 4 and index 6 to 5, but that would cost more.

So, it seems that choosing x=1 is the optimal choice in the first example.

Wait, but how do I choose the optimal x?

Is there a way to choose x such that the minimal subarray to set to x minimizes the total cost?

Perhaps I need to iterate over all possible x values (from 1 to n, since a_i <= n), and for each x, calculate the minimal subarray that needs to be set to x to make all elements equal to x.

Then, choose the x that results in the minimal cost.

But this seems inefficient, especially since n can be up to 2e5, and t up to 1e4, so total time would be too high.

I need a smarter approach.

Let me think differently.

Suppose I choose x to be the most frequent element in the array. Then, the minimal subarray to set to x would be the subarray that covers all elements not equal to x.

But is this optimal?

Wait, in the first example, the most frequent element is 1, appearing twice. Setting indices 2 to 5 to 1 costs 4 burles, which matches the output.

In the third example, 8 appears four times, and setting indices 4 and 5 to 8 costs 2 burles.

In the fifth example, choosing x=1 or x=2, both appear once, so setting one element to match the other costs 1 burle.

In the sixth example, choosing x=1,2, or 3, all appear once, so setting two elements to make all three equal costs 2 burles.

So, choosing the most frequent element seems to be a good strategy, but I need to confirm if this always gives the minimal cost.

Wait, but what if there are multiple elements with the same frequency?

In such cases, choosing any of them should give the same cost, as the subarray to set would cover the same number of elements not equal to x.

Wait, but perhaps there's a better way.

Let me consider that the cost is equal to the number of elements not equal to x.

Wait, but no, because I can set a subarray to x, and the elements outside that subarray must already be equal to x.

So, the cost is equal to the length of the subarray that needs to be set to x.

Therefore, to minimize the cost, I need to maximize the length of the subarray where elements are already equal to x, because the total cost is n minus the length of the longest subarray with elements equal to x.

Wait, perhaps not.

Wait, let's think in terms of the minimal subarray to set to x such that all elements outside this subarray are already equal to x.

So, I need to find a subarray [i,j] such that all elements outside [i,j] are equal to x.

Then, the cost is (j - i + 1).

To minimize this cost, I need to maximize the length of the subarray where elements outside are equal to x.

In other words, find the maximal subarray [i,j] such that all elements before i and all elements after j are equal to x.

Then, the minimal cost is n minus the length of this subarray.

Wait, but I need to minimize the cost, which is the length of the subarray to set to x.

So, minimal cost is minimal over all x and subarrays where the subarray length is minimized.

Wait, perhaps I need to find, for each x, the minimal subarray to set so that all elements outside this subarray are already equal to x.

Then, the cost is the length of this subarray.

To minimize this, I need to maximize the subarray where elements outside are equal to x.

Wait, perhaps for each x, find the maximal subarray where elements outside are equal to x, then the minimal cost for that x is n minus this maximal subarray length.

Then, take the minimal over all x.

But I'm getting confused.

Let me try to formalize it.

Let x be the value to which we want to make all elements equal.

Let's find the minimal subarray [i,j] such that, after setting arr[i..j] to x, all elements in the array are equal to x.

This means that, for all positions k < i, arr[k] == x.

And for all positions k > j, arr[k] == x.

So, in other words, the prefix up to i-1 and the suffix from j+1 to n must already be equal to x.

So, for a given x, I need to find the minimal j - i + 1 such that arr[1..i-1] == x and arr[j+1..n] == x.

To find this, I can precompute the longest prefix and longest suffix that are equal to x.

Then, for each possible i and j, ensure that arr[1..i-1] == x and arr[j+1..n] == x, and minimize j - i + 1.

The minimal j - i + 1 would be over all i and j satisfying the above conditions.

To optimize this, for a given x, find the maximal j - i + 1 where arr[1..i-1] == x and arr[j+1..n] == x.

Then, the minimal subarray to set is n - (prefix + suffix - overlap).

Wait, this is getting complicated.

Perhaps a better way is:

For each x, find the minimal subarray to set to x such that the entire array becomes x.

This subarray should cover all positions where arr[k] != x.

So, the minimal subarray covering all arr[k] != x.

Then, the cost is the length of this subarray.

To find the minimal such cost over all x.

In the first example, x=1, positions where arr[k] != 1 are 2,3,4,5.

So, the minimal subarray covering these is from 2 to 5, length 4.

For x=5, positions where arr[k] !=5 are 1,2,3,4,6, so subarray from 1 to 6, length 6.

So, choosing x=1 is better.

In the third example, x=8, positions where arr[k] !=8 are 4,5, so subarray from 4 to 5, length 2.

Choosing x=1, positions where arr[k] !=1 are 1,2,3,6,7,8, so subarray from 1 to 8, length 8.

So, choosing x=8 is better.

So, the strategy is: for each x, find the minimal subarray that covers all positions where arr[k] != x.

Then, choose the x for which this subarray is minimal.

In other words, for each x, find the minimal j - i + 1 such that all arr[k] != x are within i <= k <= j.

This is equivalent to finding the minimal window that includes all positions where arr[k] != x.

Then, the cost is j - i + 1.

To find this minimal window for each x, I can:

- Identify all positions where arr[k] != x.

- Then, find the minimal subarray that covers all these positions.

But this seems inefficient for large n and t.

I need a better way.

Wait, perhaps I can think of it differently.

Suppose I fix x, then the positions where arr[k] != x need to be covered by the subarray [i,j].

So, the minimal subarray covering all arr[k] != x is the minimal window that includes all these positions.

To find this minimal window, I can find the minimal j - i + 1 such that all arr[k] != x are within i to j.

This is equivalent to finding the minimal subarray that covers all the non-x elements.

To find this efficiently, I can:

- Collect all positions where arr[k] != x.

- Then, find the minimal subarray that covers all these positions.

This can be done by finding the minimal j - i + 1 such that arr[i..j] contains all positions where arr[k] != x.

Wait, but actually, if I have all positions where arr[k] != x, say pos1, pos2, ..., pos_m, then the minimal subarray covering all these positions is from min(pos1, pos2, ..., pos_m) to max(pos1, pos2, ..., pos_m).

So, the minimal subarray is from the smallest position where arr[k] != x to the largest position where arr[k] != x.

Therefore, the minimal subarray length is max(pos) - min(pos) + 1, where pos are positions where arr[k] != x.

So, for each x, find the positions where arr[k] != x, and set the subarray from the minimal such position to the maximal such position to x.

The cost is max(pos) - min(pos) + 1.

Then, choose the x that minimizes this cost.

In the first example, for x=1, positions where arr[k] !=1 are 2,3,4,5.

So, min(pos)=2, max(pos)=5, cost=5-2+1=4.

For x=5, positions where arr[k] !=5 are 1,2,3,4,6.

So, min(pos)=1, max(pos)=6, cost=6-1+1=6.

So, choosing x=1 is better.

In the third example, x=8, positions where arr[k] !=8 are 4,5.

So, min(pos)=4, max(pos)=5, cost=2.

Choosing x=1, positions where arr[k] !=1 are 1,2,3,6,7,8.

So, min(pos)=1, max(pos)=8, cost=8.

So, choosing x=8 is better.

In the fifth example, x=1, positions where arr[k] !=1 is position 2, so cost=1.

x=2, positions where arr[k] !=2 is position 1, so cost=1.

So, minimal cost is 1.

In the sixth example, x=1, positions where arr[k] !=1 are 2,3, so cost=2.

x=2, positions where arr[k] !=2 are 1,3, so cost=2.

x=3, positions where arr[k] !=3 are 1,2, so cost=2.

So, minimal cost is 2.

This seems consistent with the sample outputs.

Therefore, the strategy is:

- For each possible x, find the positions where arr[k] != x.

- Find the minimal subarray that covers from the minimal such position to the maximal such position.

- The cost is max(pos) - min(pos) + 1, where pos are positions where arr[k] != x.

- If there are no positions where arr[k] != x, the cost is 0.

- Then, choose the x that gives the minimal such cost.

Now, to implement this efficiently, considering that n can be up to 2e5 and t up to 1e4, with total n over all test cases up to 2e5, I need an efficient way to compute this.

If I iterate over all possible x from 1 to n for each test case, and for each x, find the min and max positions where arr[k] != x, then the cost is max(pos) - min(pos) + 1.

Then, choose the minimal such cost over all x.

Given that n is up to 2e5 and t is up to 1e4, but total n over all test cases is up to 2e5, this should be efficient enough.

I need to make sure that the implementation is optimized.

Let me think about how to implement this.

For each test case:

- Read n and the array arr.

- For each possible x from 1 to n:

- Find all positions where arr[k] != x.

- If there are no such positions, cost is 0.

- Else, find the minimal subarray covering all these positions, which is from min(pos) to max(pos), with length max(pos) - min(pos) + 1.

- Keep track of the minimal such cost over all x.

- Output this minimal cost.

But iterating over all x from 1 to n for each test case would be O(t * n^2), which is too slow for n up to 2e5 and t up to 1e4.

Wait, but the total sum of n over all test cases is up to 2e5, so if I can make it O(n) per test case, it should be fine.

But iterating over all x from 1 to n and finding positions where arr[k] != x seems inefficient.

Is there a better way?

Wait, perhaps I can find, for each x, the positions where arr[k] != x.

But doing this explicitly would be too slow.

Alternatively, I can think about it differently.

Let me consider that the minimal subarray to set to x to make the entire array equal to x is the subarray from the first position where arr[k] != x to the last position where arr[k] != x.

So, for each x, the cost is last(pos) - first(pos) + 1, where pos are positions where arr[k] != x.

To find first(pos) and last(pos) for each x, I can:

- Find the first and last positions where arr[k] != x, for each x.

But iterating over all x from 1 to n would still be O(n^2).

Wait, perhaps I can find, for each x, the minimal and maximal positions where arr[k] != x.

To optimize this, I can iterate through the array once and keep track of the positions where arr[k] != x for each x.

But this seems tricky.

An alternative approach is to iterate through the array and group positions by the value that is not x.

Wait, this seems complicated.

Let me think differently.

Suppose I fix x and find the minimal subarray to set to x to make the entire array equal to x.

As I need to cover all positions where arr[k] != x, the minimal subarray is from the leftmost position where arr[k] != x to the rightmost position where arr[k] != x.

So, for each x, the cost is rightmost(arr[k] != x) - leftmost(arr[k] != x) + 1.

To compute this efficiently, I can:

- Find, for each x, the minimum position where arr[k] != x and the maximum position where arr[k] != x.

Then, the cost for x is max_pos[x] - min_pos[x] + 1.

To find min_pos[x] and max_pos[x], I can iterate through the array once and record for each x, the positions where arr[k] != x.

But storing positions for each x would be O(n^2).

This is not efficient.

An optimization is to note that for a given x, min_pos[x] is the first position where arr[k] != x, and max_pos[x] is the last position where arr[k] != x.

So, I can iterate through the array once and collect for each position k, the x where arr[k] != x.

Wait, that seems messy.

Perhaps a better way is to iterate through the array and keep track of the positions where arr[k] != x for each x.

But again, this seems inefficient.

Let me consider another approach.

Suppose I find the minimal cost over all possible x, which is the minimal (max(pos) - min(pos) + 1) where pos are positions where arr[k] != x.

This is equivalent to finding the minimal window that covers all positions where arr[k] != x, for each x.

But as I need to do this for each x, it's still inefficient.

Wait, perhaps I can find the minimal among all x of (max(pos) - min(pos) + 1).

So, I need to find the x where the range of positions where arr[k] != x is minimized.

In other words, find the x where the difference between the maximum position and minimum position where arr[k] != x is minimized.

So, I need to find the x where the span of positions where arr[k] != x is the smallest.

This seems like I need to find the x where the non-x elements are most concentrated in a small interval.

To find this efficiently, perhaps I can:

- For each position k, record the value arr[k].

- Then, for each x, collect the positions where arr[k] != x.

- Find the minimal (max(pos) - min(pos) + 1) over all x.

But again, this seems too slow for large n and t.

I need a smarter way.

Let me consider that the cost for x is the range of positions where arr[k] != x.

To minimize this, I need to maximize the concentration of non-x elements in a small interval.

Alternatively, think about it as finding the x that appears the most frequently at the boundaries.

Wait, perhaps I can find the value that appears the most in the array, and use that as x.

Then, the positions where arr[k] != x would be minimized, and the range would be minimized.

But is this always optimal?

In the first example, x=1 appears twice, and x=5 appears once.

Choosing x=1 gives a cost of 4, while choosing x=5 gives a cost of 6.

So, choosing the most frequent x minimizes the range.

Wait, but in the sixth example, all x appear once, so choosing any x gives the same cost.

Wait, but in that case, choosing any x would give the same cost, which is 2.

So, perhaps choosing the most frequent x is the way to go.

Wait, but in the third example, x=8 appears four times, and x=1 appears twice.

Choosing x=8 gives a cost of 2, while choosing x=1 gives a cost of 8.

So, choosing the most frequent x gives the minimal cost.

Similarly, in the first example, x=1 appears twice, which is more frequent than x=5 appearing once.

So, perhaps choosing the most frequent x minimizes the cost.

Is this always true?

Let me see.

Suppose the array is [1,2,1,2,1], n=5.

Here, x=1 appears three times, x=2 appears twice.

Choosing x=1, positions where arr[k] !=1 are 2 and 4.

So, cost is 4 - 2 + 1 = 3.

Choosing x=2, positions where arr[k] !=2 are 1,3,5.

So, cost is 5 -1 +1 =5.

So, choosing x=1 is better.

Another example: [1,2,3,1,2,3], n=6.

Each x appears twice.

Choosing x=1, positions where arr[k] !=1 are 2,3,5,6.

So, cost is 6-2 +1=5.

Choosing x=2, positions where arr[k] !=2 are 1,3,4,6.

Cost is 6-1 +1=6.

Choosing x=3, positions where arr[k] !=3 are 1,2,4,5.

Cost is 5-1 +1=5.

So, choosing x=1 or x=3 gives cost=5, choosing x=2 gives cost=6.

So, choosing the most frequent x doesn't necessarily give the minimal cost if multiple x have the same frequency.

Wait, but in this case, all x have the same frequency.

So, perhaps choosing any x in this case gives the same cost.

Wait, but in the previous example, choosing x=1 gives cost=5, and x=2 gives cost=6.

So, even when frequencies are the same, choosing different x can give different costs.

So, choosing the most frequent x doesn't always give the minimal cost.

Therefore, I need a better approach.

Let me think differently.

Suppose I iterate through all possible subarrays and find the minimal subarray such that, after setting it to some x, the entire array becomes equal to x.

Wait, but this seems too vague.

Alternatively, perhaps I can find the minimal subarray such that, after setting it to x, all elements outside this subarray are already equal to x.

So, for a given subarray [i,j], I need to choose x such that all elements outside [i,j] are equal to x.

Then, set the subarray [i,j] to x.

The cost is j - i + 1.

To minimize this cost, I need to choose [i,j] and x such that all elements outside [i,j] are equal to x, and j - i + 1 is minimized.

To find this efficiently, perhaps I can find, for each possible x, the minimal subarray that covers all positions where arr[k] != x.

Then, choose the x for which this subarray is minimal.

But again, this seems inefficient.

Wait, perhaps I can find, for each x, the minimal j - i + 1 such that all arr[k] != x are within i to j.

This is equivalent to finding, for each x, the minimal window that covers all positions where arr[k] != x.

To find this efficiently, I can:

- For each x, collect all positions where arr[k] != x.

- Then, find the minimal j - i + 1 such that all these positions are within i to j.

But this is the same as finding the minimal subarray that covers all arr[k] != x.

As I thought earlier, this is simply the difference between the maximum position and minimum position where arr[k] != x.

So, for each x, if I have at least one position where arr[k] != x, then the minimal subarray to cover them is from min(pos) to max(pos), with length max(pos) - min(pos) + 1.

If there are no positions where arr[k] != x, then the cost is 0.

Therefore, for each x, I can find min(pos) and max(pos) for positions where arr[k] != x.

Then, the cost for x is max(pos) - min(pos) + 1, if there are positions where arr[k] != x, else 0.

Then, choose the minimal such cost over all x.

To implement this efficiently, I need a way to compute min(pos) and max(pos) for each x without iterating through all positions for each x.

To optimize this, I can:

- Find the positions where arr[k] != x for each x.

But this seems unavoidable.

Alternatively, I can precompute for each x, the positions where arr[k] != x.

But this would require O(n^2) time and space.

Given the constraints, this is not feasible.

I need a better way.

Let me consider that for a given x, the positions where arr[k] != x are the positions that need to be covered by the subarray.

So, the minimal subarray that covers all these positions is from the minimal such position to the maximal such position.

Therefore, for each x, the cost is max(pos) - min(pos) +1, where pos are positions where arr[k] != x.

To compute this efficiently, perhaps I can:

- Find all unique values in the array.

- For each unique value x, find the min and max positions where arr[k] != x.

- Then, compute max(pos) - min(pos) +1 for each x.

- Choose the minimal such value.

This reduces the number of x's to consider to the number of unique values in the array, which can be up to n.

But n can be up to 2e5, and t up to 1e4, but total n over all test cases is up to 2e5, so it should be manageable.

To implement this efficiently, I can:

- For each test case, find the unique values in the array.

- For each unique value x, find the min and max positions where arr[k] != x.

- If there are no positions where arr[k] != x, then cost is 0.

- Else, cost is max(pos) - min(pos) +1.

- Choose the minimal such cost over all x.

To optimize further, I can:

- Find the frequency of each unique value.

- Find the x with the highest frequency.

- Then, the cost for this x would be the range from the first position where arr[k] != x to the last position where arr[k] != x.

- Assume that choosing the x with the highest frequency minimizes the range.

But as I saw in earlier examples, this seems to hold.

However, in cases where multiple x have the same frequency, I need to check all of them.

But in practice, it might be efficient enough.

Wait, perhaps I can iterate through the array once, collect the frequency of each x, and keep track of the minimum and maximum positions for each x.

Then, for each x, the cost would be max(pos) - min(pos) +1, where pos are positions where arr[k] != x.

Wait, but to find min(pos) and max(pos) for arr[k] != x, I need to track the positions where arr[k] != x.

To optimize, perhaps I can:

- Find the minimum and maximum positions for each x where arr[k] == x.

- Then, for each x, the min(pos) where arr[k] != x is the first position that is not within any x's range.

Wait, this seems too convoluted.

Let me try to implement the straightforward approach and see if it works within time limits.

Given that the total sum of n over all test cases is up to 2e5, and t up to 1e4, but n per test case is up to 2e5, so I need to make sure that per test case, the time is O(n).

Therefore, I need an O(n) solution per test case.

Here's an idea:

- For each test case, iterate through the array once, and for each x, keep track of the first and last positions where arr[k] != x.

- To do this, I can:

- Find all unique x in the array.

- For each x, find the first and last positions where arr[k] != x.

- Then, compute the cost for each x as last(pos) - first(pos) +1.

- Choose the minimal such cost.

To implement this efficiently, I can:

- Find all unique x in the array.

- For each x, find the first and last positions where arr[k] != x.

- To find this efficiently, I can iterate through the array once and collect for each x, the positions where arr[k] != x.

But this would require O(n) time per x, leading to O(n^2) time per test case, which is too slow.

Wait, but if I iterate through the array once and collect for each x, the positions where arr[k] != x, I can then find the min and max positions for each x in O(n) time.

Here's how:

- Create a dictionary for each x, storing the list of positions where arr[k] != x.

- Then, for each x, min(pos) and max(pos) can be found in O(1) time if I store them during the iteration.

- So, overall time per test case is O(n).

Given that the total sum of n over all test cases is up to 2e5, this should be efficient enough.

Let me try to implement this logic.

So, for each test case:

- Read n and the array arr.

- Find all unique values in arr.

- For each unique x, find the positions where arr[k] != x.

- For each x, if there are positions where arr[k] != x, compute max(pos) - min(pos) +1.

- Else, cost is 0.

- Choose the minimal such cost over all x.

- Output this minimal cost.

This seems correct and efficient.

Let me verify it with the sample inputs.

First sample input:

6

1 2 3 4 5 1

Unique x: 1,2,3,4,5

For x=1:

positions where arr[k] !=1: 2,3,4,5

cost: 5-2+1=4

For x=2:

positions where arr[k] !=2:1,3,4,5,6

cost:6-1+1=6

For x=3:

positions where arr[k] !=3:1,2,4,5,6

cost:6-1+1=6

For x=4:

positions where arr[k] !=4:1,2,3,5,6

cost:6-1+1=6

For x=5:

positions where arr[k] !=5:1,2,3,4,6

cost:6-1+1=6

Minimal cost is 4.

Which matches the sample output.

Second sample input:

7

1 1 1 1 1 1 1

Unique x:1

For x=1:

positions where arr[k] !=1: none

cost:0

Minimal cost is 0.

Third sample input:

8

8 8 8 1 2 8 8 8

Unique x:1,2,8

For x=1:

positions where arr[k] !=1:1,2,3,6,7,8

cost:8-1+1=8

For x=2:

positions where arr[k] !=2:1,2,3,4,6,7,8

cost:8-1+1=8

For x=8:

positions where arr[k] !=8:4,5

cost:5-4+1=2

Minimal cost is 2.

Which matches the sample output.

So, this approach seems correct.

Now, to implement this efficiently, I need to:

- For each test case, iterate through the array once to find unique x and positions where arr[k] != x.

- Then, for each unique x, compute the minimal subarray length as max(pos) - min(pos) +1.

- Keep track of the minimal such cost.

- Output the minimal cost.

To optimize space, I can keep track of min(pos) and max(pos) for each x without storing all positions.

Here's how I can do it:

- For each unique x, initialize min_pos = n+1, max_pos = -1.

- Iterate through the array:

- For each position k, for each unique x, if arr[k] != x:

- If k < min_pos[x], set min_pos[x] = k

- If k > max_pos[x], set max_pos[x] = k

- After iteration, for each x, if min_pos[x] == n+1, cost=0, else cost=max_pos[x] - min_pos[x] +1.

- Choose the minimal such cost.

But this would require iterating through all unique x for each position k, which is O(n * number of unique x), which could be up to O(n^2) in the worst case.

To make it efficient, I need to iterate through the array once and update min_pos and max_pos for each x simultaneously.

Here's a better way:

- Find all unique x in the array.

- Initialize dictionaries min_pos and max_pos for each x, initialized to None.

- Iterate through the array:

- For each position k:

- For each unique x:

- If arr[k] != x:

- If min_pos[x] is None or k < min_pos[x], set min_pos[x] = k

- If max_pos[x] is None or k > max_pos[x], set max_pos[x] = k

But this is still O(n * number of unique x), which is too slow for n up to 2e5.

I need a smarter way.

Let me think differently.

Suppose I iterate through the array