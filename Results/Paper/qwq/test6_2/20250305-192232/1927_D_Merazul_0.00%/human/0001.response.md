Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and a set of queries. Each query gives me a range within the array, from index l to r, and I need to find two indices i and j within that range such that the elements at those indices are different, i.e., a_i ≠ a_j. If such a pair doesn't exist, I should return -1 -1.

First, I need to understand the problem thoroughly. The array has n elements, and there are q queries. The constraints are that n can be up to 2*10^5, and q can be up to 2*10^5, and there are t test cases with t up to 10^4, but the sum of n and q across all test cases doesn't exceed 2*10^5 each. So, overall, it's important to have an efficient solution.

I need to process each query independently, looking only within the specified range [l, r]. My goal is to find any two indices within this range that have different values. If all elements in the range are the same, then no such pair exists, and I should return -1 -1.

One straightforward way is, for each query, iterate through the range [l, r], keep track of the unique elements, and as soon as I find two different elements, record their indices. If only one unique element is found after checking the entire range, return -1 -1.

However, since n and q can be up to 2*10^5 each, and t is up to 10^4, but with the sum of n and q across all test cases being up to 2*10^5, I need an efficient way to handle this. Iterating through each query separately and scanning the range each time would be O(q * n), which could be too slow if q and n are both large.

Is there a smarter way to preprocess the array so that query responses are faster? Let's think about it.

One idea is to preprocess the array to find intervals where the elements are all the same or where changes occur. For example, I can find the positions where the element changes value, and store those positions. Then, for each query [l, r], I can check if there's at least one change within that interval.

To implement this, I can iterate through the array once and record the positions where a[i] ≠ a[i-1]. Then, for each query [l, r], I can check if there's any change position within [l, r]. If there is, then there exists at least one pair of indices with different values; otherwise, all elements are the same.

This approach would involve O(n) preprocessing time and O(log n) query time if I use binary search to check for the presence of a change within [l, r], which is efficient enough given the constraints.

Another way is to use a segment tree or a sparse table to answer range queries efficiently, but that might be overkill for this problem.

Let me think about the preprocessing step in more detail. I'll iterate through the array and collect the indices where the value changes. Then, for each query, I'll check if there's at least one such change index within [l, r].

Here's a step-by-step plan:

1. Read the number of test cases, t.

2. For each test case:

a. Read n, the length of the array.

b. Read the array a of n integers.

c. Read q, the number of queries.

d. For each query:

i. Read l and r (1-based indices).

ii. Determine if there exists i and j in [l, r] such that a_i ≠ a_j.

iii. Output i and j if such a pair exists, otherwise -1 -1.

To optimize, I'll preprocess the array to find all positions where a[i] ≠ a[i-1]. Then, for each query [l, r], I'll check if there's at least one such position in [l, r].

To handle 1-based indexing, I need to be careful with how I store and access the array.

Also, I need to make sure that the solution is efficient enough to handle the maximum input sizes within reasonable time limits.

Now, let's consider some edge cases:

- All elements in the array are the same. In this case, for any query, if n >= 2, there will be no such pair since all elements are equal.

- All elements are distinct. In this case, for any query with r - l + 1 >= 2, any two indices will satisfy the condition.

- Queries with l = r. In this case, since there's only one element, no such pair exists, so output -1 -1.

- Queries with l = r - 1, i.e., two elements. If they are different, output their indices; otherwise, -1 -1.

- The entire array is queried.

I need to make sure that my solution handles these cases correctly.

Also, since t can be up to 10^4, but the sum of n and q across all test cases is up to 2*10^5, I need to make sure that my solution is efficient per test case.

Wait, actually, the problem says "It is guaranteed that the sum of the values of n across all test cases does not exceed 2*10^5, and similarly, the sum of the values of q across all test cases does not exceed 2*10^5." So, overall, I have up to 2*10^5 elements and up to 2*10^5 queries to handle.

Given that, I need an overall time complexity that is linear or linearithmic.

Let me think about the preprocessing step again.

I can iterate through the array and record the positions where the value changes. For example, if a[1] ≠ a[2], record position 2; if a[2] ≠ a[3], record position 3; and so on.

Then, for each query [l, r], I need to check if there's any change position within [l, r]. If there is, then there exists at least one pair with different values; otherwise, all elements are the same.

To implement this efficiently, I can store the change positions in a list and use binary search to check if there's any change position within [l, r].

Specifically, for each query, I can perform a binary search to find if there's any change position in the list that lies within [l, r].

If I find at least one, then I can output any two indices that straddle that change position.

If not, then all elements in [l, r] are the same, and I output -1 -1.

To make it even more efficient, I can precompute for each position the nearest change to the left or right, but perhaps that's unnecessary.

Wait, perhaps a better approach is to preprocess the maximum length of equal elements starting from each position.

But I think the change position approach is sufficient.

Let me try to outline the steps more concretely.

Preprocessing:

1. Iterate through the array from index 1 to n-1.

2. For each i from 1 to n-1:

a. If a[i] ≠ a[i+1], record i+1 as a change position.

3. Store all change positions in a list, say changes.

Now, for each query [l, r]:

1. Check if there's any change position in changes that lies within [l, r].

2. If yes, then such a pair exists; otherwise, it doesn't.

To check if there's any change position within [l, r], I can use binary search on the list 'changes' to find the first change position >= l and <= r.

If such a position exists, then output any two indices that straddle this change.

Otherwise, output -1 -1.

To output specific indices, I can choose the first two indices in [l, r] if there's a change, or output -1 -1 if not.

This seems efficient enough, as preprocessing is O(n), and each query can be answered in O(log n) time using binary search.

Now, I need to implement this logic carefully, paying attention to 1-based vs 0-based indexing, and handling edge cases properly.

Also, since t can be up to 10^4, I need to make sure that I reset any test case-specific variables between test cases.

I should also consider the input reading part, as reading input efficiently is crucial for large input sizes.

In Python, reading input using sys.stdin.readline can be faster than using input(), especially for large inputs.

So, I should use sys.stdin.readline for faster input reading.

Additionally, since there are multiple test cases, and the first line contains t, followed by the descriptions of t test cases, I need to read the input accordingly.

Each test case has:

- One line with n

- One line with n integers (a)

- One line with q

- q lines with two integers each (l and r)

I need to read these correctly, process each test case one by one, and output the results accordingly.

Now, let's think about how to implement this.

First, import sys for faster input reading.

Then, read the entire input at once using sys.stdin.read(), split it into tokens, and process them one by one.

This is efficient because it reduces the number of read operations.

I can use an index to track the current position in the token list.

Then, for each test case, read n, read the next n integers as a, read q, and then read the next 2*q integers as l and r for each query.

For preprocessing, as described earlier, find the change positions and store them in a list.

For each query, perform a binary search on the change positions to check if there's any change within [l, r].

If yes, output any two indices with different values within [l, r]; otherwise, output -1 -1.

To output specific indices, I can iterate through [l, r] and find the first two indices with different values.

But since we already have a change position within [l, r], I can output that position and its neighboring position.

Wait, actually, to make it simple, I can iterate through [l, r] and output the first two indices with different values.

But since we're using Python, and loops are relatively slow, and with q up to 2*10^5, I need to make sure that the per-query time is minimized.

An alternative is, for each query, find the first index in [l, r] where a[i] ≠ a[l], and output l and that i.

If no such i exists, output -1 -1.

This way, I don't need to store all change positions; I can handle each query independently.

This seems simpler and avoids the need for preprocessing and binary search.

Let me think about this.

For each query [l, r], iterate from l to r, and check if a[i] ≠ a[l]. If such an i is found, output l and i. If no such i is found, output -1 -1.

This seems correct and efficient enough, as the total time complexity would be O(n + q), since each query can be answered in O(r - l) time, and sum of r - l across all queries is up to 2*10^5.

Given that n and q are up to 2*10^5 each, and sum of r - l is up to 2*10^5, this should be acceptable.

This approach avoids the need for preprocessing and binary search, making the code simpler.

I should implement this approach.

Now, considering 1-based indexing, I need to make sure that I adjust the indices correctly when accessing the array.

In Python, lists are 0-based, so I need to map l and r from 1-based to 0-based indexing.

Also, I need to handle the case when l == r. In this case, there's only one element, so no pair exists, and I should output -1 -1.

I need to make sure that this is handled correctly.

Additionally, I need to ensure that the output for each query is on a new line, and that there are no extra blank lines separating the outputs of different test cases, unless specified.

But according to the problem, "You may separate the outputs for the test cases with empty lines. This is not a mandatory requirement." So, I can choose to include or exclude empty lines between test cases.

I'll proceed without including empty lines between test cases to keep the output compact.

Now, let's consider implementing this logic.

I need to read the input efficiently.

I'll use sys.stdin.read() to read all input at once, split it into tokens, and process them using an index to track the current position.

This is efficient in Python for large inputs.

I'll write a function, say, solve(), that handles one test case.

Within solve(), I'll read n, read the next n integers as a, read q, and then process q queries.

For each query, read l and r, adjust them to 0-based indexing, and then iterate through the range [l, r] to find two indices with different values.

If such a pair is found, output them (adjusting back to 1-based indexing); otherwise, output -1 -1.

I need to make sure that I handle the input correctly, especially regarding the number of elements read for each test case.

Also, since t can be up to 10^4, but the sum of n and q across all test cases is up to 2*10^5, I need to make sure that my solution doesn't have high constants that could lead to timeouts.

In Python, this should be manageable as long as I avoid nested loops and keep the per-query time low.

Let me think about implementing this.

First, import sys.

Then, read all input at once using sys.stdin.read(), split it into tokens.

Initialize an index to 0.

Define a function solve() that reads one test case from the current index and processes it.

Within solve():

- Read t from tokens[index], increment index.

- For each test case from 1 to t:

- Read n from tokens[index], increment index.

- Read the next n integers as a, increment index by n.

- Read q from tokens[index], increment index.

- For each query from 1 to q:

- Read l and r from tokens[index] and tokens[index+1], increment index by 2.

- Adjust l and r to 0-based indexing.

- If l == r, output -1 -1.

- Else, iterate from l to r:

- If a[i] ≠ a[l], output l+1 and i+1.

- If no such i is found, output -1 -1.

This seems straightforward.

I need to make sure that I handle the 1-based vs 0-based indexing correctly.

Also, I need to ensure that I don't go out of bounds when accessing a[i].

Additionally, I can optimize the query handling by breaking early once I find a pair.

Now, considering that t can be up to 10^4, but the sum of n and q across all test cases is up to 2*10^5, this should be acceptable.

I should also consider using global variables or passing parameters appropriately.

In Python, using global variables can be efficient in terms of code simplicity.

Now, let's think about implementing this in code.

But wait, looking back at the sample input and output, I see that there are multiple test cases, and the output for each query is on a new line.

I need to make sure that I print a newline after each test case's output, but it's not mandatory.

I'll proceed without adding extra newlines between test cases.

Also, I need to ensure that there are no trailing spaces or extra newlines in the output.

In Python, when printing, I can use print(i, j) to output the indices, which adds a space between them.

For the case where no pair exists, I should output -1 -1.

Now, to test this logic, let's consider the first test case from the sample input:

5

1 1 2 1 1

3

1 5

1 2

1 3

According to the sample output, the expected outputs are:

2 3

-1 -1

1 3

Let's see why:

First query: 1 5, range [1,2,1,1,1]. a[1]=1, a[2]=2, which are different, so output 1 and 2.

But in the sample output, it's 2 and 3. That's also correct since a[2]=2 and a[3]=1 are different.

So, multiple correct answers are possible.

Second query: 1 2, range [1,1]. All elements are the same, so output -1 -1.

Third query: 1 3, range [1,1,2]. a[1]=1, a[3]=2 are different, so output 1 and 3.

My approach would output 1 and 2 for the first query since a[1]=1 and a[2]=2 are different, which is also correct.

Hence, multiple pairs can be valid, and any one of them is acceptable.

Therefore, my approach is correct.

Another consideration is to choose the smallest possible i and j for simplicity.

Now, let's think about implementing this in code.

I need to read all input at once, split it into tokens, and process them using an index.

I can write a while loop that continues until all test cases are processed.

Within each test case, read n, read a, read q, and then process q queries.

For each query, read l and r, adjust to 0-based indexing, check for the pair, and output accordingly.

I need to make sure that I handle the end of input correctly, especially for multiple test cases.

In Python, reading all input at once and splitting into tokens is efficient.

Now, considering that t can be up to 10^4, but with the sum of n and q across all test cases being up to 2*10^5, I need to make sure that my code doesn't have any unnecessary operations that could lead to timeouts.

I should avoid unnecessary list copies or operations within loops.

Also, in Python, list access is O(1), so that's fine.

Now, let's consider writing the code accordingly.

I'll write a function solve() that handles the entire input reading and processing.

Within solve(), I'll read all input at once, split into tokens, and process them using an index.

Then, I'll handle each test case one by one, reading n, a, q, and then processing q queries.

For each query, I'll find the first j in [l, r] such that a[j] ≠ a[l], and output l+1 and j+1.

If no such j is found, output -1 -1.

I need to make sure that l and r are correctly adjusted for 0-based indexing.

Also, I need to handle the case when l == r appropriately.

Now, considering that the problem allows outputs to be separated by empty lines, but it's not mandatory, I'll proceed without adding extra newlines between test cases.

Finally, I need to make sure that the code is efficient and doesn't have any unnecessary computations.

I believe this approach is correct and efficient for the given constraints.

## Final Solution
To solve this problem, we need to determine if there exists at least one pair of different elements within a specified range in an array for multiple queries. If such a pair exists, we output the indices of these elements; otherwise, we output -1 -1.

### Approach
1. **Read Input Efficiently:** Use `sys.stdin.read()` to read all input at once for efficiency.
2. **Preprocess the Array:** For each test case, read the array and prepare to process queries.
3. **Process Each Query:** For each query, check if there are different elements within the specified range.
4. **Output the Result:** If a pair of different elements is found, output their indices; otherwise, output -1 -1.

### Solution Code
```python
def main():
    import sys
    tokens = sys.stdin.read().split()
    idx = 0
    t = int(tokens[idx])
    idx += 1
    for _ in range(t):
        n = int(tokens[idx])
        idx += 1
        a = list(map(int, tokens[idx:idx+n]))
        idx += n
        q = int(tokens[idx])
        idx += 1
        for _ in range(q):
            l = int(tokens[idx]) - 1  # Convert to 0-based indexing
            r = int(tokens[idx+1]) - 1  # Convert to 0-based indexing
            idx += 2
            if l == r:
                print(-1, -1)
                continue
            for j in range(l, r+1):
                if a[j] != a[l]:
                    print(l+1, j+1)  # Convert back to 1-based indexing
                    break
            else:
                print(-1, -1)

if __name__ == "__main__":
    main()
```

### Explanation
1. **Reading Input:** We read all input at once using `sys.stdin.read()` and split it into tokens for easy access.
2. **Processing Test Cases:** For each test case, we read the array length `n`, the array `a`, and the number of queries `q`.
3. **Handling Queries:** For each query, we read the range `[l, r]`, adjust for 0-based indexing, and check for different elements:
   - If `l == r`, directly output -1 -1 since there's only one element.
   - Iterate from `l` to `r` and check if any element is different from `a[l]`. If found, output the indices of `a[l]` and the different element.
   - If no different element is found within the range, output -1 -1.
4. **Efficiency:** This approach ensures that each query is processed efficiently, with a time complexity proportional to the range size, which is optimized given the constraints.