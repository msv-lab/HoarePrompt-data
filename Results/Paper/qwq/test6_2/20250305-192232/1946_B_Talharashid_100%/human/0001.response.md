Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly k operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. My goal is to maximize the sum of the array after k such operations, and since the sum can be very large, I need to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation does. So, in one operation, I choose a contiguous subarray, compute its sum, and then insert that sum into the array somewhere. The key here is that I can choose where to insert it, but the position might not matter much since I can rearrange the array in a way that maximizes the sum.

Wait, but the array is being modified by inserting these sums. Each insertion increases the length of the array, but the problem doesn't seem to care about the actual array after operations, just the sum. So, maybe I can think in terms of how the sum changes with each operation.

Let's consider what happens in one operation:

1. I select a contiguous subarray.

2. I compute its sum.

3. I insert this sum into the array.

After this operation, the total sum of the array increases by the sum of the subarray because I'm inserting it, not replacing anything.

Wait, actually, the problem says "insert the sum of this subarray anywhere in the array." So, I'm adding this sum to the array, which means the total sum of the array increases by that sum.

Therefore, each operation allows me to add the sum of some contiguous subarray to the array's sum.

My aim is to maximize the sum after k operations.

So, in each operation, I want to add the largest possible sum of a contiguous subarray to the array's sum.

Hmm, that sounds like I should find the maximum sum of any contiguous subarray and add it in each operation.

But, there's a twist because after each operation, the array changes, and potentially, the maximum sum subarray could change.

Wait, but in each operation, I'm just inserting the sum somewhere, which increases the total sum, but the existing elements remain the same, and I can choose any subarray in the modified array for the next operation.

This seems a bit tricky. Maybe there's a smarter way to approach this.

Let me think differently. Suppose I look at the initial array and find its maximum subarray sum. Then, in each operation, I can choose to add this maximum subarray sum to the array's sum.

But, as I perform operations, the array grows, and potentially, I can create larger sums.

Wait, but since I can choose where to insert the sum, maybe I can strategically place it to create larger subarrays.

Alternatively, perhaps I can model this as adding the maximum subarray sum in each operation, and since operations are independent in terms of adding to the total sum, I can just add the maximum subarray sum in each of the k operations.

But I need to verify if this is indeed the case.

Let's consider a simple example to test this idea.

Take the first test case:

n = 2, k = 2

a = [-4, -7]

The maximum subarray sum is max(-4, -7, -4 + -7) = max(-4, -7, -11) = -4

If I add -4 in each operation, total sum after 2 operations: (-4) + (-7) + (-4) + (-4) = -19

But the sample output is 999,999,996, which is -11 modulo 10^9 + 7.

Wait, that doesn't match. So, perhaps choosing the maximum subarray sum in each operation isn't the right approach here.

Wait, maybe I need to choose the empty subarray. The sum of the empty subarray is 0, which is better than adding -4.

If I choose the empty subarray in both operations, I add 0 in each operation, so the total sum is (-4) + (-7) + 0 + 0 = -11, which modulo 10^9 + 7 is 999,999,996. That matches the sample output.

So, in this case, choosing the empty subarray was better than choosing a non-empty subarray.

In the second test case:

n = 3, k = 3

a = [2, 2, 8]

The maximum subarray sum is 2 + 2 + 8 = 12

If I add 12 in each of the 3 operations, the total sum would be 2 + 2 + 8 + 12 + 12 + 12 = 48

But the sample output is 96, which suggests that perhaps I can add the sum of the new array after each operation.

Wait, maybe I need to consider that after each operation, the array changes, and I can choose subarrays from the new array.

Wait, let's see:

Initial array: [2, 2, 8], sum = 12

Operation 1: choose the entire array [2,2,8], sum=12, insert 12 somewhere, say at the end: [2,2,8,12], sum=24

Operation 2: choose the entire new array [2,2,8,12], sum=24, insert 24: [2,2,8,12,24], sum=48

Operation 3: choose the entire new array [2,2,8,12,24], sum=48, insert 48: [2,2,8,12,24,48], sum=96

That matches the sample output.

So, in this case, by choosing the entire array each time and inserting its sum, the sum doubles each time.

Wait, actually, it more than doubles because we're adding the sum, not doubling the array.

Wait, no, in the first operation, sum was 12, after inserting 12, sum becomes 24 (12 + 12). Then, sum is 24, insert 24, sum becomes 48, and so on.

So, each operation allows me to add the current sum to the array, thereby doubling the sum.

Wait, but in general, I might not always be able to double the sum each time.

Wait, but in this case, it seems possible.

So, perhaps in general, if I can always choose the entire array's sum and insert it, the sum increases by the current sum each time, effectively doubling the sum each operation.

But, in the first test case, if I choose the empty subarray each time, I add 0 each time, so the sum remains -11, which modulo 1e9+7 is 999,999,996.

That seems to be the best I can do in that case.

So, perhaps the strategy is:

- If the current sum of the array is positive, add the current sum to the array in each operation, effectively doubling the sum each time.

- If the current sum is non-positive, it's better to add 0 in each operation, to not decrease the sum.

Wait, but in the first test case, the initial sum is -11, which is negative, so adding 0 in each operation is better, resulting in sum = -11.

In the second test case, initial sum is 12, which is positive, so adding 12 in each operation, doubling the sum each time, leads to sum = 12 * (2^3) = 96.

So, perhaps the general formula is:

- If the initial sum is positive, then after k operations, the sum is initial_sum * (2^k - 1)

- If the initial sum is non-positive, then the best is to add 0 in each operation, so the sum remains the initial_sum.

Wait, in the second test case, with initial_sum=12 and k=3, 12 * (2^3 - 1) = 12 * 7 = 84, but the sample output is 96.

Wait, that doesn't match.

Wait, perhaps it's initial_sum * 2^k.

In the second test case, 12 * 2^3 = 96, which matches the sample output.

Wait, but why 2^k?

Because each operation is effectively doubling the sum.

Wait, let's see:

- Initial sum: S

- Operation 1: add S, sum becomes S + S = 2S

- Operation 2: add 2S, sum becomes 2S + 2S = 4S

- Operation 3: add 4S, sum becomes 4S + 4S = 8S

- ...

- After k operations: sum is S * 2^k

Yes, that makes sense.

In the first test case, S = -11, 2^2 = 4, so -11 * 4 = -44, but the sample output is -11 modulo 1e9+7 = 999,999,996.

Wait, that doesn't match.

Wait, perhaps I'm missing something.

Wait, in the first test case, if I choose to add 0 in each operation, the sum remains -11, which is better than choosing to add -11 repeatedly, which would make the sum worse.

So, perhaps the formula is:

- If S > 0, sum after k operations is S * 2^k

- If S <= 0, sum after k operations is S + 0 * k = S

But in the first test case, S = -11, which is less than 0, so sum remains -11.

But according to the above, S * 2^k would be -11 * 4 = -44, which is worse than -11.

So, indeed, when S <= 0, it's better to add 0 in each operation, keeping the sum as S.

When S > 0, adding S in each operation leads to sum * 2^k.

So, the general formula seems to be:

- If S > 0, sum after k operations is S * 2^k

- Else, sum after k operations is S

But, in the fourth test case:

n = 5, k = 1

a = [4, -2, 8, -12, 9]

Sum = 4 - 2 + 8 -12 + 9 = 7

According to the formula, 7 * 2^1 = 14, but the sample output is 17.

So, there's something wrong with this approach.

Wait, perhaps I need to choose the maximum subarray sum to add in each operation, not necessarily the entire array's sum.

In the fourth test case, the maximum subarray sum is 4 + (-2) + 8 = 10

If I add 10 in one operation, the new sum would be 7 + 10 = 17, which matches the sample output.

So, perhaps the correct approach is:

- Find the maximum subarray sum M

- In each of the k operations, add M to the array's sum

- So, the total sum after k operations is initial_sum + k * M

But, in the second test case, if I take M = 12 and initial_sum = 12, then sum after 3 operations is 12 + 3*12 = 48, but the sample output is 96.

Wait, that doesn't match.

Wait, perhaps it's more complicated.

Wait, in the second test case, by adding the current sum in each operation, it becomes 12 * 2^k.

But if I consider adding the maximum subarray sum in each operation, it's different.

Wait, maybe I need to consider that after adding the maximum subarray sum, the array changes, and the new maximum subarray sum could be larger.

But that seems too complicated.

Let me think differently.

Let's consider that in each operation, I can choose any subarray, compute its sum, and insert it into the array.

I need to maximize the sum after k operations.

I need to maximize the sum added in each operation.

So, in each operation, I should choose the subarray with the maximum sum available at that moment and insert it.

So, in the first operation, I choose the maximum subarray sum M1 and insert it.

Now, the array has an additional element equal to M1.

In the second operation, I can choose the maximum subarray sum from the new array, which might include the newly inserted M1.

This seems recursive and complicated to track.

Maybe there's a better way.

Let me consider that after each operation, I'm adding the maximum possible sum to the array.

So, if I can keep adding the maximum possible sum in each operation, that would be ideal.

But how do I compute that efficiently?

Another idea: perhaps the maximum sum I can add in each operation is the maximum subarray sum of the initial array, and by adding it repeatedly, I can maximize the total sum.

But in the fourth test case, that seems to work, but in the second test case, it doesn't match.

Wait, in the second test case, if I add 12 in each of the 3 operations, sum becomes 12 + 12 + 12 = 36, but the sample output is 96.

Wait, but in the explanation, they show that by adding the current sum in each operation, it becomes 12, then 24, then 48, which is 12 * 2^3 = 96.

So, perhaps in each operation, adding the current sum is better than adding a fixed M.

But then, in the fourth test case, adding the current sum would be 7 + 7 = 14, but the sample output is 17.

So, that doesn't match.

Wait, perhaps I need to choose between adding the current sum or adding the maximum subarray sum in each operation.

In the fourth test case, adding the maximum subarray sum (10) once gives 7 + 10 = 17, which is better than adding the current sum (7).

So, perhaps the strategy is:

- In each operation, add the maximum subarray sum of the initial array.

- So, total sum after k operations is initial_sum + k * M, where M is the maximum subarray sum of the initial array.

But in the second test case, M = 12, initial_sum = 12, so sum after 3 operations is 12 + 3*12 = 48, but sample output is 96.

Wait, that's not matching.

Wait, maybe I need to consider that after adding M, the array can have a larger M.

But in the second test case, M = 12, after adding 12, the new array can have M = 24, and so on.

So, perhaps in each operation, M doubles.

Wait, but that seems too good to be true.

Wait, in the second test case, if I add M=12 in the first operation, new sum is 12 + 12 = 24.

Now, the new M is 24.

Add 24 in the second operation, sum becomes 24 + 24 = 48.

Add 48 in the third operation, sum becomes 48 + 48 = 96.

That matches the sample output.

So, in this case, M doubles in each operation.

But in the fourth test case, initial M = 10, initial sum = 7.

After adding 10, sum becomes 17, and new M could be 10 again, but since k=1, it's just 7 + 10 = 17, which matches the sample.

So, perhaps the general formula is:

- Find the maximum subarray sum M of the initial array.

- Then, after k operations, the sum is initial_sum + M * (2^k - 1)

Wait, in the second test case, initial_sum = 12, M = 12, so sum = 12 + 12*(2^3 - 1) = 12 + 12*7 = 12 + 84 = 96, which matches.

In the fourth test case, initial_sum = 7, M = 10, sum = 7 + 10*(2^1 - 1) = 7 + 10*1 = 17, which matches.

Wait, but in the first test case, initial_sum = -11, M = -4.

Sum = -11 + (-4)*(2^2 -1) = -11 -4*3 = -11 -12 = -23, but sample output is -11.

So, that doesn't match.

Wait, perhaps I need to take M as the maximum of the initial M and 0.

Because, if M is negative, adding it would make the sum worse.

So, perhaps M should be max(M, 0).

In the first test case, M = -4, so M = 0.

Sum = -11 + 0*(2^2 -1) = -11, which matches the sample.

In the second test case, M = 12, sum = 12 + 12*(2^3 -1) = 12 + 12*7 = 96, which matches.

In the fourth test case, M = 10, sum = 7 + 10*(2^1 -1) = 7 + 10 = 17, which matches.

So, this seems to be the correct formula.

Therefore, the general approach is:

- Compute the initial sum S of the array.

- Find the maximum subarray sum M of the initial array.

- Set M = max(M, 0)

- Then, the sum after k operations is S + M * (2^k - 1)

- Finally, take this sum modulo 10^9 + 7.

Wait, but in the second test case, S + M*(2^k -1) = 12 + 12*(8 -1) = 12 + 84 = 96, which matches.

But in the first test case, S + M*(2^k -1) = -11 + 0*(4 -1) = -11 + 0 = -11, which matches.

In the fourth test case, 7 + 10*(2 -1) = 7 + 10 = 17, which matches.

Seems correct.

But, in the seventh test case, n=6, k=1000, a=[-1e9, -1e9, -1e9, -1e9, -1e9, -1e9]

Sum S = -6e9

M = -1e9 (the least negative subarray sum)

M = max(-1e9, 0) = 0

Sum after k operations = -6e9 + 0*(2^1000 -1) = -6e9

But the sample output is 42, which is -6e9 modulo 1e9+7.

Wait, -6e9 modulo 1e9+7 is -6e9 + 7e9 = 1e9, but the sample output is 42.

Wait, perhaps I'm miscalculating.

Wait, no, -6e9 modulo 1e9+7 is -6e9 + 7e9 = 1e9, but 1e9 modulo 1e9+7 is 1e9.

But the sample output is 42, which suggests that the sum is different.

Wait, perhaps I need to consider that M could be 0, but in this case, M is -1e9, so M=0.

Sum = -6e9 + 0*(2^1000 -1) = -6e9

But -6e9 modulo 1e9+7 is -6e9 + 7e9 = 1e9, but sample output is 42.

Wait, perhaps I need to compute it differently.

Wait, maybe the sum is not just S + M*(2^k -1), but something else.

Wait, perhaps it's S * 2^k, but in this case, S is -6e9, 2^1000 is a huge number, which would make the sum extremely negative, but the sample output is 42.

Wait, perhaps there's a misunderstanding in how modulo operation works with negative numbers.

Let me recall that the modulo operation should return a number in the range [0, m-1], where m is the modulus.

So, to compute x modulo m, it's (x % m + m) % m to ensure it's positive.

So, in this case, (-6e9) % (1e9+7) = (-6e9 + 7e9) % (1e9+7) = (1e9) % (1e9+7) = 1e9

But the sample output is 42, which suggests that the sum is different.

Wait, perhaps the sum is not S + M*(2^k -1), but something else.

Wait, in the seventh test case, if M=0, then sum should be S + 0*(2^k -1) = S.

But according to the sample, it's 42.

Wait, perhaps I need to compute S * 2^k.

Wait, in the second test case, S=12, 12*2^3=96, which matches.

In the first test case, S=-11, -11*2^2=-44, but sample output is -11 modulo 1e9+7=999,999,996.

Wait, that doesn't match with S * 2^k.

Wait, perhaps I need to choose whether to double the sum or add M in each operation to maximize the sum.

But that seems too time-consuming for large k.

Wait, perhaps the formula is S * 2^k - M * (2^k -1)

Wait, in the second test case, 12*8 - 12*(7) = 96 - 84 = 12, which doesn't match.

No, that's not it.

Wait, maybe it's S * 2^k - (S - M) * (2^k -1)

In the second test case: 12*8 - (12 -12)*(7) = 96 - 0 = 96, matches.

In the first test case: -11*4 - (-11 - (-4))*(3) = -44 - (-7)*3 = -44 +21 = -23, but sample is -11.

Doesn't match.

Wait, perhaps it's S * 2^k - (S - M) * (2^k -1), but adjusted for M <=0.

Wait, this is getting too complicated.

Maybe I need to think recursively.

Define f(k) as the maximum sum after k operations.

Then, f(0) = S

f(k) = f(k-1) + M_k, where M_k is the maximum subarray sum at step k.

But M_k can be up to f(k-1), because we can choose to add f(k-1) as a subarray sum.

Wait, if we can choose to add the entire array's sum in each operation, then f(k) = f(k-1) + f(k-1) = 2*f(k-1)

So, f(k) = S * 2^k

But in the first test case, S=-11, 2^2=4, -11*4=-44, but sample output is -11 modulo 1e9+7=999,999,996.

But in reality, by choosing to add 0 in each operation, sum remains -11, which is better than adding -11 repeatedly.

So, perhaps f(k) = S + M * (2^k -1), where M = max(subarray sum, 0)

In the first test case, M=-4, so M=0, f(k)= -11 + 0*(2^2 -1) = -11

In the second test case, M=12, f(k)=12 + 12*(2^3 -1) = 12 + 84 =96

In the seventh test case, M=-1e9, M=0, f(k)= -6e9 +0*(2^1000 -1) = -6e9

But sample output is 42, which is -6e9 modulo 1e9+7.

Wait, -6e9 modulo 1e9+7 is -6e9 +7e9 =1e9, but sample output is 42.

Wait, perhaps I'm missing something about how the operations work.

Wait, maybe in each operation, I can choose to add any subarray sum, including zero, and I should choose the one that maximizes the sum.

So, in the seventh test case, all elements are negative, so the best is to choose the empty subarray sum (0) in each operation, so the sum remains -6e9.

But according to the sample, it's 42, which is -6e9 modulo 1e9+7.

Wait, perhaps I'm miscalculating the modulo.

Let me compute -6e9 modulo 1e9+7.

-6e9 +7e9 =1e9

1e9 modulo 1e9+7 is 1e9, but the sample output is 42.

Wait, perhaps there's a mistake in the sample output.

Wait, looking back at the sample input and output, the seventh test case output is 42.

Wait, perhaps 42 is -6e9 modulo 1e9+7.

Wait, -6e9 modulo 1e9+7:

-6e9 % (1e9+7) = -6e9 + 7e9 =1e9

1e9 < 1e9+7, so 1e9 is the result.

But the sample output is 42, which suggests that the sum is different.

Wait, perhaps I need to consider that after each operation, I can choose to add 0, but maybe there's a different way to interpret it.

Wait, perhaps in the seventh test case, the sum is not -6e9, but something else.

Wait, let's compute the sum:

a = [-1e9, -1e9, -1e9, -1e9, -1e9, -1e9]

sum = -6e9

M = max subarray sum = max of all subarrays, which is max(a) = -1e9

So, M = max(-1e9, 0) =0

sum after k operations = -6e9 +0*(2^1000 -1) = -6e9

-6e9 modulo 1e9+7 = -6e9 +7e9 =1e9

But sample output is 42, which suggests that perhaps the sum is different.

Wait, perhaps the sum is S * 2^k.

In this case, -6e9 * 2^1000, which is a very large negative number.

But modulo 1e9+7, it's equivalent to (-6e9 * 2^1000) mod (1e9+7)

But computing this directly is tricky, but perhaps it's equivalent to (S * 2^k) mod (1e9+7)

In the second test case, (12 * 2^3) mod (1e9+7) =96 mod (1e9+7)=96, which matches.

In the first test case, (-11 * 2^2) mod (1e9+7) = (-44) mod (1e9+7)=999,999,996, which matches.

In the seventh test case, (-6e9 * 2^1000) mod (1e9+7)

But the sample output is 42, which might be the result of this modulo operation.

So, perhaps the correct formula is (S * 2^k) mod (1e9+7)

But in the fourth test case, S=7, 7 * 2^1 =14, but sample output is 17.

This doesn't match.

Wait, perhaps I need to add M*k instead of using the 2^k factor.

Wait, in the fourth test case, S=7, M=10, sum=7 +10*1=17, which matches.

But in the second test case, S=12, M=12, sum=12 +12*3=48, but sample output is 96, which is S*2^k.

Wait, perhaps I need to choose between adding M*k or S*2^k, taking the maximum.

But in this case, for S>0, S*2^k is better than S + M*k.

Wait, in the second test case, S=12, M=12, S*2^3=96, S+M*3=48, so 96 is better.

In the fourth test case, S=7, M=10, S*2^1=14, S+M*1=17, so 17 is better.

Wait, so perhaps in general, it's max(S*2^k, S + M*k)

But in the second test case, M=12, S=12, so S + M*k =12 +12*3=48, S*2^k=96, so 96 is better.

In the fourth test case, M=10, S=7, S + M*k=7+10*1=17, S*2^k=14, so 17 is better.

In the first test case, M=-4, S=-11, S + M*k=-11 + (-4)*2=-19, S*2^k=-44, both worse than adding 0*k, which is S +0*k= -11.

So, perhaps the general formula is:

- Compute M = max(subarray sum, 0)

- Then, the sum after k operations is max(S*2^k, S + M*k, S +0*k)

- Take the maximum among these three.

In the first test case, S=-11, M=0

max( -44, -11, -11 ) = -11, which matches.

In the second test case, S=12, M=12

max(96, 48, 12) =96, matches.

In the fourth test case, S=7, M=10

max(14,17,7)=17, matches.

In the seventh test case, S=-6e9, M=0

max(-6e9 * 2^1000, -6e9 +0*1000, -6e9) = max( -6e9 * 2^1000, -6e9, -6e9)

-6e9 * 2^1000 is a very large negative number, so the maximum is -6e9.

But according to the sample, it's 42, which is -6e9 modulo 1e9+7.

Wait, perhaps I need to compute (max(S*2^k, S + M*k, S +0*k)) modulo 1e9+7

But in this case, max(-6e9 * 2^1000, -6e9, -6e9) = -6e9

-6e9 modulo 1e9+7 is -6e9 +7e9=1e9, but sample output is 42.

Wait, perhaps there is a misunderstanding in the problem statement.

Wait, in the note of the seventh test case, it says:

"In the seventh test case, it will always be advantageous for us to take an empty subarray of the array. In this case, the sum of the resulting array will not differ from the sum of the original. The answer will be the sum of the original array, taken modulo — 42, because (-6⋅(10^9+7)+42=−6 000 000 000)."

Wait, that's confusing. It says "the answer will be the sum of the original array, taken modulo — 42", but modulo is always non-negative, so perhaps it's trying to say that -6e9 modulo 1e9+7 is calculated as -6e9 + 7e9 =1e9, but then it says -6*(1e9+7)+42=-6e9, which suggests that 1e9 modulo 1e9+7 is 1e9, but the sample output is 42.

Wait, perhaps I'm missing something.

Wait, let's compute -6e9 modulo 1e9+7 correctly.

To compute x modulo m, it's (x % m + m) % m to ensure non-negativity.

So, (-6e9 % (1e9+7) + 1e9+7) % (1e9+7)

-6e9 divided by 1e9+7 is -6 with a remainder of -6e9 - (-6)*(1e9+7) = -6e9 +6e9 +42*1e9 =42

Wait, let's do the calculation step by step.

Compute quotient q = floor(-6e9 / 1e9+7) = floor(-6e9 / 1e9+7) = floor(-6.000000000 - (6e9 % 1e9+7)/(1e9+7))

Wait, better to use the formula:

x modulo m = x - m * floor(x / m)

So, -6e9 modulo (1e9+7) = -6e9 - (1e9+7) * floor(-6e9 / (1e9+7))

First, floor(-6e9 / 1e9+7) = floor(-5.999999993) = -6

So, -6e9 - (1e9+7)*(-6) = -6e9 +6e9 +42 =42

So, -6e9 modulo 1e9+7 is 42.

Therefore, in the seventh test case, the sum is -6e9, and its modulo is 42, which matches the sample output.

So, in this case, sum after k operations is S +0*k = S = -6e9, which modulo 1e9+7 is 42.

Therefore, the general formula is:

- Compute M = max(subarray sum, 0)

- Then, sum after k operations is max( S * 2^k, S + M * k, S + 0 * k )

- Take the maximum among these three options.

Wait, but in the fourth test case, S=7, M=10, S*2^1=14, S+M*1=17, S+0*1=7, so max is 17.

In the second test case, S=12, M=12, S*2^3=96, S+M*3=48, S+0*3=12, so max is 96.

In the first test case, S=-11, M=0, S*2^2=-44, S+M*2=-11, S+0*2=-11, so max is -11.

In the seventh test case, S=-6e9, M=0, S*2^1000 is very negative, S+M*k=-6e9, S+0*k=-6e9, so max is -6e9, which modulo is 42.

So, this seems correct.

Now, to implement this efficiently, I need to:

1. Compute the initial sum S of the array.

2. Compute the maximum subarray sum M of the array.

3. Compute the maximum among S*2^k, S + M*k, and S +0*k.

4. Take this maximum value modulo 1e9+7.

Also, since k and n can be up to 2e5, I need an efficient way to compute M, which is the maximum subarray sum.

I can compute M using Kadane's algorithm, which is O(n).

Computing S is O(n).

Computing S*2^k can be done efficiently using exponentiation by squaring.

Similarly, M*k and S +0*k are straightforward.

Finally, take the maximum among these three and compute modulo 1e9+7.

Edge cases to consider:

- S <=0 and M <=0: in this case, adding 0 in each operation is the best, so sum remains S.

- S >0 and M >0: in this case, S*2^k is better than S + M*k, especially for large k.

- S >0 and M <=0: in this case, S*2^k is better than S + M*k.

- S <=0 and M >0: in this case, compare S + M*k vs S*2^k.

Wait, in the fourth test case, S=7, M=10, k=1, S*2^1=14, S + M*1=17, so S + M*k is better.

Wait, but in general, for larger k, S*2^k would eventually surpass S + M*k.

Wait, yes, for large k, S*2^k grows exponentially, while S + M*k grows linearly.

So, perhaps for small k, S + M*k could be larger, but for large k, S*2^k dominates.

But in the problem, k can be up to 2e5, which is large, so S*2^k would dominate unless S is negative.

Wait, but in the fourth test case, with k=1, S + M*k is larger.

So, perhaps I need to choose the maximum between S*2^k and S + M*k, and also consider S +0*k when S <=0 and M <=0.

Wait, more precisely:

- If S >0 and M >0: choose max(S*2^k, S + M*k)

- If S <=0 and M <=0: choose S (which is S +0*k)

- If S >0 and M <=0: choose S*2^k

- If S <=0 and M >0: choose S + M*k

Wait, but in the fourth test case, S=7, M=10, which is S>0 and M>0, and S + M*k > S*2^k when k=1.

For k=1, 7 +10=17 > 14, but for k=2, 7*4=28 vs 7 +20=27, so 28>27.

So, for k=1, S + M*k > S*2^k, but for k=2, S*2^k > S + M*k.

So, in general, for S>0 and M>0, we need to choose the maximum between S*2^k and S + M*k.

Similarly, for S>0 and M<=0, S*2^k is better.

For S<=0 and M<=0, S is better.

For S<=0 and M>0, S + M*k is better.

But in the fourth test case, S=7, M=10, k=1: choose S + M*k=17

For k=2: S*4=28 > S +20=27, so choose S*4=28

So, perhaps the general formula is:

- If S >0 and M >0: choose max(S*2^k, S + M*k)

- Else if S <=0 and M <=0: choose S

- Else if S <=0 and M >0: choose S + M*k

- Else (S >0 and M <=0): choose S*2^k

But in the fourth test case, S=7, M=10, choose max(14,17)=17 for k=1

For k=2: max(28,27)=28

So, need to choose the maximum between S*2^k and S + M*k when S>0 and M>0.

In other cases, as mentioned.

Now, to implement this efficiently, I need to handle large exponents for 2^k, but since we're working modulo 1e9+7, which is a prime, I can use fast exponentiation.

Also, need to handle negative numbers when computing the final sum modulo 1e9+7.

So, in code, I need to:

- Read t test cases.

- For each test case:

- Read n and k.

- Read the array a.

- Compute S = sum(a)

- Compute M = maximum subarray sum.

- If S >0 and M >0:

- Compute S * 2^k modulo 1e9+7

- Compute S + M*k modulo 1e9+7

- Choose the maximum of these two.

- Else if S <=0 and M <=0:

- The sum is S modulo 1e9+7

- Else if S <=0 and M >0:

- The sum is S + M*k modulo 1e9+7

- Else (S >0 and M <=0):

- The sum is S * 2^k modulo 1e9+7

- Finally, print the result modulo 1e9+7

Now, to compute 2^k modulo 1e9+7 efficiently, I can use the pow function in Python, which is efficient.

Also, to compute the maximum subarray sum, I can use Kadane's algorithm.

Implementing Kadane's algorithm:

def max_subarray_sum(a):

current_max = a[0]

global_max = a[0]

for num in a[1:]:

current_max = max(num, current_max + num)

global_max = max(global_max, current_max)

return global_max

But need to handle all elements negative.

If all elements are negative, the maximum subarray sum is the largest negative number.

Also, need to handle M <=0 in some cases.

Wait, but in the formula, when S>0 and M>0, choose max(S*2^k, S + M*k)

When S>0 and M<=0, choose S*2^k

When S<=0 and M<=0, choose S

When S<=0 and M>0, choose S + M*k

So, in the case where M<=0 and S>0, choose S*2^k

Wait, but in that case, M<=0, so adding M in operations would decrease the sum, which is worse than adding 0