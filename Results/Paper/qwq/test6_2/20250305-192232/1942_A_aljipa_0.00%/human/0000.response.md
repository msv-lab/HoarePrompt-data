Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of length n, where each element is between 1 and 10^9, and exactly k out of its n cyclic shifts are sorted. If no such array exists, I should output -1.

First, I need to understand what a cyclic shift is. From the description, the x-th cyclic shift of the array a is a_x, a_{x+1}, ..., a_n, a_1, a_2, ..., a_{x-1}. So, for example, if n=4, the cyclic shifts are:

- x=1: a1, a2, a3, a4

- x=2: a2, a3, a4, a1

- x=3: a3, a4, a1, a2

- x=4: a4, a1, a2, a3

I need exactly k of these shifts to be sorted in non-decreasing order.

Let's look at the examples provided:

1. For n=2, k=2:

   - Array: [1, 1]

   - Cyclic shifts:

     - [1, 1] (sorted)

     - [1, 1] (sorted)

   - Both shifts are sorted, so k=2.

2. For n=3, k=1:

   - Array: [69420, 69, 420]

   - Cyclic shifts:

     - [69420, 69, 420] (not sorted)

     - [69, 420, 69420] (sorted)

     - [420, 69420, 69] (not sorted)

   - Only one sorted shift, so k=1.

3. For n=3, k=2:

   - Output: -1

   - Meaning, no such array exists.

So, for different values of n and k, I need to find if there's an array that has exactly k sorted cyclic shifts.

First, let's consider some basic cases:

- If k = n, meaning all cyclic shifts must be sorted.

- If k = 1, meaning only one cyclic shift is sorted.

- If k = 0, meaning no cyclic shift is sorted. But since k >=1 as per the problem, k=0 is not possible.

Let's think about k = n.

If k = n, all cyclic shifts must be sorted. What does that imply about the array?

Well, if all cyclic shifts are sorted, the array must be constant, i.e., all elements are equal.

Because, if any two elements are different, rotating the array could bring a smaller element after a larger one, making that shift unsorted.

For example, [1,1,1] has all shifts sorted, but [1,2,1] doesn't.

Wait, [1,2,1] has some sorted shifts:

- [1,2,1] (sorted: 1<=2<=1? No)

- [2,1,1] (sorted: 2<=1<=1? No)

- [1,1,2] (sorted: 1<=1<=2? Yes)

So, only one sorted shift, which matches k=1.

Back to k=n.

Seems like only constant arrays satisfy k=n.

But let's verify.

Suppose n=2, k=2.

Array [1,1]: both shifts are [1,1], which are sorted.

Array [1,2]: shifts are [1,2] (sorted) and [2,1] (not sorted). So k=1.

Array [2,1]: shifts are [2,1] (not sorted) and [1,2] (sorted). So k=1.

Array [2,2]: both shifts are [2,2], sorted. So k=2.

Hence, only constant arrays satisfy k=n.

Similarly, for n=3, k=3.

[1,1,1]: all shifts sorted.

[1,1,2]: shifts are [1,1,2], [1,2,1], [2,1,1].

- [1,1,2] sorted

- [1,2,1] not sorted

- [2,1,1] not sorted

So k=1.

Hence, only constant arrays satisfy k=n.

Similarly, for any n, k=n only constant arrays work.

Now, for k=1.

We need exactly one cyclic shift to be sorted.

Looking at the example: n=3, k=1.

Array [69420,69,420]

Shifts:

- [69420,69,420]: 69420 >=69, not sorted

- [69,420,69420]: 69<=420<=69420, sorted

- [420,69420,69]: 420<=69420 but 69420>=69, not sorted

Hence, only one sorted shift.

Another example: n=3, k=2 is impossible, as per the sample output.

So, for k=1, it's possible for n>=2.

Wait, for n=1, k=1:

Array [a], only one shift, which is sorted.

So, for n=1, k=1 is always satisfied with any single element array.

For n=2, k=1:

Array [1,2]: shifts [1,2] (sorted), [2,1] (not sorted) => k=1

Array [2,1]: shifts [2,1] (not sorted), [1,2] (sorted) => k=1

Array [1,1]: k=2, which is not k=1.

Hence, for k=1, n>=2, arrays where exactly one shift is sorted, which seems possible by making the array non-constant and ensuring only one shift is sorted.

Now, for k=0, but k>=1 as per constraints, so not needed.

Now, the problem is to find, for given n and k, whether such an array exists.

From the sample outputs:

- For n=2, k=2: [1,1]

- For n=3, k=1: [69420,69,420]

- For n=3, k=2: -1

Hence, for some n and k, no such array exists.

I need to find a general way to determine if such an array exists for given n and k, and if yes, construct one.

Let's think about the properties.

First, for k=n, only constant arrays work.

For k=1, it's possible for n>=2 by making the array non-constant and ensuring only one shift is sorted.

For other values of k, it's less clear.

Looking at the sample where n=3, k=2 is impossible.

Is there a general rule here?

Let's think about the number of sorted shifts an array can have.

For a given array, how many of its cyclic shifts can be sorted?

Let's consider that.

Suppose I have an array a1, a2, ..., an.

Its cyclic shifts are:

- Shift 1: a1, a2, ..., an

- Shift 2: a2, a3, ..., a1

- ...

- Shift n: an, a1, a2, ..., a{n-1}

I need exactly k of these to be sorted.

Let's consider the array is arranged in some order.

One approach is to consider the array as a circular list and find rotations where the list is sorted.

This seems related to the number of starting points where the circular list is sorted.

In other words, if I fix the array and rotate it, how many rotations result in a sorted list.

I need exactly k such rotations.

Let's consider that for a sorted array, all rotations may not be sorted, unless the array is constant.

Wait, for a sorted array that is not constant, rotations may or may not be sorted.

For example, [1,2,3]:

- [1,2,3] sorted

- [2,3,1] not sorted (2<=3<=1? No)

- [3,1,2] not sorted (3<=1<=2? No)

Hence, only one sorted rotation.

Similarly, [1,2,2]:

- [1,2,2] sorted

- [2,2,1] sorted (2<=2<=1? No)

- [2,1,2] not sorted (2<=1<=2? No)

Wait, [2,2,1] is not sorted because 2<=2<=1 is false.

Wait, 2<=2 is true, but 2<=1 is false, so [2,2,1] is not sorted.

Hence, only one sorted rotation.

So, for sorted arrays, seems only one rotation is sorted.

What about arrays that are not fully sorted?

For example, [1,3,2]:

- [1,3,2] sorted? 1<=3<=2? No

- [3,2,1] sorted? 3<=2<=1? No

- [2,1,3] sorted? 2<=1<=3? No

Hence, no sorted rotations.

[1,1,2]:

- [1,1,2] sorted

- [1,2,1] not sorted

- [2,1,1] not sorted

Hence, k=1

[1,2,1]:

- [1,2,1] not sorted

- [2,1,1] not sorted

- [1,1,2] sorted

Hence, k=1

[1,2,3]:

- [1,2,3] sorted

- [2,3,1] not sorted

- [3,1,2] not sorted

Hence, k=1

So, for n=3, it seems that k can only be 1 or 3.

Hence, for n=3, k=2 is impossible, which matches the sample output.

Similarly, for n=2:

- [1,1]: k=2

- [1,2]: k=1

- [2,1]: k=1

- [2,2]: k=2

Hence, for n=2, k can be 1 or 2.

Similarly, for n=1, k=1 always.

Hence, a pattern seems to emerge that for a given n, k can only be 1 or n, except for n=1 where k=1.

Wait, for n=1, k=1 is the only possibility.

For n=2, k can be 1 or 2.

For n=3, k can be 1 or 3.

For n=4, perhaps similar.

Let's check n=4.

Suppose n=4, k=1.

Array [1,2,3,4]:

- [1,2,3,4] sorted

- [2,3,4,1] not sorted

- [3,4,1,2] not sorted

- [4,1,2,3] not sorted

Hence, k=1

Array [1,1,1,1]:

- All 4 shifts are sorted: k=4

Array [1,2,3,2]:

- [1,2,3,2] sorted? 1<=2<=3<=2? No

- [2,3,2,1] sorted? 2<=3<=2<=1? No

- [3,2,1,2] sorted? 3<=2<=1<=2? No

- [2,1,2,3] sorted? 2<=1<=2<=3? No

Hence, k=0, which is invalid as per constraints.

Array [1,2,2,1]:

- [1,2,2,1] sorted? 1<=2<=2<=1? No

- [2,2,1,1] sorted? 2<=2<=1<=1? No

- [2,1,1,2] sorted? 2<=1<=1<=2? No

- [1,1,2,2] sorted

Hence, k=1

So, for n=4, k=1 is possible.

What about k=2?

Is there an array where exactly two cyclic shifts are sorted?

Let's try to construct one.

Suppose [1,2,1,2]:

- [1,2,1,2] sorted? 1<=2<=1<=2? No

- [2,1,2,1] sorted? 2<=1<=2<=1? No

- [1,2,1,2] same as first, not sorted

- [2,1,2,1] same as second, not sorted

Hence, k=0

Not useful.

Another attempt: [1,2,3,2]

Already tried, k=0

[1,2,2,3]:

- [1,2,2,3] sorted

- [2,2,3,1] sorted? 2<=2<=3<=1? No

- [2,3,1,2] sorted? 2<=3<=1<=2? No

- [3,1,2,2] sorted? 3<=1<=2<=2? No

Hence, k=1

Not helpful.

Another attempt: [1,1,2,2]

- [1,1,2,2] sorted

- [1,2,2,1] sorted? 1<=2<=2<=1? No

- [2,2,1,1] sorted

- [2,1,1,2] sorted? 2<=1<=1<=2? No

Hence, k=2

Wait, this seems promising.

So, for n=4, k=2 is possible with [1,1,2,2]

Let's check:

- [1,1,2,2] sorted

- [1,2,2,1] not sorted

- [2,2,1,1] sorted

- [2,1,1,2] not sorted

Hence, k=2

So, for n=4, k=2 is possible.

But for n=3, k=2 is not possible.

Hence, the pattern earlier may not hold.

Let me see.

Wait, perhaps k can be 1 or n, or some divisors of n.

Wait, for n=4, k=2 is possible, but for n=3, k=2 is not possible.

Similarly, for n=2, k=1 and k=2 are possible.

For n=1, k=1 is possible.

For n=4, k=2 is possible.

Is there a general rule here?

Let's consider that k must be a divisor of n.

For n=1, divisors are {1}

For n=2, divisors are {1,2}

For n=3, divisors are {1,3}

For n=4, divisors are {1,2,4}

And indeed, for n=2, k=1 and 2 are possible.

For n=3, k=1 and 3 are possible.

For n=4, k=1,2,4 are possible.

Wait, but in the sample, for n=3, k=2 is not possible, which matches that only divisors are possible.

Wait, but for n=4, k=2 is possible.

Wait, but is k=2 a divisor of n=4? Yes, 4/2=2.

Similarly, for n=2, k=1 and 2, both divisors.

For n=3, k=1 and 3, both divisors.

Hence, perhaps k must be a divisor of n.

But wait, for n=4, k=2 is possible, as shown with [1,1,2,2]

For n=6, k=2 would not be possible because 6/2=3, but k=2 is not a divisor in that sense.

Wait, no, k=2 is a divisor of 6, since 6/2=3.

Wait, perhaps k must be a divisor of n.

But in n=3, k=2 is not a divisor, and it's impossible.

In n=4, k=2 is a divisor and possible.

In n=2, k=1 and 2, both divisors.

In n=1, k=1 is a divisor.

Hence, perhaps k must be a divisor of n.

But is this always true?

Wait, for n=4, k=2 is possible with [1,1,2,2]

For n=4, k=4 is possible with [1,1,1,1]

For n=4, k=1 is possible with [1,2,3,4]

So, for n=4, k=1,2,4 are possible, which are all divisors of 4.

Similarly, for n=6, k=1,2,3,6 are possible.

Wait, but for n=6, k=3 is possible.

For example, [1,1,1,2,2,2]

- [1,1,1,2,2,2] sorted

- [1,1,2,2,2,1] not sorted

- [1,2,2,2,1,1] not sorted

- [2,2,2,1,1,1] sorted

- [2,2,1,1,1,2] not sorted

- [2,1,1,1,2,2] not sorted

Hence, k=2, which is divisor of 6.

Wait, but I thought k=3 is possible.

Wait, perhaps I miscalculated.

Wait, [1,1,2,2,3,3]

- [1,1,2,2,3,3] sorted

- [1,2,2,3,3,1] sorted

- [2,2,3,3,1,1] sorted

- [2,3,3,1,1,2] not sorted

- [3,3,1,1,2,2] sorted

- [3,1,1,2,2,3] not sorted

Hence, k=4, which is divisor of 6.

Wait, 6/4 is not an integer, but 4 is not a divisor of 6.

Wait, no, 6/4=1.5, so 4 is not a divisor of 6.

Hence, k=4 is possible for n=6, which is not a divisor of 6.

Wait, but earlier I thought k must be a divisor of n.

But in this case, k=4 is not a divisor of n=6.

Hence, my earlier assumption is incorrect.

So, perhaps there's another pattern.

Let me think differently.

Suppose I have an array where some elements are equal, and some are not.

I need to find how many cyclic shifts are sorted.

Perhaps, the number of sorted cyclic shifts corresponds to the number of distinct rotations where the array is sorted.

In circular arrays, the number of distinct rotations where the array is sorted can vary.

I need to find if there exists an array where exactly k rotations result in a sorted array.

Let me consider that for a sorted array with duplicates, the number of sorted rotations can be greater than 1.

For example, [1,1,2,2]

- [1,1,2,2] sorted

- [1,2,2,1] not sorted

- [2,2,1,1] sorted

- [2,1,1,2] not sorted

Hence, k=2

Similarly, [1,1,1,2]

- [1,1,1,2] sorted

- [1,1,2,1] sorted

- [1,2,1,1] sorted

- [2,1,1,1] not sorted

Wait, is [1,1,2,1] sorted? 1<=1<=2<=1? No, it's not sorted.

Wait, [1,1,2,1]: 1<=1<=2<=1 is false.

Hence, only [1,1,1,2] and [1,1,2,1] and [1,2,1,1] are considered, but only [1,1,1,2] is sorted.

Hence, k=1

Wait, perhaps I need a better approach.

Let me consider that for an array to have exactly k sorted cyclic shifts, the array must have a specific structure.

Perhaps, the array must be composed of repeated sequences that allow exactly k sorted shifts.

Wait, perhaps I can think in terms of the array being divided into k equal parts, each of which is sorted, and the transitions between parts are such that the shifts are not sorted.

But this seems vague.

Let me consider the greatest common divisor (GCD) of n and k.

Wait, in group theory, the number of distinct rotations of an array of length n is related to the GCD of the shift amount and n.

But I'm not sure if that directly applies here.

Alternatively, perhaps the number of sorted cyclic shifts is related to the number of times the array repeats a certain pattern.

Wait, perhaps if the array is composed of k identical blocks, each of size n/k, then the number of sorted shifts would be k.

Wait, for example, n=4, k=2: [1,1,2,2]

- [1,1,2,2] sorted

- [1,2,2,1] not sorted

- [2,2,1,1] sorted

- [2,1,1,2] not sorted

Hence, k=2

Similarly, for n=6, k=2: [1,1,2,2,3,3]

- [1,1,2,2,3,3] sorted

- [1,2,2,3,3,1] not sorted

- [2,2,3,3,1,1] sorted

- [2,3,3,1,1,2] not sorted

- [3,3,1,1,2,2] sorted

- [3,1,1,2,2,3] not sorted

Wait, in this case, k=3

Wait, but earlier I thought it's k=4.

Wait, perhaps I miscalculated earlier.

Wait, for [1,1,2,2,3,3]

- [1,1,2,2,3,3] sorted

- [1,2,2,3,3,1] not sorted

- [2,2,3,3,1,1] sorted

- [2,3,3,1,1,2] not sorted

- [3,3,1,1,2,2] sorted

- [3,1,1,2,2,3] not sorted

Hence, k=3

And 3 is a divisor of 6.

Wait, but earlier I thought k=4, but actually it's k=3.

Hence, k=3 is a divisor of 6.

Similarly, for n=6, k=3 is possible.

Hence, perhaps k must be a divisor of n.

But earlier, for n=4, k=2 is a divisor and possible.

For n=3, k=1 and 3 are divisors and possible, k=2 not a divisor and not possible.

Hence, perhaps k must be a divisor of n.

But is this always the case?

Let's check for n=5, which is prime.

Hence, divisors are 1 and 5.

Hence, only k=1 and k=5 are possible.

Let's try to construct an array for n=5, k=1.

For example, [1,2,3,4,5]

- [1,2,3,4,5] sorted

- [2,3,4,5,1] not sorted

- [3,4,5,1,2] not sorted

- [4,5,1,2,3] not sorted

- [5,1,2,3,4] not sorted

Hence, k=1

Similarly, for k=5, only constant array [1,1,1,1,1] would work.

Hence, for n=5, only k=1 and k=5 are possible, which are divisors of 5.

Similarly, for n=6, k=2,3,6 are possible.

Wait, for n=6, k=2 is possible with [1,1,2,2,3,3]

Wait, earlier I thought k=3, but actually:

[1,1,2,2,3,3]

- [1,1,2,2,3,3] sorted

- [1,2,2,3,3,1] not sorted

- [2,2,3,3,1,1] sorted

- [2,3,3,1,1,2] not sorted

- [3,3,1,1,2,2] sorted

- [3,1,1,2,2,3] not sorted

Hence, k=3

But 3 is a divisor of 6.

Similarly, [1,1,2,2,2,2]

- [1,1,2,2,2,2] sorted

- [1,2,2,2,2,1] not sorted

- [2,2,2,2,1,1] sorted

- [2,2,2,1,1,2] not sorted

- [2,2,1,1,2,2] not sorted

- [2,1,1,2,2,2] not sorted

Hence, k=2, which is a divisor of 6.

Hence, seems consistent.

Hence, perhaps the rule is that k must be a divisor of n.

But to confirm, let's check for n=4, k=2: possible.

For n=4, k=4: [1,1,1,1]

For n=4, k=1: [1,2,3,4]

For n=4, k=2: [1,1,2,2]

Hence, k divides n in all possible cases.

Similarly, for n=6, k=3: [1,1,2,2,3,3]

k=3 divides n=6.

Hence, perhaps the rule is that k must be a divisor of n.

Hence, in the code, for each test case, check if k divides n.

If yes, construct an array with repeating blocks.

For example, for n=6, k=3: have two blocks of [1,2,3], arranged as [1,2,3,1,2,3]

But wait, that would be [1,2,3,1,2,3]

- [1,2,3,1,2,3] sorted? 1<=2<=3<=1<=2<=3? No

- [2,3,1,2,3,1] sorted? 2<=3<=1<=2<=3<=1? No

- [3,1,2,3,1,2] sorted? 3<=1<=2<=3<=1<=2? No

- [1,2,3,1,2,3] same as first

- [2,3,1,2,3,1] same as second

- [3,1,2,3,1,2] same as third

Hence, k=0, which is not correct.

Wait, perhaps I need to adjust the values.

Wait, perhaps make the blocks have increasing values.

For example, [1,1,2,2,3,3]

- [1,1,2,2,3,3] sorted

- [1,2,2,3,3,1] not sorted

- [2,2,3,3,1,1] sorted

- [2,3,3,1,1,2] not sorted

- [3,3,1,1,2,2] sorted

- [3,1,1,2,2,3] not sorted

Hence, k=3

So, for n=6, k=3: [1,1,2,2,3,3]

Similarly, for n=4, k=2: [1,1,2,2]

For n=4, k=4: [1,1,1,1]

For n=4, k=1: [1,2,3,4]

Hence, seems to work.

Similarly, for n=5, k=1: [1,2,3,4,5]

For n=5, k=5: [1,1,1,1,1]

Hence, the general approach seems to be:

- If k divides n, then construct an array with n/k unique values, each repeated k times.

- For example, for n=6, k=3: 6/3=2, so two unique values, each repeated 3 times: [1,1,1,2,2,2]

Wait, but earlier [1,1,2,2,3,3] had three unique values, each repeated twice.

Wait, perhaps I need to adjust.

Wait, for n=6, k=3:

- Number of unique values: n/k = 2

- So, two unique values, each repeated 3 times.

- For example, [1,1,1,2,2,2]

- Shifts:

  - [1,1,1,2,2,2] sorted

  - [1,1,2,2,2,1] not sorted

  - [1,2,2,2,1,1] not sorted

  - [2,2,2,1,1,1] sorted

  - [2,2,1,1,1,2] not sorted

  - [2,1,1,1,2,2] not sorted

Hence, k=2, which is not what we wanted.

Wait, but k=3 was earlier achieved with [1,1,2,2,3,3]

Wait, perhaps the number of unique values should be k, each repeated n/k times.

Wait, for n=6, k=3: have 3 unique values, each repeated 2 times.

- [1,1,2,2,3,3]

- Shifts:

  - [1,1,2,2,3,3] sorted

  - [1,2,2,3,3,1] not sorted

  - [2,2,3,3,1,1] sorted

  - [2,3,3,1,1,2] not sorted

  - [3,3,1,1,2,2] sorted

  - [3,1,1,2,2,3] not sorted

Hence, k=3

Similarly, for n=4, k=2: have 2 unique values, each repeated 2 times.

- [1,1,2,2]

- Shifts:

  - [1,1,2,2] sorted

  - [1,2,2,1] not sorted

  - [2,2,1,1] sorted

  - [2,1,1,2] not sorted

Hence, k=2

Similarly, for n=5, k=1: have 1 unique value repeated 5 times.

Wait, but for k=1, we need to have a non-constant array.

Wait, perhaps for k=1, it's a special case.

Wait, perhaps for k=1, the array should be strictly increasing.

But for n=3, k=1: [1,2,3]

- [1,2,3] sorted

- [2,3,1] not sorted

- [3,1,2] not sorted

Hence, k=1

Similarly, for n=4, k=1: [1,2,3,4]

- [1,2,3,4] sorted

- [2,3,4,1] not sorted

- [3,4,1,2] not sorted

- [4,1,2,3] not sorted

Hence, k=1

Similarly, for n=5, k=1: [1,2,3,4,5]

- [1,2,3,4,5] sorted

- [2,3,4,5,1] not sorted

- [3,4,5,1,2] not sorted

- [4,5,1,2,3] not sorted

- [5,1,2,3,4] not sorted

Hence, k=1

So, for k=1, a strictly increasing array works.

Similarly, for k=n, a constant array works.

For other k values, where k divides n, constructing an array with k unique values, each repeated n/k times, seems to work.

Hence, perhaps the general rule is:

- If k divides n, then such an array exists.

- Else, no such array exists.

But, to confirm, let's check for n=4, k=2: possible.

For n=4, k=3: 4 is not divisible by 3, hence not possible.

Wait, but n=4, k=3: 4 is not divisible by 3, hence no such array exists.

Similarly, for n=5, k=2: 5 is not divisible by 2, hence no such array exists.

Hence, in the code, for each test case, check if k divides n.

- If yes, construct an array with k unique values, each repeated n/k times.

- If not, output -1.

Wait, but for k=1 and k=n, it works as special cases.

For k=1:

- Have a strictly increasing array.

For k=n:

- Have a constant array.

But, in the general case, for k dividing n, constructing an array with k unique values, each repeated n/k times, works.

Wait, but for k=1, this would mean one unique value repeated n times, which is a constant array, which is sorted in all rotations, i.e., k=n.

But in the earlier examples, for k=1, we used strictly increasing arrays.

Hence, perhaps for k=1, it's a special case where we use a strictly increasing array.

Similarly, for k=n, use a constant array.

For other k where k divides n, use k unique values, each repeated n/k times.

Hence, in code, handle these cases separately.

Hence, the plan is:

- If k == n:

- Output an array where all elements are equal.

- For example, [1,1,1,...,1]

- If k == 1:

- Output a strictly increasing array.

- For example, [1,2,3,...,n]

- Else, if k divides n:

- Output an array with k unique values, each repeated n/k times.

- For example, for n=6, k=3: [1,1,2,2,3,3]

- Else:

- Output -1

Now, to implement this in code.

Given that t test cases, each with n and k.

Constraints:

- Sum of n over all test cases <=10^3

- 1 <= k <=n <=10^3

Hence, feasible.

Edge cases:

- n=1, k=1: [any value], say [1]

- n=2, k=1: [1,2]

- n=2, k=2: [1,1]

- n=3, k=1: [1,2,3]

- n=3, k=3: [1,1,1]

- n=3, k=2: -1

- n=4, k=1: [1,2,3,4]

- n=4, k=2: [1,1,2,2]

- n=4, k=4: [1,1,1,1]

- n=5, k=1: [1,2,3,4,5]

- n=5, k=5: [1,1,1,1,1]

- n=5, k=2: -1

- n=6, k=2: [1,1,2,2,3,3]

- n=6, k=3: [1,1,2,2,3,3]

- n=6, k=6: [1,1,1,1,1,1]

Hence, seems consistent.

Hence, in code, for each test case:

- If k ==n:

- Output [1]*n

- Elif k ==1:

- Output range(1, n+1)

- Elif n %k ==0:

- block_size =n //k

- Construct an array with k unique values, each repeated block_size times.

- For example, for n=6, k=3, block_size=2: [1,1,2,2,3,3]

- Else:

- Output -1

Hence, the code provided seems to follow this logic.

Wait, looking back at the provided code:

def func():

t = int(input())

for _ in range(t):

(n, k) = (int(i) for i in input().split())

res = [1] *n if k ==n else range(n) if k ==1 else [-1]

print(*res)

Hence, for k ==n, it outputs [1]*n, which is correct.

For k ==1, it outputs range(n), which is 0 to n-1.

Wait, but in my earlier examples, I used 1 to n.

Hence, perhaps it should be range(1, n+1)

But in Python, range(n) is 0 to n-1.

Hence, it's outputting [0,1,2,...,n-1]

But the problem specifies 1 <= a_i <=10^9

Hence, outputting 0 is invalid.

Hence, this is an error in the code.

It should be range(1, n+1)

Similarly, for k divides n, it outputs [-1], which is incorrect.

Wait, no, in the else clause, it's outputting [-1], which for n>=1, prints -1 followed by spaces.

But the requirement is to output a single -1.

Hence, it's incorrect.

Hence, the code is flawed.

Hence, Correctness: False

## Final Solution
To solve this problem, we need to determine if there exists an array of length \( n \) such that exactly \( k \) of its cyclic shifts are sorted. If such an array exists, we need to construct it; otherwise, we should output -1.

### Approach

1. **Understanding Cyclic Shifts and Sorted Arrays**:
   - A cyclic shift of an array is created by rotating its elements.
   - We need exactly \( k \) of these shifts to be sorted in non-decreasing order.

2. **Key Observations**:
   - If \( k = n \), the array must be constant (all elements equal).
   - If \( k = 1 \), the array can be strictly increasing.
   - For other values of \( k \), it is possible only if \( k \) divides \( n \). In such cases, the array can be constructed by repeating a sequence of \( k \) unique values, each repeated \( \frac{n}{k} \) times.

3. **Implementation Steps**:
   - For \( k = n \), output an array where all elements are the same.
   - For \( k = 1 \), output a strictly increasing array from 1 to \( n \).
   - For other \( k \), check if \( k \) divides \( n \):
     - If yes, construct an array with \( k \) unique values, each repeated \( \frac{n}{k} \) times.
     - If not, output -1.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        if k == n:
            res = [1] * n
        elif k == 1:
            res = list(range(1, n + 1))
        elif n % k == 0:
            block_size = n // k
            res = []
            for i in range(k):
                res.extend([i + 1] * block_size)
        else:
            res = [-1]
        print(*res)

func()
```

### Explanation

- **Case 1: \( k = n \)**:
  - The array is filled with the same value (1 in this case).
  - All cyclic shifts are sorted.

- **Case 2: \( k = 1 \)**:
  - The array is strictly increasing: [1, 2, 3, ..., n].
  - Only one cyclic shift is sorted.

- **Case 3: \( k \) divides \( n \)**:
  - The array is constructed by repeating \( k \) unique values, each \( \frac{n}{k} \) times.
  - This ensures exactly \( k \) cyclic shifts are sorted.

- **Otherwise**:
  - Output -1, as no such array exists.

This approach ensures that we handle all edge cases and constraints efficiently, providing the correct output for each test case.