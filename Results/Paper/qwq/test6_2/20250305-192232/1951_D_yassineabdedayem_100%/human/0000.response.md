Alright, I have this problem to solve. Let's understand what's being asked here. So, Alice has 'n' coins and wants to buy exactly 'k' jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel ranging from 1 to 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if it's possible for Bob to set up the stalls and set the prices in such a way that Alice ends up buying exactly 'k' jewels. If it's possible, I need to output "YES", followed by the number of stalls and their respective prices. If not, I should output "NO".

First, I need to think about how Alice's buying behavior works. She starts with 'n' coins and visits each stall in order. At each stall, she buys as many jewels as she can with her current coins, using as much coins as possible on those jewels.

So, if a stall has a price 'p', and she has 'c' coins, she can buy floor(c / p) jewels and will have c % p coins left.

Bob needs to set up the stalls in such a way that the total number of jewels Alice buys across all stalls is exactly 'k'.

I also need to make sure that the number of stalls is at most 60.

Looking at the example provided:

In the first test case:

n = 7, k = 3

Stalls: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11

Alice buys:

- At stall 2: 3 jewels (7 // 2 = 3), coins left: 1

- At other stalls, she can't buy any more jewels because she has less than the price required.

Total jewels: 3, which matches k.

In the third test case:

n = 255, k = 8

Stalls: 128, 64, 32, 16, 8, 4, 2, 1

Alice buys:

- At stall 128: 1 jewel, coins left: 127

- At stall 64: 1 jewel, coins left: 63

- At stall 32: 1 jewel, coins left: 31

- At stall 16: 1 jewel, coins left: 15

- At stall 8: 1 jewel, coins left: 7

- At stall 4: 1 jewel, coins left: 3

- At stall 2: 1 jewel, coins left: 1

- At stall 1: 1 jewel, coins left: 0

Total jewels: 8, which matches k.

This seems similar to the binary representation of numbers. In the third test case, the stall prices are powers of 2, decreasing from 128 down to 1. This allows Alice to buy one jewel at each stall, effectively subtracting the stall price from her remaining coins each time.

In the first test case, they used a sequence starting from 2 up to 11, but only the first stall was sufficient to get the exact number of jewels.

So, perhaps there's a general approach here.

Let me think about the general case.

If Bob sets up stalls with decreasing prices, like in the third example, Alice will buy one jewel per stall until her coins are less than the price of the next stall.

So, if Bob sets up stalls with prices that are powers of some number, maybe she buys a certain number at each stall.

Wait, in the third example, with prices being powers of 2, she buys one at each stall.

Similarly, if Bob sets up stalls with prices that are multiples of some number, maybe he can control how many jewels she buys at each stall.

But I need a general strategy that works for any n and k, as long as it's possible within at most 60 stalls.

Let me consider the minimal number of stalls required.

If k = 1, Alice needs to buy exactly one jewel. Bob can set up one stall with price n, so Alice buys one jewel and has zero coins left.

If k = n, Alice needs to buy n jewels. Bob can set up n stalls, each with price 1, so Alice buys one jewel from each stall.

Wait, but Bob can set up at most 60 stalls, so if k > 60, I need to make sure that it's possible with at most 60 stalls.

Wait, k can be up to 10^18, which is much larger than 60, so I need a way to handle large k with at most 60 stalls.

Looking back at the third example, with k = 8 and n = 255, they used 8 stalls, each with prices being powers of 2, decreasing from 128 to 1.

In this case, Alice buys one jewel from each stall.

So, perhaps one strategy is to set up k stalls, each with price p_i such that the sum of floor(c / p_i) for c starting from n and updating after each stall, equals k.

But this seems too vague.

Let me think differently.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

Alice buys floor(n / p1) jewels from the first stall, then has n % p1 coins left.

Then, she buys floor((n % p1) / p2) jewels from the second stall, and so on.

So, the total number of jewels bought is sum over i from 1 to s of floor(n_i / p_i), where n_i is the coins left before visiting stall i.

We need this sum to be exactly k.

Our task is to choose s <= 60 and p1, p2, ..., ps such that this sum is exactly k.

I need to find a way to control the sum to be exactly k.

Let me consider the minimal number of stalls required.

If Bob sets up only one stall, with price p, then Alice buys floor(n / p) jewels.

We need floor(n / p) = k.

This implies that p = floor(n / k).

But wait, floor(n / p) = k implies that p = floor(n / k).

Wait, no.

Wait, floor(n / p) = k implies that p <= floor(n / k).

Wait, actually, floor(n / p) = k implies that n / p >= k and n / p < k + 1.

So, n / p >= k and n / p < k + 1.

Which means n / k >= p and p > n / (k + 1).

So, p <= floor(n / k) and p > ceil(n / (k + 1)).

Wait, let's think carefully.

floor(n / p) = k implies that k <= n / p < k + 1.

So, p >= ceil(n / (k + 1)) and p <= floor(n / k).

If there exists such a p, then with one stall, we can achieve exactly k jewels.

So, in the code provided, for the case when n == k, it sets up one stall with price 1, which makes sense because floor(n / 1) = n = k.

For other cases, if there exists a p such that floor(n / p) = k, then one stall is sufficient.

But in cases where such a p does not exist, or to adjust for exact k, Bob might need to set up multiple stalls.

Looking at the code:

def func():

t = int(input())

for _ in range(t):

(n, k) = map(int, stdin.readline().split())

if n == k:

print('YES')

print(1)

print(1)

elif n + 2 > k * 2:

print('YES')

print(2)

print(n - k + 1, end=' ')

print(1)

else:

print('NO')

So, it's handling three cases:

1. If n == k, set up one stall with price 1.

2. If n + 2 > k * 2, set up two stalls: one with price n - k + 1 and another with price 1.

3. Otherwise, output "NO".

Let me verify if this logic is correct.

First case is straightforward: if n == k, setting price to 1 allows Alice to buy n jewels from one stall.

Second case: n + 2 > k * 2, which simplifies to n > 2k - 2.

In this case, it sets up two stalls: first with price p1 = n - k + 1, second with price p2 = 1.

Let's see what happens:

- At first stall, Alice buys floor(n / p1) jewels.

- Then, she has n % p1 coins left.

- At second stall, she buys floor((n % p1) / 1) jewels.

- Total jewels: floor(n / p1) + floor((n % p1) / 1).

We need this sum to be equal to k.

Let me compute floor(n / p1) + floor((n % p1) / 1).

Since n % p1 < p1, and p1 = n - k + 1, so n % p1 < n - k + 1.

Therefore, floor(n / p1) = floor(n / (n - k + 1)).

Let me denote m = n - k + 1.

Then, floor(n / m) + floor((n % m) / 1) = floor(n / m) + (n % m).

Because floor((n % m) / 1) = n % m.

So, total jewels = floor(n / m) + (n % m).

But m = n - k + 1.

We need floor(n / m) + (n % m) = k.

Let me check if this holds.

Let q = floor(n / m), r = n % m.

So, n = q * m + r, with 0 <= r < m.

Total jewels = q + r.

We need q + r = k.

But n = q * m + r = q * (n - k + 1) + r.

But r < m = n - k + 1.

I need to see if q + r = k.

Wait, substituting n = q * m + r into n = q * (n - k + 1) + r.

This seems messy.

Let me try with some numbers.

Take n = 7, k = 3.

Then m = 7 - 3 + 1 = 5.

So, p1 = 5, p2 = 1.

Alice buys floor(7 / 5) = 1 jewel from first stall, left with 2 coins.

Then buys floor(2 / 1) = 2 jewels from second stall.

Total: 1 + 2 = 3, which matches k.

Another example: n = 6, k = 4.

m = 6 - 4 + 1 = 3.

p1 = 3, p2 = 1.

Alice buys floor(6 / 3) = 2 jewels from first stall, left with 0 coins.

Then buys floor(0 / 1) = 0 jewels from second stall.

Total: 2 + 0 = 2, which is less than k = 4.

Wait, but according to the code, it should print "YES" in this case, but actually, total jewels are 2, not 4.

Wait, maybe I'm misunderstanding.

Wait, in the code, it checks if n + 2 > k * 2, which for n=6, k=4, 6 + 2 = 8 > 8, which is not true, so it's actually n + 2 <= k * 2, which is 8 <= 8, so it's equal, which falls under "else: print('NO')".

Wait, the condition is n + 2 > k * 2.

For n=7, k=3: 7 + 2 = 9 > 6, which is true.

For n=6, k=4: 6 + 2 = 8 > 8, which is false.

Wait, 8 > 8 is false, so it's "NO".

But in the example input, the second case is 6 4, and the output is "NO", which matches.

Wait, but in my calculation, for n=6, k=4, m=3, p1=3, p2=1, total jewels=2, which is less than k=4, so correctly it should be "NO".

But wait, the condition n + 2 > k * 2 seems arbitrary. Let's see where it comes from.

Wait, perhaps it's a derived condition for when the two-stall setup works.

Let me think about when two stalls are sufficient.

Suppose Bob sets up two stalls, with prices p1 and p2.

Alice buys floor(n / p1) jewels from the first stall, then has n % p1 coins left.

Then buys floor((n % p1) / p2) jewels from the second stall.

Total jewels: floor(n / p1) + floor((n % p1) / p2) = k.

We need to choose p1 and p2 such that this sum equals k.

In the code, it chooses p1 = n - k + 1 and p2 = 1.

Let me see under what conditions this works.

Let p1 = n - k + 1.

Then, floor(n / p1) = floor(n / (n - k + 1)).

Let me denote m = n - k + 1.

So, floor(n / m) = q, where q is the quotient when n is divided by m.

Let r = n % m.

So, n = q * m + r, with 0 <= r < m.

Total jewels: q + floor(r / 1) = q + r.

We need q + r = k.

But n = q * m + r = q * (n - k + 1) + r.

We need q + r = k.

Let me express r in terms of q:

From n = q * (n - k + 1) + r, and r = n - q * (n - k + 1).

Substitute into q + r = k:

q + n - q * (n - k + 1) = k.

Simplify:

n + q - q * (n - k + 1) = k.

n + q * (1 - (n - k + 1)) = k.

n + q * (1 - n + k - 1) = k.

n + q * (k - n) = k.

n + qk - qn = k.

Rearrange:

qk - qn = k - n.

q(k - n) = k - n.

If k != n, then q = 1.

If k = n, then q can be any value, but in that case, p1 = n - n + 1 = 1, which is handled separately in the code.

So, if q = 1, then from n = 1 * m + r = m + r, with 0 <= r < m.

But m = n - k + 1.

So, n = (n - k + 1) + r.

Thus, r = n - (n - k + 1) = k - 1.

So, total jewels: q + r = 1 + (k - 1) = k.

Perfect, so it works when q = 1 and r = k - 1.

But for q to be 1, we need n >= m and n < 2m.

That is, m <= n < 2m.

Since m = n - k + 1, this translates to n - k + 1 <= n < 2(n - k + 1).

Simplify:

n - k + 1 <= n is always true.

And n < 2(n - k + 1):

n < 2n - 2k + 2.

Subtract n:

0 < n - 2k + 2.

Which is n > 2k - 2.

Wait, but the code checks n + 2 > k * 2, which is equivalent to n > 2k - 2.

So, this condition ensures that q = 1.

Hence, when n > 2k - 2, setting p1 = n - k + 1 and p2 = 1 results in Alice buying exactly k jewels.

In other cases, it's impossible with two stalls, and the code outputs "NO".

But is this always the case? Is it possible to have more than two stalls to achieve k jewels when n <= 2k - 2?

Looking back at the problem, Bob can set up up to 60 stalls.

So, maybe with more stalls, it's possible to achieve k jewels even when n <= 2k - 2.

Let's consider an example where n <= 2k - 2.

Take n = 4, k = 3.

Here, n = 4, 2k - 2 = 4, so n == 2k - 2.

According to the code, it would output "NO", but maybe with more stalls, it's possible.

Let's try to set up three stalls.

Suppose p1 = 2, p2 = 1, p3 = 1.

Alice buys floor(4 / 2) = 2 jewels from first stall, left with 0 coins.

Then, floor(0 / 1) = 0 from second stall.

Total jewels: 2 + 0 + 0 = 2, which is less than k.

Alternatively, p1 = 1, p2 = 1, p3 = 1.

Alice buys 4 jewels from first stall, which is more than k.

Not useful.

Alternatively, p1 = 2, p2 = 2, p3 = 1.

Alice buys floor(4 / 2) = 2 from first stall, left with 0.

Then, floor(0 / 2) = 0 from second stall.

Total: 2 + 0 + 0 = 2, still less than k.

Another approach: p1 = 3, p2 = 1, p3 = 1.

Alice buys floor(4 / 3) = 1 jewel from first stall, left with 1 coin.

Then, floor(1 / 1) = 1 from second stall, left with 0.

Total: 1 + 1 + 0 = 2, still less than k.

Seems like it's impossible to get exactly k = 3 jewels with n = 4 coins, even with more stalls.

Another example: n = 3, k = 2.

Possible with two stalls: p1 = 2, p2 = 1.

Alice buys floor(3 / 2) = 1 jewel, left with 1 coin.

Then buys floor(1 / 1) = 1 jewel.

Total: 2, which matches k.

So, in this case, with n = 3 and k = 2, it's possible with two stalls.

But according to the condition n + 2 > k * 2, 3 + 2 = 5 > 4, which holds, so the code would output "YES" with two stalls: p1 = 3 - 2 + 1 = 2, p2 = 1.

Which works, as shown.

Another case: n = 5, k = 3.

n + 2 = 7 > 6, which holds.

Set p1 = 5 - 3 + 1 = 3, p2 = 1.

Alice buys floor(5 / 3) = 1 jewel, left with 2 coins.

Then buys floor(2 / 1) = 2 jewels.

Total: 3, which matches k.

Good.

Another case: n = 4, k = 2.

n + 2 = 6 > 4, holds.

Set p1 = 4 - 2 + 1 = 3, p2 = 1.

Alice buys floor(4 / 3) = 1 jewel, left with 1 coin.

Then buys floor(1 / 1) = 1 jewel.

Total: 2, which matches k.

Good.

Another case: n = 4, k = 3.

n + 2 = 6 > 6 is false.

So, the code outputs "NO", which matches our earlier conclusion that it's impossible.

Hence, the condition n + 2 > k * 2 seems to correctly identify when it's possible to achieve k jewels with two stalls using the specified pricing strategy.

But is there a scenario where n + 2 > k * 2 holds, but the two-stall strategy doesn't work?

Let me check with n = 1, k = 1.

1 + 2 = 3 > 2, which holds.

Set p1 = 1 - 1 + 1 = 1, p2 = 1.

Alice buys floor(1 / 1) = 1 jewel, left with 0 coins.

Then floor(0 / 1) = 0 jewels.

Total: 1, which matches k.

Good.

Another scenario: n = 2, k = 1.

2 + 2 = 4 > 2, holds.

Set p1 = 2 - 1 + 1 = 2, p2 = 1.

Alice buys floor(2 / 2) = 1 jewel, left with 0 coins.

Then floor(0 / 1) = 0 jewels.

Total: 1, which matches k.

Good.

Another scenario: n = 1, k = 2.

1 + 2 = 3 > 4, which is false, so "NO".

Indeed, with one coin, it's impossible to buy two jewels, even with more than two stalls.

For example, with two stalls: p1 = 1, p2 = 1.

Alice buys floor(1 / 1) = 1 jewel, left with 0 coins.

Then floor(0 / 1) = 0 jewels.

Total: 1, which is less than 2.

Alternatively, p1 = 1, p2 = 0.5, but prices must be integers, so p2 = 1.

Not possible.

Hence, "NO" is correct.

So, the condition seems valid.

But the problem allows up to 60 stalls, not just two.

Is there a case where n + 2 <= k * 2, but with more than two stalls, it's possible to achieve k jewels?

Let me think about n = 4, k = 3.

n + 2 = 6 > 6 is false.

But with three stalls, is it possible?

Suppose p1 = 2, p2 = 1, p3 = 1.

Alice buys floor(4 / 2) = 2 jewels, left with 0 coins.

Then floor(0 / 1) = 0, and floor(0 / 1) = 0.

Total: 2, which is less than 3.

Alternatively, p1 = 1, p2 = 1, p3 = 1.

Alice buys 4 jewels from first stall, which is more than k.

Not useful.

Alternatively, p1 = 3, p2 = 1, p3 = 1.

Alice buys floor(4 / 3) = 1 jewel, left with 1 coin.

Then buys floor(1 / 1) = 1 jewel, left with 0 coins.

Then buys floor(0 / 1) = 0 jewels.

Total: 2, still less than 3.

Another approach: p1 = 2, p2 = 2, p3 = 1.

Alice buys floor(4 / 2) = 2 jewels, left with 0 coins.

Then buys floor(0 / 2) = 0, and floor(0 / 1) = 0.

Total: 2, still less than 3.

Seems impossible.

Another example: n = 5, k = 4.

n + 2 = 7 > 8 is false.

Is it possible to achieve k = 4 with more stalls?

With two stalls: p1 = 5 - 4 + 1 = 2, p2 = 1.

Alice buys floor(5 / 2) = 2 jewels, left with 1 coin.

Then buys floor(1 / 1) = 1 jewel.

Total: 3, which is less than 4.

With three stalls: p1 = 2, p2 = 1, p3 = 1.

Alice buys floor(5 / 2) = 2 jewels, left with 1 coin.

Then buys floor(1 / 1) = 1 jewel, left with 0 coins.

Then buys floor(0 / 1) = 0 jewels.

Total: 3, still less than 4.

Another approach: p1 = 1, p2 = 1, p3 = 1.

Alice buys 5 jewels from first stall, which is more than k.

Not useful.

Alternatively, p1 = 3, p2 = 1, p3 = 1.

Alice buys floor(5 / 3) = 1 jewel, left with 2 coins.

Then buys floor(2 / 1) = 2 jewels.

Total: 3, still less than 4.

Seems impossible.

Hence, the condition n + 2 > k * 2 seems to cover all cases where it's possible with two stalls, and in cases where it's not possible with two stalls, it's also impossible with more stalls.

Therefore, the code is correct in outputting "YES" when n + 2 > k * 2 and "NO" otherwise, with the provided stall setups.

Hence, the given program is correct.

**Final Answer**

\[ \boxed{\text{Correctness: True}} \]