Alright, I have this problem to solve. Let's see what it's about. So, I'm the CEO of a startup, and I need to buy tickets for my employees to a concert. There are n days to buy tickets, and each day has a certain price per ticket, given by the array a_i. There are some constraints:

1. I can't buy more than m tickets per day.

2. If I buy x tickets on day i, then from day i+1 onwards, the price per ticket increases by x.

My goal is to buy exactly k tickets in total, across these n days, spending the minimum possible amount of money.

First, I need to understand the problem fully. So, for each day, there's a base price per ticket, and this price increases by the number of tickets I've bought on previous days.

For example, in the first test case:

4 2 3

8 6 4 2

This means n=4 days, m=2 tickets per day, and k=3 tickets to buy.

The prices are 8,6,4,2 per ticket on each day respectively.

If I buy 0 on day 1, prices for days 2-4 remain 6,4,2.

Then, if I buy 0 on day 2, prices for days 3-4 remain 4,2.

Then, buy 1 on day 3 for 4, and prices for day 4 increase by 1, so day 4 price becomes 2+1=3.

Finally, buy 2 on day 4 for 2*3=6.

Total cost is 4 + 6 = 10, which matches the first output.

Another test case:

4 2 8

8 6 4 2

Here, n=4, m=2, k=8.

Since k=8 and m=2, I have to buy 2 tickets each day for 4 days.

Each day, I buy 2 tickets at the current price plus the sum of x from previous days.

Day 1: buy 2 at 8 each, total 16. Prices increase by 2 for next days.

Day 2: buy 2 at (6+2)=8 each, total 16.

Day 3: buy 2 at (4+4)=8 each, total 16.

Day 4: buy 2 at (2+6)=8 each, total 16.

Total cost is 64, which matches the second output.

Okay, so the problem is to choose on which days to buy tickets to minimize the total cost, given the constraints.

Constraints:

- 1 ≤ n ≤ 3*10^5

- 1 ≤ m ≤ 10^9

- 1 ≤ k ≤ min(n*m, 10^9)

- 1 ≤ a_i ≤ 10^9

- Sum of n over all test cases ≤ 3*10^5

Given the large constraints, especially n up to 3*10^5 and t up to 10^4, but sum of n over all test cases ≤ 3*10^5, I need an efficient algorithm, preferably O(n log n) per test case or better.

First thoughts:

- Since the price increases by x for all subsequent days, it's beneficial to buy tickets on days with lower base prices, but need to consider the increase in prices for future days.

- It's a trade-off between buying on a day with a low price but potentially increasing future prices, or buying on a day with a higher price but less impact on future days.

- Need to find an optimal strategy to minimize the total cost.

Let me think about how to model this.

Approach:

I need to decide how many tickets to buy on each day, up to m per day, and the total must be exactly k.

Each day, if I buy x tickets, the price per ticket on that day is a_i plus the sum of all x's from previous days.

So, the total cost on day i is x * (a_i + sum of all x's from day 1 to day i-1).

I need to minimize the sum of these costs over all days, subject to sum of x's being exactly k and x <= m per day.

This seems like a optimization problem with constraints.

Dynamic Programming Idea:

At first glance, it might seem like a dynamic programming problem, where I keep track of the number of tickets bought so far and the current price increase.

However, given the large constraints (n up to 3*10^5 per test case), a standard DP approach would be too slow.

I need a smarter way.

Observation:

The price increase is directly proportional to the number of tickets bought on previous days. So, the order in which I buy tickets matters.

I should prioritize buying tickets on days with the lowest a_i, but need to consider the impact on future days.

Another way to look at it: the total cost is the sum over all tickets of the price at the time they are bought.

Each ticket bought on day i will cost a_i plus the sum of x's from day 1 to day i-1.

So, if I buy x_i tickets on day i, the cost is x_i * (a_i + sum_{j=1}^{i-1} x_j)

I need to minimize the sum over i of x_i * (a_i + sum_{j=1}^{i-1} x_j), subject to sum x_i = k and x_i <= m for all i.

This seems complex. Maybe there's another way to approach this.

Let me think about the incremental cost.

If I buy one more ticket on day i, it increases the total cost by a_i plus the sum of x's from day 1 to day i-1, and also increases the price for all subsequent days by 1.

So, the marginal cost of buying one ticket on day i is a_i + sum_{j=1}^{i-1} x_j, and it increases the marginal cost for all future tickets by 1.

This seems tricky to optimize directly.

Alternative Approach:

Perhaps I can sort the days based on their base prices and decide how many tickets to buy on each day accordingly.

Wait, but the prices change based on previous purchases.

Another idea: since the price increase is uniform for all subsequent days, maybe I can model this as assigning tickets to days in a way that minimizes the total cost.

Let me consider that each ticket has a cost equal to the base price of the day it's bought plus the number of tickets bought on previous days.

So, if I have k tickets to buy, and I assign ticket t to day i, its cost will be a_i plus the number of tickets bought on days before i.

I need to assign each ticket to a day, respecting the constraint that no more than m tickets are bought per day, to minimize the total cost.

This sounds like assigning tickets to days with minimal cost, where the cost for a ticket on a day increases based on previous assignments.

This seems complicated, but maybe there's a greedy approach.

Greedy Idea:

What if I always buy tickets on the day with the current lowest price?

But the price changes based on previous purchases, so I need to keep track of the cumulative price increase.

Wait, perhaps I can sort the days by their base price a_i and prioritize buying as many tickets as possible on the days with the lowest a_i, considering the price increases.

But I have to respect the m tickets per day limit.

Let me try to formalize this.

Suppose I sort the days in increasing order of a_i.

I'll consider buying tickets on these days in this order.

But I need to account for the price increases due to previous purchases.

Wait, actually, since the price increase is equal to the total number of tickets bought on previous days, the effective price for a ticket on day i would be a_i plus the sum of x_j for j < i.

If I sort the days by a_i, and assign as many tickets as possible to the days with the lowest a_i first, considering the price increases.

But I'm not sure.

Let me think differently.

Suppose I fix the days on which I buy tickets, and then decide how many tickets to buy on each of those days, respecting the m limit per day, and the total k tickets.

I need to choose a subset of days and a number of tickets to buy on each chosen day, such that the sum of tickets is k, and no more than m per day, and the total cost is minimized.

This sounds like a minimization problem with constraints.

Another angle: since the price increases uniformly for all future days based on the number of tickets bought on previous days, maybe I can calculate the cost for buying a certain number of tickets on a certain day, considering its base price and the price increases.

Wait, perhaps I can calculate for each day the cost if I buy x tickets on that day, considering the price increase for future days.

But it's still complex.

Let me consider the following approach:

- Sort the days in increasing order of a_i.

- Try to buy as many tickets as possible on the days with the lowest a_i, respecting the m per day limit.

- However, since buying tickets on earlier days increases the price for later days, I need to balance between buying on low a_i days and not increasing the prices too much for higher a_i days.

This seems tricky.

Let me think about the example again.

First test case:

n=4, m=2, k=3

a = [8,6,4,2]

Sort days by a_i: day4=2, day3=4, day2=6, day1=8

Option 1: buy on day3 and day4.

- Buy 1 on day3 (a=4, no previous x, cost=4)

- Buy 2 on day4 (a=2 +1 from day3, so 3 per ticket, cost=6)

- Total=10

Option 2: buy on day4 only.

- Buy 2 on day4 (a=2, cost=4)

- Buy 1 on day3 (a=4 +2 from day4, so 6, cost=6)

- Total=10

Option 3: buy on day3 only.

- Buy 2 on day3 (a=4, cost=8)

- Buy 1 on day4 (a=2 +2 from day3, so 4, cost=4)

- Total=12

So, buying on both day3 and day4 is better.

Another option:

- Buy 1 on day3 (a=4, cost=4)

- Buy 2 on day4 (a=2 +1=3, cost=6)

- Total=10

Seems the same as option1.

Another test case:

n=4, m=2, k=8

a=[8,6,4,2]

Here, since k=8 and m=2, I have to buy 2 tickets each day for 4 days.

Total cost:

Day1: 2 tickets at 8 each → 16

Day2: 2 tickets at 6+2=8 each → 16

Day3: 2 tickets at 4+4=8 each → 16

Day4: 2 tickets at 2+6=8 each → 16

Total=64

This seems optimal, as buying on higher a_i days would increase the cost more.

Another test case:

n=5, m=100, k=1

a=[10000,1,100,10,1000]

Here, m=100, k=1

I can buy the single ticket on any day.

Choose the day with the lowest a_i, which is day2=1.

Cost=1

Indeed, the output is 1.

Last test case:

n=6, m=3, k=9

a=[5,5,5,5,5,5]

Here, all a_i are equal.

So, the price increase is solely based on the number of tickets bought previously.

I need to buy 9 tickets, up to 3 per day.

Option: buy 3 on day1, 3 on day2, 3 on day3.

Cost:

Day1: 3 tickets at 5 each → 15

Day2: 3 tickets at 5+3=8 each → 24

Day3: 3 tickets at 5+6=11 each → 33

Total=15+24+33=72

Another option: buy all 9 on day1 → not allowed, m=3

Or buy 3 on day1, 3 on day4, 3 on day5, etc., but since all a_i are equal, it won't change the total cost.

So, total cost is 72.

Seems optimal.

From these examples, it seems that buying tickets on days with the lowest a_i, while considering the price increases for future days, leads to the minimal cost.

But how to generalize this?

I need an algorithm that selects days to buy tickets in a way that minimizes the total cost, considering the price increases.

I recall that in some optimization problems, sorting and greedy approaches are used.

Perhaps I can sort the days by a_i and try to buy as many tickets as possible on the days with the lowest a_i, but considering the price increases due to previous purchases.

Wait, but if I buy tickets on a day with a low a_i, it will increase the prices for future days, which might negate the benefit of the low a_i.

So, I need to find a balance.

Let me think about the impact of buying x tickets on a day.

The cost for buying x tickets on day i is x * (a_i + sum of all x_j for j < i).

Additionally, this x will increase the price for all future days by x.

So, for all days j > i, the a_j increases by x.

This means that buying x tickets on day i affects the costs of all future days.

This seems like a dependency that makes the problem more complex.

Another way to look at it: the total cost can be expressed as the sum over all tickets of the base price of the day they are bought plus the sum of x_j for all days j before the day the ticket is bought.

Wait, perhaps I can model this as assigning each of the k tickets to a day, with constraints on the number of tickets per day, and minimizing the total cost where the cost of a ticket assigned to day i is a_i plus the number of tickets assigned to days before i.

But with k up to 1e9, this seems infeasible.

I need a better approach.

Let me consider the following:

Suppose I select q days to buy tickets, and on each selected day, I buy m tickets, except possibly on the last selected day where I buy the remaining tickets.

Since m can be up to 1e9 and n up to 3e5, I need an efficient way to calculate the total cost.

Wait, perhaps I can calculate how many days I need to buy tickets.

Given that I can buy up to m tickets per day, the number of days needed is ceil(k / m).

Let q = ceil(k / m)

Then, I need to choose q days to buy tickets, buying m tickets on each of the first q-1 days, and k - (q-1)*m tickets on the q-th day.

Now, I need to choose which q days to select, and the order in which to buy the tickets.

But choosing the days in a certain order affects the price increases.

I need to choose the q days such that the sum of the costs is minimized.

Wait, perhaps I should select the q days with the lowest a_i, and buy m tickets on each of the first q-1 days, and the remaining on the q-th day.

But I need to consider the price increases due to previous purchases.

Wait, maybe sorting the days in increasing order of a_i and selecting the first q days is the way to go.

Then, the sum of x_j for j < i would be m * (i-1) for i <= q-1, and m*(q-1) for i=q.

Wait, not sure.

Let me try to formalize this.

Suppose I select days d1, d2, ..., dq in order, with d1 < d2 < ... < dq.

Then, on day d1, I buy m tickets at cost m * (a_{d1} + 0), since no previous purchases.

Then, for day d2, I buy m tickets at cost m * (a_{d2} + m), since m tickets were bought on day d1.

Similarly, day d3: m * (a_{d3} + 2m), and so on.

Finally, day dq: (k - (q-1)*m) * (a_{dq} + (q-1)*m)

Total cost would be:

Sum over i=1 to q-1 of m * (a_{di} + (i-1)*m) + (k - (q-1)*m) * (a_{dq} + (q-1)*m)

Wait, no.

Wait, on day d1: m * (a_{d1} + 0)

On day d2: m * (a_{d2} + m)

On day d3: m * (a_{d3} + 2m)

...

On day dq: (k - (q-1)*m) * (a_{dq} + (q-1)*m)

So, total cost is:

Sum from i=1 to q-1 of m * (a_{di} + (i-1)*m) + (k - (q-1)*m) * (a_{dq} + (q-1)*m)

This seems manageable.

Now, if I sort the days in increasing order of a_i, and select the first q days, that might give me the minimal cost.

Wait, but need to confirm.

Let me sort the days by a_i in increasing order.

Let's say the sorted days are s1, s2, ..., sn, where a_{s1} <= a_{s2} <= ... <= a_{sn}

Then, select the first q days: s1, s2, ..., sq

Then, buy m tickets on s1, s2, ..., sq-1, and (k - (q-1)*m) tickets on sq.

Then, the total cost would be:

Sum from i=1 to q-1 of m * (a_{si} + (i-1)*m) + (k - (q-1)*m) * (a_{sq} + (q-1)*m)

This seems like a formula I can compute.

But is this the minimal possible cost?

Let me check with the first test case.

First test case:

n=4, m=2, k=3

a=[8,6,4,2]

Sort a: [2,4,6,8], so s1=4, s2=3, s3=2, s4=1

q = ceil(3/2) = 2

So, buy 2 tickets on day4 (a=2), and 1 ticket on day3 (a=4)

Total cost: 2*(2 + 0) + 1*(4 + 2) = 4 + 6 = 10, which matches the sample output.

Another test case:

n=4, m=2, k=8

a=[8,6,4,2]

Sort a: [2,4,6,8], s1=4, s2=3, s3=2, s4=1

q = ceil(8/2)=4

Buy 2 on day4 (2+0=2), 2 on day3 (4+2=6), 2 on day2 (6+4=10), 2 on day1 (8+6=14)

Total cost: 2*2 + 2*6 + 2*10 + 2*14 = 4 + 12 + 20 + 28 = 64, which matches the sample.

Another test case:

n=5, m=100, k=1

a=[10000,1,100,10,1000]

Sort a: [1,10,100,1000,10000], s1=2, s2=4, s3=3, s4=5, s5=1

q=ceil(1/100)=1

Buy 1 ticket on day2 (a=1 + 0 =1), total cost=1, which matches the sample.

Last test case:

n=6, m=3, k=9

a=[5,5,5,5,5,5]

Sort a: [5,5,5,5,5,5], s1=1, s2=2, s3=3, s4=4, s5=5, s6=6

q=ceil(9/3)=3

Buy 3 on day1 (5+0=5), 3 on day2 (5+3=8), 3 on day3 (5+6=11)

Total cost: 3*5 + 3*8 + 3*11 = 15 + 24 + 33 = 72, matches the sample.

So, this approach seems correct.

Hence, the algorithm is:

- Sort the days in increasing order of a_i.

- Compute q = ceil(k / m)

- Select the first q days from the sorted list.

- Buy m tickets on each of the first q-1 days.

- Buy (k - (q-1)*m) tickets on the q-th day.

- Compute the total cost using the formula:

Sum from i=1 to q-1 of m * (a_{si} + (i-1)*m) + (k - (q-1)*m) * (a_{sq} + (q-1)*m)

This seems efficient, as sorting n days takes O(n log n), and per test case, we have up to 3e5 days, with t up to 1e4, but sum of n over all test cases is up to 3e5, so total time should be acceptable.

Now, let's look at the given program and see if it implements this logic correctly.

Given Program:

def func():

t = int(input())

for _ in range(t):

L = list(map(int, input().split()))

M = list(map(int, input().split()))

(n, m, k) = (L[0], L[1], L[2])

m = min(m, k)

M.sort()

q = int(math.ceil(k / m))

N = M[:q]

n = len(N)

if n * m == k:

cost = m * sum(N) + m * m * ((n - 1) * n // 2)

else:

w = N.pop()

mu = k - (n - 1) * m

cost = mu * w

n = len(N)

cost += m * sum(N) + m * m * ((n - 1) * n // 2) + n * m * mu

print(cost)

continue

Explanation:

- Read t, the number of test cases.

- For each test case:

- Read n, m, k.

- Read the array a of n integers.

- Set m to be the minimum of m and k.

- Sort the array a in ascending order.

- Compute q as ceil(k / m).

- Select the first q days with the lowest a_i.

- If n * m == k, meaning exactly q-1 days are filled with m tickets, and the last day with m tickets as well.

- Compute cost as m * sum(N) + m * m * ((n - 1) * n // 2)

- Else, compute mu = k - (n - 1) * m, which is the number of tickets to buy on the last day.

- Remove the last day's a_i (w = N.pop())

- Compute cost as mu * w + m * sum(N) + m * m * ((n - 1) * n // 2) + n * m * mu

- Print the cost.

Let's verify if this matches the earlier derived formula.

From earlier:

Total cost is:

Sum from i=1 to q-1 of m * (a_{si} + (i-1)*m) + (k - (q-1)*m) * (a_{sq} + (q-1)*m)

Let's break this down:

First part: sum from i=1 to q-1 of m * (a_{si} + (i-1)*m)

This can be written as m * sum(a_{si} for i=1 to q-1) + m * m * sum(i-1 for i=1 to q-1)

sum(i-1 for i=1 to q-1) is sum from 0 to q-2, which is (q-1)*(q-2)/2

So, first part: m * sum(a_{si} for i=1 to q-1) + m * m * (q-1)*(q-2)/2

Second part: (k - (q-1)*m) * (a_{sq} + (q-1)*m)

Now, in the code:

N = M[:q], which are the q lowest a_i's.

If n * m == k, which is q * m == k since n=q, then:

cost = m * sum(N) + m * m * ((n - 1) * n // 2)

But n = q, so this is m * sum(N) + m * m * (q -1)*(q -2)/2

Wait, but sum(N) includes a_{sq}, which should not be included in the sum for the first part.

Wait, perhaps I need to adjust the indices.

Wait, perhaps N = M[:q], and then sum(N) is sum of a_{s1} to a_{sq}.

But in the formula, the first part is sum from i=1 to q-1 of m * (a_{si} + (i-1)*m), and the second part is (k - (q-1)*m) * (a_{sq} + (q-1)*m)

So, in the code, when n * m == k, it's buying m tickets on each of the q days.

But according to the earlier logic, we should buy m tickets on the first q-1 days and the remaining on the q-th day.

Wait, but in this case, if q * m == k, then it's buying m tickets on each of the q days.

Wait, perhaps the code is considering q days, buying m on each of the first q-1 days, and m on the q-th day.

But according to the earlier logic, it should buy m on the first q-1 days and k - (q-1)*m on the q-th day.

So, in the case where q * m == k, buying m on each of the q days is fine.

Now, in the code, when n * m == k, it sets cost = m * sum(N) + m * m * ((n -1)*n//2)

But according to the formula, it should be m * sum(a_{s1} to a_{sq-1}) + m * (a_{sq} + (q-1)*m)

Wait, perhaps I'm misinterpreting.

Wait, in the code, when n * m == k, it's summing over all q days, but according to the formula, it should be summing m * (a_{si} + (i-1)*m) for i=1 to q.

Wait, perhaps I need to reconcile the formulas.

Let's re-express the total cost when q * m == k:

Total cost = sum from i=1 to q of m * (a_{si} + (i-1)*m)

This is m * sum(a_{si} for i=1 to q) + m * m * sum(i-1 for i=1 to q)

sum(i-1 for i=1 to q) = sum from 0 to q-1 = q*(q-1)/2

So, total cost = m * sum(a_{si} for i=1 to q) + m * m * q*(q-1)/2

In the code, it's m * sum(N) + m * m * (n -1)*n//2, where n=q.

So, this matches.

Now, in the else case, when k - (q-1)*m < m, it pops w = N.pop(), which is a_{sq}.

Then, mu = k - (n-1)*m

cost = mu * w + m * sum(N) + m * m * ((n-1)*(n-2)//2) + n * m * mu

Wait, in the formula, it should be:

sum from i=1 to q-1 of m * (a_{si} + (i-1)*m) + mu * (a_{sq} + (q-1)*m)

Which is m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)/2 + mu * (a_{sq} + (q-1)*m)

In the code, it's:

mu * w + m * sum(N) + m * m * ((n-1)*(n-2)//2) + n * m * mu

But N is M[:q], and w is N.pop(), which is a_{sq}.

Then, sum(N) is sum(a_{s1} to a_{sq-1}).

So, m * sum(N) is m * sum(a_{s1} to a_{sq-1})

m * m * ((n-1)*(n-2)//2) is m * m * (q-1)*(q-2)//2

n * m * mu is q * m * mu

But in the formula, it should be mu * (a_{sq} + (q-1)*m)

So, mu * a_{sq} + mu * (q-1)*m

In the code, it's mu * w + m * sum(N) + m * m * ((n-1)*(n-2)//2) + n * m * mu

Which is mu * a_{sq} + m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + q * m * mu

Wait, but according to the formula, it should be:

m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + mu * (a_{sq} + (q-1)*m)

Which is m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + mu * a_{sq} + mu * (q-1)*m

But in the code, it's mu * a_{sq} + m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + q * m * mu

Wait, q * m * mu is extra compared to the formula.

Wait, perhaps there's a mistake in the code.

Wait, in the else part, it's:

cost = mu * w + m * sum(N) + m * m * ((n-1)*(n-2)//2) + n * m * mu

But according to the formula, it should be:

cost = m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + mu * (a_{sq} + (q-1)*m)

Which is m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + mu * a_{sq} + mu * (q-1)*m

But in the code, it's mu * a_{sq} + m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)//2 + q * m * mu

Which includes an extra q * m * mu compared to the formula.

This suggests that the code is incorrect.

Wait, perhaps there's a reason for adding q * m * mu.

Wait, maybe the term q * m * mu accounts for the price increases on the last day.

Wait, no, I think the code is incorrect.

Let me check with the first test case.

First test case:

n=4, m=2, k=3

a=[8,6,4,2]

sorted a: [2,4,6,8]

q=ceil(3/2)=2

N = [2,4]

mu = 3 - (2-1)*2 = 3 - 2 =1

w = N.pop() =4

cost = 1*4 + 2*(2) + 2*2*(1*0/2) + 2*2*1 = 4 + 4 + 0 + 4 = 12

But according to the correct cost, it should be 10.

So, the code gives 12, but the correct answer is 10.

Hence, the code is incorrect.

Wait, perhaps I miscalculated.

Wait, m = min(m,k) =2

q=ceil(3/2)=2

N=[2,4]

mu=3-1*2=1

w=4

cost=1*4 +2*(2) +2*2*(1*0/2)+2*2*1=4+4+0+4=12

But according to the correct calculation, it should be 10.

Hence, the code is incorrect.

Alternative Approach:

I need to fix the code.

Let me implement the correct formula.

Total cost should be:

sum from i=1 to q-1 of m * (a_{si} + (i-1)*m) + mu * (a_{sq} + (q-1)*m)

Where mu = k - (q-1)*m

In the code, it should be:

sum_from_i1_to_q1 = m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)/2

sum_from_iq = mu * (a_{sq} + (q-1)*m)

Total cost = sum_from_i1_to_q1 + sum_from_iq

In the code, it's doing sum_from_i1_to_q1 = m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)/2

And sum_from_iq = mu * a_{sq} + q * m * mu

Wait, why q * m * mu?

Wait, it should be mu * (a_{sq} + (q-1)*m)

But in the code, it's mu * a_{sq} + q * m * mu

Which is mu * a_{sq} + q * m * mu = mu * (a_{sq} + q * m)

But according to the formula, it should be mu * (a_{sq} + (q-1)*m)

So, the code is adding an extra m * mu.

Hence, the code is incorrect.

Correct cost should be:

sum_from_i1_to_q1 + mu * (a_{sq} + (q-1)*m)

Which is m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)/2 + mu * (a_{sq} + (q-1)*m)

In the code, it's m * sum(a_{s1} to a_{sq-1}) + m * m * (q-1)*(q-2)/2 + mu * a_{sq} + q * m * mu

Which is extra m * mu compared to the correct formula.

Hence, the code is incorrect.

Correctness: **False**