Alright, I have this problem to solve. It's about determining who wins a game between Bodya and Sasha based on their scores after a certain number of turns. They are both moving around a permutation and collecting scores based on the positions they choose to stay or move to. The game lasts for k turns, and both make decisions simultaneously.

First, I need to understand the problem completely. We have a permutation p of length n, and an array a of the same length. Both players start at specific positions, P_B for Bodya and P_S for Sasha. In each turn, each player can choose to stay at their current position or move to the position indicated by the permutation p. Each time they are at a position x, they add a_x to their score.

The goal is to see who has a higher score after exactly k turns. If they have the same score, it's a draw.

Given that n can be up to 2*10^5 and k up to 10^9, and there are up to 10^4 test cases, efficiency is crucial. So, I need an approach that can handle large inputs quickly.

Let's think about how the players can maximize their scores. Since they can choose to stay or move each turn, they need to decide whether staying put or moving to p_x gives them a better score in the long run.

But wait, they are trying to win, so they will choose the option that maximizes their own score. However, since they make decisions simultaneously, their choices don't affect each other directly; they just follow their own strategies.

I need to model the decision process for each player independently and then compare their final scores.

Let's consider one player's perspective. The player starts at position s. Each turn, they can choose to stay at the current position and add a_s to their score, or move to p_s and add a_{p_s} to their score in the next turn.

This sounds like a dynamic decision process, possibly modeled with dynamic programming or some kind of graph traversal.

But with k up to 10^9, traditional DP approaches won't suffice because they would be too slow. I need a smarter way to calculate the maximum possible score for each player.

Looking at the permutation p, I recall that permutations can be decomposed into cycles. Maybe I can exploit the cycle structure of p to find a pattern in the movement.

If I can find the cycles in p, I can determine how the positions are connected and how the players can traverse these cycles to maximize their scores.

Let's consider that starting from any position, repeatedly applying p will eventually lead back to the starting position because p is a permutation (a bijection).

So, each position belongs to exactly one cycle. If a player is on a cycle of length m, after m turns, they return to the starting position.

But k can be up to 10^9, which is much larger than n, which is up to 2*10^5. So, I need a way to handle large k efficiently.

Wait, perhaps I can precompute the cycle structure and then for each cycle, determine the optimal way to stay or move within that cycle.

But I'm not sure yet. Let's think differently.

Suppose a player is at position x. They have two choices:

1. Stay at x and add a_x to their score.

2. Move to p_x and add a_{p_x} to their score in the next turn.

This seems similar to choosing between immediate reward (a_x) and a potential future reward (a_{p_x}).

This resembles a decision tree, but with k up to 10^9, it's impractical to traverse the tree directly.

Maybe I can model this as a graph where each node is a position, and there is an edge from x to p_x. Since p is a permutation, this graph consists of disjoint cycles.

In each cycle, the optimal strategy would be to choose to stay at the position with the highest a_x in the cycle, and move otherwise.

Wait, but it's not that simple because choosing to stay affects the subsequent choices.

Let me think about it differently. For each player, I need to maximize the sum of a_x over k turns, where at each turn, they can choose to stay or move to p_x.

This sounds like a Markov Decision Process (MDP), where each state is a position, and actions are "stay" or "move".

But again, with large n and k, I need a more efficient approach.

Perhaps I can find a mathematical formula or pattern that allows me to compute the maximum score efficiently.

Let's consider that if a player chooses to stay at position x for all k turns, their total score would be k * a_x.

If they choose to move to p_x and stay there for the remaining k-1 turns, their total score would be a_{p_x} + (k-1)*a_{p_x} = k * a_{p_x}.

They can also choose a combination of staying and moving.

But since they make decisions simultaneously in each turn, perhaps the optimal strategy is to always stay at the position with the maximum a_x in their cycle.

Wait, but they can choose to move to p_x and then decide again.

I need to find, for each player, the maximum possible sum they can achieve in k steps, where each step allows them to stay or move to p_x.

This seems like a problem that can be modeled using dynamic programming, but with k up to 10^9, I need a smarter approach.

Let me consider the possible behaviors:

1. If a player stays at position x for all k turns, their score is k * a_x.

2. If they move to p_x and stay there for the remaining k-1 turns, their score is a_{p_x} + (k-1)*a_{p_x} = k * a_{p_x}.

3. They can alternate between staying and moving in some pattern to maximize their score.

But perhaps the best strategy is to find the position in their cycle with the maximum a_x and stay there for as many turns as possible.

But since they can choose to stay or move each turn, they can potentially "skip" some turns to reach a better position.

Wait, but if they move to p_x, they are committed to that position for the next turn.

I think I need to model this more carefully.

Let me consider that the player can choose to stay at the current position and collect a_x, or move to p_x and collect a_{p_x} in the next turn.

This sounds like a recursive decision process.

Let's define dp[x][t] as the maximum score a player can achieve starting at position x with t turns left.

Then, dp[x][t] = max(a_x + dp[x][t-1], a_{p_x} + dp[p_x][t-1])

But with n up to 2*10^5 and k up to 10^9, this is not feasible to compute directly.

I need a better way.

Let's consider that for a given position x, if a_x >= a_{p_x}, then it's better to stay at x.

Otherwise, it's better to move to p_x.

Wait, but this might not always be true because of the chain of positions.

Wait, perhaps I can find for each position x, the maximum a_y among the positions reachable from x without moving back.

But this seems complicated.

Let me think about the cycles again.

Since p is a permutation, it decomposes into disjoint cycles.

Each player is confined to their respective cycle.

So, for each player, I can find the cycle they are in and then determine the optimal way to stay or move within that cycle.

Given that, perhaps I can represent each cycle and compute the maximum possible score within that cycle for k turns.

But I still need to handle k up to 10^9 efficiently.

Let me consider a single cycle.

Suppose we have a cycle: x -> p_x -> p_{p_x} -> ... -> x

Let’s say the cycle has length m.

Then, the positions in the cycle are x, p_x, p_{p_x}, ..., and after m steps, it repeats.

Now, the player can choose to stay at any position in the cycle for any number of turns.

So, in k turns, the player can choose to stay at certain positions and move to others.

This seems complex to model directly.

Perhaps I can think of it as choosing a sequence of positions to stay at, with the constraint that moving to p_x requires using one turn to reach p_x.

Wait, maybe I can model it as a linear path where each step is either staying or moving.

But again, with k up to 10^9, I need a smarter approach.

Let me consider that the optimal strategy is to find the position in the cycle with the maximum a_x and stay there for as many turns as possible.

But since k is very large, and the cycle length m might be small, I need to see how the choices repeat.

Wait, perhaps I can compute the maximum possible score by finding the maximum a_x in the cycle and multiplying it by k.

But that would only be correct if the player can stay at that position for all k turns.

However, if the maximum a_x is at a certain position, the player needs to reach that position first before staying there.

But if the cycle length is m, and k is much larger than m, perhaps I can compute the score by considering the path to the maximum a_x and then staying there.

Wait, perhaps I can find, for each cycle, the maximum a_x and the minimal number of steps required to reach that position from the starting position.

Then, for k greater than or equal to that minimal number of steps, the player can stay at the maximum a_x for the remaining turns.

This seems promising.

Let me formalize this.

For a given cycle, find the position x in the cycle with the maximum a_x.

Let’s say the minimal number of steps from the starting position s to x is d.

Then, for k >= d, the player can reach x in d steps and stay there for the remaining k - d steps, accumulating (k - d) * a_x + sum of a_{s_i} for the first d steps.

Wait, but the player can choose to stay or move at each step, so it's not just a path from s to x.

This is getting complicated.

Let me try to think differently.

Suppose I iterate through the positions that the player can be at, keeping track of the maximum possible score at each step.

But with k up to 10^9, I need a way to compute this efficiently.

Wait, perhaps I can represent the process as a graph and find the maximum score using some graph algorithm.

But I'm not sure.

Let me consider that in each turn, the player has two choices: stay or move.

So, from position x, they can choose to stay and add a_x to their score, or move to p_x and add a_{p_x} to their score in the next turn.

This sounds like a decision tree where each node has two branches: stay or move.

But with k up to 10^9, traversing this tree is impossible.

I need a mathematical insight here.

Let me consider that the maximum score is achieved by staying at the position with the maximum a_x for as many turns as possible.

To do that, the player needs to reach that position first.

So, for each player, I can find the position in their cycle with the maximum a_x and calculate the minimal number of steps to reach it from their starting position.

Then, if k is greater than or equal to that minimal number of steps, the player can stay at that position for k - d turns, where d is the number of steps to reach it.

The total score would be the sum of a_x for each step along the path plus (k - d) * a_max, where a_max is the maximum a_x in the cycle.

Wait, but the player can choose to stay at any position at any time, so this might not capture all possibilities.

This is getting too convoluted.

Let me look at smaller examples to see if I can find a pattern.

Take the first example from the problem:

n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3] which is [3,0,1,2] 0-indexed

a = [7,2,5,6]

Wait, no, in the first example, n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3] which is [3,0,1,2] 0-indexed

a = [7,2,5,6]

Wait, but in the explanation, Bodya starts at 3, stays there, gets 5, then stays again and gets another 5, total 10.

Sasha starts at 2, moves to p_2=1, gets 2, then stays at 1 and gets 7, total 9.

So Bodya wins.

In this case, it seems that Bodya chose to stay at position 3, which has a_3=5, and Sasha chose to move to position 1 and then stay there.

Wait, but Sasha could have chosen to stay at position 2 both turns, getting 5 + 5 = 10, which is more than 9.

Wait, but in the explanation, Sasha moved to position 1 and stayed there, getting 2 + 7 = 9.

But if Sasha stays at position 2 for both turns, getting a_2 + a_2 = 5 + 5 = 10, which is better.

But according to the output, Bodya has 10 and Sasha has 9, so Bodya wins.

But if Sasha chooses to stay at position 2 for both turns, getting 10, then it would be a draw.

But in the explanation, it seems Sasha chose to move to position 1 and stay there, getting 9.

So perhaps the players don't necessarily choose the optimal path.

Wait, no, the problem says both players are trying to win.

So, they will choose the strategy that maximizes their own score.

So, in this case, Sasha should choose to stay at position 2 for both turns to get 10, which is better than 9.

But in the explanation, it shows Sasha moving to position 1 and staying there, getting 9.

This suggests that perhaps there are constraints on how they can move.

Wait, no, the problem says they can choose to stay or move to p_x each turn.

So, Sasha could choose to stay at position 2 for both turns, getting a_2 + a_2 = 5 + 5 = 10.

Or, move to position 1 and stay there, getting a_1 + a_1 = 7 + 7 = 14.

Wait, but in the explanation, it shows Sasha moving to position 1 and staying there, getting a_1 + a_1 = 7 + 2 = 9.

Wait, that doesn't make sense.

Wait, in the first turn, Sasha moves from position 2 to position 1 (p_2=1), and gets a_1=7.

Wait, no, in the explanation, it says Sasha moves to p_2=1 and gets a_2=2 in the first turn, then stays at position 1 and gets a_1=7 in the second turn.

Wait, that seems inconsistent.

Wait, perhaps there is a mistake in the explanation.

Let me read the problem again.

"two things happen to each player:

- If the current position of the player is x , his score increases by a_x .

- Then the player either stays at his current position x or moves from x to p_x ."

So, in each turn:

1. The player's score increases by a_x, where x is the current position.

2. Then, the player chooses to stay at x or move to p_x.

So, in the first turn:

- Bodya is at position 3, scores a_3=5, then chooses to stay at position 3.

- Sasha is at position 2, scores a_2=5, then chooses to move to p_2=1.

In the second turn:

- Bodya is still at position 3, scores another a_3=5, stays at position 3.

- Sasha is now at position 1, scores a_1=7, stays at position 1.

Total scores:

- Bodya: 5 + 5 = 10

- Sasha: 5 + 7 = 12

But according to the explanation, Sasha has 9, which contradicts this.

Wait, perhaps there is a misunderstanding in the problem statement.

Let me read it again carefully.

"The game lasts k turns. The players make moves simultaneously. On each turn, two things happen to each player:

- If the current position of the player is x , his score increases by a_x .

- Then the player either stays at his current position x or moves to p_x ."

So, in each turn:

1. Both players look at their current position x and add a_x to their score.

2. Then, simultaneously, both players decide to stay at x or move to p_x.

Given that, in the first turn:

- Bodya is at position 3, scores a_3=5, then chooses to stay at position 3.

- Sasha is at position 2, scores a_2=5, then chooses to move to p_2=1.

In the second turn:

- Bodya is still at position 3, scores a_3=5, stays at position 3.

- Sasha is now at position 1, scores a_1=7, stays at position 1.

Total scores:

- Bodya: 5 + 5 = 10

- Sasha: 5 + 7 = 12

But according to the explanation, Sasha has 9, which doesn't match.

Wait, perhaps there is a misinterpretation of the positions.

In the problem, p is a permutation, and positions are 1 to n.

In the first turn:

- Bodya is at position 3, scores a_3=5, chooses to stay at position 3.

- Sasha is at position 2, scores a_2=2, chooses to move to p_2=1.

In the second turn:

- Bodya is at position 3, scores a_3=5, stays at position 3.

- Sasha is at position 1, scores a_1=7, stays at position 1.

Total scores:

- Bodya: 5 + 5 = 10

- Sasha: 2 + 7 = 9

This matches the explanation.

So, in the first turn, Sasha scores a_2=2, not a_1=7, because the scoring happens before the move.

Hence, Sasha scores a_2=2, then moves to p_2=1.

In the second turn, Sasha is at position 1, scores a_1=7, stays at position 1.

Hence, total score for Sasha is 2 + 7 = 9.

If Sasha chooses to stay at position 2 for both turns, he would score a_2 + a_2 = 2 + 2 = 4, which is worse than 9.

Hence, moving to position 1 and staying there is better for Sasha.

Therefore, in this case, Bodya can get 10, and Sasha can get 9, so Bodya wins.

But according to the note, it says "Bodya always can win this game", but in this case, Bodya can get 10, and Sasha can get 9, so Bodya wins.

But in another scenario, if Sasha chooses to stay at position 2 for both turns, getting 4, Bodya still has 10, so Bodya still wins.

Hence, Bodya can always win this game.

But how to generalize this for any n, k, p, and a?

I need to find a way to compute the maximum possible score for each player given their starting positions and the rules.

Given the constraints, I need an efficient algorithm.

Let me consider that for each player, their movement is determined by the permutation p.

Since p is a permutation, it forms cycles.

Each player is confined to their own cycle.

Hence, I can consider each cycle separately.

Within a cycle, the player can choose to stay or move at each turn.

I need to maximize the sum of a_x over k turns.

Let me consider that in each turn, the player can choose to stay and collect a_x, or move to p_x and collect a_{p_x} in the next turn.

This sounds like a Markov Decision Process, but with large k, I need a smarter approach.

Let me consider that the optimal strategy is to find the position in the cycle with the maximum a_x and stay there for as many turns as possible.

To do that, the player needs to reach that position in the minimal number of steps and then stay there.

Hence, the maximum score would be:

- Sum of a_x for each step to reach the position with maximum a_x.

- Plus (k - d) * a_max, where d is the number of steps to reach the position with maximum a_x.

But I need to consider that the player can choose to stay at any position at any time.

Wait, perhaps I can compute for each position in the cycle the maximum a_x that can be achieved starting from that position with k turns.

But this seems too vague.

Let me consider that for each cycle, I can find the position with the maximum a_x and compute the minimal distance from the starting position to that position.

Then, the maximum score would be (k - d) * a_max + sum of a_x along the path to a_max.

But I'm not sure.

Let me try to think recursively.

Define dp[x][t] as the maximum score starting at position x with t turns left.

Then,

dp[x][t] = max(a_x + dp[x][t-1], a_{p_x} + dp[p_x][t-1])

But with k up to 10^9, this is not feasible.

I need to find a way to compute dp[x][k] efficiently.

Let me consider that for large k, the player will eventually reach a position where a_x is maximum in the cycle and stay there forever.

Hence, for large k, the score will be (k - d) * a_max + sum of a_x along the path to a_max.

But I need to handle the case where k is less than d.

Wait, perhaps I can compute for each position in the cycle the maximum a_x and the minimal distance to it.

Then, for each player, compute the maximum score based on k and d.

But I need a better structure.

Let me consider that in each cycle, the player can choose to loop through the cycle in a certain way to maximize their score.

But this is getting too complicated.

Let me look for a mathematical pattern.

Suppose a player is in a cycle of length m.

They can choose to stay at any position in the cycle for any number of turns.

Hence, in k turns, they can choose to stay at positions that maximize their sum.

But again, with large k, I need a way to compute this efficiently.

Wait, perhaps I can consider that the player can choose to stay at the position with the maximum a_x for as many turns as possible, only moving when necessary to reach that position.

Hence, the maximum score would be (k - d) * a_max + sum of a_x along the path to a_max.

But I need to find d, the minimal number of steps to reach a_max from the starting position.

In other words, d is the distance from the starting position to the position with a_max in the cycle.

Once the player reaches a_max, they can stay there for the remaining turns.

Hence, the total score would be (k - d) * a_max + sum of a_x for the first d steps.

But I need to make sure that d is minimized.

Wait, but in a cycle, there might be multiple positions with a_max.

I need to consider all positions with a_max and find the minimal d for each.

Wait, perhaps I can find the position with the maximum a_x in the cycle and compute the minimal distance from the starting position to that position.

Then, the maximum score is (k - d) * a_max + sum of a_x along the path of length d.

But I need to make sure that this path is the one that maximizes the sum of a_x.

Wait, perhaps not.

Let me consider that in each turn, the player can choose to stay or move.

Hence, they can choose to loop through the cycle in any way.

This seems too flexible.

Let me consider that for a cycle, the player can choose to loop through the cycle in a way that maximizes the sum of a_x over k turns.

But again, with large k, I need a way to compute this efficiently.

Wait, perhaps I can model this as a linear recurrence.

Define dp[t] as the maximum score at time t.

Then, dp[t] = max(a_x + dp[t-1], a_{p_x} + dp[t-1]), but this seems redundant.

Wait, perhaps I can think in terms of the greatest possible score per turn.

Find the maximum a_x in the cycle and see how quickly the player can reach it.

Then, for k greater than or equal to the distance to a_max, the player can achieve (k - d) * a_max + sum of a_x along the path.

But I need to handle the case where there are multiple a_max in the cycle.

Wait, perhaps I can find all positions with a_x equal to a_max and find the minimal distance from the starting position to any of these positions.

Then, the maximum score is (k - d) * a_max + sum of a_x along the path of length d to a_max.

But I need to make sure that the sum of a_x along the path is maximized.

Wait, perhaps I can compute d as the minimal distance to any a_max position, and then compute the sum of a_x along that minimal path.

But in a cycle, there might be multiple paths to a_max.

I need to choose the path that minimizes d and maximizes the sum of a_x.

Hence, for each a_max position, find the distance from the starting position and the sum of a_x along that path.

Then, choose the path that minimizes d and maximizes the sum.

Hence, for each a_max position, compute the minimal distance d and the sum of a_x along that path.

Then, the maximum score is (k - d) * a_max + sum.

Then, among all a_max positions, choose the one that maximizes this expression.

This seems correct.

Hence, for each player, I can:

1. Find all positions in their cycle with a_x equal to a_max.

2. For each such position, compute the minimal distance d from the starting position to it.

3. Compute sum_d, the sum of a_x along the path of length d to that position.

4. Then, the maximum score is (k - d) * a_max + sum_d.

5. Choose the a_max position that maximizes this score.

Then, compare the maximum scores of Bodya and Sasha to determine the winner.

But with n up to 2*10^5 and k up to 10^9, I need an efficient way to compute this.

First, I need to find the cycle for each player.

Then, within each cycle, find the positions with a_x equal to a_max.

Then, for each such position, compute the minimal distance d from the starting position.

Then, compute sum_d, the sum of a_x along that path.

Then, compute (k - d) * a_max + sum_d.

Finally, choose the maximum among these.

But with n up to 2*10^5 and t up to 10^4, I need this to be efficient.

Hence, I need to optimize the cycle detection and the computations within each cycle.

Let me think about how to implement this.

First, for cycle detection in a permutation.

I can start from the starting position and follow p[x] until I return to the starting position.

During this process, I can record the path, which is the cycle.

Then, within the cycle, I can find the position with the maximum a_x.

Then, for each player, find the minimal distance to that position and compute the sum along that path.

But wait, there might be multiple positions with a_x equal to a_max.

Hence, I need to consider all such positions and choose the one that minimizes d and maximizes sum_d.

Wait, perhaps I can iterate through the cycle and for each position, keep track of the sum so far and the distance from the starting position.

Then, when I reach a position with a_x equal to a_max, I can compute (k - d) * a_max + sum_d and keep the maximum among these.

But I need to consider that the cycle repeats every m steps, where m is the cycle length.

Hence, for large k, the player can loop through the cycle multiple times before reaching a_max.

This complicates things.

Wait, perhaps I can model the cycle as a circular list and iterate through it to find the minimal d and corresponding sum_d.

But with k up to 10^9, I need a way to handle this efficiently.

Let me consider that in a cycle, the player can choose to move forward or stay.

But since p is a permutation, moving is deterministic.

Wait, no, the player can choose to stay or move to p_x each turn.

Hence, it's like a graph where each node has two outgoing edges: one to itself (stay) and one to p_x (move).

But with large n and k, this is not practical.

Let me consider that for each cycle, I can represent it as a list of positions in order.

Then, for each player, starting from their starting position, I can iterate through the cycle, keeping track of the sum and distance to positions with a_x equal to a_max.

Then, for each such position, compute (k - d) * a_max + sum_d.

Then, choose the maximum among these.

But with k up to 10^9, I need to handle large k efficiently.

Wait, perhaps I can find that for each cycle, once the player reaches a position with a_x equal to a_max, they can stay there forever, accumulating a_max per turn.

Hence, the maximum score would be (k - d) * a_max + sum of a_x along the path of length d to a_max.

Then, among all possible a_max positions, choose the one with the smallest d and largest sum_d.

Hence, for each a_max position, compute d and sum_d, then choose the one that maximizes (k - d) * a_max + sum_d.

This seems correct.

Hence, for each player, I can:

- Find their cycle.

- Find all positions in the cycle with a_x equal to a_max.

- For each such position, compute d and sum_d.

- Choose the maximum (k - d) * a_max + sum_d.

Then, compare the results for Bodya and Sasha to determine the winner.

Now, I need to implement this efficiently.

Given that n can be up to 2*10^5 and t up to 10^4, I need to optimize the cycle detection and computations.

First, for cycle detection, I can iterate through the permutation starting from the starting position until I return to the starting position, recording the path.

Then, within the cycle, I can find the position with the maximum a_x.

Then, for each player, find the minimal distance d to that position and compute sum_d.

But wait, there might be multiple positions with a_x equal to a_max.

Hence, I need to consider all such positions and choose the one that minimizes d and maximizes sum_d.

Wait, perhaps I can iterate through the cycle and keep track of the cumulative sum and distance.

Then, whenever I reach a position with a_x equal to a_max, compute (k - d) * a_max + sum_d.

Then, choose the maximum among these.

This seems feasible.

Hence, for each cycle, I can represent it as a list of positions in order.

Then, for each player, starting from their starting position, iterate through the cycle, keeping track of the cumulative sum and distance.

Whenever I reach a position with a_x equal to a_max, compute (k - d) * a_max + sum_d.

Then, choose the maximum among these.

But I need to handle the case where k is larger than the cycle length.

Hence, I need to consider that the player can loop through the cycle multiple times before reaching a_max.

But I think that by choosing to reach a_max in the minimal number of steps and then staying there, I can achieve the maximum score.

Hence, I don't need to consider looping through the cycle multiple times; I just need to reach a_max as quickly as possible and stay there.

Hence, for each player, find the minimal d to any a_max position and compute (k - d) * a_max + sum_d.

Then, choose the maximum among these.

Wait, but sum_d is the sum of a_x along the path of length d to a_max.

Hence, I need to compute sum_d for the path from the starting position to a_max.

Hence, for each a_max position, find the minimal d and corresponding sum_d.

Then, compute (k - d) * a_max + sum_d.

Then, choose the maximum among these.

This seems manageable.

Hence, for each cycle, I can precompute for all a_max positions the minimal d and sum_d from the starting position.

Then, for each player, compute the maximum (k - d) * a_max + sum_d among all a_max positions.

Then, compare the results for Bodya and Sasha.

But with t up to 10^4 and n up to 2*10^5, I need to optimize this.

Wait, but t is up to 10^4, and n is up to 2*10^5 per test case.

Wait, no, t is the number of test cases, and each test case has its own n and k.

But the problem says "the sum of values of n over all test cases does not exceed 2*10^5".

Hence, I need to process all test cases efficiently in total time.

Hence, I need to process all test cases in O(N), where N is the sum of n over all test cases, which is up to 2*10^5.

Hence, I need an O(N) total time solution.

Given that, I need to find a way to compute the maximum score for each player in O(N) total time.

Let me think about how to achieve this.

First, for each test case, I need to:

1. Read n, k, P_B, P_S.

2. Read the permutation p.

3. Read the array a.

Then, for each player, find their cycle and compute the maximum possible score.

But with t up to 10^4 and n up to 2*10^5 in total, I need to process each test case in O(n) time.

Hence, for each test case, I need an O(n) time solution.

Given that, I need to find a way to compute the maximum score for each player in O(n) time per test case.

Given that, perhaps I can find for each position x, the maximum score achievable from x with k turns.

Then, for Bodya and Sasha, I can just look up their starting positions.

But with k up to 10^9, I need a way to compute this efficiently.

Wait, perhaps I can iterate through the permutation, following the path for each player, and compute the maximum score along the way.

But I need to handle the cycles properly.

Let me consider that for each position x, I can iterate through the permutation, following p_x, until I see a position I've seen before, which indicates a cycle.

Then, once I have the cycle, I can compute the maximum score for that cycle.

But with t up to 10^4 and n up to 2*10^5 in total, I need to optimize this.

Wait, perhaps I can compute for each cycle the maximum a_x and the minimal d for each position to reach a_max.

Then, for each player, compute (k - d) * a_max + sum_d.

But I need to handle the sum_d efficiently.

Wait, perhaps I can precompute for each position in the cycle the sum of a_x along the path from the starting position.

Then, for each a_max position, compute (k - d) * a_max + sum_d.

But with large k, I need to handle this carefully.

Wait, perhaps I can iterate through the cycle, keeping track of the cumulative sum and the minimal d to reach a_max.

Then, for each player, compute the maximum (k - d) * a_max + sum_d.

But I need to make sure that this is done efficiently.

Let me consider implementing a function that, given the cycle, a_max, and k, computes the maximum score.

Hence, for each cycle, I can process it once and compute the maximum score for any starting position in that cycle.

Then, for each player, I can look up their starting position in the cycle and compute their maximum score.

But with t up to 10^4 and n up to 2*10^5 in total, I need to make sure that this is efficient.

Wait, perhaps I can represent each cycle as a list, and for each position in the cycle, precompute the minimal d and sum_d to reach a_max.

Then, for each player, use that precomputation to compute their maximum score.

But I need to make sure that this can be done in O(n) time per test case.

Given time constraints, perhaps I need a different approach.

Let me consider that in each cycle, the player can choose to stay at any position for any number of turns.

Hence, the player can choose to stay at the position with the maximum a_x for as many turns as possible.

To reach that position, the player needs to follow the path defined by the permutation.

Hence, the minimal d is the minimal distance from the starting position to any position with a_x equal to a_max.

Then, the maximum score is (k - d) * a_max + sum_d.

Hence, for each cycle, I can find a_max and for each starting position, find the minimal d to a_max and the corresponding sum_d.

Then, compute (k - d) * a_max + sum_d.

But with large k, I need to handle the case where k - d is negative.

Wait, k is the number of turns, which is at least 1, but d can be up to n, which is up to 2*10^5.

Hence, if k <= d, the player cannot reach a_max in time, and the score would be the sum of a_x along the path up to k steps.

Hence, I need to handle two cases:

1. If k <= d: the player cannot reach a_max in time, so the score is the sum of a_x along the path for k steps.

2. If k > d: the score is (k - d) * a_max + sum_d