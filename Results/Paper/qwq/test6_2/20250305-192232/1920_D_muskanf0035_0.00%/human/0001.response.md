Alright, I have this problem to solve. Let's understand what's being asked here. So, Jayden has an array 'a' which starts empty, and he performs a series of operations on it. There are two types of operations:

1. Append an integer x to the end of the array 'a'.

2. Append x copies of the current array 'a' to itself.

After performing these operations, there are q queries asking for the k-th element of the final array 'a'.

First, I need to make sure I understand the operations correctly.

Operation 1: Simple enough. If b=1, we just add the integer x to the end of the array.

Operation 2: This seems a bit trickier. If b=2, we append x copies of the current array 'a' to itself. So, if a is [1,2], and x=3, then after this operation, a becomes [1,2,1,2,1,2].

Also, it's guaranteed that before any operation of type 2, there's at least one operation of type 1, so the array is not empty when a type 2 operation is performed.

Now, regarding the queries: for each query, we have a k, and we need to find the k-th element of the final array 'a'. The constraints are that n and q can be up to 1e5, and x in operation 2 can be up to 1e9, which is a really large number. So, we need to be careful with time and space complexity.

Looking at the provided program, it's divided into two functions: func_1 and func_2. Func_2 seems to handle the input and call func_1 for each test case, then print the results.

Let's look at func_1:

def func_1(n, operations, queries):

array = []

result = []

for (op_type, value) in operations:

if op_type == 1:

array.append(value)

else:

array.extend([array[i] for i in range(len(array))] * value)

for k in queries:

result.append(array[(k - 1) % len(array)])

return result

Wait a minute, this seems problematic. In operation 2, it's supposed to append x copies of the current array to itself, but in this code, it's extending the array with x copies of itself. However, according to the problem, when b=2, it should append x copies of a to the end of a, meaning a becomes [a, a, a, ..., a] x times.

But in this code, it's doing array.extend([array[i] for i in range(len(array))] * value), which is equivalent to array.extend(array * value). So, it's effectively concatenating x copies of the current array to itself.

Wait, but in Python, lists are reference types, so copying and extending should work fine here, as long as we're not modifying the original array while copying.

But considering the constraints, n can be up to 1e5, and x can be up to 1e9, which means that the array can become extremely large very quickly, especially with operation 2.

For example, if we have an operation 2 with x=1e9, and the current array size is 1e5, then the new array size would be 1e5 + 1e5 * 1e9 = 1e5 * (1 + 1e9) = 1e5 * 1e9 + 1e5, which is 1e14 + 1e5, which is way beyond any feasible memory limits.

So, this approach is not going to work because it will exceed memory limits by a large margin.

Therefore, I need a smarter way to handle this without constructing the entire array, especially since the array can become astronomically large.

I need to find a way to compute the k-th element without building the entire array.

Let's think about how the array evolves with each operation.

Let's consider the operations step by step.

Initialize: a is empty.

Perform operation 1: append x. So, a = [x]. Size is 1.

Perform operation 2: append x copies of a to itself. So, a becomes [a, a, ..., a] x times.

Wait, but the problem says: "append x copies of array a to the end of array a". So, it's a.extend([a]*x), meaning a becomes a + a*x.

Wait, no. In Python, a.extend([a]*x) would add x references to a itself, but I think the intention is to add x copies of the elements of a.

Wait, in the problem statement, it says: "append x copies of array a to the end of array a". So, if a = [1,2], and x=3, then a becomes [1,2,1,2,1,2].

So, it's concatenating x copies of a to itself.

But in the code provided, it's doing array.extend([array[i] for i in range(len(array))] * value), which is equivalent to array.extend(array * value), which should achieve the desired effect.

However, as I thought earlier, this approach is not feasible for large x, as it will consume too much memory.

So, I need a different approach.

Maybe I can keep track of the size of the array after each operation, without actually storing the array.

For operation 1: append x, so size increases by 1.

For operation 2: append x copies of the current a, so the new size is size + x * size = size * (x + 1).

Then, for each query, given k, I need to find the k-th element in the final array.

But with n up to 1e5 and operations potentially exponentially increasing the size, I need an efficient way to compute the k-th element without building the array.

I recall that in some problems involving operations that duplicate parts of an array or string, we can use a segment tree or some kind of tree structure to handle range updates and queries efficiently.

But perhaps there's a smarter way here.

Let me consider that each operation 2 effectively multiplies the size of the array by a factor of (x + 1), because it appends x copies of itself to itself, making the new size equal to size * (x + 1).

Wait, let's see:

Initial size: 0

Operation 1: append x, size = 1

Operation 2: append x copies of a to a, so a becomes a + a*x, which is a*(x+1). So, size = size * (x + 1)

Operation 1: append x, size = size + 1

And so on.

Wait, but it's not strictly multiplying by (x + 1), because operation 2 appends x copies of a to a, making it a * (x + 1).

Wait, no, a becomes a + a*x, which is a*(x + 1).

Wait, but in terms of size, if size_before = size, then size_after = size + x*size = size*(x + 1).

Yes, that's correct.

So, perhaps I can keep track of the size after each operation, and then, for each query, find out which part of the final array the k-th element belongs to, by traversing the operations in reverse.

Wait, maybe it's similar to how we handle tries or trees, where we keep track of the cumulative size.

Alternatively, perhaps I can represent the final array as a tree, where each operation 2 creates a new level with x repetitions of the previous level.

But I need to think differently.

Let me consider that after each operation, I can compute the current size of the array.

So, I can have a list that keeps track of the size after each operation.

For example:

Operation 1: size = 1

Operation 2: size = size * (x + 1)

Operation 1: size = size + 1

And so on.

Wait, no. Operation 2: append x copies of a to a, so the new size is size + x * size = size * (x + 1)

Yes, that's correct.

So, I can compute the size after each operation.

Then, for each query, given k, I need to find which element corresponds to k in the final array.

To do this efficiently, perhaps I can start from the last operation and see how the array was built up.

Wait, maybe I can simulate the operations in reverse.

Wait, perhaps I can keep a list of the size after each operation, and then for each query, starting from the final size, determine in which part the k-th element lies.

Wait, this seems similar to binary indexed trees or segment trees, but I need to think carefully.

Let me try to outline an approach:

1. Compute the size of the array after each operation.

- Initialize size = 0

- For each operation:

- If operation 1: size += 1

- If operation 2: size *= (x + 1)

2. For each query, given k, find the k-th element in the final array.

- To do this, traverse the operations in reverse, seeing how the final array was built.

- Determine which "branch" of the array construction the k-th element belongs to.

This seems promising, but I need to formalize it.

Let me consider an example to see if this works.

Take the first test case from the example:

5 10

1 1

1 2

2 1

1 3

2 3

Queries: 1 2 3 4 5 6 14 15 16 20

So, let's compute the size after each operation:

Initial size = 0

Operation 1: append 1 -> size = 1

Operation 1: append 2 -> size = 2

Operation 2: append 1 copy of a to a -> a becomes a + a*1 = a*2 -> size = 2 * (1 + 1) = 4

Operation 1: append 3 -> size = 4 + 1 = 5

Operation 2: append 3 copies of a to a -> a becomes a + a*3 = a*4 -> size = 5 * 4 = 20

So, final size is 20.

Queries are for k = 1 to 20.

Now, I need to find the k-th element in the final array.

Instead of building the entire array, I need a way to find the k-th element based on the operations.

Let me think about how the array is built:

- Start with empty array.

- Operation 1: append 1 -> a = [1]

- Operation 1: append 2 -> a = [1,2]

- Operation 2: append 1 copy of a to a -> a = [1,2,1,2]

- Operation 1: append 3 -> a = [1,2,1,2,3]

- Operation 2: append 3 copies of a to a -> a = [1,2,1,2,3,1,2,1,2,3,1,2,1,2,3,1,2,1,2,3]

Now, for k from 1 to 20, the elements are:

1:1, 2:2, 3:1, 4:2, 5:3, 6:1, 7:2, 8:1, 9:2, 10:3, 11:1, 12:2, 13:1, 14:2, 15:3, 16:1, 17:2, 18:1, 19:2, 20:3

So, the answers for the queries should be: 1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 2 3

But in the sample output, for the first test case, it's:

1 2 1 2 3 1 2 3 1 3

Wait, that doesn't match exactly. Wait, perhaps I misread.

Wait, in the sample output, for the first test case, it's:

1 2 1 2 3 1 2 3 1 3

But according to my calculation, it should be:

1 2 1 2 3 1 2 1 2 3

So, there's a discrepancy here. Maybe I made a mistake in understanding the operations.

Wait, let's re-examine the operations:

Operation 2 says: append x copies of a to the end of a. So, a becomes a + [a]*x.

Wait, but in the sample explanation, after operation 3 (which is operation 2 with x=1), a becomes [1,2,1,2].

Then, operation 4: append 3, so a = [1,2,1,2,3]

Operation 5: operation 2 with x=3, so append 3 copies of a to a, meaning a becomes a + [a]*3 = a + a + a + a, which is a*4.

So, a = [1,2,1,2,3,1,2,1,2,3,1,2,1,2,3,1,2,1,2,3]

So, the 14th element should be 2, the 15th is 3, the 16th is 1, etc.

But in the sample output, for k=14,15,16,20, it's 2 3 1 3, which matches my calculation.

Wait, in my earlier calculation, for k=14,15,16,20, I have 2,3,1,3, which matches the sample output. So, perhaps I miscounted earlier.

Anyway, the main point is that building the entire array is not feasible for large n and x.

So, I need a smarter way to find the k-th element without constructing the array.

Let's think about how to do that.

I can keep track of the size of the array after each operation, as I did earlier.

Then, for each query, I can determine which operation's addition corresponds to the k-th element.

Starting from the final size, I can see which operation contributed to the k-th position.

Since operations can exponentially increase the size, I need an efficient way to traverse the operations in reverse.

Wait, perhaps I can keep a list of the size before each operation, and then for each query, starting from the final size, I can see which operation's addition contains the k-th element.

Let me try to formalize this.

First, compute the size after each operation, as I did earlier.

Then, for each query k, starting from the final size, check in which part the k-th element lies.

For example, in the last operation:

If the last operation is operation 1, which appends a single element, then if k is equal to the final size, the element is the one appended in operation 1.

If k is less than the final size, then it lies in the previous part of the array.

Similarly, if the last operation is operation 2, which appends x copies of the previous a, then the new elements are x * size_before copies.

So, I need to find in which copy the k-th element lies.

This seems a bit involved, but it's doable.

Perhaps I can keep a list of sizes after each operation, and then for each query, starting from the final size, check in which operation's addition the k-th element falls.

Let me try to implement this step by step.

First, initialize size = 0

Then, for each operation, keep track of the size after that operation.

operations = [(b1, x1), (b2, x2), ..., (bn, xn)]

sizes = [0]

for op in operations:

if op[0] == 1:

sizes.append(sizes[-1] + 1)

elif op[0] == 2:

sizes.append(sizes[-1] * (op[1] + 1))

Now, sizes[i] is the size after the i-th operation.

Then, for each query k, I need to find which element corresponds to k in the final array.

I can start from the last operation and see in which part the k-th element lies.

Let's define a function to find the k-th element:

def find_kth_element(operations, k):

sizes = [0]

for op in operations:

if op[0] == 1:

sizes.append(sizes[-1] + 1)

elif op[0] == 2:

sizes.append(sizes[-1] * (op[1] + 1))

# Now, sizes[-1] is the final size

# Now, traverse backwards to find the k-th element

current_size = sizes[-1]

for i in range(len(operations), 0, -1):

op = operations[i-1]

if op[0] == 1:

if k == current_size:

return op[1]

else:

current_size -= 1

elif op[0] == 2:

repeat_factor = op[1]

block_size = sizes[i-1]

blocks = repeat_factor + 1  # original + x copies

total_size = block_size * blocks

if k > total_size - block_size:

# k is in one of the copied blocks

copy_index = (k - (total_size - block_size)) // block_size

offset = (k - (total_size - block_size)) % block_size

return find_kth_element(operations[:i-1], offset)

else:

# k is in the original part

return find_kth_element(operations[:i-1], k)

Wait, this seems recursive and might be inefficient for large n and q.

Perhaps I need an iterative approach to avoid recursion depth issues.

Let me think again.

I need to simulate the process without building the array.

I can keep track of the sizes and, for each query, iterate through the operations in reverse to find out which element corresponds to k.

Let me try to implement this iteratively.

First, compute the size after each operation, as in the sizes list above.

Then, for each query k, start from the final size and trace back to find the k-th element.

Here's a step-by-step plan:

- Initialize current_size = sizes[-1] (final size)

- Initialize index = n (the last operation)

- While index > 0:

- Look at operation at index - 1

- If operation is type 1:

- If k == current_size:

- The k-th element is the integer appended in this operation.

- Else:

- Subtract 1 from current_size and decrement index by 1.

- Elif operation is type 2:

- Let x = operation[1]

- Let size_before = sizes[index - 1]

- Let block_size = size_before

- Let total_copied_size = block_size * x

- Let new_size = block_size + total_copied_size = block_size * (x + 1)

- If k > block_size:

- Find which copy it belongs to:

- copy_number = (k - block_size - 1) // block_size + 1

- offset = (k - block_size - 1) % block_size + 1

- Set k = offset

- Else:

- Set k = k

- Set current_size = block_size

- Set index = index - 1

This way, we're reducing k and current_size based on which part of the array it falls into.

This should work efficiently since each query traverses the operations in reverse once.

Given that n can be up to 1e5 and q up to 1e5, and t up to 5000, but the sum of n and q over all test cases does not exceed 1e5, this should be acceptable.

Let me try to implement this logic in code.

First, precompute the sizes after each operation.

Then, for each query, perform the steps as described.

Also, need to handle the modulo operation carefully, as k can be up to 1e18, but in the problem, it's guaranteed that k <= min(1e18, c), where c is the final size of the array.

Wait, in the problem statement, it says "k <= min(1e18, c)", so we don't need to worry about k being larger than c, as it's guaranteed to be <= c.

Hence, we can safely assume k <= c.

Now, let's think about how to implement this efficiently.

I need to precompute the sizes after each operation.

Then, for each query, traverse the operations in reverse to find the k-th element.

To optimize, I can store the sizes in a list, and keep track of the current size and the current operation index.

Also, for operation 2, since x can be up to 1e9, but n is up to 1e5, and t is up to 5000, with the sum of n and q over all test cases <= 1e5, it should be manageable.

I need to make sure that the code is efficient and doesn't have unnecessary computations.

Let me try to write a sample code snippet to see if this works.

Define a function to find the k-th element:

def find_kth_element(operations, sizes, k):

index = len(operations)

current_size = sizes[-1]

while index > 0:

index -= 1

op = operations[index]

if op[0] == 1:

if k == current_size:

return op[1]

else:

current_size -= 1

elif op[0] == 2:

x = op[1]

size_before = sizes[index]

block_size = size_before

total_copied_size = block_size * x

new_size = block_size + total_copied_size

if k > block_size:

# Find which copy it belongs to

copy_number = (k - block_size - 1) // block_size + 1

offset = (k - block_size - 1) % block_size + 1

k = offset

else:

# k is in the original part

pass

current_size = block_size

return None  # Should never reach here if k <= c

Wait, in the sample input, for the first test case, with operations:

1 1

1 2

2 1

1 3

2 3

And sizes:

0

1  # after op1: append 1

2  # after op2: append 2

4  # after op3: append 1 copy of a to a (a becomes [1,2,1,2])

5  # after op4: append 3

20 # after op5: append 3 copies of a to a (a becomes [1,2,1,2,3,1,2,1,2,3,1,2,1,2,3,1,2,1,2,3])

Now, for k=14:

k=14 > block_size=5 (after op5: operation 2 with x=3, block_size=5)

copy_number = (14 - 5 - 1) // 5 + 1 = (8) //5 +1 = 1 +1 = 2

offset = (14 - 5 -1) %5 +1 = 8%5 +1 = 3 +1 =4

So, k=4

Now, index=4, operation 2 with x=3

current_size=5

index=3, operation1 with append 3

k=4 <= current_size=5

If k == current_size:

return 3

Else, k=4 <5, so go to previous operation.

index=2, operation2 with x=1

current_size=2

k=4 >2

copy_number=(4-2-1)//2 +1 =1//2 +1=0+1=1

offset=(4-2-1)%2 +1=1%2 +1=1+1=2

k=2

index=1, operation1 with append2

k=2 <= current_size=1

Wait, current_size=1, but k=2 >1, which is invalid.

Wait, perhaps I have an error in the logic.

Wait, perhaps I need to adjust how I handle operation 2.

Let me think again.

When operation 2 is performed with x copies, the new array is a + a*x, which is a*(x+1).

So, the new size is size_before * (x + 1).

In the find_kth_element function, when operation 2 is encountered, I need to determine in which of the (x+1) blocks the k-th element lies.

Each block has size size_before.

So, if k <= size_before, it's in the original part.

Else, it's in one of the copied blocks.

Copy number can be calculated as (k - size_before - 1) // size_before +1

And offset within that copy is (k - size_before -1) % size_before +1

Then, set k to the offset and continue with the previous operations.

Wait, in the earlier calculation for k=14:

sizes = [0,1,2,4,5,20]

operations = [(1,1),(1,2),(2,1),(1,3),(2,3)]

Start with k=14, current_size=20, index=5

index=4, operation=(2,3), size_before=5, block_size=5, total_copied_size=15, new_size=20

k=14 > block_size=5

copy_number=(14-5-1)//5 +1 =8//5 +1=1+1=2

offset=(14-5-1)%5 +1=3+1=4

set k=4

Now, index=4, operation=(2,3), current_size=5

index=3, operation=(1,3), current_size=4

k=4 <=4

if k == current_size: return 3

Else, k=4 == current_size=4, so return 3

Wait, in the sample output, for k=14, it's 2, but according to this, it's returning 3, which is incorrect.

Wait, perhaps I have a mistake in the logic.

Let me check again.

After operation 4, a = [1,2,1,2,3], size=5

After operation 5, a = [1,2,1,2,3,1,2,1,2,3,1,2,1,2,3,1,2,1,2,3], size=20

So, the first 5 elements are the original a, then 3 copies of a.

So, positions 1-5: original a

6-10: copy 1 of a

11-15: copy 2 of a

16-20: copy 3 of a

So, k=14 is in copy 2 (positions 11-15), element number 14-10=4, so a[4]=2

Hence, the correct element is 2.

But according to my earlier function, it returned 3, which is wrong.

So, there's an error in the logic.

I need to fix this.

Let me think differently.

Perhaps, for operation 2, with x copies, the new array is a original + x copies of a.

So, if k <= size_before, it's in the original part.

Else, it's in one of the copied blocks.

So, copy_number = (k - size_before -1) // size_before +1

But actually, copy_number starts from 0.

Wait, perhaps it's better to calculate the number of copies and the offset.

Let me adjust the function.

def find_kth_element(operations, sizes, k):

index = len(operations)

current_size = sizes[-1]

while index > 0:

index -= 1

op = operations[index]

if op[0] == 1:

if k == current_size:

return op[1]

else:

current_size -= 1

elif op[0] == 2:

x = op[1]

size_before = sizes[index]

block_size = size_before

total_copied_size = block_size * x

new_size = block_size + total_copied_size

if k <= block_size:

# In the original part

pass

else:

# In one of the copied blocks

copy_number = (k - block_size -1) // block_size +1

if copy_number > x:

raise ValueError("Invalid copy number")

offset = (k - block_size -1) % block_size +1

k = offset

current_size = block_size

continue

# Now, find the k-th element in the original part

return find_kth_element(operations[:index], k)

Wait, this is still recursive, which might not be efficient.

Let me try an iterative approach without recursion.

def find_kth_element(operations, sizes, k):

index = len(operations)

current_size = sizes[-1]

while index > 0:

index -= 1

op = operations[index]

if op[0] == 1:

if k == current_size:

return op[1]

else:

current_size -= 1

elif op[0] == 2:

x = op[1]

size_before = sizes[index]

block_size = size_before

total_copied_size = block_size * x

new_size = block_size + total_copied_size

if k > block_size:

# Find which copy it belongs to

copy_number = (k - block_size -1) // block_size +1

if copy_number > x:

raise ValueError("Invalid copy number")

offset = (k - block_size -1) % block_size +1

k = offset

else:

# k is in the original part

pass

current_size = block_size

# After processing all operations, k should be within the original a

return operations[0][1]

Wait, but in the first operation, it's possible to have operation 1 or 2.

Wait, actually, the problem states that before any operation 2, there is at least one operation 1, so the array is not empty when operation 2 is performed.

Hence, when we reach index=0, it should be an operation 1, appending the first element.

So, in that case, if k ==1, return that element.

But in the earlier example, for k=14, it should return 2, but according to this function, it returns 3, which is wrong.

I need to fix the logic.

Let me try to simulate the steps for k=14 in the first test case.

operations:

0: (1,1)

1: (1,2)

2: (2,1)

3: (1,3)

4: (2,3)

sizes:

0

1

2

4

5

20

Start with k=14, current_size=20, index=5

index=4, op=(2,3), size_before=5, block_size=5, total_copied_size=15, new_size=20

k=14 >5, so copy_number=(14-5-1)//5 +1 =8//5 +1=1+1=2

offset=(14-5-1)%5 +1=3+1=4

set k=4

current_size=5

index=3, op=(1,3), current_size=5

k=4 <=5

if k==5, return 3

else, k=4

current_size=5-1=4

index=2, op=(2,1), size_before=2, block_size=2, total_copied_size=2, new_size=4

k=4 >2, copy_number=(4-2-1)//2 +1=1//2 +1=0+1=1

offset=(4-2-1)%2 +1=0%2 +1=0+1=1

set k=1

current_size=2

index=1, op=(1,2), current_size=2

k=1 <=2

if k==2, return 2

else, k=1

current_size=2-1=1

index=0, op=(1,1), current_size=1

k=1 ==1, return 1

Wait, but according to the earlier simulation, it should return 2.

I must have made a mistake in the simulation.

Wait, perhaps I need to adjust how I handle operation 2.

Let me think differently.

When operation 2 is performed with x copies, the new array is a original followed by x copies of a.

So, the original a is first, then a is repeated x times.

Hence, the first block is the original a, and the next x blocks are copies of a.

So, the total size is size_before * (x + 1).

Given k, if k <= size_before, it's in the original a.

Else, it's in one of the x copied blocks.

So, copy_number = (k - size_before -1) // size_before +1

And offset = (k - size_before -1) % size_before +1

Then, set k = offset and continue with the previous operations.

Wait, in the earlier simulation, for k=14:

sizes = [0,1,2,4,5,20]

operations = [(1,1),(1,2),(2,1),(1,3),(2,3)]

Start with k=14, current_size=20, index=5

index=4, op=(2,3), size_before=5, block_size=5, total_copied_size=15, new_size=20

k=14 >5, so copy_number=(14-5-1)//5 +1=8//5 +1=1+1=2

offset=(14-5-1)%5 +1=3+1=4

set k=4

current_size=5

index=3, op=(1,3), current_size=5

k=4 <=5

if k==5, return 3

else, k=4

current_size=5-1=4

index=2, op=(2,1), size_before=2, block_size=2, total_copied_size=2, new_size=4

k=4 >2, copy_number=(4-2-1)//2 +1=1//2 +1=0+1=1

offset=(4-2-1)%2 +1=0%2 +1=0+1=1

set k=1

current_size=2

index=1, op=(1,2), current_size=2

k=1 <=2

if k==2, return 2

else, k=1

current_size=2-1=1

index=0, op=(1,1), current_size=1

k=1 ==1, return 1

But according to the array [1,2,1,2,3,1,2,1,2,3,1,2,1,2,3,1,2,1,2,3], the 14th element is 2.

But according to this simulation, it returns 1, which is incorrect.

Wait, perhaps the mistake is in how I handle operation 2.

Let me try to adjust the logic.

When operation 2 is performed with x copies, the new array is a original followed by x copies of a.

So, the first block is the original a (size_before), and the next x blocks are each a copy of a (each of size_before).

Hence, total new size is size_before * (x + 1).

Given k, if k <= size_before, it's in the original a.

Else, it's in one of the x copied blocks.

So, copy_number = (k - size_before -1) // size_before +1

But copy_number should not exceed x.

If copy_number > x, then it's invalid.

Otherwise, offset = (k - size_before -1) % size_before +1

Then, set k = offset

And continue with the previous operations.

Wait, perhaps I need to set k = offset and continue with the previous operations, but considering that the copied block is identical to the original a at that operation.

Wait, perhaps I need to treat the copied blocks as identical to the original a at the time of the operation.

Hence, when k is in one of the copied blocks, I should set k to the offset within the original a and continue from there.

Wait, perhaps I need to keep track of the version of a at the time of the operation.

This is getting complicated.

Let me look for a different approach.

I recall that in some problems involving building arrays through repetitive operations, we can treat the array as a tree, where each operation 2 creates child nodes representing the copies.

Then, finding the k-th element is like traversing the tree to find the k-th node.

But building such a tree is not feasible due to time and space constraints.

Another idea: Since operation 2 appends x copies of a to a, the array becomes a concatenated x+1 times.

Hence, the array is a * (x + 1).

Given that x can be up to 1e9, it's impossible to build the array.

But perhaps I can treat the array as a periodic structure after each operation 2.

Wait, but operation 2 depends on the current a, which can change with operation 1.

I need a way to handle this efficiently.

Let me consider that after each operation, I can represent the array as a combination of previous arrays.

Specifically, after operation 2, the array is a concatenated (x+1) times.

So, if I can represent the array as a combination of blocks, each block being a previous version of a, then I can map k to the corresponding block and offset.

This seems similar to how file systems handle block addressing.

Wait, perhaps I can keep track of the version of a at each operation and map k to the corresponding version and offset.

But this might be too slow for large n and q.

Let me think about another approach.

Suppose I keep track of the size of a after each operation, and for operation 2, I record that a is now a * (x + 1).

Then, for each query, I can find which part of the final a the k-th element belongs to by repeatedly dividing k by the repetition factor.

Wait, perhaps I can treat the operations as building a compressed representation of the array, where operation 2 indicates that the array is repeated x+1 times.

Then, for a query k, I can traverse the operations in reverse, reducing k according to the repetition factors.

This seems promising.

Let me formalize this.

First, compute the size of a after each operation.

Then, for each query k, starting from the final size, find which operation's addition contains the k-th element.

If the last operation is operation 1, which appends a single element, then if k equals the final size, it's that element.

Otherwise, reduce k by 1 and check the previous operation.

If the last operation is operation 2, which appends x copies of a to a, then the new size is size_before * (x + 1).

If k <= size_before, then it's in the original a.

Else, it's in one of the x copied blocks.

In this case, find which copy it belongs to by computing (k - size_before -1) // size_before to get the copy number, and (k - size_before -1) % size_before +1 to get the offset within that copy.

Then, set k to the offset and continue with the previous operations.

Repeat this until we reach the first operation.

This should work.

Let me try to simulate this for k=14 in the first test case.

operations:

0: (1,1)

1: (1,2)

2: (2,1)

3: (1,3)

4: (2,3)

sizes:

0

1

2

4

5

20

Start with k=14, current_size=20, index=5

index=4, op=(2,3), size_before=5, block_size=5, total_copied_size=15, new_size=20

k=14 >5, so copy_number=(14-5-1)//5 +1=8//5 +1=1+1=2

offset=(14-5-1)%5 +1=3+1=4

set k=4

current_size=5

index=3, op=(1,3), current_size=5

k=4 <=5

if k==5, return 3

else, k=4

current_size=5-1=4

index=2, op=(2,1), size_before=2, block_size=2, total_copied_size=2, new_size=4

k=4 >2, copy_number=(4-2-1)//2 +1=1//2 +1=0+1=1

offset=(4-2-1)%2 +1=0%2 +1=0+1=1

set k=1

current_size=2

index=1, op=(1,2), current_size=2

k=1 <=2

if k==2, return 2

else, k=1

current_size=2-1=1

index=0, op=(1,1), current_size=1

k=1 ==1, return 1

But according to the array, k=14 should be 2.

Hence, there is a mistake in the logic.

Wait, perhaps I need to adjust how I handle operation 2.

Let me consider that after operation 2 with x copies, the new a is a original followed by x copies of a.

Hence, the first size_before elements are the original a, and the next x*size_before elements are x copies of a.

So, if k <= size_before, it's in the original a.

Else, it's in one of the x copies.

In that case, copy_number = (k - size_before -1) // size_before +1

But copy_number should not exceed x.

If copy_number > x, then it's invalid.

Otherwise, offset = (k - size_before -1) % size_before +1

Then, set k = offset

And continue with the previous operations.

Wait, perhaps the mistake is in how I handle operation 1.

When operation 1 appends a single element, it increases the size by 1.

Hence, if k == current_size, it's that element.

Else, reduce current_size by 1 and move to the previous operation.

In the earlier simulation, for k=4 and current_size=5 after operation (1,3), since k < current_size, we reduce current_size to 4 and move to the previous operation.

But perhaps I need to consider that operation 1 appends a single element, so if k == current_size, it's that element, else, it's in the previous part of the array.

Wait, perhaps I need to adjust the order of operations.

Let me try to think differently.

Let me consider that each operation either appends a single element or appends x copies of the current a.

Hence, the array can be seen as built in layers, where each operation 2 creates new layers based on the previous a.

I need to find a way to map k to the corresponding element without building the array.

Another idea: Since operation 2 can be seen as repeating the current a x times, I can treat the array as a tree, where each operation 2 creates x child nodes, each being a copy of the current a.

Then, finding the k-th element is like traversing this tree to find the k-th node.

But with x up to 1e9, this is not feasible.

I need a better approach.

Wait, perhaps I can treat the array as a sequence of blocks, where each operation 2 creates new blocks.

Let me try to represent the array as a combination of blocks, each block corresponding to a version of a at some operation.

This is