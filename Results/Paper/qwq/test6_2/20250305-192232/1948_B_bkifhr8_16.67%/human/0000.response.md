Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and I can perform a specific operation on any element that's at least 10. The operation allows me to delete that element and insert its digits in the same position. For example, if I have [12, 3, 45, 67] and I apply the operation to the third element, 45, it becomes [12, 3, 4, 5, 67]. Another example is [2, 10], and applying the operation to the second element gives [2, 1, 0].

My task is to determine whether it's possible to make the array sorted in non-decreasing order by performing this operation any number of times, possibly zero.

First, I need to understand the operation clearly. When I choose an element that's at least 10, I can replace it with its individual digits. So, for example, 12 becomes 1 and 2. This operation can be applied multiple times.

I need to check if, after applying these operations in some way, the array becomes sorted in non-decreasing order.

Let me look at the examples provided to understand better.

First test case:

4

12 3 45 67

The solution says YES, and in the note, it explains that by splitting the first element, 12, into 1 and 2, the array becomes [1, 2, 3, 45, 67], which is sorted.

Second test case:

3

12 28 5

The solution is NO, meaning there's no way to make it sorted by splitting any numbers.

Third test case:

2

0 0

It's already sorted, so YES.

From these examples, it seems that splitting numbers can help rearrange the array to be sorted, but not all arrays can be made sorted through this process.

Now, I need to think about how to approach this problem.

First, I need to consider that splitting a number affects the array by replacing the number with its digits. For example, 12 becomes 1 and 2, which are both smaller than 12, so it's like breaking down the number into smaller parts.

But, I need to ensure that after all possible splits, the array is sorted in non-decreasing order.

One way to think about this is to consider the maximum possible value at each position after splitting.

Wait, maybe I should consider the smallest possible value each position can have after splitting.

Let me think differently. Suppose I have an array, and I want to split numbers in such a way that the array becomes sorted.

I need to ensure that for every position i, the element at i is less than or equal to the element at i+1.

But splitting a number can change the length of the array, which complicates things.

Wait, but the problem allows me to perform the operation any number of times, so I can split numbers as much as I want.

I need to find a way to determine if there's a sequence of splits that leads to a sorted array.

Let me consider that each number can be split into its digits, and these digits can be arranged in any order.

But no, the digits are inserted in the same position, in the order they appear in the number.

So, for example, splitting 12 in [12, 3, 45, 67] replaces 12 with 1 and 2, maintaining their order.

So, the array becomes [1, 2, 3, 45, 67].

Another example: [2, 10] becomes [2, 1, 0] after splitting 10.

Now, I need to see if, by splitting numbers that are at least 10, I can make the array sorted in non-decreasing order.

I need to find a way to decide whether such a sequence of splits exists.

One approach could be to try all possible sequences of splits and check if any of them result in a sorted array. But this seems inefficient, especially since n can be up to 50, and each number can have up to 2 digits.

Wait, but numbers can be up to 99, which means they can have at most 2 digits.

So, each number can be split into at most two digits.

I need to think about how splitting affects the array.

Let me consider that each number in the array can be either kept as is or split into its digits.

So, for each number that is at least 10, I have two choices: keep it or split it.

But actually, I can only split it if it's at least 10, and when I split it, I replace it with its digits.

I need to consider all possible ways of splitting the numbers and check if any of those results in a sorted array.

But with n up to 50, and each number possibly being split or not, this could lead to a large number of possibilities.

I need a smarter way to approach this.

Let me consider the array and try to build a sorted sequence by deciding for each number whether to split it or not.

I need to ensure that the sequence is non-decreasing.

I should consider the smallest possible value at each position, considering whether to split the number or not.

Wait, perhaps I can think in terms of the minimum value that each position can have after splitting.

For example, for a number like 12, the minimum value it can have after splitting is 1 (since splitting 12 gives 1 and 2).

Similarly, for 45, splitting gives 4 and 5, so the minimum value is 4.

For a number less than 10, it remains as is.

So, for each position, I can decide to split the number (if it's >=10) or keep it, and choose the minimum possible value.

But I need to ensure that the sequence is sorted, meaning that the chosen value for each position is <= the chosen value for the next position.

Wait, but it's not just about choosing the minimum value for each position; I need to consider how splitting affects the entire array.

Because splitting a number increases the array's length, inserting multiple digits in place of one number.

So, it's not just choosing a single value for each position; it's about expanding the array.

This seems complicated.

Maybe I need to think recursively, considering all possible splits and checking if any of them lead to a sorted array.

But with n up to 50, this would be too slow.

I need a better approach.

Let me consider the array as a whole and see what conditions would make it impossible to sort.

If there exists a number that, no matter how I split it, disrupts the sorted order, then the answer is NO.

Otherwise, it's YES.

Wait, perhaps I can iterate through the array and keep track of the maximum value so far, considering the splits.

Let me try to think of a greedy approach.

Start from the beginning of the array and keep track of the maximum value encountered so far.

For each position, consider the number or its split digits, and ensure that they are >= the maximum so far.

But I need to think carefully.

Wait, maybe I should consider the array after all possible splits have been performed, and see if it can be sorted.

But splitting can be done in various ways, and it's not clear how to model this.

Let me consider that splitting a number into digits is like replacing it with a sequence of digits, and I can do this for any number >=10 any number of times.

I need to see if, after all possible splits, the array can be sorted.

But this is still vague.

Perhaps I need to consider that splitting a number allows me to insert its digits in the same order, and I can choose to split some numbers and not others.

I need to find a way to arrange the array such that it's sorted, using the digits of the numbers where splitting is applied.

This seems complex.

Let me think differently.

Suppose I have the array [12, 3, 45, 67].

If I split 12 into 1 and 2, the array becomes [1, 2, 3, 45, 67], which is sorted.

If I don't split 12, the array is [12, 3, 45, 67], which is not sorted.

So, in this case, splitting 12 helps to sort the array.

In the second example, [12, 28, 5], let's see what happens.

If I split 12 into 1 and 2, the array becomes [1, 2, 28, 5].

This is not sorted.

If I split 28 into 2 and 8, it becomes [1, 2, 2, 8, 5].

Still not sorted.

If I split 12 and 28, I get [1, 2, 2, 8, 5].

If I split 5 (which is less than 10, so no split), it remains as is.

It seems like there's no way to make this array sorted through splitting.

In the third example, [0, 0], it's already sorted, so no need to split.

Now, I need to generalize this.

I need to find a way to determine, for any given array, whether it's possible to sort it by splitting numbers >=10 into their digits.

I need to find a condition or a method to check this efficiently.

Let me consider that splitting a number into digits can be seen as replacing the number with a sequence of digits, and I can choose to do this for any number >=10.

So, for each number in the array, I have two options: keep it as is (if it's <10 or if splitting doesn't help), or split it into its digits (if it's >=10).

I need to choose for each number whether to split it or not, and then check if the resulting array is sorted.

But with n up to 50, and each number having two options (split or not), this could lead to 2^n possibilities, which is too much to compute for n=50.

Therefore, I need a smarter approach.

Maybe I can think in terms of the digits that make up the numbers.

Each number can be represented by its digits, and splitting allows me to insert those digits into the array in their original order.

So, for example, 12 is '1' followed by '2', 45 is '4' followed by '5', etc.

I need to arrange these digits in such a way that the array is sorted.

But I need to maintain the relative order of the digits from their original positions.

This seems tricky.

Let me consider that splitting a number allows me to insert its digits in the same order, and I can choose to split some numbers and not others.

I need to see if there's a way to split some numbers to make the entire array sorted.

I need to find a way to model this.

Perhaps I can think of the array as a sequence of digits, where some digits are grouped together in numbers >=10, and I can choose to split these groups.

So, for [12, 3, 45, 67], it's like having '12', '3', '45', '67', and I can choose to split '12' into '1' and '2', and '45' into '4' and '5', etc.

Then, the array becomes a sequence of digits, and I need to see if this sequence is sorted.

But I can choose which numbers to split, so I need to find a combination of splits that results in a sorted sequence.

This seems complicated.

Let me consider that splitting a number into digits allows me to have more flexibility in arranging the sequence.

But since the digits are inserted in the same order, I can't reorder them.

So, I need to ensure that, after splitting, the sequence of digits is non-decreasing.

I need to find a way to check this efficiently.

Maybe I can iterate through the array and keep track of the maximum value so far, considering the splits.

Wait, perhaps I can think in terms of the maximum digit in the current number and compare it to the next number.

But I'm getting confused.

Let me try to think recursively.

Define a function that takes the current position in the array and the previous value.

At each position, I can choose to split the number or not (if it's >=10), and then recursively check the next positions.

But this might be too slow for n=50.

I need a better way.

Maybe I can model this as a graph, where each number can be split into its digits, and I need to find a path that is sorted.

But this seems overkill.

Let me think about the properties of the numbers and their splits.

Suppose I have two consecutive numbers, a and b.

If a > b, and a >=10, I can split a into its digits.

After splitting, a is replaced by its digits, say d1, d2, ..., dk, where d1 <= d2 <= ... <= dk.

I need to ensure that d1 <= b, and d1 >= previous value.

But this is getting too involved.

Wait, perhaps I can consider that splitting a number allows me to insert its digits in a way that can help in sorting.

But I need a clear approach.

Let me look at the constraints again.

n is between 2 and 50, and a_i is between 0 and 99.

Given that n can be up to 50, and a_i can be up to 99, which has at most 2 digits, maybe I can consider that splitting a number >=10 gives me two digits, both less than 10.

So, for example, 12 splits into 1 and 2, both <10.

45 splits into 4 and 5, both <10.

Similarly, 67 splits into 6 and 7, both <10.

So, after splitting, all elements in the array are <10.

Wait, but numbers less than 10 are not split.

So, in the array, after all possible splits, I have a sequence of digits, all less than 10.

But, in the first example, [12, 3, 45, 67] splits to [1, 2, 3, 4, 5, 6, 7], which is sorted.

In the second example, [12, 28, 5] splits to [1, 2, 2, 8, 5], which is not sorted.

So, perhaps the key is to see if, after splitting all numbers >=10, the resulting sequence is sorted.

But in the first example, splitting only 12 was enough to sort the array.

In the second example, splitting all numbers gives [1, 2, 2, 8, 5], which is not sorted.

But if I split 12 and 28, I get [1, 2, 2, 8, 5], which is not sorted.

If I split only 28, I get [12, 2, 8, 5], which is not sorted.

If I split only 12, I get [1, 2, 28, 5], which is not sorted.

If I don't split any, [12, 28, 5], which is not sorted.

So, in this case, no matter what I do, I can't get a sorted array.

In the third example, [0, 0] is already sorted.

So, perhaps the approach is to split all numbers >=10 and see if the resulting sequence is sorted.

But in the first example, splitting only 12 was enough, and splitting all numbers would also result in a sorted array: [1, 2, 3, 4, 5, 6, 7].

Wait, but in the second example, splitting all numbers gives [1, 2, 2, 8, 5], which is not sorted.

So, perhaps the approach is to split all numbers >=10 and see if the resulting sequence is sorted.

If it is, then answer YES; else, NO.

But in the first example, splitting only 12 was enough, but splitting all numbers also results in a sorted sequence.

In the second example, splitting all numbers doesn't result in a sorted sequence.

So, perhaps it's sufficient to check if splitting all numbers >=10 results in a sorted sequence.

But I need to confirm if this is always the case.

Let me think of another example.

Consider [15, 2, 3].

If I split 15 into 1 and 5, the array becomes [1, 5, 2, 3].

This is not sorted.

If I don't split 15, the array is [15, 2, 3], which is not sorted.

If I split 15 and then split 5 into 5 (no change since 5 <10), it remains [1, 5, 2, 3].

Still not sorted.

So, in this case, it's impossible to sort the array through splitting.

Another example: [20, 1, 2].

If I split 20 into 2 and 0, the array becomes [2, 0, 1, 2].

This is not sorted.

If I don't split 20, it's [20, 1, 2], which is not sorted.

So, impossible to sort.

Another example: [11, 11, 11].

If I split all 11's into 1 and 1, the array becomes [1,1,1,1,1,1], which is sorted.

So, in this case, splitting all numbers >=10 results in a sorted array.

Another example: [13, 14, 15].

If I split all of them, I get [1,3,1,4,1,5], which is not sorted.

If I split only the first two, [1,3,1,4,15], which is not sorted.

If I split only the first one, [1,3,14,15], which is sorted.

So, in this case, splitting only the first number is enough to sort the array.

But splitting all numbers doesn't result in a sorted array.

So, in this case, splitting all numbers doesn't work, but splitting only some of them does.

This suggests that it's not always sufficient to split all numbers; sometimes, splitting only some of them is necessary.

But this complicates things because it means I need to consider all possible combinations of splits.

Given that n can be up to 50, and each number can be split or not (if >=10), this could lead to an exponential number of possibilities, which is not feasible.

I need a better approach.

Perhaps I can model this as a sequence of digits, considering that splitting allows me to insert digits into the array while maintaining their order.

So, I can think of the array as a sequence of digits, where some digits are grouped into numbers >=10.

Then, splitting allows me to ungroup these digits.

I need to see if, after ungrouping some of these digits, the sequence is sorted.

This seems similar to sorting a sequence where some elements are locked together.

But I need to find a way to check this efficiently.

Let me consider that after all possible splits, the array is a sequence of digits, each less than 10, and I need to check if this sequence is sorted.

But as seen in the earlier example, splitting all numbers may not be necessary or sufficient.

So, perhaps I need to find a way to determine if there's a way to split some numbers to make the sequence sorted, without having to check all possible combinations.

I need to find a condition that allows me to decide this efficiently.

Let me consider that the minimal value for each position is the smallest digit in the number if it's >=10, or the number itself if it's <10.

Similarly, the maximal value is the number itself if it's <10, or the number if it's >=10 and not split.

But I need to ensure that the sequence is sorted, meaning that each position is <= the next position.

This seems too vague.

Let me think about dynamic programming.

Define dp[i] as whether the subarray from position 0 to i-1 can be sorted by splitting some numbers.

But I'm not sure how to transition between states.

This seems complicated.

Let me consider that splitting a number into digits allows me to have more flexibility, but I need to maintain the relative order of the digits.

So, perhaps I can iterate through the array and keep track of the possible digits that can be inserted at each step.

But this seems too broad.

Wait, maybe I can think in terms of the digits' values and ensure that each inserted digit is >= the previous digit in the sequence.

But I need to consider that splitting a number allows me to insert multiple digits in sequence.

This is getting too involved.

Let me consider that after splitting, the array consists only of single-digit numbers.

Because any number >=10 is split into its digits, which are <10.

So, the final array after all splits consists only of single-digit numbers.

Therefore, the problem reduces to checking if the sequence of digits, after splitting all necessary numbers, is sorted in non-decreasing order.

But the issue is that splitting a number increases the array's length, inserting multiple digits in place of one number.

So, I need to see if there's a way to split some numbers to achieve a sorted sequence of digits.

This seems tricky.

Let me consider that for each number, if it's >=10, I can choose to split it or keep it as is.

If I keep it, it remains as one number.

If I split it, it becomes its digits.

Then, I need to arrange these choices such that the resulting sequence is sorted.

Given the constraints, perhaps I can model this as a graph where each number is a node, and edges represent possible splits, and then find a path that is sorted.

But this seems too complex.

Let me think differently.

Suppose I have the array [a1, a2, ..., an].

I need to transform it into a sequence of digits by splitting some numbers, and then check if this sequence is sorted.

I need to find a way to decide which numbers to split to achieve a sorted sequence.

Given the time constraints, I need an efficient solution.

Perhaps I can iterate through the array and try to build the sorted sequence step by step.

At each step, for each number, consider whether to split it or not (if it's >=10), and choose the option that allows the sequence to remain sorted.

This sounds like a greedy approach.

Let me try to formalize this.

Start with an empty sequence.

Iterate through the array:

- For each number:

- If it's less than 10, add it to the sequence.

- If it's greater than or equal to 10, decide whether to split it into digits or keep it as is.

- Choose the option that allows the sequence to remain sorted.

- If at any point, no choice allows the sequence to remain sorted, return NO.

- If the entire array is processed and the sequence is sorted, return YES.

This seems promising.

Let me try this approach with the first example.

Example 1:

n=4

a=[12,3,45,67]

Start with an empty sequence.

First number: 12 (>=10), so choose to split it into 1 and 2.

Add 1 and 2 to the sequence: [1,2]

Second number: 3 (<10), add it to the sequence: [1,2,3]

Third number: 45 (>=10), can choose to split it into 4 and 5 or keep it as 45.

If I split it into 4 and 5, the sequence becomes [1,2,3,4,5]

If I keep it as 45, the sequence becomes [1,2,3,45]

Both options are sorted.

Fourth number: 67 (>=10), can choose to split it into 6 and 7 or keep it as 67.

If I split it into 6 and 7, the sequence becomes [1,2,3,4,5,6,7]

If I keep it as 67, the sequence becomes [1,2,3,45,67]

Both are sorted.

So, in this case, it's possible to make the array sorted.

Now, let's try the second example.

Example 2:

n=3

a=[12,28,5]

Start with an empty sequence.

First number: 12 (>=10), choose to split it into 1 and 2.

Add 1 and 2 to the sequence: [1,2]

Second number: 28 (>=10), choose to split it into 2 and 8.

Add 2 and 8 to the sequence: [1,2,2,8]

Third number: 5 (<10), add it to the sequence: [1,2,2,8,5]

This sequence is not sorted.

Alternatively, if I keep 28 as is, the sequence becomes [1,2,28,5].

Which is also not sorted.

So, in this case, it's impossible to make the array sorted.

Third example:

n=2

a=[0,0]

Both numbers are <10, so add them directly: [0,0], which is sorted.

So, YES.

This approach seems to work for these examples.

Let me try another example to verify.

Example:

n=3

a=[15,2,3]

Start with empty sequence.

First number: 15 (>=10), choose to split it into 1 and 5.

Add 1 and 5 to the sequence: [1,5]

Second number: 2 (<10), add it to the sequence: [1,5,2]

Which is not sorted.

Alternatively, if I keep 15 as is, the sequence becomes [15,2], which is not sorted.

So, in this case, it's impossible to make the array sorted.

Another example:

n=3

a=[20,1,2]

Start with empty sequence.

First number: 20 (>=10), choose to split it into 2 and 0.

Add 2 and 0 to the sequence: [2,0]

Second number: 1 (<10), add it to the sequence: [2,0,1]

Which is not sorted.

If I keep 20 as is, the sequence becomes [20,1], which is not sorted.

So, impossible to sort.

Another example:

n=3

a=[11,11,11]

Start with empty sequence.

First number: 11 (>=10), choose to split it into 1 and 1.

Add 1 and 1 to the sequence: [1,1]

Second number: 11 (>=10), choose to split it into 1 and 1.

Add 1 and 1 to the sequence: [1,1,1,1]

Third number: 11 (>=10), choose to split it into 1 and 1.

Add 1 and 1 to the sequence: [1,1,1,1,1,1]

Which is sorted.

So, YES.

Another example:

n=3

a=[13,14,15]

Start with empty sequence.

First number: 13 (>=10), choose to split it into 1 and 3.

Add 1 and 3 to the sequence: [1,3]

Second number: 14 (>=10), choose to split it into 1 and 4.

Add 1 and 4 to the sequence: [1,3,1,4]

Which is not sorted.

If I keep 14 as is, the sequence becomes [1,3,14]

Now, third number: 15 (>=10), choose to split it into 1 and 5.

Add 1 and 5 to the sequence: [1,3,14,1,5]

Which is not sorted.

If I keep 15 as is, the sequence becomes [1,3,14,15]

Which is sorted.

Wait, but 3 < 14 < 15, so [1,3,14,15] is sorted.

So, in this case, it's possible to make the array sorted by not splitting 14 and keeping 15 as is.

So, YES.

But in my earlier thought, I thought it was NO, but actually, it's YES.

So, my initial approach might have a flaw.

Wait, in the earlier thought, I considered splitting all numbers, but in this case, splitting only 13 is enough to make the array sorted.

So, perhaps the approach should be to split only the numbers that are necessary, rather than splitting all numbers.

This complicates the approach because I need to decide for each number whether to split it or not, to achieve a sorted sequence.

Given the time constraints, I need an efficient way to do this.

Let me consider that for each number, if it's >=10, I can choose to split it or keep it, and I need to choose the option that allows the sequence to remain sorted.

So, at each step, I need to choose the option that allows the sequence to continue being sorted.

Let me try to formalize this.

Initialize an empty list 'result'.

Initialize a variable 'prev' to store the previous value in 'result'.

Iterate through each number in the array:

if number < 10:

if result is empty or number >= prev:

add number to result

set prev to number

else:

return NO

else: # number >=10

digits = list of digits in number

if can insert digits into result such that the sequence remains sorted:

insert digits into result at appropriate positions

update prev accordingly

else:

return NO

But inserting digits into arbitrary positions sounds problematic.

Alternatively, perhaps I can iterate through the array and, for each number, decide whether to split it or keep it, ensuring that the sequence remains sorted.

But this still seems too vague.

Let me consider that after splitting, the array becomes a sequence of digits, and I need to check if this sequence is sorted.

But as seen in earlier examples, sometimes splitting all numbers >=10 results in a sorted sequence, and sometimes it doesn't.

Moreover, sometimes splitting only some numbers is enough.

This suggests that splitting all numbers >=10 might not be the best approach.

But given the time constraints, I need a way to determine if it's possible to sort the array without checking all possible combinations.

Let me consider that the minimal possible value for a position is the smallest digit in the number if it's >=10, or the number itself if it's <10.

Similarly, the maximal possible value is the number itself if it's <10, or the highest digit if it's >=10 and split.

Wait, perhaps I can iterate through the array and keep track of the maximum value so far, considering the possible splits.

At each step, ensure that the next element (or its minimal possible value) is >= the maximum so far.

But I need to formalize this.

Let me try to define for each number in the array:

- If the number is <10, its value is fixed.

- If the number is >=10, its minimal possible value is its smallest digit, and its maximal possible value is the number itself.

Wait, but splitting it into digits can introduce multiple digits, not just the minimal one.

This is getting too complicated.

Let me think differently.

Suppose I split all numbers >=10 into their digits.

Then, I have a sequence of single-digit numbers.

If this sequence is sorted, then the answer is YES.

Otherwise, it's NO.

But in the earlier example, [13,14,15], splitting all numbers gives [1,3,1,4,1,5], which is not sorted, but splitting only 13 gives [1,3,14,15], which is sorted.

So, in this case, splitting all numbers doesn't result in a sorted sequence, but splitting only some numbers does.

Therefore, splitting all numbers >=10 is not always the correct approach.

Hence, I need a way to decide which numbers to split and which to keep to achieve a sorted sequence.

Given the time constraints, I need an efficient solution, preferably O(n) time.

Perhaps I can iterate through the array and, for each number, check if it's possible to either keep it or split it to maintain the sorted order.

Let me try to formalize this.

Initialize an empty list 'result'.

Initialize 'prev' to -1 (since all numbers are >=0).

For each number in the array:

if number < 10:

if prev <= number:

add number to result

set prev to number

else:

return NO

else: # number >=10

digits = list of digits in number

if all digits >= prev:

insert digits into result

set prev to the last digit

else:

if number >= prev:

add number to result

set prev to number

else:

return NO

This seems like a possible approach.

Let me test it with the first example.

Example 1:

n=4

a=[12,3,45,67]

Initialize result=[], prev=-1

First number: 12 >=10

Digits: [1,2]

Check if all digits >= prev (-1): 1 >= -1 and 2 >= -1 → yes

Insert digits into result: [1,2]

Set prev=2

Second number: 3 <10

Check if prev <= 3: 2 <= 3 → yes

Add 3 to result: [1,2,3]

Set prev=3

Third number: 45 >=10

Digits: [4,5]

Check if all digits >= prev (3): 4 >=3 and 5>=3 → yes

Insert digits into result: [1,2,3,4,5]

Set prev=5

Fourth number: 67 >=10

Digits: [6,7]

Check if all digits >= prev (5): 6>=5 and 7>=5 → yes

Insert digits into result: [1,2,3,4,5,6,7]

Set prev=7

The sequence is sorted, so return YES.

Good.

Second example:

n=3

a=[12,28,5]

Initialize result=[], prev=-1

First number: 12 >=10

Digits: [1,2]

All digits >= -1: yes

Insert digits: [1,2]

Set prev=2

Second number: 28 >=10

Digits: [2,8]

All digits >= prev (2): 2>=2 and 8>=2 → yes

Insert digits: [1,2,2,8]

Set prev=8

Third number: 5 <10

Check if prev <=5: 8 <=5 → no

Return NO

Which matches the expected output.

Third example:

n=2

a=[0,0]

Initialize result=[], prev=-1

First number: 0 <10

0 >= -1 → yes

Add 0 to result: [0]

Set prev=0

Second number: 0 <10

0 >=0 → yes

Add 0 to result: [0,0]

Set prev=0

The sequence is sorted, so return YES.

Another example:

n=3

a=[15,2,3]

Initialize result=[], prev=-1

First number: 15 >=10

Digits: [1,5]

All digits >= -1: yes

Insert digits: [1,5]

Set prev=5

Second number: 2 <10

Check if prev <=2: 5 <=2 → no

Return NO

Which is correct, as in this case, it's impossible to sort the array.

Another example:

n=3

a=[20,1,2]

Initialize result=[], prev=-1

First number: 20 >=10

Digits: [2,0]

All digits >= -1: yes

Insert digits: [2,0]

Set prev=0

Second number: 1 <10

Check if prev <=1: 0 <=1 → yes

Add 1 to result: [2,0,1]

Set prev=1

Third number: 2 <10

Check if prev <=2: 1 <=2 → yes

Add 2 to result: [2,0,1,2]

But [2,0,1,2] is not sorted.

But according to this approach, it would return YES, which is incorrect.

So, this approach has a flaw.

In this case, when splitting 20 into [2,0], and then adding 1 and 2, the sequence [2,0,1,2] is not sorted.

But according to the approach, it would return YES, which is wrong.

Hence, this approach is insufficient.

I need to find a better way.

Let me consider that when splitting a number, I need to ensure that all its digits are >= the previous element in the sequence and that the digits are in non-decreasing order.

Wait, but digits of a number are not necessarily in non-decreasing order.

For example, in 15, digits are [1,5], which is sorted.

In 45, digits are [4,5], which is sorted.

In 67, digits are [6,7], which is sorted.

So, perhaps I can assume that the digits of a number are always in non-decreasing order, but that's not always true.

For example, in 31, digits are [3,1], which is not sorted.

Wait, but according to the problem, when splitting a number, the digits are inserted in the same order they appear in the number.

So, for 31, splitting it would give [3,1], which is not sorted.

In such cases, splitting such a number would make it harder to sort the array.

So, perhaps I need to consider whether splitting a number with digits in non-increasing order can still lead to a sorted sequence.

This seems complicated.

Let me think differently.

Suppose I build the sequence step by step, and at each step, I ensure that the elements added are >= the previous element in the sequence.

For numbers <10, I just add them as is.

For numbers >=10, I can choose to split them into digits or keep them as is.

I need to choose the option that allows the sequence to remain sorted.

Let me try to implement this logic.

Initialize result=[]

Initialize prev=-1

For each number in the array:

if number <10:

if number >= prev:

add number to result

set prev to number

else:

return NO

else: # number >=10

digits = list of digits in number

if all digits >= prev:

insert digits into result

set prev to the last digit

else:

if number >= prev:

add number to result

set prev to number

else:

return NO

This is similar to my earlier approach.

Let me test it with the previous problematic example.

Problematic example:

n=3

a=[20,1,2]

Initialize result=[], prev=-1

First number: 20 >=10

Digits: [2,0]

Check if all digits >= prev (-1): 2>=-1 and 0>=-1 → yes

Insert digits into result: [2,0]

Set prev=0

Second number:1 <10

Check if 1 >= prev (0): 1>=0 → yes

Add 1 to result: [2,0,1]

Set prev=1

Third number:2 <10

Check if 2 >= prev (1): 2>=1 → yes

Add 2 to result: [2,0,1,2]

But [2,0,1,2] is not sorted.

So, according to this approach, it would return YES, which is incorrect.

Hence, this approach is flawed.

I need to find a better way.

Perhaps I need to ensure that, when splitting a number, all its digits are >= the previous element in the sequence and that the digits are in non-decreasing order.

Wait, but in the example above, [2,0,1,2], the digits [2,0] are not in non-decreasing order.

So, maybe I need to ensure that the digits of a split number are in non-decreasing order.

But in the earlier example, 20's digits are [2,0], which are not sorted.

So, perhaps I need to check if the digits of the number are in non-decreasing order before splitting.

If they are, then splitting is safe.

If not, then I can't split the number.

Wait, but in the earlier example, if I don't split 20, and keep it as 20, then the sequence becomes [20,1,2], which is not sorted.

If I split 20 into [2,0], I get [2,0,1,2], which is not sorted.

So, in this case, it's impossible to sort the array.

Hence, the approach should return NO.

So, perhaps I need to modify the approach to ensure that, when splitting a number, its digits are in non-decreasing order.

Let me try to formalize this.

Initialize result=[]

Initialize prev=-1

For each number in the array:

if number <10:

if number >= prev:

add number to result

set prev to number

else:

return NO

else: # number >=10

digits = list of digits in number

if digits are in non-decreasing order and all digits >= prev:

insert digits into result

set prev to the last digit

elif number >= prev:

add number to result

set prev to number

else:

return NO

Let me test this with the problematic example.

Example:

n=3

a=[20,1,2]

Initialize result=[], prev=-1

First number: 20 >=10

Digits: [2,0]

Are digits in non-decreasing order? 2 >=0 → no

So, don't split, check if 20 >= prev (-1): yes

Add 20 to result: [20]

Set prev=20

Second number:1 <10

Check if 1 >= prev (20): 1 >=20 → no

Return NO

Which is correct.

Another example:

n=3

a=[15,2,3]

Initialize result=[], prev=-1

First number:15 >=10

Digits: [1,5]

Are digits in non-decreasing order? 1 <=5 → yes

All digits >= prev (-1): yes

Insert digits into result: [1,5]

Set prev=5

Second number:2 <10

Check if 2 >= prev (5): 2 >=5 → no

Return NO

Which is correct.

Another example:

n=3

a=[13,14,15]

Initialize result=[], prev=-1

First number:13 >=10

Digits: [1,3]

Are digits in non-decreasing order? 1<=3 → yes

All digits >= prev (-1): yes

Insert digits into result: [1,3]

Set prev=3

Second number:14 >=10

Digits: [1,4]

Are digits in non-decreasing order? 1<=4 → yes

All digits >= prev (3): 1 >=3 → no

So, don't split, check if 14 >= prev (3): yes

Add 14 to result: [1,3,14]

Set prev=14

Third number:15 >=10

Digits: [1,5]

Are digits in non-decreasing order? 1<=5 → yes

All digits >= prev (14): 1 >=14 → no

So, don't split, check if 15 >= prev (14): yes

Add 15 to result: [1,3,14,15]

Set prev=15

The sequence [1,3,14,15] is sorted, so return YES

Which is correct.

Another example:

n=4

a=[12,3,45,67]

Initialize result=[], prev=-1

First number:12 >=10

Digits: [1,2]

Are digits in non-decreasing order? 1<=2 → yes

All digits >= prev (-1): yes

Insert digits into result: [1,2]

Set prev=2

Second number:3 <10

Check if 3 >= prev (2): yes

Add 3 to result: [1,2,3]

Set prev=3

Third number:45 >=10

Digits: [4,5]

Are digits in non-decreasing order?