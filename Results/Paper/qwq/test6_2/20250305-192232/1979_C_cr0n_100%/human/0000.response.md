Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome. The goal is to distribute my bets in such a way that no matter which outcome wins, the amount I get back is more than the total amount I bet.

First, I need to understand the constraints. For each test case, I'm given n (the number of outcomes), and then a list of k_i values, which are the multipliers for each outcome. The k_i values are at least 2, which makes sense because if it were 1, you'd just get your money back, which doesn't help in coming out ahead.

The problem says that exactly one of the n outcomes will be winning, and I need to ensure that for whichever outcome wins, the amount I get back is greater than the total amount I bet on all outcomes.

So, let's think about what this means mathematically. Let's denote the bet on the i-th outcome as x_i. The total bet is S = x_1 + x_2 + ... + x_n.

If the i-th outcome wins, I get back k_i * x_i coins. I need this to be greater than S, the total bet. So, for each i, k_i * x_i > S.

But S is the sum of all x_j, including x_i. So, S = x_1 + x_2 + ... + x_n.

Therefore, for each i, k_i * x_i > x_1 + x_2 + ... + x_n.

This seems a bit tricky. I need to find integer values for x_i such that this inequality holds for every i.

Let me try to rearrange this inequality.

k_i * x_i > S

But S = sum of all x_j, so:

k_i * x_i > sum_{j=1 to n} x_j

I can write this as:

k_i * x_i - x_i > sum_{j ≠ i} x_j

Because sum_{j=1 to n} x_j = x_i + sum_{j ≠ i} x_j

So:

k_i * x_i - x_i > sum_{j ≠ i} x_j

Which simplifies to:

x_i * (k_i - 1) > sum_{j ≠ i} x_j

This seems more manageable.

I need this to hold for every i.

This is a system of inequalities that I need to satisfy simultaneously.

This seems like a problem that might involve finding a common multiple or something related to the least common multiple (LCM), given that the multipliers are involved.

Let me consider an example to get a better understanding.

Take the first example from the input:

3

3 2 7

So, n=3, k1=3, k2=2, k3=7

According to the sample output, one possible solution is 27 41 12.

Let's check if this satisfies the conditions.

Total bet S = 27 + 41 + 12 = 80

If outcome 1 wins: 3*27 = 81 > 80

If outcome 2 wins: 2*41 = 82 > 80

If outcome 3 wins: 7*12 = 84 > 80

Yes, it satisfies the condition for all outcomes.

Now, how can I generalize this to find such x_i values for any given set of k_i?

Looking at the code provided, it seems to be attempting to solve this problem.

Let's look at the code step by step.

First, it reads the number of test cases, cases, and then loops through each test case by calling func_2() for each one.

func_2() reads n and the list of k_i values.

Then, it initializes den as the first k_i value and iterates through all k_i, computing the least common multiple (LCM) of all k_i using func_1(), which calculates the LCM of two numbers using their greatest common divisor (GCD).

So, den becomes the LCM of all k_i.

Then, it calculates vprod as a list where each element is den divided by the corresponding k_i.

So, vprod[i] = den / k_i.

Then, it calculates den as den - sum(vprod).

If den <= 0, it prints -1, else it prints the vprod list.

Wait a minute, this seems suspicious.

Let me verify with the first example.

n=3, k=[3,2,7]

LCM of 3,2,7 is 42.

vprod = [42/3, 42/2, 42/7] = [14,21,6]

sum(vprod) = 14+21+6 = 41

den = 42 - 41 = 1, which is greater than 0, so it should print 14 21 6.

But in the sample output, it's 27 41 12, which sums to 80.

So, why is the code producing 14 21 6 in this case, while the sample output is different?

Wait, perhaps I misread the code.

Looking back, the code actually calculates den as the LCM of all k_i, then vprod as den // k_i for each i, then den as den - sum(vprod).

But in the sample output, it's printing vprod as 27 41 12, which doesn't match the LCM approach directly.

Wait, perhaps the code is different from what I thought.

Looking back, in the code:

den = den - sum(vprod)

if den <=0:

print(-1)

else:

print vprod

But in the first test case, den = 42 - 41 =1 >0, so it should print 14 21 6, but the sample output is 27 41 12.

Hmm, maybe I need to understand the code correctly.

Wait, perhaps the bets are being scaled up by den.

Let me think differently.

Suppose I have vprod as [14,21,6], and den=1.

Maybe I need to multiply each vprod by den to get the actual bets.

But den=1 in this case, so bets would be [14,21,6], but in the sample output, it's [27,41,12].

This doesn't match.

Wait, perhaps the code is incorrect.

Alternatively, maybe I need to scale up the bets so that den is a common multiple that makes the inequalities hold.

Wait, perhaps I need to find a common multiple where den is greater than the sum of vprod.

But in the first example, den=1, which is less than sum(vprod)=41, but according to the code, it's den=42 -41=1, which is less than sum(vprod), but the condition is den >0.

Wait, the condition is den > sum(vprod), but in the code, it's den = den - sum(vprod), and check if den >0.

Wait, perhaps I need to think differently.

Let me try to derive a general solution.

I need to find x_i such that for each i, k_i * x_i > sum_{j=1 to n} x_j

Let’s denote S = sum_{j=1 to n} x_j

So, for each i, k_i * x_i > S

But S = x_1 + x_2 + ... + x_n

So, for each i, k_i * x_i > x_1 + x_2 + ... + x_n

This can be rewritten as:

k_i * x_i - x_i > x_1 + x_2 + ... + x_{i-1} + x_{i+1} + ... + x_n

x_i * (k_i - 1) > S - x_i

But S = sum_{j=1 to n} x_j, so S - x_i = sum_{j ≠ i} x_j

So, x_i * (k_i - 1) > sum_{j ≠ i} x_j

This seems similar to what I had before.

This is a system of inequalities that needs to be satisfied simultaneously.

This seems a bit tricky. Maybe there's a way to find x_i in terms of a common multiple.

Let me consider that x_i = C / k_i, where C is some common multiple.

Wait, but x_i needs to be integers, and C needs to be chosen such that k_i * x_i > sum(x_j)

If x_i = C / k_i, then k_i * x_i = C, which needs to be greater than sum(x_j) for all i.

Sum(x_j) = sum(C / k_j) for j=1 to n

So, for all i, C > sum_{j=1 to n} (C / k_j)

Divide both sides by C: 1 > sum_{j=1 to n} (1 / k_j)

This implies that sum_{j=1 to n} (1 / k_j) < 1

If this condition holds, then I can choose C such that C > sum_{j=1 to n} (C / k_j)

But this seems too general. Maybe I need to find the minimal C that satisfies this.

Wait, but in the sample input, sum of 1/k_j for n=3, k=[3,2,7]:

1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 <1

Which is less than 1.

In the second test case, n=2, k=[3,3]:

1/3 + 1/3 = 2/3 <1

In the third test case, n=5, k=[5,5,5,5,5]:

5*(1/5) =1, which is not less than 1, so sum_{j=1 to n} (1 / k_j) =1, which is not less than 1, so no solution, hence -1 in the sample output.

In the fourth test case, n=6, k=[7,9,3,17,9,13]:

sum of 1/k_j = 1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13

Let's calculate this:

1/3 ≈ 0.3333

1/7 ≈ 0.1429

1/9 ≈ 0.1111, so 2/9 ≈ 0.2222

1/13 ≈ 0.0769

1/17 ≈ 0.0588

Sum ≈ 0.3333 + 0.1429 + 0.2222 + 0.0769 + 0.0588 ≈ 0.8341 <1

So, solution exists.

Fifth test case, n=3, k=[6,3,2]:

1/6 + 1/3 + 1/2 = 1/6 + 2/6 + 3/6 = 6/6 =1, so sum=1, no solution, hence -1.

Sixth test case, n=5, k=[9,4,6,8,3]:

1/9 + 1/4 + 1/6 + 1/8 + 1/3

Let's find a common denominator, say 72:

(8 + 18 + 12 + 9 + 24)/72 = 71/72 <1, so solution exists.

So, it seems that the condition sum_{j=1 to n} (1 / k_j) <1 is necessary for a solution to exist.

If this sum is less than 1, then a solution exists; otherwise, it doesn't.

This seems to align with the sample outputs.

Now, assuming that sum_{j=1 to n} (1 / k_j) <1, how do I find the x_i values?

From earlier, we have x_i = C / k_i, and C > sum_{j=1 to n} (C / k_j)

Which simplifies to C > sum(x_j), which is automatically satisfied if C is large enough.

But in practice, to ensure that C is an integer and satisfies all inequalities, I need to choose C such that C is a multiple of all k_i, i.e., C is the least common multiple (LCM) of all k_i.

Then, x_i = C / k_i, and k_i * x_i = C.

And sum(x_j) = sum(C / k_j) = C * sum(1 / k_j)

Since sum(1 / k_j) <1, then C > C * sum(1 / k_j), which holds.

Therefore, choosing C as the LCM of all k_i, and x_i = C / k_i, should satisfy the conditions.

But in the first sample input, LCM of 3,2,7 is 42.

Then x_i = [42/3, 42/2, 42/7] = [14,21,6], sum=41.

And for each i, k_i * x_i =42, which is greater than 41.

So, why is the sample output [27,41,12], which sums to 80, and k_i * x_i =81,82,84, which are all greater than 80.

But according to the above, [14,21,6] also satisfies the condition, as 42 >41.

So, why is the output [27,41,12] instead of [14,21,6]?

Wait, perhaps the code is doing something else.

Looking back at the code:

den = LCM of all k_i

vprod = [den // k_i for each k_i]

then den = den - sum(vprod)

if den <=0:

print(-1)

else:

print vprod

In the first test case, den=42, vprod=[14,21,6], sum(vprod)=41, den=42-41=1.

But it prints vprod=[14,21,6], but the sample output is [27,41,12].

This suggests that the code might be incorrect, or perhaps there's another step.

Wait, maybe the bets need to be scaled up by den.

Let's see: if I multiply vprod by den, where den=1, then [14,21,6] remains the same, but sample output is [27,41,12].

This doesn't match.

Alternatively, perhaps the bets need to be vprod[i] * den.

But den=1, so it would be [14,21,6], which still doesn't match the sample output.

Wait, maybe I need to multiply vprod by some factor to make sum(vprod)*factor > sum(vprod)*factor.

Wait, this seems confusing.

Perhaps I need to iterate to find the minimal C such that C > sum(C / k_j).

But C is the LCM, which should already satisfy this, as shown earlier.

Alternatively, perhaps the code is incorrect, and the sample output suggests a different approach.

Let me consider another approach.

Suppose I set x_i = C / (k_i -1), for some C.

But this seems arbitrary.

Wait, perhaps I need to ensure that for each i, k_i * x_i > S, where S = sum(x_j)

This is equivalent to x_i > S / k_i

But S = sum(x_j), so for each i, x_i > (sum(x_j)) / k_i

This seems recursive.

Alternatively, perhaps I can set x_i = a_i * t, where t is a scaling factor, and a_i are integer coefficients.

Then, S = t * sum(a_j)

And for each i, k_i * a_i * t > t * sum(a_j)

Divide both sides by t (assuming t>0):

k_i * a_i > sum(a_j)

So, the inequalities are scaled by t, but the condition remains the same.

Therefore, I can choose t=1, and find a_i such that k_i * a_i > sum(a_j) for all i.

This seems similar to the original problem.

So, perhaps finding any set of a_i that satisfies this condition, and then setting x_i = a_i, is sufficient.

But how to find such a_i?

One way is to set a_i proportional to some function of k_i.

Looking back, the earlier approach with a_i = LCM / k_i seems to work, as in the first sample input, [14,21,6] sums to 41, and 42 >41.

But the sample output is [27,41,12], which sums to 80, and 81>80, 82>80, 84>80.

So, both [14,21,6] and [27,41,12] are valid solutions for the first test case.

The problem states that if multiple solutions exist, any one can be printed.

So, the code's output of [14,21,6] would also be acceptable.

But in the sample output, it's [27,41,12], which is different.

Perhaps there's another step in the code that I'm missing.

Looking back at the code:

den = LCM of all k_i

vprod = [den // k_i for each k_i]

then den = den - sum(vprod)

if den <=0:

print(-1)

else:

print vprod

In the first test case, den=42, vprod=[14,21,6], sum=41, den=42-41=1>0, so print [14,21,6]

But sample output is [27,41,12], which seems to be a different solution.

Perhaps the code is incorrect, or perhaps there's a misunderstanding in the problem.

Wait, maybe the bets need to be multiplied by den.

Let's see: vprod=[14,21,6], den=1.

Then, bets would be [14*1, 21*1, 6*1] = [14,21,6], which sums to 41.

But in the sample output, it's [27,41,12], which sums to 80.

Wait, 80 is 41 * 2 -1, but that seems arbitrary.

Alternatively, perhaps the bets need to be multiplied by den, which is 1, so it remains the same.

Wait, perhaps the bets need to be multiplied by some factor to make den positive.

But in this case, den=1, which is already positive.

I'm getting confused.

Let me consider that the minimal C is LCM multiplied by some factor.

But in the first test case, C=42 works, as 42 >41.

But the sample output seems to be using C=81, since 3*27=81, 2*41=82, 7*12=84, all greater than 80.

But why choose C=81 instead of C=42?

Wait, perhaps the code is incorrect.

Let me check another test case.

Second test case:

n=2, k=[3,3]

LCM=3

vprod=[1,1]

sum(vprod)=2

den=3-2=1>0, so print [1,1], which matches the sample output.

Third test case:

n=5, k=[5,5,5,5,5]

LCM=5

vprod=[1,1,1,1,1]

sum(vprod)=5

den=5-5=0 <=0, so print -1, which matches the sample output.

Fourth test case:

n=6, k=[7,9,3,17,9,13]

LCM of these numbers: let's see, LCM of 7,9,3,17,9,13.

First, LCM of 7 and 9 is 63.

LCM of 63 and 3 is 63.

LCM of 63 and 17 is 1071.

LCM of 1071 and 9 is still 1071.

LCM of 1071 and 13 is 1071*13=13923.

Wait, but in the sample output, the bets are [1989,1547,4641,819,1547,1071], which sums to 11613.

Now, 13923 -11613=2310, which is greater than 0.

And 13923 >11613, so it satisfies the condition.

But according to the code, vprod=[13923/7,13923/9,13923/3,13923/17,13923/9,13923/13]

Which is [1989,1547,4641,819,1547,1071], sum=11613.

den=13923-11613=2310>0, so it prints [1989,1547,4641,819,1547,1071], which matches the sample output.

Fifth test case:

n=3, k=[6,3,2]

LCM=6

vprod=[1,2,3]

sum=6

den=6-6=0 <=0, so print -1, which matches the sample output.

Sixth test case:

n=5, k=[9,4,6,8,3]

LCM=72

vprod=[8,18,12,9,24]

sum=71

den=72-71=1>0, so print [8,18,12,9,24], which matches the sample output.

Wait, but in the first test case, the code would print [14,21,6], but the sample output is [27,41,12].

So, perhaps there are multiple solutions, and the code is providing a different one from the sample.

But in the fourth test case, the code's output matches the sample output.

Wait, perhaps the code is correct, and the sample output is just one of the possible solutions.

The problem states that if multiple solutions exist, any one can be printed.

So, in the first test case, both [14,21,6] and [27,41,12] are valid solutions.

Similarly, in the sixth test case, [8,18,12,9,24] is a valid solution.

Therefore, the code is correct, as it provides a valid solution for each test case, whenever one exists.

Hence, Correctness: **True**

**Final Solution**
To solve this problem, we need to determine how to distribute coins among various outcomes in a game such that, regardless of which outcome wins, the returned coins are more than the total coins bet. This must be achieved by adhering to the game's rules and constraints provided.

### Approach

1. **Understanding the Problem:**
   - We have `n` outcomes, each with a multiplier `k_i`.
   - We need to bet integer amounts `x_i` on each outcome.
   - The total coins bet should be less than the coins received for any winning outcome.

2. **Mathematical Formulation:**
   - Let `S` be the total coins bet: `S = x_1 + x_2 + ... + x_n`.
   - For each outcome `i`, the condition is `k_i * x_i > S`.

3. **Solution Strategy:**
   - Calculate the Least Common Multiple (LCM) of all `k_i`. This ensures that `k_i` divides the LCM.
   - Set each bet `x_i` to be `LCM // k_i`.
   - Verify if the sum of all `x_i` is less than the LCM. If it is, the solution is valid; otherwise, no solution exists.

4. **Implementation:**
   - Use the LCM to calculate the bets.
   - Check if the LCM minus the sum of the bets is positive. If yes, print the bets; else, print `-1`.

### Solution Code

```python
from math import gcd

def func_1(a, b):
    return a * b // gcd(a, b)

def func_2():
    N = int(input().strip())
    vals = [int(r) for r in input().strip().split()]
    den = vals[0]
    for x in vals:
        den = func_1(den, x)
    vprod = [den // r for r in vals]
    s_sum = sum(vprod)
    if den > s_sum:
        print(' '.join([str(x) for x in vprod]))
    else:
        print(-1)

cases = int(input())
for _ in range(cases):
    func_2()
```

### Explanation

1. **Reading Input:**
   - Read the number of test cases.
   - For each test case, read `n` and the list of multipliers `k_i`.

2. **Calculating LCM:**
   - Compute the LCM of all `k_i` values using the `func_1` function which calculates LCM of two numbers.

3. **Calculating Bets:**
   - Calculate the bet for each outcome as `vprod[i] = LCM // k_i`.

4. **Validation:**
   - Sum all bets and check if `LCM > sum(vprod)`.
   - If true, print the bets; otherwise, print `-1`.

This approach ensures that the bets are distributed correctly to satisfy the game's conditions for each test case.