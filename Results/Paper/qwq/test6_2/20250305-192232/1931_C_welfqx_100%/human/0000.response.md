Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation allows me to select three integers i, j, x, where 1 ≤ i ≤ j ≤ n, and set all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles. My goal is to make all elements of the array equal, and I need to find the least amount of burles I need to spend to achieve this.

First, I need to understand what the operation does. It lets me change a contiguous subarray to a single value, and the cost is the length of that subarray. I can do this operation at most once. So, I need to think about how to use this operation to make the entire array equal, possibly without using the operation at all if the array is already equal or if I can make adjustments in a way that minimizes the cost.

Looking at the examples:

- For the array [1, 2, 3, 4, 5, 1], the output is 4. Maybe I can set indices 2 to 5 to 1, making the array [1,1,1,1,1,1], with a cost of 4.

- For [1,1,1,1,1,1,1], the output is 0, which makes sense because all elements are already equal.

- For [8,8,8,1,2,8,8,8], the output is 2. Maybe setting indices 4 and 5 to 8, making the array [8,8,8,8,8,8,8,8], with a cost of 2.

- For [1], the output is 0, which is straightforward.

- For [1,2], the output is 1. Maybe setting either index to match the other with a cost of 1.

- For [1,2,3], the output is 2. Maybe setting two elements to match the third one.

- For [4,3,2,7,1,1,3], the output is 6.

- For [9,9,2,9,2,5,5,5,3], the output is 7.

From these examples, it seems like the strategy is to find the largest contiguous subarray that already has the same value and then use the operation to set the remaining parts to that value, minimizing the cost.

Wait, but I can only perform the operation once. So, I need to choose a value to set the entire array to and decide which part to change in one go.

Let me think differently. If I can perform the operation only once, I can choose to set a certain subarray to a specific value. To make the entire array equal, I need to ensure that all elements are the same, which means that either I don't perform the operation if the array is already equal, or I perform the operation in such a way that the changed subarray helps unify the array.

But it's tricky because I can only do it once. Maybe the key is to choose a value that appears frequently in the array and try to minimize the cost of changing the rest to that value.

Wait, but I can only change one subarray in one operation. So, perhaps I should look for the largest subarray where all elements are already equal to the value I choose, and then change the rest in one operation.

Hmm, maybe that's not the right approach.

Let me consider that I can set a subarray to a certain value, and the rest of the array remains as is, but I need the entire array to have the same value after the operation. That means that the subarray I change should cover all the elements that don't match the value I want for the entire array.

Wait, perhaps it's better to think in terms of making the entire array equal to a specific value with at most one operation.

So, suppose I choose a value x that I want all elements to be. Then, I need to set all elements that are not x to x. But I can only do one operation, which allows me to set a subarray to x.

So, to minimize the cost, I need to choose the subarray that covers as many non-x elements as possible in one go.

Wait, but if I choose x to be the most frequent value in the array, then the number of operations needed would be minimized because fewer elements are not x.

But since I can only perform one operation, I need to cover all non-x elements in one subarray.

Is that possible? Not necessarily, because the non-x elements might be spread out in the array.

Wait, but the problem allows me to perform the operation only once, meaning I can set one subarray to x, and the rest of the array remains as is, but I need the entire array to be x after the operation.

So, for that to happen, all elements that are not x must be covered by the subarray I choose to set to x.

In other words, the subarray I choose should include all positions where the array has a value different from x.

That way, after setting that subarray to x, all elements in the array are x.

The cost is the length of that subarray.

To minimize the cost, I need to find the smallest subarray that covers all the non-x elements.

Wait, but if I choose x to be the most frequent value in the array, then the number of non-x elements is minimized, and hence the subarray needed to cover them could be smaller.

But I need to make sure that all non-x elements are covered by a single subarray.

So, for a given x, if all non-x elements are contiguous, then I can cover them with one subarray. Otherwise, if they are in multiple disjoint segments, I would need multiple operations, but I can only perform one operation.

Wait, but I can only perform one operation. So, if the non-x elements are not contiguous, I cannot cover them all in one operation.

But the problem states that I can perform the operation at most once, meaning zero or one operation.

So, in the case where the array is already all x, I don't need any operation, and the cost is zero.

If the non-x elements are contiguous, I can set that subarray to x in one operation, with cost equal to the length of that subarray.

If the non-x elements are not contiguous, I cannot cover them all in one operation, meaning I have to leave some non-x elements unchanged, which would mean the array cannot be made entirely x with just one operation.

But the problem says that it can always be done. So, even if the non-x elements are not contiguous, I can still choose to set a subarray that includes some x elements as well, to make the entire array x.

Wait, but if I set a subarray to x, including some x elements, that's fine, as long as all non-x elements are covered by that subarray.

So, to make the entire array x, I need to set a subarray that includes all non-x elements, and possibly some x elements as well.

The cost is the length of that subarray.

To minimize the cost, I need to find the smallest subarray that includes all non-x elements.

So, for a given x, I need to find the smallest subarray that covers all positions where a[i] != x.

If all non-x elements are contiguous, then it's easy, just set that subarray to x.

If they are not contiguous, I need to find the smallest subarray that covers all their positions.

That would be the subarray from the first non-x element to the last non-x element.

So, in other words, find the leftmost position where a[i] != x and the rightmost position where a[j] != x, and set the subarray from i to j to x.

The cost would be j - i + 1.

So, for each possible x, I can calculate this cost, and then choose the x that minimizes this cost.

But there's a catch: x can be any integer, but in the problem, a[i] are integers between 1 and n, inclusive.

So, x can be any integer between 1 and n.

But since n can be up to 2e5, and t up to 1e4, with total n across all test cases up to 2e5, I need an efficient algorithm.

If I iterate over all possible x, which can be up to n=2e5, and for each x, find the min subarray covering all non-x elements, that would be O(n^2), which is too slow.

So, I need a better approach.

Wait, maybe I can observe that the minimal cost for a given x is equal to the distance between the first and last non-x elements.

Specifically, for each x, let's find the leftmost position where a[i] != x, and the rightmost position where a[j] != x, then the minimal subarray covering all non-x elements is from i to j, with cost j - i + 1.

Then, I need to choose x such that this cost is minimized.

So, the problem reduces to finding, among all possible x, the one that minimizes j - i + 1, where i is the leftmost position where a[i] != x, and j is the rightmost position where a[j] != x.

If x is such that all elements are x, then i and j don't exist, meaning no non-x elements, so the cost is 0.

Otherwise, the cost is j - i + 1.

To minimize this, I need to maximize the length of the subarray where a[k] == x for k not in [i,j].

Wait, perhaps it's better to think in terms of the length of the longest subarray where a[k] == x, and then the cost is n - length of this subarray.

Wait, let's see:

If I choose x, and there is a longest subarray where a[k] == x, then to make the entire array x, I need to change the parts before and after this subarray.

But I can only perform one operation, which is to set one subarray to x.

So, perhaps the minimal cost is n - length of the longest subarray where a[k] == x.

Wait, is that correct?

Let me consider:

Suppose I have a subarray where a[k] == x for k in [p, q], and it's the longest such subarray.

Then, to make the entire array x, I need to set the parts before p and after q to x.

But since I can only perform one operation, I need to set a subarray that covers both the prefix before p and the suffix after q.

Wait, but the prefix before p and the suffix after q are not contiguous; they are separate.

So, I cannot cover them with one subarray.

Unless I set the subarray from the first position to q, or from p to the last position.

Wait, let's think differently.

Suppose I choose to set the subarray from 1 to q to x, which has cost q.

Then, the array from p to n would be x, provided that from p to n, only the part from p to q is x, and the rest needs to be set.

Wait, this is getting confusing.

Let me try to find a better way.

Perhaps I can consider that the minimal cost is n - the maximum frequency of any x in the array.

But that doesn't account for the contiguity requirement.

Wait, no, because I can only set one subarray to x, not multiple.

Let me consider the frequency of each x and see.

Wait, maybe I need to find the x that appears the most times in a contiguous subarray.

But that might not be straightforward.

Another idea: the minimal cost is equal to n - the length of the longest subarray with all elements equal to some x.

Because if I set that subarray to x, and the rest to x in one operation, the cost is n - length of that subarray.

Wait, but I can only perform one operation, which is to set one subarray to x.

So, it's not exactly that.

Wait, perhaps I need to find the minimal cost such that, by setting one subarray to x, I can make the entire array x.

Let me consider that.

Suppose I choose x, and I need to set a subarray [i, j] to x, such that, after this operation, all elements in the array are x.

That means that, for all positions k where a[k] != x, must be in the subarray [i, j].

In other words, [i, j] must include all positions where a[k] != x.

So, i is the minimum k where a[k] != x, and j is the maximum k where a[k] != x.

Then, setting [i, j] to x will make all a[k] == x for the entire array.

The cost is j - i + 1.

So, for each possible x, I can compute i and j as the first and last positions where a[k] != x, and then the cost is j - i + 1.

If there are no positions where a[k] != x, the cost is 0.

Then, among all possible x (from 1 to n), I need to choose the x that minimizes j - i + 1.

But x can be any integer from 1 to n, but not necessarily present in the array.

Wait, but in the constraints, a[i] are integers between 1 and n, inclusive.

So, x can be any integer from 1 to n.

But in the operation, I can choose x to be any integer, including those not present in the array.

But choosing x not present in the array would mean that all elements are not x, so I need to set the entire array to x, with cost n.

Which might not be optimal, depending on the array.

So, to minimize j - i + 1, I need to maximize the length of the subarray where a[k] == x.

Because j - i + 1 = (n - length of the longest subarray where a[k] == x).

Wait, is that correct?

Let me see.

Suppose I have a subarray where a[k] == x for k in [p, q], and it's the longest such subarray.

Then, the first position where a[k] != x is before p, and the last position where a[k] != x is after q.

So, i is the minimum k where a[k] != x, which is less than p.

j is the maximum k where a[k] != x, which is greater than q.

Then, j - i + 1 is the length from i to j, which is the part that needs to be set to x.

But actually, the part from p to q is already x, so I need to set from 1 to q and from p to n to x.

But I can only perform one operation, which is to set one subarray to x.

So, perhaps I need to set the subarray from i to j to x in one operation.

Wait, but i could be less than p and j could be greater than q.

But in the operation, I can only set one subarray to x.

So, to cover all positions where a[k] != x, I need to set the subarray from i to j to x.

The cost is j - i + 1.

So, the minimal cost is j - i + 1.

I need to choose x to minimize j - i + 1.

Now, I need to find, among all x, the one where j - i + 1 is minimized.

Where i is the first position where a[k] != x, and j is the last position where a[k] != x.

Wait, but if I choose x such that it appears frequently in the array, then the positions where a[k] != x are minimized, and j - i + 1 is smaller.

So, to minimize j - i + 1, I need to maximize the length of the subarray where a[k] == x.

Wait, perhaps not directly.

Wait, let's think about it differently.

Suppose I choose x, and find all positions where a[k] != x.

Let's say these positions are p1, p2, ..., pm, where p1 < p2 < ... < pm.

Then, to cover all these positions with one subarray, I need to choose a subarray from p1 to pm.

The cost is pm - p1 + 1.

So, for each x, I can find p1 and pm, and compute pm - p1 + 1.

I need to choose x that minimizes this value.

Now, to minimize pm - p1 + 1, I need to minimize the distance between the first and last positions where a[k] != x.

This is equivalent to minimizing the span covered by the non-x elements.

To minimize this span, I need to choose x such that the non-x elements are as close together as possible.

In other words, choose x such that the non-x elements are as compact as possible.

But since I can't control the positions of the non-x elements, I need to choose x such that the non-x elements are minimized and as compact as possible.

Wait, perhaps choosing x to be the most frequent value in the array would help minimize the span.

Wait, perhaps I can find the x with the longest contiguous subarray where a[k] == x.

Then, the span of non-x elements would be from the first position before this subarray to the last position after this subarray.

Wait, I'm getting stuck.

Let me try to think of a different approach.

Another way to look at it is to find the minimal length of a subarray such that, by setting this subarray to x, the entire array becomes x.

This means that all positions where a[k] != x must be included in this subarray.

So, for each x, find the minimal subarray that includes all positions where a[k] != x.

This minimal subarray would be from the first position where a[k] != x to the last position where a[k] != x.

So, for each x, compute i = min{k | a[k] != x}, j = max{k | a[k] != x}, and the cost is j - i + 1.

If there are no positions where a[k] != x, the cost is 0.

Then, among all possible x, choose the one that minimizes j - i + 1.

So, to implement this, for each x, I need to find the first and last positions where a[k] != x, and compute j - i + 1.

Then, take the minimal such value over all x.

But since x can be from 1 to n, and n can be up to 2e5, and t up to 1e4, with total n across all test cases up to 2e5, I need an efficient way to compute this.

One way is to iterate over all x from 1 to n for each test case, but that would be too slow because t * n can be up to 2e5, and for each x, finding i and j would take O(n), which is not feasible.

So, I need a smarter way.

Let me think about the minimal cost.

Suppose I fix x, and find all positions where a[k] != x.

Then, the minimal subarray that covers all these positions is from the minimum of these k to the maximum of these k.

So, for a given x, let's define:

left[x] = min{k | a[k] != x}

right[x] = max{k | a[k] != x}

Then, cost[x] = right[x] - left[x] + 1 if left[x] exists, else 0.

I need to find min_x cost[x]

But computing this naively would be too slow.

Is there a way to compute this more efficiently?

Perhaps I can find the overall left and right boundaries that cover all non-x elements for all x.

Wait, perhaps I can find the overall left and right boundaries that cover all positions where a[k] != x, for each x.

Wait, maybe I can find the minimal cost without explicitly iterating over all x.

Wait, perhaps I can find the minimal j - i + 1 over all possible i and j such that between i and j, all non-x elements are covered.

But I need to consider x as well.

Wait, maybe I can find the minimal window [i, j] such that, by setting [i, j] to some x, the entire array becomes x.

So, I need to choose x and [i, j] such that all a[k] != x are within [i, j].

I need to choose x and [i, j] to minimize j - i + 1.

This seems tricky.

Let me think about it differently.

Suppose I fix the subarray [i, j], and set it to some x.

Then, to make the entire array equal to x, x must be equal to a[k] for all k not in [i, j].

So, for the subarray [i, j], x must be equal to a[k] for all k < i and k > j.

If a[k] for k < i are not all equal, then I cannot choose such an x.

Wait, perhaps I need to consider the values outside [i, j].

This seems complicated.

Let me try to think about the minimal cost.

The minimal cost is the minimal j - i + 1 such that setting [i, j] to some x makes the entire array equal to x.

This means that, outside [i, j], all elements are already equal to x.

So, x must be equal to a[k] for all k < i and for all k > j.

If there are multiple x that satisfy this, I can choose any of them.

So, for a given [i, j], x must be equal to a[k] for all k not in [i, j].

If a[k] are not the same for all k not in [i, j], then no x can satisfy this, meaning that choosing [i, j] doesn't allow me to make the entire array equal.

So, I need to choose [i, j] such that all elements outside [i, j] are equal.

Then, set [i, j] to that value.

The cost is j - i + 1.

So, to minimize the cost, I need to maximize the length of the subarrays before i and after j that are equal to the value outside [i, j].

Wait, perhaps I can think in terms of the longest prefix and suffix that are equal.

Let me consider the following approach:

Find the longest prefix where all elements are equal to some value x.

Find the longest suffix where all elements are equal to some value x.

Then, the minimal cost would be n - (length of longest prefix where a[k] == x) - (length of longest suffix where a[k] == x) + overlap if any.

Wait, perhaps.

Let me formalize this.

Let me define:

- left[x] = length of the longest prefix where a[k] == x

- right[x] = length of the longest suffix where a[k] == x

Then, for a given x, the minimal subarray to set would be from left[x] + 1 to n - right[x].

The cost would be (n - right[x] - left[x])

But I need to make sure that between left[x] + 1 and n - right[x], all elements are covered.

Wait, perhaps not exactly.

Wait, let's think about it.

If I have a longest prefix where a[k] == x, and a longest suffix where a[k] == x, then the part in between needs to be set to x.

The length of that part is n - left[x] - right[x].

But I need to make sure that in the suffix and prefix, a[k] == x.

Wait, perhaps I need to find the minimal j - i + 1 such that setting [i, j] to x makes the entire array equal to x.

This seems similar to finding the minimal j - i + 1 such that all a[k] != x are within [i, j].

So, for each x, find the positions where a[k] != x, then set [i, j] to x, where i is the minimal k where a[k] != x, and j is the maximal k where a[k] != x.

Then, the cost is j - i + 1.

If there are no such k, cost is 0.

So, to minimize this, I need to choose x such that the span from first to last a[k] != x is minimized.

In other words, choose x such that the non-x elements are as close together as possible.

To implement this efficiently, perhaps I can find the minimal difference between the maximum and minimum indices among all positions where a[k] != x, over all x.

But again, iterating over all x from 1 to n is too slow.

Wait, perhaps I can find the minimal window [i, j] such that, for some x, all a[k] != x are within [i, j].

This seems similar to finding the minimal j - i + 1 such that, for some x, all a[k] != x are in [i, j].

This is equivalent to finding the minimal j - i + 1 such that, outside [i, j], all a[k] are equal to some x.

Wait, but outside [i, j], all a[k] must be equal to x.

So, the prefix and suffix must have a[k] == x.

So, perhaps I can iterate over all possible x and find the minimal j - i + 1 where j is the last position where a[k] != x and i is the first position where a[k] != x.

Then, choose the minimal among these.

But this is O(n^2), which is too slow.

I need a better way.

Let me consider that the minimal cost is n - the length of the longest contiguous subarray with all elements equal to some x.

Because if I have a longest subarray where a[k] == x, then I need to set the parts before and after this subarray to x.

The cost would be n - length of this subarray.

But in reality, the parts before and after might overlap, and I can set a subarray that covers both.

Wait, perhaps.

Let me consider that the minimal cost is n - the maximum length of any subarray where all elements are equal to some x.

Because setting the rest of the array to x would cost n - length of that subarray.

So, choosing the x with the longest subarray where a[k] == x would minimize the cost.

This seems plausible.

Let me check with the examples.

First test case: [1,2,3,4,5,1]

The longest subarray with equal elements is of length 1 (any single element).

So, n - 1 = 5, but the expected output is 4.

Hmm, doesn't match.

Wait, maybe it's not correct.

Second test case: [1,1,1,1,1,1,1]

The longest subarray with equal elements is 7, n - 7 = 0, which matches the output.

Third test case: [8,8,8,1,2,8,8,8]

The longest subarray with equal elements is 3 (either the first three 8's or the last three 8's).

n - 3 = 5, but the output is 2.

So, my assumption is incorrect.

Wait, perhaps I need to consider the sum of the lengths of the longest equal subarrays at both ends.

Wait, let's think differently.

Suppose I choose x to be the value that has the longest combined prefix and suffix that are equal to x.

Then, the cost would be n - (left[x] + right[x]).

Then, I need to maximize left[x] + right[x] for any x.

So, the minimal cost is n - max over x of (left[x] + right[x]).

Let me check this with the third test case.

For x = 8, left[8] = 3 (first three 8's), right[8] = 3 (last three 8's), so left[8] + right[8] = 6.

n - 6 = 2, which matches the output.

For the first test case: [1,2,3,4,5,1]

For x = 1, left[1] = 1, right[1] = 1, sum = 2.

For x = 2, left[2] = 0, right[2] = 0.

For x = 3, left[3] = 0, right[3] = 0.

For x = 4, left[4] = 0, right[4] = 0.

For x = 5, left[5] = 0, right[5] = 0.

So, max sum is 2, n - 2 = 4, which matches the output.

Seems correct.

So, the minimal cost is n - max over x of (left[x] + right[x]).

Where left[x] is the length of the longest prefix where a[k] == x.

right[x] is the length of the longest suffix where a[k] == x.

So, for each x, compute left[x] and right[x], then compute left[x] + right[x], and take the maximum over all x.

Then, minimal cost is n - max_sum.

This seems efficient, as I can compute left[x] and right[x] for all x in O(n).

So, in code, I can do:

- Initialize left[x] = 0 for all x.

- Iterate from left to right, set left[a[k]] = left[a[k]] + 1, and update left[x] for other x to 0.

- Wait, no, that's not correct.

Wait, actually, left[x] is the length of the longest prefix where a[k] == x.

So, for each x, find the longest prefix where a[k] == x.

Similarly, find the longest suffix where a[k] == x.

So, for x = a[0], left[x] = length of the run of a[0] at the beginning.

Similarly, for x = a[n-1], right[x] = length of the run of a[n-1] at the end.

For other x, left[x] and right[x] are 0.

Wait, no, if x == a[0], left[x] is the length of the run of x at the start.

Similarly for right[x].

So, for each x, left[x] is the length of the prefix where a[k] == x.

Similarly, right[x] is the length of the suffix where a[k] == x.

So, for x = a[0], left[x] = length of the run of x at the start.

For x = a[n-1], right[x] = length of the run of x at the end.

For other x, left[x] and right[x] are 0.

Then, for each x, sum left[x] + right[x], and find the maximum sum.

Then, minimal cost is n - max_sum.

This seems correct based on the earlier examples.

Let me verify with another example.

Consider [1,2,3,4,5,1]

For x = 1, left[1] = 1, right[1] = 1, sum = 2.

For x = 2, left[2] = 0, right[2] = 0.

For x = 3, left[3] = 0, right[3] = 0.

For x = 4, left[4] = 0, right[4] = 0.

For x = 5, left[5] = 0, right[5] = 0.

max_sum = 2, n - 2 = 4, which matches the first test case.

Another test case: [1,1,1,1,1,1,1]

For x = 1, left[1] = 7, right[1] = 7, sum = 7.

For other x, sum = 0.

max_sum = 7, n - 7 = 0, which matches.

Third test case: [8,8,8,1,2,8,8,8]

For x = 8, left[8] = 3, right[8] = 3, sum = 6.

For x = 1, left[1] = 0, right[1] = 0.

For x = 2, left[2] = 0, right[2] = 0.

max_sum = 6, n - 6 = 2, which matches.

Seems correct.

So, in code, for each test case:

- Read n and the array a.

- If n == 1, output 0.

- Else, find x where left[x] + right[x] is maximized.

- left[x] is the length of the longest prefix where a[k] == x.

- right[x] is the length of the longest suffix where a[k] == x.

- Compute max_sum = max over x of (left[x] + right[x]).

- If max_sum >= n, then cost is 0.

- Else, cost is n - max_sum.

- Output the cost.

Implementing this should be efficient enough, as it's O(n) per test case, and total n across all test cases is 2e5.

Now, looking at the provided code:

def func():

t = int(input())

for r in range(t):

n = int(input())

f = 1

num = [int(_) for _ in input().split()]

for j in range(n - 1):

if num[j] != num[j + 1]:

f = 0

break

if n == 1 or f == 1:

print(0)

continue

onum = num.copy()

onum.reverse()

cn = 1

ck = 1

f = 1

symb1 = num[0]

symb2 = onum[0]

for i in range(n - 1):

if num[i] == num[i + 1]:

cn += 1

else:

break

for ii in range(n - 1):

if onum[ii] == onum[ii + 1]:

ck += 1

else:

break

if symb1 == symb2:

cn += ck

print(n - max(cn, ck))

So, the code does the following:

- Reads t test cases.

- For each test case:

- Reads n and the array num.

- Checks if all elements are equal; if so, prints 0.

- If n == 1, prints 0.

- Else, reverses the array to get onum.

- Finds the length of the longest prefix where a[k] == num[0], stored in cn.

- Finds the length of the longest prefix where a[k] == onum[0], which is the longest suffix where a[k] == num[-1], stored in ck.

- If num[0] == num[-1], sets cn += ck.

- Prints n - max(cn, ck).

Wait, but according to my earlier reasoning, I should compute left[x] + right[x] for all x and take the maximum.

In the code, it seems to be computing left[num[0]] + right[num[-1]] if num[0] == num[-1], else just left[num[0]] and right[num[-1]] separately.

Wait, but in my earlier approach, I need to compute left[x] + right[x] for all x and take the maximum.

The provided code seems to be computing left[num[0]] + right[num[-1]] only if num[0] == num[-1], else taking max of left[num[0]] and right[num[-1]].

This might not always give the correct result.

For example, consider the array [1,2,1,1,2,2,2].

Here, num[0] = 1, num[-1] = 2.

left[1] = 1 (only the first element is 1).

right[2] = 4 (the last four elements are 2).

So, cn = 1, ck = 4.

max(cn, ck) = 4.

n - 4 = 3.

But according to my earlier approach, I need to find x where left[x] + right[x] is maximized.

For x = 1:

left[1] = 1, right[1] = 2 (the last two 1's).

sum = 3.

For x = 2:

left[2] = 0, right[2] = 4.

sum = 4.

So, max_sum = 4, n - 4 = 3.

Which matches the code's output.

But in this case, num[0] != num[-1], so it takes max(cn, ck) = 4, and n - 4 = 3.

If num[0] == num[-1], it adds cn and ck.

Wait, in the third test case: [8,8,8,1,2,8,8,8]

num[0] = 8, num[-1] = 8.

So, symb1 == symb2.

cn = 3 (first three 8's), ck = 3 (last three 8's).

Then, cn += ck → cn = 6.

Prints n - 6 = 2, which matches.

But in this case, for x = 8, left[8] + right[8] = 3 + 3 = 6.

For other x, it's less.

So, it seems to work.

But is this general?

Let me consider another example.

Suppose the array is [1,1,2,2,1,1].

n = 6.

num[0] = 1, num[-1] = 1.

left[1] = 2, right[1] = 2.

So, cn = 2, ck = 2, cn += ck → cn = 4.

n - 4 = 2.

But according to my earlier approach:

For x = 1:

left[1] = 2, right[1] = 2, sum = 4.

For x = 2:

left[2] = 0, right[2] = 0.

So, max_sum = 4, n - 4 = 2.

Correct.

Another example: [1,2,3,1,2,1]

n = 6.

num[0] = 1, num[-1] = 1.

left[1] = 1, right[1] = 1.

cn = 1, ck = 1, cn += ck → cn = 2.

n - 2 = 4.

But according to my earlier approach:

For x = 1:

left[1] = 1, right[1] = 1, sum = 2.

For x = 2:

left[2] = 0, right[2] = 0.

For x = 3:

left[3] = 0, right[3] = 0.

max_sum = 2, n - 2 = 4.

Correct.

Another example: [1,1,2,2,3,3]

n = 6.

num[0] = 1, num[-1] = 3.

left[1] = 2, right[3] = 2.

cn = 2, ck = 2.

max(cn, ck) = 2.

n - 2 = 4.

But according to my earlier approach:

For x = 1:

left[1] = 2, right[1] = 0, sum = 2.

For x = 2:

left[2] = 0, right[2] = 0.

For x = 3:

left[3] = 0, right[3] = 2, sum = 2.

So, max_sum = 2, n - 2 = 4.

Correct.

Seems like the code is working correctly for these cases.

Wait, but in the earlier example [1,2,1,1,2,2,2], num[0] = 1, num[-1] = 2, so cn = 1, ck = 4, max(cn, ck) = 4, n - 4 = 3.

According to my approach, max_sum = 4, n - 4 = 3.

Correct.

Another example: [1,2,3,4,5,1]

num[0] = 1, num[-1] = 1.

left[1] = 1, right[1] = 1, cn += ck → cn = 2.

n - 2 = 4.

Which matches the first test case.

Seems correct.

So, perhaps the code is correct.

But I need to make sure that this approach covers all possible x and gives the correct max_sum.

In the code, it seems to consider only x = num[0] and x = num[-1], and if num[0] == num[-1], it adds their left and right lengths.

But what if there exists some x in the middle that has a higher left[x] + right[x]?

For example, consider [1,2,2,2,1].

Here, num[0] = 1, num[-1] = 1.

left[1] = 1, right[1] = 1, sum = 2.

For x = 2:

left[2] = 0, right[2] = 0.

But actually, for x = 2, left[2] = 0 and right[2] = 0, but there is a longer subarray in the middle with x = 2.

Wait, no, left[2] is the length of the prefix where a[k] == 2, which is 0, since a[0] = 1 != 2.

right[2] is the length of the suffix where a[k] == 2, which is 3 (the last three 2's).

So, left[2] + right[2] = 0 + 3 = 3.

For x = 1:

left[1] = 1, right[1] = 1, sum = 2.

So, max_sum = 3, n - 3 = 2.

But according to the code:

num[0] = 1, num[-1] = 1.

cn = 1 (left[1] = 1), ck = 1 (right[1] = 1), cn += ck → cn = 2.

Then, n - 2 = 4.

Which is incorrect.

Wait, but according to my earlier approach, it should be n - 3 = 2.

So, in this case, the code gives an incorrect answer.

Hence, the code is flawed.

Therefore, the program is incorrect.

So, the Correctness is False.

## Final Solution
To solve this problem, we need to make all elements of the array equal with the least amount of burles spent, given that we can perform at most one operation to set a subarray to a specific value.

### Approach
1. **Initial Check:** If all elements in the array are already equal, no operation is needed, and the cost is 0.
2. **Operation Cost Calculation:** 
   - Identify the value to which we want to make all elements equal.
   - Determine the minimal subarray that needs to be set to this value to achieve the goal.
   - The cost is the length of this subarray.
3. **Optimal Value Selection:** 
   - Choose the value that minimizes the cost.
   - This is achieved by maximizing the sum of the longest prefix and suffix that have the same value.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        num = list(map(int, input().split()))
        
        if n == 1 or all(x == num[0] for x in num):
            print(0)
            continue
        
        max_sum = 0
        x_set = set(num)
        
        for x in x_set:
            left_x = 0
            while left_x < n and num[left_x] == x:
                left_x += 1
            right_x = 0
            while right_x < n and num[n - 1 - right_x] == x:
                right_x += 1
            max_sum = max(max_sum, left_x + right_x)
        
        if max_sum >= n:
            print(0)
        else:
            print(n - max_sum)

```

### Explanation
1. **Initial Check:**
   - If the array has only one element or all elements are equal, print 0 as no operation is needed.
   
2. **Operation Cost Calculation:**
   - For each unique value `x` in the array, calculate the longest prefix (`left_x`) and suffix (`right_x`) that consist entirely of `x`.
   - The sum `left_x + right_x` represents the total length of array boundaries that are already equal to `x`.
   - The minimal cost to make the entire array equal to `x` is `n - (left_x + right_x)`, as this is the length of the subarray that needs to be set to `x`.

3. **Optimal Value Selection:**
   - Find the maximum `left_x + right_x` over all possible `x` values.
   - The minimal cost is then `n - max_sum`.
   - If `max_sum` is greater than or equal to `n`, the cost is 0, meaning the array is already composed of a single value.

This approach ensures that we efficiently determine the minimal cost by leveraging prefix and suffix computations for each possible value `x`.