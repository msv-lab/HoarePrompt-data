Alright, I've got this problem to solve. Let's see what it's about. So, there's a game where I'm standing at point 0 on a straight line, and there are these monsters at different positions along this line, each with some health. Every second, a few things happen:

1. I can shoot up to k bullets at any monsters I choose. Each bullet reduces a monster's health by 1. I can aim all bullets at one monster or distribute them among different monsters.

2. After shooting, any monster with health 0 or less dies.

3. Then, all living monsters move one step closer to me. If any monster reaches point 0, I lose.

My goal is to figure out if I can eliminate all the monsters before any of them reaches me.

First, I need to understand the sequence of events each second:

- I shoot bullets at monsters, potentially reducing their health.

- Some monsters may die if their health drops to 0 or below.

- The remaining monsters move one step closer.

I have to make sure that no monster reaches point 0 before I can eliminate them all.

Let's consider the constraints:

- There can be up to 3*10^5 monsters per test case, and t can be up to 3*10^4, but the sum of n over all test cases doesn't exceed 3*10^5. So, overall, it's manageable in terms of time, but I need an efficient solution.

- Positions are unique, non-zero integers, and they are sorted in increasing order.

I need to think about how to prioritize which monsters to shoot first.

An initial thought is to handle the monsters that are closest to me first because they pose the immediate threat. However, if a monster is far away but has a lot of health, I might need to allocate more bullets to it earlier to ensure it doesn't approach too much before I can eliminate it.

Wait, maybe I should consider the time each monster will take to reach me based on its position and how many bullets I need to shoot at it.

Let's formalize this.

For each monster, I know its position x_i and health a_i.

Each second, I can shoot up to k bullets, and monsters move one step closer.

I need to ensure that before a monster reaches me, I've shot enough bullets at it to reduce its health to 0 or below.

So, for each monster, the time it will take to reach me is |x_i| seconds.

In those |x_i| seconds, I need to have shot at least a_i bullets at it.

But, I can shoot at multiple monsters each second, up to k bullets in total.

So, for each monster, there's a deadline: |x_i| seconds, and a requirement: a_i bullets.

I need to schedule my bullet shots in a way that meets all these deadlines.

This sounds similar to scheduling problems where tasks have deadlines and require certain amounts of resource.

In particular, it resembles the problem of scheduling jobs with deadlines and processing times, where the resource is the number of bullets I can shoot per second.

Given that, I need an algorithm to determine if it's possible to allocate the bullets in such a way that all monsters are eliminated before they reach me.

One approach is to sort the monsters based on their deadlines (time to reach me) and then check if I can allocate the required bullets within those deadlines, given that I can shoot up to k bullets per second.

But since monsters move closer every second, the effective time to eliminate a monster is decreasing as I shoot bullets.

Wait, perhaps I need to consider the order in which monsters approach me and ensure that I allocate enough bullets to the ones that are closer first.

Let me think differently.

Suppose I sort the monsters based on their distance from me, from closest to farthest.

Then, for each monster, I calculate the time it will take to reach me and ensure that I've eliminated it before it reaches me.

But I need to consider that as I shoot bullets, I'm allocating them to different monsters, and I have a limited number of bullets per second.

I need to find a way to distribute the bullets over time such that no monster reaches me with positive health.

This seems complex. Maybe there's a smarter way to look at it.

Let's consider the furthest monster. It has the most time to be eliminated, so it's the least urgent.

The closest monster has the least time, so it's the most urgent.

So, perhaps I should prioritize shooting at the closest monsters first.

But, if I focus only on the closest monsters, I might not have enough time to deal with the farther ones that are more dangerous in the long run.

I need a balance.

Wait, maybe I can sort the monsters based on their distance and then calculate the total bullets needed up to each point and see if I can meet the requirements within the time frames.

Let's try to formalize this.

Suppose I sort the monsters in increasing order of their distance from me.

For each monster, I know how many bullets I need to shoot at it and how much time I have to do so.

Then, for each position, I can calculate the cumulative bullets needed and see if I can allocate them within the available time.

This sounds promising.

Let's try with an example.

Take the first test case from the example:

3 2

1 2 3

-1 2 3

So, n=3 monsters, k=2 bullets per second.

Monsters:

- Monster 1: a=1, x=-1, distance=1

- Monster 2: a=2, x=2, distance=2

- Monster 3: a=3, x=3, distance=3

Sort them by increasing distance:

- Monster 1: distance 1, health 1

- Monster 2: distance 2, health 2

- Monster 3: distance 3, health 3

Now, for Monster 1, it will reach me in 1 second, so I need to shoot at least 1 bullet at it within 1 second.

Given that I can shoot up to 2 bullets per second, I can shoot 1 bullet at Monster 1 in the first second, eliminating it.

Then, in the second second, I can shoot 2 bullets at Monster 2, eliminating it before it reaches me.

Finally, in the third second, I can shoot 2 bullets at Monster 3, reducing its health to 1, and then in the fourth second, shoot another 2 bullets to eliminate it.

Wait, but according to the sample input, it's possible to eliminate all monsters.

In the explanation, they do it in 3 seconds.

Okay, so in the first second, shoot 1 bullet at Monster 1 and 1 bullet at Monster 3.

- Monster 1: health 0, dies.

- Monster 3: health 2, moves closer to x=2.

In the second second, shoot 2 bullets at Monster 2.

- Monster 2: health 0, dies.

- Monster 3: moves closer to x=1.

In the third second, shoot 2 bullets at Monster 3.

- Monster 3: health 0, dies.

So, all monsters are eliminated before any reaches me.

Great, that matches the sample.

Now, let's see how to generalize this.

I need to sort the monsters by their distance, from closest to farthest.

Then, for each monster, I need to ensure that the total bullets shot at it and all previous monsters doesn't exceed the available bullets up to that time.

Wait, not exactly.

I need to make sure that for each monster, the total bullets shot at it are sufficient before its deadline (when it reaches me).

Given that, perhaps I can iterate through the monsters in order of increasing distance, keeping track of the total bullets needed so far and comparing it to the maximum possible bullets I could have shot by that time.

Maximum bullets I can shoot by time t is t * k.

Wait, but I need to consider that I can allocate bullets to different monsters in any way each second.

So, for each monster, I have to make sure that by the time it reaches me, I've shot at least a_i bullets at it.

But since I can shoot up to k bullets per second, allocated among any monsters, I need to ensure that the cumulative bullets needed for all monsters don't exceed the total bullets I can allocate up to their deadlines.

This sounds like a resource allocation over time problem.

To solve this, I can sort the monsters by their distance (deadline), and then for each monster, accumulate the bullets needed and check if it's possible given the bullets I can shoot up to that time.

Wait, perhaps I can use the concept of prefix sums.

Let's sort the monsters by their distance in increasing order.

Then, for each monster, calculate the cumulative bullets needed up to that monster, and check if it's less than or equal to the maximum bullets I can shoot up to that time.

The maximum bullets I can shoot up to time t is t * k.

So, for each monster i, with distance t_i, cumulative bullets needed is sum(a_j for j from 1 to i), and this should be less than or equal to t_i * k.

Wait, but this might not be entirely accurate because the earlier monsters may have smaller distances, so I need to make sure that the cumulative bullets needed up to monster i is less than or equal to the sum of k per second up to time t_i.

But, since the monsters move closer every second, I need to consider that the time available to shoot at a monster is from now until it reaches me.

However, I also have to account for the fact that I can shoot at multiple monsters simultaneously each second.

This seems tricky.

Let me think differently.

Suppose I have monsters sorted by their distance.

I can iterate through them one by one, and for each monster, calculate how many bullets I need to shoot at it, considering the time I have to eliminate it.

But I need to keep track of the bullets allocated to each monster over time.

This seems complicated.

Maybe there's a simpler way.

Looking back at the sample input, in the first test case, n=3, k=2, a=[1,2,3], x=[-1,2,3].

Sorted by distance: Monster 1 (x=-1, a=1), Monster 2 (x=2, a=2), Monster 3 (x=3, a=3).

For Monster 1, distance=1, need 1 bullet. So, by time t=1, I need to have shot 1 bullet at it.

Maximum bullets I can shoot by t=1 is 1*2=2, which is more than enough.

For Monster 2, distance=2, need 2 bullets. By t=2, I can shoot up to 2*2=4 bullets.

But, I need to allocate bullets to both Monster 1 and Monster 2.

Wait, but Monster 1 only needs 1 bullet, so in t=1, I can shoot 1 bullet at Monster 1 and 1 bullet at Monster 2.

Then, in t=2, I can shoot 2 bullets at Monster 2, eliminating it.

Similarly, for Monster 3, distance=3, need 3 bullets. By t=3, I can shoot up to 3*2=6 bullets.

But I need to allocate bullets to Monster 3 over the available time, considering the bullets already allocated to other monsters.

This seems like I need to keep track of the total bullets allocated so far and see if it's possible to allocate the required bullets for each monster within their deadlines.

Wait, perhaps I can sort the monsters by their distance and then calculate the cumulative bullets needed and compare it with the maximum bullets I can shoot up to that distance.

So, for each monster i, with distance t_i, the cumulative bullets needed up to monster i should be less than or equal to t_i * k.

But, I need to make sure that the bullets are allocated in a way that respects the deadlines.

Wait, maybe I can iterate through the monsters in order of increasing distance, and keep a running total of bullets needed.

At each monster, I check if the cumulative bullets needed so far is less than or equal to t_i * k.

If yes, proceed to the next monster.

If not, it's impossible.

This seems to make sense.

Let's test it with the first sample.

Monsters sorted by distance:

- Monster 1: t=1, a=1

- Monster 2: t=2, a=2

- Monster 3: t=3, a=3

Cumulative bullets needed:

- After Monster 1: 1

  - Compare to 1*2=2: 1 <= 2, okay.

- After Monster 2: 1 + 2 = 3

  - Compare to 2*2=4: 3 <= 4, okay.

- After Monster 3: 1 + 2 + 3 = 6

  - Compare to 3*2=6: 6 <= 6, okay.

So, it's possible.

In the second sample:

2 1

1 1

-1 1

Monsters sorted by distance:

- Monster 1: t=1, a=1

- Monster 2: t=1, a=1

Cumulative bullets needed:

- After Monster 1: 1

  - Compare to 1*1=1: 1 <= 1, okay.

- After Monster 2: 1 + 1 = 2

  - Compare to 1*1=1: 2 > 1, not okay.

So, it's impossible, which matches the sample output of "NO".

Great, this seems to work.

Let me try with the third sample:

4 10

3 4 2 5

-3 -2 1 3

Sorted by distance:

- Monster 2: t=2, a=4

- Monster 4: t=3, a=5

- Monster 3: t=1, a=2

- Monster 1: t=3, a=3

Wait, no. Positions are -3, -2, 1, 3, so distances are 3, 2, 1, 3.

Sorted by increasing distance:

- Monster 3: t=1, a=2

- Monster 2: t=2, a=4

- Monster 1: t=3, a=3

- Monster 4: t=3, a=5

Cumulative bullets needed:

- After Monster 3: 2

  - Compare to 1*10=10: 2 <= 10, okay.

- After Monster 2: 2 + 4 = 6

  - Compare to 2*10=20: 6 <= 20, okay.

- After Monster 1: 2 + 4 + 3 = 9

  - Compare to 3*10=30: 9 <= 30, okay.

- After Monster 4: 2 + 4 + 3 + 5 = 14

  - Compare to 3*10=30: 14 <= 30, okay.

So, it's possible, which should correspond to "YES".

Fourth sample:

5 3

2 1 3 2 5

-3 -2 3 4 5

Distances: 3, 2, 3, 4, 5

Sorted by increasing distance:

- Monster 2: t=2, a=1

- Monster 1: t=3, a=2

- Monster 3: t=3, a=3

- Monster 4: t=4, a=2

- Monster 5: t=5, a=5

Cumulative bullets needed:

- After Monster 2: 1

  - Compare to 2*3=6: 1 <= 6, okay.

- After Monster 1: 1 + 2 = 3

  - Compare to 3*3=9: 3 <= 9, okay.

- After Monster 3: 1 + 2 + 3 = 6

  - Compare to 3*3=9: 6 <= 9, okay.

- After Monster 4: 1 + 2 + 3 + 2 = 8

  - Compare to 4*3=12: 8 <= 12, okay.

- After Monster 5: 1 + 2 + 3 + 2 + 5 = 13

  - Compare to 5*3=15: 13 <= 15, okay.

So, "YES".

Fifth sample:

2 1

1 2

1 2

Distances: 1, 2

Sorted by increasing distance:

- Monster 1: t=1, a=1

- Monster 2: t=2, a=2

Cumulative bullets needed:

- After Monster 1: 1

  - Compare to 1*1=1: 1 <= 1, okay.

- After Monster 2: 1 + 2 = 3

  - Compare to 2*1=2: 3 > 2, not okay.

So, "NO".

This matches the sample outputs.

Seems like this approach works.

Now, to implement this efficiently, I need to sort the monsters by their distance in increasing order, then iterate through them, keeping a running total of the bullets needed and comparing it to the maximum bullets I can shoot up to that distance.

Given that n can be up to 3*10^5 and t up to 3*10^4, but the sum of n over all test cases is up to 3*10^5, I need an O(n log n) solution, which is acceptable.

In code, I'll read t test cases, for each test case:

- Read n and k.

- Read array a (health).

- Read array x (positions).

- Compute distances as absolute values of x.

- Sort the monsters based on increasing distance.

- Iterate through the sorted monsters, keeping a running total of bullets needed.

- For each monster, check if the cumulative bullets needed is less than or equal to distance * k.

- If all monsters satisfy this, print "YES"; else, print "NO".

Wait, but in the fifth sample, distances are 1 and 2, and cumulative bullets are 1 and 3, compared to 1*1=1 and 2*1=2.

So, 3 > 2, which is not okay, hence "NO".

But in the fourth sample, distances are 2, 3, 3, 4, 5, and cumulative bullets are 1, 3, 6, 8, 13, compared to 2*3=6, 3*3=9, 3*3=9, 4*3=12, 5*3=15.

All cumulative bullets are less than or equal to the corresponding max bullets, so "YES".

Seems correct.

I need to make sure that for each monster, the cumulative bullets needed up to that monster is less than or equal to the distance of that monster multiplied by k.

If that's true for all monsters, then it's possible to eliminate all monsters before any reaches me.

Otherwise, it's not possible.

This seems to be an efficient and correct way to solve the problem.

## Final Solution
To solve this problem, we need to determine if we can eliminate all monsters before any of them reaches our character in a game scenario involving shooting monsters and managing their movement towards us.

### Approach
1. **Problem Analysis**:
   - We stand at point 0 on a straight line.
   - Monsters are positioned at various points (positive and negative) with given health.
   - Each second, we can shoot up to `k` bullets, each reducing a monster's health by 1.
   - After shooting, monsters with health <= 0 die, and the remaining monsters move one step closer to us.
   - If any monster reaches point 0, we lose.

2. **Insight**:
   - We need to ensure that each monster is eliminated before it reaches us.
   - Monsters closer to us pose an immediate threat, but those farther away have more time to be eliminated.

3. **Algorithm**:
   - **Sort the Monsters**: Based on their distance from us (absolute value of their position), from closest to farthest.
   - **Cumulative Bullets Check**: Iterate through the sorted list of monsters and maintain a running total of bullets needed to eliminate them. For each monster, check if the cumulative bullets needed are less than or equal to the product of the time (distance) and the bullet firing rate (`k`).

4. **Complexity**:
   - Sorting the monsters takes O(n log n).
   - Iterating through the sorted list is O(n).
   - Overall, the approach is efficient for the given constraints.

### Solution Code
```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        k = int(data[idx + 1])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        x = list(map(int, data[idx:idx + n]))
        idx += n
        
        # Create list of monsters with their distances and health
        monsters = sorted(zip(x, a), key=lambda p: abs(p[0]))
        
        bullets_used = 0
        can_survive = True
        for pos, health in monsters:
            distance = abs(pos)
            total_bullets_needed = bullets_used + health
            if total_bullets_needed > distance * k:
                can_survive = False
                break
            bullets_used += health
        print('YES' if can_survive else 'NO')

if __name__ == '__main__':
    main()
```

### Explanation
1. **Reading Input**:
   - Read the number of test cases `t`.
   - For each test case, read `n` (number of monsters) and `k` (maximum bullets per second).
   - Read the health array `a` and position array `x`.

2. **Sorting Monsters**:
   - Sort the monsters based on their distance from us (absolute position values).

3. **Checking Cumulative Bullets**:
   - Maintain a running total of bullets needed (`bullets_used`).
   - For each monster, check if the cumulative bullets needed exceed the bullets that can be fired up to that distance (`distance * k`).
   - If all monsters satisfy this condition, print "YES"; otherwise, print "NO".

This approach ensures that we efficiently determine the feasibility of eliminating all monsters before any reach us, by leveraging sorting and cumulative sum checks.