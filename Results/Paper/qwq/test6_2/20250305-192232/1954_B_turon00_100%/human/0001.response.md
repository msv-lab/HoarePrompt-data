Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. If it's impossible to make it not beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if I can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ |a| - 1) such that a[i - 1] equals a[i + 1], and replace a[i] with a[i - 1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. This operation can be repeated as many times as I want.

My goal is to remove the minimum number of elements to prevent the array from being transformed into an array where all elements are the same using these operations.

Let's look at the examples to get a better understanding.

First test case:

3

2 2 2

It's already all twos, so no matter how many elements I remove, it remains beautiful because I can always make all elements the same (by doing no operations). So, it's impossible to make it not beautiful, hence -1.

Second test case:

5

1 2 1 2 1

If I remove the element at index 5 (which is 1), the array becomes [1, 2, 1, 2]. Now, let's see if this is still beautiful. If I try to apply the operation:

- For i=2 (element 2), a[1]=1 and a[3]=1, so I can replace a[2] with 1, making the array [1,1,1,2]. But then, I can't make all elements the same because there's still a 2.

- Alternatively, if I choose i=3 (element 1), a[2]=2 and a[4]=2, so I can replace a[3] with 2, making the array [1,2,2,2]. Again, I can't make all elements the same because there's still a 1.

So, by removing one element, I can make the array not beautiful.

Third test case:

1

1

It's just one element, which is already beautiful. Since there's only one element, I can't make it not beautiful by removing elements, because removing the only element would leave an empty array, which might be considered not beautiful, but according to the problem, n >=1, so perhaps removing elements to get an empty array is considered impossible. Anyway, the output is -1.

Fourth test case:

7

3 3 3 5 3 3 3

If I remove the first three elements, the array becomes [5,3,3,3]. Let's see if this is beautiful. Can I make all elements the same?

- a[2]=3 and a[4]=3, so for i=3 (element 3), I can replace a[3] with a[2]=3, but it's already 3.

- No operations can be performed, and the array is not all the same, so it's not beautiful.

So, by removing three elements, I can make it not beautiful.

From these examples, it seems that if the array consists of only one unique element, or if it's already not possible to make all elements the same, then removing elements won't help, and the answer is -1.

Otherwise, I need to find the minimum number of elements to remove so that after removal, the array cannot be made beautiful.

Wait, but in the second test case, the array has multiple unique elements, and by removing one element, I can make it not beautiful.

Let me think differently. Maybe the key is to break the sequences where elements are the same.

Wait, perhaps the problem reduces to finding the minimum number of removals to break all sequences where the same element repeats in a certain pattern.

But that seems vague. Let's think about the operation allowed in the problem.

The operation is: if a[i-1] == a[i+1], then replace a[i] with a[i-1].

So, this operation allows me to change a[i] to match its neighbors if they are equal.

This seems like a way to propagate values through the array, making stretches of identical elements.

So, in the first test case, all elements are already equal, so no matter what I remove, I can still make all elements equal.

In the second test case, the array is alternating: 1,2,1,2,1. If I remove one element, I can break this pattern.

In the fourth test case, there are stretches of 3's with a single 5 in the middle.

Wait, perhaps the problem is related to the number of times the most frequent element appears.

But I'm not sure.

Let me consider what it means for an array to be not beautiful. It means that no matter how many operations I perform, I cannot make all elements equal.

Given the operation allowed, if I have an array where all elements are already equal, it's beautiful. If I have an array where there are multiple distinct elements that cannot be made equal through the operations, then it's not beautiful.

So, perhaps, if the array has only one unique element, or if all elements can be made equal through operations, then to make it not beautiful, I need to ensure that after removal, the remaining array cannot have all elements made equal.

Wait, but in the first test case, where all elements are already equal, removing any number of elements won't prevent me from making all remaining elements equal, because they are already equal. So, it's impossible to make it not beautiful in this case.

In the second test case, the array is [1,2,1,2,1]. If I remove one element, say the last one, the array becomes [1,2,1,2]. Now, can I make all elements equal? Let's see:

- Choose i=2 (a[1]=1, a[3]=1, so replace a[2] with 1): array becomes [1,1,1,2]. Now, choose i=4 (a[3]=1, a[5]=nothing, but i=4 is out of bounds now). So, no more operations. The array is not all equal.

- Alternatively, choose i=3 (a[2]=1, a[4]=2, but they are not equal, so can't perform the operation).

So, the array [1,2,1,2] cannot be made beautiful.

Another way: if I remove the first element, the array becomes [2,1,2,1]. Similar logic applies.

So, removing one element is sufficient.

In the fourth test case, [3,3,3,5,3,3,3], if I remove the first three elements, the array becomes [5,3,3,3]. Now, can I make all elements equal?

- Choose i=2 (a[1]=5, a[3]=3, not equal, can't perform operation).

- Choose i=3 (a[2]=3, a[4]=3, equal, so replace a[3] with 3, but it's already 3.

- No operations can be performed, and the array is not all equal.

Hence, it's not beautiful.

So, the strategy seems to be: find the minimum number of elements to remove so that the remaining array cannot be made beautiful.

But what's the general approach?

Let me consider that if the array has only one unique element, it's impossible to make it not beautiful, hence -1.

Otherwise, if there are multiple unique elements, perhaps the minimum number of elements to remove is related to the frequency of the most frequent element.

Wait, perhaps it's the frequency of the most frequent element.

Wait, in the second test case, the most frequent element is 1, which appears 3 times.

If I remove one element, I can break the sequence.

In the fourth test case, the most frequent element is 3, appearing 6 times.

If I remove three elements, I can reduce it to three 3's and one 5.

But I need a more concrete approach.

Let me consider that the array is beautiful if and only if all elements can be made equal by performing the operations.

Given that, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal.

But determining when it's impossible seems tricky.

Wait, perhaps I can think in terms of connectivity.

Imagine the array as a graph where elements connected by the operation can be made equal.

But I'm not sure.

Wait, another idea: the operation allows me to change a[i] to a[i-1] if a[i-1] == a[i+1].

This seems like a way to propagate values through the array.

If I have a sequence where a[i-1] == a[i+1], I can set a[i] to that value.

So, in the first test case, all elements are equal, so I can always make any element equal to its neighbors.

In the second test case, the array is alternating, so I can't make all elements equal.

Wait, but according to the problem, it's given that the array is beautiful, so in the second test case, it must be possible to make all elements equal.

Wait, but in the explanation, it says that after removing one element, the resulting array is not beautiful.

Wait, perhaps I need to think differently.

Given that the array is beautiful, meaning that it's possible to make all elements equal by performing the operations, I need to remove elements in such a way that it's no longer possible to make all elements equal.

So, the goal is to破坏 this possibility.

I need to find the minimum number of elements to remove so that, after removal, it's impossible to make all remaining elements equal using the operations.

Wait, perhaps the key is to remove elements such that there are at least two different elements that cannot be made equal through the operations.

But I need to formalize this.

Let me consider that if the array consists of only one unique element, it's impossible to make it not beautiful, hence -1.

If the array has multiple unique elements, but all can be made equal through operations, then I need to remove enough elements so that after removal, there are at least two different elements that cannot be made equal.

But I need a better approach.

Let me consider the following:

- Find the most frequent element.

- Calculate how many elements are not equal to this most frequent element.

- If I remove all elements that are not equal to the most frequent element, the remaining array will consist only of the most frequent element, which is still beautiful.

- Therefore, to make the array not beautiful, I need to remove fewer elements.

Wait, perhaps I need to remove enough elements so that the remaining array has at least two different elements, and it's impossible to make them equal through operations.

But this seems too vague.

Let me look at the fourth test case again.

Array: [3,3,3,5,3,3,3]

Most frequent element: 3, appearing 6 times.

If I remove three elements, for example, the first three 3's, the array becomes [5,3,3,3].

Now, can I make all elements equal?

- Choose i=2 (a[1]=5, a[3]=3), but a[1] != a[3], so can't perform operation.

- Choose i=3 (a[2]=3, a[4]=3), so replace a[3] with 3 (no change).

- Choose i=4, out of bounds.

So, no operations can be performed, and the array is not beautiful.

Hence, removing three elements is sufficient.

Is there a better way?

If I remove two elements, say the first two 3's, the array becomes [3,3,5,3,3,3].

Now, can I make all elements equal?

- Choose i=3 (a[2]=3, a[4]=5), can't perform operation.

- Choose i=4 (a[3]=5, a[5]=3), can't perform operation.

- Choose i=5 (a[4]=3, a[6]=3), replace a[5] with 3 (no change).

- Choose i=6, out of bounds.

So, no operations can be performed, and the array is not beautiful.

Wait, but according to the sample output, it's 3, but according to this, removing two elements seems sufficient.

Wait, perhaps I chose the wrong elements to remove.

If I remove the first two 3's, the array becomes [3,3,5,3,3,3].

Is this not beautiful?

- Can I make all elements equal?

- Choose i=3 (a[2]=3, a[4]=5), can't perform operation.

- Choose i=4 (a[3]=5, a[5]=3), can't perform operation.

- Choose i=5 (a[4]=3, a[6]=3), replace a[5] with 3 (no change).

- Choose i=6, out of bounds.

So, the array remains [3,3,5,3,3,3], which is not beautiful.

Hence, removing two elements is sufficient, but the sample output says 3.

Wait, maybe I misread the sample output.

Looking back, the fourth test case has n=7, a=[3,3,3,5,3,3,3], and the output is 3.

But according to my previous reasoning, removing two elements seems sufficient.

Wait, perhaps the sample output is incorrect, or perhaps I misunderstood the problem.

Wait, in the note, it says "you can remove the first three elements, for example. The resulting array [5,3,3,3] is not beautiful."

But according to my earlier reasoning, removing two elements also makes it not beautiful.

So, perhaps the minimum number is 2, but the sample output is 3.

Wait, maybe there's a mistake in the sample output.

Wait, let's check again.

Looking back at the problem statement:

"the minimum number of elements you have to remove from it in order for it to stop being beautiful."

In the fourth test case, n=7, a=[3,3,3,5,3,3,3], and the sample output is 3.

But according to my earlier reasoning, removing two elements is sufficient.

Wait, perhaps I need to think differently.

Maybe the problem is not just about removing elements to have at least two different elements remaining, but about preventing the array from being made beautiful through operations.

Wait, perhaps the operations can be used to propagate values in a way that I need to consider connected components or something similar.

Let me think in terms of groups of equal elements.

If I have a group of equal elements, operations can be used to expand the group to include neighboring elements under certain conditions.

Wait, perhaps I need to find the minimal number of elements to remove so that no group of equal elements can span the entire array through operations.

But I need a clearer approach.

Let me consider that the array is beautiful if and only if all connected components of equal elements are connected in such a way that operations can be used to make the entire array equal.

Wait, perhaps I need to model the array as a graph where elements are nodes, and there are edges between elements that can be made equal through operations.

Then, if the graph is connected, the array is beautiful.

But I'm not sure.

Wait, perhaps I should consider that the operations allow me to change a[i] to a[i-1] if a[i-1] == a[i+1].

This seems similar to saying that a[i] can be set to a[i-1] if a[i-1] == a[i+1], which implies some kind of equality propagation.

Maybe I can think of the array as having runs of equal elements, and the operations allow me to extend these runs under certain conditions.

Wait, perhaps I should look for the minimal number of removals to break all possible paths of equality propagation.

But this is getting too abstract.

Let me consider a different approach.

Suppose I have an array where all elements are equal; it's beautiful, and I can't make it not beautiful by removing elements because the remaining elements are still equal.

If I have an array with multiple unique elements, and I can remove some elements to leave behind an array where it's impossible to make all elements equal through operations, then that's the goal.

Perhaps the minimal number of removals is equal to the frequency of the most frequent element minus the number of positions where that element appears in a non-propagatable way.

But I need a better approach.

Let me consider that in order for the array to be not beautiful, there must be at least two different elements remaining, and it must be impossible to make them equal through operations.

This seems similar to ensuring that there are at least two different elements that cannot be connected through a sequence of operations.

Wait, perhaps I need to find the minimal number of removals such that there are at least two different elements, and these elements are not connected through operations.

But I need a more concrete plan.

Let me consider that if I remove all elements except for one of each unique element, that should make it not beautiful.

But perhaps I can do better.

Wait, perhaps the answer is the frequency of the most frequent element minus one, but only if there are other elements present.

But in the first test case, all elements are the same, so removing any number won't make it not beautiful.

In the second test case, the most frequent element is 1, appearing three times.

If I remove one element, I can make it not beautiful.

In the fourth test case, the most frequent element is 3, appearing six times.

According to this, removing five elements would be sufficient, but the sample output is 3.

So, this approach is incorrect.

Wait, perhaps it's related to the number of times the most frequent element appears in a row.

But I'm still not getting it.

Let me look at the code provided and see if that gives me any clues.

The code is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().strip().split()))

tmp = a[0]

cnt = 0

ans = n

for i in range(n):

if a[i] == tmp:

cnt += 1

else:

ans = min(ans, cnt)

cnt = 0

ans = min(ans, cnt)

if n == 1 or ans == n:

print(-1)

else:

print(ans)

So, the code initializes tmp to a[0], then iterates through the array, counting the number of consecutive elements equal to tmp.

Whenever it encounters an element not equal to tmp, it updates ans to be the minimum of ans and cnt, and resets cnt to 0.

After the loop, it takes the minimum of ans and the last cnt.

Then, if n == 1 or ans == n, it prints -1; else, it prints ans.

Wait, in the first test case, a = [2,2,2], tmp = 2, cnt = 3, ans = 3.

Since n == 3 and ans == 3, it prints -1, which matches the sample output.

In the second test case, a = [1,2,1,2,1], tmp = 1.

Iterate:

i=0: a[0]=1 == tmp, cnt=1

i=1: a[1]=2 != tmp, ans = min(ans,1)=1, cnt=0

i=2: a[2]=1 == tmp, cnt=1

i=3: a[3]=2 != tmp, ans = min(1,1)=1, cnt=0

i=4: a[4]=1 == tmp, cnt=1

Final ans = min(1,1)=1

Since n=5 and ans=1, it prints 1, matching the sample output.

In the third test case, n=1, a=[1], tmp=1, cnt=1, ans=1.

Since n==1, it prints -1, matching the sample.

In the fourth test case, a=[3,3,3,5,3,3,3], tmp=3.

Iterate:

i=0: a[0]=3 == tmp, cnt=1

i=1: a[1]=3 == tmp, cnt=2

i=2: a[2]=3 == tmp, cnt=3

i=3: a[3]=5 != tmp, ans = min(ans,3)=3, cnt=0

i=4: a[4]=3 == tmp, cnt=1

i=5: a[5]=3 == tmp, cnt=2

i=6: a[6]=3 == tmp, cnt=3

Final ans = min(3,3)=3

Prints 3, matching the sample output.

So, the code seems to be calculating the minimum number of consecutive elements equal to a[0] in any stretch of such elements.

Wait, but in the second test case, it's calculating the minimum cnt where a[i]==tmp, which is 1 in each stretch of 1's.

Hence, ans=1, which matches the sample output.

In the fourth test case, the minimum cnt where a[i]==3 is 1 (at the end, but cnt is 3), so ans=3.

But earlier, I thought that removing two elements is sufficient.

However, perhaps the code is correct, and my earlier reasoning was flawed.

Alternatively, maybe the code is incorrect.

Wait, perhaps the code is finding the minimum number of elements to remove to break the array's beauty.

If I think about it, in the second test case, removing one element is sufficient to break the beauty, as shown in the sample.

In the fourth test case, removing three elements is necessary to break the beauty.

But according to my earlier reasoning, removing two elements seems sufficient.

Wait, perhaps I made a mistake in my earlier reasoning.

Let me re-examine the fourth test case.

Array: [3,3,3,5,3,3,3]

If I remove the first two 3's, the array becomes [3,3,5,3,3,3].

Now, can I make all elements equal?

- Choose i=3 (a[2]=3, a[4]=5), can't perform operation.

- Choose i=4 (a[3]=5, a[5]=3), can't perform operation.

- Choose i=5 (a[4]=3, a[6]=3), replace a[5] with 3 (no change).

- Choose i=6, out of bounds.

So, no operations can be performed, and the array is not beautiful.

Hence, removing two elements is sufficient, but the sample output is 3.

Wait, perhaps the problem expects the minimal number of removals to ensure that the remaining array cannot be made beautiful, regardless of which elements are removed.

Wait, but the sample output is 3, while according to my reasoning, 2 should be sufficient.

Perhaps there's a misunderstanding.

Wait, maybe the problem is to remove elements such that the remaining array is not beautiful, and to find the minimal number of removals that guarantee this.

In other words, find the minimal k such that after removing any k elements, the array is not beautiful.

But that seems different from the sample output.

Wait, in the fourth test case, removing three elements is sufficient, and perhaps removing two might not always work, depending on which elements are removed.

Wait, if I remove any two elements, does it always make the array not beautiful?

For example, if I remove the two 5's (but there's only one 5), so perhaps removing two 3's.

If I remove the first two 3's, as before, it becomes [3,3,5,3,3,3], which is not beautiful.

If I remove two 3's from elsewhere, say the last two 3's, the array becomes [3,3,3,5,3], now:

- Choose i=3 (a[2]=3, a[4]=5), can't perform operation.

- Choose i=4 (a[3]=5, a[5]=3), can't perform operation.

- Choose i=5, out of bounds.

So, again, not beautiful.

Hence, removing two elements seems sufficient, but the sample output is 3.

Wait, perhaps the problem is to remove elements such that the remaining array has at least two different elements, and it's impossible to make them equal through operations.

But in the fourth test case, even after removing two elements, there are still multiple different elements, and it's impossible to make them equal.

Hence, perhaps the code is incorrect.

Alternatively, maybe the code is correct, and the sample output is 3 because that's the frequency of the most frequent element minus something.

Wait, in the fourth test case, the most frequent element is 3, appearing six times.

According to the code, ans is 3, which is the minimum number of consecutive 3's in any stretch.

Wait, but I'm not sure.

Perhaps the code is finding the minimum number of elements to remove in any stretch of elements equal to a[0] to break the beauty.

But I'm still confused.

Let me consider another approach.

Suppose I need to remove elements such that the remaining array cannot be made beautiful.

If the array is already beautiful, and I remove elements, I need to ensure that the remaining array cannot be made beautiful.

Perhaps, the minimal number of elements to remove is equal to the frequency of the most frequent element minus the number of times it appears in a non-continuous manner.

But this seems too vague.

Wait, perhaps the answer is the frequency of the most frequent element minus the maximum number of times it appears in a single continuous block.

But in the fourth test case, the most frequent element is 3, appearing six times, with two blocks: one of three 3's, then a 5, then another three 3's.

So, the maximum continuous block of 3's is three.

Hence, frequency is six, maximum continuous block is three, six minus three is three, which matches the sample output.

In the second test case, the most frequent element is 1, appearing three times, with maximum continuous block of one.

Hence, three minus one is two, but the sample output is one.

So, this doesn't match.

Wait, perhaps it's frequency minus maximum continuous block minus one.

In the fourth test case, six minus three is three, matching the sample.

In the second test case, three minus one is two, but the sample output is one.

So, still not matching.

Alternatively, perhaps it's the size of the maximum block of the most frequent element.

But again, in the second test case, it's not matching.

Wait, perhaps I need to consider the number of times the most frequent element appears in the smallest block.

In the second test case, the smallest block of 1's is one element, so frequency is three, smallest block is one, so three minus one is two, but