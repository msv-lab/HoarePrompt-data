Alright, I've got this problem to solve. It's about a game between Alice and Bob where they have some coins in their wallets and they take turns making moves according to certain rules. The goal is to determine who will win if both play optimally.

First, I need to understand the problem completely. Alice starts with 'a' coins and Bob with 'b' coins. They take turns, with Alice going first. In each turn, the player can choose to exchange wallets with the opponent or keep the current wallet, and then remove one coin from their current wallet. The player who can't make a valid move loses.

So, the key points are:

1. Players take turns alternately, starting with Alice.

2. In each turn, a player can choose to swap wallets or keep the current one.

3. After choosing, the player removes one coin from their current wallet.

4. The player who can't remove a coin because their wallet is empty loses.

I need to determine, for given values of 'a' and 'b', who will win the game if both play optimally.

First, I should think about the base cases.

- If both a and b are 1:

Alice's options:

- Swap: a=1, b=1 -> Alice removes 1, a=0, b=1.

- Not swap: a=0, b=1.

In both cases, Bob faces a=0 and b=1.

Bob's options:

- Swap: a=1, b=0 -> Bob removes 1, a=0, b=0.

- Not swap: a=0, b=0.

In both cases, Alice can't make a move, so Bob wins.

- If a=1, b=2:

Alice's options:

- Swap: a=2, b=1 -> Alice removes 1, a=1, b=1.

- Not swap: a=0, b=2.

If Alice swaps, then it's Bob's turn with a=1, b=1. From the previous case, Bob would win.

If Alice doesn't swap, a=0, b=2. Bob can't swap because a=0, so he must keep his wallet and remove 1, making a=0, b=1.

Then, Alice can only swap, making a=0, b=1 again, and Bob can't make a move, so Alice wins.

Wait, but according to the previous logic, it seems complicated. Maybe there's a pattern based on the sum of a and b.

Looking at the example outputs:

- 1 1: Bob

- 1 4: Alice

- 5 3: Bob

- 4 5: Alice

- 11 9: Bob

- 83 91: Bob

- 1032 9307: Alice

- 839204 7281: Alice

- 1000000000 1000000000: Bob

- 53110 2024: Bob

Looking at these, it seems that when a + b is even, Bob wins, else Alice wins.

Wait, let's check:

- 1 + 1 = 2 (even): Bob wins

- 1 + 4 = 5 (odd): Alice wins

- 5 + 3 = 8 (even): Bob wins

- 4 + 5 = 9 (odd): Alice wins

- 11 + 9 = 20 (even): Bob wins

- 83 + 91 = 174 (even): Bob wins

- 1032 + 9307 = 1032 + 9307 = 1032 is even, 9307 is odd, sum is odd: Alice wins

- 839204 + 7281 = even + odd = odd: Alice wins

- 1000000000 + 1000000000 = even + even = even: Bob wins

- 53110 + 2024 = even + even = even: Bob wins

Yes, it matches the pattern: if a + b is even, Bob wins; else, Alice wins.

Is this always true?

Let me think about the game theory behind this.

This seems like an impartial game, where the positions can be classified as either winning or losing based on the current state.

The game ends when a player cannot make a move, which is when both wallets are empty or the player's wallet is empty and they can't swap.

But in this game, players can choose to swap or not, and then remove one coin.

I need to find the Grundy number or mex for each possible state to determine if a position is winning or losing.

But given the large constraints (a and b up to 10^9), it's impractical to compute Grundy numbers for all states.

Instead, I need to find a mathematical pattern or a way to classify the winning and losing positions based on a and b.

From the initial observation, it seems that the sum a + b determines the winner.

Specifically, if a + b is even, Bob wins; otherwise, Alice wins.

But I need to verify if this is always true.

Let me consider a few more cases.

Case 1: a = 2, b = 2

Sum is 4 (even), so Bob should win.

Let's see:

Alice's move:

- Swap: a=2, b=2 -> remove 1, a=1, b=2.

- Not swap: a=1, b=2.

Bob's move:

- If a=1, b=2:

- Swap: a=2, b=1 -> remove 1, a=1, b=1.

- Not swap: a=0, b=2.

Alice's move:

- If a=1, b=1: Alice loses (as in the first example).

- If a=0, b=2: Alice swaps, a=0, b=2 -> can't remove, so Bob wins.

So, in both subcases, Bob wins.

Case 2: a = 2, b = 3

Sum is 5 (odd), so Alice should win.

Let's see:

Alice's move:

- Swap: a=3, b=2 -> remove 1, a=2, b=2.

- Not swap: a=1, b=3.

If Alice swaps: a=2, b=2. From previous case, Bob wins.

If Alice doesn't swap: a=1, b=3.

Bob's move:

- Swap: a=3, b=1 -> remove 1, a=2, b=1.

- Not swap: a=0, b=3.

Alice's move:

- If a=2, b=1: Alice can swap to a=1, b=2 -> remove 1, a=0, b=2. Bob can't swap, so he removes 1, a=0, b=1. Alice swaps, a=0, b=1, Bob can't move, Alice wins.

- If a=0, b=3: Alice swaps, a=3, b=0 -> remove 1, a=2, b=0. Bob removes 1, a=1, b=0. Alice removes 1, a=0, b=0. Bob can't move, Alice wins.

So, in both subcases, Alice wins.

This seems consistent with the initial observation.

Let me try another case.

Case 3: a = 3, b = 4

Sum is 7 (odd), so Alice should win.

Alice's move:

- Swap: a=4, b=3 -> remove 1, a=3, b=3.

- Not swap: a=2, b=4.

If swap: a=3, b=3. Sum is even, so Bob should win from here.

If not swap: a=2, b=4. Sum is 6 (even), Bob wins.

Wait, but according to the initial observation, since a + b is odd, Alice should win.

But in both subcases, it seems Bob wins.

Wait, maybe my initial observation is incorrect.

Wait, in the first case with a=1, b=1: Bob wins.

a=1, b=4: Alice wins.

a=3, b=4: according to my calculation, Bob wins in both subcases, but according to the initial observation, Alice should win.

Hmm, maybe the pattern is more complex.

Let me re-examine the initial test cases.

From the example:

Input:

10

1 1

1 4

5 3

4 5

11 9

83 91

1032 9307

839204 7281

1000000000 1000000000

53110 2024

Output:

Bob

Alice

Bob

Alice

Bob

Bob

Alice

Alice

Bob

Bob

Looking at a + b:

1+1=2 (even): Bob

1+4=5 (odd): Alice

5+3=8 (even): Bob

4+5=9 (odd): Alice

11+9=20 (even): Bob

83+91=174 (even): Bob

1032+9307=1032 odd + 9307 even = odd: Alice

839204 even + 7281 odd = odd: Alice

1000000000 even + 1000000000 even = even: Bob

53110 even + 2024 even = even: Bob

So, in all these cases, it seems that when a + b is even, Bob wins; when a + b is odd, Alice wins.

But in my previous case with a=3, b=4, sum is 7 (odd), Alice should win, but according to my analysis, Bob wins.

Wait, maybe I made a mistake in that analysis.

Let's re-examine a=3, b=4.

Alice's move:

Option 1: Swap a=4, b=3 -> remove 1, a=3, b=3.

Now, it's Bob's turn with a=3, b=3.

Bob's move:

Option 1: Swap a=3, b=3 -> remove 1, a=2, b=3.

Option 2: Not swap a=2, b=3.

Alice's move:

If a=2, b=3:

Option 1: Swap a=3, b=2 -> remove 1, a=2, b=2.

Option 2: Not swap a=1, b=3.

Bob's move:

If a=2, b=2:

Option 1: Swap a=2, b=2 -> remove 1, a=1, b=2.

Option 2: Not swap a=1, b=2.

Alice's move:

If a=1, b=2:

Option 1: Swap a=2, b=1 -> remove 1, a=1, b=1.

Option 2: Not swap a=0, b=2.

Bob's move:

If a=1, b=1: Bob loses.

If a=0, b=2: Bob can't swap, so removes 1, a=0, b=1.

Alice's move: Swap a=0, b=1 -> a=0, b=1. Bob can't move, Alice wins.

So, in both subcases, Alice wins.

Therefore, in a=3, b=4, Alice can force a win.

Wait, in my initial analysis, I thought Bob wins, but actually, Alice can force a win.

So, the initial observation holds: if a + b is odd, Alice wins; else, Bob wins.

Another way to think about it is in terms of the parity of the total number of coins.

If the total number of coins is even, Bob wins; otherwise, Alice wins.

But I need to confirm this with more cases.

Let me try a=2, b=2: sum=4 (even), Bob wins.

a=2, b=3: sum=5 (odd), Alice wins.

a=3, b=4: sum=7 (odd), Alice wins.

a=4, b=4: sum=8 (even), Bob wins.

Seems consistent.

But why is this the case?

Let's think in terms of game theory.

This game is similar to the game of Nim or other impartial games where the Grundy number (or mex) can determine the winner.

In such games, a position is winning if the Grundy number is non-zero, and losing if it is zero.

In this problem, the game state can be represented by the pair (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

Each move consists of choosing to swap or not, and then removing one coin from the current wallet.

The player who can't make a move loses.

I need to find a way to calculate the Grundy number for each state (a, b).

However, given the large constraints (a and b up to 10^9), it's impractical to compute Grundy numbers for all possible states.

Instead, I need to find a pattern or a mathematical formula that can determine the winner based on a and b.

From the initial observation, it seems that the sum a + b determines the winner: if even, Bob wins; else, Alice wins.

But why is this so?

Let me think recursively.

Consider the game as a graph where each node is a state (a, b), and edges represent possible moves.

The game ends when a player can't make a move, i.e., when a = 0 and b = 0 or when the player's current wallet is empty.

But in this game, since players can choose to swap or not, and then remove one coin, the game tree can be complex.

However, perhaps there is a symmetry or a invariant that can be exploited.

Let me consider the parity of a and b.

If a and b are both even or both odd (i.e., a + b is even), then Bob wins.

If one is even and the other is odd (i.e., a + b is odd), Alice wins.

Wait, but in the earlier case where a=2, b=3 (sum=5, odd), Alice wins.

Similarly, a=3, b=4 (sum=7, odd), Alice wins.

a=4, b=4 (sum=8, even), Bob wins.

a=5, b=5 (sum=10, even), Bob wins.

So, perhaps it's about the parity of a + b.

But I need to confirm this.

Let me consider the game in terms of the number of coins.

Each move reduces the total number of coins by 1, because one coin is removed each turn.

The game ends when a player can't make a move, which happens when their current wallet is empty and they can't swap to the other wallet.

Wait, but players can choose to swap or not.

Let me think differently.

Suppose we have a total of t coins, where t = a + b.

Each move reduces t by 1.

The player who is faced with t = 0 loses, because they can't make a move.

But in reality, the game doesn't exactly work like this because players can swap wallets, which changes the distribution of coins between a and b.

However, perhaps the total number of coins determines the winner.

In standard impartial games, the mex rule can be applied.

But in this case, the game is not exactly impartial because the available moves depend on the current player and the state.

Wait, maybe it's a partisan game.

In any case, the initial observation seems to hold for the provided test cases.

Therefore, the strategy is:

- If a + b is even, Bob wins.

- If a + b is odd, Alice wins.

Given that, the provided program seems to implement this logic.

Looking at the program:

def func():

for i in range(int(input())):

s = input()

a = int(list(s.split())[0])

b = int(list(s.split())[1])

if (a + b) % 2 == 0:

print('bob ')

else:

print('alice')

Wait, but in the example output, there are cases where a + b is even and Bob wins, and where a + b is odd and Alice wins.

So, the program seems to correctly implement this logic.

However, in the initial analysis, I thought about a=3, b=4, sum=7 (odd), Alice wins, which matches the program's output.

Similarly, a=2, b=2, sum=4 (even), Bob wins.

Therefore, the program seems correct.

But to be thorough, let's check against another case.

Consider a=0, b=1.

Wait, according to the problem, a and b are at least 1, so a=0 is not possible initially.

But during the game, a wallet can reach 0.

But in the initial input, a and b are at least 1.

Wait, in the program, it reads a and b from input, assuming they are at least 1.

So, the program just checks if a + b is even, then Bob wins, else Alice wins.

Given that this matches the observed pattern in the example outputs, and my analysis confirms it, I can conclude that the program is correct.

Therefore, Correctness: True

**Final Solution**

To solve this problem, we need to determine the winner of a game between Alice and Bob based on optimal play, given their initial coin counts in their wallets.

## Approach

1. **Problem Analysis**:
   - Alice and Bob take turns with Alice starting first.
   - Each player can choose to swap wallets or keep their current wallet and then remove one coin from their chosen wallet.
   - The player who cannot make a valid move loses.

2. **Insight**:
   - By analyzing several test cases, we observe that the sum of the coins in both wallets determines the winner.
   - If the sum `(a + b)` is even, Bob wins; otherwise, Alice wins.

3. **Optimal Strategy**:
   - The game can be considered as an impartial game where the total number of coins dictates the outcome.
   - The parity (even or odd) of the sum of coins is the deciding factor.

## Solution Code

```python
def func():
    for _ in range(int(input())):
        s = input()
        a = int(list(s.split())[0])
        b = int(list(s.split())[1])
        if (a + b) % 2 == 0:
            print('Bob')
        else:
            print('Alice')

# Note: The function func() should be called to execute the code.
# However, in programming competition platforms, the function might be automatically invoked.
```

## Explanation

- **Input Handling**:
  - Read the number of test cases.
  - For each test case, read the values of `a` and `b`.

- **Logic**:
  - Check if the sum of `a` and `b` is even or odd.
  - If the sum is even, print "Bob"; otherwise, print "Alice".

- **Efficiency**:
  - The solution runs in constant time for each test case, making it efficient even for large inputs.

This approach ensures that we determine the winner efficiently and correctly based on the given problem constraints and observations from test cases.