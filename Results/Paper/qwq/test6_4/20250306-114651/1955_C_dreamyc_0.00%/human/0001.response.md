Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n ships, each with some durability a_i, and they're arranged in a sequence from 1 to n. The Kraken attacks these ships in a specific pattern: first the first ship, then the last, then the first again, and so on. Each attack reduces the durability of the targeted ship by 1. When a ship's durability drops to zero, it sinks and is removed from the sequence. The Kraken attacks k times in total, following this pattern, and I need to figure out how many ships are sunk after these attacks.

First, I need to understand the process clearly. The Kraken alternates between attacking the first and the last ship in the current sequence. After each attack, if a ship's durability reaches zero, it's removed from the sequence. This removal can affect which ships are first and last in the sequence for subsequent attacks.

Given that n can be up to 2*10^5 and k can be up to 10^15, I need an efficient algorithm. A naive approach where I simulate each attack one by one would be too slow because of the large constraints. So, I need a smarter way to handle this.

Let me think about the pattern of attacks. The Kraken alternates between attacking the first and the last ship. If I can process pairs of attacks (one on the first and one on the last), I might be able to handle multiple attacks at once.

Suppose I have a list of ships with their durabilities. I can use a deque (double-ended queue) to efficiently remove ships from both ends.

Let's consider the example provided:

n=4, k=5, a=[1,2,4,3]

1. Attack first ship: a[0] becomes 0, so it's removed. Now a=[2,4,3]

2. Attack last ship: a[2] becomes 2, so a=[2,4,2]

3. Attack first ship: a[0] becomes 1, so a=[1,4,2]

4. Attack last ship: a[2] becomes 1, so a=[1,4,1]

5. Attack first ship: a[0] becomes 0, so it's removed. Now a=[4,1]

So, two ships are sunk.

In this process, I can see that in each pair of attacks (first and last), I can reduce the durability of both ships by 1 (assuming their durability is greater than 0). If one of them sinks, it's removed, and the sequence changes.

But with large n and k, simulating each attack individually would be inefficient. I need a way to process multiple attacks at once.

Let me consider the idea of processing complete cycles where the Kraken attacks the first and the last ship. If both ships have durability greater than the number of attacks I can perform, I can calculate how many such cycles I can complete before one of the ships sinks.

Wait, maybe I should think in terms of the minimum durability between the first and last ship. If I have x as the minimum durability between the first and last ship, I can perform x pairs of attacks (first and last) before one of them sinks. In each pair, I reduce both ships' durability by 1.

So, if I have k attacks, and I can perform k//2 pairs of attacks, but I need to make sure that I don't overstep the durability of the ships.

Let me try to formalize this.

Initialize a deque with the ships' durabilities.

Initialize a counter for sunk ships.

While k > 0 and there are at least two ships left:

Get the first ship's durability a and the last ship's durability b.

Let x = min(a, b)

If k >= 2*x:

Perform x pairs of attacks: reduce a and b by x.

k -= 2*x

Else:

Determine how many pairs of attacks can be performed: pairs = k // 2

Reduce a and b by pairs.

k -= 2*pairs

If a <= pairs:

The first ship is sunk.

Increment sunk counter.

If b <= pairs:

The last ship is sunk.

Increment sunk counter.

Remove the sunk ships from the deque.

If k > 0 and there's only one ship left:

If k >= the remaining ship's durability:

Sink it.

Increment sunk counter.

Else:

Do nothing.

Return the sunk counter.

Wait, but in the example above, when k=5, n=4, a=[1,2,4,3]

First attack: first ship's durability 1 is reduced to 0, sunk, remove it. a=[2,4,3], k=4

Second attack: last ship's durability 3 is reduced to 2, a=[2,4,2], k=3

Third attack: first ship's durability 2 is reduced to 1, a=[1,4,2], k=2

Fourth attack: last ship's durability 2 is reduced to 1, a=[1,4,1], k=1

Fifth attack: first ship's durability 1 is reduced to 0, sunk, remove it. a=[4,1], k=0

Total sunk ships: 2

In my proposed algorithm:

Initialize deque: [1,2,4,3]

x = min(1,3) = 1

k >= 2*1 => yes

a and b reduced by 1: a=0, b=2

k -= 2 => k=3

Since a=0, first ship is sunk, remove it. deque=[2,4,2], sunk=1

Next iteration:

x = min(2,2) = 2

k >= 2*2 => 3 >= 4 => no

pairs = k // 2 = 1

Reduce a and b by 1: a=1, b=1

k -= 2 => k=1

Neither a nor b is <=1, so no ships sunk.

deque remains [1,4,1], k=1

Since k=1 and there are multiple ships left, can't perform a pair attack.

If k is odd, the next attack would be on the first ship.

Attack first ship: a[0] =1 -1 =0, sunk, remove it.

deque=[4,1], k=0

sunk=2

Which matches the example.

Seems promising.

Let me try another example:

n=4, k=6, a=[1,2,4,3]

Following the same steps:

First pair: x=min(1,3)=1, k>=2 => yes, a=0, b=2, k=4, remove first ship, deque=[2,4,2], sunk=1

Next pair: x=min(2,2)=2, k>=4 => yes, a=0, b=0, k=0, remove both, sunk=3

But according to the example output, it should be 3 sunk ships.

Wait, but in the problem's example output for n=4, k=6, a=[1,2,4,3], it's 3.

Yes, matches.

Another example:

n=5, k=20, a=[2,7,1,8,2]

Following the algorithm:

First pair: x=min(2,2)=2, k>=4 => yes, a=0, b=0, k=16, remove both, deque=[7,1,8], sunk=2

Next pair: x=min(7,8)=7, k>=14 => yes, a=0, b=1, k=2, remove first ship, deque=[1,8], sunk=3

Next, k=2, which is enough for one pair, but min(1,8)=1, k>=2 => yes, a=0, b=7, k=0, remove first ship, deque=[7], sunk=4

Then, k=0, but since k=0, no more attacks.

So, sunk=4, but according to the sample output, it's 5.

Wait, discrepancy here.

Wait, sample output for n=5, k=20, a=[2,7,1,8,2] is 5, but according to my algorithm, it's 4.

Hmm, need to check.

Wait, perhaps I need to consider that after removing ships, if only one ship is left and k is still remaining, I should check if it can be sunk.

In the above case:

After sinking the first four ships, deque=[7], k=0, so no more attacks.

But according to sample output, all 5 ships are sunk.

Wait, perhaps I misread the sample output.

Wait, let's check the sample input and output.

Sample Input:

6

4 5

1 2 4 3

4 6

1 2 4 3

5 20

2 7 1 8 2

2 2

3 2

2 15

1 5

2 7

5 2

Sample Output:

2

3

5

0

2

2

So, for n=5, k=20, a=[2,7,1,8,2], output is 5.

In my algorithm, I have sunk=4, but according to sample, it's 5.

So, perhaps there's a mistake in my algorithm.

Let me try to simulate it step by step.

Initial deque: [2,7,1,8,2], k=20

First pair: x=min(2,2)=2, k>=4 => yes, a=0, b=0, k=16, remove both, deque=[7,1,8], sunk=2

Second pair: x=min(7,8)=7, k>=14 => yes, a=0, b=1, k=2, remove first ship, deque=[1,8], sunk=3

Third pair: x=min(1,8)=1, k>=2 => yes, a=0, b=7, k=0, remove first ship, deque=[7], sunk=4

Now, k=0, but deque has one ship left with durability 7.

According to my algorithm, since k=0, no more attacks, so total sunk=4.

But sample output is 5, meaning all ships are sunk.

So, there must be something wrong with my algorithm.

Wait, perhaps I need to consider that after removing ships, if only one ship is left, and k is still remaining, I should check if that single ship can be sunk with the remaining k attacks.

In the above step, after sinking the fourth ship, deque=[7], k=0.

But in reality, after removing the fourth ship, if k is still greater than 0, I should check if the remaining k attacks can sink the last ship.

Wait, but in this case, k=0, so no more attacks.

Wait, but according to the sample output, all 5 ships are sunk, which suggests that even if k=0, all ships are considered sunk.

Wait, maybe I miscounted.

Wait, perhaps every time a ship is removed, it's considered sunk, regardless of whether k is exhausted or not.

In my earlier simulation, I removed two ships initially (first and last), then two more, and finally one remains.

But according to the sample output, all 5 should be sunk.

Wait, perhaps I need to adjust my algorithm to consider that each removal counts as a sunk ship, regardless of whether k is exhausted or not.

Wait, but in the first example, n=4, k=5, output is 2, meaning only two ships are sunk.

Wait, maybe I need to think differently.

Wait, perhaps I need to keep track of the total attacks made until all ships are sunk, and then see how many ships are sunk within k attacks.

Wait, perhaps I need to simulate the process until all ships are sunk or k attacks are done.

Wait, maybe instead of removing ships immediately when their durability reaches zero, I should mark them as sunk and keep track of the number of sunk ships.

Wait, no, the problem says that when a ship's durability drops to zero, it sinks and is no longer subjected to attacks.

So, I need to remove it from the sequence.

But in the sample case, it seems that all ships are sunk when k=20 and n=5.

Wait, perhaps my earlier simulation was incorrect.

Let me try again.

Initial deque: [2,7,1,8,2], k=20

First attack: first ship 2 -> 1, deque=[1,7,1,8,2], k=19

Second attack: last ship 2 ->1, deque=[1,7,1,8,1], k=18

Third attack: first ship 1 ->0, sunk, remove it, deque=[7,1,8,1], sunk=1, k=17

Fourth attack: last ship 1 ->0, sunk, remove it, deque=[7,1,8], sunk=2, k=16

Fifth attack: first ship 7 ->6, deque=[6,1,8], k=15

Sixth attack: last ship 8 ->7, deque=[6,1,7], k=14

Seventh attack: first ship 6 ->5, deque=[5,1,7], k=13

Eighth attack: last ship 7 ->6, deque=[5,1,6], k=12

Ninth attack: first ship 5 ->4, deque=[4,1,6], k=11

Tenth attack: last ship 6 ->5, deque=[4,1,5], k=10

Eleventh attack: first ship 4 ->3, deque=[3,1,5], k=9

Twelfth attack: last ship 5 ->4, deque=[3,1,4], k=8

Thirteenth attack: first ship 3 ->2, deque=[2,1,4], k=7

Fourteenth attack: last ship 4 ->3, deque=[2,1,3], k=6

Fteenth attack: first ship 2 ->1, deque=[1,1,3], k=5

Sixteenth attack: last ship 3 ->2, deque=[1,1,2], k=4

Seventeenth attack: first ship 1 ->0, sunk, remove it, deque=[1,2], sunk=3, k=3

Eighteenth attack: last ship 2 ->1, deque=[1,1], k=2

Nineteenth attack: first ship 1 ->0, sunk, remove it, deque=[1], sunk=4, k=1

Twentieth attack: last ship 1 ->0, sunk, remove it, deque=[], sunk=5, k=0

So, total sunk ships: 5, which matches the sample output.

But this is a very time-consuming process to simulate one by one, especially with large n and k.

I need a better way to handle this.

Let me think differently.

I can model this as a process where in each cycle (first and last attack), I can reduce the durability of the first and last ship by 1, provided their durability is greater than 0.

If a ship's durability reaches 0, it's removed, and the sequence is updated.

I need to process these cycles until k attacks are done or all ships are sunk.

But directly simulating this would be inefficient for large n and k.

I need a way to batch process these attacks.

Let me consider that in each pair of attacks (first and last), I can reduce both ships' durability by 1, as long as both have durability >0.

If I have multiple such pairs, I can calculate how many pairs I can perform before one of the ships sinks.

For example, if the first ship has durability a and the last has b, and a <= b, then in a pairs of attacks, the first ship will be sunk, and the last ship will have b - a remaining durability.

Similarly, if b < a, then after b pairs, the last ship is sunk, and the first ship has a - b remaining durability.

After one ship is sunk, I remove it and repeat the process with the updated sequence.

To handle this efficiently, I can use a deque to add and remove from both ends.

But even with a deque, if I simulate each pair of attacks one by one, it might be too slow for n=2e5 and k=1e15.

I need a way to handle large k efficiently.

One approach is to batch process the attacks in chunks where the number of attacks is the minimum durability of the first and last ship multiplied by 2.

For example, if the first ship has durability a and the last has b, and m = min(a, b), then I can perform m pairs of attacks, reducing both ships' durability by m.

This would consume 2*m attacks.

After that, I remove the ships that have durability reduced to 0.

I can repeat this process until k is less than 2*m.

When k < 2*m, I need to process the remaining k attacks one by one, alternating between the first and last ship.

This way, I can handle large k efficiently by processing in batches.

Let me try this with the earlier example:

n=5, k=20, a=[2,7,1,8,2]

Initial deque: [2,7,1,8,2]

m = min(2,2) = 2, 2*2=4 <=20, so perform 2 pairs:

a=2-2=0, b=2-2=0, remove both, deque=[7,1,8], k=20-4=16, sunk=2

Now, deque=[7,1,8]

m = min(7,8)=7, 2*7=14 <=16, perform 7 pairs:

a=7-7=0, b=8-7=1, remove first ship, deque=[1,8], k=16-14=2, sunk=3

Now, deque=[1,8], k=2

m = min(1,8)=1, 2*1=2 <=2, perform 1 pair:

a=1-1=0, b=8-1=7, remove first ship, deque=[7], k=2-2=0, sunk=4

Now, deque=[7], k=0

No more attacks, total sunk=4

But according to the sample, it should be 5.

Wait, perhaps I need to consider that the last remaining ship can be attacked until it's sunk, even if k is less than its durability.

Wait, in the initial simulation step by step, after sinking the fourth ship, deque=[7], k=0, so no more attacks, but according to the sample, all 5 ships are sunk.

Wait, maybe I need to consider that if k is remaining and there's only one ship left, I can sink it if k >= its durability.

But in this case, k=0, so I can't sink it.

But the sample output says 5, which suggests that all ships are sunk.

Wait, perhaps I miscounted the sunk ships.

Wait, in the step-by-step simulation, after the twentieth attack, deque is empty, and sunk=5.

But in my batch processing, I have sunk=4, which suggests that there's a mistake in my batch processing approach.

Wait, perhaps I need to increment sunk counter every time I remove a ship, not just when I remove it after its durability reaches zero.

Wait, no, the problem says that a ship is sunk when its durability drops to zero.

Let me try another approach.

Maybe I should keep track of the number of attacks performed on each ship.

But with n and k being large, that might not be efficient.

Wait, perhaps I can calculate the total attacks each ship receives based on their positions.

But it's not straightforward because the sequence changes as ships are removed.

Another idea: since the Kraken alternates between attacking the first and last ship, I can model the sequence of attacks.

Let's number the attacks from 1 to k.

Attacks 1,3,5,... are on the first ship, and attacks 2,4,6,... are on the last ship.

But as ships are removed, the first and last ships change.

This seems too vague to implement efficiently.

Let me think about the batch processing again.

In the batch processing, I can process m = min(a, b) pairs, where a and b are the durabilities of the first and last ships.

Each pair consists of one attack on the first and one on the last.

So, I can reduce a and b by m.

Then, if a <= m, the first ship is sunk, and similarly for b.

This seems correct.

Wait, in the earlier example, I ended up with sunk=4, but the sample output is 5.

Perhaps I need to consider that even if k=0, but the last ship has durability <=0 due to previous attacks.

Wait, no, in my simulation, after k=0, there's still one ship left with durability 7.

So, according to my algorithm, only 4 ships are sunk, but the sample output is 5.

This suggests that my algorithm is incorrect.

Wait, perhaps I need to consider that when I perform m pairs of attacks, I should decrement k by 2*m, but if k < 2*m, I need to handle the remaining attacks carefully.

Let me try to adjust my algorithm.

Initialize deque with ships' durabilities.

Initialize sunk = 0

While k > 0 and deque has ships:

a = deque[0]

b = deque[-1]

m = min(a, b)

if k >= 2*m:

# Perform m pairs of attacks

a -= m

b -= m

k -= 2*m

if a == 0:

remove first ship, sunk +=1

if b == 0:

remove last ship, sunk +=1

else:

# k < 2*m

# Determine how many pairs can be performed

pairs = k // 2

# Attack first ship pairs times

a -= pairs

# Attack last ship pairs times

b -= pairs

k -= 2*pairs

if a <=0:

remove first ship, sunk +=1

if b <=0:

remove last ship, sunk +=1

# If k is odd, perform one more attack on the first ship

if k % 2 ==1:

if deque:

if deque[0] >0:

deque[0] -=1

if deque[0] ==0:

remove first ship, sunk +=1

else:

pass

# If deque is empty, no more attacks

else:

pass

Finally, if deque is empty, all ships are sunk.

But in the earlier example, this still gives me sunk=4, while sample output is 5.

Wait, perhaps I need to consider that after removing ships, if only one ship is left, and k is still remaining, I should check if k >= that ship's durability.

In the earlier example, after sinking the fourth ship, deque=[7], k=0.

But in reality, if k=0, I can't perform any more attacks.

So, only 4 ships are sunk.

But according to the sample output, it's 5.

Wait, perhaps there's a mistake in the sample output or my understanding.

Wait, let's look back at the sample input and output.

Sample Input:

6

4 5

1 2 4 3

4 6

1 2 4 3

5 20

2 7 1 8 2

2 2

3 2

2 15

1 5

2 7

5 2

Sample Output:

2

3

5

0

2

2

For the third test case, n=5, k=20, a=[2,7,1,8,2], output is 5.

But according to my algorithm, it's 4.

Wait, maybe I need to consider that after removing the first four ships, even though k=0, the last ship is already sunk because its durability is <=0.

Wait, in my simulation, after removing the fourth ship, deque=[7], k=0.

But in the step-by-step simulation earlier, after 20 attacks, deque is empty, sunk=5.

Wait, perhaps I missed something.

Wait, in the step-by-step simulation, after the twentieth attack, the last ship's durability reaches 0 and is removed, sunk=5.

But in my batch processing, after processing the third pair, deque=[7], k=0.

Wait, perhaps in the batch processing, I need to check if the remaining ship has durability <=0 after the last batch.

Wait, no, in that case, deque=[7], k=0, and durability is 7 >0, so it's not sunk.

But in the step-by-step simulation, with k=0, no more attacks, so deque=[7], sunk=4.

But sample output is 5.

This inconsistency suggests that my batch processing approach is missing something.

Wait, perhaps I need to consider that when I perform the last batch, I might have overcounted the attacks.

Wait, maybe I need to adjust the batch size to ensure that I don't overstep the remaining k attacks.

Let me try another approach.

Instead of batch processing, I can process the attacks in pairs until k < 2.

In each pair, reduce the first and last ship's durability by 1, and decrement k by 2.

If a ship's durability reaches 0, remove it and increment sunk.

If k becomes odd, perform one more attack on the first ship.

This might be simpler.

Let me try with n=5, k=20, a=[2,7,1,8,2]

Initial deque: [2,7,1,8,2], k=20

Pair 1: a=2-1=1, b=2-1=1, k=18

Pair 2: a=1-1=0, b=1-1=0, remove both, deque=[7,1,8], sunk=2, k=16

Pair 3: a=7-1=6, b=8-1=7, k=14

Pair 4: a=6-1=