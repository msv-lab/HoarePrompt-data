Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n ships, each with a certain durability, arranged in a line from 1 to n. The Kraken attacks these ships k times, alternating between the first and the last ship. Each attack reduces the durability of the target ship by 1. If a ship's durability drops to 0, it sinks and is removed from the line. I need to figure out how many ships are sunk after k attacks.

First, I need to understand the sequence of attacks. The Kraken starts by attacking the first ship, then the last, then the first again, and so on. After each pair of attacks (first and last), it continues until it has performed k attacks in total.

I should think about how to simulate this process efficiently, especially since n can be up to 2*10^5 and k can be up to 10^15. That's a lot, so a naive simulation where I iterate each attack one by one would be too slow. I need a smarter way to handle this.

Let me consider the pattern of attacks. Since the Kraken alternates between the first and the last ship, I can think of the attacks in pairs: one on the first and one on the last. Each pair reduces the durability of both the first and the last ship by 1, unless one of them has already sunk.

But k can be up to 10^15, which is a huge number, so I need to find a way to process multiple attacks at once, maybe in batches.

I should consider the durabilities of the ships at the ends. Let's say the first ship has durability a[l] and the last has a[r]. If a[l] <= a[r], then the first ship will sink first if the Kraken keeps attacking it and the last ship alternately.

Wait, no. If a[l] <= a[r], and the Kraken attacks the first ship, reducing a[l] by 1, and then attacks the last ship, reducing a[r] by 1, and repeats this process. So effectively, each pair of attacks reduces both a[l] and a[r] by 1.

Similarly, if a[l] > a[r], the last ship will sink first.

I need to find a way to handle these pairs of attacks efficiently.

Let me think about it in terms of while loops. I can have a loop that continues as long as there are ships left and attacks remaining.

I'll maintain two pointers, l and r, representing the current first and last ships that haven't sunk yet.

In each iteration of the loop, I'll determine how many pairs of attacks I can perform before one of the end ships sinks.

For example, if a[l] <= a[r], then after a[l] pairs of attacks, the first ship will sink. In these a[l] pairs, the last ship's durability will be reduced by a[l]. So, I can reduce a[r] by a[l], set a[l] to 0 (sunk), and increment the count of sunks.

Then, I move the l pointer to the next ship.

Similarly, if a[l] > a[r], I can perform a[r] pairs of attacks, reducing a[l] by a[r] and setting a[r] to 0, incrementing sunks, and moving the r pointer accordingly.

I need to keep track of the number of pairs of attacks performed and ensure that I don't exceed the total k attacks.

Wait, but k can be up to 10^15, which is a very large number, so I need to make sure that I can handle large k efficiently.

Let me formalize this approach:

1. Initialize l = 0 and r = n - 1.

2. While l <= r and k > 0:

a. If l == r, meaning only one ship left:

i. If k >= a[l], sink this ship and break.

ii. Else, break since not enough attacks to sink it.

b. Else, if a[l] <= a[r]:

i. If k >= a[l] * 2:

- Perform a[l] * 2 attacks: a[l] attacks on the first ship and a[l] attacks on the last ship.

- Reduce a[r] by a[l].

- Set a[l] to 0 (sunk).

- Increment sunks by 1.

- Move l to l + 1.

- Subtract a[l] * 2 from k.

ii. Else if k == a[l] * 2 - 1:

- Perform k attacks: a[l] attacks on the first ship and (a[l] - 1) attacks on the last ship.

- Set a[l] to 0 (sunk).

- Reduce a[r] by (a[l] - 1).

- Increment sunks by 1.

- Break.

iii. Else:

- Not enough attacks to sink either ship, break.

c. Else if a[l] > a[r]:

i. Similar to the above, but considering a[r] instead.

- If k >= a[r] * 2:

- Perform a[r] * 2 attacks: a[r] attacks on the first ship and a[r] attacks on the last ship.

- Reduce a[l] by a[r].

- Set a[r] to 0 (sunk).

- Increment sunks by 1.

- Move r to r - 1.

- Subtract a[r] * 2 from k.

ii. Else if k == a[r] * 2 - 1:

- Perform k attacks: a[r] attacks on the first ship and (a[r] - 1) attacks on the last ship.

- Set a[r] to 0 (sunk).

- Reduce a[l] by a[r].

- Increment sunks by 1.

- Break.

iii. Else:

- Not enough attacks to sink either ship, break.

This seems like a reasonable approach. I need to implement this logic carefully to handle all edge cases, such as when there's only one ship, or when k is very large but doesn't suffice to sink any more ships.

Let me think about some examples to verify this logic.

Example 1:

n=4, k=5, a=[1,2,4,3]

Step-by-step:

- l=0, r=3

- a[l]=1 <= a[r]=3

- k=5 >= 1*2=2

- Perform 2 attacks: first ship goes to 0, last ship to 3-1=2

- sunks=1

- l=1, r=3, a=[0,2,4,2], k=3

- l < r

- a[l]=2 <= a[r]=2

- k=3 >= 2*2=4? No.

- k=3 == 2*2 -1=3

- Perform 3 attacks: first ship to 2-1=1, last ship to 2-1=1

- sunks=1

- Break

- Only one ship sunk so far, but according to the example, after 5 attacks, two ships are sunk.

Wait, seems like my logic is missing something here.

Wait, in the example, after 5 attacks, a=[1,4,2], meaning two ships are sunk (the first and the last originally).

But according to my steps above, I have k=3 left after first iteration, but perhaps I need to continue.

Wait, maybe I need to adjust the logic.

Let me try again.

Alternative approach:

Instead of processing in fixed pairs, consider that each pair of attacks reduces both ends by 1, until one of them runs out.

So, in each iteration:

- Determine the minimum number of pairs that can be performed before one of the ends runs out.

- If a[l] <= a[r], then after a[l] pairs, the first ship sinks.

- Else, after a[r] pairs, the last ship sinks.

- Perform that number of pairs, update the durabilities, move the pointers, and subtract the attacks performed.

- Continue until k is exhausted or no ships are left.

Wait, perhaps I need to think in terms of the minimum durability between the two ends.

Let me try this approach.

Updated approach:

While l <= r and k > 0:

if l == r:

if k >= a[l]:

sunks +=1

break

else:

break

else:

if a[l] <= a[r]:

# First ship will sink first after a[l] pairs

if k >= a[l] * 2:

# Perform a[l] * 2 attacks

k -= a[l] * 2

a[r] -= a[l]

sunks +=1

l +=1

if a[r] <=0:

sunks +=1

r -=1

elif k == a[l] * 2 -1:

# Perform k attacks: a[l] on first, a[l]-1 on last

a[l] =0

a[r] -= (a[l])

sunks +=1

break

else:

break

else:

# a[l] > a[r]

if k >= a[r] * 2:

# Perform a[r] * 2 attacks

k -= a[r] * 2

a[l] -= a[r]

sunks +=1

r -=1

if a[l] <=0:

sunks +=1

l +=1

elif k == a[r] * 2 -1:

# Perform k attacks: a[r] on first, a[r]-1 on last

a[r] =0

a[l] -= a[r]

sunks +=1

break

else:

break

Let's try this with the first example:

n=4, k=5, a=[1,2,4,3]

l=0, r=3

a[l]=1 <= a[r]=3

k=5 >= 1*2=2

Perform 2 attacks: k=3

a[r] -=1 => a=[1,2,4,2], l=1, r=3

Check a[l]=2 <= a[r]=2

k=3 >=2*2=4? No

k=3 ==2*2-1=3

Perform 3 attacks: a[l]-=2, a[r]-=1

a=[1,0,4,1], sunks=2

Break

Total sunks=2, which matches the example.

Another test:

n=4, k=6, a=[1,2,4,3]

Following the same steps as above:

After first iteration: k=3, a=[1,2,4,2], l=1, r=3

Then:

a[l]=2 <= a[r]=2

k=3 >=4? No

k=3 ==3

Perform 3 attacks: a[l]-=2, a[r]-=1 => a=[1,0,4,1], sunks=2

Break

But according to the sample output, for n=4 k=6, output is 3.

Wait, seems like my logic is not complete.

Wait, perhaps I need to continue attacking after one ship is sunk.

Wait, no. When a ship sinks, it's removed from the line, so the ends change.

Wait, in the first iteration, when a[l] is sunk, l is incremented.

Then, check again.

Wait, perhaps I need to adjust the conditions.

Let me try another approach.

Use a deque to simulate the ships, since we are removing from both ends.

But with n up to 2e5 and t up to 1e4, that might be too slow.

Wait, but time constraints are tight, so I need an O(n) solution.

Wait, n is up to 2e5 per test case, and t up to 1e4, but total n across all test cases is 2e5, so it should be manageable.

But I need to optimize it.

Alternative idea:

Since k can be up to 1e15, but n is up to 2e5, I can process the ships in pairs, calculating how many attacks are needed to sink them.

But it's not that simple because the attacks are alternating between first and last.

Wait, perhaps I can calculate the total number of attacks needed to sink all ships, and see if k is sufficient.

But the problem is that k might not be enough to sink all ships, and I need to find exactly how many are sunk.

Wait, maybe I can model this as a two-pointer approach where I keep track of the attacks on the first and last ships, and iteratively sink them as needed.

Wait, perhaps I can think in terms of the sum of durabilities.

But that might not work because the attacks are alternating.

Wait, perhaps I can calculate how many full cycles of attacks I can perform before sinking one or both of the end ships.

Let me try to formalize this.

Define a cycle as two attacks: one on the first ship and one on the last ship.

In each cycle, both a[l] and a[r] are reduced by 1, provided they are still afloat.

If a[l] <= a[r], then after a[l] cycles, the first ship sinks.

Similarly, if a[l] > a[r], then after a[r] cycles, the last ship sinks.

So, in general, the number of cycles needed to sink one of the end ships is min(a[l], a[r]).

After that, we can move the corresponding pointer and repeat the process.

But k can be up to 1e15, so I need to handle a large number of cycles efficiently.

I can calculate how many cycles I can perform before running out of k attacks or before sinking one of the end ships.

Let me try to implement this logic.

Initialize l=0, r=n-1, sunks=0

While l <= r and k > 0:

if l == r:

if k >= a[l]:

sunks +=1

break

else:

break

else:

att_per_cycle = 2

min_a = min(a[l], a[r])

cycles = min(k // att_per_cycle, min_a)

# Perform cycles number of cycles

a[l] -= cycles

a[r] -= cycles

k -= cycles * att_per_cycle

if a[l] == 0:

sunks +=1

l +=1

if a[r] == 0:

sunks +=1

r -=1

This seems better.

In this way, I can handle multiple cycles at once, reducing a[l] and a[r] by the same amount.

Wait, but when l == r, I need to handle it differently because it's only one ship.

In that case, if k >= a[l], it sinks, and I break.

Otherwise, I can't sink it, and I break.

Let me test this logic with the first example.

n=4, k=5, a=[1,2,4,3]

l=0, r=3

min_a = min(1,3)=1

cycles = min(5//2,1)=1

a[l]-=1 => a[l]=0

a[r]-=1 => a[r]=2

k -=2 => k=3

sunks=1

l=1, r=3

a=[0,2,4,2]

min_a = min(2,2)=2

cycles = min(3//2,2)=1

a[l]-=1 => a[l]=1

a[r]-=1 => a[r]=1

k -=2 => k=1

sunks=1

l=1, r=3

a=[0,1,4,1]

min_a = min(1,1)=1

cycles = min(1//2,1)=0

Not enough attacks to perform another cycle, so break.

Total sunks=1, but according to the sample, it should be 2.

Wait, perhaps I need to handle the remaining attacks after the cycles.

In the above step, after cycles=1, k=1, but I have to see if I can perform any additional attacks.

Maybe I need to adjust the logic to handle the remaining attacks after performing the full cycles.

Let me think again.

After performing the full cycles, I might have some attacks left (k might be odd, since attacks are performed in pairs).

So, after performing the full cycles, if k is still greater than 0, I can perform the remaining attack on the first ship.

Wait, but k is divided by 2 to get the number of cycles, since each cycle consists of 2 attacks.

Wait, perhaps I need to adjust the calculation.

Alternative idea:

Calculate the number of full cycles I can perform with k attacks.

Each cycle consists of one attack on the first ship and one on the last ship.

So, total cycles = k // 2

Then, determine how many cycles I can perform before sinking one of the end ships.

Let me try this.

Initialize l=0, r=n-1, sunks=0

While l <= r and k > 0:

if l == r:

if k >= a[l]:

sunks +=1

break

else:

break

else:

cycles = min(k // 2, a[l], a[r])

a[l] -= cycles

a[r] -= cycles

k -= cycles * 2

if a[l] == 0:

sunks +=1

l +=1

if a[r] == 0:

sunks +=1

r -=1

But in the first example, n=4, k=5, a=[1,2,4,3]

l=0, r=3

cycles = min(5//2=2,1,3)=1

a[l]-=1 => a[l]=0

a[r]-=1 => a[r]=2

k -=2 => k=3

sunks=1

l=1, r=3

a=[0,2,4,2]

cycles = min(3//2=1,2,2)=1

a[l]-=1 => a[l]=1

a[r]-=1 => a[r]=1

k -=2 => k=1

sunks=1

l=1, r=3

a=[0,1,4,1]

cycles = min(1//2=0,1,1)=0

No more cycles can be performed, so break.

Total sunks=1, but sample output is 2.

Wait, perhaps I need to handle the remaining attack when k is odd.

In this case, k=1 is left, which can be used to attack the first ship.

So, after the cycles, if k > 0, perform one more attack on the first ship.

Thus, a[l] -=1

if a[l] ==0:

sunks +=1

l +=1

But in this case, a[l]=1-1=0, so sunks=2

That matches the sample output.

So, I need to adjust the logic to handle the remaining attack if k is odd.

Let me modify the approach:

While l <= r and k > 0:

if l == r:

if k >= a[l]:

sunks +=1

break

else:

break

else:

cycles = min(k // 2, a[l], a[r])

a[l] -= cycles

a[r] -= cycles

k -= cycles * 2

if a[l] == 0:

sunks +=1

l +=1

if a[r] == 0:

sunks +=1

r -=1

if k % 2 ==1:

if l <= r:

a[l] -=1

if a[l] ==0:

sunks +=1

l +=1

This should work.

Let's test it with the first example:

n=4, k=5, a=[1,2,4,3]

l=0, r=3

cycles = min(2,1,3)=1

a[l]=0, a[r]=2

k=3

sunks=1

l=1, r=3

a=[0,2,4,2]

cycles = min(1,2,2)=1

a[l]=1, a[r]=1

k=1

sunks=1

l=1, r=3

a=[0,1,4,1]

cycles = min(0,1,1)=0

k=1 is odd, l <= r

a[l]=1-1=0

sunks=2

l=2, r=3

a=[0,0,4,0]

But r -=1 since a[r]=0

sunks=3

Wait, but according to the sample, only two ships are sunk.

Wait, perhaps I need to ensure that I don't increment sunks for the same ship multiple times.

Wait, in the first iteration, a[l]=1-1=0, sunks=1, l=1

Then, in the second iteration, a[l]=2-1=1, a[r]=2-1=1, k=1

Then, k=1 is odd, attack a[l]=1-1=0, sunks=2, l=2

Then, r=3, a[r]=1-1=0, sunks=3

But according to the sample, only two ships are sunk.

Wait, perhaps I need to ensure that I don't perform an extra attack when k is odd and l > r.

Wait, in the sample explanation, after 5 attacks, a=[1,4,2], meaning ships 1 and 4 are sunk.

So, only two ships are sunk.

In my adjusted logic, I ended up with sunks=3, which is incorrect.

So, there's still an issue with the logic.

Alternative idea:

Instead of performing cycles and then a potential extra attack, maybe I need to alternate the attacks properly.

That is, first attack the first ship, then the last, and so on, in an alternating fashion, but in batches to handle large k.

Let me try to think differently.

Initialize l=0, r=n-1, sunks=0

While l <= r and k > 0:

if l == r:

if k >= a[l]:

sunks +=1

break

else:

break

else:

if a[l] <= a[r]:

# First ship will sink first after a[l] attacks

if k >= a[l] * 2:

# Perform a[l] attacks on first and a[l] attacks on last

k -= a[l] * 2

a[r] -= a[l]

sunks +=1

l +=1

if a[r] ==0:

sunks +=1

r -=1

elif k >= a[l] * 2 -1:

# Perform a[l]*2 -1 attacks: a[l] on first, a[l]-1 on last

k -= a[l] * 2 -1

a[l] =0

a[r] -= (a[l])

sunks +=1

break

else:

break

else:

# a[l] > a[r]

if k >= a[r] * 2:

# Perform a[r] attacks on first and a[r] attacks on last

k -= a[r] * 2

a[l] -= a[r]

sunks +=1

r -=1

if a[l] ==0:

sunks +=1

l +=1

elif k >= a[r] * 2 -1:

# Perform a[r]*2 -1 attacks: a[r] on first, a[r]-1 on last

k -= a[r] * 2 -1

a[r] =0

a[l] -= a[r]

sunks +=1

break

else:

break

This seems similar to what I had earlier.

Let's try it with n=4, k=5, a=[1,2,4,3]

l=0, r=3

a[l]=1 <= a[r]=3

k=5 >=1*2=2

k -=2, k=3

a[r] -=1, a=[1,2,4,2]

sunks=1

l=1, r=3

a[l]=2 <= a[r]=2

k=3 >=2*2=4? No

k=3 ==2*2 -1=3

k -=3, k=0

a[l] -=2, a[l]=0

a[r] -=1, a[r]=1

sunks=2

Break

Total sunks=2, which matches the sample.

Another test: n=4, k=6, a=[1,2,4,3]

Following the same steps:

First iteration:

l=0, r=3

a[l]=1 <= a[r]=3

k=6 >=1*2=2

k -=2, k=4

a[r] -=1, a=[1,2,4,2]

sunks=1

l=1, r=3

a[l]=2 <= a[r]=2

k=4 >=2*2=4

k -=4, k=0

a[r] -=2, a=[1,2,4,0]

sunks=2

l=1, r=2

But a[r]=0, so sunks +=1, sunks=3

r=1

l=1, r=1

a[l]=2

k=0, so break

Total sunks=3, which matches the sample.

Another test: n=5, k=20, a=[2,7,1,8,2]

Proceed similarly.

So, perhaps this logic is correct.

I need to implement it carefully to handle all edge cases.

I should also consider cases where k is very large, up to 1e15, but since I'm processing in batches, it should handle large k efficiently.

Also, need to make sure that I don't perform negative attacks or have negative durabilities.

I need to be careful with the conditions when l == r, to handle the last ship correctly.

Additionally, I need to ensure that I don't count a ship as sunk multiple times.

I should also consider the case when n=1, which is straightforward.

Let me think about n=2, k=2, a=[3,2]

l=0, r=1

a[l]=3 > a[r]=2

So, k >=2*2=4? No

k >=2*2-1=3? Yes

k -=3, k=-1 (but should be 0), a[l]-=2, a[r]-=1 => a=[1,1]

sunks=1

But according to the sample, output is 0, meaning no ships are sunk.

Wait, but in this step, a[l]=1 and a[r]=1, which are both still afloat.

So, sunks=1 is correct, but according to the sample, output is 0.

Wait, sample input has n=2 k=2 a=[3,2], output=0.

But according to my logic, sunks=1.

Wait, perhaps I misread the sample.

Wait, in the sample input, for n=2 k=2 a=[3,2], output=0.

But according to my logic, I have sunks=1, which doesn't match the sample.

So, perhaps there's a mistake in my logic.

Let me check again.

n=2, k=2, a=[3,2]

l=0, r=1

a[l]=3 > a[r]=2

k >=2*2=4? No

k >=2*2-1=3? No

So, break without sinking any ships.

Thus, sunks=0, which matches the sample.

I must have miscalculated earlier.

Yes, in the else clause, if k < a[r]*2 -1, then break without sinking any ships.

Hence, sunks=0.

So, my logic is correct.

Another test: n=2 k=7 a=[1,5]

l=0, r=1

a[l]=1 <= a[r]=5

k >=1*2=2? Yes

k -=2, k=5

a[r] -=1, a=[1,4]

sunks=1

l=1, r=1

a[l]=4

k=5 >=4

sunks +=1

break

Total sunks=2, which matches the sample.

Another test: n=2 k=7 a=[5,2]

l=0, r=1

a[l]=5 > a[r]=2

k >=2*2=4? Yes

k >=4? Yes

k -=4, k=3

a[l] -=2, a=[3,2]

sunks=1

r=0

l=0, r=0

a[l]=3

k=3 >=3

sunks +=1

break

Total sunks=2, matches the sample.

Last test: n=2 k=15 a=[1,5]

l=0, r=1

a[l]=1 <= a[r]=5

k >=1*2=2? Yes

k -=2, k=13

a[r] -=1, a=[1,4]

sunks=1

l=1, r=1

a[l]=4

k=13 >=4

sunks +=1

break

Total sunks=2, matches the sample.

Seems like the logic is correct.

Therefore, the given program is correct.

**Final Solution**

To solve this problem, we need to determine how many ships are sunk after a series of attacks by the Kraken. The Kraken alternates between attacking the first and the last ship in a line, reducing their durability until they sink.

### Approach

1. **Initialization**:
   - We use two pointers, `l` and `r`, to track the current first and last ships that haven't sunk yet.
   - We maintain a counter `sunks` to count the number of ships that have been sunk.

2. **Simulate Attacks**:
   - While there are ships left (`l <= r`) and attacks remaining (`k > 0`):
     - If only one ship is left (`l == r`), check if the remaining attacks can sink it.
     - If multiple ships are left:
       - Determine which end (first or last ship) has lesser durability.
       - Calculate the number of attack pairs that can be performed before one of the end ships sinks.
       - Update the durability of the ships and the attack count accordingly.
       - Move the pointers and increment the sunk ships counter when a ship's durability drops to zero.

3. **Efficiently Handle Large `k`**:
   - By processing attack pairs in batches, we efficiently handle large values of `k` without iterating attack by attack.

### Solution Code

```python
def func_1(n, k, a):
    l, r = 0, n - 1
    sunks = 0
    while l <= r and k > 0:
        if l == r:
            if k >= a[l]:
                sunks += 1
                break
            else:
                break
        else:
            if a[l] <= a[r]:
                if k >= a[l] * 2:
                    k -= a[l] * 2
                    a[r] -= a[l]
                    sunks += 1
                    l += 1
                    if a[r] == 0:
                        sunks += 1
                        r -= 1
                elif k == a[l] * 2 - 1:
                    k -= a[l] * 2 - 1
                    a[l] = 0
                    a[r] -= (a[l])
                    sunks += 1
                    break
                else:
                    break
            else:
                if k >= a[r] * 2:
                    k -= a[r] * 2
                    a[l] -= a[r]
                    sunks += 1
                    r -= 1
                    if a[l] == 0:
                        sunks += 1
                        l += 1
                elif k == a[r] * 2 - 1:
                    k -= a[r] * 2 - 1
                    a[r] = 0
                    a[l] -= a[r]
                    sunks += 1
                    break
                else:
                    break
    return sunks

# Read input and process each test case
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(func_1(n, k, a))
```

### Explanation

- **Initialization**: We initialize pointers `l` and `r` to the start and end of the ship list, and `sunks` to keep track of sunk ships.
- **Simulate Attacks**:
  - We handle the case when only one ship is left separately.
  - For multiple ships, we check which end has lesser durability and perform attacks in pairs accordingly.
  - We update the ship durabilities and attack count in batches to handle large `k` efficiently.
- **Efficient Handling of Large `k`**: By processing attacks in pairs and updating ship durabilities in bulk, we ensure the solution runs efficiently even for large input sizes.

This approach ensures we correctly and efficiently determine the number of ships sunk after the Kraken's attacks.