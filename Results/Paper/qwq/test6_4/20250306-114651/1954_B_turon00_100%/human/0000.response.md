Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. If it's impossible to make it not beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if I can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ |a| - 1) such that a[i - 1] = a[i + 1], and replace a[i] with a[i - 1].

So, in other words, if the elements on both sides of an element are equal, I can change that element to match them. This operation can be performed any number of times.

I need to make sure I understand how this operation works. Let's take an example from the problem:

Example 1:

Input: [2, 2, 2]

Output: -1

Explanation: It's impossible to make this array not beautiful because no matter how many elements you remove, all elements are already the same.

Example 2:

Input: [1, 2, 1, 2, 1]

Output: 1

Explanation: By removing one element, say the last one, the array becomes [1, 2, 1, 2], which is not beautiful.

Example 3:

Input: [1]

Output: -1

Explanation: A single-element array is already beautiful, and removing it would make the array empty, which is considered not beautiful. But according to the problem, we should output -1 if it's impossible to make it not beautiful.

Example 4:

Input: [3, 3, 3, 5, 3, 3, 3]

Output: 3

Explanation: By removing the first three 3's, the array becomes [5, 3, 3, 3], which is not beautiful.

From these examples, I need to find a pattern or a property that determines whether an array can be made not beautiful by removing a certain number of elements.

Let me think about the operation allowed. The operation allows me to change an element in the middle if its neighbors are equal. This seems like a way to propagate the value of the neighbors into the middle element.

If I have a sequence where all elements are the same, like [2, 2, 2], I can't make it not beautiful by removing elements because no matter which elements I remove, the remaining array will still have all elements equal, which is beautiful.

In the second example, [1, 2, 1, 2, 1], if I remove one element, say the last one, the array becomes [1, 2, 1, 2]. Now, let's see if this is beautiful. Can I make all elements the same using the operation?

Looking at index 2 (0-based indexing), a[1] = 2, a[0] = 1, a[2] = 1. Since a[0] != a[2], I can't perform the operation on a[1].

Looking at index 3, a[2] = 1, a[1] = 2, a[3] = 2. Again, a[1] != a[3], so I can't perform the operation on a[2].

So, no operations can be performed, and the array is not beautiful.

Another way to look at it is that in the original array [1, 2, 1, 2, 1], if I remove one element, I break the pattern needed for the operation.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], if I remove the first three 3's, the array becomes [5, 3, 3, 3]. Now, can I make all elements the same?

Looking at index 1, a[0] = 5, a[1] = 3, a[2] = 3. Since a[0] != a[2], I can't perform the operation on a[1].

Looking at index 2, a[1] = 3, a[2] = 3, a[3] = 3. Here, a[1] == a[3], so I can replace a[2] with a[1], making the array [5, 3, 3, 3] -> [5, 3, 3, 3]. No change because a[2] was already 3.

No operations can change the array, and since the elements are not all the same, it's not beautiful.

So, the goal is to remove the minimum number of elements to break the property that allows the array to be made beautiful.

I need to find a way to identify the smallest set of elements to remove so that no sequence remains where the operation can be applied to make all elements equal.

But this seems complicated. Maybe there's a simpler way to look at it.

Let me consider that the array is beautiful if there exists a value that can be propagated through the operations to make all elements equal.

Given that, perhaps the array is beautiful if all elements can be made equal to a certain value by repeatedly applying the operation.

But how can I determine if it's possible to make all elements equal to a certain value?

Wait, the problem states that the array is already beautiful, so I don't need to check if it's beautiful; I need to find the minimum number of elements to remove to make it not beautiful.

So, perhaps I need to find the smallest number of elements to remove so that it's no longer possible to make all elements equal.

Another way to think about it is to find the smallest number of elements to remove so that there's no way to propagate any value through the array using the operation.

But this seems too vague. Let's think differently.

Let's consider that in a beautiful array, if I can make all elements equal to a certain value by replacing elements in the middle that have equal neighbors.

This seems similar to propagating a value through the array, like a contagion, where if two elements are the same, they can make their neighbor the same.

So, perhaps the array is beautiful if all connected components of the same value can be connected through these operations.

Wait, maybe I should think in terms of groups of the same values.

Let's consider that the array is divided into segments of the same value.

For example, in [1, 2, 1, 2, 1], the segments are 1, 2, 1, 2, 1.

In [3, 3, 3, 5, 3, 3, 3], the segments are 3, 5, 3.

Now, if there is only one unique value in the array, it's already beautiful, and it's impossible to make it not beautiful by removing elements because removing elements won't change that all remaining elements are the same.

But in the second example, [1, 2, 1, 2, 1], there are multiple values, and by removing one element, I can break the pattern.

So, perhaps the key is to find the minimal number of elements to remove so that not all remaining elements can be made equal.

Wait, but in the first example, [2, 2, 2], it's impossible to make it not beautiful, so the output is -1.

In the third example, [1], it's a single element, which is already beautiful, and removing it would make the array empty, which is not beautiful.

So, perhaps the rule is that if the array has only one unique value or has only one element, it's impossible to make it not beautiful.

But in the fourth example, [3, 3, 3, 5, 3, 3, 3], by removing three elements, I can make it [5, 3, 3, 3], which is not beautiful.

Wait, but why three? Is there a better way?

Wait, in that example, removing the first three 3's gives [5, 3, 3, 3], which is not beautiful.

But is there a way to remove fewer elements to achieve the same?

Let's see: if I remove only two elements, say the first two 3's, the array becomes [3, 5, 3, 3, 3]. Now, can I make all elements equal?

Looking at index 1 (0-based), a[0] = 3, a[1] = 5, a[2] = 3. Since a[0] == a[2], I can replace a[1] with 3, making the array [3, 3, 3, 3, 3]. So, it's still beautiful.

If I remove different elements, say the fourth and fifth elements, removing 5 and one 3, the array becomes [3, 3, 3, 3]. Again, all elements are equal, so it's still beautiful.

So, in this case, I need to remove at least three elements to break the connectivity of the 3's.

Wait, perhaps the minimal number of elements to remove is equal to the smallest segment that connects different values.

But I need a better approach.

Let me consider that the array is beautiful if all elements can be made equal by propagating values through the operations.

So, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal.

One way to think about it is to remove elements such that the remaining array has at least two different values that cannot be made equal through the operations.

But this seems too vague.

Another approach is to find the minimal number of elements to remove so that the remaining array cannot have all elements made equal.

Wait, perhaps I can find the minimal number of elements to remove so that there are at least two different values in the array that cannot be made equal through the operations.

But I need a clearer strategy.

Let me consider that in a beautiful array, if there exists a value that can be propagated through the operations to make all elements equal.

So, to make it not beautiful, I need to ensure that no single value can be propagated to all positions.

In other words, there should be at least two different values in the array such that neither can be propagated to all positions.

But I'm still not sure.

Wait, perhaps I can think in terms of the frequency of the most frequent value.

If the most frequent value appears in a way that it can be propagated to all positions, then removing elements that are not that value won't make the array not beautiful.

But in some cases, even if a value is frequent, removing certain elements can prevent propagation.

This is getting complicated.

Let me look back at the examples.

In the first example, [2, 2, 2], all elements are the same, so it's impossible to make it not beautiful.

In the second example, [1, 2, 1, 2, 1], by removing one element, I can make it [1, 2, 1, 2], which cannot be made beautiful.

In the third example, [1], it's a single element, so it's impossible to make it not beautiful.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], by removing three elements, I can make it [5, 3, 3, 3], which is not beautiful.

Wait, in the fourth example, why not remove fewer elements?

If I remove two elements, say the first two 3's, the array becomes [3, 5, 3, 3, 3]. As I saw earlier, I can still make all elements equal to 3 by replacing the 5 with 3.

So, removing two elements isn't enough.

If I remove three elements, say the first three 3's, the array becomes [5, 3, 3, 3]. Now, I can't make all elements equal to 3 because the 5 can't be changed to 3 since its neighbors are not both 3.

Wait, a[0] = 5, a[1] = 3, a[2] = 3. Since a[1] != a[2], I can't perform the operation on a[1].

Similarly, a[1] = 3, a[0] = 5, a[2] = 3. Since a[0] != a[2], I can't perform the operation on a[1].

So, no operations can be performed, and the array is not beautiful.

Hence, the minimal number of elements to remove is three.

But is there a better way to calculate this?

Let me consider that in a beautiful array, all elements can be made equal to the most frequent value by propagating it through the operations.

To make the array not beautiful, I need to ensure that the most frequent value cannot be propagated to all positions.

So, perhaps the minimal number of elements to remove is equal to the number of elements that are not equal to the most frequent value.

But in the second example, the most frequent values are 1 and 2, both appearing twice.

Wait, in that case, it's not clear which value to consider.

Wait, maybe I need to consider the minimal number of elements to remove so that the remaining array does not have a single value that can be propagated to all positions.

Alternatively, perhaps I need to find the minimal number of elements to remove so that the remaining array has at least two different values that cannot be made equal through the operations.

This is getting too convoluted.

Let me think differently.

Suppose I have an array where all elements are the same; I can't make it not beautiful by removing elements because removing elements won't change that the remaining elements are all the same.

In other cases, where there are multiple values, I need to remove elements to prevent making all elements equal.

Perhaps the minimal number of elements to remove is equal to the minimal number of elements that, when removed, disconnect the array into segments where each segment has different values that can't be made equal.

But I'm not sure.

Wait, perhaps I can think in terms of runs of the same value.

Let's consider the array as a sequence of runs, where each run is a sequence of the same value.

For example:

[1, 2, 1, 2, 1] has runs: 1, 2, 1, 2, 1

[3, 3, 3, 5, 3, 3, 3] has runs: 3, 5, 3

Now, if there is only one run, meaning all elements are the same, it's impossible to make it not beautiful.

Otherwise, perhaps the minimal number of elements to remove is equal to the length of the shortest run.

Wait, in the second example, [1, 2, 1, 2, 1], the runs are all of length 1, so the minimal number to remove is 1, which matches the example.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], the runs are 3 (length 3), 5 (length 1), 3 (length 3). The shortest run is of length 1, but removing one element doesn't make it not beautiful, as we've seen. So, this approach is incorrect.

Hence, this idea doesn't hold.

Let me try another approach.

Suppose I consider the frequency of the most frequent value.

In the first example, [2, 2, 2], the most frequent value is 2 with frequency 3.

In the second example, [1, 2, 1, 2, 1], both 1 and 2 appear twice.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], 3 appears five times, and 5 appears once.

If I remove elements that are not the most frequent value, in the fourth example, removing the single 5, the array becomes [3, 3, 3, 3, 3, 3], which is still beautiful.

So, removing elements that are not the most frequent value isn't enough; I need to remove enough elements to break the connectivity of the most frequent value.

Wait, perhaps I need to remove elements such that the most frequent value is disconnected into multiple segments.

But I need a more concrete plan.

Let me consider that the array is beautiful if all elements can be made equal to the most frequent value by propagating it through the operations.

To prevent this, I need to remove elements such that the most frequent value cannot be propagated to all positions.

In other words, I need to remove elements to create at least one "barrier" that cannot be crossed by the most frequent value.

Considering the operation allows changing an element if its neighbors are equal.

So, if I have a sequence like A, B, A, and A is the most frequent value, I can change B to A.

Similarly, in A, C, B, A, I can first change B to A (since A == A), then C to A (since A == A), making the whole array A.

Wait, no. In A, C, B, A:

First, a[1] = C, a[0] = A, a[2] = B. Since a[0] != a[2], I can't change a[1].

Similarly, a[2] = B, a[1] = C, a[3] = A. Since a[1] != a[3], I can't change a[2].

So, in this case, I can't make all elements equal to A.

Hence, the array [A, C, B, A] is not beautiful.

So, in this case, even if A is the most frequent value, if there are barriers that cannot be crossed, the array is not beautiful.

Therefore, to make the array not beautiful, I need to ensure that there are barriers that prevent the propagation of the most frequent value to all positions.

So, perhaps the minimal number of elements to remove is equal to the number of times I need to remove elements to break the connectivity of the most frequent value.

But I need a way to calculate this.

Let me think about the most frequent value's runs.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], the runs of 3 are [3,3,3], [3,3,3], separated by a single 5.

If I remove the 5, the array becomes [3,3,3,3,3,3], which is still beautiful.

If I remove one of the 3's adjacent to 5, say the first 3 before 5, the array becomes [3,3,5,3,3,3]. Now, can I make all elements equal to 3?

Looking at the array [3,3,5,3,3,3]:

- a[2] = 5, a[1] = 3, a[3] = 3. Since a[1] == a[3], I can replace a[2] with 3, making the array [3,3,3,3,3,3], which is beautiful.

So, removing one 3 doesn't help.

If I remove two 3's adjacent to 5, say the first two 3's before 5, the array becomes [3,5,3,3,3]. Now, can I make all elements equal to 3?

Looking at the array [3,5,3,3,3]:

- a[1] = 5, a[0] = 3, a[2] = 3. Since a[0] == a[2], I can replace a[1] with 3, making the array [3,3,3,3,3], which is beautiful.

Still beautiful.

If I remove three 3's, say the first three 3's, the array becomes [5,3,3,3]. Now, can I make all elements equal to 3?

Looking at the array [5,3,3,3]:

- a[0] = 5, a[1] = 3, a[2] = 3. Since a[0] != a[2], I can't perform the operation on a[1].

- a[1] = 3, a[0] = 5, a[2] = 3. Since a[0] != a[2], I can't perform the operation on a[1].

- a[2] = 3, a[1] = 3, a[3] = 3. Since a[1] == a[3], I can replace a[2] with 3, but it's already 3.

No operations can be performed, and the array is not beautiful.

Hence, removing three elements is necessary.

So, in this case, the minimal number of elements to remove is three.

Looking back, the runs of 3 are separated by a single 5.

To break the connectivity of 3's, I need to remove enough elements to separate the runs of 3's in such a way that the operations can't propagate the value 3 between them.

In this case, removing the 5 and two adjacent 3's would suffice, but as we've seen, that's not the case.

Wait, perhaps I need to remove all elements of the separating run.

In this case, the separating run is the single 5.

But removing just the 5 isn't enough, as shown earlier.

Hence, this approach is flawed.

Let me consider another angle.

Suppose I have a sequence where the most frequent value is connected through runs, and I need to break those connections.

In graph theory terms, think of the array as a graph where elements are nodes, and there are edges between elements that can be used to propagate the value.

But this might be too time-consuming.

Let me consider a simpler heuristic.

In the array, find the minimal number of elements to remove so that the most frequent value doesn't cover the entire array.

Wait, but in the fourth example, even after removing elements, if the remaining most frequent value is connected, the array remains beautiful.

This is getting too complicated.

Let me look at the provided program and see what it's doing.

The program is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().strip().split()))

tmp = a[0]

cnt = 0

ans = n

for i in range(n):

if a[i] == tmp:

cnt += 1

else:

ans = min(ans, cnt)

cnt = 0

ans = min(ans, cnt)

if n == 1 or ans == n:

print(-1)

else:

print(ans)

So, it's iterating through the array and counting the length of consecutive runs of the first element's value.

Then, it takes the minimal length of such runs, and that's the answer, unless the array has only one element or all elements are the same.

In the first example, [2, 2, 2], ans would be 3, and since n == 3, it prints -1.

In the second example, [1, 2, 1, 2, 1], tmp = 1, cnt increases to 1 (index 0), then at index 1, a[1] == 2 != 1, so ans = min(ans, 1) -> ans = 1, then cnt = 0.

At index 2, a[2] == 1 == tmp, cnt = 1, at index 3, a[3] == 2 != tmp, so ans = min(1, 1) = 1, cnt = 0.

At index 4, a[4] == 1 == tmp, cnt = 1.

Finally, ans = min(1, 1) = 1.

Since n != 1 and ans != n, it prints 1, which matches the example.

In the third example, [1], n == 1, so it prints -1.

In the fourth example, [3, 3, 3, 5, 3, 3, 3], tmp = 3, cnt = 3 (indices 0-2), then at index 3, a[3] == 5 != 3, so ans = min(ans, 3) -> ans = min(inf, 3) = 3, then cnt = 0.

At index 4, a[4] == 3 == tmp, cnt = 1, at index 5, a[5] == 3, cnt = 2, at index 6, a[6] == 3, cnt = 3.

Finally, ans = min(3, 3) = 3.

So, it prints 3, which matches the example.

So, the program seems to be working correctly for the given examples.

But is this logic generally correct?

Let me think about it.

The program is finding the minimal length of consecutive runs of the first element's value.

Then, it outputs this minimal run length, unless the array has only one element or all elements are the same.

In the second example, [1, 2, 1, 2, 1], the runs of 1 are of length 1, then 1, then 1.

So, the minimal run length is 1, which matches the answer.

In the fourth example, the runs of 3 are of length 3 and 3, so the minimal is 3, which matches.

But is this always correct?

Let me consider another example.

Suppose the array is [1, 1, 2, 2, 1, 1].

According to the program, tmp = 1, cnt = 2, then at index 2, a[2] = 2 != 1, so ans = min(ans, 2) -> ans = 2, then cnt = 0.

At index 3, a[3] = 2 == 2, cnt = 1, at index 4, a[4] = 1 != 2, so ans = min(2, 1) = 1, then cnt = 0.

At index 5, a[5] = 1 == 1, cnt = 1.

Finally, ans = min(1, 1) = 1.

So, the program would output 1.

Is this correct?

Let's see: if I remove one element, say the first element, the array becomes [1, 2, 2, 1, 1]. Is this not beautiful?

Looking at the array [1, 2, 2, 1, 1]:

- Can I make all elements equal to 1?

Looking at index 1, a[0] = 1, a[1] = 2, a[2] = 2. Since a[0] != a[2], can't perform operation on a[1].

Looking at index 2, a[1] = 2, a[2] = 2, a[3] = 1. Since a[1] == a[2], I can replace a[3] with 2, making the array [1, 2, 2, 2, 1].

Now, looking at index 3, a[2] = 2, a[3] = 2, a[4] = 1. Since a[2] == a[3], I can replace a[4] with 2, making the array [1, 2, 2, 2, 2].

Looking at index 0, a[0] = 1, a[1] = 2, a[2] = 2. Since a[1] == a[2], I can replace a[0] with 2, making the array [2, 2, 2, 2, 2].

So, the array is still beautiful.

Wait, but according to the program, it should output 1, meaning that removing one element makes it not beautiful, but in this case, even after removing one element, it remains beautiful.

So, perhaps the program is incorrect.

Wait, but in the example I just thought of, removing one element still keeps the array beautiful.

Is there a way to make it not beautiful by removing one element?

Let's try removing the third element, the second 2, making the array [1, 1, 2, 1, 1].

Now, can I make all elements equal to 1?

Looking at index 2, a[1] = 1, a[2] = 2, a[3] = 1. Since a[1] == a[3], I can replace a[2] with 1, making the array [1, 1, 1, 1, 1], which is beautiful.

So, still beautiful.

Is there another element I can remove to make it not beautiful?

Let's try removing the second element, making the array [1, 2, 2, 1, 1].

Looking at index 1, a[0] = 1, a[1] = 2, a[2] = 2. Since a[0] != a[2], can't perform operation on a[1].

Looking at index 2, a[1] = 2, a[2] = 2, a[3] = 1. Since a[1] == a[2], I can replace a[3] with 2, making the array [1, 2, 2, 2, 1].

Looking at index 0, a[0] = 1, a[1] = 2, a[2] = 2. Since a[1] == a[2], I can replace a[0] with 2, making the array [2, 2, 2, 2, 1].

Looking at index 4, a[3] = 2, a[4] = 1. Since a[3] == a[3], I can replace a[4] with 2, making the array [2, 2, 2, 2, 2].

Still beautiful.

So, in this case, removing one element doesn't make the array not beautiful.

Hence, the program's output of 1 is incorrect; it should be higher.

Wait, but according to the program's logic, it's taking the minimal run length of the first element's value.

In this case, the runs of 1 are of length 2, then 2, then 2.

So, the minimal run length is 2.

But the program would output 1, which is incorrect.

Wait, perhaps I miscounted.

Wait, in the array [1, 1, 2, 2, 1, 1], tmp = 1, cnt = 2 (indices 0-1), then at index 2, a[2] = 2 != 1, so ans = min(ans, 2) -> ans = 2, then cnt = 0.

At index 3, a[3] = 2 == 2, cnt = 1, at index 4, a[4] = 1 != 2, so ans = min(2, 1) = 1, then cnt = 0.

At index 5, a[5] = 1 == 1, cnt = 1.

Finally, ans = min(1, 1) = 1.

So, the program would output 1, but as we've seen, removing one element doesn't make the array not beautiful.

Hence, the program is incorrect.

Therefore, Correctness: **False**

