Alright, I have this problem to solve. Let's read it carefully.

We have Alice and Bob playing a game on an array `a` of size `n`. Alice starts with an empty array `c`. They take turns, with Alice going first. On Alice's turn, she picks an element from `a`, appends it to `c`, and deletes it from `a`. On Bob's turn, he picks an element from `a`, deletes it from `a`, but does not add it to `c`. The game ends when `a` is empty, and the score is the MEX of `c`, which is the smallest non-negative integer not in `c`.

Alice wants to maximize the MEX, and Bob wants to minimize it. We need to find the final score assuming both play optimally.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in it. For example:

- MEX of [2,2,1] is 0 (since 0 is missing).

- MEX of [3,1,0,1] is 2 (0 and 1 are present, 2 is missing).

- MEX of [0,3,1,2] is 4 (0,1,2,3 are present, 4 is missing).

So, the goal is to have the highest possible MEX in `c` when Alice picks elements, considering that Bob is trying to disrupt this by removing elements that could help increase the MEX.

Let's think about how the game progresses. The total number of moves is `n`, with Alice and Bob alternating turns, Alice starting first. So, Alice gets to pick roughly half of the elements, plus one if `n` is odd.

Wait, no. Actually, since Alice picks an element and adds it to `c` on her turn, and Bob just removes an element from `a` on his turn, the number of elements in `c` will be equal to the number of Alice's turns.

Given that Alice starts first, if `n` is odd, Alice will have one more turn than Bob. If `n` is even, they have equal turns.

But actually, since Bob only removes elements without adding to `c`, the number of elements in `c` is equal to the number of Alice's turns.

Wait, no. Alice's turn: pick an element from `a`, append it to `c`, and delete it from `a`. Bob's turn: pick an element from `a`, delete it from `a`.

So, each turn reduces the size of `a` by one, and Alice adds one element to `c` per her turn.

Therefore, the total number of elements in `c` at the end of the game is equal to the number of Alice's turns.

Since Alice starts first, and they alternate, if `n` is even, both have `n/2` turns. If `n` is odd, Alice has `(n+1)/2` turns, and Bob has `(n-1)/2` turns.

But wait, no. Since Bob also deletes an element from `a` on his turn, the size of `a` decreases by one each turn, regardless of who plays.

So, total turns are `n`, with Alice playing on turns 1,3,5,... and Bob on turns 2,4,6,...

Therefore, number of Alice's turns is ceil(n/2), and Bob's turns is floor(n/2).

Wait, no. In programming terms, for `n` turns, Alice plays on odd-numbered turns, Bob on even.

So, if `n` is even, both play `n/2` times. If `n` is odd, Alice plays `(n+1)/2` times, Bob `(n-1)/2`.

Wait, but in terms of turn numbering:

- Turn 1: Alice picks and adds to `c`.

- Turn 2: Bob picks and deletes from `a`.

- Turn 3: Alice picks and adds to `c`.

- Turn 4: Bob picks and deletes from `a`.

- ...

- Last turn: if `n` is odd, Alice picks and adds to `c`; if even, Bob picks and deletes from `a`.

Therefore, number of elements in `c` is ceil(n/2).

Wait, let's take an example.

If `n=1`: Alice picks and adds to `c`, `c` has 1 element.

If `n=2`: Alice picks and adds to `c`, then Bob deletes one, `c` has 1 element.

If `n=3`: Alice picks and adds to `c`, Bob deletes one, Alice picks and adds to `c`, `c` has 2 elements.

If `n=4`: Alice picks and adds to `c`, Bob deletes one, Alice picks and adds to `c`, Bob deletes one, `c` has 2 elements.

So, in general, `c` will have ceil(n/2) elements.

Wait, but in n=4, `c` has 2 elements, which is floor(n/2).

Wait, no: n=1 -> 1, n=2 ->1, n=3->2, n=4->2, n=5->3, etc.

So, it's floor((n+1)/2).

Wait, for n=1: floor(2/2)=1

n=2: floor(3/2)=1

n=3: floor(4/2)=2

n=4: floor(5/2)=2

n=5: floor(6/2)=3

Yes, so number of elements in `c` is floor((n+1)/2).

Got it.

Now, the problem is to choose which elements go into `c` such that the MEX of `c` is maximized, given that Bob is trying to minimize it.

So, it's a game where Alice and Bob have opposing goals regarding the MEX of `c`.

I need to find the final MEX when both play optimally.

Let me think about what determines the MEX of `c`. It's the smallest non-negative integer not present in `c`.

So, to maximize MEX, Alice wants to include as many low numbers as possible in `c`, up to a point.

But Bob is trying to minimize it, so he wants to prevent Alice from including certain numbers.

Wait, but Bob only deletes elements from `a`, he doesn't choose what goes into `c`.

Wait, no, Bob also picks an element from `a` on his turn, but doesn't add it to `c`; he just deletes it.

So, Bob can choose to delete elements that Alice might want to pick later.

Ah, so Bob can strategically delete elements that Alice would use to achieve a higher MEX.

Wait, but MEX is about the absence of a number in `c`. So, Alice wants to have as many low numbers in `c` as possible to make the MEX higher.

Bob wants to prevent that by removing elements that Alice might pick.

Wait, but Bob can only delete one element per turn, and he can choose which one to delete.

So, Bob can try to delete elements that Alice values for achieving a higher MEX.

Alice, on the other hand, picks elements to add to `c` in a way that maximizes the MEX.

This seems like a game where Alice wants to include certain elements in `c`, and Bob wants to interfere by deleting elements that could help Alice.

I need to find the optimal strategy for both.

Let me consider some small examples to get an idea.

Example 1:

n=4

a=[0,0,1,1]

Possible game:

- Alice picks 1 and adds to c=[1], a=[0,0,1]

- Bob deletes 0, a=[0,1]

- Alice picks 0 and adds to c=[1,0], a=[1]

- Bob deletes 1, a=[]

c=[1,0], MEX=2

Another possible game:

- Alice picks 0, c=[0], a=[0,1,1]

- Bob deletes 1, a=[0,1]

- Alice picks 1, c=[0,1], a=[0]

- Bob deletes 0, a=[]

c=[0,1], MEX=2

Another game:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob deletes 1, a=[0,0]

- Alice picks 0, c=[1,0], a=[0]

- Bob deletes 0, a=[]

c=[1,0], MEX=2

Seems like MEX is 2 in all these scenarios.

Example 2:

n=4

a=[0,1,2,3]

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob deletes 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob deletes 3, a=[]

c=[0,2], MEX=1

Another game:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob deletes 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob deletes 3, a=[]

c=[1,2], MEX=0

Another game:

- Alice picks 2, c=[2], a=[0,1,3]

- Bob deletes 1, a=[0,3]

- Alice picks 0, c=[2,0], a=[3]

- Bob deletes 3, a=[]

c=[2,0], MEX=1

Seems like MEX can be 0 or 1, but the minimal possible is 0, which Bob would aim for.

Wait, but in the first game, MEX is 1, and in the second, MEX is 0.

So, Bob can force MEX to be 0 in some scenarios.

Example 3:

n=2

a=[1,1]

Possible game:

- Alice picks 1, c=[1], a=[1]

- Bob deletes 1, a=[]

c=[1], MEX=0

Another game:

- Alice picks 1, c=[1], a=[1]

- Bob deletes 1, a=[]

c=[1], MEX=0

Only one option, MEX=0

So, in this case, MEX is 0.

Looking at the sample outputs:

Test case 1: 2

Test case 2: 1

Test case 3: 0

So, for the first test case, MEX is 2, and for the second, 1, and for the third, 0.

I need to find a general strategy to compute this for any given `a`.

Let me think about what determines the MEX.

The MEX is the smallest non-negative integer not present in `c`.

Alice wants to maximize this, so she wants `c` to contain as many low numbers as possible.

Bob wants to minimize it, so he wants to prevent Alice from having certain low numbers in `c`.

Given that Alice picks elements to add to `c`, and Bob can delete elements from `a`, including those that Alice might want.

I need to model their strategies.

Let me consider that the game is about selecting a subset of size ceil((n+1)/2) from `a`, and Bob can influence which elements are in that subset.

Wait, no. Actually, Alice chooses which elements to add to `c`, and Bob can delete elements, potentially removing elements that Alice might want to pick later.

This seems complex. Maybe I need to think differently.

Let me consider the frequency of each number in `a`.

Let's count how many times each number appears in `a`.

For a number `i`, if it appears `k` times in `a`, then Alice and Bob have to consider how many of these `k` can end up in `c`.

Bob can delete some of them, potentially preventing Alice from picking them.

I need to find out, for each number `i`, whether it's possible for Alice to have at least one copy of `i` in `c`, despite Bob's deletions.

If Alice can ensure that `i` is in `c`, then she can include it; otherwise, Bob can prevent it.

So, for each `i`, I need to determine if Alice can force at least one `i` into `c`.

If she can, then she can include it; otherwise, Bob can prevent it.

Then, the MEX would be the smallest `i` for which Alice cannot force at least one `i` into `c`.

So, the problem reduces to determining, for each `i`, whether Alice can ensure that at least one `i` ends up in `c`, given that Bob is trying to prevent it.

If Alice can ensure that, then `i` will be in `c`; otherwise, it won't be, and `i` would be the MEX.

So, I need to find the smallest `i` for which Alice cannot ensure that at least one `i` is in `c`.

Now, how do I determine, for each `i`, whether Alice can force at least one `i` into `c`?

Let's think in terms of the number of turns Alice has and the number of `i`s available.

Total turns: `n`

Alice's turns: ceil(n/2)

Bob's turns: floor(n/2)

Wait, earlier I thought it was floor((n+1)/2) for Alice and floor(n/2) for Bob.

Wait, in programming terms:

- If n is even, both have n/2 turns.

- If n is odd, Alice has (n+1)/2 turns, Bob has (n-1)/2 turns.

Wait, but in terms of ceil and floor:

Alice's turns: ceil(n/2)

Bob's turns: floor(n/2)

Yes, that's correct.

So, Alice has ceil(n/2) turns to pick elements to add to `c`.

Bob has floor(n/2) turns to delete elements from `a`.

Now, for a particular `i`, if the number of times `i` appears in `a` is `k`, then Alice needs to pick at least one `i` into `c`, while Bob tries to delete them.

Bob can delete up to floor(n/2) elements, including the `i`s.

Alice can pick up to ceil(n/2) elements.

Wait, but Bob can delete any elements, including `i`s.

Alice wants at least one `i` to be in `c`.

So, for Alice to ensure that at least one `i` is in `c`, she needs to pick at least one `i` into `c`, despite Bob possibly deleting some `i`s.

Let me think in terms of availability.

If there are `k` copies of `i` in `a`, and Bob can delete up to floor(n/2) elements, then the number of `i`s that Bob can delete is up to floor(n/2), but only up to `k`, if `k` is less than floor(n/2).

Wait, no. Bob can delete up to floor(n/2) elements in total, not necessarily only `i`s.

So, Bob can delete elements elsewhere, but Alice needs to make sure that at least one `i` remains until she picks it.

This seems like a problem of ensuring that at least one `i` is picked by Alice, given that Bob can delete up to floor(n/2) elements.

Wait, perhaps I can model it as: for each `i`, the number of `i`s that are not deleted by Bob should be at least one, provided that Alice picks one when available.

But Alice gets to pick first, and she can choose which elements to pick.

Wait, perhaps I need to think in terms of the number of `i`s that are left when it's Alice's turn.

This seems complicated.

Let me look for a different approach.

I recall that in some games, the MEX can be determined by looking at the frequencies of the numbers and the number of moves each player has.

Let me consider that Alice can pick ceil(n/2) elements to include in `c`, and Bob can delete floor(n/2) elements.

So, for each `i`, if the number of `i`s in `a` is greater than the number of deletions Bob can make, then Alice can ensure that at least one `i` is in `c`.

In other words, if cnt[i] > floor(n/2), then Alice can ensure that at least one `i` is in `c`.

Because Bob can delete at most floor(n/2) elements, so if there are more `i`s than that, some will remain, and Alice can pick one.

Similarly, if cnt[i] <= floor(n/2), then Bob can potentially delete all `i`s.

Wait, but Bob might choose to delete other elements instead, allowing Alice to pick `i`.

So, if cnt[i] > floor(n/2), Alice can always pick at least one `i`, because even if Bob deletes floor(n/2) elements, some `i`s will remain.

If cnt[i] <= floor(n/2), then Bob can delete all `i`s, preventing Alice from picking any.

Wait, but Bob might choose to delete other elements, allowing Alice to pick `i`.

However, since Bob wants to minimize the MEX, he would prefer to delete elements that help Alice achieve a higher MEX.

Wait, no. Bob wants to minimize the MEX, so he would want to prevent Alice from having lower numbers in `c`.

Wait, MEX is the smallest missing number in `c`.

So, to minimize MEX, Bob would want to ensure that lower numbers are not in `c`.

Therefore, for lower `i`, Bob would want to delete them to prevent Alice from having them, thus making those `i`s missing in `c`, lowering the MEX.

Wait, but MEX is the smallest missing number.

So, to minimize MEX, Bob wants to make lower numbers missing in `c`.

Therefore, for lower `i`, Bob would want to delete all copies of `i`, so that `i` is missing in `c`.

Alice, on the other hand, wants to include lower numbers in `c` to make higher numbers the MEX.

So, for each `i`, if cnt[i] > floor(n/2), Alice can ensure at least one `i` is in `c`, because Bob can't delete them all.

If cnt[i] <= floor(n/2), then Bob can delete all `i`s, preventing Alice from picking any.

Therefore, for each `i`, starting from 0 upwards, if cnt[i] > floor(n/2), Alice can ensure `i` is in `c`; otherwise, Bob can prevent it.

So, the smallest `i` for which cnt[i] <= floor(n/2) will be the MEX.

Wait, but in the first test case:

n=4

a=[0,0,1,1]

floor(n/2)=2

cnt[0]=2, which is equal to floor(n/2)=2, so Bob can delete both 0's, preventing Alice from picking any 0.

Therefore, 0 would not be in `c`, making MEX=0.

But in the sample output, it's 2.

Wait, that contradicts my conclusion.

So, perhaps my reasoning is incomplete.

Let me check another test case.

Second test case:

n=4

a=[0,1,2,3]

floor(n/2)=2

cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1

For i=0, cnt[0]=1 <=2, Bob can delete it, making 0 missing in `c`.

For i=1, cnt[1]=1 <=2, Bob can delete it, making 1 missing in `c`.

So, MEX would be 0 or 1, but sample output is 1.

Wait, according to my previous logic, MEX should be 0, but sample output is 1.

So, my previous conclusion is incorrect.

I need to rethink this.

Perhaps I need to consider the total number of elements Alice can pick and how Bob can interfere.

Let me consider that Alice can pick ceil(n/2) elements, and Bob can delete floor(n/2) elements.

The MEX is determined by which numbers are missing in `c`.

Bob wants to make sure that lower numbers are missing, while Alice wants to include them.

Wait, perhaps I need to iterate through the numbers starting from 0 and check if Alice can include them in `c`.

For each `i`, from 0 upwards, check if Alice can ensure that at least one `i` is in `c`.

If she can, then `i` is in `c`, otherwise, it's missing, and `i` is the MEX.

To determine if Alice can ensure that at least one `i` is in `c`, given that Bob can delete up to floor(n/2) elements.

Wait, but Bob can choose which elements to delete.

So, if cnt[i] > floor(n/2), Alice can pick at least one `i`, because Bob can't delete them all.

If cnt[i] <= floor(n/2), Bob can delete all `i`s, preventing Alice from picking any.

Therefore, the smallest `i` for which cnt[i] <= floor(n/2) would be the MEX.

But in the first test case, cnt[0]=2, floor(n/2)=2, so cnt[0]=2 <=2, so Bob can delete both 0's, making 0 missing in `c`, so MEX=0, but sample output is 2.

Contradiction.

Wait, perhaps I need to consider that Alice can pick multiple turns, and she can pick different `i`s.

Wait, but MEX is about the smallest missing number.

So, perhaps I need to find the smallest `i` for which, even if Alice tries to include it in `c`, Bob can prevent it.

Given that, for each `i`, if cnt[i] > floor(n/2), Alice can pick at least one `i`, else Bob can delete all `i`s.

Hence, the smallest `i` with cnt[i] <= floor(n/2) is the MEX.

But in the first test case, cnt[0]=2 <=2, so MEX should be 0, but sample output is 2.

Wait, maybe I need to consider the cumulative effect.

Wait, perhaps I need to iterate through `i` from 0 upwards, and for each `i`, calculate the total number of elements that Alice needs to include to ensure `i` is in `c`.

Wait, perhaps I need to consider the sum of cnt[j] for j < i, and see if Alice can pick enough elements to include at least one of each j < i.

This seems complicated.

Let me look for a different approach.

I recall that in some games, the result can be determined by the number of available moves and the number of elements.

Wait, perhaps I can think in terms of the number of elements Alice can control.

Alice can control ceil(n/2) elements in `c`.

Bob can influence floor(n/2) elements by deleting them.

So, the MEX would be the smallest `i` for which the number of available `i`s is less than or equal to the number of deletions Bob can make.

Wait, perhaps I need to find the smallest `i` such that cnt[i] - floor(n/2) <= 0, meaning Bob can delete enough to prevent Alice from having `i` in `c`.

Wait, but in the first test case, cnt[0]=2, floor(n/2)=2, so cnt[0] -2 =0, which is <=0, so MEX=0, but sample output is 2.

Again, contradiction.

Wait, perhaps I need to accumulate the deletions.

Let me try to think differently.

Suppose I sort the numbers in ascending order and see which ones Alice can include.

But that might not help directly.

Let me consider that Alice wants to include as many low numbers as possible, and Bob wants to prevent that.

So, for each `i`, starting from 0, Alice tries to include at least one `i` in `c`.

Bob tries to prevent that by deleting `i`s.

If cnt[i] > floor(n/2), Alice can include at least one `i`, because Bob can't delete them all.

If cnt[i] <= floor(n/2), Bob can delete all `i`s, preventing Alice from including any in `c`.

Hence, the smallest `i` with cnt[i] <= floor(n/2) would be the MEX.

But in the first test case, cnt[0]=2 <=2, so MEX=0, but sample output is 2.

Wait, perhaps I need to consider that Alice can include multiple numbers, and the MEX is determined by which numbers are missing in `c`.

Wait, maybe I need to find the smallest `i` such that, after Alice picks ceil(n/2) elements optimally, and Bob deletes floor(n/2) elements optimally, `i` is missing from `c`.

This seems too vague.

Let me consider the number of available turns and deletions.

Total elements: n

Alice picks ceil(n/2) elements to include in `c`.

Bob deletes floor(n/2) elements.

So, the elements in `c` are those picked by Alice minus those deleted by Bob, but Bob deletes from `a`, not from `c`.

Wait, no, Bob deletes from `a`, which affects what Alice can pick later.

This is getting too complicated.

Let me look for a different strategy.

I found that in the first test case, MEX is 2, but according to my earlier logic, it should be 0.

So, my logic is flawed.

Let me consider that Alice can pick elements in such a way that she includes certain numbers, and Bob can only delete elements, potentially disrupting Alice's choices.

Wait, perhaps I need to consider that Alice can pick elements in a way that maximizes the MEX, and Bob tries to minimize it by deleting elements that would help Alice achieve a higher MEX.

Let me try to think in terms of available moves.

Total turns: n

Alice's turns: ceil(n/2)

Bob's turns: floor(n/2)

Let me consider that Alice can pick any remaining element on her turn, and Bob can delete any remaining element on his turn.

Alice wants to maximize the MEX of `c`, which is the smallest missing number in `c`.

Bob wants to minimize it.

So, the MEX depends on which numbers are in `c`.

Alice wants as many low numbers as possible in `c`, while Bob wants to prevent that.

I need to find the smallest `i` such that, no matter how Alice plays, Bob can ensure that `i` is not in `c`.

Wait, that sounds like the definition of MEX in this context.

So, to find the MEX, I need to find the smallest `i` for which Bob can ensure that `i` is not in `c`, regardless of Alice's choices.

In other words, for each `i`, starting from 0 upwards, check if Bob can prevent `i` from being in `c`.

If Bob can prevent `i` from being in `c`, then `i` is the MEX.

Otherwise, Alice can ensure that `i` is in `c`, so MEX is higher.

So, for each `i`, I need to determine if Bob can prevent `i` from being in `c`.

If Bob can prevent `i` from being in `c`, then MEX is `i`.

Else, continue to the next `i`.

To determine if Bob can prevent `i` from being in `c`, he needs to ensure that no `i` is picked by Alice into `c`.

Given that Alice has ceil(n/2) picks, and Bob has floor(n/2) deletions.

If the number of `i`s in `a` is less than or equal to the number of deletions Bob can make, then Bob can delete all `i`s, preventing Alice from picking any.

Hence, if cnt[i] <= floor(n/2), Bob can delete all `i`s, ensuring that `i` is not in `c`.

Therefore, the smallest `i` for which cnt[i] <= floor(n/2) is the MEX.

But in the first test case, cnt[0]=2, floor(n/2)=2, so cnt[0]=2 <=2, so MEX=0, but sample output is 2.

Wait, that's not matching.

Wait, perhaps I need to consider the cumulative effect.

Wait, maybe I need to consider the total number of deletions Bob needs to prevent multiple low numbers.

Wait, perhaps I need to iterate through `i` from 0 upwards, and accumulate the number of deletions needed to prevent those `i`s from being in `c`.

Let me try that.

For each `i`, from 0 upwards:

- If cnt[i] > floor(n/2), then Bob cannot prevent `i` from being in `c`, so `i` is included in `c`.

- Else, cnt[i] <= floor(n/2), Bob can delete all `i`s, preventing them from being in `c`.

Then, the MEX is the smallest `i` for which cnt[i] <= floor(n/2).

But in the first test case, cnt[0]=2 <=2, so MEX=0, but sample output is 2.

Hmm.

Wait, perhaps I need to consider that even if cnt[i] <= floor(n/2), Bob might choose to delete other elements instead, allowing Alice to pick `i`.

But Bob is trying to minimize the MEX, so he would prioritize deleting low `i`s to make them missing in `c`.

So, in the first test case:

n=4, a=[0,0,1,1]

floor(n/2)=2

cnt[0]=2 <=2, so Bob can delete both 0's, making 0 missing in `c`.

Hence, MEX=0, but sample output is 2.

This suggests that my approach is incorrect.

Wait, perhaps I need to consider that Alice can include multiple low numbers, and only the smallest missing number is the MEX.

Wait, in the first test case, it's possible for Alice to have both 0 and 1 in `c`, making MEX=2.

But according to my previous logic, since cnt[0]=2 <=2, Bob can delete both 0's, making 0 missing, so MEX=0.

But sample output is 2, which suggests that Bob cannot force MEX=0.

Wait, perhaps Bob cannot delete both 0's if Alice picks them first.

Wait, let's think step by step.

Total turns: 4

Alice's turns: turns 1 and 3

Bob's turns: turns 2 and 4

Scenario 1:

- Turn 1: Alice picks 0, c=[0], a=[0,1,1]

- Turn 2: Bob deletes 0, a=[1,1]

- Turn 3: Alice picks 1, c=[0,1], a=[1]

- Turn 4: Bob deletes 1, a=[]

c=[0,1], MEX=2

Scenario 2:

- Turn 1: Alice picks 1, c=[1], a=[0,0,1]

- Turn 2: Bob deletes 0, a=[0,1]

- Turn 3: Alice picks 0, c=[1,0], a=[1]

- Turn 4: Bob deletes 1, a=[]

c=[1,0], MEX=2

Scenario 3:

- Turn 1: Alice picks 0, c=[0], a=[0,1,1]

- Turn 2: Bob deletes 1, a=[0,1]

- Turn 3: Alice picks 1, c=[0,1], a=[0]

- Turn 4: Bob deletes 0, a=[]

c=[0,1], MEX=2

In all scenarios, MEX is 2.

So, Bob cannot force MEX to be 0 or 1; it's always 2.

Hence, my previous logic is flawed.

Wait, perhaps I need to consider that Bob can only delete elements that are not picked by Alice.

Wait, no, Bob deletes elements from `a`, which are the remaining elements not yet picked.

So, in the first scenario:

- Turn 1: Alice picks 0, c=[0], a=[0,1,1]

- Turn 2: Bob deletes 0, a=[1,1]

- Turn 3: Alice picks 1, c=[0,1], a=[1]

- Turn 4: Bob deletes 1, a=[]

Here, Bob deleted a 0 and a 1, but Alice still managed to pick one 0 and one 1.

Hence, MEX=2.

So, even though cnt[0]=2 <=2, Bob couldn't prevent Alice from picking at least one 0.

Wait, perhaps because Bob deleted one 0, but Alice picked the other 0 before Bob could delete it.

Wait, no, in the first scenario, Alice picks one 0, then Bob deletes another 0, then Alice picks 1, and Bob deletes 1.

So, Alice managed to pick one 0 and one 1.

Hence, even though cnt[0]=2 <=2, Alice can still get at least one 0 in `c`.

Similarly, for cnt[1]=2 <=2, Alice can get at least one 1 in `c`.

Hence, MEX=2.

So, perhaps my earlier condition is incorrect.

Wait, perhaps the condition should be cnt[i] > floor(n/2), then Alice can include at least one `i` in `c`.

Because Bob can delete up to floor(n/2) elements, if cnt[i] > floor(n/2), there will be at least one `i` left for Alice to pick.

In the first test case, cnt[0]=2 > floor(n/2)=2 is not true, since 2 <=2.

Wait, no, 2 >2 is false.

Wait, but in reality, Alice can still pick at least one 0.

Wait, perhaps the condition is cnt[i] > floor(n/2), but in this case, cnt[0]=2 >2 is false, yet Alice can still pick one 0.

So, my logic is incomplete.

Wait, perhaps I need to consider that Alice has ceil(n/2) picks, and Bob has floor(n/2) deletions.

So, for each `i`, if cnt[i] > floor(n/2), then Alice can pick at least one `i`, because Bob can't delete them all.

But in the first test case, cnt[0]=2 > floor(n/2)=2 is false, yet Alice can still pick one 0.

Wait, perhaps I need to consider the total number of deletions Bob can make relative to the number of picks Alice has.

Wait, perhaps I need to iterate through `i` from 0 upwards, and for each `i`, calculate if Alice can pick at least one `i` given that Bob can delete up to floor(n/2) elements.

But this seems too vague.

Let me try to think in terms of necessary and sufficient conditions for Alice to include `i` in `c`.

Alice can include `i` in `c` if she can pick at least one `i` before Bob deletes all of them.

Given that Bob can delete floor(n/2) elements, if cnt[i] > floor(n/2), Alice can pick at least one `i`.

If cnt[i] <= floor(n/2), Bob can delete all `i`s.

Hence, the smallest `i` for which cnt[i] <= floor(n/2) should be the MEX.

But in the first test case, cnt[0]=2 <=2, so MEX=0, but sample output is 2.

This suggests that even when cnt[0]<= floor(n/2), Alice can still include 0 in `c`.

Wait, perhaps because Alice picks first, she can pick a 0, and even if Bob deletes a 0, Alice can pick another 0.

Wait, in the first scenario:

- Alice picks 0, c=[0], a=[0,1,1]

- Bob deletes 0, a=[1,1]

- Alice picks 1, c=[0,1], a=[1]

- Bob deletes 1, a=[]

Here, Alice picked one 0 before Bob could delete it.

Hence, even though cnt[0]=2 <=2, Alice managed to include one 0 in `c`.

Similarly, she included one 1.

Hence, MEX=2.

So, perhaps my condition should be cnt[i] > floor(n/2), Alice can include at least one `i`.

But in this case, cnt[0]=2 >2 is false, yet Alice included one 0.

Wait, perhaps it's cnt[i] > floor(n/2), but in this case, cnt[0]=2 >2 is false, yet Alice included one 0.

Wait, maybe the condition is cnt[i] > floor(n/2), but in this case, cnt[0]=2 >2 is false, but Alice still included one 0.

Hmm.

Wait, perhaps I need to consider that Alice has ceil(n/2) picks, and Bob has floor(n/2) deletions.

So, if cnt[i] > floor(n/2), Alice can pick at least one `i`, because Bob can't delete them all.

If cnt[i] <= floor(n/2), Bob can delete all `i`s, preventing Alice from picking any.

But in this case, cnt[0]=2 <=2, so Bob can delete both 0's, but Alice still managed to pick one 0.

Wait, perhaps because Bob can only delete one element per turn, and Alice picks first, Alice can pick one 0 before Bob deletes the other.

Hence, even if cnt[i] <= floor(n/2), Alice can still pick one `i` if she picks it early enough.

This complicates things.

Perhaps I need to consider that Alice can pick elements in such a way that she maximizes the number of low numbers in `c`, and Bob tries to minimize it.

So, perhaps the correct condition is that if cnt[i] > floor(n/2), Alice can include at least one `i` in `c`.

If cnt[i] <= floor(n/2), Bob can delete all `i`s, preventing Alice from including any.

Hence, the smallest `i` for which cnt[i] <= floor(n/2) is the MEX.

But in the first test case, cnt[0]=2 <=2, so MEX=0, but sample output is 2.

This suggests that MEX is not 0, but 2.

Hence, my logic is incorrect.

Wait, perhaps I need to consider that Alice can include multiple low numbers, and only the highest possible MEX is determined by the first `i` where cnt[i] <= floor(n/2) + (number of higher numbers).

This seems too vague.

Let me look for a different approach.

I found that in the second test case:

n=4

a=[0,1,2,3]

floor(n/2)=2

cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1

According to my previous logic, cnt[0]=1 <=2, so Bob can delete it, making 0 missing in `c`, hence MEX=0.

But sample output is 1.

So, again, my logic is incorrect.

Wait, perhaps I need to consider the cumulative deletions.

That is, for each `i`, calculate the total number of deletions Bob needs to prevent all j < i from being in `c`.

If Bob can prevent all j < i, then MEX is i.

Else, continue to the next i.

Wait, perhaps I need to iterate through i from 0 to n, and for each i, calculate the sum of cnt[j] for j from 0 to i-1.

Then, if sum(cnt[j] for j < i) > floor(n/2), Alice can include at least one of each j < i in `c`, because Bob can't delete them all.

Else, Bob can delete enough to prevent at least one of them.

Then, the MEX would be the smallest i for which sum(cnt[j] for j < i) <= floor(n/2).

Wait, let's test this in the first test case:

i=0: sum(j <0) =0 > floor(2)=2? No, 0 <=2, so MEX=0, but sample output is 2.

Not matching.

Wait, perhaps I need to adjust the sum.

Wait, perhaps it's sum(cnt[j] for j < i) < ceil(n/2).

Wait, in the first test case:

i=0: sum(j <0)=0 < ceil(4/2)=2, so MEX=0, but sample output is 2.

Still not matching.

Wait, perhaps I need to consider sum(cnt[j] for j < i) <= floor(n/2).

Wait, in first test case:

i=0: sum(j <0)=0 <= floor(4/2)=2, so MEX=0, but sample output is 2.

Again, not matching.

Wait, perhaps I need to consider sum(cnt[j] for j <=i).

Wait, trying in first test case:

i=0: sum(j <=0)=2 <= floor(4/2)=2, so MEX=0, but sample output is 2.

Still not matching.

Wait, perhaps I need to consider sum(cnt[j] for j < i) <= floor(n/2), then MEX=i.

In first test case:

i=0: sum(j <0)=0 <=2, so MEX=0, but sample output is 2.

Wait, perhaps I need to find the smallest i where sum(cnt[j] for j < i) + cnt[i] <= floor(n/2) + sum(cnt[k] for k < i).

Wait, this is getting too complicated.

Let me try to think differently.

I recall that in some games, the outcome can be determined by the number of available moves and the number of deletions.

Perhaps I can model this as a game where Alice needs to collect certain numbers, and Bob tries to block them.

Alternatively, perhaps I can think in terms of the number of times Alice can pick elements before Bob can delete them.

Wait, perhaps I can consider that Alice can include any element that she picks before Bob deletes it.

Hence, for each i, if cnt[i] > floor(n/2), Alice can pick at least one i.

If cnt[i] <= floor(n/2), Bob can delete all i's.

Hence, the smallest i for which cnt[i] <= floor(n/2) is the MEX.

But again, in the first test case, cnt[0]=2 <=2, so MEX=0, but sample output is 2.

This suggests that even when cnt[i] <= floor(n/2), Alice can still include at least one i in c.

Wait, perhaps because Alice picks first, she can pick an i before Bob deletes it.

Hence, if cnt[i] >= floor(n/2) +1, Alice can pick at least one i.

Because Bob can delete floor(n/2) elements, but if there are floor(n/2)+1 elements, Alice can pick one before Bob deletes them all.

Wait, in the first test case, cnt[0]=2 >= floor(4/2)+1=2+1=3? No, 2 <3, so Bob can delete two 0's.

Hence, Alice cannot include 0 in c.

But in reality, she can, as per the sample.

Wait, perhaps I need to consider that Alice has ceil(n/2) picks.

Hence, if cnt[i] > floor(n/2), Alice can pick at least one i.

Because she has ceil(n/2) picks, and Bob can delete floor(n/2) elements.

Hence, if cnt[i] > floor(n/2), there will be at least one i left for Alice to pick.

In the first test case, cnt[0]=2 > floor(4/2)=2 is false, so Bob can prevent Alice from picking 0.

But in reality, Alice can pick one 0.

Wait, perhaps the condition is cnt[i] > floor(n/2), but in this case, cnt[0]=2 >2 is false, yet Alice can pick one 0.

Hence, perhaps the condition is cnt[i] >= floor(n/2) +1.

But in the first test case, cnt[0]=2 >=2 +1=3 is false, yet Alice can pick one 0.

This is confusing.

Let me try to think differently.

Suppose I sort the numbers in ascending order and try to include as many low numbers as possible in c.

Alice wants to include low numbers, Bob wants to prevent that.

Hence, Alice will try to pick low numbers first, and Bob will try to delete low numbers to prevent Alice from including them.

Wait, but Bob deletes from a, not from c.

Hence, Bob can delete low numbers to reduce the count available for Alice to pick.

But Alice picks first, so she can pick a low number before Bob deletes it.

Hence, in the first test case, Alice can pick one 0 and one 1, regardless of Bob's deletions.

Hence, MEX=2.

Wait, perhaps the general rule is that Alice can include at least floor((cnt[i]+1)/2) instances of i in c.

Because she has ceil(n/2) picks, and Bob has floor(n/2) deletions.

Hence, for each i, if floor((cnt[i]+1)/2) >=1, then Alice can include at least one i in