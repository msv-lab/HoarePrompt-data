Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel ranging from 1 to 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if Bob can set up the stalls and set their prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES", along with the number of stalls and their prices. If it's not possible, I should output "NO".

First, I need to understand how Alice's buying behavior works. She starts with n coins and visits each stall in order. At each stall, she buys as many jewels as her coins can buy at that stall's price, and then moves on to the next stall with whatever coins are left.

So, if Bob sets up s stalls with prices p1, p2, ..., ps, Alice will buy floor(n / p1) jewels at the first stall, then floor((n - p1 * floor(n / p1)) / p2) at the second stall, and so on.

My goal is to choose s (with s <= 60) and the prices p1, p2, ..., ps such that the total number of jewels Alice buys is exactly k.

Let me think about some examples to get a better understanding.

Example 1:

n = 7, k = 3

One possible solution is to set up 10 stalls with prices 2, 3, 4, 5, 6, 7, 8, 9, 10, 11.

At the first stall, Alice buys 3 jewels (7 // 2 = 3), and is left with 1 coin (7 - 3*2 = 1).

Since 1 coin is not enough to buy any jewels at any of the remaining stalls (prices from 3 to 11), she stops after buying 3 jewels.

This matches the desired k = 3.

Example 2:

n = 6, k = 4

The output is "NO", meaning it's impossible to set up stalls in a way that Alice buys exactly 4 jewels.

Example 3:

n = 255, k = 8

One possible solution is to set up 8 stalls with prices 128, 64, 32, 16, 8, 4, 2, 1.

At each stall, Alice buys 1 jewel, spending the largest possible power of 2 that is less than or equal to her remaining coins, until she has spent all her coins.

This way, she buys exactly 8 jewels.

From these examples, I can see that in the first example, Bob sets up multiple stalls with increasing prices, and in the third example, he sets up stalls with decreasing prices that are powers of 2.

Maybe there's a pattern here.

Let me consider the general case.

I need to find s <= 60 and prices p1, p2, ..., ps such that the sum of floor(n / p1), floor((n - floor(n / p1) * p1) / p2), and so on, up to ps, equals k.

This seems complicated. Maybe I can find a way to minimize or maximize the number of jewels bought.

First, if Bob sets all stalls with p = 1, then Alice will buy n jewels at the first stall, which is only acceptable if n = k.

Similarly, if Bob sets p1 = n, then Alice buys 1 jewel at the first stall and 0 at all others, which is only acceptable if k = 1.

So, for general k, I need to set prices in a way that controls how many jewels Alice buys at each stall.

Let me consider the minimal number of stalls required.

In the third example, s = 8 is used, which is acceptable since s <= 60.

I need to find a way to set up the stalls such that the total jewels bought is exactly k.

Another approach is to think about the minimal number of stalls needed to make Alice buy exactly k jewels.

Let me consider that Alice will always buy floor(n / p) jewels at a stall with price p.

So, if I can partition n into k parts where each part is the price p of a stall, and the number of jewels bought at each stall is floor(n / p), I need to ensure that the sum of these floor divisions equals k.

This seems tricky.

Wait, maybe I can think recursively.

Suppose I set up one stall with price p1.

Alice buys floor(n / p1) jewels at this stall and is left with n - floor(n / p1) * p1 coins.

Then, I set up the remaining s-1 stalls to make her buy exactly k - floor(n / p1) jewels with the remaining coins.

But this seems too vague.

Let me think about the minimal possible k and maximal possible k.

The minimal k is 1, achieved by setting p1 = n.

The maximal k is n, achieved by setting p1 = 1.

So, for any k between 1 and n, inclusive, it should be possible to achieve.

But wait, in the second example, n = 6 and k = 4, and the output is "NO".

So, my assumption is wrong.

There must be some constraints based on the number of stalls.

Given that s <= 60, maybe there are some k values that cannot be achieved with s <= 60.

Looking back at the problem, it's not just about achieving any k between 1 and n, but doing so with at most 60 stalls.

Maybe there are some k values that require more than 60 stalls to achieve.

Hence, in such cases, the answer should be "NO".

But in the first example, s = 10 is used for n = 7 and k = 3.

In the third example, s = 8 for n = 255 and k = 8.

So, it's possible to achieve some k with a small number of stalls.

But for others, it might not be possible.

I need to find a general method to determine if it's possible for any given n and k.

Let me consider the case when k = 1.

In this case, Bob can set up one stall with p = n, and Alice will buy one jewel.

So, "YES" with s = 1 and p1 = n.

Similarly, if k = n, Bob can set up one stall with p = 1, and Alice will buy n jewels.

So, "YES" with s = 1 and p1 = 1.

Now, what if k is between 1 and n.

Let me consider k = n - 1.

Can Bob set up stalls to make Alice buy exactly n - 1 jewels?

One way is to set up two stalls: first with p1 = 1, and second with p2 > n.

At the first stall, Alice buys floor(n / 1) = n jewels, but that's more than k = n - 1.

So, that doesn't work.

Alternatively, set p1 = ceil(n / (k)), but I need to think carefully.

Wait, perhaps set p1 = ceil(n / (k)).

Wait, but I need to ensure that the total jewels bought across all stalls is exactly k.

This is getting complicated.

Let me think differently.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

Let me denote the number of jewels bought at each stall as q1, q2, ..., qs, where qi = floor(ni / pi), and ni is the remaining coins before visiting stall i.

Then, the total jewels bought is q1 + q2 + ... + qs = k.

I need to choose p1, p2, ..., ps such that this sum is exactly k.

This seems too vague to work with directly.

Maybe I can consider the minimal number of stalls required to achieve k.

Let me consider a greedy approach.

Start with s = 1.

Set p1 = n // k.

Then, q1 = floor(n / p1) = floor(n / floor(n / k)).

But floor(n / floor(n / k)) could be greater than or equal to k.

Wait, maybe not helpful.

Alternatively, set p1 = ceil(n / k).

Then, q1 = floor(n / ceil(n / k)).

This could be floor(n / ceil(n / k)).

Wait, let's take an example.

Suppose n = 10, k = 3.

Then, ceil(10 / 3) = 4.

Then, floor(10 / 4) = 2.

So, q1 = 2.

Then, remaining coins: n - q1 * p1 = 10 - 8 = 2.

Now, set p2 = ceil(2 / (3 - 2)) = ceil(2 / 1) = 2.

Then, q2 = floor(2 / 2) = 1.

Total jewels: 2 + 1 = 3, which is exactly k.

So, in this case, s = 2, p1 = 4, p2 = 2.

This seems to work.

Another example: n = 7, k = 3.

ceil(7 / 3) = 3.

q1 = floor(7 / 3) = 2.

Remaining coins: 7 - 6 = 1.

p2 = ceil(1 / (3 - 2)) = ceil(1 / 1) = 1.

q2 = floor(1 / 1) = 1.

Total jewels: 2 + 1 = 3.

So, s = 2, p1 = 3, p2 = 1.

But in the first example, they used s = 10 with p1 to p10 being 2 to 11.

But my approach suggests s = 2 is sufficient.

So, maybe there are multiple ways to achieve the same k.

Now, in the second example, n = 6, k = 4.

Let's try the same approach.

ceil(6 / 4) = 2.

q1 = floor(6 / 2) = 3.

Remaining coins: 6 - 6 = 0.

But k = 4, but Alice has already bought 3 jewels and has 0 coins left, so she can't buy any more jewels.

Hence, total jewels = 3, which is less than k = 4.

So, this approach fails here.

Alternatively, maybe set p1 = ceil(6 / 4) = 2, q1 = 3, remaining coins = 0.

Since k = 4 > 3, it's impossible.

Hence, "NO".

This matches the sample output.

So, in this case, it's impossible to make Alice buy exactly k = 4 jewels with n = 6 coins.

Now, is there a general condition to determine if it's possible or not?

From the above example, it seems that if after setting p1 = ceil(n / k), the remaining jewels to be bought cannot be achieved with the remaining coins, it's impossible.

But I need a more concrete condition.

Let me think about the minimal number of stalls required.

Suppose I set p1 = floor(n / k), p2 = floor((n - q1 * p1) / (k - q1)), and so on, until the total jewels bought is k.

But this seems too vague.

Alternatively, maybe think in terms of binary representation.

In the third example, s = 8, with prices being powers of 2 from 128 down to 1.

This seems similar to binary representation.

Wait, 255 is 2^8 - 1, and 8 is the number of bits in 255.

Wait, 255 in binary is 11111111, which has 8 bits.

So, by setting prices as powers of 2, Alice buys one jewel at each stall, totaling 8 jewels.

Similarly, for n = 7 (binary 111), k = 3, but in the sample, they used s = 10, but perhaps s = 3 is sufficient: p1 = 4, p2 = 2, p3 = 1.

At p1 = 4, buys 1 jewel, remaining 3 coins.

At p2 = 2, buys 1 jewel, remaining 1 coin.

At p3 = 1, buys 1 jewel, remaining 0 coins.

Total jewels: 3.

So, s = 3 works, but in the sample, they used s = 10.

Maybe to pad it up or something.

But the problem allows up to 60 stalls, so s = 3 is acceptable.

So, perhaps in general, setting prices as powers of 2 could work for some cases.

But in the second example, n = 6, k = 4.

If I set s = 4, with p1 = 4, p2 = 2, p3 = 1, p4 = 1.

At p1 = 4, buys 1 jewel, remaining 2 coins.

At p2 = 2, buys 1 jewel, remaining 0 coins.

At p3 = 1, buys 0 jewels.

At p4 = 1, buys 0 jewels.

Total jewels: 2, which is less than k = 4.

Alternatively, set p1 = 2, p2 = 2, p3 = 1, p4 = 1.

At p1 = 2, buys 3 jewels, remaining 0 coins.

At p2 = 2, buys 0 jewels.

At p3 = 1, buys 0 jewels.

At p4 = 1, buys 0 jewels.

Total jewels: 3, which is still less than k = 4.

Another attempt: p1 = 1, p2 = 1, p3 = 1, p4 = 1.

At p1 = 1, buys 6 jewels, remaining 0 coins.

Total jewels: 6, which is more than k = 4.

But in this case, Alice would buy all 6 jewels at the first stall, so s = 4 doesn't help.

Hence, it's impossible to make Alice buy exactly k = 4 jewels with n = 6 coins.

So, the answer is "NO".

Now, I need to find a general condition to determine if it's possible or not.

Let me consider that the minimal number of stalls required is ceil(k / m), where m is the maximal number of jewels Alice can buy at a single stall.

But m can be up to n, if p = 1.

This doesn't seem helpful.

Alternatively, perhaps think about the minimal number of stalls needed to make Alice buy exactly k jewels.

Suppose Bob sets up s stalls.

At the first stall, Alice buys floor(n / p1) jewels.

At the second stall, she buys floor((n - p1 * floor(n / p1)) / p2) jewels, and so on.

This seems too recursive.

Maybe I need to find a way to partition n into k parts, where each part is the price p of a stall, and the number of jewels bought at each stall is 1.

Wait, but that's not necessarily the case, because at each stall, she buys floor(n / p) jewels.

So, if p <= n, she buys at least one jewel.

Wait, no, if p > n, she buys 0 jewels.

So, to make her buy exactly one jewel at a stall, p should satisfy p <= n and 2*p > n.

Wait, no.

Let me think.

If p > n, q = 0.

If p <= n and 2*p > n, then q = 1.

If p <= n/2, then q >= 2.

So, to make q = 1, p should satisfy n / 2 < p <= n.

Because if p > n / 2, then floor(n / p) = 1.

If p <= n / 2, then floor(n / p) >= 2.

Hence, to make Alice buy exactly one jewel at a stall, set p > n / 2.

Similarly, to make her buy exactly two jewels, set p <= n / 2 and p > n / 3.

Wait, no, it's not that straightforward.

This is getting too complicated.

Let me look for a simpler condition.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

I need to have sum(floor(n / p1), floor(n / p2), ..., floor(n / ps)) = k.

But this is difficult to control directly.

An alternative approach is to maximize or minimize the number of jewels bought.

The minimal number of stalls to buy exactly k jewels would be ceil(k / max_q), where max_q is the maximal number of jewels Alice can buy at a single stall, which is floor(n / 1) = n.

But ceil(k / n):

- If k <= n, then s = 1 (set p1 = floor(n / k)).

- If k > n, then s = ceil(k / n).

But in the second example, n = 6, k = 4, ceil(4 / 6) = 1.

But with s = 1, p1 = floor(6 / 4) = 1, q1 = floor(6 / 1) = 6, which is more than k = 4.

Hence, it's impossible.

Wait, but the sample output is "NO", which matches.

Another example: n = 7, k = 3.

ceil(3 / 7) = 1.

With s = 1, p1 = floor(7 / 3) = 2, q1 = floor(7 / 2) = 3, which matches k = 3.

Hence, "YES" with s = 1, p1 = 2.

But in the sample, they used s = 10 with p1 to p10 being 2 to 11.

So, multiple solutions are possible.

Wait, but in this case, s = 1 is sufficient, but the sample used s = 10.

So, perhaps any s between 1 and 60 is acceptable, as long as the total jewels bought is k.

Hence, for n = 7, k = 3, both s = 1 with p1 = 2 and s = 10 with p1 to p10 being 2 to 11 are acceptable.

So, perhaps the general approach is:

- If k <= n, then set s = 1, p1 = floor(n / k).

- If k > n, then it's impossible, output "NO".

But in the second example, n = 6, k = 4, which fits k <= n, but output is "NO".

Wait, but according to my previous calculation, with s = 1, p1 = floor(6 / 4) = 1, q1 = floor(6 / 1) = 6, which is more than k = 4.

Hence, it's impossible.

So, my previous assumption is incorrect.

Hence, I need a better condition.

Let me think differently.

Suppose Bob sets up s stalls.

The total jewels bought is sum(floor(n / p1), floor(n / p2), ..., floor(n / ps)).

I need this sum to be exactly k.

One way to achieve this is to set p1, p2, ..., ps such that each floor(n / pi) is equal to qi, where sum(qi) = k.

But I need to ensure that the remaining coins after each stall are correctly handled.

Wait, but in reality, the remaining coins after stall i are n - sum over j=1 to i of (qj * pj).

Hence, it's not just the sum of floor(n / pi), but it's more involved.

This seems too complex.

Let me look for a different approach.

I recall that in the first example, with n = 7 and k = 3, they used s = 10 with p1 to p10 being 2 to 11.

At p1 = 2, q1 = 3, remaining n = 1.

Then, for p2 to p10, since p >= 3, q2 to q10 = 0.

Hence, total jewels = 3.

Similarly, in the third example, with n = 255 and k = 8, they used s = 8 with p1 to p8 being 128, 64, 32, 16, 8, 4, 2, 1.

At p1 = 128, q1 = 1, remaining n = 127.

At p2 = 64, q2 = 1, remaining n = 63.

At p3 = 32, q3 = 1, remaining n = 31.

At p4 = 16, q4 = 1, remaining n = 15.

At p5 = 8, q5 = 1, remaining n = 7.

At p6 = 4, q6 = 1, remaining n = 3.

At p7 = 2, q7 = 1, remaining n = 1.

At p8 = 1, q8 = 1, remaining n = 0.

Total jewels = 8.

So, in this case, s = 8 works.

But in the second example, n = 6, k = 4.

Is there any way to set up s <= 60 stalls to make Alice buy exactly 4 jewels?

Let me try.

Option 1:

s = 2, p1 = 3, p2 = 2.

At p1 = 3, q1 = 2, remaining n = 0.

At p2 = 2, q2 = 0.

Total jewels = 2 < 4.

Not enough.

Option 2:

s = 3, p1 = 2, p2 = 2, p3 = 1.

At p1 = 2, q1 = 3, remaining n = 0.

At p2 = 2, q2 = 0.

At p3 = 1, q3 = 0.

Total jewels = 3 < 4.

Still not enough.

Option 3:

s = 4, p1 = 2, p2 = 2, p3 = 1, p4 = 1.

At p1 = 2, q1 = 3, remaining n = 0.

At p2 = 2, q2 = 0.

At p3 = 1, q3 = 0.

At p4 = 1, q4 = 0.

Total jewels = 3 < 4.

Still not enough.

Option 4:

s = 1, p1 = 1.

At p1 = 1, q1 = 6, remaining n = 0.

Total jewels = 6 > 4.

More than k.

But Alice buys all 6 jewels at the first stall, so she doesn't visit the other stalls.

Hence, total jewels = 6 > 4.

Not acceptable.

Option 5:

s = 2, p1 = 4, p2 = 1.

At p1 = 4, q1 = 1, remaining n = 2.

At p2 = 1, q2 = 2, total jewels = 3 < 4.

Still not enough.

Option 6:

s = 3, p1 = 5, p2 = 2, p3 = 1.

At p1 = 5, q1 = 1, remaining n = 1.

At p2 = 2, q2 = 0.

At p3 = 1, q3 = 1, total jewels = 2 < 4.

Still not enough.

Option 7:

s = 4, p1 = 6, p2 = 3, p3 = 2, p4 = 1.

At p1 = 6, q1 = 1, remaining n = 0.

At p2 = 3, q2 = 0.

At p3 = 2, q3 = 0.

At p4 = 1, q4 = 0.

Total jewels = 1 < 4.

Still not enough.

I can't seem to find a combination where Alice buys exactly 4 jewels with n = 6.

Hence, it's "NO".

So, how can I generalize this?

I need to find a way to make the sum of floor(n / p1), floor(n' / p2), ..., floor(n'' / ps) = k, where n' is the remaining coins after the first stall, and so on.

This seems too involved.

Perhaps I need to find a way to make the total jewels bought equal to k by carefully choosing the prices.

An alternative approach is to consider that Alice will buy floor(n / p1) jewels at the first stall, then floor(n' / p2) at the second, and so on.

I need to ensure that the sum of these floor divisions equals k.

This seems too vague to work with directly.

Maybe I can think in terms of the minimal and maximal possible jewels bought.

The minimal jewels bought is 1, by setting p1 = n.

The maximal jewels bought is n, by setting p1 = 1.

But in between, it's not straightforward.

Wait, perhaps I can think in terms of the total jewels bought being greater than or equal to k, and then adjust the prices to make it exactly k.

But I'm not sure.

Let me consider another approach.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

He wants sum(floor(n / p1), floor(n' / p2), ..., floor(n'' / ps)) = k.

One way to achieve this is to set p1, p2, ..., ps such that:

- At the first stall, Alice buys q1 = floor(n / p1) jewels.

- At the second stall, she buys q2 = floor((n - q1 * p1) / p2) jewels.

- And so on, until the s-th stall.

- The sum q1 + q2 + ... + qs = k.

This seems too vague to work