Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and a set of queries. Each query gives me a range within the array, from index l to r, and I need to find two indices i and j within that range where the elements are different, i.e., a_i ≠ a_j. If such a pair doesn't exist, I should return -1 -1.

First, I need to understand the problem thoroughly. I have multiple test cases, each with an array of integers and a number of queries. For each query, I need to look at a subarray defined by l and r, and find any two elements that are different. If all elements are the same, then no such pair exists.

Let me think about the constraints. The array can be up to 2*10^5 elements, and there can be up to 2*10^5 queries per test case. With t test cases up to 10^4, but considering the sum of n and q across all test cases doesn't exceed 2*10^5, I need to be careful with time complexity.

A naive approach would be, for each query, iterate from l to r and check if there are any two different elements. But with the constraints, this would be too slow because it would be O(q * r - l + 1), which could be up to 10^10 operations, way beyond time limits.

I need a smarter way to handle this. Let's think about precomputing some information about the array that can help answer the queries efficiently.

One idea is to precompute for each position the next position where a different element occurs, and similarly, the previous position where a different element occurs. This way, for any query, I can quickly find such a pair.

Let me think about it in more detail. I can create two arrays:

- next_diff: for each index i, next_diff[i] is the smallest index j > i where a[j] ≠ a[i].

- prev_diff: for each index i, prev_diff[i] is the largest index j < i where a[j] ≠ a[i].

Then, for a query [l, r], I can choose:

- i = l, j = next_diff[l] (if next_diff[l] <= r)

- or i = r, j = prev_diff[r] (if prev_diff[r] >= l)

- or find any other pair where elements differ.

Wait, actually, I need to ensure that both i and j are within [l, r]. So, for example, if next_diff[l] is within [l, r], then (l, next_diff[l]) is a valid pair. If not, maybe I can look at prev_diff[r] and see if it's within [l, r].

But this might be overly complicated. Let's think differently.

Another approach is to precompute for each position i, the smallest index j > i where a[j] ≠ a[i], and similarly, the largest index j < i where a[j] ≠ a[i]. Then, for a query [l, r], I can find the minimum of next_diff for l to r, and see if it's within [l, r]. Similarly for prev_diff.

But I'm not sure if this is the most efficient way.

Let me consider the fact that I only need to find any pair where a_i ≠ a_j. I don't need to find all such pairs, just any one pair that satisfies the condition.

An efficient way to handle range queries is to use a segment tree or a sparse table, which can answer range queries quickly, usually in O(1) or O(log n) time per query.

In this case, since I need to find if there are at least two distinct elements in the range [l, r], I can build a segment tree that stores the unique elements in each range.

Wait, but storing unique elements in each range might be space-inefficient, especially since a_i can be up to 10^6.

Alternatively, I can store the frequency of each element in each range, but that would require a lot of space and time.

Let me think about it differently. Since the queries are independent, I can answer them in any order. So, perhaps I can sort the queries and process them in a way that minimizes the computation needed.

But I'm not sure about that approach right now.

Let me consider using a sparse table. A sparse table can be built in O(n log n) time and answer RMQ (Range Minimum/Maximum Query) in O(1) time. But in this problem, I need to check if there are at least two distinct elements in the range.

Wait, maybe I can store the minimum and maximum elements in the range, and check if they are different. If the minimum and maximum are the same, then all elements in the range are equal. If they are different, then there exists at least one pair of elements that are different.

That seems promising. So, I can build a sparse table that stores the minimum and maximum values in each range, and for each query, check if min[l..r] ≠ max[l..r]. If they are not equal, then such a pair exists, and I can pick any two indices where the elements differ. If they are equal, then all elements are the same, and no such pair exists.

But wait, I need to output the indices i and j where a_i ≠ a_j. So, it's not enough to just check if such a pair exists; I need to find specific indices.

So, using the sparse table, I can quickly determine if such a pair exists. But I still need a way to find specific indices i and j where a_i ≠ a_j.

Let me think about how to find such indices efficiently.

One way is, for each query [l, r], if min[l..r] ≠ max[l..r], then find the smallest i >= l where a[i] = min[l..r], and the smallest j >= l where a[j] = max[l..r], ensuring that a[i] ≠ a[j].

But this might require additional processing.

Wait, actually, since I have the sparse table, I can find min[l..r] and max[l..r]. If they are different, I can find any i where a[i] = min[l..r] and any j where a[j] = max[l..r], with l <= i, j <= r.

To find the positions of min and max elements, I can precompute for each position the position of the nearest min or max element to the left or right.

But this seems a bit involved.

Let me consider another approach.

Since the queries are independent, perhaps I can answer them in a way that doesn't require precomputing everything upfront.

Wait, but with n and q up to 2*10^5, I need an efficient solution.

Let me consider building a segment tree that stores the set of unique elements in each range.

But storing sets in each node would be too slow and space-consuming.

Alternatively, I can store the frequency counts in each node, but that would require a lot of space and time.

Wait, perhaps I can store just the minimum and maximum in each node, as I thought earlier.

Then, for each query, if min[l..r] ≠ max[l..r], I can iterate from l to r and find the first i where a[i] = min[l..r], and the first j where a[j] = max[l..r], ensuring that a[i] ≠ a[j].

But iterating from l to r for each query would be too slow, since q can be up to 2*10^5 and n up to 2*10^5.

I need a way to find such i and j efficiently, without iterating through the range each time.

Let me consider precomputing for each position i, the next position where a[j] ≠ a[i], and similarly, the previous position where a[j] ≠ a[i].

Then, for each query [l, r], I can use these precomputed values to find such a pair quickly.

Let's try to formalize this.

I can create two arrays:

- next_diff[i]: the smallest j > i such that a[j] ≠ a[i], or n+1 if no such j exists.

- prev_diff[i]: the largest j < i such that a[j] ≠ a[i], or 0 if no such j exists.

Then, for a query [l, r], I can do the following:

- If a[l] ≠ a[next_diff[l]], and next_diff[l] <= r, then (l, next_diff[l]) is a valid pair.

- Similarly, if a[r] ≠ a[prev_diff[r]], and prev_diff[r] >= l, then (prev_diff[r], r) is a valid pair.

- If neither of these holds, then all elements in [l, r] are equal, so output -1 -1.

Wait, but I need to ensure that i and j are both within [l, r].

Let me think about it step by step.

First, compute next_diff and prev_diff arrays.

To compute next_diff:

Initialize next_diff[n] = n+1

for i from n-1 downto 1:

if a[i] ≠ a[i+1]:

next_diff[i] = i+1

else:

next_diff[i] = next_diff[i+1]

Similarly, for prev_diff:

Initialize prev_diff[1] = 0

for i from 2 to n:

if a[i] ≠ a[i-1]:

prev_diff[i] = i-1

else:

prev_diff[i] = prev_diff[i-1]

Then, for each query [l, r]:

- If next_diff[l] <= r and a[l] ≠ a[next_diff[l]]:

output l and next_diff[l]

- Else if prev_diff[r] >= l and a[r] ≠ a[prev_diff[r]]:

output r and prev_diff[r]

- Else:

output -1 -1

This seems correct because:

- If next_diff[l] is within [l, r], and a[l] ≠ a[next_diff[l]], then we have found a pair.

- Similarly, if prev_diff[r] is within [l, r], and a[r] ≠ a[prev_diff[r]], then we have found a pair.

- If neither condition holds, then all elements in [l, r] are equal.

Let me test this logic with an example.

Take the first test case:

n = 5

a = [1, 1, 2, 1, 1]

q = 3

Queries:

1 5

1 2

1 3

Compute next_diff:

Initialize next_diff[5] = 6

a[4] = 1, a[5] = 1, so next_diff[4] = next_diff[5] = 6

a[3] = 2, a[4] = 1, so next_diff[3] = 4

a[2] = 1, a[3] = 2, so next_diff[2] = 3

a[1] = 1, a[2] = 1, so next_diff[1] = next_diff[2] = 3

So next_diff = [3, 3, 4, 6, 6]

Compute prev_diff:

Initialize prev_diff[1] = 0

a[2] = 1, a[1] = 1, so prev_diff[2] = 0

a[3] = 2, a[2] = 1, so prev_diff[3] = 2

a[4] = 1, a[3] = 2, so prev_diff[4] = 3

a[5] = 1, a[4] = 1, so prev_diff[5] = prev_diff[4] = 3

So prev_diff = [0, 0, 2, 3, 3]

Now, for query 1 5:

next_diff[1] = 3, which is within [1,5], and a[1] = 1 ≠ a[3] = 2, so output 1 and 3

For query 1 2:

next_diff[1] = 3, which is > 2, so skip

prev_diff[2] = 0, which is < 1, so skip

So output -1 -1

For query 1 3:

next_diff[1] = 3, which is within [1,3], and a[1] = 1 ≠ a[3] = 2, so output 1 and 3

This matches the sample output.

Let me check another test case.

Second test case:

n = 6

a = [30, 20, 20, 10, 10, 20]

q = 5

Queries:

1 2

2 3

2 4

2 6

3 5

Compute next_diff:

next_diff[6] = 7

a[5] = 10, a[6] = 20, so next_diff[5] = 6

a[4] = 10, a[5] = 10, so next_diff[4] = next_diff[5] = 6

a[3] = 20, a[4] = 10, so next_diff[3] = 4

a[2] = 20, a[3] = 20, so next_diff[2] = next_diff[3] = 4

a[1] = 30, a[2] = 20, so next_diff[1] = 2

So next_diff = [2, 4, 4, 6, 6, 7]

Compute prev_diff:

prev_diff[1] = 0

a[2] = 20 ≠ a[1] = 30, so prev_diff[2] = 1

a[3] = 20 == a[2], so prev_diff[3] = prev_diff[2] = 1

a[4] = 10 ≠ a[3], so prev_diff[4] = 3

a[5] = 10 == a[4], so prev_diff[5] = 4

a[6] = 20 ≠ a[5], so prev_diff[6] = 5

So prev_diff = [0,1,1,3,4,5]

Now, for query 1 2:

next_diff[1] = 2, within [1,2], a[1] ≠ a[2], so output 1 and 2

For query 2 3:

next_diff[2] = 4, which is > 3, so skip

prev_diff[3] = 1, which is < 2, so skip

So output -1 -1

For query 2 4:

next_diff[2] = 4, within [2,4], a[2] = 20 ≠ a[4] = 10, so output 2 and 4

For query 2 6:

next_diff[2] = 4, within [2,6], a[2] = 20 ≠ a[4] = 10, so output 2 and 4

For query 3 5:

next_diff[3] = 4, within [3,5], a[3] = 20 ≠ a[4] = 10, so output 3 and 4

This also matches the sample output.

Seems like this approach works.

Now, let's think about implementing this efficiently.

First, precompute next_diff and prev_diff arrays.

To compute next_diff:

Initialize next_diff[n] = n+1

for i from n-1 downto 1:

if a[i] ≠ a[i+1]:

next_diff[i] = i+1

else:

next_diff[i] = next_diff[i+1]

Similarly, for prev_diff:

Initialize prev_diff[1] = 0

for i from 2 to n:

if a[i] ≠ a[i-1]:

prev_diff[i] = i-1

else:

prev_diff[i] = prev_diff[i-1]

Then, for each query [l, r]:

if next_diff[l] <= r and a[l] ≠ a[next_diff[l]]:

print(l, next_diff[l])

elif prev_diff[r] >= l and a[r] ≠ a[prev_diff[r]]:

print(r, prev_diff[r])

else:

print(-1, -1)

This should work efficiently, as the precomputation is O(n), and each query is O(1).

Now, considering the constraints, with t up to 10^4, but sum of n and q across all test cases <= 2*10^5, this should be acceptable.

I need to make sure that the implementation is efficient and doesn't have any unnecessary computations.

Also, need to handle the indices correctly, keeping in mind that the array is 1-indexed as per the problem statement.

Let me think about edge cases.

Edge case 1: All elements are the same.

For example, n=5, a=[1,1,1,1,1], q=1, query=[1,5]

In this case, next_diff[i] would be the next position where a[j] ≠ 1, which doesn't exist, so next_diff[i] = n+1 for all i.

prev_diff[i] would be the previous position where a[j] ≠ 1, which doesn't exist except for i=1.

So, for query [1,5], next_diff[1]=6 > 5, and prev_diff[5]=0 < 1, so output -1 -1.

Edge case 2: All elements are different.

For example, n=5, a=[1,2,3,4,5], q=1, query=[1,5]

Here, next_diff[i]=i+1 for all i < n, and next_diff[n]=n+1

prev_diff[i]=i-1 for all i >1, prev_diff[1]=0

For query [1,5], next_diff[1]=2 <=5 and a[1] ≠ a[2], so output 1 2

Alternatively, could also output 5 and prev_diff[5]=4, since a[5] ≠ a[4]

But according to the approach, it would output 1 and 2.

Which is correct.

Edge case 3: Single element in the range.

Wait, the problem says 1 <= l <= r <= n, but n >=2, so r-l+1 >=2.

Wait, no, in the problem statement, it's given that n >=2 and l <=r, but l can be equal to r.

Wait, checking the problem statement: "1 ≤ l ≤ r ≤ n"

But in the problem description, it says to find two indices i and j such that l <= i <=r and l <=j <=r and a_i ≠ a_j.

So, if l=r, then i and j must both be l, but a_l cannot be compared to itself.

So, for l=r, there are no such pairs, since a_i cannot be unequal to itself.

Wait, but the problem allows l <= i <=r and l <=j <=r, but doesn't specify i ≠ j.

Wait, reading again: "find two indices i and j (or determine that they do not exist) such that:

- l <= i <= r;

- l <= j <= r;

- a_i ≠ a_j."

It doesn't specify that i ≠ j, so potentially i can be equal to j.

But, if i=j, then a_i cannot be unequal to itself.

So, I think it's implied that i ≠ j, but to be sure, I need to check.

Wait, the problem says "two indices i and j", but doesn't specify i ≠ j.

However, in the sample input, when l=r, it outputs -1 -1, indicating that no such pair exists.

So, it's safe to assume that i ≠ j is implied.

Hence, for l=r, output -1 -1.

In our approach, if l=r, then next_diff[l] would be beyond r, and prev_diff[r] would be before l, so we output -1 -1, which is correct.

Another edge case: l=1, r=n, all elements same except one.

For example, n=4, a=[1,1,2,1], q=1, query=[1,4]

next_diff[1]=3, within [1,4], a[1]=1 ≠ a[3]=2, so output 1 3

Which is correct.

Another case: l=2, r=4, a=[1,2,2,2]

next_diff[2]=3, within [2,4], a[2]=2 ≠ a[3]=2? No, they are equal.

Wait, no, a[2]=2 and a[3]=2 are equal, so next_diff[2]=next_diff[3]=4

a[2]=2 and a[4]=2 are equal, so next_diff[2]=4

But in this case, all elements in [2,4] are 2, so should output -1 -1

Wait, but according to the approach, next_diff[2]=4, and a[2]=2 == a[4]=2, so skip

prev_diff[4]=3, which is >=l=2, but a[4]=2 == a[3]=2, so skip

Hence, output -1 -1, which is correct.

Wait, but in this array, a=[1,2,2,2], for query [2,4], all elements are 2, so correct to output -1 -1

Seems like the approach handles this correctly.

Another case: l=2, r=4, a=[1,2,3,2]

next_diff[2]=3, within [2,4], a[2]=2 ≠ a[3]=3, so output 2 3

Which is correct.

Seems solid.

Now, about implementation.

I need to read t test cases.

For each test case:

- Read n

- Read array a of n integers

- Read q

- Read q queries, each with l and r

- Compute next_diff and prev_diff

- Answer each query

I need to handle multiple test cases efficiently.

Also, need to make sure that indices are 1-based as per the problem.

In programming, arrays are usually 0-based, so I need to adjust indices accordingly.

Let me think about coding this.

First, read t.

Then, for each test case:

Read n

Read a as a list of integers, with indices from 1 to n

Read q

Read q pairs of l and r

Compute next_diff:

Initialize next_diff[n] = n+1

for i from n-1 downto 0:

if a[i] != a[i+1]:

next_diff[i] = i+1

else:

next_diff[i] = next_diff[i+1]

Compute prev_diff:

Initialize prev_diff[0] = 0

for i from 1 to n-1:

if a[i] != a[i-1]:

prev_diff[i] = i-1

else:

prev_diff[i] = prev_diff[i-1]

Then, for each query (l, r):

l and r are 1-based, so convert to 0-based: l -=1; r -=1

if next_diff[l] <= r and a[l] != a[next_diff[l]]:

print(l+1, next_diff[l]+1)

elif prev_diff[r] >= l and a[r] != a[prev_diff[r]]:

print(r+1, prev_diff[r]+1)

else:

print(-1, -1)

This should work.

I need to make sure that the arrays are 0-based while handling indices correctly.

Also, need to handle the case when l=r, which should always output -1 -1.

Wait, in our approach, if l=r, then next_diff[l] is beyond r, and prev_diff[r] is before l, so it should output -1 -1, which is correct.

I think this is solid.

Let me think about time complexity.

Precomputing next_diff and prev_diff is O(n) per test case.

Answering each query is O(1).

With t test cases, sum of n and q across all test cases <= 2*10^5, so total time should be acceptable.

I need to make sure that the implementation is optimized and doesn't have any unnecessary operations inside loops.

Also, need to read input efficiently, as the input size can be large.

In Python, reading input with sys.stdin.readline() is faster than input().

So, I should use sys.stdin.readline() for reading inputs.

Also, since t can be up to 10^4, but sum of n and q across all test cases is <=2*10^5, I need to make sure that the code doesn't have any per-test-case overhead that could cause timeouts.

I should also consider consolidating input reading.

Perhaps read all input at once and process it.

Let me think about that.

I can read all input at once using sys.stdin.read(), split it into tokens, and process them as needed.

This is often faster in Python for large inputs.

So, I can do something like:

import sys

def main():

import sys

data = sys.stdin.read().split()

ptr = 0

t = int(data[ptr])

ptr +=1

for _ in range(t):

n = int(data[ptr])

ptr +=1

a = list(map(int, data[ptr:ptr+n]))

ptr +=n

q = int(data[ptr])

ptr +=1

queries = []

for _ in range(q):

l = int(data[ptr]) -1 # convert to 0-based

r = int(data[ptr+1]) -1 # convert to 0-based

queries.append((l,r))

ptr +=2

# Compute next_diff

next_diff = [n] * n

next_diff[n-1] = n

for i in range(n-2, -1, -1):

if a[i] != a[i+1]:

next_diff[i] = i+1

else:

next_diff[i] = next_diff[i+1]

# Compute prev_diff

prev_diff = [0] * n

prev_diff[0] = 0

for i in range(1, n):

if a[i] != a[i-1]:

prev_diff[i] = i-1

else:

prev_diff[i] = prev_diff[i-1]

# Answer queries

for (l,r) in queries:

if next_diff[l] <= r and a[l] != a[next_diff[l]]:

print(l+1, next_diff[l]+1)

elif prev_diff[r] >= l and a[r