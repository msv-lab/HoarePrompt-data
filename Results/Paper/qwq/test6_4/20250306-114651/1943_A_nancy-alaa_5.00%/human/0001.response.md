Alright, I've got this problem to solve. Let's see what it's about. So, there's this game between Alice and Bob where they're playing with an array of integers. Alice starts with an empty array c, and they take turns making moves. On Alice's turn, she picks an element from the original array a, appends it to c, and deletes it from a. On Bob's turn, he just picks an element from a and deletes it. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not present in c. Alice wants to maximize the score, and Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand what MEX is. MEX stands for minimum excludant, which is the smallest non-negative integer not present in the array. For example, for [2,2,1], MEX is 0 because 0 isn't in the array. For [3,1,0,1], it's 2, since 0 and 1 are present, but 2 isn't. And for [0,3,1,2], it's 4, as 0,1,2,3 are present.

So, the goal is to find the MEX of array c after the game ends, assuming both players play optimally. Alice wants to maximize this MEX, and Bob wants to minimize it.

Let me think about how the game progresses. Alice and Bob alternate turns, with Alice going first. Alice gets to add one element to c and remove it from a per turn, while Bob just removes one element from a per turn. So, for each pair of turns (Alice's and Bob's), two elements are removed from a: one goes to c and one doesn't.

Wait, no. Actually, in Alice's turn, she picks an element, appends it to c, and deletes it from a. In Bob's turn, he picks an element and deletes it from a. So, for every two turns (one Alice, one Bob), two elements are removed from a, one of which goes to c.

If n is odd, there will be (n//2) Alice's turns and (n//2) Bob's turns, with one extra turn for Alice.

Wait, let's think about the number of turns:

- Total elements: n

- Each turn removes one element from a.

- Alice's turn: remove one and add it to c.

- Bob's turn: remove one, don't add to c.

- So, total turns: n turns.

- Alice plays on turns 1, 3, 5, ..., which are the odd-numbered turns.

- Bob plays on turns 2, 4, 6, ..., the even-numbered turns.

- So, Alice plays ceil(n/2) times, and Bob plays floor(n/2) times.

Wait, no. Wait, turns are alternating, Alice starts.

- Total turns: n turns.

- Alice plays on turns 1,3,5,... up to n.

- Bob plays on turns 2,4,6,... up to n.

- So, if n is odd, Alice plays (n//2 + 1) times, Bob plays (n//2) times.

- If n is even, Alice and Bob both play (n/2) times.

So, in terms of how many elements go into c:

- Alice adds one element to c per her turn.

- Bob doesn't add any.

- Therefore, total elements in c at the end: number of Alice's turns.

- Which is ceil(n/2).

Wait, no. Wait, in each of Alice's turns, she adds one element to c.

- So, total elements in c: number of Alice's turns.

- Which is ceil(n/2).

Wait, but in terms of code, it's easier to think in terms of n being the size of a.

Wait, but I need to think about what c will look like at the end.

Goal is to find MEX of c, which is the smallest missing non-negative integer in c.

Alice wants to maximize MEX, Bob wants to minimize it.

I need to find out what MEX will be if both play optimally.

So, I need to model their strategies.

Let me consider that MEX is determined by which numbers are in c.

So, c will have ceil(n/2) elements, since Alice gets to choose ceil(n/2) elements to add to c.

But, Bob can influence which elements are available for Alice to choose from.

Wait, no. Wait, actually, Bob can remove elements that Alice might want to add to c.

Wait, but Bob can choose any element to remove on his turn.

So, Bob can remove elements that Alice would want to add to c, thereby forcing Alice to choose less desirable elements.

Wait, but Alice gets to choose first, then Bob, alternately.

Wait, perhaps I need to think differently.

I need to think about the final composition of c.

c will have ceil(n/2) elements, chosen by Alice, with Bob trying to interfere.

Wait, perhaps I need to think in terms of selecting elements for c.

Wait, maybe I can think in terms of available numbers and their frequencies.

Let me consider frequencies of each number in a.

Let me count how many times each number appears in a.

Let's say I have a frequency map of the numbers in a.

Now, Alice wants to maximize MEX of c, which means she wants c to contain as many low numbers as possible, up to the point where a higher number can be included without gaps.

Wait, no, actually, to maximize MEX, Alice wants c to contain as many low numbers as possible, so that the smallest missing number is as large as possible.

Wait, no, actually, to maximize MEX, Alice wants c to contain as many low numbers as possible, so that the smallest missing number is as large as possible.

Wait, actually, to maximize MEX, Alice wants c to contain as many low numbers as possible, because MEX is the smallest missing number.

So, the higher the MEX, the larger the sequence of consecutive numbers starting from 0 is present in c.

Hence, Alice wants c to have as many low numbers as possible.

Bob, on the other hand, wants to minimize MEX, so he wants to disrupt Alice's ability to collect low numbers.

So, Bob will try to remove low numbers that Alice might want to add to c.

Wait, but Bob can only remove one element per turn, and Alice chooses which element to add to c.

Wait, but Alice chooses first, then Bob, alternately.

Wait, perhaps I need to think in terms of available numbers and their frequencies.

Let me consider that.

Let me consider that initially, I have a frequency map of the numbers in a.

Let's say I have counts for each number from 0 to n-1.

Now, the game consists of n turns, alternating between Alice and Bob, with Alice starting.

In each turn:

- Alice chooses an element from a, adds it to c, and deletes it from a.

- Bob chooses an element from a, deletes it from a.

So, in total, after n turns, a is empty, and c contains ceil(n/2) elements.

Now, I need to find the MEX of c, given optimal play from both sides.

So, I need to model how Alice and Bob make their choices to maximize and minimize MEX, respectively.

I need to think about what numbers Alice should add to c and what numbers Bob should remove from a to affect c.

Wait, but Bob can remove any element from a, not necessarily the one Alice would choose.

So, perhaps I need to think in terms of available frequencies.

Let me consider that.

Let me consider that for each number i from 0 to n-1, I have a certain count in a.

Now, the game is played in turns, with Alice and Bob taking turns, Alice starting.

In each turn:

- Alice chooses an element to add to c and remove from a.

- Bob chooses an element to remove from a.

So, for each pair of turns (Alice's and Bob's), two elements are removed from a: one goes to c, one doesn't.

If n is odd, there's an extra Alice's turn.

Now, to maximize MEX, Alice wants to include as many low numbers in c as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from including low numbers in c.

So, Bob will try to remove low numbers from a, making them unavailable for Alice.

Wait, but Alice chooses first in each pair of turns.

So, perhaps Alice can counter Bob's strategy.

Wait, maybe I need to think in terms of the number of times each number appears in a.

Let me consider that.

Suppose a number x appears cnt[x] times in a.

Now, in the game, Alice and Bob take turns removing elements, with Alice also adding to c on her turn.

So, for each number x, the number of times it's available to be added to c is cnt[x], minus the number of times Bob removes it.

But Bob can remove it either when it's his turn or when it's Alice's turn.

Wait, no, Bob removes it on his turn, and Alice removes and adds to c on her turn.

Wait, perhaps I need to think in terms of the total number of times each number is removed, including by Alice and Bob.

Wait, perhaps I can think in terms of the total number of times each number is removed, and see how many times it's added to c.

But this seems complicated.

Let me think differently.

Let me consider that the game consists of n steps, and in each step, one element is removed from a, and possibly added to c (only by Alice).

So, the sequence of removals is determined by the sequence of choices made by Alice and Bob.

Alice wants to maximize the MEX of c, which means she wants c to contain as many low numbers as possible.

Bob wants to minimize the MEX of c, which means he wants to prevent Alice from including low numbers in c.

So, perhaps I can think in terms of which numbers are available at the time Alice makes her choices.

Wait, maybe I can think in terms of simulating the game.

Let me consider that.

Let's say I sort the array a in ascending order.

Wait, but the array is not necessarily sorted, and sorting might not help directly.

Wait, perhaps I need to think in terms of frequency counts.

Let me consider that.

Let me count the frequency of each number in a.

Let's say I have a frequency map mpp where mpp[x] is the count of x in a.

Now, the game proceeds with Alice and Bob taking turns.

Alice starts.

In each of Alice's turns, she picks an element, adds it to c, and deletes it from a.

In each of Bob's turns, he picks an element and deletes it from a.

The game ends when a is empty, and the score is the MEX of c.

I need to find the MEX of c when both play optimally.

So, to maximize MEX, Alice wants c to contain as many low numbers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from including low numbers in c.

So, Bob will try to remove low numbers from a, making them unavailable for Alice.

Wait, but Alice gets to choose first in each pair of turns.

Wait, perhaps I need to think in terms of who has control over which numbers.

Wait, maybe I can think in terms of the number of times each number appears and how many turns are played.

Wait, perhaps I can think in terms of the minimal number that Alice can't get enough copies of to include in c.

Wait, that might be a way.

Let me consider that.

Suppose I have number x.

Alice wants to include x in c.

But Bob can interfere by removing x from a.

So, for each x, I need to see how many times it appears in a, and how many times Alice can add it to c before Bob removes it.

Wait, perhaps I can think in terms of the number of times Alice can add x to c.

Given that Alice and Bob take turns, with Alice starting, and Alice gets to choose which element to add to c.

Wait, perhaps I can think in terms of the available copies of each number and the sequence of choices.

This seems complicated.

Let me look for a pattern or a simpler way to approach this.

Let me consider some examples.

Take the first example from the input:

n=4

a=[0,0,1,1]

So, mpp={0:2,1:2}

Now, according to the sample output, the MEX is 2.

So, in this case, c ends up with [0,1], and MEX is 2.

Wait, but in the explanation, it shows a different sequence, but the MEX is still 2.

Another example:

n=4

a=[0,1,2,3]

Output:1

Wait, but according to the definition, MEX of [0,1,2,3] would be 4.

But the output is 1, which suggests that c ends up with [0,1,2,3] having MEX 4, but the output is 1.

Wait, no, wait, n=4, a=[0,1,2,3], output is 1.

Wait, that seems incorrect based on my understanding.

Wait, perhaps I misread.

Wait, no, in the second test case:

4

0 1 2 3

Output:1

Wait, but if c ends up with [0,1,2,3], MEX is 4.

But the output is 1, which contradicts my assumption.

Wait, perhaps in this test case, c ends up with only some elements.

Wait, total elements in c would be ceil(4/2)=2 elements.

Wait, hold on.

Wait, no, wait, total turns are 4, Alice plays on turns 1,3, Bob on turns 2,4.

So, Alice adds elements on turns 1 and 3, Bob removes elements on turns 2 and 4.

Wait, no, in the problem statement, on Alice's turn, she picks an element, adds it to c, and deletes it from a.

On Bob's turn, he picks an element, deletes it from a.

So, in total, after 4 turns, a is empty, and c contains the elements Alice added.

So, in this case, Alice adds elements on turns 1 and 3, so c has 2 elements.

Hence, in the second test case, c has 2 elements, and MEX is 1.

Wait, but if c has 2 elements, how can MEX be 1?

Wait, for example, if c=[0,2], MEX is 1.

Or c=[0,1], MEX is 2.

But the output is 1, so perhaps Bob can force c to be [0,2], for example.

Wait, perhaps I need to see possible scenarios.

Let me think about possible sequences.

Sequence 1:

- Alice chooses 0, c=[0], a=[1,2,3]

- Bob chooses 1, a=[2,3]

- Alice chooses 2, c=[0,2], a=[3]

- Bob chooses 3, a=[]

- c=[0,2], MEX=1

Sequence 2:

- Alice chooses 0, c=[0], a=[1,2,3]

- Bob chooses 2, a=[1,3]

- Alice chooses 1, c=[0,1], a=[3]

- Bob chooses 3, a=[]

- c=[0,1], MEX=2

So, depending on the choices, MEX can be 1 or 2.

Alice wants to maximize MEX, Bob wants to minimize it.

So, in this case, Bob can force MEX to be 1 by choosing to remove 2, preventing Alice from getting both 0 and 1.

Wait, but in the second sequence, Bob chooses 2, and Alice still gets to choose 1.

Wait, perhaps Bob can choose to remove 1 instead.

Wait, let's see:

- Alice chooses 0, c=[0], a=[1,2,3]

- Bob chooses 1, a=[2,3]

- Alice chooses 2, c=[0,2], a=[3]

- Bob chooses 3, a=[]

- c=[0,2], MEX=1

Alternatively:

- Alice chooses 0, c=[0], a=[1,2,3]

- Bob chooses 3, a=[1,2]

- Alice chooses 1, c=[0,1], a=[2]

- Bob chooses 2, a=[]

- c=[0,1], MEX=2

So, Bob can choose to remove 1 or 3, leading to different MEX.

So, Bob can choose to remove 1, leading to MEX=1, or remove 3, leading to MEX=2.

Since Bob wants to minimize MEX, he will choose to remove 1, forcing MEX=1.

Hence, the minimal MEX Alice can achieve is 1.

Hence, the output is 1.

Another test case:

n=2

a=[1,1]

Output:0

So, c will have ceil(2/2)=1 element.

Bob will remove one element, and Alice will add one element.

So, c will have one element, either 1.

MEX would be 0, since 0 is not in c.

Hence, output is 0.

Wait, but according to the problem, MEX is 0 if 0 is not in c.

In this case, c has [1], so MEX is 0.

Hence, output is 0.

First test case:

n=4

a=[0,0,1,1]

Output:2

Possible c=[0,1], MEX=2.

Another possible c=[0,1], MEX=2.

Hence, MEX is 2.

Wait, but in the earlier simulation, in the second test case, MEX could be 1 or 2, but Bob can force it to be 1.

Hence, output is 1.

So, perhaps I need to think in terms of minimal MEX Alice can achieve, considering Bob's interference.

Now, let's think about how to generalize this.

I need to find the minimal MEX Alice can achieve, given that Bob is trying to minimize it.

Wait, no, actually, Alice wants to maximize MEX, Bob wants to minimize it.

Wait, perhaps I need to think in terms of how many copies of each number Alice can get into c.

Given that Alice gets to choose ceil(n/2) elements to add to c, and Bob gets to choose floor(n/2) elements to remove from a.

But Bob can choose to remove elements that Alice wants.

So, perhaps I need to think in terms of the number of times each number appears in a, and how many times Alice can add them to c before Bob removes them.

Wait, perhaps I can think in terms of the number of times Alice can add a number to c.

Given that Alice gets to choose ceil(n/2) elements to add to c, and Bob gets to remove floor(n/2) elements.

But Bob can remove any elements, including those that Alice wants.

So, perhaps I need to think in terms of the minimal number that Alice can't get enough copies of.

Wait, perhaps I can think in terms of the frequency of each number.

Let me consider that.

For each number x, if it appears freq[x] times in a, then Alice can add ceil(freq[x]/2) copies of x to c, assuming Bob doesn't interfere.

But Bob can interfere by removing x's that Alice wants to add.

Wait, perhaps I need to think in terms of the minimal number of x that Alice can add to c.

Wait, perhaps I can think in terms of the number of times Alice can add x to c, given that Bob can remove some x's.

Wait, maybe I can think in terms of the minimal number x such that Alice can't add x to c.

Wait, perhaps I need to iterate through the numbers starting from 0 and check if Alice can add x to c.

If Alice can add x to c, then MEX is higher.

If not, then MEX is x.

Wait, perhaps I need to find the smallest x where Alice can't add x to c.

So, for each x from 0 to n-1, I need to check if Alice can add x to c.

If she can, then MEX is higher, so I move to the next x.

If she can't, then MEX is x.

So, I need to find the smallest x where Alice can't add x to c.

Wait, but MEX is the smallest x not in c.

So, if x is in c, then MEX is higher.

If x is not in c, then MEX is x.

Hence, I need to find the smallest x that is not in c.

But c contains ceil(n/2) elements chosen by Alice, with Bob trying to minimize MEX.

Wait, perhaps I need to think in terms of the number of times x appears in a and how many times Alice can add x to c.

Let me consider that.

Suppose x appears freq[x] times in a.

Alice can add floor((freq[x]+1)/2) copies of x to c.

Because for each pair of turns, Alice and Bob, Alice can add one x, and Bob can remove one x.

But if freq[x] is odd, Alice can add one more x.

Wait, perhaps I can think in terms of the number of times Alice can add x to c.

Given that Alice gets to choose ceil(n/2) elements to add to c, and Bob gets to remove floor(n/2) elements.

But Bob can remove any elements, including those that Alice wants.

So, for each x, the number of times Alice can add x to c is max(freq[x] - floor(n/2), 0).

Wait, but this might not be accurate, because Bob can choose to remove other elements as well.

Wait, perhaps I need to think in terms of the minimal x where freq[x] - floor(n/2) < 1, meaning Alice can't add at least one x to c.

Wait, but this seems too simplistic.

Wait, perhaps I need to iterate through x from 0 to n-1, and for each x, check if Alice can add x to c.

To do that, I need to see if freq[x] is greater than the number of times Bob can remove x.

Wait, but Bob can choose to remove any elements, not necessarily x.

So, perhaps I need to think in terms of the total number of elements Bob can remove.

Bob can remove floor(n/2) elements.

So, to prevent Alice from adding x to c, Bob needs to remove freq[x] elements of x.

Wait, no, Bob can remove up to floor(n/2) elements in total.

So, Bob can choose to remove elements that Alice wants, but he can't remove more than floor(n/2) elements.

Hence, for each x, the number of times Alice can add x to c is freq[x] - the number of times Bob removes x.

But Bob will try to minimize MEX, so he will prioritize removing low x's that Alice wants.

So, perhaps I need to iterate through x from 0 to n-1, and for each x, see if Alice can add at least one x to c, even after Bob removes as many x's as possible.

Wait, perhaps I can think in terms of the remaining frequency after Bob removes floor(n/2) elements.

But Bob can choose to remove elements strategically.

Wait, perhaps I need to think in terms of the minimal x where freq[x] <= floor(n/2).

Because if freq[x] <= floor(n/2), Bob can remove all instances of x, preventing Alice from adding any x to c.

Hence, MEX would be x.

Wait