Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a string consisting of lowercase Latin letters, and I need to partition this string into substrings where none of these substrings is a palindrome. A palindrome is a string that reads the same forwards and backwards, like "racecar" or "abccba".

First, I need to understand what a partition is. It's an ordered sequence of substrings that, when concatenated, form the original string. So, for example, if I have the string "abc", possible partitions could be ["a", "b", "c"], ["ab", "c"], or ["a", "bc"], right?

My task is to find at least one such partition where none of the substrings is a palindrome. If such a partition exists, I should print "YES", followed by the number of parts in the partition and the parts themselves. If no such partition exists, I should print "NO".

Let's look at the examples provided to get a better understanding.

First test case:

Input:

sinktheyacht

Output:

YES

1

sinktheyacht

So, the entire string "sinktheyacht" is not a palindrome, so partitioning it into a single substring satisfies the condition.

Second test case:

Input:

lllllllll

Output:

NO

Here, every possible substring of "lllllllll" is a palindrome because all characters are 'l'. So, there's no way to partition this string into substrings that are not palindromes.

Third test case:

Input:

uwuowouwu

Output:

YES

3

uw uow ouwu

In this case, the string can be partitioned into three substrings: "uw", "uow", and "ouwu", none of which are palindromes.

Alright, so I need to devise a way to determine whether such a partition exists for any given string.

Let's think about when it's impossible to find such a partition. It seems like if every possible substring is a palindrome, then it's impossible. But wait, that's not quite right. Because even if the entire string is a palindrome, I can still partition it into smaller substrings that might not be palindromes.

For example, take "aba". It's a palindrome, but if I partition it into "a" and "ba", "a" is a palindrome, but "ba" is not. So, this partition contains one palindrome and one non-palindrome. That doesn't satisfy the condition because all parts must not be palindromes.

Wait, "a" is a palindrome, so this partition is invalid. So, for "aba", I need to find a partition where neither part is a palindrome. Is that possible?

Let's see:

- Partition into "ab" and "a": "ab" is not a palindrome, but "a" is a palindrome.

- Partition into "a" and "ba": "a" is a palindrome, "ba" is not.

- Partition into "aba": "aba" is a palindrome.

So, no valid partition exists for "aba".

Another example: "abba".

Possible partitions:

- "a" and "bb" and "a": "a" and "a" are palindromes.

- "ab" and "ba": "ab" is not a palindrome, "ba" is not a palindrome.

Wait, "ab" and "ba" are both not palindromes. So, this is a valid partition.

So, even though "abba" is a palindrome, I can partition it into two parts, each not a palindrome.

Interesting. So, sometimes, even if the whole string is a palindrome, there might still be a valid partition.

From this, I can infer that it's not just about whether the whole string is a palindrome or not, but about the possible partitions.

Let me think about the conditions under which a valid partition exists.

First, if the entire string is not a palindrome, then partitioning it into a single substring satisfies the condition.

Second, if the entire string is a palindrome, I need to see if I can partition it into smaller substrings, none of which are palindromes.

But, as seen in the "aba" example, sometimes even that's not possible.

Wait, in "abba", I could partition it into "ab" and "ba", both not palindromes.

In "aba", any partition either includes a single character (which is a palindrome) or "ab" and "a" or "a" and "ba", both of which include a palindrome.

So, what's the difference?

Let's see another example: "abc".

It's not a palindrome. So, partitioning it into "abc" is valid.

Alternatively, "a", "b", "c" – but "a", "b", "c" are all palindromes, so that's invalid.

Wait, no. Single characters are palindromes, so partitioning "abc" into "a", "b", "c" is invalid because each part is a palindrome.

But "abc" itself is not a palindrome, so partitioning it into one substring is valid.

Another example: "abcba".

This is a palindrome. Possible partitions:

- "a", "bcb", "a": "a" and "a" are palindromes.

- "ab", "cba": "ab" is not a palindrome, "cba" is not a palindrome.

So, this is a valid partition.

Wait, "ab" and "cba" are both not palindromes.

Wait, but "ab" is "ab", which is not a palindrome, and "cba" is "cba", which is not a palindrome.

So, this is a valid partition.

Another example: "abcdcba".

This is a palindrome. Possible partitions:

- "abc", "dc", "ba": "abc" is not a palindrome, "dc" is not a palindrome, "ba" is not a palindrome.

So, this is a valid partition.

Wait, but "dc" is "dc", which is not a palindrome.

Yes, correct.

So, it seems that for some palindromic strings, I can still find partitions where none of the parts are palindromes.

But in the "aba" case, it's not possible.

So, what's the general rule here?

Let me think about this.

I need to find a way to determine whether a given string can be partitioned into substrings that are not palindromes.

One approach could be to check if there exists at least one partition where no substring is a palindrome.

To make this efficient, especially considering the constraints (sum of |s| over all test cases does not exceed 10^6), I need an efficient algorithm.

Let me think about the properties of palindromes.

A palindrome reads the same forwards and backwards.

So, for a string to not be a palindrome, there must be at least one position where the character doesn't match its corresponding character from the end.

For example, in "abba", positions 0 and 3 match, positions 1 and 2 match, so it's a palindrome.

In "ab", position 0 and 1 do not match, so it's not a palindrome.

So, to check if a string is a palindrome, I can compare characters symmetrically from the ends towards the center.

Now, for the partitioning, I need to ensure that none of the substrings in the partition are palindromes.

One way to approach this is:

- If the entire string is not a palindrome, then partition it into a single substring.

- If the entire string is a palindrome, then try to partition it into two substrings, neither of which is a palindrome.

- If that's not possible, then try partitioning into more substrings.

But, in the problem, the output requires printing "YES" if such a partition exists, followed by the number of parts and the parts themselves.

Moreover, the problem guarantees that the sum of |s| over all test cases does not exceed 10^6, and t can be up to 10^4.

So, I need an efficient solution, preferably O(n) per test case, where n is the length of the string.

Let me think about the cases where no such partition exists.

From the second test case, "lllllllll", every possible substring is a palindrome because all characters are the same.

Similarly, for "a", it's a palindrome, and since it's only one character, any partition will include "a", which is a palindrome. So, no valid partition exists.

Another example is "aba". As we saw earlier, any partition either includes single characters or combinations like "ab" and "a", where "ab" is not a palindrome, but "a" is a palindrome. So, no valid partition exists.

Wait, but in "abba", I can partition it into "ab" and "ba", both not palindromes.

So, what's the difference between "aba" and "abba"?

In "aba", any partition that includes more than one character would include at least one palindrome.

Wait, let's see:

- "ab" and "a": "ab" is not a palindrome, "a" is a palindrome.

- "a" and "ba": "a" is a palindrome, "ba" is not a palindrome.

- "aba": "aba" is a palindrome.

So, no valid partition exists.

In "abba":

- "ab" and "ba": both not palindromes.

- "a", "b", "b", "a": all are palindromes.

- "abb" and "a": "abb" is not a palindrome, "a" is a palindrome.

- "a", "bb", "a": "a" and "a" are palindromes, "bb" is a palindrome.

So, the only valid partition is "ab" and "ba".

Therefore, for "abba", a valid partition exists.

So, the key seems to be whether the string is a palindrome and whether it's possible to split it into two or more parts, none of which are palindromes.

But how do I generalize this?

Let me consider the following:

- If the string is not a palindrome, then partitioning it into a single substring suffices.

- If the string is a palindrome, then I need to see if I can split it into two or more substrings, none of which are palindromes.

But, in the case of "aba", it's a palindrome, and any split includes single characters or combinations that include palindromes.

So, for palindromic strings, I need to check if there's a way to split them into non-palindromic substrings.

But how?

Let me think about the structure of palindromic strings.

A palindrome has symmetric structure. If I try to split it into two parts, I need both parts to not be palindromes.

But in "aba", splitting into "ab" and "a" includes "a" which is a palindrome.

Splitting into "a" and "ba" includes "a" which is a palindrome.

Splitting into "aba" is a palindrome.

So, no valid partition.

In "abba", splitting into "ab" and "ba" both not palindromes works.

Similarly, in "abcba", splitting into "abc" and "ba" – "abc" is not a palindrome, "ba" is not a palindrome.

Wait, but "abc" is not a palindrome, and "ba" is not a palindrome.

Wait, "ba" is not a palindrome because "b" doesn't equal "a".

Wait, is "ba" a palindrome? It has two characters, 'b' and 'a', which are different, so it's not a palindrome.

So, that works.

Another example: "a". It's a palindrome, and any partition includes "a", which is a palindrome. So, no valid partition.

"aa". It's a palindrome. Possible partitions:

- "a" and "a": both palindromes.

- "aa": palindrome.

So, no valid partition.

"aba". As we saw, no valid partition.

"abba". Valid partition into "ab" and "ba".

"abcba". Valid partition into "abc" and "ba".

So, it seems that for palindromic strings, if the length is greater than 2 and I can split it into two parts, neither of which is a palindrome, then it's possible.

But in "aa", splitting into "a" and "a" includes palindromes.

In "aba", splitting into "ab" and "a" includes "a", which is a palindrome.

In "abba", splitting into "ab" and "ba" works.

So, perhaps, for palindromic strings, if the string can be split into two non-palindromic substrings, then it's possible.

Otherwise, it's not possible.

So, the general approach could be:

- Check if the entire string is not a palindrome. If not, partition it into a single substring.

- If the entire string is a palindrome, then try to split it into two substrings, and check if both substrings are not palindromes.

- If both substrings are not palindromes, then it's valid.

- If not, then try splitting in different ways.

But, to make it efficient, I need a way to decide how to split the string.

Let me consider splitting the string into two parts: prefix and suffix.

I need to choose a split point such that both prefix and suffix are not palindromes.

So, for a palindromic string s of length n, I can try splitting it into prefix s[0..i] and suffix s[i+1..n-1] for some i from 0 to n-2.

Then, check if neither prefix nor suffix is a palindrome.

If I find such an i, then I can output "YES", with k=2, and the two parts.

But, in "aba", for i=0: prefix="a" (palindrome), suffix="ba" (not palindrome).

For i=1: prefix="ab" (not palindrome), suffix="a" (palindrome).

So, no valid split.

In "abba", for i=1: prefix="abb" (not palindrome), suffix="a" (palindrome).

For i=2: prefix="abb" (not palindrome), suffix="" (empty string, which is not a palindrome, but empty strings are not considered as per problem constraints, since |s| >=1).

Wait, the problem says strings consist of lowercase Latin characters, and |s| >=1.

So, empty strings are not considered.

Wait, in the splitting, I need to ensure that all parts are non-empty substrings.

So, splitting "abba" into "abb" and "a" includes "a", which is a palindrome.

Splitting into "ab" and "ba" both not palindromes.

So, that works.

Wait, but in "aba", splitting into "ab" and "a" includes "a", which is a palindrome.

So, no valid split.

Similarly, in "aa", splitting into "a" and "a" includes "a", which is a palindrome.

So, no valid split.

In "abba", splitting into "ab" and "ba" works.

So, the rule seems to be: for palindromic strings, if I can split it into two non-palindromic substrings, then "YES", else "NO".

But, to make it efficient, I need a way to quickly determine if such a split exists.

Let me think about the properties of palindromic strings.

In a palindromic string, characters are symmetric around the center.

If the string has even length, the first half mirrors the second half.

If it has odd length, there's a central character.

Now, if I try to split the string into two parts, I need both parts to be non-palindromic.

So, for example, in "abba", splitting into "ab" and "ba".

Both "ab" and "ba" are not palindromes.

In "aba", splitting into "ab" and "a":

"ab" is not a palindrome, but "a" is a palindrome.

Splitting into "a" and "ba":

"a" is a palindrome, "ba" is not.

Splitting into "aba":

"aba" is a palindrome.

So, no valid split.

Similarly, in "aa", splitting into "a" and "a":

both are palindromes.

Splitting into "aa":

"aa" is a palindrome.

So, no valid split.

In "abcbba":

This is not a palindrome.

So, partitioning into "abcbba" works.

Wait, "abcbba" is not a palindrome.

Wait, "abcbba" reversed is "abbcbA", which is different, so it's not a palindrome.

Wait, unless it's "abcbba" vs "abcbba" reversed is "abcbba". Wait, no, "abcbba" reversed is "abcbba". So, it is a palindrome.

Wait, no, wait, "abcbba" reversed is "abcbba". So, it is a palindrome.

Wait, but in my earlier thought, I considered it as not a palindrome.

Wait, perhaps I made a mistake.

Wait, "abcbba" is a palindrome because it reads the same forwards and backwards.

So, for "abcbba", I need to find a partition where none of the parts are palindromes.

Possible partitions:

- "abcbba": palindrome.

- "abc" and "bba": "abc" is not a palindrome, "bba" is not a palindrome.

So, this is a valid partition.

Wait, but "abc" is "abc", which is not a palindrome.

"bba" is "bba", which is not a palindrome.

So, this works.

So, even though "abcbba" is a palindrome, I can partition it into "abc" and "bba", both not palindromes.

Another way: "ab" and "cbba": "ab" is not a palindrome, "cbba" is not a palindrome.

So, multiple valid partitions exist.

So, for palindromic strings, if I can split it into two non-palindromic substrings, then it's possible.

Now, the question is, how to determine if such a split exists.

Let me consider that for a palindromic string s, if there exists an index i (0 <= i < n) such that both s[0..i] and s[i+1..n-1] are not palindromes, then "YES", else "NO".

But, as seen in "aba", for i=0: s[0..0]="a" (palindrome), s[1..2]="ba" (not palindrome).

For i=1: s[0..1]="ab" (not palindrome), s[2..2]="a" (palindrome).

For i=2: s[0..2]="aba" (palindrome), s[3..2]=invalid.

So, no valid split.

In "abba", for i=0: s[0..0]="a" (palindrome), s[1..3]="bba" (not palindrome).

For i=1: s[0..1]="ab" (not palindrome), s[2..3]="ba" (not palindrome).

So, this works.

In "aa", for i=0: s[0..0]="a" (palindrome), s[1..1]="a" (palindrome).

For i=1: s[0..1]="aa" (palindrome), s[2..1]=invalid.

So, no valid split.

In "abcbba", for i=2: s[0..2]="abc" (not palindrome), s[3..5]="bba" (not palindrome).

So, this works.

So, the general approach is:

- If the string is not a palindrome, output "YES" with k=1 and the string itself.

- If the string is a palindrome, try to split it into two parts where neither part is a palindrome.

- To do this efficiently, iterate through possible split points and check if both parts are not palindromes.

- If such a split exists, output "YES", k=2, and the two parts.

- If no such split exists, output "NO".

Now, to make this efficient, I need a way to quickly check if a substring is a palindrome.

Given the constraints (sum of |s| <= 10^6), I need an O(n) solution per test case.

Checking if a string is a palindrome normally takes O(n) time, but doing this for every possible split point would be O(n^2) in the worst case, which is too slow for the given constraints.

So, I need a smarter way to check for palindromes.

Wait, perhaps I can precompute the palindromic substrings using some algorithm, like Manacher's algorithm, but that might be too complex.

Let me think differently.

For the palindromic string s, if I can find a split point where neither part is a palindrome, then it's "YES".

Given that s is a palindrome, what makes a substring not a palindrome?

If I can find a split point where at least one character in the prefix doesn't match its corresponding character in the suffix.

Wait, since s is a palindrome, the prefix and suffix are mirrors of each other.

So, for the prefix s[0..i], to not be a palindrome, there must be at least one position j in [0, i//2] where s[j] != s[i - j].

Similarly for the suffix s[i+1..n-1].

But since s is a palindrome, s[j] == s[n-1-j] for all j.

So, perhaps I can find a split point i where s[0..i] is not a palindrome and s[i+1..n-1] is not a palindrome.

Given that s is a palindrome, what would make s[0..i] not a palindrome?

It would be if s[0..i] is not symmetric.

But since s is a palindrome, s[0..i] is symmetric only if i <= (n-1)/2.

Wait, no.

Wait, s being a palindrome means that s[j] == s[n-1-j] for all j from 0 to n-1.

So, for s[0..i] to be a palindrome, it must satisfy s[j] == s[i - j] for j from 0 to i//2.

But since s is a palindrome, s[j] == s[n-1-j], but for s[0..i], we have s[j] == s[i - j].

So, for s[0..i] to be a palindrome, s[j] == s[i - j] for all j from 0 to i//2.

But since s is a palindrome, s[j] == s[n-1-j].

So, if i < n - 1 - i, then s[i] == s[n-1-i], but for s[0..i] to be a palindrome, s[j] == s[i - j].

Wait, this is getting complicated.

Maybe I need a different approach.

Let me consider that for a palindromic string s, if I can find a split point i such that s[0..i] and s[i+1..n-1] are both not palindromes.

Given that s is a palindrome, s[0..i] is a palindrome only if i <= (n-1)/2, and s[i+1..n-1] is a palindrome only if i >= (n-1)/2.

Wait, no.

Wait, for s[0..i] to be a palindrome, it must be symmetric within its own bounds.

Similarly for s[i+1..n-1].

But since s is a palindrome, s[0..i] being a palindrome would require that s[0..i] is symmetric.

Wait, perhaps I can find a split point i where s[0..i] is not equal to the reverse of s[0..i], and s[i+1..n-1] is not equal to the reverse of s[i+1..n-1].

But since s is a palindrome, s[j] == s[n-1-j], but for substrings, it's not necessarily the case.

Wait, maybe I should just try to find a split point where s[0..i] is not equal to its reverse, and s[i+1..n-1] is not equal to its reverse.

Given that s is a palindrome, s[0..i] is equal to s[n-1-i..n-1], but s[0..i] being a palindrome requires s[0..i] equal to its reverse, which is s[i..0].

Wait, s[0..i] equal to s[i..0].

But s is a palindrome, so s[0] == s[n-1], s[1] == s[n-2], and so on.

So, for s[0..i] to be a palindrome, s[0] == s[i], s[1] == s[i-1], etc.

Given that s is a palindrome, s[0] == s[n-1], s[1] == s[n-2], etc.

So, for s[0..i] to be a palindrome, s[0] == s[i], s[1] == s[i-1], etc.

But since s is a palindrome, s[0] == s[n-1], s[1] == s[n-2], etc.

So, if i != n-1-i, then s[0..i] may or may not be a palindrome.

Wait, this seems too convoluted.

Let me try to think differently.

Suppose s is a palindrome.

If s has length 1, it's a palindrome, and any partition includes "a", which is a palindrome, so "NO".

If s has length 2, and s[0] == s[1], then it's a palindrome.

- If s[0] != s[1], it's not a palindrome, so partition into "ab".

So, for palindromic strings of length >= 3, I need to see if I can split them into two non-palindromic substrings.

Let me consider that for palindromic strings of length >= 4, it's always possible to split them into two non-palindromic substrings.

Wait, is that true?

Take "abba":

Split into "ab" and "ba": both not palindromes.

Take "abcba":

Split into "abc" and "ba": both not palindromes.

Take "aaaa":

Split into "aaa" and "a": "aaa" is a palindrome, "a" is a palindrome.

Split into "aa" and "aa": both are palindromes.

Split into "a", "aaa": all are palindromes.

So, for "aaaa", no valid split exists.

Wait, but "aaaa" is a palindrome.

So, my previous thought is not correct.

So, for some palindromic strings of length >=4, a valid split exists, but for others, it doesn't.

So, I need a better way to determine when a valid split exists.

Let me consider that for palindromic strings where all characters are the same, like "aaaa", "bbb", etc., any split will include at least one palindrome.

Because any substring consisting of identical characters is a palindrome.

So, for strings like "aaaa", no valid partition exists.

Similarly, for strings like "abcbba", which have varying characters, a valid split might exist.

Wait, but "abcbba" is a palindrome, and I can split it into "abc" and "bba", both not palindromes.

So, perhaps, for palindromic strings where not all characters are the same, a valid split exists.

Wait, but in "abcbba", all characters are not the same, and I can split it into two non-palindromic substrings.

In "aaaa", all characters are the same, and no valid split exists.

In "aba", which is a palindrome with not all characters the same, but no valid split exists.

Wait, but in "aba", all characters are not the same, yet no valid split exists.

Wait, "aba" has 'a', 'b', 'a' – not all characters are the same.

So, having not all characters the same doesn't guarantee a valid split.

So, that's not the right condition.

Let me think differently.

Suppose s is a palindromic string.

If s has at least one character that is different from the first character, then I can find a split where both parts are not palindromes.

Wait, in "aba", the first character is 'a', and there is a 'b' in the middle.

But, as we've seen, no valid split exists.

In "abba", the first character is 'a', and there is a 'b' and another 'a'.

In "abba", splitting into "ab" and "ba" works.

So, perhaps, if the first character is different from the last character in any part, it's not a palindrome.

Wait, in "abba", s[0] == s[3] == 'a', s[1] == s[2] == 'b'.

So, for the prefix "ab", s[0] != s[1], so it's not a palindrome.

For the suffix "ba", s[3] != s[4] (but s[4] doesn't exist), wait, s[3..3] is "a", which is a palindrome, but in the split "ab" and "ba", "ba" is not a palindrome because 'b' != 'a'.

Wait, but "ba" is "b" and "a", which is not a palindrome because it's not symmetric.

Wait, "ba" is not a palindrome because it's two different characters.

Wait, is "ba" a palindrome? Let's see: "ba" reversed is "ab", which is different from "ba", so it's not a palindrome.

So, in "abba", splitting into "ab" and "ba" works.

In "aba", splitting into "ab" and "a":

"ab" is not a palindrome, but "a" is a palindrome.

Splitting into "a" and "ba":

"a" is a palindrome, "ba" is not a palindrome.

Splitting into "aba":

"aba" is a palindrome.

So, no valid split exists.

What's the difference between "abba" and "aba"?

In "abba", the prefix "ab" is not a palindrome, and the suffix "ba" is not a palindrome.

In "aba", any split includes a single character, which is a palindrome.

So, perhaps, for palindromic strings where the first character is equal to the last character, and the string length is greater than 2, I can try splitting it into two parts where neither part is a palindrome.

But I need a way to determine if such a split is possible.

Let me consider that for palindromic strings where all characters are the same, no valid split exists.

In "aaaa", all characters are 'a', so any substring is a palindrome.

In "abcbba", not all characters are the same, and I can split it into "abc" and "bba", both not palindromes.

In "aba", not all characters are the same, but no valid split exists.

Wait, so having all characters the same is a sufficient condition for "NO", but not a necessary condition.

Because in "aba", not all characters are the same, but it's still "NO".

So, perhaps, for palindromic strings where the string has only one distinct character, output "NO".

Otherwise, try to split it into two parts, neither of which is a palindrome.

But, as seen in "aba", that might not always work.

Wait, perhaps, for palindromic strings with more than one distinct character, if the length is greater than 2, and it's possible to split it into two parts where neither part is a palindrome, then "YES".

Otherwise, "NO".

But, to implement this efficiently, I need a way to check this quickly.

Let me consider that for palindromic strings, if I can find a split point i where s[0..i] and s[i+1..n-1] are both not palindromes, then "YES".

To do this efficiently, I can precompute for each prefix and suffix whether they are palindromes.

But precomputing for each possible i whether s[0..i] and s[i+1..n-1] are palindromes would take O(n^2) time, which is too slow.

I need a smarter way.

Wait, perhaps I can use the fact that s is a palindrome.

If s is a palindrome, then s[0..i] is a palindrome if and only if s[n-1-i..n-1] is a palindrome.

Wait, no.

Wait, since s is a palindrome, s[0..i] is a palindrome only if s[0..i] is equal to s[i..0], which, given s is a palindrome, is equal to s[n-1-i..n-1].

Wait, this is getting too complicated.

Let me try to find a different approach.

Suppose s is a palindrome.

If I can find a split point i such that s[0..i] is not a palindrome and s[i+1..n-1] is not a palindrome, then "YES".

Given that s is a palindrome, s[0..i] is a palindrome only if i <= (n-1)/2.

Wait, no.

Wait, s being a palindrome means that s[j] == s[n-1-j] for all j.

For s[0..i] to be a palindrome, s[j] == s[i - j] for all j.

Given that s[j] == s[n-1-j], for s[0..i] to be a palindrome, s[i - j] == s[j] == s[n-1-j].

So, s[i - j] == s[n-1 - j].

This implies that s[i] == s[n-1].

But this seems too vague.

Maybe I should consider specific cases.

Let me consider that for palindromic strings, if the string has at least one substring that is not a palindrome, then I can split the string accordingly.

Wait, but in "aaaa", all substrings are palindromes, so no valid split.

In "abcbba", some substrings are not palindromes, so I can split into those.

But, to make it efficient, perhaps I can check if the string has at least one position where s[j] != s[n-1-j], but since s is a palindrome, s[j] == s[n-1-j] for all j.

Wait, no, if s is a palindrome, s[j] == s[n-1-j] for all j.

So, in that case, s[0] == s[n-1], s[1] == s[n-2], and so on.

So, for s[0..i], to not be a palindrome, there must be some j in [0, i] where s[j] != s[i - j].

But since s[j] == s[n-1-j], and s[i - j] == s[j], only if s[j] == s[i - j], which is true if s is a palindrome.

Wait, I'm getting stuck here.

Let me try to think about the frequency of characters.

If the string is a palindrome and has more than one distinct character, and its length is greater than 2, maybe I can split it into two parts where neither part is a palindrome.

But as seen in "aba", that's not always possible.

Wait, perhaps, if the string is a palindrome and has a center that's different from the ends, I can split it accordingly.

Wait, in "abcbba", it's a palindrome with center 'c', which is different from the ends.

But in "aba", the center 'b' is different from the ends 'a'.

But in "abcbba", I can split into "abc" and "bba", both not palindromes.

In "aba", splitting into "ab" and "a" includes "a", which is a palindrome.

Wait, perhaps, if the string is a palindrome and has an odd length, and the center character is different from the first character, then I can split it into two parts, each with the center character included in one part.

But I'm not sure.

This seems too vague.

Let me consider that for palindromic strings where all characters are the same, no valid split exists.

For palindromic strings where not all characters are the same, try to split it into two parts where neither part is a palindrome.

To implement this efficiently, perhaps I can do the following:

- If the string is not a palindrome, output "YES" with k=1 and the string itself.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, try to find a split point i where s[0..i] and s[i+1..n-1] are both not palindromes.

- To check if s[0..i] is not a palindrome, I can check if s[0] != s[i], since s is a palindrome, s[0] == s[n-1], s[1] == s[n-2], etc.

- So, for s[0..i], if s[0] != s[i], then it's not a palindrome.

- Similarly, for s[i+1..n-1], if s[i+1] != s[n-1], then it's not a palindrome.

- But since s is a palindrome, s[i+1] == s[n-2 - i], etc.

Wait, perhaps I can simplify this.

Let me consider that for s[0..i] to not be a palindrome, s[0] != s[i].

Similarly, for s[i+1..n-1] to not be a palindrome, s[i+1] != s[n-1 - (i+1)] = s[n-2 - i].

But since s is a palindrome, s[n-2 - i] == s[i+1].

Wait, this seems too tangled.

Let me try to think about it differently.

Suppose s is a palindrome.

If s has any substring that is not a palindrome, then I can try to split the string at that point.

But, for palindromic strings, every substring is a palindrome only if all characters are the same.

Wait, is that true?

Take "aaaa": all substrings are palindromes.

"abba": substrings are "a", "b", "b", "a", "ab", "bb", "ba", "abb", "bba", "abbb", "bb", "bba", etc.

Wait, "ab" is not a palindrome, "ba" is not a palindrome.

So, in "abba", I can find substrings that are not palindromes.

Similarly, in "aba", substrings are "a", "b", "a", "ab", "ba", "aba".

Here, "ab" and "ba" are not palindromes.

But, when trying to split "aba" into "ab" and "a", "a" is a palindrome.

So, even if there are substrings that are not palindromes, the partition may still include palindromes.

So, that doesn't directly help.

Wait, perhaps, for palindromic strings, if the string has length >=4 and not all characters are the same, then a valid split exists.

But, in "abcbba", which is length 6, I can split it into "abc" and "bba", both not palindromes.

In "aba", length 3, cannot split into two parts where both are not palindromes.

In "abba", length 4, can split into "ab" and "ba", both not palindromes.

In "abcba", length 5, can split into "abc" and "ba", both not palindromes.

In "aa", length 2, cannot split into two parts.

Wait, "aa" is a palindrome, and splitting into "a" and "a" includes palindromes.

So, perhaps, for palindromic strings with length >=4 and not all characters the same, a valid split exists.

But in "abcbba", which is length 6, it works.

In "abcba", length 5, it works.

In "abba", length 4, it works.

In "aba", length 3, it doesn't work.

In "aa", length 2, it doesn't work.

In "a", length 1, it doesn't work.

So, perhaps, for palindromic strings with length >=4 and not all characters the same, a valid split exists.

For palindromic strings with length <=3, it depends.

Wait, in "abcbba", length 6, works.

In "abcba", length 5, works.

In "abba", length 4, works.

In "aba", length 3, doesn't work.

In "aa", length 2, doesn't work.

In "a", length 1, doesn't work.

So, perhaps, for palindromic strings with length >=4 and not all characters the same, a valid split exists.

For palindromic strings with length <4 or all characters the same, no valid split exists.

But, in "aaaa", length 4, all characters the same, no valid split.

In "abcbba", length 6, not all characters the same, valid split exists.

In "abcba", length 5, not all characters the same, valid split exists.

In "abba", length 4, not all characters the same, valid split exists.

In "aba", length 3, not all characters the same, no valid split.

In "aa", length 2, all characters the same, no valid split.

In "a", length 1, no valid split.

So, perhaps, for palindromic strings:

- If the string has all characters the same and length >=1, output "NO".

- Else, if the string has different characters and length >=4, output "YES" with k=2 and split into two parts, each not a palindrome.

But, in "aba", which has different characters and length=3, no valid split exists.

So, perhaps, for palindromic strings with length >=4 and not all characters the same, output "YES", else "NO".

But in "aba", length=3, no valid split.

In "abba", length=4, valid split.

In "abcba", length=5, valid split.

In "abcbba", length=6, valid split.

In "aaaa", length=4, no valid split.

In "aa", length=2, no valid split.

In "a", length=1, no valid split.

So, this seems to hold.

Therefore, the approach can be:

- If the string is not a palindrome, output "YES" with k=1 and the string itself.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, if the length >=4, output "YES" with k=2 and split into two parts, each not a palindrome.

- Else, output "NO".

Now, I need to ensure that when splitting into two parts, both parts are not palindromes.

Given that the string is a palindrome and length >=4, and not all characters are the same, I can split it into two parts of lengths 2 and (n-2).

Since n >=4, both parts will have length >=2.

For parts of length >=2, to not be a palindrome, I need to ensure that s[0] != s[i], where i is the end of the prefix.

Wait, for a substring of length >=2, it's not a palindrome if s[j] != s[i - j] for some j.

But, since s is a palindrome, s[j] == s[n-1-j].

So, for the prefix s[0..i], to not be a palindrome, s[0] != s[i].

Similarly, for the suffix s[i+1..n-1], to not be a palindrome, s[i+1] != s[n-1].

But since s is a palindrome, s[0] == s[n-1], s[1] == s[n-2