Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this n x n matrix that's initially filled with zeros. Nene can perform two types of operations on this matrix. Each operation allows her to set an entire row or column to a permutation of numbers from 1 to n. The goal is to maximize the sum of all the elements in the matrix using no more than 2n operations.

First, I need to understand what these operations do. A type 1 operation lets me choose a row and set its values to any permutation of 1 through n. Similarly, a type 2 operation lets me choose a column and set its values to any permutation of 1 through n.

Since the matrix is initially all zeros, every operation I perform will set an entire row or column to some permutation. If I set a row and then set a column that intersects with that row, the value at their intersection will be overwritten by the column operation.

So, I need to think about how to coordinate these operations to maximize the sum. One straightforward approach is to decide which rows and columns to operate on and ensure that their operations don't conflict in a way that reduces the total sum.

Let me consider the sum contributed by each cell in the matrix. If a cell is set by a row operation and not overwritten by a column operation, its value will be from the row operation. Similarly, if it's set by a column operation and not overwritten by a row operation, its value will be from the column operation. If both operations are performed on a cell, the column operation overwrites the row operation.

Given that, perhaps I should perform row operations for some rows and column operations for some columns, making sure that the operations don't overlap in a way that wastes higher values.

Wait, but the problem allows up to 2n operations, which is more than enough to set all rows and columns if needed. However, I need to maximize the sum without minimizing the number of operations, but still within the limit.

Let me think about the maximum possible sum. If I could set every cell to n, the sum would be n * n * n = n^3. But is that possible?

Well, if I set all rows to [n, n-1, n-2, ..., 1], and then set all columns to [n, n-1, n-2, ..., 1], the cells where rows and columns intersect would be set by the column operations, so effectively, the matrix would be filled with the column permutations.

Wait, no. Let's think carefully. If I set a row i to a permutation p, and then set a column j to a permutation q, the value at a[i][j] will be q[j], because the column operation overwrites the row operation.

So, if I set all columns to [n, n-1, ..., 1], then every cell a[i][j] will be set to n - j + 1, assuming j is 1-indexed. The sum would then be n * (n + 1)/2 * n, which is n^2 * (n + 1)/2.

Similarly, if I set all rows to [n, n-1, ..., 1], the sum would be the same.

But perhaps I can do better by combining row and column operations.

Let me consider that each operation, whether row or column, sets an entire row or column to a permutation of 1 to n. The key is to maximize the sum, so I should aim to have as many high values as possible in the matrix.

Suppose I perform k row operations and m column operations, with k + m <= 2n.

I need to find the optimal k and m such that the sum is maximized.

Let me think about the effect of row and column operations.

If I perform a row operation on row i, setting it to a permutation, and then perform a column operation on column j, setting it to another permutation, the cell a[i][j] will be set to the value from the column operation.

So, the row operations that are not overwritten by column operations will have their values persist, while the cells in columns that are operated on will be set by the column operations.

Therefore, the sum will be the sum of the row operations that are not overwritten plus the sum of the column operations that are performed.

Wait, more precisely, the sum will be the sum of the row operations for the rows that are not overwritten by column operations, plus the sum of the column operations for the columns that are operated on.

But actually, it's a bit more involved because rows and columns can overlap.

Let me try to think differently.

Suppose I perform operations only on rows. If I set k rows to permutations, the sum would be k * (n * (n + 1)/2). Similarly, if I set m columns to permutations, the sum would be m * (n * (n + 1)/2).

But because of overlaps, if both a row and a column are set, the cell at their intersection is set by the column operation.

So, the total sum would be the sum of the row operations for the rows not overwritten by column operations, plus the sum of the column operations for the columns that are operated on.

Wait, perhaps inclusion-exclusion could help here.

If I set k rows and m columns, the sum would be k * (n * (n + 1)/2) + m * (n * (n + 1)/2) - (number of cells where row and column operations overlap) * (value set by column operation).

But since column operations overwrite row operations, the overlap cells are set by the column operations.

So, the sum is sum of row operations for rows not overwritten by any column operation, plus sum of column operations for columns that are operated on.

Wait, perhaps it's better to think in terms of which cells are set by row operations and which by column operations.

Specifically, cells that are in rows operated on but not in columns operated on are set by row operations. Cells that are in columns operated on are set by column operations, regardless of row operations.

So, if I perform operations on k rows and m columns, the sum is:

sum_row = k * (n * (n + 1)/2)

sum_col = m * (n * (n + 1)/2)

But since the cells where columns are operated on are set by column operations, I need to subtract the sum of those cells that are in rows operated on but now overwritten by column operations.

Wait, maybe it's better to calculate the sum as:

sum = (sum of row operations for rows not overwritten by column operations) + (sum of column operations for columns operated on)

Where the sum of row operations for rows not overwritten by column operations is (k - overlap) * (n * (n + 1)/2), and the sum of column operations is m * (n * (n + 1)/2).

But this seems messy. Maybe there's a smarter way to approach this.

Let me consider that each operation, whether row or column, can set n cells to a permutation of 1 to n, summing to n * (n + 1)/2.

Given that, and with up to 2n operations, the maximum sum would be up to 2n * n * (n + 1)/2 = n^2 * (n + 1).

But is that achievable?

Wait, but in reality, operations can overlap, so the sum might be less than that if there's overwriting.

So, perhaps I need to maximize the sum by carefully choosing which rows and columns to operate on.

An alternative approach is to think in terms of filling the matrix row-wise or column-wise.

Suppose I perform row operations for all rows, setting each row to a permutation of 1 to n. The sum would be n * (n * (n + 1)/2) = n^2 * (n + 1)/2.

Similarly, if I perform column operations for all columns, the sum would be the same.

But perhaps I can do better by combining both.

Wait, let's think about the maximum possible sum.

If I could set every cell to n, the sum would be n^3.

But is that possible within 2n operations?

Probably not, because operations overwrite each other.

So, what's the best I can do?

Let me consider small n, like n=1 and n=2, to see a pattern.

For n=1:

- Matrix is 1x1.

- I can perform either a type 1 or type 2 operation.

- In either case, I can set the single cell to 1.

- So, sum is 1.

- The example given matches this.

For n=2:

- Matrix is 2x2.

- I can perform up to 4 operations.

- The example provided gives a sum of 7 with 3 operations.

Let me see how that works.

- Operation 1: type 1, row 1, permutation [1,2]

- Operation 2: type 1, row 2, permutation [1,2]

- Operation 3: type 2, column 1, permutation [1,2]

After operation 1: a = [[1,2],[0,0]]

After operation 2: a = [[1,2],[1,2]]

After operation 3: a = [[1,2],[2,2]]

Sum = 1+2+2+2 = 7

Indeed, that matches the example.

Is there a way to get a higher sum with up to 4 operations?

Suppose I do:

- Operation 1: type 1, row 1, [2,1]

- Operation 2: type 1, row 2, [2,1]

- Operation 3: type 2, column 1, [2,1]

- Operation 4: type 2, column 2, [2,1]

After operation 1: a = [[2,1],[0,0]]

After operation 2: a = [[2,1],[2,1]]

After operation 3: a = [[2,1],[1,1]]

After operation 4: a = [[2,1],[1,1]]

Sum is 2+1+1+1=5, which is less than 7.

Alternatively:

- Operation 1: type 1, row 1, [2,1]

- Operation 2: type 2, column 1, [2,1]

- Operation 3: type 2, column 2, [2,1]

After operation 1: a = [[2,1],[0,0]]

After operation 2: a = [[2,1],[1,0]]

After operation 3: a = [[2,1],[1,1]]

Sum is 2+1+1+1=5, which is less than 7.

Another attempt:

- Operation 1: type 1, row 1, [2,1]

- Operation 2: type 1, row 2, [2,1]

- Operation 3: type 2, column 1, [2,2]

Sum after operation 1: [[2,1],[0,0]]

After operation 2: [[2,1],[2,1]]

After operation 3: [[2,1],[2,1]]

Sum is 2+1+2+1=6, still less than 7.

Another attempt:

- Operation 1: type 2, column 1, [2,1]

- Operation 2: type 2, column 2, [2,1]

- Operation 3: type 1, row 1, [2,2]

Sum after operation 1: [[2,0],[1,0]]

After operation 2: [[2,2],[1,1]]

After operation 3: [[2,2],[1,1]]

Sum is 2+2+1+1=6, still less than 7.

Seems like 7 is the best possible.

So, for n=2, the maximum sum is 7.

Let me try n=3.

Suppose n=3.

Maximum sum seems to be higher, but I need to figure out the pattern.

If I follow the approach from n=2, perhaps I can generalize it.

Wait, maybe there's a formula for the maximum sum.

Looking back at n=2, sum is 7.

For n=1, sum is 1.

For n=2, sum is 7.

Wait, 7 is 4*3/2 + 3*2/2 = 6 +1, wait, maybe not.

Alternatively, perhaps it's n^2 * n / 2 + something.

Wait, perhaps I need to find a formula for the sum.

Let me think differently.

Suppose I perform k row operations and m column operations, with k + m <= 2n.

Each row operation sets a row to sum n*(n+1)/2.

Each column operation sets a column to sum n*(n+1)/2.

But where a column operation is performed, it overwrites the row operations for that column.

So, the total sum would be sum of row operations for rows not overwritten by any column operation, plus sum of column operations for columns where operations are performed.

Wait, more precisely:

- For rows not overwritten by any column operation, their sum is n*(n+1)/2 each.

- For rows that are overwritten by at least one column operation, their sum is the sum of the column operations for the columns that overwrite them.

Wait, perhaps it's better to calculate the sum as:

sum = (number of rows not overwritten by any column operation) * (n*(n+1)/2) + sum over columns of n*(n+1)/2.

But that's not accurate because the sum over columns includes the cells that are in rows not overwritten by any column operation.

This is getting complicated.

Maybe I need to accept that achieving sum s with operations m is tricky, and look for a different approach.

Looking back at the example for n=2, sum=7 with 3 operations.

Let me see what's happening there.

- Operation 1: type 1, row 1, [1,2] → a=[ [1,2], [0,0] ]

- Operation 2: type 1, row 2, [1,2] → a=[ [1,2], [1,2] ]

- Operation 3: type 2, column 1, [1,2] → a=[ [1,2], [2,2] ]

Sum=1+2+2+2=7.

Alternatively, if in operation 3, I set column 1 to [2,1], then a=[ [2,2], [1,2] ], sum=2+2+1+2=7.

Same sum.

Seems like the maximum sum is 7 for n=2.

Is there a pattern here?

Let me think about the sum.

For n=1, sum=1.

For n=2, sum=7.

For n=3, what would be the sum?

If I follow the same logic, perhaps sum = 3*3*3/2 = 27/2 = 13.5, but sums are integers, so probably 13 or 14.

But I need to see what's achievable.

Let me try n=3.

- Operation 1: type 1, row 1, [1,2,3]

- Operation 2: type 1, row 2, [1,2,3]

- Operation 3: type 1, row 3, [1,2,3]

- Operation 4: type 2, column 1, [2,2,2]

- Operation 5: type 2, column 2, [2,2,2]

Sum after operation 1: [[1,2,3],[0,0,0],[0,0,0]]

After operation 2: [[1,2,3],[1,2,3],[0,0,0]]

After operation 3: [[1,2,3],[1,2,3],[1,2,3]]

After operation 4: [[2,2,3],[2,2,3],[2,2,3]]

After operation 5: [[2,2,3],[2,2,3],[2,2,3]]

Sum=2+2+3+2+2+3+2+2+3=21.

Is that the maximum?

Alternatively, if I do:

- Operation 1: type 1, row 1, [3,2,1]

- Operation 2: type 1, row 2, [3,2,1]

- Operation 3: type 1, row 3, [3,2,1]

- Operation 4: type 2, column 1, [3,3,3]

- Operation 5: type 2, column 2, [3,3,3]

Sum after operation 1: [[3,2,1],[0,0,0],[0,0,0]]

After operation 2: [[3,2,1],[3,2,1],[0,0,0]]

After operation 3: [[3,2,1],[3,2,1],[3,2,1]]

After operation 4: [[3,2,1],[3,2,1],[3,2,1]]

After operation 5: [[3,3,1],[3,3,1],[3,3,1]]

Sum=3+3+1+3+3+1+3+3+1=20.

Which is less than 21.

Another attempt:

- Operation 1: type 2, column 1, [3,3,3]

- Operation 2: type 2, column 2, [3,3,3]

- Operation 3: type 2, column 3, [3,3,3]

- Operation 4: type 1, row 1, [3,3,3]

Sum after operation 1: [[3,0,0],[3,0,0],[3,0,0]]

After operation 2: [[3,3,0],[3,3,0],[3,3,0]]

After operation 3: [[3,3,3],[3,3,3],[3,3,3]]

After operation 4: [[3,3,3],[3,3,3],[3,3,3]]

Sum=3*9=27.

Wait, but that's 4 operations, and 2n=6, so that's acceptable.

But in the problem constraints, it's mentioned that it's possible to achieve the maximum sum in no more than 2n operations.

In this case, n=3, 2n=6, and I used 4 operations to get sum=27.

Is that the maximum possible?

Wait, but in n=2, sum=7, which is less than n^3=8, but in n=3, sum=27 equals n^3.

Is there a pattern here?

Wait, n=1: sum=1=1^3

n=2: sum=7 < 8=2^3

n=3: sum=27=3^3

Wait, but for n=2, 7 is less than 8.

Wait, but in n=3, is 27 achievable?

Wait, in n=3, if I set all columns to [3,3,3], then the matrix becomes all 3's, sum=27.

Similarly, in n=2, if I set all columns to [2,2], sum=8, but in the example, it's 7.

Wait, perhaps in n=2, sum=8 is achievable.

Let me check.

- Operation 1: type 2, column 1, [2,2]

- Operation 2: type 2, column 2, [2,2]

After operation 1: [[2,0],[2,0]]

After operation 2: [[2,2],[2,2]]

Sum=2+2+2+2=8.

Wait, but in the example, they used 3 operations to get 7.

But with only 2 operations, I can get 8.

Wait, perhaps I misread the example.

Wait, in the example, they used 3 operations to get 7.

But with 2 operations, I can get 8.

Wait, perhaps there's a mistake in the example.

Wait, in the problem statement, for n=2, they provided a solution with sum=7 using 3 operations.

But it seems I can achieve sum=8 with only 2 operations.

Is that possible?

Wait, perhaps I'm missing something.

Let me check again.

In the problem statement, for n=2, the output is:

7 3

1 1 1 2

1 2 1 2

2 1 1 2

Which corresponds to:

- Operation 1: type 1, row 1, [1,2]

- Operation 2: type 1, row 2, [1,2]

- Operation 3: type 2, column 1, [1,2]

After operation 1: [[1,2],[0,0]]

After operation 2: [[1,2],[1,2]]

After operation 3: [[1,2],[2,2]]

Sum=1+2+2+2=7

But if I perform only 2 operations:

- Operation 1: type 2, column 1, [2,2]

- Operation 2: type 2, column 2, [2,2]

After operation 1: [[2,0],[2,0]]

After operation 2: [[2,2],[2,2]]

Sum=2+2+2+2=8

So, with 2 operations, I can achieve sum=8, which is better than the example's 7 with 3 operations.

Is there a reason why the example used 3 operations to get 7 when 2 operations can achieve 8?

Wait, perhaps it's a mistake in the problem statement.

Alternatively, maybe there's a constraint I'm missing.

Wait, looking back at the problem statement:

"It can be shown that the maximum possible sum can always be obtained in no more than 2n operations."

But in the example for n=2, sum=7 is achieved with 3 operations, but as shown, sum=8 can be achieved with 2 operations.

Wait, perhaps the example is just illustrative, and not the optimal solution.

I think there might be a mistake in the problem statement's example.

Moving on, I need to find a general approach to maximize the sum.

From the n=1 and n=2 cases, it seems that setting all columns to [n,n,...,n] achieves the maximum sum of n^3 using n operations.

But in the n=2 example, they achieved sum=7 with 3 operations, but as shown, sum=8 can be achieved with 2 operations.

So perhaps the formula is sum = n^3, achieved with n operations.

But for n=1, sum=1^3=1 with 1 operation.

For n=2, sum=8 with 2 operations.

For n=3, sum=27 with 3 operations.

Is there a general formula here?

Wait, but in the n=2 example, they showed sum=7 with 3 operations, but as I showed, sum=8 can be achieved with 2 operations.

So perhaps their sum is not the maximum possible.

Wait, maybe I'm missing something.

Let me think differently.

Suppose I perform n column operations, setting each column to [n,n,...,n]. Then the matrix becomes all n's, sum=n^3, using n operations.

Similarly, I could perform n row operations, setting each row to [n,n,...,n], achieving the same sum.

So, sum=n^3 can be achieved with n operations.

But in the n=2 example, they showed sum=7 with 3 operations, but sum=8 can be achieved with 2 operations.

So perhaps their sum is not the maximum possible, or maybe I'm misunderstanding something.

Wait, perhaps there's a misprint in the problem statement's example.

Anyway, moving forward, I'll assume that the maximum sum is n^3, achievable with n operations.

But let's verify for n=2.

With n=2, sum=8, achievable with 2 operations.

For n=3, sum=27 with 3 operations.

For n=1, sum=1 with 1 operation.

So, in general, sum=n^3 with n operations.

But in the problem, they allow up to 2n operations, which is more than enough.

So, perhaps I can achieve sum=n^3 with n operations, and use the remaining operations to try to increase the sum further, but it's unlikely since the matrix is already filled with n's.

Wait, but in reality, sum=n^3 is achievable with n operations, and cannot be exceeded.

Wait, but in n=2, sum=8 is achievable with 2 operations, which is n^3.

In n=3, sum=27 with 3 operations.

But in the n=2 example, they showed sum=7 with 3 operations, which is less than 8.

So perhaps their solution is not optimal.

Anyway, I'll proceed with the assumption that the maximum sum is n^3, achievable with n operations.

Therefore, in the program, for each test case, I can output sum=n^3 and m=n, and perform n column operations, each setting a column to [n,n,...,n].

But let's look at the provided program to see what it's doing.

Looking at the program:

def func():

t = int(input())

for _ in range(t):

n = int(input())

(sum, r) = (0, 0)

for i in range(1, n + 1):

if n * (n + 1) // 2 > i * n:

r = i

sum += n * (n + 1) // 2

else:

sum += i * n

print(sum, n + r)

for j in range(1, n + r + 1):

if j <= n:

print(1, j, end=' ')

print(*range(1, n + 1))

else:

print(2, j % n, end=' ')

print(*range(1, n + 1))

So, it's calculating sum and r based on a loop from 1 to n.

For each i from 1 to n:

if n*(n+1)/2 > i*n:

set r = i

sum += n*(n+1)/2

else:

sum += i*n

Then print sum and m = n + r

Then perform m operations:

for j from 1 to n:

print type 1, row j, permutation 1 to n

for j from n+1 to n+r:

print type 2, column j % n, permutation 1 to n

Wait, but j % n can be 0, but in the problem, columns are 1-indexed from 1 to n.

Wait, j % n when j = n+1 would be (n+1) % n = 1

j = n+2 would be 2, and so on.

So, it's cycling through the columns.

But in the operations, it's setting rows 1 to n to [1,2,...,n], and then columns 1 to r to [1,2,...,n].

Wait, but in the earlier analysis, setting rows to [n,n-1,...,1] or [1,2,...,n] doesn't matter for the sum, since it's the same.

Wait, but n*(n+1)/2 is the sum of a row set to [1,2,...,n].

But to maximize the sum, we should set rows to [n,n-1,...,1], so that each row sums to n*(n+1)/2, but the highest values are in each row.

Wait, but in terms of sum, [1,2,...,n] and [n,n-1,...,1] both sum to n*(n+1)/2.

So, it doesn't matter for the sum which permutation is used, as long as it's a permutation of 1 to n.

But in terms of achieving higher sums in the matrix, perhaps certain permutations are better when combined with column operations.

Wait, but in the program, it's using [1,2,...,n] for both row and column operations.

Given that, let's see what sum it's calculating.

In the loop:

for i in range(1, n + 1):

if n * (n + 1) // 2 > i * n:

r = i

sum += n * (n + 1) // 2

else:

sum += i * n

Wait, n*(n+1)/2 is the sum of a row set to [1,2,...,n], which is n*(n+1)/2.

i*n is the sum if the row is set to [i,i,...,i], but since it's a permutation, it's [1,2,...,n], sum is always n*(n+1)/2.

Wait, perhaps I'm misunderstanding the intention here.

Wait, perhaps the idea is to set some rows to [1,2,...,n] and some columns to [1,2,...,n], and calculate the sum accordingly.

But in reality, since each row operation sets a row to [1,2,...,n], sum per row operation is n*(n+1)/2.

Similarly for column operations.

But due to overwriting, the total sum isn't just m * n*(n+1)/2.

Wait, perhaps the program is trying to compute the sum based on how many row and column operations are performed.

Let me take an example with n=2.

For n=2, n*(n+1)/2 = 3, i*n for i=1 is 2, i=2 is 4.

So, for i from 1 to 2:

i=1: 3 > 2 → sum +=3, r=1

i=2: 3 > 4 → no, sum +=4, r=1 (from previous)

Total sum=3+4=7, m=2+1=3

Which matches the example's sum=7 with 3 operations.

But as I showed earlier, sum=8 can be achieved with 2 operations.

So, perhaps this sum calculation is not optimal.

Wait, perhaps the sum calculation is based on a specific strategy.

Let me see.

The sum is calculated by iterating i from 1 to n, and for each i, if n*(n+1)/2 > i*n, sum += n*(n+1)/2, else sum += i*n, and set r=i in the first case.

For n=2:

i=1: 3 > 2 → sum +=3, r=1

i=2: 3 > 4 → false, sum +=4, r still 1

Total sum=7, m=2+1=3

Operations:

- Operation 1: type 1, row 1, [1,2]

- Operation 2: type 1, row 2, [1,2]

- Operation 3: type 2, column 1, [1,2]

Which results in matrix [[1,2],[2,2]], sum=7.

But as I showed earlier, setting columns 1 and 2 to [2,2] achieves sum=8.

So, perhaps this sum calculation is not optimal.

Wait, maybe the sum calculation is intended to compute the sum when performing row operations for rows 1 to n and column operations for columns 1 to r.

But in the n=2 case, with r=1, it's performing 3 operations: two row operations and one column operation, resulting in sum=7.

But with two column operations, sum=8.

So, perhaps the program's sum calculation is not achieving the maximum possible sum.

Wait, perhaps there's a different strategy to maximize the sum.

Let me consider that when performing column operations, the column operations overwrite the row operations for the cells in those columns.

So, if I perform row operations for all rows, setting them to [n,n-1,...,1], and then perform column operations for some columns, setting them to [n,n-1,...,1], the cells in the columns operated on will be set by the column operations.

Therefore, the sum would be:

sum = (n - m) * row_sum + m * column_sum

Where m is the number of column operations, row_sum = n*(n+1)/2, column_sum = n*(n+1)/2.

But since row_sum and column_sum are the same, it's unclear how this helps.

Wait, but in terms of maximizing the sum, perhaps I need to set columns to [n,n-1,...,1] and rows to [n,n-1,...,1], but coordinate them so that the overwrites are optimal.

Wait, maybe I should think in terms of which operations to perform first.

If I perform all row operations first, setting each row to [n,n-1,...,1], then perform some column operations, setting columns to [n,n-1,...,1], overwriting the corresponding cells.

But since row_sum and column_sum are equal, it's not clear how to maximize beyond that.

Wait, perhaps I need to consider that different permutations can lead to different sums, but the problem specifies that the permutation is of 1 to n, so the sum per row or column operation is always n*(n+1)/2.

Wait, but in terms of cell values, different permutations place different values in different cells, which could affect the overall sum when operations overlap.

Wait, perhaps I need to choose specific permutations to maximize the sum.

For example, for row operations, set rows to [n,n-1,...,1], and for column operations, set columns to [n,n-1,...,1], so that the overwrites place higher values in the matrix.

But given that, perhaps the sum remains the same regardless of the permutation chosen, as long as it's a permutation of 1 to n.

Wait, but in reality, the sum per operation is fixed, so the total sum depends on how many operations are performed and which cells they affect.

Given that, perhaps the maximum sum is achieved by performing column operations for all columns, setting each column to [n,n,...,n], achieving sum=n^3 using n operations.

Wait, but in reality, since permutations must contain all numbers from 1 to n, I cannot set a column to [n,n,...,n], because that's not a permutation.

Wait, actually, [n,n,...,n] is not a permutation. A permutation must contain each number from 1 to n exactly once.

So, I cannot set a column or row to [n,n,...,n]. That's invalid.

Wait, but in my earlier thoughts, I assumed that permutations could have multiple n's, but that's incorrect.

A permutation must contain each number from 1 to n exactly once.

So, setting a row or column to a permutation means that each row or column will have values from 1 to n, summing to n*(n+1)/2.

Therefore, the sum per operation is fixed at n*(n+1)/2.

Given that, performing operations that set rows and columns will cover the matrix, with column operations overwriting row operations in the cells where they intersect.

Therefore, the total sum would be:

sum = (number of rows not overwritten by any column operation) * (n*(n+1)/2) + (number of column operations) * (n*(n+1)/2)

But this seems to suggest that sum is proportional to the number of row operations not overwritten plus the number of column operations.

Given that, to maximize the sum, I should maximize the number of column operations, since each column operation covers an entire column and overwrites any row operations in that column.

Therefore, performing column operations for all n columns would cover the entire matrix, sum = n * (n*(n+1)/2).

Similarly, performing row operations for all n rows would sum to n * (n*(n+1)/2).

But in reality, n * (n*(n+1)/2) = n^2 * (n+1)/2.

But in the n=2 example, this would be 2 * (2*3/2) = 6, but the example shows sum=7 with 3 operations.

Wait, that doesn't match.

Wait, perhaps I need to consider that performing column operations for m columns and row operations for k rows, the sum is:

sum = k * (n*(n+1)/2) + m * (n*(n+1)/2) - (k * m * (n+1)/2)

But that seems incorrect.

Wait, perhaps inclusion-exclusion doesn't apply directly here.

Let me think differently.

Each cell in the matrix can be set by either a row operation or a column operation, with column operations overwriting row operations.

Therefore, the sum is:

sum = sum over all cells of max(value set by row operation, value set by column operation)

But since row and column operations set permutations, it's not straightforward to calculate.

Wait, perhaps I should consider that each cell is set by the last operation that affects it, which would be the column operation if a column operation is performed on that column, otherwise the row operation.

Therefore, the sum is:

sum = sum over all rows not overwritten by any column operation of (n*(n+1)/2) + sum over all columns with column operations of (n*(n+1)/2)

But this double-counts the cells where rows not overwritten and columns with operations intersect.

Wait, no, because the column operations overwrite the row operations.

So, for rows not overwritten by any column operation, their sum is n*(n+1)/2.

For rows that have at least one column operation on their columns, their sum is only the sum of the column operations on those columns.

Wait, this is getting too convoluted.

Let me consider that the sum is:

sum = (n - m) * (n*(n+1)/2) + m * (n*(n+1)/2) = n * (n*(n+1)/2)

Where m is the number of column operations.

Wait, that suggests that sum is always n * (n*(n+1)/2), regardless of m.

But in reality, in the n=2 example, with m=2 column operations, sum=8, which is 2*(2*3/2)=6, but actually 8>6.

So, that formula is incorrect.

Wait, perhaps I need to think differently.

Let me consider that performing m column operations allows me to set m*n cells to n*(n+1)/2 per column, but with potential overlaps.

Wait, perhaps it's better to accept that the sum is maximized by performing column operations for all columns, achieving sum = n*(n+1)/2 * n = n^2*(n+1)/2.

But in n=2, that would be 4*3/2 *2=12/2*2=6, but earlier I showed that sum=8 is achievable.

Wait, but n=2, n^3=8, which is greater than n^2*(n+1)/2=6.

So, perhaps that formula is not tight.

Wait, perhaps the maximum sum is n^3, achievable by setting all cells to n, but since permutations must contain numbers from 1 to n, it's impossible to set all cells to n.

Wait, but in reality, you cannot set all cells to n because permutations must include all numbers from 1 to n exactly once per row or column operation.

Therefore, the sum is constrained by the permutations.

Given that, perhaps the maximum sum is n^2 * (n+1)/2, which is the sum if all rows are set to [n,n-1,...,1], or all columns are set to [n,n-1,...,1].

But in the n=2 example, sum=8 > 6, which contradicts this.

Wait, perhaps I need to consider that when setting columns to [n,n-1,...,1], the sum is n*(n+1)/2 per column, and similarly for rows.

But in reality, the sum is maximized when as many cells as possible are set to the highest values in the permutations.

Given that, perhaps performing column operations for all columns achieves the maximum sum.

But in n=2, performing two column operations can achieve sum=8, which is n^3.

Wait, but n^3 is achievable.

Wait, n^3 would be setting all cells to n, but since permutations must include all numbers from 1 to n, it's impossible to set all cells to n.

Wait, but in n=2, [2,2] is not a permutation, because it must be [1,2] or [2,1].

So, if I set both columns to [2,1], the matrix becomes [2,2],[1,1], sum=6.

Wait, but earlier I thought of setting both columns to [2,2], but that's invalid because [2,2] is not a permutation.

Wait, perhaps I made a mistake earlier.

Let me think again.

In n=2, possible column operations are setting a column to [1,2] or [2,1].

Similarly for row operations.

So, if I perform two column operations, setting both columns to [2,1], the matrix becomes [2,2],[1,1], sum=6.

Alternatively, setting column 1 to [2,1] and column 2 to [1,2], matrix becomes [2,1],[1,2], sum=6.

In both cases, sum=6.

But in the example, they showed sum=7 with 3 operations.

Wait, perhaps with 3 operations, sum=7 is achievable.

Wait, in the earlier analysis, I thought sum=8 was achievable with 2 operations, but according to the problem's example, sum=7 with 3 operations.

Perhaps I made a mistake.

Let me re-examine.

If I perform two column operations, setting both columns to [2,1], matrix is [2,2],[1,1], sum=6.

If I perform an additional row operation, say on row 1 to [2,1], matrix becomes [2,1],[1,1], sum=5.

Which is less than 6.

Alternatively, perform two column operations: column 1=[2,1], column 2=[1,2], matrix=[2,1],[1,2], sum=6.

Then perform a row operation on row 1 to [1,2], matrix=[1,2],[1,2], sum=6.

Still sum=6.

Wait, perhaps I cannot achieve sum=8 with 2 operations.

Wait, perhaps my earlier assumption was wrong.

Let me try again.

If I perform two column operations:

- Operation 1: type 2, column 1, [2,1]

- Operation 2: type 2, column 2, [2,1]

Matrix becomes [2,2],[1,1], sum=6.

Alternatively:

- Operation 1: type 2, column 1, [1,2]

- Operation 2: type 2, column 2, [1,2]

Matrix becomes [1,1],[2,2], sum=6.

In both cases, sum=6.

Wait, but earlier I thought sum=8 was achievable, but perhaps that was mistaken.

Wait, perhaps I confused column operations with setting all cells in the column to n, but that's invalid because permutations must include all numbers from 1 to n.

Therefore, in n=2, the maximum sum achievable is 6, not 8.

But in the problem's example for n=2, they show sum=7 with 3 operations.

Wait, perhaps sum=7 is the maximum achievable.

Wait, perhaps I need to consider a different strategy.

Let me consider performing row operations first, then column operations.

For n=2:

- Operation 1: type 1, row 1, [2,1]

- Operation 2: type 1, row 2, [2,1]

- Operation 3: type 2, column 1, [2,1]

After operation 1: [[2,1],[0,0]]

After operation 2: [[2,1],[2,1]]

After operation 3: [[2,1],[1,1]]

Sum=2+1+1+1=5.

Alternatively:

- Operation 1: type 1, row 1, [2,1]

- Operation 2: type 2, column 2, [2,1]

- Operation 3: