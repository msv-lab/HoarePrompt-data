Alright, I've got this problem to solve. Let's see what it's asking for. So, Sasha has an array of numbers, and he wants to rearrange them to maximize something called "beauty." The beauty is defined as the sum of (a_i - a_{i-1}) for all i from 2 to n. So, basically, for each pair of consecutive elements in the array, I subtract the previous one from the current one and add all those differences up.

First, I need to understand what this sum represents. Let's take an example from the input. In the first test case, n=3 and the array is [2, 1, 3]. If I rearrange it to [1, 2, 3], then the beauty is (2-1) + (3-2) = 1 + 1 = 2. Another arrangement, say [3, 1, 2], would have beauty (1-3) + (2-1) = -2 + 1 = -1, which is worse. So, rearranging can change the beauty.

I need to find the maximum possible beauty. Looking at the example, it seems that sorting the array in ascending order gives the maximum beauty. In the first example, sorting to [1, 2, 3] gives beauty 2, which is higher than any other arrangement.

Wait, but in the second test case, all elements are 69, so no matter how you arrange them, the differences will be zero, so the beauty is zero. That makes sense.

In the third test case, n=5 and the array is [100, 54, 80, 43, 90]. If I sort it to [43, 54, 80, 90, 100], the beauty would be (54-43) + (80-54) + (90-80) + (100-90) = 11 + 26 + 10 + 10 = 57, which matches the sample output.

Similarly, in the fourth test case, n=4 and the array is [3, 4, 3, 3]. Sorting it to [3, 3, 3, 4], the beauty is (3-3) + (3-3) + (4-3) = 0 + 0 + 1 = 1, which again matches the sample output.

And in the fifth test case, n=2 and the array is [2, 1], sorting to [1, 2] gives beauty (2-1) = 1, which is correct.

So, it seems that sorting the array in ascending order maximizes the beauty. But why is that? Let's think about the sum of (a_i - a_{i-1}) for i from 2 to n.

If I write it out, it's (a2 - a1) + (a3 - a2) + (a4 - a3) + ... + (an - a_{n-1}). If I look closely, this is a telescoping sum, where most terms cancel out. Specifically, a2 cancels with -a2, a3 cancels with -a3, and so on, until I'm left with -a1 + an. So, the entire sum simplifies to an - a1, where an is the last element and a1 is the first element in the arranged array.

Wait, that's interesting. So, no matter how I arrange the array, the beauty is simply the last element minus the first element. That means the maximum beauty is achieved by minimizing a1 and maximizing an.

So, to maximize an - a1, I should choose the smallest possible a1 and the largest possible an. That means sorting the array in ascending order, so a1 is the smallest element and an is the largest element.

That makes sense, and it's consistent with the sample inputs and outputs. So, in essence, the beauty is always equal to the last element minus the first element after arrangement.

Therefore, the program provided seems to be correct. It reads the number of test cases, then for each test case, it reads n and the array, finds the maximum and minimum values in the array, and prints their difference.

In the code, 'x' is initialized to 0, and 'y' is initialized to 100000000. Then, for each element in the array, it updates 'x' to be the maximum value found and 'y' to be the minimum value found. Finally, it prints x - y.

Given that the constraints specify that a_i can be up to 10^9, initializing y to 100000000 might not always work if there are negative numbers, but according to the problem, a_i is at least 1, so y will correctly find the minimum value.

Hence, the program is correct.

**Final Answer**

\[\boxed{\text{Yes}}\]

**Correctness**

\[ \boxed{\text{True}} \]