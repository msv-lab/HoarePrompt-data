Alright, I have this interactive problem to solve. Let's try to understand what's being asked here.

So, there's a secret permutation p of numbers from 0 to n-1, and I need to find two indices i and j such that p_i XOR p_j is maximized. I can ask up to 3n queries where I compare (p_a OR p_b) with (p_c OR p_d). The goal is to find the pair with the maximum XOR using these comparisons.

First, I need to recall what XOR and OR operations do. XOR gives me the bits that are set in one number or the other but not both, while OR gives me the bits that are set in either number.

Since I can't directly access the values of p, I have to use these queries to gather information about the relative magnitudes of the OR operations, and from there, try to infer something about the XOR.

Let's think about the properties of XOR. The maximum possible XOR between two numbers in a set would be achieved by two numbers that differ in the highest possible number of leading bits. For example, in a set of numbers from 0 to n-1, the two numbers with the highest XOR would likely be the ones with the most differing high-order bits.

But since the permutation is secret, I don't know which indices correspond to which values. So, I need a strategy to find those two indices that give the maximum XOR.

Looking at the sample input and output, it seems like the approach is to first find the maximum element in terms of OR operations and then find the pair that gives the maximum XOR.

Wait, but OR and XOR are different operations. Maximizing OR doesn't directly translate to maximizing XOR. OR combines the set bits from both numbers, while XOR highlights the differences.

Maybe I need to find the two largest elements in the permutation, because their XOR would be large if they have differing high-order bits.

But that might not always be the case. For example, if n=3, p=[0,1,2], then 1 XOR 2 = 3, which is larger than 0 XOR 2 = 2 or 0 XOR 1 = 1. So, in this case, the maximum XOR is between the two largest elements.

Another example: n=4, p=[0,1,2,3]. Here, 1 XOR 3 = 2, 2 XOR 3 = 1, 0 XOR 3 = 3, so the maximum XOR is 3, which is between 0 and 3.

Wait, in this case, it's between the smallest and the largest.

Hmm, so maybe the maximum XOR is between the smallest and the largest elements in the permutation.

But let's check another example: n=5, p=[0,1,2,3,4]. 0 XOR 4 = 4, 1 XOR 4 = 5, 2 XOR 4 = 6, 3 XOR 4 = 7. So, the maximum XOR is 7 between 3 and 4.

So, in this case, it's between the second largest and the largest.

Wait, but in n=4, it was between 0 and 3, which is smallest and largest.

In n=2, it's between 0 and 1, which is again smallest and largest.

Wait, in n=3, it was between 1 and 2.

Wait, maybe it's always between the smallest and largest?

Wait, no, in n=5, it was between 3 and 4, not 0 and 4.

Wait, 3 and 4 have XOR of 7, which is higher than 0 and 4, which is 4.

So, in that case, it's between the second largest and the largest.

This is getting confusing. Maybe I need a different approach.

Let me think about the properties of XOR again.

XOR is maximized when the numbers differ in as many high-order bits as possible.

So, to maximize p_i XOR p_j, I need p_i and p_j to have as many differing bits as possible in their binary representations.

Given that p is a permutation of 0 to n-1, the numbers are unique and range from 0 to n-1.

If n is small, like n=2, then p is [0,1], and XOR is 1.

For n=3, p=[0,1,2], and XOR between 1 and 2 is 3.

For n=4, p=[0,1,2,3], and XOR between 3 and 0 is 3.

For n=5, p=[0,1,2,3,4], and XOR between 3 and 4 is 7.

Wait, 3 is 011 and 4 is 100, so XOR is 111, which is 7.

For n=6, p=[0,1,2,3,4,5], XOR between 5 (101) and 4 (100) is 001, which is 1.

Wait, that's not maximum. What about 5 XOR 3? 101 XOR 011 = 110, which is 6.

And 5 XOR 2? 101 XOR 010 = 111, which is 7.

And 5 XOR 1? 101 XOR 001 = 100, which is 4.

And 5 XOR 0? 101 XOR 000 = 101, which is 5.

So, in this case, the maximum XOR is 7, achieved by 5 XOR 2.

Similarly, in n=5, it was 3 XOR 4 = 7.

So, perhaps, in general, the maximum XOR is achieved by the two numbers that differ in the most significant bit positions.

But how do I find such a pair without knowing the actual values of p?

I can't directly access p, but I can compare OR operations of pairs.

Is there a way to use these OR comparisons to infer the relative magnitudes or bit patterns of the p values?

Wait, OR of two numbers is going to be larger if more bits are set in their combination.

So, perhaps, by comparing ORs, I can get some information about which p's have higher values or which bits are set.

But it's still not straightforward to relate OR comparisons to XOR values.

Let me consider the approach used in the provided code.

In the code, for each test case, it first tries to find a 'mak' index that seems to be some kind of maximum based on OR comparisons.

Specifically, it initializes 'mak' to 0 and then compares (p_mak OR p_mak) with (p_i OR p_i) for each i from 1 to n-1. Depending on the comparison, it updates 'mak' to i if (p_i OR p_i) > (p_mak OR p_mak).

Wait, but p_i OR p_i is just p_i, since OR-ing a number with itself doesn't change it.

So, this step is essentially finding the index 'mak' with the maximum p_i.

Then, it sets 'mak2' to 'mak', which seems like a copy.

Next, it compares (p_mak OR p_mak2) with (p_i OR p_mak2) for each i from 0 to n-1.

But p_mak OR p_mak2 is p_mak OR p_mak, which is p_mak, since 'mak2' is the same as 'mak'.

Wait, no, 'mak2' is set to 'mak', so p_mak OR p_mak2 is p_mak OR p_mak, which is p_mak.

So, comparing p_mak with p_i OR p_mak2 (which is p_i OR p_mak).

If p_i OR p_mak > p_mak, then it sets 'mak' to i and records it in 'pans'.

If p_i OR p_mak == p_mak, it also adds i to 'pans'.

So, 'pans' seems to collect indices i where p_i OR p_mak is either greater than or equal to p_mak.

Wait, but p_i OR p_mak being greater than p_mak would imply that p_i has some bits set that p_mak doesn't have.

But p_mak was chosen as the index with the maximum p_i.

So, is it possible for p_i OR p_mak to be greater than p_mak?

If p_mak is the maximum p_i, then p_i OR p_mak should be equal to p_mak for all i, because p_i OR p_mak can't be larger than p_mak if p_mak is the maximum.

But in the sample input, it shows that for n=4, p=[0,3,1,2], and 'mak' is initially set to 0.

Then, comparing p_0 OR p_0 = 0 with p_i OR p_i for i=1,2,3.

For i=1, p_1 OR p_1 = 3, which is greater than 0, so 'mak' is updated to 1.

Then, for i=2, p_2 OR p_2 = 1, which is less than 3, so no change.

For i=3, p_3 OR p_3 = 2, which is less than 3, so 'mak' remains 1.

Then, 'mak2' is set to 1.

Next, it compares (p_mak OR p_mak2) with (p_i OR p_mak2) for each i.

But p_mak is 1, p_mak2 is 1, so p_mak OR p_mak2 is 3 OR 3 = 3.

For each i, p_i OR p_mak2 is p_i OR 3.

So, for i=0, p_0 OR 3 = 0 OR 3 = 3, which equals 3.

For i=1, p_1 OR 3 = 3 OR 3 = 3, equals.

For i=2, p_2 OR 3 = 1 OR 3 = 3, equals.

For i=3, p_3 OR 3 = 2 OR 3 = 3, equals.

So, 'pans' would include all indices 0,1,2,3.

Then, it finds the index 'mak' in 'pans' by comparing p_pans[mak] with p_pans[i] for each i.

Initially, 'mak' is set to 0.

Comparing p_0 OR p_0 with p_1 OR p_1: 0 OR 0 = 0 vs. 3 OR 3 = 3. '<', so 'mak' becomes 1.

Then, comparing p_1 OR p_1 with p_2 OR p_2: 3 vs. 1 OR 1 =1. '>', so 'mak' remains 1.

Then, comparing p_1 OR p_1 with p_3 OR p_3: 3 vs. 2 OR 2 =2. '>', so 'mak' remains 1.

Finally, it prints '! 1 1', which is i=1 and j=1.

But p_1 XOR p_1 is 0, which is not the maximum.

Wait, in the sample output, it's '! 3 2'.

Wait, perhaps I misread the code.

Looking back, in the code, after finding 'pans', it sets 'mak' to 0 and then compares p_pans[mak] OR p_pans[mak] with p_pans[i] OR p_pans[i].

Wait, no, it's printing '! mak2 mak', which in this case would be '! 1 1'.

But in the sample output, it's '! 3 2'.

So, perhaps there's a mistake in my understanding.

Wait, perhaps 'mak2' is being used as an index differently.

Wait, in the sample interaction, after the queries, it prints '! 3 2'.

So, maybe the code is different from what I thought.

Wait, perhaps 'mak2' is being used differently.

Wait, perhaps I need to trace the code more carefully.

Let me look at the code again.

First, it finds 'mak' by comparing p_i OR p_i for each i.

Then, it sets 'mak2' to 'mak'.

Then, it collects 'pans' by comparing (p_mak OR p_mak2) with (p_i OR p_mak2).

Then, it finds 'mak' in 'pans' by comparing p_pans[mak] OR p_pans[mak] with p_pans[i] OR p_pans[i].

Finally, it prints '! mak2 mak'.

In the sample case, it seems to print '! 3 2'.

But according to the code, 'mak2' is 1, and 'mak' is 1, so it should print '! 1 1'.

Wait, maybe I need to see what 'pans' contains.

In the sample case, 'pans' would contain all indices 0,1,2,3.

Then, when comparing p_pans[mak] OR p_pans[mak] with p_pans[i] OR p_pans[i], it's comparing p_0 OR p_0 with p_pans[i] OR p_pans[i].

Wait, p_pans[mak] is p_0, which is 0.

Comparing 0 with p_pans[i] OR p_pans[i].

For i=1, p_1 OR p_1 =3, which is greater than 0, so 'mak' becomes 1.

Then, comparing p_pans[1] OR p_pans[1] =3 with p_pans[2] OR p_pans[2]=1. 3>1, so 'mak' remains 1.

Comparing p_pans[3] OR p_pans[3]=2. 3>2, so 'mak' remains 1.

Then, it prints '! mak2 mak', which is '! 1 1'.

But in the sample output, it's '! 3 2'.

So, perhaps there's a misunderstanding.

Wait, perhaps 'mak2' is being updated somewhere else.

Wait, in the code, 'mak2' is set to 'mak' initially, but then 'mak' is updated in the loop.

So, 'mak2' remains 1, and 'mak' becomes 1.

But in the sample output, it's '! 3 2'.

So, perhaps the code is different from what's provided.

Alternatively, maybe there's a misstep in my reasoning.

Let me consider another approach.

Maybe I can find the position of the highest set bit in the permutation and use that to find the two numbers that differ in that bit.

For example, if the highest set bit is at position k, then the two numbers with different bits at position k will have a large XOR.

But I need to find such a pair without directly knowing the values.

Alternatively, perhaps I can iterate through the bits from the most significant to the least significant and try to maximize the XOR at each step.

But this seems complicated with the constraints of the queries.

Another idea: since I can compare ORs of pairs, maybe I can use these comparisons to sort the p values in some way or to find the maximum p value.

Wait, in the code, it seems to be finding some kind of maximum p value by comparing p_i OR p_i.

But as I thought earlier, p_i OR p_i is just p_i, so comparing p_i with p_j is directly comparing their values.

So, in the first loop, it's finding the index 'mak' with the maximum p_i.

Then, it sets 'mak2' to 'mak'.

Then, it collects 'pans' by comparing (p_mak OR p_mak2), which is p_mak OR p_mak, which is p_mak, with (p_i OR p_mak2), which is p_i OR p_mak.

So, it's comparing p_mak with p_i OR p_mak.

If p_i OR p_mak > p_mak, it sets 'mak' to i and adds i to 'pans'.

If p_i OR p_mak == p_mak, it adds i to 'pans'.

So, 'pans' collects all i where p_i OR p_mak >= p_mak.

But since p_mak is the maximum p_i, p_i OR p_mak should be equal to p_mak for all i.

Wait, but in the sample case, it's adding all indices to 'pans'.

Then, it finds 'mak' in 'pans' by comparing p_pans[mak] OR p_pans[mak] with p_pans[i] OR p_pans[i].

This seems like finding the maximum p_pans[i] in 'pans'.

Finally, it prints '! mak2 mak', which in the sample case would be '! 1 1', but in the sample output, it's '! 3 2'.

So, perhaps there's a mistake in the code or in my understanding.

Wait, maybe 'mak2' is being updated somewhere else.

Wait, in the code, 'mak2' is set to 'mak' initially, and then 'mak' is updated in the loop, but 'mak2' remains the initial 'mak'.

So, in the sample case, 'mak2' is 1, and 'mak' is 1, so it prints '! 1 1', but in the sample output, it's '! 3 2'.

So, perhaps the code is different from what's provided.

Alternatively, maybe there's a misunderstanding in the interaction.

Wait, perhaps 'mak2' is being used as one of the indices in the final answer, and 'mak' is the other.

But in the sample case, p_1 XOR p_1 is 0, which is not the maximum.

The maximum is p_3 XOR p_2 = 2 XOR 1 = 3.

So, perhaps 'mak2' should be 3 and 'mak' should be 2.

But according to the code, 'mak2' is set to the index with the maximum p_i, and then 'mak' is set to the index with the maximum p_pans[i].

But in the sample case, p_1 is 3, which is the maximum, so 'mak2' is 1.

Then, 'pans' includes all indices, and 'mak' is set to 1.

So, it should print '! 1 1', but in the sample output, it's '! 3 2'.

Wait, perhaps there's a misindexing.

In Python, list indices start at 0, but the output requires 0-based indices.

In the sample output, it's '! 3 2', which correspond to p_3 and p_2, which are 2 and 1, respectively.

Their XOR is 3, which is correct.

But according to the code, 'mak2' is 1 and 'mak' is 1, so it should print '! 1 1'.

Unless 'mak' is being used as an index in 'pans'.

Wait, 'mak' is initially set to 0, and then updated in the loop.

Wait, in the loop:

for i in range(1, len(pans)):

if str(input()) == '>':

mak = i

So, it's comparing p_pans[mak] OR p_pans[mak] with p_pans[i] OR p_pans[i].

In the sample case, 'pans' is [0,1,2,3].

Comparing p_0 OR p_0 =0 with p_1 OR p_1 =3: '<', so 'mak' becomes 1.

Then, comparing p_1 OR p_1 =3 with p_2 OR p_2 =1: '>', so 'mak' remains 1.

Then, comparing p_1 OR p_1 =3 with p_3 OR p_3 =2: '>', so 'mak' remains 1.

So, 'mak' is 1.

Then, it prints '! mak2 mak', which is '! 1 1'.

But in the sample output, it's '! 3 2'.

So, perhaps there's a mistake in the code or in my understanding.

Wait, maybe 'mak2' and 'mak' are being used as indices in the permutation.

In the sample case, 'mak2' is 1, which corresponds to p_1=3.

Then, 'mak' is 1, which corresponds to p_1=3.

So, printing '! 1 1' would be p_1 and p_1, which is 3 XOR 3=0.

But the sample output is '! 3 2', which correspond to p_3=2 and p_2=1, which is correct.

So, perhaps the code is incorrect.

Alternatively, perhaps there's a misunderstanding in the interaction.

Wait, perhaps 'mak2' should be set to another index.

Wait, maybe I need to think differently.

Let me consider that the maximum XOR will be between the two numbers that differ the most in their binary representation.

To find such a pair, perhaps I need to find the two numbers with the highest Hamming distance.

But I need a way to find such a pair using the allowed queries.

Alternatively, perhaps I can find the maximum and second maximum elements and take their XOR.

But in some cases, as I saw earlier, the maximum XOR isn't necessarily between the maximum and second maximum elements.

For example, in n=5, p=[0,1,2,3,4], the maximum XOR is between 3 and 4, which are p_3 and p_4.

So, perhaps I need to find the two elements whose binary representations differ the most starting from the most significant bit.

One way to do this is to find the highest bit position where the bits differ and choose the pair that has different bits in that position.

But again, without knowing the actual values, it's tricky.

Wait, maybe I can iterate through the bit positions from high to low and try to find two numbers that differ in that bit position.

Start with the most significant bit and go downwards.

But I need to do this using the allowed queries, which are comparisons of ORs of pairs.

This seems complicated.

Let me look back at the code.

In the code, it first finds 'mak', which is the index with the maximum p_i.

Then, it collects 'pans', which are indices i where p_i OR p_mak >= p_mak.

Since p_mak is the maximum, p_i OR p_mak should always be equal to p_mak.

So, 'pans' should include all indices.

Then, it finds 'mak' in 'pans' which has the maximum p_pans[mak].

But since 'pans' includes all indices, this is just finding the index with the maximum p_i in the entire permutation, which is 'mak2'.

So, in the end, it prints '! mak2 mak', which are both the same index, which doesn't make sense because p_mak2 XOR p_mak would be 0.

But in the sample interaction, it's printing different indices.

So, perhaps there's a mistake in the code.

Alternatively, perhaps 'mak' is being used differently.

Wait, maybe 'mak' is being used as an index in 'pans', which is a list of indices.

So, 'mak' is an index into 'pans', not directly into the permutation.

Wait, in the code, 'mak' is initialized to 0, and then in the loop:

for i in range(1, len(pans)):

print('?', pans[mak], pans[mak], pans[i], pans[i])

sys.stdout.flush()

s = str(input())

if s == '>':

mak = i

So, it's comparing p_pans[mak] OR p_pans[mak] with p_pans[i] OR p_pans[i].

If p_pans[i] OR p_pans[i] > p_pans[mak] OR p_pans[mak], then set 'mak' to i.

Since 'pans' includes all indices, this is finding the index in 'pans' with the maximum p_i.

But 'pans' includes all indices, so this is just finding the index with the maximum p_i, which is 'mak2'.

So, in the end, 'mak' points to the index with the maximum p_i in 'pans', which is 'mak2'.

Therefore, printing '! mak2 mak' would be printing the same index twice, which is incorrect.

So, perhaps this approach is flawed.

I need a different strategy.

Let me consider that for any two numbers, their XOR is maximized when their binary representations differ the most.

Given that p is a permutation of 0 to n-1, the two numbers with the highest XOR would likely be the minimum and maximum values in the permutation, but as I saw in earlier examples, that's not always the case.

Alternatively, perhaps I can find the two numbers with the highest possible bitwise OR, but again, OR and XOR are different.

Wait, perhaps I can find the two numbers with the highest individual values and then take their XOR.

But as I saw in n=6, p=[0,1,2,3,4,5], the maximum XOR is between 5 and 2, which is 7, not between 5 and 4, which is 1.

So, it's not simply between the maximum and second maximum.

Alternatively, perhaps I can find the two numbers with the highest bitwise AND.

But that seems unrelated.

Wait, perhaps I can find the two numbers with the most differing high-order bits.

To do that, I need to find two numbers where the most significant bit differs.

If n is a power of 2, then the numbers from 0 to n-1 have the most significant bit set for half of them.

But since n can be any value, this is complicated.

Alternatively, perhaps I can iterate through the bit positions, starting from the highest, and try to select two numbers that differ in that bit.

But I need a way to do that using the allowed queries.

This is getting too