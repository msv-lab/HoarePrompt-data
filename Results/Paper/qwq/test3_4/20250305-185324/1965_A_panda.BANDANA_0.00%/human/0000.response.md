Alright, I've got this problem to figure out. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual compared to standard stone-removal games. Let's see...

So, the game setup is that there are n piles of stones, and on each turn, a player chooses a positive integer k that is less than or equal to the smallest pile and removes k stones from every nonempty pile. The player who can't make a move because all piles are empty loses. Alice goes first, and both play optimally. I need to determine who wins each game for multiple test cases.

First, I need to understand the game mechanics deeply. The key here is that the player removes k stones from every nonempty pile, where k is at most the smallest pile's size. This is different from games where you remove stones from a single pile.

Let me think about the game state and how it evolves. Suppose we have piles with sizes a1, a2, ..., an. The smallest pile has size m. Then, the player can choose any k from 1 to m, and remove k stones from each pile that has stones.

After the move, the piles will have a1 - k, a2 - k, ..., an - k, but only if ai >= k. If ai < k, then that pile becomes empty.

Wait, no, the rule says to remove k stones from each nonempty pile. So, if ai >= k, it becomes ai - k; if ai < k, it becomes 0.

I need to see how the game progresses and find a way to determine the winner without simulating the entire game, which would be inefficient given the constraints.

Given that n can be up to 2*10^5 and t up to 10^4, with the sum of n over all test cases up to 2*10^5, I need an O(n log n) per test case solution at worst.

But perhaps there's a smarter way, some game theory concept that can reduce the complexity.

I recall that in impartial games, the concept of Nimbers or the mex function can be used to determine the winner. Maybe this game can be modeled as a Nim heap or something similar.

Let me consider some small examples to see if I can find a pattern.

Take the first test case from the example:

5

3 3 3 3 3

Alice can choose k=3 and remove 3 stones from each pile, making all piles empty. So, she wins immediately.

Next test case:

2

1 7

Alice must choose k=1 (since the smallest pile is 1), removes 1 from each pile, resulting in 0 and 6.

Now, Bob chooses k up to 6 (since the smallest nonempty pile is 6), say k=6, removes 6 from the pile of 6, making it empty. Now, only one pile is left, which is empty, so Alice can't move and loses.

So, Bob wins.

Another test case:

7

1 3 9 7 4 2 100

Alice chooses k=1 (smallest pile is 1), removes 1 from each pile:

0, 2, 8, 6, 3, 1, 99

Now, Bob can choose k up to 1 (the smallest nonempty pile is 1), removes 1 from each nonempty pile:

0, 1, 7, 5, 2, 0, 98

Alice can choose k up to 1, removes 1 from each nonempty pile:

0, 0, 6, 4, 1, 0, 97

Bob chooses k=1:

0, 0, 5, 3, 0, 0, 96

Alice chooses k=1:

0, 0, 4, 2, 0, 0, 95

Bob chooses k=1:

0, 0, 3, 1, 0, 0, 94

Alice chooses k=1:

0, 0, 2, 0, 0, 0, 93

Bob chooses k=1:

0, 0, 1, 0, 0, 0, 92

Alice chooses k=1:

0, 0, 0, 0, 0, 0, 91

Now, all piles are empty, so Alice wins.

Wait, but according to the example output, Alice wins this game, which matches what I just saw.

But this seems tedious to do for larger n. There must be a better way.

Let me try to find a pattern or a mathematical formula.

I notice that in the first test case, all piles are equal, and Alice can remove all stones in one move.

In the second test case, there's a pile of size 1, which forces Alice to remove 1 from all piles, making one pile empty and others reduced, leading to Bob's win.

In the third test case, Alice removes 1 from all piles, and then the game continues until Alice makes the last move.

Perhaps the number of times you can subtract 1 from the smallest pile determines the winner.

Wait, but that seems vague.

Let me think differently.

Suppose I sort the piles in ascending order: a1 <= a2 <= ... <= an.

On each move, the player chooses k <= a1 (the smallest nonempty pile) and subtracts k from each nonempty pile.

This operation is equivalent to removing the top k layers of stones from all piles simultaneously.

I wonder if this game is equivalent to some other known impartial game.

Alternatively, perhaps I can model this game as a Nim game with certain heaps.

Wait, in Nim, players remove stones from a single pile, but here, stones are removed from all nonempty piles simultaneously.

That's a crucial difference.

Let me think about the game in terms of its Grundy numbers (Nimbers).

In combinatorial game theory, the Grundy number of a game state is the mex (minimum excludant) of the Grundy numbers of the positions reachable in one move.

If the Grundy number of the initial position is non-zero, the first player wins; otherwise, the second player wins, assuming optimal play.

So, if I can compute the Grundy number for this game, I can determine the winner.

But computing Grundy numbers directly is not feasible for large n and a_i up to 10^9.

I need to find a pattern or a mathematical formula that allows me to compute the Grundy number efficiently.

Let me consider some small cases.

Case 1: n=1

- If a1 > 0, Alice can choose k=1 to a1, remove k stones, making the pile empty. Bob can't move, so Alice wins.

- So, for n=1, Alice always wins if a1 > 0.

Wait, but according to the sample input, there's a case with n=1 and a1=1000000000, and the output is Alice, which matches this.

Case 2: n=2

- Let's say a1 <= a2.

- Alice chooses k from 1 to a1.

- After removing k from both piles, the new piles are a1 - k and a2 - k (if a2 - k >= 0), else 0.

- If a1 - k = 0, then only one pile remains with a2 - k stones.

- If a1 - k > 0, then both piles are reduced.

- This seems complicated to compute the Grundy number directly.

Wait, maybe there's a better way.

I recall that in games where you can remove stones from all piles simultaneously, it might be related to the mex of certain values.

Let me think differently.

Suppose I sort the piles in ascending order: a1 <= a2 <= ... <= an.

Consider the differences between consecutive piles: a2 - a1, a3 - a2, ..., an - a_{n-1}.

I'm not sure if this helps directly.

Wait, perhaps I can think of the game as a misère game, but misère games are generally more complicated.

Alternatively, maybe I can think in terms of the number of stones or something.

Wait, perhaps I can think about the minimal number of moves required to empty all piles.

If the total number of moves is odd, Alice wins; if even, Bob wins.

But I need to see if this makes sense.

In the first test case, Alice can make one move (k=3) to empty all piles. One move is odd, so Alice wins.

In the second test case, Alice makes one move (k=1), resulting in piles 0 and 6. Then Bob makes one move (k=6), emptying the second pile. Total moves: two, which is even, so Bob wins.

In the third test case, Alice makes the first move (k=1), then Bob, Alice, Bob, and so on, until Alice makes the last move. Total moves are odd, so Alice wins.

Wait, but in the third test case, from the earlier simulation, there were 7 moves: Alice, Bob, Alice, Bob, Alice, Bob, Alice. That's 7 moves, which is odd, so Alice wins.

This seems to hold.

So, perhaps the total number of moves is determined by the number of times you can subtract the smallest pile's k from all piles until all piles are empty.

But this seems too vague and not directly helpful for computing the winner efficiently.

Let me see if there's a mathematical way to determine the number of moves or who wins.

I need to find a pattern or property that decides the winner based on the pile sizes.

Looking back at the sample inputs and outputs:

Test case 1:

5

3 3 3 3 3

Alice wins by choosing k=3.

Test case 2:

2

1 7

Alice chooses k=1, Bob chooses k=6, and Alice can't move. Bob wins.

Test case 3:

7

1 3 9 7 4 2 100

Alice chooses k=1, Bob chooses k=1, and so on, until Alice makes the last move. Alice wins.

Test case 4:

3

1 2 3

Alice chooses k=1, Bob chooses k=1, Alice chooses k=1, Bob chooses k=1, Alice chooses k=1. Alice wins.

Test case 5:

6

2 1 3 4 2 4

Alice chooses k=1, Bob chooses k=1, Alice chooses k=1, Bob chooses k=1. Bob wins.

Test case 6:

8

5 7 2 9 6 3 3 2

Alice chooses k=2, Bob chooses k=2, Alice chooses k=2, Bob chooses k=1, Alice chooses k=1. Alice wins.

Test case 7:

1

1000000000

Alice chooses k=1000000000 and wins immediately.

From these, it seems that when there is at least one pile with 1 stone, Bob has an advantage, but it's not straightforward.

Wait, in test case 2, there is a pile with 1 stone, and Bob wins.

In test case 3, there is a pile with 1 stone, but Alice wins.

So, having a pile with 1 stone doesn't always mean Bob wins.

Wait, perhaps it's more about the parity of the number of piles with 1 stone.

But in test case 2, one pile with 1 stone, Bob wins.

In test case 3, one pile with 1 stone, Alice wins.

Wait, maybe something else.

Let me look for another approach.

I found that this game is similar to a game called "Reduced Nim" or "Nim with subtraction."

But I need to find a direct way to compute who wins.

Wait, perhaps I can think of the game as equivalent to a single Nim heap with a certain size.

If I can find such an equivalent Nim heap, I can determine the winner based on its size.

Alternatively, perhaps the mex of certain values can determine the winner.

But I'm not sure.

Let me consider the minimal excludant (mex) of the possible moves.

Wait, perhaps I can sort the piles and look at the differences.

Wait, I need to think differently.

I recall that in games where you reduce all piles simultaneously, the Grundy number can sometimes be determined by the XOR of certain values.

But I'm not sure.

Let me try to think recursively.

Define the game state as a multiset of pile sizes.

The possible moves are to choose k from 1 to the minimum pile size and remove k from each pile.

The game ends when all piles are empty.

I need to compute the Grundy number for the initial position.

But with n up to 2*10^5 per test case, I can't compute Grundy numbers naively.

I need a smarter way.

Wait, perhaps I can find a mathematical formula based on the pile sizes.

Let me consider the minimal pile size.

If the minimal pile size is m, then the player can choose any k from 1 to m.

After choosing k, each pile is reduced by k, and piles that were less than or equal to k become empty.

So, the number of nonempty piles decreases based on how many piles were <= k.

This seems tricky to model directly.

Wait, perhaps I can sort the piles in ascending order and think about how many moves are needed to reduce them to zero.

Let me sort the piles: a1 <= a2 <= ... <= an.

In each move, the player chooses k <= a1 and subtracts k from each ai.

After the move, a1 is reduced to a1 - k, which becomes zero if a1 <= k.

Similarly, ai is reduced to ai - k if ai >= k, else zero.

So, in each move, the number of nonempty piles decreases by the number of piles that were equal to k.

Wait, no, it's the number of piles that are <= k.

Wait, if k is chosen, then all piles >= k will be reduced by k, and piles < k will become zero.

So, the number of nonempty piles decreases by the number of piles that were < k.

Wait, no.

Wait, if k is chosen, then for each pile:

- If ai >= k, ai becomes ai - k.

- If ai < k, ai becomes 0.

So, the number of piles that become empty is equal to the number of piles where ai < k.

Therefore, the number of nonempty piles decreases by the number of piles where ai < k.

So, the new number of nonempty piles is equal to the number of piles where ai >= k.

Wait, yes.

So, the player chooses k and reduces k from all piles >= k, and sets piles < k to 0.

Wait, no, more precisely, the player chooses k <= a1, and reduces k from all piles, setting piles where ai < k to 0.

So, the number of nonempty piles after the move is equal to the number of piles where ai >= k.

Since k <= a1, and a1 is the smallest nonempty pile, all piles with ai >= k will remain nonempty after the move.

Wait, no, if k <= a1, and a1 is the smallest nonempty pile, then all piles are >= k, so all piles will have ai - k >= 0.

Wait, but if ai < k, ai becomes 0.

But since k <= a1, and a1 is the smallest nonempty pile, ai >= a1 for all nonempty piles.

So, ai >= k for all piles, meaning that after the move, all piles will have ai - k >= 0.

Wait, but if ai >= k, ai becomes ai - k, which is >= 0.

If ai < k, ai becomes 0.

But since k <= a1, and a1 is the smallest nonempty pile, ai >= a1 for all nonempty piles.

Therefore, ai >= k for all piles, meaning that after the move, all piles will have ai - k >= 0.

Wait, but in the earlier simulation, I saw piles becoming empty, but that was because in those moves, k was equal to the pile size.

Wait, perhaps I need to think differently.

Let me consider that after each move, the number of nonempty piles decreases based on how many piles were exactly equal to k.

Wait, perhaps.

Wait, suppose I have piles sorted in ascending order: a1 <= a2 <= ... <= an.

The player chooses k <= a1.

After choosing k, the new pile sizes are:

a1 - k, a2 - k, ..., an - k, but any pile that had ai < k becomes 0.

But since k <= a1, and a1 <= ai for all i, ai - k >= 0 for all i.

Wait, but in the earlier simulation, I saw piles becoming empty, but that was because k was equal to the pile size.

Wait, no, if k <= a1, and a1 <= ai for all i, then ai - k >= 0 for all i.

So, no pile becomes empty unless ai < k, but since k <= a1 <= ai, ai - k >= 0.

Wait, perhaps I'm missing something.

Wait, suppose a1 = 1, a2 = 2, and k = 1.

Then, after the move, a1 = 0, a2 = 1.

So, the pile a1 becomes empty.

Wait, but earlier I thought that k <= a1, and a1 <= ai for all i, so ai - k >= 0.

But in this case, a1 - k = 0.

So, piles with ai == k become 0.

Piles with ai > k become ai - k.

So, the number of nonempty piles decreases by the number of piles where ai == k.

Because those piles become empty.

Yes, that makes sense.

So, when choosing k, the number of nonempty piles decreases by the number of piles where ai == k.

Therefore, the game can be modeled as a game where you can reduce the number of nonempty piles by a certain amount based on the choice of k.

This seems promising.

Let me think about the game in terms of the number of nonempty piles.

Initially, there are n nonempty piles.

A move consists of choosing k <= a1, and reducing each ai by k, setting ai < k to 0.

The number of nonempty piles decreases by the number of piles where ai == k.

Wait, more precisely, the number of nonempty piles decreases by the number of piles where ai < k.

Wait, no.

Wait, in the earlier example:

a1 = 1, a2 = 2, k = 1.

After the move: a1 = 0, a2 = 1.

So, the number of nonempty piles decreases by 1 (the pile that was equal to k).

Wait, but ai < k would be ai < k, which in this case, a1 < k would be 1 < 1, which is false.

Wait, perhaps I need to think differently.

Wait, in general, when you choose k, the piles where ai < k become empty, and the piles where ai >= k become ai - k.

Therefore, the number of nonempty piles decreases by the number of piles where ai < k.

Yes, that's correct.

So, if you choose k, the number of nonempty piles decreases by the number of piles where ai < k.

Let me denote s(k) as the number of piles where ai < k.

Then, after choosing k, the number of nonempty piles becomes n - s(k).

Then, the next player faces a game with n - s(k) nonempty piles.

This seems like a subtraction game, where you can subtract s(k) from n.

Wait, but s(k) depends on k, which is constrained by a1.

This is getting complicated.

Perhaps I can think of the game in terms of the mex of certain values.

Alternatively, maybe there's a way to group the piles based on their sizes.

Wait, perhaps I can sort the piles and think about the differences between consecutive piles.

Let me try that.

Sort the piles: a1 <= a2 <= ... <= an.

Compute the differences: a2 - a1, a3 - a2, ..., an - a_{n-1}.

But I'm not sure if this helps directly.

Wait, perhaps I can think of the game as equivalent to a Nim game with heaps of size differences.

But I need to think carefully.

Let me consider an example.

Take test case 3:

7

1 3 9 7 4 2 100

Sort them: 1,2,3,4,7,9,100

Differences: 1,1,1,3,2,91

Not sure if this helps.

Wait, perhaps I can think in terms of binary representations or something.

But that seems too vague.

Let me consider another approach.

I recall that in games where you can remove stones from multiple piles simultaneously, the Grundy number can sometimes be the XOR of the Grundy numbers of the individual components.

But in this case, since the moves affect all piles at once, it's not straightforward.

Wait, perhaps I can think of the game as equivalent to a single pile where the move is determined by the smallest pile.

But I need to find a way to map this to a known game.

Alternatively, maybe I can think recursively.

Define the game state as G(n, a1, a2, ..., an).

The possible moves are to choose k from 1 to a1, and move to G(n - s(k), a1 - k, a2 - k, ..., an - k), where s(k) is the number of piles where ai < k.

Wait, but ai - k could be negative, but in reality, they become 0.

So, more precisely, the new piles are max(ai - k, 0).

This seems too recursive and not practical for large n.

I need a better way.

Let me consider the minimal pile size, a1.

If a1 = 0, the game is over, no moves can be made.

Otherwise, the player can choose k from 1 to a1.

After choosing k, the new minimal pile size is a_{s(k)+1} - k, where s(k) is the number of piles with ai < k.

Wait, more precisely, after choosing k, the new piles are ai - k for ai >= k, and 0 otherwise.

So, the new minimal pile size is a_{s(k)+1} - k, where s(k) is the number of piles with ai < k.

Wait, perhaps I can think in terms of the number of times I can subtract the minimal pile size.

But this seems too vague.

Wait, perhaps I can think about the game in terms of its nimber, which is the mex of the nimbers of the positions reachable in one move.

But computing this directly is not feasible for large n.

I need to find a pattern or a mathematical formula.

Let me look back at the sample inputs and see if I can find a pattern.

Test case 1:

5 piles of 3 each.

Alice chooses k=3, removes 3 from each, all piles become 0. Alice wins.

Test case 2:

2 piles: 1 and 7.

Alice chooses k=1, removes 1 from each, piles become 0 and 6.

Bob chooses k=6, removes 6 from the pile of 6, making it 0. Alice can't move, so Bob wins.

Test case 3:

7 piles: 1,3,9,7,4,2,100.

Alice chooses k=1, removes 1 from each, piles become 0,2,8,6,3,1,99.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,1,7,5,2,0,98.

Alice chooses k=1, removes 1 from each nonempty pile, piles become 0,0,6,4,1,0,97.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,0,5,3,0,0,96.

Alice chooses k=1, removes 1 from each nonempty pile, piles become 0,0,4,2,0,0,95.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,0,3,1,0,0,94.

Alice chooses k=1, removes 1 from each nonempty pile, piles become 0,0,2,0,0,0,93.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,0,1,0,0,0,92.

Alice chooses k=1, removes 1 from each nonempty pile, piles become 0,0,0,0,0,0,91.

Now, all piles are empty, so Alice wins.

Looking at this, it seems that the number of moves made is equal to the number of times we can subtract 1 from the minimal nonempty pile.

Wait, in test case 1, Alice wins in one move by choosing k=3.

In test case 2, there are two moves: Alice chooses k=1, Bob chooses k=6.

In test case 3, there are seven moves: Alice, Bob, Alice, Bob, Alice, Bob, Alice.

So, when the number of moves is odd, Alice wins; when even, Bob wins.

This seems to hold for these test cases.

Wait, but is this always true?

Looking at test case 4:

3 piles: 1,2,3.

Alice chooses k=1, removes 1 from each, piles become 0,1,2.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,0,1.

Alice chooses k=1, removes 1 from the remaining pile, making it 0.

So, Alice makes the last move, winning. Total moves: 3, which is odd.

Test case 5:

6 piles: 2,1,3,4,2,4.

Alice chooses k=1, removes 1 from each pile, piles become 1,0,2,3,1,3.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,0,1,2,0,2.

Alice chooses k=1, removes 1 from each nonempty pile, piles become 0,0,0,1,0,1.

Bob chooses k=1, removes 1 from each nonempty pile, piles become 0,0,0,0,0,0.

Bob makes the last move, so Bob wins. Total moves: 4, which is even.

This seems consistent.

So, perhaps the total number of moves is equal to the number of times you can subtract 1 from the minimal nonempty pile, and depending on whether this number is odd or even, Alice or Bob wins.

But I need to confirm if this is always the case.

Wait, perhaps I can think in terms of the mex of the number of moves.

But I need a better understanding.

Let me try to think recursively again.

Define the game state by the multiset of pile sizes.

The possible moves are to choose k from 1 to the minimal pile size and remove k from each pile.

The game ends when all piles are empty.

This is similar to a Nim game where the Grundy number is the XOR of the Grundy numbers of the individual piles, but since moves affect all piles simultaneously, it's different.

Wait, perhaps I can think of the game as equivalent to a single Nim heap with a certain size.

If I can find such an equivalent Nim heap, I can determine the winner based on its size.

But how?

Wait, perhaps the equivalent Nim heap size is the mex of the possible moves.

But I need to formalize this.

Alternatively, perhaps I can sort the piles and think about the game in terms of the differences between consecutive piles.

But I'm stuck.

Let me look for an invariant in the game.

An invariant is a property that remains unchanged after any move.

In this game, perhaps the parity of the number of moves is an invariant.

From the test cases, it seems that when the total number of moves is odd, Alice wins; if even, Bob wins.

So, perhaps the winner depends on the parity of the number of moves required to empty all piles.

If that's the case, then Alice wins if the number of moves is odd; Bob wins if even.

So, I need to find a way to determine the parity of the number of moves.

But how can I determine the parity without simulating the game?

Let me consider sorting the piles in ascending order: a1 <= a2 <= ... <= an.

The minimal pile is a1.

The player chooses k from 1 to a1 and removes k from each pile.

After the move, the new minimal pile is a_{s(k)+1} - k, where s(k) is the number of piles with ai < k.

Wait, more precisely, after choosing k, the new piles are ai - k for ai >= k, and 0 otherwise.

So, the new minimal pile is a_{s(k)+1} - k, where s(k) is the number of piles with ai < k.

Wait, s(k) is the number of piles with ai < k.

So, the number of piles that become empty is s(k), and the remaining n - s(k) piles have sizes a_{s(k)+1} - k, a_{s(k)+2} - k, ..., an - k.

This seems recursive, but with large n, I need an efficient way.

Wait, perhaps I can think of the game as equivalent to a single pile where the size is determined by the minimal pile.

But I need to find a better approach.

Let me consider binary representations.

Suppose I look at the binary representations of the pile sizes.

But I don't see an immediate connection.

Wait, perhaps I can think in terms of the number of times each pile can be reduced.

But again, this seems too vague.

Let me consider another angle.

Suppose I fix k and see what happens.

But choosing different k leads to different reductions, and it's not clear how to manage this.

Wait, perhaps I can think of the game as equivalent to a game of Nim where each pile's size is the number of times you can subtract 1 from it.

But that doesn't seem right.

Wait, perhaps I can think of each pile contributing to the total number of moves.

But I need to think differently.

Let me consider the minimal excludant (mex) of the exponents in the binary representations.

Wait, that seems too vague.

I need to find a mathematical pattern.

Let me look back at the sample inputs and see if there's a pattern in the pile sizes that determines the winner.

Test case 1:

5 piles of 3 each.

Alice wins by choosing k=3.

Test case 2:

2 piles: 1 and 7.

Alice chooses k=1, Bob chooses k=6, Bob wins.

Test case 3:

7 piles: 1,3,9,7,4,2,100.

Alice wins after 7 moves.

Test case 4:

3 piles:1,2,3.

Alice wins after 3 moves.

Test case 5:

6 piles:2,1,3,4,2,4.

Bob wins after 4 moves.

Test case 6:

8 piles:5,7,2,9,6,3,3,2.

Alice wins after 5 moves.

Test case 7:

1 pile:1000000000.

Alice wins by choosing k=1000000000.

Looking at these, it seems that if there is at least one pile with size 1, Bob has an advantage, but it's not consistent.

Wait, in test case 2 and test case 3, both have a pile of size 1, but different winners.

So, having a pile of size 1 doesn't solely determine the winner.

Wait, perhaps it's about the number of piles with size 1.

In test case 2, one pile of size 1; Bob wins.

In test case 3, one pile of size 1; Alice wins.

Not consistent.

Wait, perhaps it's about the parity of the number of piles with size 1.

But in both test case 2 and 3, the number of piles with size 1 is odd, but different winners.

Wait, no, test case 2 has one pile of size 1, test case 3 has one pile of size 1.

Wait, perhaps something else.

Wait, perhaps it's about the minimal pile size.

In test case 1, minimal pile is 3; Alice wins.

Test case 2, minimal pile is 1; Bob wins.

Test case 3, minimal pile is 1; Alice wins.

Not consistent.

Wait, perhaps it's about whether the minimal pile size is 1 or greater than 1.

In test case 2, minimal pile is 1, Bob wins.

In test case 3, minimal pile is 1, Alice wins.

So, not solely based on that.

Wait, perhaps it's about the number of piles that have size 1.

But in test case 2 and test case 3, both have one pile of size 1, but different winners.

Wait, perhaps it's about the difference between the minimal pile and the second minimal pile.

But that seems too vague.

I need to find a different approach.

Let me consider the game as equivalent to a Nim game with a certain heap size.

If I can find the equivalent Nim heap size, I can determine the winner based on whether the Nim sum is zero or not.

But I need to find what that equivalent Nim heap size would be.

Alternatively, perhaps I can think in terms of the mex of the exponents in the binary representations.

But I'm stuck.

Let me try to think about the game in terms of its binary representations.

Wait, perhaps I can think about the number of moves required to empty all piles.

In the first test case, one move.

In the second test case, two moves.

In the third test case, seven moves.

In the fourth test case, three moves.

In the fifth test case, four moves.

In the sixth test case, five moves.

In the seventh test case, one move.

So, when the number of moves is odd, Alice wins; when even, Bob wins.

Therefore, perhaps the winner is determined by the parity of the number of moves required to empty all piles.

If that's the case, then I need to find the parity of the number of moves.

But how can I compute the number of moves or its parity efficiently?

Let me consider sorting the piles in ascending order: a1 <= a2 <= ... <= an.

Then, the number of moves seems to be equal to the number of times I can subtract 1 from the minimal nonempty pile.

Wait, in the third test case, sorted piles:1,2,3,4,7,9,100.

First move: choose k=1, subtract 1 from each, piles become:0,1,2,3,6,8,99.

Second move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,1,2,5,7,98.

Third move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,1,4,6,97.

Fourth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,3,5,96.

Fifth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,2,4,95.

Sixth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,1,3,94.

Seventh move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,0,2,93.

Eighth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,0,1,92.

Ninth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,0,0,91.

Wait, but in the earlier simulation, it seemed to take seven moves, but now it seems to take nine moves.

I must have made a mistake in the earlier simulation.

Wait, perhaps I need a better way to count the number of moves.

Let me think differently.

Suppose I sort the piles in ascending order: a1 <= a2 <= ... <= an.

Then, the minimal pile is a1.

Alice chooses k from 1 to a1.

Suppose she chooses k = a1, then all piles are reduced by a1, and the new piles are a2 - a1, a3 - a1, ..., an - a1, with a1 - a1 = 0.

So, the new nonempty piles are a2 - a1, a3 - a1, ..., an - a1, provided they are >=0.

This seems similar to the Euclidean algorithm for finding GCD, where you subtract the smaller number from the larger one.

But I'm not sure.

Wait, perhaps I can think of the game as a series of subtractions until all piles are empty.

But I need to find a pattern.

Let me consider that the total number of moves is equal to the number of times you can subtract 1 from the minimal nonempty pile.

Wait, in the third test case, sorted piles:1,2,3,4,7,9,100.

First move: choose k=1, subtract 1 from each, piles become:0,1,2,3,6,8,99.

Second move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,1,2,5,7,98.

Third move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,1,4,6,97.

Fourth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,3,5,96.

Fifth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,2,4,95.

Sixth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,1,3,94.

Seventh move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,0,2,93.

Eighth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,0,1,92.

Ninth move: choose k=1, subtract 1 from each nonempty pile, piles become:0,0,0,0,0,0,91.

Wait, now it seems to take nine moves, which is odd, and Alice wins, but in the earlier simulation, it seemed to take seven moves.

I must have miscounted earlier.

So, perhaps the number of moves is indeed nine, which is odd, and Alice wins.

But I need a general way to compute the number of moves or its parity.

Let me consider that each nonempty pile contributes to the number of moves.

Specifically, each pile will be involved in moves until it is reduced to zero.

So, perhaps the total number of moves is equal to the sum of the pile sizes divided by the number of piles.

But that doesn't make sense.

Wait, perhaps it's the sum of the pile sizes minus the number of piles.

But no, that doesn't seem right.

Wait, perhaps it's the sum of ceil(ai / k) for some k.

But this seems too vague.

Let me think differently.

Suppose I fix k and see how many moves are required.

But k changes with each move.

Wait, perhaps I can think recursively.

Define f(n, a1, a2, ..., an) as the number of moves in the game.

Then, f(n, a1, ..., an) = 1 + min over k in [1, a1] of f(n - s(k), a_{s(k)+1} - k, ..., an - k).

But this is too slow for large n.

I need a better approach.

Let me consider that the minimal pile size determines the number of moves.

Wait, in the first test case, minimal pile is 3, and it takes one move.

In the second test case, minimal pile is 1, and it takes two moves.

In the third test case, minimal pile is 1, and it takes nine moves.

This seems inconsistent.

Wait, perhaps I need to consider the differences between consecutive pile sizes.

Let me sort the piles: a1 <= a2 <= ... <= an.

Then, the number of moves is equal to a_n, assuming that a1 = a2 = ... = an.

Wait, no, in the first test case, a1 = a2 = ... = an = 3, and it takes one move.

But in general, it's not that simple.

Wait, perhaps the number of moves is equal to the number of piles minus the number of times you can group piles with equal sizes.

But I'm not sure.

Let me consider that each time you choose k, you're reducing the minimal pile to zero and reducing the other piles accordingly.

So, the number of moves might be equal to the number of distinct minimal pile sizes.

Wait, in the third test case, sorted piles:1,2,3,4,7,9,100.

First move: choose k=1, reduce all piles by 1.

Piles become:0,1,2,3,6,8,99.

Second move: choose k=1, reduce all nonempty piles by 1.

Piles become:0,0,1,2,5,7,98.

Third move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,1,4,6,97.

Fourth move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,0,3,5,96.

Fifth move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,0,2,4,95.

Sixth move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,0,1,3,94.

Seventh move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,0,0,2,93.

Eighth move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,0,0,1,92.

Ninth move: choose k=1, reduce nonempty piles by 1.

Piles become:0,0,0,0,0,0,91.

So, it took nine moves.

But what's the pattern here?

Wait, perhaps the number of moves is equal to the sum of the pile sizes minus the number of piles.

Wait, in the third test case, sum of piles is 1+3+9+7+4+2+100 = 126, number of piles is 7, so sum - n = 119, which is not equal to 9.

So, that doesn't hold.

Wait, perhaps it's the sum of the pile sizes minus the number of non-zero piles.

But in the third test case, sum is 126, number of non-zero piles is 7, 126 - 7 = 119, still not 9.

Not helpful.

Wait, perhaps it's the maximum pile size minus the minimal pile size.

In the third test case, max is 100, min is 1, 100 - 1 = 99, which is not 9.

Still not matching.

Wait, perhaps it's the number of times you can subtract 1 from the minimal pile.

But in the third test case, it took nine moves, but minimal pile was 1, so 1*9=9.

Wait, perhaps it's the sum of the pile sizes minus the number of piles.

But in the third test case, 126 - 7 = 119, which is not 9.

Wait, perhaps I need to think recursively.

Suppose I sort the piles and consider the differences between consecutive piles.

In the third test case:

sorted:1,2,3,4,7,9,100

Differences:1 to 2 (1), 2 to 3 (1), 3 to 4 (1), 4 to 7 (3), 7 to 9 (2), 9 to 100 (91).

Then, the number of moves is equal to the sum of these differences minus the number of differences.

But sum of differences is 1+1+1+3+2+91=99, minus 6 differences: 99 - 6 = 93, which is not 9.

Still not matching.

Wait, perhaps the number of moves is equal to the number of piles times the minimal pile size.

In