Alright, I have this problem to solve. Let's see what it's asking for. So, we have an undirected weighted graph with n vertices and m edges. The graph doesn't have loops or multiple edges between the same pair of vertices. It's also not necessarily connected. I need to find a simple cycle where the weight of the lightest edge is as minimal as possible.

First, I need to understand what a simple cycle is. A simple cycle is a path that starts and ends at the same vertex without passing through the same vertex or edge twice, except for the starting and ending vertex. So, no repeats except for the start and end being the same.

The problem asks for the lightest edge in the cycle to be as small as possible. So, among all possible simple cycles in the graph, I need to find one where the smallest edge weight is the smallest possible compared to all other cycles.

Looking at the input format, there are multiple test cases, each with n vertices and m edges. Each edge is defined by two vertices and a weight.

I need to output, for each test case, two numbers: b and k. b is the weight of the lightest edge in the found cycle, and k is the number of vertices in the cycle. Then, on the next line, list the vertices in the cycle in traversal order.

The problem states that there is always at least one simple cycle in the graph given the constraints, so I don't need to worry about cases where no cycle exists.

Let me think about how to approach this.

One way to find cycles in a graph is to perform a depth-first search (DFS) and look for back edges, which would indicate a cycle.

But I need to find a cycle where the lightest edge is as small as possible.

Maybe I can sort the edges by their weights and try to find cycles starting from the smallest weights.

Wait, but the problem involves finding a cycle where the minimum edge is as small as possible, not necessarily the cycle with the smallest maximum edge or anything like that.

I need to minimize the lightest edge in the cycle.

An idea comes to mind: use a union-find structure to keep track of connected components. As I add edges in order of decreasing weight, I can find cycles by identifying when adding an edge would connect two vertices that are already in the same connected component.

Wait, that seems promising.

So, if I sort the edges in decreasing order of their weights and start adding them to the union-find structure, whenever I try to add an edge between two vertices that are already connected, that means adding that edge would create a cycle.

Moreover, since I'm adding edges in decreasing order of weight, the lightest edge in that cycle would be the smallest weight among the edges in the cycle.

But wait, no. Actually, since I'm adding edges in decreasing order, the cycle would include the current edge and the path that already connects the two vertices through heavier edges.

So, the lightest edge in that cycle would be the smallest edge along that cycle.

But I need to make sure that this is indeed the cycle with the minimal lightest edge.

Hmm.

Let me think differently.

Suppose I consider the lightest edge in any cycle. If I can find a cycle where the lightest edge is as small as possible, that would be ideal.

Alternatively, I can think in terms of finding cycles and keeping track of the minimal lightest edge among all found cycles.

But that seems inefficient, especially given the constraints.

Wait, perhaps I can use the fact that in a graph, the minimal cycle basis can be found, and among those, find the one with the minimal lightest edge.

But that might be too complex.

Let me consider the union-find approach again.

If I sort the edges in decreasing order of weight and add them to the union-find structure, whenever I encounter an edge that would create a cycle (i.e., the two vertices are already connected), I can record that cycle.

Since I'm adding edges in decreasing order, the cycle found would have the current edge as part of it, and the other path connecting the two vertices would consist of heavier edges.

Therefore, the lightest edge in that cycle would be the current edge, which is the smallest in that cycle.

Wait, no. The current edge is the heaviest in that cycle because I'm adding edges in decreasing order.

So, in that case, the lightest edge in the cycle would be one of the heavier edges already present in the union-find structure.

Wait, I'm getting confused.

Let me try to clarify.

Suppose I sort the edges in decreasing order of weight and start adding them to the union-find structure.

When I add an edge that connects two vertices already in the same connected component, that edge forms a cycle with the existing edges between those two vertices.

In that cycle, the lightest edge would be the smallest weight among all edges in that cycle.

But since I'm adding edges in decreasing order, the cycle would include the current edge (which is heavy) and the path between the two vertices, which consists of heavier edges.

Wait, no. The path between the two vertices in the union-find structure consists of edges that were added before the current edge, which are heavier since I'm adding in decreasing order.

Therefore, the lightest edge in the cycle would be the smallest among the edges in the path connecting the two vertices, which are all heavier than the current edge.

Wait, but that's not necessarily true.

Actually, the path between the two vertices in the union-find structure might include edges that are lighter than the current edge.

Wait, no, since I'm adding edges in decreasing order, the edges added so far are heavier than the current edge.

Wait, but union-find keeps track of connected components, but it doesn't preserve the actual paths; it just keeps track of connectivity.

So, when I find that two vertices are already connected, I know there is some path between them, but I don't know what edges are on that path.

Therefore, I can't directly determine the lightest edge in that path.

This seems like a problem.

Maybe I need a different approach.

Another idea: for each edge, consider it as a candidate for being the lightest edge in some cycle.

So, for each edge, I can check if there is a path between its two vertices that doesn't include itself, and if such a path exists, then combining that path with the edge forms a cycle where the edge is the lightest one if its weight is less than or equal to all weights in the path.

But this seems too time-consuming, especially given the constraints.

Wait, perhaps I can iterate through the edges in increasing order of weight and for each edge, find if there is a path between its two vertices using only edges with heavier weights.

If such a path exists, then the lightest edge in the cycle would be this edge's weight.

Then, among all such cycles, I can choose the one with the smallest lightest edge.

This seems promising.

So, sort the edges in increasing order of weight.

For each edge, check if there is a path between its two vertices using only edges that are heavier than this edge.

If such a path exists, then this edge can be part of a cycle where it is the lightest edge.

Then, among all such edges, choose the one with the smallest weight.

To implement this efficiently, I can use a union-find structure.

Here's how:

Sort the edges in increasing order of weight.

Initialize a union-find structure with all vertices.

Iterate through the edges in order.

For each edge, check if the two vertices are already connected in the union-find structure.

If they are, that means there is a path between them using heavier edges, so the current edge, being lighter, is the lightest edge in that cycle.

Then, I can output this edge's weight and the cycle formed.

If they are not connected, add this edge to the union-find structure.

This seems efficient and fits within the time constraints, given that union-find operations are nearly O(1) per operation with path compression and union by rank.

Now, let's see how to reconstruct the cycle.

Once I find that adding an edge would create a cycle, I need to find the path between the two vertices in the current union-find structure and include the current edge to form the cycle.

But union-find doesn't directly provide the path.

So, I need a way to find the path between two vertices that are connected through the union-find structure.

One way to do this is to perform a DFS from one vertex to the other, using the edges that have been added to the union-find structure so far.

But that could be time-consuming for large graphs.

Alternatively, I can keep track of the parent nodes as I build the union-find structure, and then use that information to reconstruct the path when a cycle is found.

Yes, that sounds better.

So, I'll modify the union-find structure to keep track of the parent when uniting two sets.

Then, when I find that two vertices are already connected, I can use the parent information to reconstruct the path from one vertex to the other, and then add the current edge to form the cycle.

This should be efficient enough.

Let me outline the steps:

1. Sort all edges in increasing order of their weights.

2. Initialize a union-find structure with n vertices.

3. For each edge in the sorted order:

a. If the two vertices are already connected in the union-find structure:

i. Reconstruct the path between the two vertices using the parent information.

ii. Add the current edge to form the cycle.

iii. Output the weight of the current edge (which is the lightest in the cycle) and the cycle.

b. Else:

i. Unite the two vertices and record the parent for one of them.

4. Since the problem guarantees that at least one cycle exists, this approach should always find a valid cycle.

Now, let's look at the provided program and see if it implements this logic correctly.

Looking at the code:

- It reads the number of test cases T.

- For each test case, it reads n and m, then reads m edges with weights.

- It sorts the edges in decreasing order of weight (edges.sort(key=lambda x: -x[2]))

- It initializes a union-find structure with n vertices.

- It iterates through the sorted edges:

- For each edge (v, w, c), it checks if v and w are already connected in the union-find.

- If they are connected, it updates the answer with the minimum weight and records the vertices v0 and v1.

- If not connected, it unites them.

- After processing all edges, it performs a DFS starting from vertex v1 to find a cycle involving v0 and v1.

- It prints the lightest edge weight and the cycle.

First, sorting the edges in decreasing order of weight seems counterintuitive based on my earlier reasoning. I thought we should sort in increasing order to find the cycle with the minimal lightest edge.

Wait, maybe there's a reason for sorting in decreasing order.

Let me think again.

If I sort edges in decreasing order and add them to the union-find, when I find an edge that connects two already connected vertices, that means there is a path between them using heavier edges. So, the cycle formed would have the current edge (which is lighter compared to the path) as its lightest edge.

Wait, that makes sense.

So, by sorting in decreasing order and finding such edges, I can ensure that the lightest edge in the cycle is the current edge being considered.

Therefore, the minimal such edge would be the one with the smallest weight among all such cycles found.

So, in the code, it sorts edges in decreasing order of weight and iterates through them. For each edge that connects two already connected vertices, it updates the answer with the minimum weight and records the vertices v0 and v1.

Then, it performs a DFS starting from v1 to find a cycle involving v0 and v1.

Finally, it prints the lightest edge weight and the cycle.

This seems correct.

But let's verify with an example.

Take the first test case from the example:

6 6

1 2 1

2 3 1

3 1 1

4 5 1

5 6 1

6 4 1

After sorting in decreasing order, all edges have weight 1, so it doesn't matter. It will find any cycle where the lightest edge is 1.

The output is:

1 3

1 2 3

Which is correct.

Another test case:

6 6

1 2 10

2 3 8

3 1 5

4 5 100

5 6 40

6 4 3

After sorting in decreasing order:

edges sorted by weight descending: (1,2,10), (2,3,8), (3,1,5), (4,5,100), (5,6,40), (6,4,3)

Start adding them to union-find:

- Add (1,2,10)

- Add (2,3,8)

- Add (3,1,5)

- Add (4,5,100)

- Add (5,6,40)

- Add (6,4,3)

When adding (6,4,3), 6 and 4 are already connected through 5, so a cycle is found.

The lightest edge in this cycle would be 3, which matches the output.

So, the code seems to be working correctly.

One thing I noticed is that in the DFS part, it seems to be collecting the path from v1 to v0, but I'm not entirely sure if it's implemented correctly.

Looking at the DFS function:

def dfs(v):

global cycle, cycle_detected

d[v] = 1

dfs_route.append(v)

for w in g[v]:

if d[w]:

if w == v0 and len(dfs_route) > 2 and not cycle_detected:

cycle = [v for v in dfs_route]

flag = 1

continue

d[w] = 1

dfs(w)

dfs_route.pop()

It seems to be collecting the path from v1 to v0 and setting cycle when it finds v0.

But I think this might not always work correctly, especially if there are multiple paths from v1 to v0.

However, since the problem only asks for any cycle that satisfies the condition, it might be acceptable as long as it finds a valid cycle.

Given that the problem guarantees at least one cycle exists, and the union-find part seems correct, I think the overall approach is correct.

Therefore, I would say the given program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]