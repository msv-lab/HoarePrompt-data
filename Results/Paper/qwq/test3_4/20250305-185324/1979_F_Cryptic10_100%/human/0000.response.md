Alright, I've got this problem to solve. It's about finding a Hamiltonian path in a graph after some edges have been removed. The graph starts as a complete graph with n vertices, and then exactly (n - 2) edges are removed, leaving behind a graph that still has a Hamiltonian path, as guaranteed by the problem.

My task is to find this Hamiltonian path using an interactive approach, where I can ask queries about the graph and get responses based on those queries. The goal is to find the path in at most n queries.

First, I need to understand the problem and the interaction process clearly.

## Understanding the Problem

### Graph Properties

- **Complete Graph**: Initially, there's an edge between every pair of distinct vertices.

- **Edges Removed**: Exactly (n - 2) edges are removed from this complete graph.

- **Hamiltonian Path**: A path that visits each vertex exactly once. The problem states that such a path always exists under these constraints.

### Queries

I can ask queries of the form `? d`, where d is an integer between 0 and n-1 inclusive. For each query, Kostyanych responds with:

- The number of a vertex v that has a degree of at least d. Among such vertices, the one with the minimum degree is chosen, and if there are multiple, the one with the minimum number is selected.

- A vertex that is not connected to v (i.e., there is no edge between v and this vertex). If no such vertex exists, 0 is reported.

- After the response, vertex v is removed from the graph along with all its edges.

- If no vertex satisfies the degree condition, "0 0" is reported.

### Objective

Find a Hamiltonian path in the original graph using at most n queries.

## Approach

To solve this problem, I need to reconstruct the original graph or at least determine the order of vertices in the Hamiltonian path using the information gained from the queries.

### Key Observations

1. **Initial Graph Structure**: The graph starts as a complete graph with n vertices and (n*(n-1))/2 edges.

2. **Edges Removed**: Exactly (n - 2) edges are removed. So, the resulting graph has (n*(n-1))/2 - (n - 2) edges.

3. **Degree of Vertices**: In a complete graph, each vertex has degree (n - 1). After removing (n - 2) edges, the degrees of some vertices will be reduced.

4. **Hamiltonian Path Existence**: Since exactly (n - 2) edges are removed from a complete graph, and it's guaranteed that a Hamiltonian path exists, the graph remains highly connected.

### Strategy

1. **Identify High-Degree Vertices**: By querying higher degree thresholds, I can identify vertices that are still connected to many others.

2. **Build Path Incrementally**: Use the information from queries to build the Hamiltonian path step by step, ensuring that I don't break the path's connectivity.

3. **Track Removed Vertices**: Keep track of vertices that have been removed in previous queries to avoid considering them again.

4. **Determine Path Order**: Use the connections and disconnections indicated by the queries to determine the order of vertices in the path.

## Solution Code

To solve this problem, we need to find a Hamiltonian path in a graph that starts as a complete graph and has exactly (n - 2) edges removed. We achieve this through an interactive approach, querying about vertices' degrees and their connections.

### Approach

1. **Querying Degrees and Connections**:
   - Use queries of the form `? d` to find vertices with degrees at least `d`. The response includes a vertex `v` that meets the criteria and another vertex not connected to `v`.
   - Remove `v` from the graph after each query.

2. **Building the Path**:
   - Track the removed vertices and use the connection information to build the Hamiltonian path.
   - For vertices with limited connections, ensure they are placed correctly in the path.

3. **Edge Cases**:
   - Handle small graphs (n=2) directly.
   - Manage the order of operations to stay within the query limit.

### Solution Code

```python
import sys

def func():
    q = lambda d: print('? %d' % d, flush=True) or map(int, input().split())
    for _ in range(int(input())):
        (vx, ops) = (set(i for i in range(1, int(input()) + 1)), [])
        while len(vx) > 2:
            (v1, v2) = q(len(vx) - 2)
            vx.remove(v1)
            if v2 > 0:
                ops += [(v1, v2)]
            else:
                (v3, _) = q(0)
                vx.remove(v3)
                ops += [(v3, 0), (v1, 0)]
        (p1, p2) = (list(vx), [])
        for (v1, v2) in ops[::-1]:
            (p2 if p1[-1] == v2 else p1).append(v1)
        print('! %s' % ' '.join(map(str, p1[::-1] + p2)), flush=True)

if __name__ == "__main__":
    func()
```

### Explanation

1. **Query Function**:
   - `q(d)`: Sends a query with degree `d` and captures the response.

2. **Tracking Vertices**:
   - Use a set `vx` to keep track of remaining vertices.
   - `ops` list stores operations (removed vertices and their disconnected vertices).

3. **Query Loop**:
   - Continue querying until only two vertices remain.
   - For each query, remove the reported vertex and log the disconnected vertex if applicable.

4. **Path Construction**:
   - With two vertices left, build the path by reversing the operations.
   - Ensure the path remains Hamiltonian by correctly ordering the vertices based on connection information.

This approach ensures that we find the Hamiltonian path within the constraints of n queries.