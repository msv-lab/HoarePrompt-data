Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. The usual price for each bun is a coins. But to attract customers, he's running a promotion where he can choose some integer k (between 0 and the minimum of n and b) and sell the first k buns at a modified price. The price for the i-th bun (where i goes from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price a coins each.

My task is to help Bob determine the maximum profit he can obtain by selling all n buns.

First, I need to understand the promotion clearly. If Bob chooses k = 0, he sells all n buns at price a coins each, so the total profit is n * a. If he chooses k > 0, he sells the first k buns at decreasing prices starting from b coins down to (b - k + 1) coins, and the remaining (n - k) buns at price a coins each.

I need to find the value of k that maximizes the total profit.

Let me think about how to approach this. Since k can be up to 10^9 and t can be up to 10^4, I need an efficient way to compute the maximum profit for each test case without iterating over all possible k values, as that would be too slow.

I should look for a way to compute the maximum profit in constant time for each test case.

Let's consider the total profit when choosing a particular k:

Total profit = sum of prices of the first k buns + sum of prices of the remaining (n - k) buns.

The sum of prices of the first k buns is the sum of an arithmetic series starting from b coins down to (b - k + 1) coins.

The formula for the sum of the first k terms of an arithmetic series is:

sum = (k / 2) * (first term + last term)

So, sum of first k buns = (k / 2) * (b + (b - k + 1)) = (k / 2) * (2b - k + 1)

Sum of the remaining (n - k) buns = (n - k) * a

Therefore, total profit = (k / 2) * (2b - k + 1) + (n - k) * a

I need to maximize this expression with respect to k.

This is a quadratic equation in terms of k:

Total profit = (-1/2) * k^2 + (b + 1)/2 * k + (n - k) * a

Simplify:

Total profit = (-1/2) * k^2 + (b + 1)/2 * k + n * a - k * a

Total profit = (-1/2) * k^2 + [(b + 1)/2 - a] * k + n * a

This is a quadratic equation in k: (-1/2) * k^2 + c * k + n * a, where c = (b + 1)/2 - a

Since the coefficient of k^2 is negative (-1/2), the quadratic opens downwards, meaning it has a maximum value at its vertex.

The vertex of a parabola given by y = ax^2 + bx + c is at x = -b/(2a)

In this case, a = -1/2, b = (b + 1)/2 - a

So, the vertex is at k = -[(b + 1)/2 - a] / (2 * (-1/2)) = [(b + 1)/2 - a] / 1 = (b + 1)/2 - a

But k has to be an integer between 0 and min(n, b), inclusive.

So, the optimal k should be the integer closest to the vertex within the allowed range.

But since k has to be an integer, I need to check the floor and ceiling of the vertex value and see which one gives the maximum profit.

Wait, but in programming problems with large constraints, especially where n and b can be up to 10^9, I need a faster way.

Let me think differently.

Let's consider the difference in profit between choosing k and k-1.

Delta = profit(k) - profit(k-1)

If delta > 0, then choosing k is better than choosing k-1.

If delta < 0, then choosing k-1 is better.

So, I can find the point where delta changes from positive to negative.

Let's compute delta:

profit(k) = (k / 2) * (2b - k + 1) + (n - k) * a

profit(k-1) = ((k-1)/2) * (2b - (k-1) + 1) + (n - (k-1)) * a

Simplify profit(k-1):

= ((k-1)/2) * (2b - k + 2) + (n - k + 1) * a

Now, delta = profit(k) - profit(k-1)

= [(k / 2) * (2b - k + 1) + (n - k) * a] - [((k-1)/2) * (2b - k + 2) + (n - k + 1) * a]

Let's expand this:

= (k / 2)(2b - k + 1) + (n - k)a - ( (k-1)/2 )(2b - k + 2) - (n - k + 1)a

= (k / 2)(2b - k + 1) - ( (k-1)/2 )(2b - k + 2) - a

= [k(2b - k + 1) - (k-1)(2b - k + 2)] / 2 - a

Let's compute the numerator:

k(2b - k + 1) - (k-1)(2b - k + 2)

= k*2b - k^2 + k - (k-1)(2b - k + 2)

= k*2b - k^2 + k - [ (k-1)(2b) - (k-1)(k) + 2(k-1) ]

= k*2b - k^2 + k - [ 2b(k-1) - k(k-1) + 2(k-1) ]

= k*2b - k^2 + k - [ 2b k - 2b - k^2 + k + 2k - 2 ]

Wait, this is getting messy. Maybe there's a better way.

Let me consider that the additional bun when increasing k from k-1 to k is sold at price (b - k + 1), and one less bun is sold at price a.

So, delta = (b - k + 1) - a

We want delta >= 0 to prefer increasing k.

So, (b - k + 1) - a >= 0 => k <= b - a + 1

Therefore, as long as k <= b - a + 1, it's better to increase k.

When k > b - a + 1, it's better to stop increasing k.

So, the optimal k is min(n, b - a + 1)

Wait, but in the problem, k can be up to min(n, b), so I need to make sure that k doesn't exceed b.

Wait, but b can be less than b - a + 1.

Wait, no, b is at least 1, a is at least 1, n is at least 1.

Wait, but b can be less than b - a + 1 if a > 1.

Wait, let's see:

If a > b, then b - a + 1 < b, which could be less than or equal to 0.

But k cannot be negative, so k >= 0.

Wait, perhaps I need to consider:

If b - a + 1 <= 0, then the optimal k is 0.

Else, k = min(n, b - a + 1)

Wait, but b - a + 1 could be less than or equal to 0.

In that case, k <= b - a + 1 <= 0, so k = 0.

If b - a + 1 > 0, then k = min(n, b - a + 1)

Wait, but k also cannot exceed b, as per the problem statement.

Wait, the problem says k <= min(n, b)

So, k = min(n, b, b - a + 1)

But b - a + 1 could be less than or equal to b.

Wait, b - a + 1 <= b when a >= 1

So, effectively, k = min(n, b - a + 1)

Wait, but need to ensure k <= b.

But since b - a + 1 <= b when a >= 1, which it is, then k = min(n, b - a + 1)

Wait, but in the example:

First test case: n=4, a=4, b=5

b - a + 1 = 5 - 4 + 1 = 2

So, k = min(4, 2) = 2

But in the explanation, they choose k=1 for maximum profit.

Wait, maybe I'm missing something.

Wait, perhaps I need to reconsider.

Wait, in the first test case, choosing k=1 gives profit 5 + 4*3 = 5 + 12 = 17

Choosing k=2 gives profit 5 + 4 + 4*2 = 5 + 4 + 8 = 17

Choosing k=3 gives profit 5 + 4 + 3 + 4*1 = 5 + 4 + 3 + 4 = 16

Choosing k=4 gives profit 5 + 4 + 3 + 2 = 14

So, maximum is 17, achieved at k=1 and k=2.

So, in this case, k= min(n, b - a +1) = min(4, 5-4+1) = min(4,2) =2

Which gives profit 17, same as k=1.

But in the note, it says for the first test case, it's optimal to choose k=1.

But k=2 also gives the same profit.

So, it's acceptable to choose k=2 as well.

So, in general, choosing k up to min(n, b - a +1) gives the maximum profit.

Wait, but in the third test case:

n=10, a=10, b=5

b - a +1 = 5 -10 +1 = -4

So, k = min(n, -4) = -4, but k cannot be negative, so k=0

Which means sell all buns at price a=10, total profit 10*10=100

Which matches the note.

Another test case: n=5, a=5, b=11

b - a +1 = 11 -5 +1 =7

So, k = min(5,7)=5

So, sell first 5 buns at prices 11,10,9,8,7, total sum = 11+10+9+8+7=45

Remaining 0 buns, so total profit 45.

Which seems correct.

Another test case: n=1000000000, a=1000000000, b=1000000000

k = min(n, b - a +1) = min(10^9, 10^9 -10^9 +1) = min(10^9,1)=1

So, sell first 1 bun at price b=10^9, remaining 10^9 -1 buns at price a=10^9

Total profit = 10^9 *10^9 = 10^18

But in the note, it's given as 1000000000000000000, which is 10^18, so correct.

Another test case: n=1000000000, a=1000000000, b=1

k = min(n, b - a +1) = min(10^9,1 -10^9 +1)=min(10^9,1 -10^9 +1)=min(10^9,2 -10^9)

Since 2 -10^9 is negative, k=0

So, sell all buns at price a=10^9, total profit 10^9 *10^9 =10^18, which matches the note.

Last test case: n=1000, a=1, b=1000

k = min(n, b - a +1)=min(1000,1000-1+1)=min(1000,1000)=1000

So, sell first 1000 buns at prices from 1000 down to 1, sum is (1000*1001)/2=500500

Which matches the note.

So, the formula seems correct.

Therefore, the optimal k is min(n, b - a +1)

And the total profit is sum of the first k buns at modified prices plus sum of the remaining (n -k) buns at price a.

Now, to compute the sum of the first k buns:

Sum = k*(2b -k +1)/2

So, total profit = k*(2b -k +1)/2 + (n -k)*a

But in the code provided, it seems to have different conditions.

Let's look at the provided code:

def func():

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

So, it has three cases:

1. If b <= a, then sell all buns at price a, total profit n*a

2. If b - a >= n, then compute the sum as int((2 * b - n + 1) * n // 2)

3. Else, compute the sum as int((b - a) * (b - a + 1) // 2 + a * n)

I need to verify if this matches the optimal solution.

First case: b <= a

In this case, the modified prices for k >=1 are less beneficial than selling at price a.

Because the modified prices are b, b-1, ..., b-k+1

If b <= a, then b <= a, b-1 <= a-1, and so on.

So, selling at a is better than selling at modified prices.

Hence, k=0 is optimal, and total profit is n*a.

This matches the first case in the code.

Second case: b - a >= n

So, b - a >= n

In this case, the modified prices for k up to n are all at least a or more.

Because the k-th modified price is b - k +1

For k up to n, b - k +1 >= b - n +1

Since b - a >= n, then b - n >= a

So, b - k +1 >= b - n +1 >= a +1 -1 = a

Wait, b - n +1 >= a

So, b - k +1 >= a for k up to n.

Therefore, all modified prices are at least a.

Hence, to maximize profit, we should choose the maximum possible k, which is min(n, b).

But in this case, since k <= n and k <= b, and b - a >= n, which implies b >= a + n, and since a >=1, b >= n +1.

So, b >= n +1, so k can be up to n.

Therefore, choose k =n

Total profit = sum of first n modified prices.

Sum = n*(2b - n +1)/2

Which matches the second case in the code.

Third case: b - a < n

In this case, the modified prices for k up to b - a +1 are more beneficial than selling at price a.

Because, as earlier, k <= b - a +1 is the point where the additional profit from increasing k is positive.

Hence, optimal k is min(n, b - a +1)

In this case, since b - a < n, and k <= b, so k = min(n, b - a +1)

Then, total profit = sum of first k modified prices + (n -k)*a

Sum of first k modified prices = k*(2b -k +1)/2

But in the code, it's written as (b - a)*(b - a +1)/2 + a*n

Wait, that seems off.

Wait, perhaps they are computing it differently.

Wait, let's see.

In the third case, b - a < n

So, k = b - a +1, but need to ensure k <= n and k <= b

Since b - a < n, and k <= b, then k = b - a +1, provided that b - a +1 <= b, which it is.

So, k = b - a +1

Then, sum of first k modified prices = k*(2b -k +1)/2

And remaining (n -k)*a

So, total profit = k*(2b -k +1)/2 + (n -k)*a

But in the code, it's written as (b - a)*(b - a +1)/2 + a*n

Wait, is this equivalent?

Let me check.

Let me compute k = b - a +1

Then, sum of first k modified prices = k*(2b -k +1)/2

= (b - a +1)*(2b - (b - a +1) +1)/2

= (b - a +1)*(2b - b + a -1 +1)/2

= (b - a +1)*(b + a)/2

= (b - a +1)*(b + a)/2

Now, total profit = (b - a +1)*(b + a)/2 + (n - (b - a +1))*a

Simplify:

= (b - a +1)*(b + a)/2 + (n - b + a -1)*a

= [(b - a +1)*(b + a) + 2*(n - b + a -1)*a]/2

= [b^2 - a^2 + b + a + 2 n a - 2 b a + 2 a^2 - 2 a]/2

This seems messy and not equal to (b - a)*(b - a +1)/2 + a*n

So, perhaps the code has a mistake.

Wait, perhaps I misread the code.

Wait, in the code, for the third case, it's:

print(int((b - a) * (b - a + 1) // 2 + a * n))

Wait, but according to my earlier reasoning, it should be k = b - a +1, and sum of first k modified prices is k*(2b -k +1)/2, and remaining (n -k)*a

But in the code, it's (b - a)*(b - a +1)/2 + a*n

Which is different.

Wait, perhaps there's a different way to compute it.

Wait, maybe I need to think differently.

Wait, perhaps the code is incorrect in the third case.

Let me check with the first test case.

First test case: n=4, a=4, b=5

b - a =1

b - a +1=2

So, k=2

Sum of first 2 modified prices: 5 +4=9

Remaining 2 buns at 4 each: 8

Total profit:9 +8=17, which matches.

According to the code, since b - a =1 < n=4, it's the third case.

So, (b - a)*(b - a +1)/2 + a*n =1*2/2 +4*4=1 +16=17, which matches.

So, in this case, it's correct.

Another test case: n=5, a=5, b=9

b - a=4 < n=5

So, k =4 +1=5

Sum of first 5 modified prices:9+8+7+6+5=35

Remaining 0 buns:0

Total profit:35

According to the code: (9-5)*5*6/2 +5*5=4*5=20 +25=45, which doesn't match.

Wait, no, let's compute correctly.

(b - a)*(b - a +1)/2 + a*n =4*5/2 +25=10 +25=35, which matches.

So, it's correct.

Another test case: n=10, a=10, b=5

b - a=5-10=-5 < n=10

So, k = min(n, b - a +1)=min(10,-5+1)=min(10,-4)=0

Sum of first 0 modified prices:0

Remaining 10 buns at 10 each:100

According to the code: since b - a=-5 < n=10, it's the third case.

(b - a)* (b - a +1)/2 + a*n =(-5)*(-4)/2 +10*10=20/2 +100=10 +100=110, which doesn't match the expected 100.

Wait, there's a mistake here.

Wait, b - a +1=5-10+1=-4

So, k = min(n, b - a +1)=min(10,-4)=0

But in the code, it's taking b - a= -5, which is negative.

But in python, multiplying two negative numbers gives a positive result.

So, (b - a)* (b - a +1)/2 + a*n = (-5)*(-4)/2 +10*10=20/2 +100=10 +100=110

But actually, the correct profit is 100.

So, in this case, the code gives incorrect result.

Wait, but earlier test cases seemed correct.

Wait, perhaps the code handles negative values incorrectly.

Wait, in the third case, when b - a <0, which is possible, we need to handle it carefully.

In reality, when b - a <0, meaning b < a, which means the modified prices are less than a, so we should choose k=0.

But in the code, it still computes (b - a)*(b - a +1)/2 + a*n, which with b - a negative, gives a positive value because (-ve)*(-ve +1)/2 is positive.

But it's incorrect because in reality, when b < a, we should just choose k=0 and get n*a.

But in the code, it's adding a positive value to n*a, which overestimates the profit.

Wait, but in the first test case, b=5, a=4, b - a=1, which is positive, so it's fine.

In the third test case, b=5, a=10, b - a=-5, which is negative.

In this case, according to the code, (b - a)*(b - a +1)/2 + a*n = (-5)*(-4)/2 +10*10=10 +100=110

But actually, choosing k=0 gives 10*10=100, which is less than 110.

But according to the problem, k cannot be negative, so k=0 is the only option, and profit is 100.

So, the code is incorrect in this case.

Wait, but in the earlier reasoning, when b - a <0, it's similar to the first case where b <= a, which should choose k=0 and profit n*a.

But in the code, the first case is when b <= a, which chooses k=0.

But in the third case, it's when b - a >=0, which includes b - a =0.

Wait, no, the code has:

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

Wait, but in the third case, it's when b - a < n, which includes b - a <0.

So, in the third case, when b - a <0, the code computes a positive value, which is incorrect.

To fix this, perhaps the third case should only be when b - a >0, i.e., b > a.

Wait, perhaps the condition should be:

if b <= a:

choose k=0, profit n*a

elif b - a >= n:

choose k=n, profit sum of first n modified prices

else:

choose k = b - a +1, profit sum of first k