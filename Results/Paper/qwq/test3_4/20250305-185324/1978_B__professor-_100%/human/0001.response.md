Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. Normally, each bun costs a coins, but he's running a promotion to attract customers. The promotion works like this: he chooses some integer k (between 0 and the minimum of n and b), and for the first k buns sold, each one costs (b - i + 1) coins, where i is the ith bun sold. The remaining (n - k) buns are sold at the usual price of a coins each.

My task is to help Bob determine the maximum profit he can make by choosing the best k for each test case.

First, I need to understand the promotion clearly. If Bob chooses k = 0, he sells all n buns at price a coins each. If he chooses k = 1, he sells the first bun at b coins, and the remaining (n - 1) buns at a coins each. If k = 2, the first bun is sold at b coins, the second at (b - 1) coins, and the remaining (n - 2) buns at a coins each, and so on, up to k = min(n, b), where the first k buns are sold at decreasing prices starting from b down to (b - k + 1), and the remaining (n - k) buns at a coins each.

The goal is to maximize the total profit, which is the sum of the prices of all buns sold.

Let me think about when it makes sense to choose different values of k.

Case 1: b <= a

If the starting promotional price b is less than or equal to the usual price a, then selling any bun at a promotional price would not increase the profit; in fact, it would decrease it because b - i + 1 <= b <= a, and for i > 1, b - i + 1 could be even less. So, the best choice is to set k = 0 and sell all buns at price a coins each.

Case 2: b > a

If b is greater than a, then selling some buns at the promotional price could be beneficial because the initial promotional prices are higher than the usual price. But I need to find the optimal k that maximizes the total profit.

Let's consider the total profit for a given k:

Profit(k) = sum of prices of first k buns + sum of prices of remaining (n - k) buns

The sum of the first k buns' prices is the sum of an arithmetic series starting from b coins down to (b - k + 1) coins.

The sum of the first k terms of an arithmetic series is:

sum = k * (first term + last term) / 2 = k * (b + (b - k + 1)) / 2 = k * (2b - k + 1) / 2

The sum of the remaining (n - k) buns at price a coins each is:

sum = (n - k) * a

Therefore, the total profit is:

Profit(k) = [k * (2b - k + 1)] / 2 + (n - k) * a

I need to maximize this expression with respect to k, where k can be from 0 to min(n, b).

Let me consider that n and b can be up to 10^9, and t can be up to 10^4, so I need an efficient way to compute this for each test case, preferably in constant time per test case.

Let me see how to find the optimal k.

First, consider that k can range from 0 to min(n, b). Let m = min(n, b).

I need to find the k in 0 to m that maximizes Profit(k) = [k*(2b - k + 1)] / 2 + (n - k)*a

Let me rearrange this expression:

Profit(k) = (2b*k - k^2 + k)/2 + a*n - a*k

Simplify:

Profit(k) = (2b*k)/2 - (k^2)/2 + k/2 + a*n - a*k

Profit(k) = b*k - (k^2)/2 + k/2 + a*n - a*k

Combine like terms:

Profit(k) = (b - a)*k - (k^2)/2 + k/2 + a*n

Let me factor out k:

Profit(k) = [ (b - a) + (1/2) - (k)/2 ] * k + a*n

Wait, that doesn't seem helpful.

Alternatively, perhaps I can consider the difference in profit when increasing k by 1.

Let's compute Profit(k+1) - Profit(k):

Difference = { [ (k+1)*(2b - (k+1) + 1) ] / 2 + (n - (k+1))*a } - { [k*(2b - k + 1)] / 2 + (n - k)*a }

Simplify the expression:

Difference = [ (k+1)*(2b - k) ] / 2 + (n - k - 1)*a - [ k*(2b - k + 1) ] / 2 - (n - k)*a

Difference = [ (k+1)*(2b - k) - k*(2b - k + 1) ] / 2 + [ (n - k - 1)*a - (n - k)*a ]

Simplify numerator of first fraction:

(k+1)*(2b - k) - k*(2b - k + 1) = (2b(k+1) - k(k+1)) - (2b*k - k*(k - 1) + k)

= 2b*k + 2b - k^2 - k - 2b*k + k^2 - k - k

= 2b - 3k

Wait, that seems off. Let's redo this step.

Expand (k+1)*(2b - k):

= 2b(k+1) - k(k+1)

= 2b*k + 2b - k^2 - k

Expand k*(2b - k + 1):

= 2b*k - k^2 + k

Now subtract:

(2b*k + 2b - k^2 - k) - (2b*k - k^2 + k) = 2b*k + 2b - k^2 - k - 2b*k + k^2 - k = 2b - 2k

So, Difference = (2b - 2k)/2 + [ (n - k - 1)*a - (n - k)*a ]

Simplify:

Difference = (2b - 2k)/2 + [ -a ]

Difference = (b - k) - a

Difference = (b - a) - k

So, the difference in profit when increasing k by 1 is (b - a) - k.

This tells us that as long as (b - a) - k > 0, increasing k increases the profit. When (b - a) - k <= 0, increasing k decreases the profit.

Therefore, the optimal k is the largest integer such that (b - a) - k > 0, which means k < b - a.

So, the optimal k is k = b - a - 1, but k cannot be negative, and it also cannot exceed min(n, b).

Wait, let's think carefully.

From the difference, Profit(k+1) - Profit(k) = (b - a) - k.

We start with k = 0.

As long as (b - a) - k > 0, increasing k increases the profit.

So, we should increase k until (b - a) - k <= 0.

Therefore, the optimal k is the smallest integer k such that k >= b - a.

But k must be between 0 and min(n, b).

Wait, actually, (b - a) - k > 0 implies k < b - a.

So, as long as k < b - a, increasing k increases the profit.

At k = b - a, the difference is zero, and for k > b - a, the difference is negative.

Therefore, the optimal k is k = b - a, if b - a <= min(n, b).

But wait, k cannot exceed min(n, b).

So, the optimal k is the minimum of (b - a) and min(n, b).

Wait, m = min(n, b)

Then, k_opt = min(m, b - a)

Wait, but b - a could be greater than b or n.

Wait, no, b and a are both positive integers up to 1e9, n up to 1e9.

But, if b - a > b, that would imply a < 0, but a >=1, and b >=1.

Wait, b - a can be negative, zero, or positive.

Wait, in the earlier analysis, we had:

If b <= a, then k=0 is optimal, which matches the first case.

If b > a, then the optimal k is k = b - a, but only if b - a <= min(n, b).

Wait, but b - a could be larger than b or n.

Wait, b - a can be larger than b if a < b, but b - a cannot be larger than b since b >=1 and a >=1.

Wait, no, b - a can be up to b-1 if a=1.

Wait, but min(n, b) constrains k.

Wait, perhaps it's better to consider:

If b <= a, k=0 is optimal.

Else, k = min(b - a, min(n, b)) is optimal.

But let's verify this with examples.

Take first test case:

n=4, a=4, b=5

b - a =1

min(n, b)=4

So, k_opt = min(1,4)=1

Profit = sum of first k buns: 5 coins for first bun, then 4 coins each for remaining 3 buns: 5 + 4 + 4 + 4 =17

Which matches the example.

Second test case:

n=5, a=5, b=9

b - a=4

min(n,b)=5

k_opt = min(4,5)=4

Profit = sum of first 4 buns: 9,8,7,6 => 9+8+7+6 + 5 (for the fifth bun) = 35

Wait, but in the example, output is 35, which matches k=5.

Wait, but according to my earlier logic, k_opt=4, but in the example, k=5 is chosen.

Wait, perhaps I have a mistake.

Wait, in this case, b=9, a=5, n=5

b - a=4

min(n,b)=5

But in the example, k=5 is chosen, which is greater than b - a=4.

So, my earlier logic is incomplete.

Wait, perhaps I need to reconsider the optimal k.

Let me think again.

From the difference:

Profit(k+1) - Profit(k) = (b - a) - k

As long as (b - a) - k >0, increasing k increases profit.

When (b - a) - k <=0, increasing k decreases profit.

So, the optimal k is the value where (b - a) - k <=0, i.e., k >= b - a.

But k must be <= min(n,b).

So, if b - a <= min(n,b), then k_opt = b - a

Else, k_opt = min(n,b)

Wait, in the second test case, b - a=4, min(n,b)=5, so k_opt=4

But in the example, k=5 is chosen, which gives a higher profit.

Wait, perhaps I need to check the profit at k=b - a and k=min(n,b)

Wait, perhaps there is a mistake in my earlier analysis.

Let me recast the problem.

Define f(k) = sum_{i=1 to k} (b - i +1) + a*(n -k)

We need to maximize f(k) over k=0 to min(n,b)

Compute f(k) = sum_{i=1 to k} (b - i +1) + a*(n -k)

The sum is an arithmetic series: sum_{i=1 to k} (b - i +1) = k*b - k(k+1)/2 +k = k*(2b - k +1)/2

So, f(k) = k*(2b - k +1)/2 + a*(n -k)

We need to maximize f(k)

Let me consider f(k+1) - f(k):

f(k+1) - f(k) = [ (k+1)*(2b - (k+1) +1)/2 + a*(n - k -1) ] - [ k*(2b - k +1)/2 + a*(n -k) ]

Simplify:

= [ (k+1)*(2b - k) /2 + a*(n - k -1) ] - [ k*(2b - k +1)/2 + a*(n -k) ]

= [ (k+1)*(2b - k) - k*(2b - k +1) ] /2 + a*(n - k -1 - n +k)

= [ (2b(k+1) - k(k+1)) - (2b k - k^2 + k) ] /2 + a*(-1)

= [ 2b k + 2b - k^2 - k - 2b k + k^2 - k ] /2 - a

= [2b - 2k]/2 - a

= (b - k) - a

= (b - a) - k

So, f(k+1) - f(k) = (b - a) - k

This tells us that as long as (b - a) - k >0, f(k+1) > f(k), and profit increases.

When (b - a) - k =0, f(k+1) = f(k)

When (b - a) - k <0, f(k+1) < f(k), and profit decreases.

Therefore, the maximum profit occurs at the largest k such that (b - a) - k >=0, which is k <= b - a

But k also cannot exceed min(n,b)

Therefore, k_opt = min(b - a, min(n,b))

Wait, but in the second test case, b - a=4, min(n,b)=5, but choosing k=5 gives a higher profit than k=4.

Wait, according to my formula, k_opt=4, but in reality, k=5 gives a higher profit.

Wait, perhaps there is a mistake in this approach.

Let me compute for the second test case:

n=5, a=5, b=9

Option 1: k=4

Profit = sum of first 4 buns: 9,8,7,6 => 9+8+7+6=30 + 5*1=5 => total 35

Option 2: k=5

Profit = sum of first 5 buns:9,8,7,6,5 => 9+8+7+6+5=35

So, both k=4 and k=5 give the same profit of 35.

Wait, in this case, k_opt could be either 4 or 5.

But according to my earlier formula, k_opt = min(b - a, min(n,b)) = min(4,5)=4

But choosing k=5 also gives the same profit.

So, in this case, k_opt can be up to k=4, and beyond that, up to k=5, the profit remains the same.

Wait, because when k=4, f(k+1) - f(k) = (b - a) - k = (9-5) -4=0, so f(k+1)=f(k)

Hence, k=4 and k=5 give the same profit.

Therefore, any k from 4 to 5 gives the same profit, which is the maximum.

Hence, in this case, k_opt can be up to k=min(b - a, min(n,b))

But in general, I need to choose k_opt = min(b - a, min(n,b))

But in this specific case, k_opt =4 or 5 both work.

In the example, k=5 was chosen, but k=4 would also give the same profit.

Hence, my formula still holds.

Another test case:

n=10, a=10, b=5

b - a= -5

So, k_opt=0

Profit=10*10=100

Which matches the example.

Another test case:

n=5, a=5, b=11

b - a=6

min(n,b)=5

So, k_opt=min(6,5)=5

Profit=sum of first 5 buns:11,10,9,8,7 =>11+10+9+8+7=45

Which matches the example.

Another test case:

n=1000000000, a=1000000000, b=1000000000

b - a=0

k_opt=0

Profit=1000000000*1000000000=1000000000000000000

Which matches the example.

Another test case:

n=1000000000, a=1000000000, b=1

b - a=-999999999

k_opt=0

Profit=1000000000*1000000000=1000000000000000000

Which matches the example.

Another test case:

n=1000, a=1, b=1000

b - a=999

min(n,b)=1000

k_opt=min(999,1000)=999

Profit=sum of first 999 buns:1000 down to 1000-999+1=2 => sum from 2 to 1000

Wait, i starts from 1, so first bun is b=1000, second is 999, ..., up to k=999 is 1000-999+1=2

Then, remaining buns: n - k =1 bun at a=1 coin.

So, sum from 2 to 1000 is (1000*1001/2) -1 =500500 -1=500499 +1=500500

Wait, sum from 1 to 1000 is 1000*1001/2=500500, but the first bun is 1000, second is 999, ..., 999th is 2, and the 1000th is 1.

Wait, but in this case, k=999, so sum from first to 999th is 1000 down to 2, sum= sum from 2 to 1000, which is sum from 1 to 1000 minus 1, which is 500500 -1=500499, plus the last bun at a=1, so total profit=500499 +1=500500, which matches the example.

Hence, the formula seems correct.

So, in code, for each test case, we can compute k_opt = min(b - a, min(n,b))

Then, compute the sum of the first k_opt buns at promotional prices and the remaining (n - k_opt) buns at price a.

To compute the sum of the first k_opt buns:

sum = k_opt*(2*b - k_opt +1)/2

Then, add (n - k_opt)*a

Hence, the total profit is sum + (n - k_opt)*a

We need to handle large numbers, up to 1e9 for n, a, b, and t up to 1e4, so we need an efficient solution, preferably O(1) per test case.

Now, looking at the provided program:

def func():

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

Let's analyze this code.

First, it reads t, the number of test cases.

Then, for each test case, it reads n, a, b.

If b <= a, it sets k=0 and profit = n * a, which is correct.

Else, it checks if b - a >= n.

If b - a >= n, it computes the sum of the first n buns at promotional prices and the remaining (n - n)=0 buns at price a.

So, sum = n*(2*b - n +1)/2 + 0*a = n*(2*b - n +1)/2

Which matches the code: print(int((2 * b - n + 1) * n // 2))

Else, it computes sum = (b - a)*(b - a +1)/2 + a*n

Wait, is this correct?

Wait, according to my earlier analysis, k_opt = min(b - a, min(n,b))

In this code, when b - a < n, it sets k = b - a

Then, sum = k*(2*b - k +1)/2 + a*(n -k)

Which is sum = (b - a)*(2*b - (b - a) +1)/2 + a*(n - (b - a))

But in the code, it's print(int((b - a) * (b - a + 1) // 2 + a * n))

Wait, that's sum = (b - a)*(b - a +1)/2 + a*n

Which is different from what it should be.

Wait, what's wrong here.

Wait, sum of first k buns should be k*(2*b - k +1)/2

Here, k = b - a

So, sum = (b - a)*(2*b - (b - a) +1)/2 + a*(n - (b - a))

Simplify sum:

sum = (b - a)*(2*b - b + a +1)/2 + a*(n - b + a)

sum = (b - a)*(b + a +1)/2 + a*(n - b + a)

But in the code, it's (b - a)*(b - a +1)/2 + a*n

Which is different.

Hence, the code seems incorrect in this part.

Wait, perhaps there's a mistake in my reasoning.

Let me recast it.

Given k = b - a

sum = k*(2*b - k +1)/2 + a*(n -k)

Plug in k = b - a:

sum = (b - a)*(2*b - (b - a) +1)/2 + a*(n - (b - a))

sum = (b - a)*(2*b - b + a +1)/2 + a*(n - b + a)

sum = (b - a)*(b + a +1)/2 + a*(n - b + a)

But in the code, it's (b - a)*(b - a +1)/2 + a*n

Which is different.

Hence, the code is incorrect in this part.

So, the correct sum should be (b - a)*(b + a +1)/2 + a*(n - b + a)

But in the code, it's (b - a)*(b - a +1)/2 + a*n

Therefore, the code is incorrect.

Hence, the answer is Correctness: False

**Final Solution**

To solve this problem, we need to determine the maximum profit Bob can make by selling his buns under the given promotion scheme.

### Approach

1. **Understanding the Promotion:**
   - Bob can choose an integer \( k \) (where \( 0 \leq k \leq \min(n, b) \)).
   - The first \( k \) buns are sold at a modified price: the \( i \)-th bun is sold at \( b - i + 1 \) coins.
   - The remaining \( n - k \) buns are sold at the usual price \( a \) coins each.

2. **Determine the Optimal \( k \):**
   - If \( b \leq a \), it's better to set \( k = 0 \) and sell all buns at price \( a \).
   - If \( b > a \), we need to find the optimal \( k \) that maximizes the profit.
   
3. **Calculate the Profit:**
   - For a given \( k \), the profit is the sum of the first \( k \) modified prices plus the sum of the remaining \( n - k \) usual prices.
   - The sum of the first \( k \) modified prices is \( \frac{k \cdot (2b - k + 1)}{2} \).
   - The sum of the remaining \( n - k \) usual prices is \( a \cdot (n - k) \).

4. **Optimal \( k \) Calculation:**
   - The optimal \( k \) is \( \min(b - a, \min(n, b)) \).

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        a = int(data[index+1])
        b = int(data[index+2])
        index += 3
        if b <= a:
            print(n * a)
        else:
            m = min(n, b)
            k = min(b - a, m)
            sum_promo = k * (2 * b - k + 1) // 2
            sum_usual = a * (n - k)
            print(sum_promo + sum_usual)

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input:**
   - Read all input data at once for efficiency.
   - Parse the number of test cases \( t \).

2. **Processing Each Test Case:**
   - For each test case, read \( n \), \( a \), and \( b \).
   - If \( b \leq a \), set \( k = 0 \) and compute profit as \( n \times a \).
   - If \( b > a \), compute the optimal \( k \) as \( \min(b - a, \min(n, b)) \).
   - Calculate the sum of the first \( k \) modified prices and the sum of the remaining \( n - k \) usual prices.
   - Output the total profit.

3. **Efficiency Considerations:**
   - The solution handles up to \( 10^4 \) test cases efficiently with \( O(1) \) operations per test case.
   - Handles large values of \( n \), \( a \), and \( b \) up to \( 10^9 \) without issues.