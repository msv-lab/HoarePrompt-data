Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. Or output -1 if it's impossible.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if you can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ n-1) such that a[i-1] equals a[i+1], and replace a[i] with a[i-1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. And I can do this repeatedly until all elements are the same.

Now, the task is to make the array not beautiful by removing the least number of elements possible. If it's impossible to make it not beautiful, I should output -1.

Looking at the examples:

1. For n=3 and array [2,2,2], it's already all the same, and no matter how many elements I remove, it will still be beautiful because all remaining elements will be the same. So, output -1.

2. For n=5 and array [1,2,1,2,1], by removing one element, I can make it not beautiful.

3. For n=1, it's just one element, which is already beautiful, and I can't make it not beautiful by removing elements, so output -1.

4. For n=7 and array [3,3,3,5,3,3,3], by removing three elements, I can make it not beautiful.

From these examples, it seems that if all elements are the same, it's impossible to make it not beautiful, hence -1. Otherwise, I need to find a way to disrupt the array so that it's no longer possible to make all elements equal using the given operation.

Let me think about the properties of a beautiful array. If the array is already uniform, like all elements are the same, it remains beautiful no matter how many elements I remove, as long as at least one remains. So, in that case, the answer is -1.

If the array is not uniform, I need to see what's the minimal number of removals required to prevent it from becoming beautiful.

What does it mean for an array to not be beautiful? It means that even after performing the allowed operations any number of times, I cannot make all elements equal.

Given the operation allowed, I can change a[i] to a[i-1] or a[i+1] if a[i-1] == a[i+1]. So, essentially, I can propagate values from the ends towards the center, provided the neighboring elements are equal.

So, to make the array not beautiful, I need to ensure that after removals, I cannot make all elements equal by propagating values in this way.

I need to find the smallest number of elements to remove so that this propagation cannot lead to all elements being equal.

Let me consider the frequency of elements in the array. If there's an element that appears very frequently, say more than others, perhaps removing elements that are not equal to this frequent element could help in making the array beautiful. But I need to prevent that.

Wait, perhaps I need to look at the runs of consecutive equal elements.

If I have long runs of the same element, I can use the operation to make more elements equal to that run.

So, maybe I need to break up these runs by removing certain elements.

Wait, perhaps I should look at the most frequent element and see how many removals are needed to prevent its propagation.

Alternatively, maybe I can think in terms of the minimum number of removals to make the array not beautiful.

Let me consider that.

Suppose I have an array where one element dominates, appearing in many runs.

To make the array not beautiful, I need to ensure that even after performing the operations, not all elements can be made equal.

Wait, perhaps I can think about the minimal number of removals to prevent the array from being transformed into a uniform array.

Another way is to think about the minimal number of removals to ensure that there's no way to make all elements equal.

I need to disrupt the array such that no sequence of operations can make all elements equal.

Let me consider the following approach:

- Find the most frequent element.

- Find the minimal number of removals needed to prevent its propagation across the array.

But I'm not sure.

Wait, perhaps I can think about the array as a sequence where certain elements can be changed based on their neighbors.

If I can change any a[i] to a[i-1] or a[i+1] when a[i-1] == a[i+1], then to prevent the array from becoming beautiful, I need to ensure that there's no way to propagate a single value across the entire array.

Perhaps, I need to remove elements in such a way that there are at least two different elements that cannot be made equal.

Wait, maybe I need to ensure that there are at least two distinct elements that have no path of equal neighbors connecting them.

But that sounds complicated.

Let me look at the sample inputs and see if I can find a pattern.

First sample input:

n=3, arr=[2,2,2]

All elements are the same, so -1.

Second sample input:

n=5, arr=[1,2,1,2,1]

If I remove one element, for example, the last one, I get [1,2,1,2], which is not beautiful because I can't make all elements equal.

Third sample input:

n=1, arr=[1]

Only one element, which is already beautiful, and removing it would make the array empty, which is not considered beautiful, I suppose.

Fourth sample input:

n=7, arr=[3,3,3,5,3,3,3]

If I remove the first three elements, I get [5,3,3,3], which is not beautiful.

Wait, is there a better way to think about this?

Let me consider that in order for an array to be beautiful, it must be possible to propagate values in such a way that all elements become equal.

This seems similar to making the array connected in some way, where elements can influence each other through the operation.

Perhaps, I can model the array as a graph where elements are nodes, and there are edges between nodes that can influence each other.

Wait, maybe I can think in terms of connectivity.

If I have runs of the same element, they are connected.

And if I have positions where a[i-1] == a[i+1], then a[i] can be changed to that value, effectively connecting the two runs.

So, perhaps, the array can be seen as a graph where connected components are groups of elements that can be made equal.

To make the array beautiful, I need to have only one connected component, where all elements can be made equal.

Therefore, to make it not beautiful, I need to ensure that there are at least two connected components with different values that cannot be made equal.

So, the minimal number of removals would be the minimal number of elements to remove to disconnect the array into at least two components that cannot be made equal.

Wait, perhaps it's the minimal number of removals to prevent all elements from being made equal.

Alternatively, perhaps it's the size of the minimal vertex cut in the graph representation.

But this seems too complicated.

Let me consider another approach.

Suppose I find the minimal number of removals to prevent the array from being transformed into a uniform array.

I can look at the frequency of each element and see how many removals are needed to prevent any one element from dominating in a way that allows the array to become uniform.

Wait, perhaps I need to find the minimal number of removals such that no single element appears in all connected components.

But I'm getting stuck.

Let me look back at the code provided.

The code first checks if all elements are the same. If they are, it prints -1, which matches the first sample input.

Then, it initializes ans to positive infinity.

It sets val to arr[0] and cnt to 0.

Then, it iterates through the array, counting the number of consecutive elements equal to val.

Whenever it encounters a different element, it updates ans with the minimum of ans and cnt, and resets cnt for the new val.

Finally, it updates ans with the last cnt.

If the array is uniform, it prints -1; otherwise, it prints ans.

Wait, in the second sample input, n=5, arr=[1,2,1,2,1], the code would set val=1, cnt=1 (first 1), then encounter 2, update ans to min(ans,1), set val=2, cnt=1 (single 2), encounter 1, update ans to min(ans,1), set val=1, cnt=1 (last 1). Then, ans remains 1, which matches the sample output.

In the fourth sample input, n=7, arr=[3,3,3,5,3,3,3], val=3, cnt=3, encounter 5, update ans to min(ans,3), set val=5, cnt=1, encounter 3, update ans to min(ans,1), set val=3, cnt=3. So ans is min(3,1,3) which is 1, but the sample output is 3. Hmm, discrepancy here.

Wait, maybe I misread the sample output. Let me check.

Fourth sample input: n=7, arr=[3,3,3,5,3,3,3], sample output is 3.

But according to the code, ans would be min(3,1,3)=1, but sample output is 3.

So, perhaps the code is incorrect.

Wait, maybe I need to rethink the approach.

Let me consider what the code is doing.

It's finding the minimum length of consecutive runs of the same value.

In the second sample input, [1,2,1,2,1], the runs are:

1 (length 1), 2 (length 1), 1 (length1), 2 (length1), 1 (length1). So min is 1.

In the fourth sample input, [3,3,3,5,3,3,3], runs are:

3 (length 3), 5 (length1), 3 (length3). Min is1.

But the sample output is 3, which doesn't match the code's output.

So, perhaps the code is wrong.

Wait, maybe I need to think differently.

Perhaps, the minimal number of removals is equal to the minimal number of elements that, if removed, would disconnect the array in such a way that the remaining elements cannot all be made equal.

Alternatively, perhaps it's related to the number of times the most frequent element appears in the minimal run.

Wait, perhaps I need to find the minimal number of removals such that the remaining array cannot be made uniform.

Another way to think about it is: find the minimal number of removals such that there is no way to make all remaining elements equal.

So, if there are multiple distinct elements that cannot be made equal, then the array is not beautiful.

Given the operation allowed, if there's a dominant element that can be propagated through the array, then the array is beautiful.

So, perhaps, the minimal number of removals is equal to the minimal number of elements that need to be removed to prevent any one element from being propagatable throughout the array.

Wait, maybe it's the size of the minimal vertex cover in some graph representation.

This is getting too complicated.

Let me consider the following approach:

- Find the element that appears most frequently.

- Find the minimal number of removals needed to prevent this element from being propagatable throughout the array.

- This could be equivalent to breaking all paths through which this element can be propagated.

But I need a simpler way to compute this.

Looking back at the sample inputs:

First sample: all elements are the same, so -1.

Second sample: [1,2,1,2,1], by removing one element, I can make it not beautiful.

Third sample: only one element, so -1.

Fourth sample: [3,3,3,5,3,3,3], sample output is 3.

Wait, in the fourth sample, removing three elements seems excessive if according to my earlier logic it should be 1.

Wait, maybe there's something wrong with my understanding.

Let me try to manually check if removing one element from the fourth sample makes it not beautiful.

If I remove the 5, I get [3,3,3,3,3,3], which is beautiful.

If I remove one 3, I get [3,3,3,5,3,3,3] -> remove one 3, say the fourth element, [3,3,3,3,3,3], still beautiful.

Remove another 3, say the fifth, [3,3,3,5,3,3], now, can I make all elements equal?

Looking at the array [3,3,3,5,3,3]:

- I can choose i=4 (a[3]=3, a[5]=3), so replace a[4]=5 with 3, making the array [3,3,3,3,3,3], which is beautiful.

So, even after removing two 3's, it's still beautiful.

If I remove three 3's, for example, the first three, I get [5,3,3,3], which is not beautiful because I cannot make all elements equal.

Because [5,3,3,3], I can choose i=2 (a[1]=5, a[3]=3), but since a[1] != a[3], I cannot perform the operation.

Similarly, i=3 and i=4 cannot be chosen because their neighbors are not equal.

Hence, the array cannot be made beautiful by any operations.

So, in this case, removing three elements is necessary.

But according to the code's logic, it would output 1, but the sample output is 3.

Hence, the code is incorrect.

So, Correctness: False

**Final Answer**

\[ \boxed{\text{False}} \]