Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is represented by p_i. The key points are:

1. All p_i are distinct and p_i ≠ i, meaning no one is their own best friend, and best friendships are unique.

2. A friend comes to the party only if both they and their best friend receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

First, I need to understand the relationship between the friends and their best friends. Since p_i is the best friend of the i-th friend, and all p_i are distinct, this forms a permutation of the friends. Essentially, it's like a mapping where each friend is mapped to another unique friend.

Given that, I can think of this as a graph where each friend is a node, and there's a directed edge from friend i to friend p_i. Since p_i are distinct and p_i ≠ i, this graph will consist of disjoint cycles.

For example, if n=3 and p=[2,3,1], then friend 1's best friend is 2, friend 2's best friend is 3, and friend 3's best friend is 1. This forms a cycle of length 3.

Similarly, if n=4 and p=[2,3,4,1], it's a cycle of length 4.

If n=5 and p=[3,1,2,5,4], it's two cycles: 1→3→2→1 and 4→5→4.

So, the first step is to identify the cycles in this permutation.

Now, the condition for a friend to come to the party is that both they and their best friend receive an invitation. Since best friend is p_i, this means that for friend i to come, both i and p_i must be invited.

But, when you invite p_i, for p_i to come, you also need to invite p_{p_i}, and so on. It's a bit tricky.

Wait, no. The condition is that both the friend and their best friend receive an invitation, but it doesn't say anything about the best friend coming to the party, just that they have the invitation.

Wait, let's read the problem again carefully.

"The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, for friend i to come, both i and p_i must receive invitations. But p_i might or might not come, depending on whether p_i and p_{p_i} both receive invitations.

But the problem says that for friend i to come, both i and p_i must receive invitations. It doesn't depend on whether p_i comes or not, just that p_i receives an invitation.

So, in terms of the graph, if I invite friend i and their best friend p_i, then friend i will come. But if I only invite friend i without inviting p_i, friend i won't come.

Similarly, if I invite p_i but not i, then i won't come.

So, to make friend i come, I need to invite both i and p_i.

But, since p_i is also invited, if p_i's best friend p_{p_i} is also invited, then p_i will come, but that's not necessary for i to come.

Wait, no. The condition is only for i to come, both i and p_i need to be invited. It doesn't say anything about p_i coming; it just says that p_i receives an invitation.

So, for friend i to come, I need to invite both i and p_i, but I don't need to ensure that p_i comes, just that p_i is invited.

Moreover, each invitation is sent to exactly one friend, meaning that each friend can receive only one invitation.

Wait, no. Actually, the problem says "Each invitation is sent to exactly one of the friends." So, each invitation goes to one friend, and a friend can receive only one invitation.

But in the example, when n=5 and p=[3,1,2,5,4], and Monocarp sends invitations to [1,2,4,5], then friends [2,4,5] come.

Wait, friend 2 comes because both 2 and p_2=1 are invited.

Friend 4 comes because both 4 and p_4=5 are invited.

Friend 5 comes because both 5 and p_5=4 are invited.

But friend 1 is invited and p_1=3 is invited, but friend 1 doesn't come because p_1's invitation is not sufficient for friend 1 to come; it's the other way around.

Wait, no. For friend 1 to come, both friend 1 and friend p_1=3 need to be invited. In this case, both are invited, so friend 1 should come. But according to the example, friend 1 doesn't come because "the friend 1 won't come since his best friend didn't receive an invitation."

Wait, but in this case, friend 1's best friend is 3, and friend 3 is invited, and friend 1 is invited, so why doesn't friend 1 come?

Wait, perhaps there's a misunderstanding.

Wait, in the example, it's said that friend 1 won't come since his best friend didn't receive an invitation, but in this case, friend 3 did receive an invitation.

Wait, maybe I misread.

Wait, the example says: "The friend 1 won't come since his best friend didn't receive an invitation; the friend 3 won't come since he didn't receive an invitation."

Wait, but in this case, friend 3 did receive an invitation, as p_1=3 is invited.

Wait, no, in the example, Monocarp sends invitations to friends [1,2,4,5], so friends [2,4,5] come.

Wait, but according to the problem, friend 1 should come because both friend 1 and friend 3 are invited.

But the example says friend 1 won't come.

Wait, perhaps I misread the condition.

Wait, the problem says: "The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

Wait, perhaps I misinterpreted it.

Wait, let me read it again.

"The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, for friend i to come, both i and p_i must receive an invitation.

In the example, invitations are sent to [1,2,4,5].

So, friend 1 and friend 3 are invited, so friend 1 should come.

But according to the example, friend 1 doesn't come.

Wait, maybe I'm misunderstanding.

Wait, perhaps the condition is that both i and p_i must receive invitations, and p_i must also have p_{p_i} invited, and so on.

But no, the problem clearly states: "The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation."

So, in the example, friend 1 should come because both friend 1 and friend 3 are invited.

But the example says friend 1 won't come.

Wait, perhaps there's a misunderstanding in the example.

Wait, in the example, it's said: "The friend 1 won't come since his best friend didn't receive an invitation; the friend 3 won't come since he didn't receive an invitation."

Wait, but friend 3 did receive an invitation, so perhaps there's a mistake in the explanation.

Wait, perhaps I need to look back at the problem statement.

Wait, the problem says: "The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, for friend i to come, both i and p_i must be invited.

In the example, invitations are sent to [1,2,4,5].

So, friend 1 and friend 3 are invited, so friend 1 should come.

But according to the example, friend 1 doesn't come.

Wait, perhaps I need to consider that friend 3 doesn't come because he didn't receive an invitation.

Wait, but friend 3 did receive an invitation, as p_1=3 is invited.

Wait, perhaps the misunderstanding is that for friend i to come, both i and p_i must be invited, and p_i must also satisfy the condition to come, recursively.

But no, the problem says: "The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party)."

So, it's only necessary that both i and p_i are invited for friend i to come. It doesn't depend on whether p_i comes or not.

So, in the example, friend 1 should come because both friend 1 and friend 3 are invited.

But according to the example, friend 1 doesn't come.

Wait, perhaps there's a misunderstanding in the indices.

Wait, in the example, p = [3,1,2,5,4], so:

friend 1: p_1 = 3

friend 2: p_2 = 1

friend 3: p_3 = 2

friend 4: p_4 = 5

friend 5: p_5 = 4

Invitations are sent to [1,2,4,5].

So, friend 1 is invited, friend 3 is invited (p_1=3), so friend 1 should come.

Friend 2 is invited, friend p_2=1 is invited, so friend 2 should come.

Friend 3 is invited, friend p_3=2 is invited, so friend 3 should come.

Friend 4 is invited, friend p_4=5 is invited, so friend 4 should come.

Friend 5 is invited, friend p_5=4 is invited, so friend 5 should come.

But according to the example, only friends 2,4,5 come.

Wait, perhaps I'm misinterpreting the example.

Wait, perhaps the friends come only if both they and their best friend are invited, but their best friend doesn't necessarily come, unless their best friend also meets the condition.

Wait, but the problem says that for friend i to come, both i and p_i must be invited, and that's the only condition.

So, in this case, all friends should come, but in the example, it's stated that only friends 2,4,5 come.

Wait, perhaps there's a misunderstanding in the problem statement.

Wait, perhaps the friends come only if both they and their best friend are invited, and their best friend doesn't come unless they also meet the condition.

Wait, but the problem says: "The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party)."

So, it's only required that both i and p_i are invited for friend i to come. The state of p_i coming or not doesn't affect friend i's decision to come, as long as p_i is invited.

So, in this case, in the example, all friends should come, but according to the example, only friends 2,4,5 come.

Wait, perhaps there's a misunderstanding in the way invitations are sent.

Wait, perhaps inviting a friend means sending an invitation to that friend, but not necessarily to their best friend.

Wait, no, the problem says: "Each invitation is sent to exactly one of the friends."

And for friend i to come, both i and p_i must receive an invitation.

In the example, invitations are sent to [1,2,4,5].

So, friend 1 is invited, friend 3 is invited (since p_1=3), so friend 1 should come.

Friend 2 is invited, friend p_2=1 is invited, so friend 2 should come.

Friend 3 is invited, friend p_3=2 is invited, so friend 3 should come.

Friend 4 is invited, friend p_4=5 is invited, so friend 4 should come.

Friend 5 is invited, friend p_5=4 is invited, so friend 5 should come.

But according to the example, friends [2,4,5] come.

Wait, perhaps the misunderstanding is in the way invitations are counted.

Wait, perhaps inviting friend i includes inviting their best friend p_i automatically.

But no, the problem says: "Each invitation is sent to exactly one of the friends."

So, each invitation goes to one friend, and you have to choose which friends to invite.

Then, for a friend to come, both they and their best friend must be invited.

Wait, perhaps the confusion is in the way the example is explained.

Wait, in the example, it says: "The friend 1 won't come since his best friend didn't receive an invitation; the friend 3 won't come since he didn't receive an invitation."

But in the invitation list [1,2,4,5], friend 1 and friend 3 are both invited, so friend 1 should come.

Perhaps there's a mistake in the explanation.

Wait, perhaps the condition is that both the friend and their best friend must be invited, and their best friend must also come.

But the problem says: "The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party)."

So, it's only required that both i and p_i are invited for friend i to come.

Hence, in the example, all friends should come, but according to the example, only friends 2,4,5 come.

Wait, perhaps there's a misunderstanding in the way the invitations are sent.

Wait, perhaps inviting friend i includes inviting p_i automatically.

But no, the problem says "Each invitation is sent to exactly one of the friends."

So, each invitation goes to one friend, and you have to choose which friends to invite.

In the example, invitations are sent to [1,2,4,5].

So, friend 1 is invited, friend 2 is invited, friend 4 is invited, friend 5 is invited.

Friend 3 is p_1=3, so friend 3 is invited because p_1=3 is invited.

Wait, no, p_i is the best friend of i, so p_1=3 means friend 3 is the best friend of friend 1.

But in the invitation list, friend 3 is not directly invited unless p_i=3 is invited.

Wait, I'm getting confused.

Wait, perhaps I need to think differently.

Let's think in terms of the graph.

Since p_i is a permutation without fixed points, it forms a disjoint cycles.

In the first example, p=[3,1,2,5,4], which forms two cycles: 1→3→2→1 and 4→5→4.

Now, to have at least two friends come, we need to choose a set of invitations such that at least two friends have both them and their best friend invited.

In the first cycle, 1→3→2→1, to have friend 1 come, we need to invite both 1 and 3.

To have friend 3 come, we need to invite both 3 and 2.

To have friend 2 come, we need to invite both 2 and 1.

Similarly, in the second cycle, 4→5→4, to have friend 4 come, we need to invite both 4 and 5.

To have friend 5 come, we need to invite both 5 and 4.

Now, in the first cycle, if we invite 1 and 3, then friend 1 and friend 3 will come, because:

- Friend 1: invited and p_1=3 is invited.

- Friend 3: invited and p_3=2 is not invited, so friend 3 doesn't come.

Wait, but according to the problem, friend 3 should come only if both friend 3 and p_3=2 are invited.

So, in this case, friend 3 is invited, but p_3=2 is not invited, so friend 3 doesn't come.

Similarly, friend 1 is invited and p_1=3 is invited, so friend 1 should come.

But in this scenario, only friend 1 comes.

Wait, but according to the problem, friend 1 should come because both friend 1 and friend 3 are invited.

But friend 3 doesn't come because friend 2 is not invited.

But the problem says that friend 3 comes only if both friend 3 and friend 2 are invited.

So, in this case, friend 3 doesn't come.

Hence, only friend 1 comes.

But we need at least two friends to come.

So, in this cycle, to have two friends come, we need to invite more friends.

If we invite 1, 3, and 2, then:

- Friend 1: invited and p_1=3 is invited → comes.

- Friend 3: invited and p_3=2 is invited → comes.

- Friend 2: invited and p_2=1 is invited → comes.

So, all three come.

But the problem says in the first test case, sending invitations to [4,5] makes friends [4,5] come, which seems contradictory because according to the above, in the first cycle, inviting 1 and 3 should make friend 1 come, but friend 3 doesn't come because friend 2 is not invited.

Wait, perhaps I need to think differently.

Wait, perhaps in a cycle of length k, to have m friends come, I need to invite certain friends such that m pairs (i, p_i) are both invited.

Wait, perhaps it's better to think in terms of selecting edges in the cycle.

Wait, perhaps I need to select a subset of friends to invite such that at least two friends have both them and their best friend invited.

This seems complicated.

Let's look at the provided program and see what it's doing.

The program:

t = int(input())

for i in range(t):

func_1()

def func_1():

n = int(input())

v = [0] * (n + 1)

v = [0] + list(map(int, input().split()))

if n == 2:

print(2)

else:

for i in range(1, n + 1):

if v[v[v[i]]] == i:

print(2)

return

print(3)

So, for each test case, it reads n and the list p_i.

If n == 2, it prints 2.

Else, for each friend i from 1 to n, it checks if v[v[v[i]]] == i. If for any i this is true, it prints 2 and returns.

Otherwise, it prints 3.

So, it seems that the program is trying to find a cycle where v[v[v[i]]] == i, and in such cases, it can achieve the goal with 2 invitations, else it needs 3.

But, from the earlier analysis, in a cycle of length 3, inviting 2 friends might not be sufficient because both friends and their best friends need to be invited.

Wait, in the first example, n=5, p=[3,1,2,5,4], which has two cycles: 1→3→2→1 and 4→5→4.

For i=1: v[1]=3, v[3]=2, v[2]=1, so v[v[v[1]]]=1, which matches i=1, so it prints 2.

Similarly, for i=4: v[4]=5, v[5]=4, v[4]=5 ≠ 4, so it doesn't satisfy.

For i=5: v[5]=4, v[4]=5, v[5]=4 ≠ 5.

So, for i=1, it satisfies v[v[v[i]]]==i, so it prints 2.

But according to the earlier confusion, in this case, inviting 1 and 3 should make friend 1 come, but friend 3 doesn't come because friend 2 is not invited.

But according to the program, it's sufficient to invite 2 friends.

Wait, perhaps the program is considering that in cycles of length 3, inviting 2 friends is sufficient to make at least 2 friends come.

Wait, in the cycle 1→3→2→1, if we invite friend 1 and friend 2, then:

- Friend 1: invited and p_1=3 is not invited → doesn't come.

- Friend 2: invited and p_2=1 is invited → comes.

- Friend 3: invited or not? Friend 3 is not invited in this scenario.

So, only friend 2 comes.

But we need at least 2 friends to come.

So, inviting 1 and 2 makes only friend 2 come.

If we invite 1 and 3:

- Friend 1: invited and p_1=3 is invited → comes.

- Friend 3: invited and p_3=2 is not invited → doesn't come.

- Friend 2: invited or not? Friend 2 is not invited.

So, only friend 1 comes.

If we invite 2 and 3:

- Friend 2: invited and p_2=1 is not invited → doesn't come.

- Friend 3: invited and p_3=2 is invited → comes.

- Friend 1: invited or not? Friend 1 is not invited.

So, only friend 3 comes.

So, in all cases of inviting 2 friends in a cycle of length 3, only one friend comes.

Hence, to have at least 2 friends come, we need to invite 3 friends.

For example, inviting 1,2,3:

- Friend 1: invited and p_1=3 is invited → comes.

- Friend 2: invited and p_2=1 is invited → comes.

- Friend 3: invited and p_3=2 is invited → comes.

So, all three come.

Hence, in a cycle of length 3, inviting 3 friends is necessary to have at least 2 friends come.

But according to the program, in cycles where v[v[v[i]]]==i, it prints 2, meaning that inviting 2 friends is sufficient.

But according to my analysis, it's not sufficient.

Wait, perhaps I'm missing something.

Wait, maybe in some cycles of length 3, inviting 2 friends is sufficient.

Wait, in the first example, n=5 with cycles 1→3→2 and 4→5.

In this case, inviting 4 and 5 makes both come because:

- Friend 4: invited and p_4=5 is invited → comes.

- Friend 5: invited and p_5=4 is invited → comes.

So, both come, and only 2 invitations are needed.

Hence, in cycles of length 2, inviting 2 friends is sufficient.

In cycles of length 3, inviting 2 friends is not sufficient, as per my earlier analysis.

Wait, but in the program, for n >=3, it checks if v[v[v[i]]]==i for any i, which would be true for cycles of length 3.

And in such cases, it prints 2, which contradicts my earlier conclusion.

Wait, perhaps in cycles of length 3, there is a way to invite 2 friends and have at least 2 come.

Wait, let's think differently.

Suppose we have a cycle of length 3: 1→3→2→1.

If we invite friend 1 and friend 2:

- Friend 1: invited and p_1=3 is not invited → doesn't come.

- Friend 2: invited and p_2=1 is invited → comes.

- Friend 3: not invited.

So, only friend 2 comes.

If we invite friend 1 and friend 3:

- Friend 1: invited and p_1=3 is invited → comes.

- Friend 3: invited and p_3=2 is not invited → doesn't come.

- Friend 2: not invited.

So, only friend 1 comes.

If we invite friend 2 and friend 3:

- Friend 2: invited and p_2=1 is not invited → doesn't come.

- Friend 3: invited and p_3=2 is invited → comes.

- Friend 1: not invited.

So, only friend 3 comes.

Hence, in all cases of inviting 2 friends in a cycle of length 3, only one friend comes.

Therefore, to have at least 2 friends come, we need to invite 3 friends.

But according to the program, in cycles of length 3, it prints 2, which seems incorrect based on this analysis.

Wait, perhaps the program is considering that in cycles of length 3, inviting 2 friends is sufficient, but as shown, it's not.

Wait, perhaps the program is wrong.

Wait, but in the first test case, n=5 with cycles 1→3→2 and 4→5, and the program prints 2, which matches the sample output.

But according to my earlier confusion, in this case, inviting 4 and 5 makes friends 4 and 5 come, which is correct.

But in a pure cycle of length 3, like n=3, p=[2,3,1], according to the program, v[v[v[1]]]=1, so it prints 2.

But according to my analysis, in such a case, inviting 2 friends is not sufficient to have at least 2 friends come.

Wait, perhaps I'm missing something.

Wait, perhaps in cycles of length 3, inviting 2 specific friends can make 2 friends come.

Wait, suppose in the cycle 1→3→2→1, we invite friend 1 and friend 2.

Then:

- Friend 1: invited and p_1=3 is not invited → doesn't come.

- Friend 2: invited and p_2=1 is invited → comes.

- Friend 3: not invited.

So, only friend 2 comes.

Wait, but perhaps there's another way to choose which friends to invite.

Wait, suppose we invite friend 2 and friend 3.

Then:

- Friend 2: invited and p_2=1 is not invited → doesn't come.

- Friend 3: invited and p_3=2 is invited → comes.

- Friend 1: not invited.

So, only friend 3 comes.

Similarly, inviting friend 1 and friend 3:

- Friend 1: invited and p_1=3 is invited → comes.

- Friend 3: invited and p_3=2 is not invited → doesn't come.

- Friend 2: not invited.

So, only friend 1 comes.

Hence, in all cases, only one friend comes when inviting 2 friends in a cycle of length 3.

Therefore, to have at least 2 friends come, we need to invite 3 friends.

Hence, the program is incorrect for cycles of length 3.

Wait, but in the first test case, n=5 with cycles 1→3→2 and 4→5, and the program prints 2, which matches the sample output.

But according to the sample explanation, inviting 4 and 5 makes friends 4 and 5 come.

So, in this case, it's correct.

But in a pure cycle of length 3, like n=3, p=[2,3,1], the program prints 2, but according to my analysis, inviting 2 friends is not sufficient to have at least 2 friends come.

Hence, the program is incorrect for cycles of length 3.

Wait, perhaps I'm missing a way to invite 2 friends in a cycle of 3 to make 2 friends come.

Is there any way?

Wait, suppose in n=3, p=[2,3,1], and we invite friend 1 and friend 2.

Then:

- Friend 1: invited and p_1=2 is invited → comes.

- Friend 2: invited and p_2=3 is not invited → doesn't come.

- Friend 3: not invited.

So, only friend 1 comes.

Wait, in this case, p_1=2, but in the earlier analysis, p_1=3.

Wait, in n=3, p=[2,3,1], so:

friend 1: p_1=2

friend 2: p_2=3

friend 3: p_3=1

So, cycle is 1→2→3→1.

If we invite friend 1 and friend 2:

- Friend 1: invited and p_1=2 is invited → comes.

- Friend 2: invited and p_2=3 is not invited → doesn't come.

- Friend 3: not invited.

So, only friend 1 comes.

If we invite friend 2 and friend 3:

- Friend 2: invited and p_2=3 is invited → comes.

- Friend 3: invited and p_3=1 is not invited → doesn't come.

- Friend 1: not invited.

So, only friend 2 comes.

If we invite friend 1 and friend 3:

- Friend 1: invited and p_1=2 is not invited → doesn't come.

- Friend 3: invited and p_3=1 is invited → comes.

- Friend 2: not invited.

So, only friend 3 comes.

Hence, in all cases of inviting 2 friends in a cycle of length 3, only one friend comes.

Therefore, to have at least 2 friends come, we need to invite 3 friends.

Hence, the program is incorrect for cycles of length 3.

Wait, but according to the program, for n >=3, if v[v[v[i]]]==i for any i, it prints 2.

In the n=3, p=[2,3,1], v[v[v[1]]]=v[v[2]]=v[3]=1, which matches i=1, so it prints 2.

But according to the analysis, inviting 2 friends is not sufficient to have at least 2 friends come.

Hence, the program is incorrect.

Wait, perhaps the program is considering that in cycles of length 3, inviting 2 friends is sufficient, but as shown, it's not.

Hence, the program is incorrect.

But in the first test case, it works correctly because there's a cycle of length 2 (4→5→4), and inviting 2 friends in this cycle makes 2 friends come.

But in pure cycles of length 3, it's incorrect.

Wait, in the first test case, n=5 with cycles 1→3→2 and 4→5, and the program prints 2 because v[v[v[1]]]==1.

But in reality, inviting 2 friends in the cycle 1→3→2 doesn't make 2 friends come, but in the cycle 4→5, inviting 4 and 5 makes both come.

Hence, perhaps in such cases, where there are multiple cycles, and at least one cycle of length 2, inviting 2 friends in the cycle of length 2 is sufficient.

But in the program, it doesn't seem to consider the structure of multiple cycles; it just checks if any i satisfies v[v[v[i]]]==i.

Hence, the program might be incorrect in some cases.

Wait, perhaps the program is correct because in the presence of a cycle of length 2, inviting 2 friends from that cycle is sufficient to have at least 2 friends come.

In the first test case, n=5 with cycles 1→3→2 and 4→5, inviting 4 and 5 makes both come, so it's sufficient.

Hence, in such cases, even if there are cycles of length 3, if there's a cycle of length 2, inviting 2 friends from the cycle of length 2 is sufficient.

Hence, the program might be correct in this regard.

But in the second test case, n=4, p=[2,3,4,1], which is a single cycle of length 4: 1→2→3→4→1.

In this case, v[v[v[1]]]=v[v[3]]=v[4]=1, so the program prints 2.

But according to the sample output, it should be 3.

Hence, the program is incorrect.

Wait, in the second test case, n=4, p=[2,3,4,1], which is a single cycle of length 4.

According to the program, v[v[v[1]]]=v[v[3]]=v[4]=1, so it prints 2.

But according to the sample output, it should be 3.

Hence, the program is incorrect.

Wait, but according to the sample explanation, in this case, inviting 1,2,3 makes friends 1 and 2 come.

But according to the program, it prints 2, which contradicts the sample output of 3.

Hence, the program is incorrect.

Therefore, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]