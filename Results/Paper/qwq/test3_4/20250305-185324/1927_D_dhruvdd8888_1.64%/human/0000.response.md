Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and a set of queries. Each query gives me a range within this array, and I need to find two indices within that range such that the elements at those indices are different. If such a pair doesn't exist, I should return -1 for both indices.

First, I need to understand the constraints. There are up to 10^4 test cases, and for each test case, the array can have up to 2*10^5 elements, and up to 2*10^5 queries. So, efficiency is key here; I need an algorithm that can handle large inputs within reasonable time limits.

Let me think about how to approach this. For each query, I need to check if there are at least two different elements in the specified range of the array. The straightforward way would be to iterate through the range and check for differences, but that would be too slow for the given constraints, as it would result in O(Q*N) time complexity, which is not feasible when Q and N are both up to 2*10^5.

I need a smarter way to handle this. One idea is to precompute some information about the array that can help me answer the queries quickly.

Let's consider preprocessing the array to identify where changes occur. That is, find the positions where the element changes value compared to the previous one. By identifying these positions, I can determine if there are different elements in any given range efficiently.

So, I can iterate through the array and record the positions where the element changes. Then, for each query, I can check if there is at least one change within the specified range. If there is, that means there are at least two different elements in that range.

To implement this, I can create a list of tuples, where each tuple contains the start and end indices of a sequence of identical elements. For example, if the array is [1, 1, 2, 1, 1], the list would be [(1, 2, 1), (3, 3, 2), (4, 5, 1)], indicating that from index 1 to 2 the element is 1, index 3 is 2, and index 4 to 5 is 1.

Once I have this list, for each query, I can use binary search to find the first segment that starts at or after the left boundary of the query, and then check if there is more than one segment within the query's range. If there is more than one segment, that means there are different elements in the range. If there's only one segment, I need to check if that segment contains different elements, which would only be possible if the segment has more than one index.

Wait, but in the preprocessing step, each segment represents a sequence of identical elements, so if there's more than one segment in the query range, there are different elements. If there's only one segment, all elements in that range are the same.

Therefore, for each query, I can use binary search to find the segments that overlap with the query range and check if there's more than one such segment.

Let me think about how to implement this in code. I'll need to use the bisect module in Python for binary search.

Looking at the given code, it seems like the author is trying to implement this idea. Let's analyze the code step by step to see if it's correct.

First, the code reads the number of test cases, tc, and then calls func_1() for each test case.

In func_1():

- It reads the input values: N (length of the array), the array nums, and Q (number of queries).

- It initializes variables s and e to 0, and num to the first element of nums.

- It appends -1 to nums to handle the last segment.

- It iterates through nums to create arr, which contains tuples of (start index, end index, value) for each segment of identical elements.

- It calculates LA as the length of arr minus one.

- Then, for each query, it reads l and r, and proceeds to answer the query based on the precomputed arr.

Now, let's look at how it answers each query.

It uses bisect_left to find the leftmost segment in arr that starts at or after l.

Then, it gets the segment at index min(eli, LA), which is (s, e, _).

Now, it has some conditions to check:

1. If s > l:

- If s == 1, print -1 -1

- Else, print s-1 s

2. Elif e >= r:

- Print -1 -1

3. Elif e < N:

- Print s e+1

4. Else:

- Print -1 -1

This seems a bit messy. Let's try to understand what's happening here.

The goal is to determine if there are two different elements in the range [l, r], and if so, return their indices.

Given that arr contains segments of identical elements, if there is more than one segment in [l, r], that means there are different elements.

If there's only one segment in [l, r], then all elements in that range are the same, so we should return -1 -1.

So, the correct approach should be:

- Use binary search to find the first segment that starts at or after l.

- Then, find all segments that end before or at r.

- If there is more than one such segment, return indices from different segments.

- If there's only one segment, check if that segment has more than one element; if it does, return any two different indices within that segment (though they would be the same element, which doesn't satisfy a_i != a_j); if it's only one element, return -1 -1.

Wait, but since all elements in a segment are the same, if there's only one segment in [l, r], and it has more than one element, all elements are the same, so we still should return -1 -1.

Wait, no. If there's only one segment in [l, r], and that segment has multiple elements, but since all elements in the segment are the same, there are no two different elements in the range.

But, according to the problem, we need to find i and j such that a_i != a_j.

So, if all elements in [l, r] are the same, we should return -1 -1.

If there are at least two different elements, return any two indices with different values.

Looking back at the code, it seems the conditions are not correctly implementing this logic.

For example, in the first condition:

If s > l:

- If s == 1, print -1 -1

- Else, print s-1 s

This seems incorrect. If s > l, that means there is a segment before s, which would mean there are different elements in [l, r].

But the code is printing s-1 and s, which might not be within [l, r].

Wait, indices are 1-based, so s-1 could be less than l.

Similarly, in the second condition:

Elif e >= r:

Print -1 -1

This might not be correct, because even if e >= r, there could be multiple segments in [l, r].

Wait, no. If e >= r, and it's the segment that starts at s, then if s <= l, and e >= r, that means the entire [l, r] is covered by this single segment, so all elements are the same, so print -1 -1.

But, we need to consider if there are multiple segments in [l, r].

Wait, perhaps the code is trying to check if there's only one segment in [l, r].

But it's a bit convoluted.

Let me try to think of a better way to implement this.

I'll use the bisect module to find the first segment that starts at or after l, and the last segment that ends at or before r.

Then, count how many segments are within this range.

If there is more than one segment, that means there are different elements.

If there's only one segment, check if its length is greater than 1, but since all elements in a segment are the same, even if the segment has multiple elements, they are all the same, so we should return -1 -1.

Therefore, the correct condition is: if there is more than one segment in [l, r], print any two indices from different segments; else, print -1 -1.

In the code, it seems like it's not correctly implementing this.

Moreover, in the problem statement, it's mentioned that l and r are 1-based indices.

So, in the array nums, indices start from 1 to N.

In Python, lists are 0-based, so we need to be careful with indexing.

Wait, in the given code, nums is read with 0-based indexing, but the segments in arr have 1-based indices.

That seems inconsistent, but perhaps it's handled correctly.

Let me look at how arr is constructed.

arr contains tuples of (start, end, value), where start and end are 1-based indices.

In Python, when iterating through nums, which is 0-based, the indices need to be adjusted accordingly.

Wait, in the code, when creating arr:

for i in range(N + 1):

if nums[i] != num:

arr.append((1 + s, i, num))

s = i

num = nums[i]

Here, nums has N elements, and then -1 is appended.

But in Python, indices start from 0, so nums[0] is the first element.

However, in the problem, indices are 1-based.

So, arr's start and end are 1-based, which seems correct.

Now, for the queries, l and r are 1-based.

In the code, it uses bisect_left to find eli = bisect_left(arr, (l, 0, 0))

Then, (s, e, _) = arr[min(eli, LA)]

Then, it has conditions based on s and e.

This seems problematic.

Let me think of a better way.

I'll use bisect_left to find the first segment that starts at or after l.

Then, I'll find the last segment that ends before or at r.

If there is more than one segment in this range, print any two indices from different segments.

Else, print -1 -1.

To implement this, I can:

- Find the left index in arr where arr[left].start >= l

- Find the right index in arr where arr[right].end <= r

- Then, the number of segments in [l, r] is right - left + 1 (if right >= left)

- If right - left + 1 >= 2, print any two indices from different segments.

- Else, if right - left + 1 == 1, and the segment's start <= l and end >= r, then all elements are the same, print -1 -1.

- But need to handle cases where l and r fall within the same segment or multiple segments.

Wait, perhaps it's better to iterate through the segments in arr and collect all segments that overlap with [l, r].

Then, if there is more than one such segment, print any two indices from different segments.

Else, print -1 -1.

Let me try to implement this logic.

First, perform a binary search to find the first segment where start >= l.

Then, find the last segment where end <= r.

Then, if there are multiple segments in between, print any two indices from different segments.

Else, print -1 -1.

In code, it would look like:

left = bisect_left(arr, (l, 0, 0))

right = bisect_right(arr, (r, float('inf'), float('inf'))) - 1

if right >= left:

if right - left + 1 >= 2:

# print any two indices from different segments

else:

# only one segment, print -1 -1

else:

# no segments, but this shouldn't happen

In the given code, it seems like it's not correctly implementing this.

Looking back at the given code:

It has:

( s, e, _ ) = arr[ min(eli, LA) ]

Then, conditions:

if s > l:

if s == 1:

print(-1, -1)

else:

print(s - 1, s)

elif e >= r:

print(-1, -1)

elif e < N:

print(s, e + 1)

else:

print(-1, -1)

This doesn't seem to correctly capture the logic I described.

For example, if s > l, it prints s-1 and s, which might not be within [l, r].

Wait, s is the start of a segment that starts after l, so s-1 would be before s, which might be within [l, r], but not necessarily.

This seems error-prone.

I think the code is incorrect in handling the query responses.

Let me consider an example to verify.

Take the first test case from the sample input:

5

1 1 2 1 1

3

1 5

1 2

1 3

According to the sample output:

2 3

-1 -1

1 3

Let's see how the code handles it.

First, arr would be:

(1, 2, 1)

(3, 3, 2)

(4, 5, 1)

For the first query, l=1, r=5

eli = bisect_left(arr, (1,0,0)) = 0

(s,e,_) = arr[min(0,2)] = (1,2,1)

since s=1 <=l=1, it doesn't enter the first if.

Then, e=2 < r=5, so it prints s and e+1, which is 1 and 4.

But the sample output is 2 3.

Wait, 2 and 3 are within [1,5] and have different values.

But the code is printing 1 and 4, which both have value 1, which is incorrect.

Wait, no, nums[1]=1, nums[4]=1, so they are the same.

But the sample output is 2 3, which are different.

So, the code is incorrect here.

Wait, perhaps the code is not correctly implementing the logic to find different elements.

In this case, since there are different elements in [1,5], it should print any two indices with different values, like 1 and 3, or 2 and 3, etc.

But the code is printing 1 and 4, which are the same.

So, it's incorrect.

Looking at the second query, l=1, r=2

eli = bisect_left(arr, (1,0,0)) = 0

(s,e,_) = arr[0] = (1,2,1)

s=1 <=l=1, and e=2 < r=2? No, e=2 == r=2, so e >= r, print -1 -1, which matches the sample output.

Third query, l=1, r=3

eli = bisect_left(arr, (1,0,0)) = 0

(s,e,_) = arr[0] = (1,2,1)

s=1 <=l=1, e=2 < r=3, so print s and e+1, which is 1 and 3.

nums[1]=1, nums[3]=2, which are different, so it's correct.

Wait, but in the first query, it printed 1 and 4, which are the same.

So, the code is not consistently correct.

I think the logic is flawed.

Let me try to fix it.

I need to ensure that the indices I print have different values.

So, if there are multiple segments in [l,r], I can pick one index from the first segment and one from the next segment.

If there's only one segment, then all elements are the same, print -1 -1.

So, in code, for each query:

left = bisect_left(arr, (l, 0, 0))

if left < len(arr) and arr[left][0] > r:

# No segment starts before or at r

print(-1, -1)

else:

# Find the rightmost segment that ends before or at r

right = bisect_right(arr, (r, float('inf'), float('inf'))) - 1

if right >= left:

if right - left + 1 >= 2:

# At least two segments in [l,r], print any two indices from different segments

i = arr[left][0]

j = arr[left + 1][0]

print(i, j)

else:

# Only one segment in [l,r]

print(-1, -1)

else:

print(-1, -1)

This seems more correct.

In the first query, l=1, r=5

left = 0

right = 2

there are 3 segments, which is >=2, so print arr[0][0]=1 and arr[1][0]=3

which are 1 and 3, which are different, as in the sample output.

In the second query, l=1, r=2

left = 0

right = 0

only one segment, so print -1 -1

In the third query, l=1, r=3

left = 0

right = 1

two segments, so print arr[0][0]=1 and arr[1][0]=3

which are different.

Seems correct.

But in the given code, it's not implementing this correctly.

It seems to be printing s and e+1 regardless of whether they are different.

Hence, the given code is incorrect.

Therefore, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]