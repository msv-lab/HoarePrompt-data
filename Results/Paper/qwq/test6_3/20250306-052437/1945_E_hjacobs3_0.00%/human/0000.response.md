Alright, I've got this problem to solve. Let's see what it's asking for. So, Anton has a permutation of size n, and he wants to find a number x using a binary search-like algorithm. But here's the twist: the array isn't sorted, and I can perform at most two swaps on the permutation before running this binary search. The goal is to rearrange the permutation in such a way that after performing the modified binary search, the value at position l ends up being equal to x.

First, I need to understand what a permutation is. A permutation of size n is just an array containing each number from 1 to n exactly once, but in any order. So, for example, [2, 3, 1] is a permutation of size 3.

Now, the binary search algorithm described here is a bit unusual. It initializes l to 1 and r to n+1, which is different from the standard binary search where l and r are typically set to the first and last indices of the array. Then, in each step, it calculates m as the floor of (r + l) / 2 and checks if p_m <= x to decide whether to set l to m or r to m. The loop continues until r - l = 1.

I need to make sure that after performing at most two swaps, this binary search ends with p_l equal to x. It's important to note that the array isn't sorted, so the standard binary search properties don't hold directly.

The problem mentions that it can be shown two operations are always sufficient. That's a crucial hint. It means that no matter how the permutation is arranged, I can always make the binary search work by swapping at most two elements.

Let me try to understand how this is possible. Maybe I need to think about where x is located in the permutation and where it needs to be for the binary search to find it correctly.

Let's consider the binary search process. It seems like it's trying to find the position where x would be if the array were sorted, but since it's not sorted, I need to adjust the array so that the search ends up at the correct position.

Wait, actually, the binary search here isn't a standard one. In standard binary search, we have a sorted array, and we repeatedly divide the search interval in half. But here, the array is not sorted, and the binary search is defined differently.

Let me try to see how this binary search works with an example.

Take the first example from the input:

n = 6, x = 3

array = [1, 2, 3, 4, 5, 6]

So, the array is already sorted. Let's see how the binary search proceeds.

Initialize l = 1, r = 7

Loop while r - l != 1:

m = floor((7 + 1)/2) = 4

Check if p_4 <= 3: p_4 = 4, which is not <= 3, so set r = m = 4

Now, l = 1, r = 4

m = floor((4 + 1)/2) = 2

p_2 = 2 <= 3, so set l = m = 2

Now, l = 2, r = 4

m = floor((4 + 2)/2) = 3

p_3 = 3 <= 3, so set l = m = 3

Now, l = 3, r = 4

m = floor((4 + 3)/2) = 3

p_3 = 3 <= 3, so set l = m = 3

Now, l = 3, r = 3, so r - l = 0, which is not 1, so exit the loop.

The final l is 3, and p_l = 3, which matches x. So, in this case, no swaps are needed.

Another example:

n = 6, x = 5

array = [3, 1, 6, 5, 2, 4]

Let's perform the binary search:

l = 1, r = 7

m = floor((7 + 1)/2) = 4

p_4 = 5 <= 5, so l = 4

Now, l = 4, r = 7

m = floor((7 + 4)/2) = 5

p_5 = 2 <= 5, so l = 5

Now, l = 5, r = 7

m = floor((7 + 5)/2) = 6

p_6 = 4 <= 5, so l = 6

Now, l = 6, r = 7

m = floor((7 + 6)/2) = 6

p_6 = 4 <= 5, so l = 6

Now, l = 6, r = 7

m = floor((7 + 6)/2) = 6

p_6 = 4 <= 5, so l = 6

This continues, but it seems like it's not finding x=5. So, I need to swap some elements to make sure that after the binary search, p_l = 5.

Looking at the output for this case, it shows:

1

3 4

Meaning one swap between indices 3 and 4.

So, swapping array[3] (6) and array[4] (5), the array becomes [3, 1, 5, 6, 2, 4]

Let's see how the binary search proceeds now:

l = 1, r = 7

m = floor((7 + 1)/2) = 4

p_4 = 6 <= 5? No, so r = m = 4

Now, l = 1, r = 4

m = floor((4 + 1)/2) = 2

p_2 = 1 <= 5, so l = 2

Now, l = 2, r = 4

m = floor((4 + 2)/2) = 3

p_3 = 5 <= 5, so l = 3

Now, l = 3, r = 4

m = floor((4 + 3)/2) = 3

p_3 = 5 <= 5, so l = 3

This meets the condition r - l = 1, so p_l = 5, which is correct.

So, by swapping 5 and 6, the binary search now correctly identifies x=5.

Another example:

n = 5, x = 1

array = [3, 5, 4, 2, 1]

Output:

2

2 4

1 5

So, two swaps: first swap indices 2 and 4, then swap indices 1 and 5.

Let's see the effect of these swaps.

First swap: indices 2 and 4: array becomes [3, 2, 4, 5, 1]

Second swap: indices 1 and 5: array becomes [1, 2, 4, 5, 3]

Now, perform the binary search:

l = 1, r = 6

m = floor((6 + 1)/2) = 3

p_3 = 4 <= 1? No, so r = m = 3

Now, l = 1, r = 3

m = floor((3 + 1)/2) = 2

p_2 = 2 <= 1? No, so r = m = 2

Now, l = 1, r = 2

m = floor((2 + 1)/2) = 1

p_1 = 1 <= 1, so l = 1

Now, l = 1, r = 2

m = floor((2 + 1)/2) = 1

p_1 = 1 <= 1, so l = 1

This meets r - l = 1, and p_l = 1, which is correct.

So, with two swaps, we can arrange the array so that the binary search finds x=1.

Looking at these examples, it seems that the strategy is to position x in such a way that the binary search ends up at the correct position.

I need to find a general approach to determine which swaps to perform.

First, I need to understand where x is currently located in the array and where it needs to be for the binary search to find it.

Given that the binary search is not a standard one, I need to simulate how it works.

Let's analyze the binary search algorithm provided:

- Initialize l = 1, r = n + 1

- While r - l != 1:

- m = floor((r + l)/2)

- If p_m <= x, set l = m

- Else, set r = m

- End loop

- Return p_l

I need to ensure that after the swaps, p_l = x when the loop ends.

This seems tricky because the search depends on the relative ordering of the elements.

Given that it's a permutation, all elements are distinct, which is helpful.

The problem suggests that two swaps are always sufficient. So, I need to find a way to perform at most two swaps to make the binary search find x correctly.

One approach could be to simulate the binary search and see where it ends up, then determine which swaps would be necessary to make p_l = x.

However, simulating the search for each test case could be time-consuming if n is large, but since the sum of n across all test cases is up to 2e5, and t is up to 2e4, I need an efficient solution.

I need to find a way to determine the necessary swaps without simulating the entire search process for each test case.

Let me think differently. Maybe I can find the position where the binary search would place l and ensure that x is at that position.

But to do that, I need to know where l would end up after the search.

Wait, perhaps I can determine the final position l after the search and see if x is already there. If not, swap x to that position.

But there might be cases where additional swaps are needed, so I need to be careful.

Let me try to formalize this.

Let’s denote pos_x as the current position of x in the array.

Let’s denote target_l as the position where l would end up after the search.

If pos_x == target_l, then no swaps are needed.

If pos_x != target_l, then swapping the elements at pos_x and target_l would place x at target_l.

But I need to ensure that this swap doesn't disrupt the condition for the binary search.

Wait, but the problem allows up to two swaps, so perhaps I can perform one swap to place x correctly, and if necessary, a second swap to fix any disruption caused by the first swap.

This seems vague. I need a better plan.

Let me consider the following steps:

1. Determine where the binary search would place l if no swaps are performed.

2. If p_l == x, then no swaps are needed.

3. If p_l != x, then find a way to place x at l using at most two swaps.

But to do this, I need to know the value of l after the search.

However, since the array is not sorted, it's not straightforward to predict where l would end up.

Maybe I need to simulate the search to find the final l.

But simulating the search for each test case might be too slow if n is large and t is large.

I need a more efficient way.

Wait, perhaps I can observe that the final l is determined by the number of elements less than or equal to x.

Let’s think about it.

In a standard binary search on a sorted array, l would be the insertion point for x, i.e., the position where x should be inserted to maintain sorted order.

In this problem, the binary search is similar but not exactly the same due to the way l and r are updated.

Wait, perhaps I can model this as finding the lower bound of x in the array, even though it's not sorted.

But since it's not sorted, the result might not make sense, which is why I need to swap elements to make it somewhat "sorted" for the search to work.

Another idea: since permutations are derangements of sorted order, maybe there's a way to measure the distance to a sorted array and perform swaps accordingly.

But this seems too vague.

Let me look back at the examples to see if there's a pattern.

In the first example:

n=6, x=3

array=[1,2,3,4,5,6]

No swaps needed because the array is already sorted, and the search finds x correctly.

In the second example:

n=6, x=5

array=[3,1,6,5,2,4]

After swapping 3 and 4 (positions 3 and 4), the array becomes [3,1,5,6,2,4], and the search finds x=5 at position 3.

In the third example:

n=5, x=1

array=[3,5,4,2,1]

After two swaps: swap 2 and 4, then 1 and 5, the array becomes [1,2,4,5,3], and the search finds x=1 at position 1.

So, in the second example, swapping 3 and 4 brought 5 to a position where the search could find it.

In the third example, two swaps were needed to bring 1 to the front.

It seems like the strategy is to bring x to its correct position in the sorted array, or at least to a position where the binary search can find it.

But I need a general approach.

Let me try to think differently.

Suppose I perform the binary search as described, and see where l ends up.

Then, if p_l != x, I need to swap x to that position.

But if swapping x to position l disrupts the condition for other elements, I might need a second swap to fix it.

Wait, perhaps I can just swap x to position l, and if necessary, swap another element to its correct position.

But this seems too vague. I need a concrete plan.

Let me consider implementing the following steps:

1. Perform the binary search to find the final l.

2. If p_l == x, do nothing.

3. Else, swap p_l with x.

4. If after the swap, the condition is satisfied, then done with one swap.

5. Else, perform a second swap to fix any discrepancies.

But I need to make sure that this approach works in all cases.

Alternatively, perhaps I can think in terms of the desired position for x and perform swaps accordingly.

Wait, maybe I can consider the position where x should be in a sorted array and try to bring it there.

But since the array isn't sorted, and I can only perform two swaps, I need to be careful.

Let me consider that in the sorted array, x would be at position x.

Wait, in a sorted permutation from 1 to n, x is at position x.

So, in the sorted array, x is at index x-1.

But since the array is not sorted, I need to bring x to index x-1, if possible, with at most two swaps.

But is this always possible?

Wait, no. Consider a permutation where x is already at index x-1. No swaps needed.

If x is not at index x-1, I can swap it there with one swap.

But I need to ensure that after swapping, the binary search finds x at that position.

But the binary search depends on the relative ordering of other elements.

Wait, maybe bringing x to its sorted position is not sufficient because the binary search isn't performed on a sorted array.

I need to think differently.

Let me consider implementing the binary search and see where l ends up.

Then, if p_l != x, perform a swap to make p_l = x.

If that swap disrupts the condition, perform a second swap to fix it.

But this seems too vague. I need a more concrete plan.

Looking back at the provided program, it seems to implement a different approach.

Let's examine the provided program to understand its logic.

The program defines a function func_1(array, find):

n = len(array)

(l, r) = (0, n - 1)

while l <= r:

mid = (l + r) // 2

if array[mid] >= find:

r = mid - 1

else:

l = mid + 1

if l != array.index(find):

print(1)

return [str(l + 1), str(array.index(find) + 1)]

else:

print(0)

So, in this function:

- It performs a modified binary search to find the position l.

- Then, it checks if p_l == x.

- If not, it swaps x to position l with one swap.

- If p_l == x, it does nothing.

Wait, but in the second example, it outputs 1 swap, which matches the expected output.

In the third example, the output is 2 swaps, but the function seems to only perform one swap when p_l != x.

So, perhaps this function isn't complete or correct for all cases.

Looking back at the problem, it says that two operations are always sufficient, but the function seems to only perform one swap when needed.

However, in some cases, like the third example, two swaps are needed, but the function only performs one swap.

Therefore, this function might not be correct.

But according to the problem, two swaps are always sufficient, so perhaps the function can be modified to perform at most two swaps to ensure p_l == x.

Alternatively, maybe the function needs to be adjusted to handle cases where one swap isn't enough.

Wait, perhaps the function needs to perform the binary search again after the first swap to check if p_l == x, and perform a second swap if necessary.

But this seems inefficient and may not guarantee correctness.

I need to find a better way.

Let me consider the following approach:

1. Perform the binary search to find the final l.

2. If p_l == x, do nothing.

3. Else, swap x with the element at position l.

4. Perform the binary search again.

5. If p_l == x, then one swap was sufficient.

6. Else, perform a second swap to fix any discrepancies.

But I need to determine what the second swap should be.

This seems too vague. I need a clearer plan.

Perhaps I can identify the positions of x and the element at the target l, and perform swaps accordingly.

Let me denote:

- pos_x: current position of x in the array.

- target_l: the position where l ends up after the binary search.

If pos_x == target_l, then no swaps are needed.

If pos_x != target_l, then swapping the elements at pos_x and target_l would place x at target_l.

Then, perform the binary search again to verify if p_l == x.

If yes, then one swap is sufficient.

If not, perform a second swap to fix it.

But I need to determine what the second swap should be.

Alternatively, perhaps I can swap x to the target_l, and if that doesn't satisfy the condition, swap another element to its correct position.

But this seems too vague. I need a more concrete strategy.

Let me consider that after swapping x to target_l, the binary search might still not find x correctly if the relative ordering of other elements isn't suitable.

Therefore, I might need a second swap to adjust those elements.

But this is still too vague.

I need to find a systematic way to perform these swaps.

Let me consider that the binary search is trying to find the lower bound of x in the array, similar to how it works in a sorted array.

In a sorted array, the lower bound is the first position where x should be inserted or found.

In this problem, since the array isn't sorted, I need to make sure that the array somewhat resembles a sorted array in the regions that the binary search traverses.

But this seems too broad.

Perhaps I need to consider the path that the binary search takes and ensure that the elements along that path satisfy the conditions for the search to reach the correct position.

This sounds promising.

Let's think about the binary search process:

- It starts with l = 1 and r = n + 1.

- In each step, it calculates m = floor((l + r)/2) and checks if p_m <= x.

- If p_m <= x, set l = m.

- Else, set r = m.

- Repeat until r - l = 1.

The goal is to have p_l = x when the loop ends.

So, I need to ensure that after the search, p_l equals x.

To do this, perhaps I need to make sure that x is at the position where l ends up.

But to do that, I need to know where l ends up after the search.

However, since the array isn't sorted, it's not straightforward to predict where l will be.

Wait, perhaps I can simulate the binary search to find the final l.

Given that n can be up to 2e5 and t up to 2e4, but the sum of n across all test cases is up to 2e5, it should be efficient enough.

So, in the function func_1, it performs a binary search to find l.

Then, if p_l != x, it swaps x to position l.

But in some cases, as shown in the third example, two swaps are needed.

So, perhaps after the first swap, I need to check again and perform a second swap if necessary.

But how do I determine the second swap?

Let me try to implement this step by step.

First, perform the binary search to find l.

If p_l == x, do nothing.

Else, swap p_l with x.

Then, perform the binary search again.

If p_l == x, then one swap was sufficient.

Else, perform a second swap.

But what should the second swap be?

Perhaps swap p_l with x again, but that would revert the first swap.

That doesn't make sense.

Alternatively, maybe swap p_l with the current x's position.

But this seems too vague.

I need a better approach.

Let me consider that after the first swap, the binary search might still not find x correctly because other elements along the search path might not be in the expected order.

Therefore, I need to adjust those elements with a second swap.

But this is still too vague.

Maybe I need to look for the element that is causing the search to fail and swap it with the correct element.

But I need a more concrete plan.

Let me consider that after the first swap, if p_l != x, then there must be some element that is preventing the search from reaching the correct position.

Perhaps I can identify that element and swap it with another element to fix the condition.

But this is still not clear.

Let me consider that in the binary search process, the choices of m and the updates to l and r depend on the values of p_m.

So, if p_m is not in the expected order, the search can go wrong.

Therefore, I need to ensure that the elements along the search path are such that the search reaches the correct position.

But this seems too broad.

Maybe I need to consider that with two swaps, I can fix any inconsistencies in the search path.

But I need a systematic way to determine which swaps to perform.

Let me try to think about the problem differently.

Suppose I fix x at the target_l position, and ensure that all elements to the left of target_l are less than or equal to x, and all elements to the right are greater than x.

But since I can only perform two swaps, this might not be feasible.

Alternatively, perhaps I can ensure that x is at target_l, and that the elements before and after it don't violate the conditions for the binary search.

But again, this seems too vague.

Let me consider that the binary search is trying to find the lower bound of x, similar to how it works in a sorted array.

In a sorted array, the lower bound is the first position where x should be inserted or found.

In this problem, since the array isn't sorted, I need to make sure that x is at the position where the search expects it to be.

Therefore, perhaps I can simulate the search to find the target_l, swap x to that position, and then check if that suffices.

If not, perform a second swap to adjust another element.

But I still need to determine which element to swap in the second swap.

This is getting too complicated.

Let me look back at the provided program and see if I can improve it to handle cases where one swap isn't enough.

In the provided program, func_1 performs a binary search to find l, and if p_l != x, it swaps x to position l.

But in some cases, as shown in the third example, two swaps are needed.

Therefore, perhaps I can modify func_1 to perform a second swap if necessary.

Here's an idea:

- Perform the binary search to find target_l.

- If p_target_l == x,