Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this queue of n people, and Kirill comes in and stands at the end, which is position n. But he's not happy about being at the end; he wants to be among the first m people in the queue. To do that, he can bribe people ahead of him to swap places.

Each person in the queue has two values associated with them: a_i and b_i. If Kirill is at position i and wants to swap with someone at position j (where j < i), he has to pay a_j coins to the person at position j. Additionally, for everyone between j and i (exclusive), he has to pay b_k coins to each of them.

My task is to find the minimum number of coins Kirill needs to spend to get into the first m positions in the queue.

First, I need to understand the operations Kirill can perform. He can choose any position j that is ahead of him (j < i) and swap places with that person, paying a_j coins to that person and b_k coins to everyone between j and i.

I need to think about how to model this problem. It seems like a dynamic programming problem because Kirill can perform this operation multiple times, and I need to find the minimum cost to reach one of the first m positions.

Let me think about the state of the dynamic programming. Let's define dp[i] as the minimum cost for Kirill to reach position i from position n.

Wait, but Kirill starts at position n, and he wants to get to any position from 1 to m. So, I need to find the minimum cost among dp[1] to dp[m].

But I need to define how he can move from position i to position j, where j < i.

Given that when he swaps with position j, he pays a_j and also pays b_k for each k between j and i.

Wait, but in the code provided, there's a function func_1 that takes pergunta, a, b, n, m as arguments. pergunta is initialized to infinity, and there's a loop that iterates from n-1 down to 0.

In the loop, if i < m, it updates pergunta to be the minimum of pergunta and x + a[i], where x is accumulated sum.

I need to understand what x represents here.

Let me look at the code step by step.

First, it reads the number of test cases, numCasos.

Then, for each test case, it reads n and m, then reads the arrays a and b.

Then, it initializes pergunta to infinity and calls func_1 with pergunta, a, b, n, m.

In func_1, it initializes x to 0.

Then, it loops from n-1 down to 0.

If i < m, it updates pergunta to be the minimum of pergunta and x + a[i].

Then, it adds to x the minimum of a[i] and b[i].

Finally, it prints pergunta.

I need to understand what x represents.

Let's consider the example given:

4

4 2

7 3 6 9

4 3 8 5

So, n=4, m=2

a = [7,3,6,9]

b = [4,3,8,5]

The code will loop from i=3 down to 0.

Initialize x=0

i=3:

i=3 < 2? No, so don't update pergunta.

x += min(a[3], b[3]) = min(9,5) = 5

x=5

i=2:

i=2 < 2? No, so don't update pergunta.

x += min(a[2], b[2]) = min(6,8) = 6

x=11

i=1:

i=1 < 2? Yes, update pergunta = min(inf, x + a[1]) = min(inf, 11 + 3) = 14

x += min(a[1], b[1]) = min(3,3) = 3

x=14

i=0:

i=0 < 2? Yes, update pergunta = min(14, x + a[0]) = min(14, 14 + 7) = 14

x += min(a[0], b[0]) = min(7,4) = 4

x=18

Then, pergunta is 14, which matches the first output in the example.

So, in this case, it seems correct.

But I need to understand why this works.

Let's think about what x represents.

x seems to accumulate some costs as we go backwards from the end of the queue to the front.

At each step, x is increased by the minimum of a[i] and b[i].

When i < m, pergunta is updated to be the minimum of its current value and x + a[i].

I need to interpret what this means.

Maybe x represents the cumulative cost to move from position n to position i.

Wait, but it's accumulating min(a[i], b[i]) as we go backwards.

Wait, perhaps it's considering the cost to move directly from position n to position j, and then adding a[j] to swap with j.

But I'm not sure.

Let me think differently.

Suppose Kirill is at position n, and he wants to move to position j < n.

To do that, he has to pay a_j and also pay b_k for all k between j and n.

Wait, but in the code, it's iterating from n-1 down to 0, and accumulating min(a[i], b[i]).

I need to see if this accumulation corresponds to some cumulative cost.

Wait, maybe it's calculating the cost to move from position n to position i, and then from position i to some position j < i.

But I'm getting confused.

Let me try to think of a smaller example.

Suppose n=2, m=1

a = [2,3]

b = [1,1]

According to the code:

pergunta = inf

x=0

i=1:

i=1 < 1? No, so don't update pergunta.

x += min(a[1], b[1]) = min(3,1) =1

x=1

i=0:

i=0 < 1? Yes, pergunta = min(inf, x + a[0]) = min(inf, 1 + 2) =3

x += min(a[0], b[0]) = min(2,1) =1

x=2

print pergunta =3

But according to the problem, Kirill is at position 2, wants to be at position 1.

Option 1: Swap directly from position 2 to position 1.

Cost: a_1 = 2

Option 2: Maybe some other way, but in this case, directly swapping to position 1 costs 2, which is less than what the code outputs, which is 3.

Wait, maybe I'm misunderstanding the operations.

Wait, in the problem, when Kirill swaps with position j, he pays a_j and also pays b_k for each k between j and i.

In this case, swapping from i=2 to j=1, he pays a_1 =2 and also pays b_k for k between 1 and 2, which is b_1 =1.

So total cost is 2 +1=3, which matches the code's output.

So, in this case, the code is correct.

Wait, but in the earlier example, it also matched.

Let me check another example.

Take n=3, m=2

a = [1,2,3]

b = [1,1,1]

According to the code:

pergunta = inf

x=0

i=2:

i=2 < 2? No, don't update pergunta.

x += min(a[2], b[2]) = min(3,1)=1

x=1

i=1:

i=1 < 2? Yes, pergunta = min(inf, x + a[1]) = min(inf,1 +2)=3

x += min(a[1], b[1])=min(2,1)=1

x=2

i=0:

i=0 < 2? Yes, pergunta = min(3, 2 +1)= min(3,3)=3

x += min(a[0], b[0])=min(1,1)=1

x=3

So, pergunta=3

Now, let's see what the actual minimum cost is.

Kirill is at position 3.

Option 1: Swap directly from 3 to 1, cost a_1 + b_2 =1 +1=2

Then, he's at position 1, which is within m=2.

Option 2: Swap from 3 to 2, cost a_2 + b_2=3 +1=4

Then, he's at position 2, which is within m=2.

So, the minimum cost is 2.

But the code outputs 3.

Hmm, seems like a mistake.

Wait, according to the problem, Kirill can perform the operation any number of times.

So, in this case, he can swap from 3 to 1, paying a_1 + b_2=1+1=2, and reach position 1, which is within m=2.

But the code outputs 3.

So, in this case, the code is incorrect.

Wait, but in the earlier examples, it seemed correct.

Maybe the code is not general.

Let me see what's happening.

In the first example:

n=4, m=2

a=[7,3,6,9]

b=[4,3,8,5]

According to the code, pergunta=14

Let's see what the actual minimum cost is.

Kirill starts at position 4.

Option 1: Swap from 4 to 3, cost a_3 + b_3=6+8=14

Then, swap from 3 to 2, cost a_2 + b_2=3+3=6

Total cost:14+6=20

Option 2: Swap from 4 to 2, cost a_2 + b_3=3+8=11

Then, swap from 2 to 1, cost a_1 + b_2=7+3=10

Total cost:11+10=21

Option 3: Swap from 4 to 1, cost a_1 + b_2 + b_3=7+3+8=18

Option 4: Swap from 4 to 3, cost 6+8=14

Then, swap from 3 to 1, cost a_1 + b_2=7+3=10

Total cost:14+10=24

So, the minimum among these is 18, but the code outputs 14, which seems incorrect.

Wait, but in the example, it's given that the output is 14, so maybe the code is correct, and my calculation is wrong.

Wait, perhaps I'm missing something.

Wait, maybe Kirill can swap directly from 4 to 1, paying a_1 + b_2 + b_3=7+3+8=18

Or swap from 4 to 2, paying a_2 + b_3=3+8=11, then swap from 2 to 1, paying a_1 + b_2=7+3=10, total 21

Or swap from 4 to 3, paying a_3 + b_3=6+8=14, then swap from 3 to 1, paying a_1 + b_2=7+3=10, total 24

Or swap from 4 to 3, paying a_3 + b_3=6+8=14, then swap from 3 to 2, paying a_2 + b_2=3+3=6, total 20

So, indeed, the minimum is 18, but the code outputs 14, which doesn't match my calculations.

Wait, maybe I'm miscalculating.

Wait, perhaps there's a better sequence.

Wait, maybe Kirill can swap from 4 to 1 directly, paying a_1 + b_2 + b_3=7+3+8=18

Or swap from 4 to 2, paying a_2 + b_3=3+8=11, then swap from 2 to 1, paying a_1 + b_2=7+3=10, total 21

Or swap from 4 to 3, paying a_3 + b_3=6+8=14, then swap from 3 to 1, paying a_1 + b_2=7+3=10, total 24

Or swap from 4 to 3, paying a_3 + b_3=6+8=14, then swap from 3 to 2, paying a_2 + b_2=3+3=6, total 20

So, indeed, the minimum is 18, but the code outputs 14, which is less than 18.

So, perhaps the code is correct, and I'm missing something.

Wait, maybe Kirill can perform multiple swaps in a way that the total cost is less.

Wait, but in this example, 14 is the answer, and according to the example output, it's correct.

But according to my calculations, 14 seems impossible.

Wait, perhaps I'm misunderstanding the problem.

Wait, the problem says Kirill can perform this action any number of times.

Each time he chooses j < i, pays a_j, and pays b_k for j < k < i.

Wait, perhaps I'm miscounting the b_k.

Wait, in the first swap from 4 to 1, he pays a_1 and b_2 + b_3.

Which is 7 + 3 + 8 =18

In the code, pergunta is 14, which seems to be less.

So, maybe there's a better way.

Wait, perhaps Kirill can swap from 4 to 3, paying a_3 + b_3=6+8=14

Then, since he's at position 3, which is still not within m=2, he needs to swap again.

But in the code, pergunta is updated when i < m, which is when i=1 and i=0.

Wait, in the first iteration, i=3:

x=0

i=3 < 2? No

x += min(a[3], b[3])=min(9,5)=5

x=5

i=2:

i=2 < 2? No

x += min(a[2], b[2])=min(6,8)=6

x=11

i=1:

i=1 < 2? Yes

pergunta = min(inf, x + a[1])=min(inf,11 +3)=14

x += min(a[1], b[1])=min(3,3)=3

x=14

i=0:

i=0 < 2? Yes

pergunta = min(14,14 +7)=min(14,21)=14

x += min(a[0], b[0])=min(7,4)=4

x=18

So, pergunta=14

But according to my earlier calculation, the minimum cost is 18, but the code says 14.

Wait, maybe I'm missing a sequence where Kirill can achieve 14.

Wait, perhaps he swaps from 4 to 2, paying a_2 + b_3=3+8=11

Then, he's at position 2, which is within m=2, so he stops.

Total cost=11, which is less than 14.

But according to the code, pergunta=14

Wait, but in the example, the output is 14, which doesn't match my calculation of 11.

Wait, perhaps I'm misunderstanding the problem.

Wait, the problem says Kirill wants to be among the first m people, meaning positions 1 to m.

In the first swap, from 4 to 2, paying 3+8=11, he reaches position 2, which is within m=2, so he stops.

So, the total cost is 11, but according to the code and the example output, it's 14.

So, perhaps the code is wrong.

Wait, maybe I need to look at the problem statement again.

"Kirill is completely dissatisfied with this situation, so he decided to bribe some people ahead of him."

"For the i-th person in the queue, Kirill knows two values: a_i and b_i . If at the moment Kirill is standing at position i , then he can choose any position j such that j < i and exchange places with the person at position j . In this case, Kirill will have to pay him a_j coins. And for each k such that j < k < i , Kirill will have to pay b_k coins to the person at position k . Kirill can perform this action any number of times."

"Kirill is thrifty, so he wants to spend as few coins as possible, but he doesn't want to wait too long, so Kirill believes he should be among the first m people in line."

So, in the first swap from 4 to 2, paying a_2 + b_3=3+8=11, he reaches position 2, which is within m=2.

In another sequence, from 4 to 3, paying a_3 + b_3=6+8=14, then from 3 to 1, paying a_1 + b_2=7+3=10, total 24.

Or from 4 to 2, paying 11, which is better.

So, why does the code output 14 instead of 11?

Wait, perhaps I need to look at the second test case.

In the second test case:

6 2

6 9 7 1 8 3

5 8 8 1 4 1

According to the code:

pergunta = inf

x=0

i=5:

i=5 < 2? No

x += min(a[5], b[5})=min(3,1)=1

x=1

i=4:

i=4 < 2? No

x += min(a[4], b[4})=min(8,4)=4

x=5

i=3:

i=3 < 2? No

x += min(a[3], b[3})=min(1,8)=1

x=6

i=2:

i=2 < 2? No

x += min(a[2], b[2})=min(7,8)=7

x=13

i=1:

i=1 < 2? Yes

pergunta = min(inf,13 +9)=13+9=22

x += min(a[1], b[1})=min(9,8)=8

x=21

i=0:

i=0 < 2? Yes

pergunta = min(22,21 +6)=min(22,27)=22

x += min(a[0], b[0})=min(6,5)=5

x=26

So, pergunta=22

But according to my earlier calculation, in the first test case, the minimum should be 11, but the code outputs 14.

So, the code seems incorrect.

Wait, but in the example output, it's 14.

Wait, perhaps the example output is wrong, or perhaps I'm misunderstanding the problem.

Wait, in the first test case, n=4, m=2

a=[7,3,6,9]

b=[4,3,8,5]

According to the code, pergunta=14

But according to my calculation, Kirill can swap from 4 to 2, paying 3+8=11, and reach position 2, which is within m=2.

So, why does the code output 14?

Wait, maybe I'm missing some constraint.

Wait, perhaps Kirill can only perform one swap.

But no, the problem says he can perform this action any number of times.

So, he can perform multiple swaps.

In that case, swapping from 4 to 2 for 11 should be acceptable, but the code outputs 14.

So, perhaps the code is wrong.

Wait, maybe I need to consider that when Kirill swaps from i to j, the b_k is for k between j and i, exclusive.

So, from 4 to 2, b_3=8, so total cost is a_2 + b_3=3+8=11

Similarly, from 4 to 1, it's a_1 + b_2 + b_3=7+3+8=18

So, indeed, 11 is better than 18.

So, why does the code output 14?

Wait, perhaps there's a misunderstanding in the problem.

Wait, maybe b_k is paid to people strictly between j and i, not including j and i.

In that case, from 4 to 2, b_3=8, so total cost is a_2 + sum(b_k for k from 3 to 3)=3+8=11

From 4 to 1, a_1 + sum(b_k for k from 2 to 3)=7+3+8=18

So, indeed, 11 is better.

But according to the code, pergunta=14

So, perhaps the code is incorrect.

Wait, maybe I need to look at how the code is calculating x.

In the code, x accumulates min(a[i], b[i]) as i decreases.

Then, when i < m, pergunta is set to min(pergunta, x + a[i])

In the first test case:

n=4, m=2

a=[7,3,6,9]

b=[4,3,8,5]

Loop from i=3 down to 0:

i=3:

x += min(a[3], b[3})=min(9,5)=5

x=5

i=2:

x += min(a[2], b[2})=min(6,8)=6

x=11

i=1:

pergunta = min(inf,11 +3)=14

x += min(a[1], b[1})=min(3,3)=3

x=14

i=0:

pergunta = min(14,14 +7)=14

x += min(a[0], b[0})=min(7,4)=4

x=18

So, pergunta=14

But according to my calculation, 11 is possible.

So, perhaps the code is incorrect.

Wait, maybe I need to think differently.

Perhaps x represents the cost to move from position n to position i, and then pergunta is x + a[i] to move from position i to position j < m.

But I'm getting confused.

Wait, maybe I need to model this as a graph where each position is a node, and edges represent possible swaps with their costs.

Then, find the minimum cost path from position n to any position <= m.

That might be a way to think about it.

But given the constraints, n can be up to 2e5, so it needs to be efficient.

But perhaps dynamic programming can be used.

Let me try to define dp[i] as the minimum cost to reach position i from position n.

Then, dp[n] = 0

For each i from n-1 down to 1, dp[i] = a_i + sum of b_k for k from j+1 to n, where j is the position we're swapping from.

Wait, maybe that's not the right way.

Alternatively, perhaps dp[i] is the minimum cost to reach any position <= m from position i.

Then, dp[i] = min over j < i of (a_j + sum b_k for k from j+1 to i) + dp[j]

But that might be too slow for n=2e5.

I need a better approach.

Looking back at the code, it seems to accumulate some costs in x and then add a_i when i < m.

But as shown in the example, it doesn't give the correct answer.

So, perhaps the code is incorrect.

Wait, but in the example, it's given that the output is 14, but according to my calculation, it should be 11.

So, perhaps the example is wrong, or perhaps I'm misunderstanding the problem.

Wait, maybe Kirill can only perform one swap.

But no, the problem says he can perform this action any number of times.

So, he can perform multiple swaps.

In that case, the minimum cost should be the minimum cost of any sequence of swaps that gets him to a position <= m.

In the first test case, swapping from 4 to 2 for 11 should be acceptable, but the code outputs 14.

So, perhaps the code is wrong.

Wait, maybe there's a constraint I'm missing.

Wait, perhaps when Kirill swaps from i to j, he pays a_j and b_k for j < k < i, not j < k <=i.

In the first test case, swapping from 4 to 2: j=2, i=4, so k=3, paying a_2 + b_3=3+8=11

Swapping from 4 to 1: j=1, i=4, k=2,3, paying a_1 + b_2 + b_3=7+3+8=18

So, indeed, 11 is better.

But according to the code, pergunta=14

So, perhaps the code is incorrect.

Wait, perhaps I need to think differently.

Maybe the code is calculating the cost differently.

Wait, in the code, pergunta is updated when i < m, to be x + a[i]

What is x?

x is accumulated min(a[k], b[k}) for k from n-1 down to i

Wait, in the first test case, when i=1, x=11, a[1}=3, so pergunta=11+3=14

When i=0, x=14, a[0}=7, so pergunta=min(14,14+7)=14

So, pergunta=14

But according to my calculation, 11 is possible.

So, perhaps the code is incorrect.

Wait, maybe x represents the cost to move from position n to position i.

Wait, but in that case, moving from n to i would involve paying sum of b_k from i+1 to n, and then paying a_i to swap to j.

I'm getting confused.

Perhaps I need to look for a different approach.

Let me consider that Kirill can perform swaps repeatedly, and I need to find the minimum cost to reach a position <=m.

I can model this as a graph where each position is a node, and there is an edge from i to j (j < i) with cost a_j + sum b_k for j < k < i.

Then, the problem reduces to finding the minimum cost path from n to any node <=m.

But with n up to 2e5, building such a graph is not feasible.

I need a smarter way.

Perhaps I can precompute prefix sums of b_k to make sum calculations faster.

But still, with n=2e5, I need an O(n) or O(n log n) solution.

Looking back at the code, it seems to be O(n), but it's not giving the correct answer in my earlier example.

So, perhaps the code is incorrect.

Wait, maybe I need to think about the cumulative cost differently.

Let me consider that x represents the minimum cost to move from position n to position i.

Then, to move from position i to position j (j < i), Kirill has to pay a_j + sum b_k from j+1 to i.

But sum b_k from j+1 to i can be represented as prefix_sum_b[i] - prefix_sum_b[j]

So, perhaps I need to precompute prefix sums of b.

Let me define prefix_b[i] = sum of b_k from 1 to i.

Then, sum of b_k from j+1 to i is prefix_b[i] - prefix_b[j]

So, the cost to swap from i to j is a_j + (prefix_b[i] - prefix_b[j])

Therefore, total cost is a_j + prefix_b[i] - prefix_b[j]

Wait, perhaps I can rearrange this.

Total cost to go from n to j via i is dp[i] + a_j + prefix_b[i] - prefix_b[j]

But I need to find dp[j] = min over i > j of dp[i] + a_j + prefix_b[i] - prefix_b[j]

This seems complicated.

Wait, maybe I can think of dp[j] = a_j + min over i > j of (dp[i] - prefix_b[j] + prefix_b[i])

Wait, dp[j] = a_j + min over i > j of (dp[i] - prefix_b[j] + prefix_b[i})

This still seems messy.

