Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount x_i on each outcome. The goal is to distribute my bets in such a way that no matter which outcome wins, the money I get back is more than the total amount I bet.

Okay, to formalize it: I need to choose x_1, x_2, ..., x_n such that for each i, k_i * x_i > sum of all x_j for j from 1 to n. And all x_i must be positive integers.

First, I need to check if such a distribution exists. If it doesn't, I should output -1. Otherwise, I need to find one possible set of x_i's that satisfy the condition.

Let's look at the example provided to understand better.

In the first test case:

n = 3

k = [3, 2, 7]

One possible solution is x = [27, 41, 12]

Total bet: 27 + 41 + 12 = 80

If first outcome wins: 3*27 = 81 > 80

If second outcome wins: 2*41 = 82 > 80

If third outcome wins: 7*12 = 84 > 80

So, it satisfies the condition.

In the second test case:

n = 2

k = [3, 3]

One possible solution is x = [1, 1]

Total bet: 1 + 1 = 2

If first outcome wins: 3*1 = 3 > 2

If second outcome wins: 3*1 = 3 > 2

Good.

In the third test case:

n = 5

k = [5, 5, 5, 5, 5]

The output is -1, meaning it's impossible to find such x_i's.

And so on for the other test cases.

So, I need to find a general method to determine whether such x_i's exist for any given n and k_i's, and if they do, find one possible distribution.

Let me try to find a pattern or a formula to calculate the x_i's.

Let’s denote s = sum of all x_j for j=1 to n.

For each i, k_i * x_i > s.

But s = sum_{j=1 to n} x_j.

So, for each i, k_i * x_i > sum_{j=1 to n} x_j.

This must hold for all i.

I need to find positive integers x_i that satisfy this for all i.

This seems a bit tricky. Maybe there's a way to express x_i in terms of k_i.

Let me think about it differently.

Suppose I fix s, the total sum of bets.

Then, for each i, x_i > s / k_i.

But x_i must be integers, so x_i >= ceil(s / k_i).

But since x_i must be integers, I can write x_i >= ceil(s / k_i).

But s = sum_{j=1 to n} x_j.

This seems like a system of inequalities that might be hard to solve directly.

Maybe there's another approach.

Let me consider the minimal possible s.

I need s < min_{i=1 to n} (k_i * x_i).

But since s = sum_{j=1 to n} x_j, and x_i >= 1 (since they are positive integers), this seems complicated.

Wait, maybe I can use the concept of the least common multiple or something similar.

Let me think about it.

Suppose I set x_i = m / k_i, where m is the least common multiple of all k_i's.

But x_i needs to be an integer, so m should be a multiple of k_i for all i.

Wait, m is the least common multiple of k_i's, so m is divisible by each k_i, so m / k_i is an integer.

Let me try this.

Set m = LCM of k_i's.

Then set x_i = m / k_i.

Then, s = sum_{j=1 to n} (m / k_j).

Now, for each i, k_i * x_i = k_i * (m / k_i) = m.

So, m > s = sum_{j=1 to n} (m / k_j).

This simplifies to m > m * sum_{j=1 to n} (1 / k_j).

Divide both sides by m (assuming m > 0, which it is since m is LCM of k_i's and k_i >= 2):

1 > sum_{j=1 to n} (1 / k_j).

So, this approach works only if sum_{j=1 to n} (1 / k_j) < 1.

Otherwise, it's impossible.

Wait, in the third test case:

n=5, k=[5,5,5,5,5]

sum_{j=1 to 5} (1/5) = 5*(1/5) = 1.

So, sum is equal to 1, which is not less than 1. Hence, it's impossible, which matches the output -1.

In the first test case:

sum_{j=1 to 3} (1/k_j) = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 < 1.

Which is less than 1, so it's possible.

In the second test case:

sum_{j=1 to 2} (1/3 + 1/3) = 2/3 < 1.

So, it's possible.

In the fourth test case:

k=[7,9,3,17,9,13]

sum_{j=1 to 6} (1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13)

Let's calculate this:

1/7 ≈ 0.142857

1/9 ≈ 0.111111

1/3 ≈ 0.333333

1/17 ≈ 0.058824

1/9 ≈ 0.111111

1/13 ≈ 0.076923

Sum ≈ 0.142857 + 0.111111 + 0.333333 + 0.058824 + 0.111111 + 0.076923 ≈ 0.834160 < 1.

So, it's possible.

In the fifth test case:

n=3, k=[6,3,2]

sum_{j=1 to 3} (1/6 + 1/3 + 1/2) = 1/6 + 2/6 + 3/6 = 6/6 = 1.

So, sum is equal to 1, which is not less than 1, hence -1.

In the sixth test case:

n=5, k=[9,4,6,8,3]

sum_{j=1 to 5} (1/9 + 1/4 + 1/6 + 1/8 + 1/3) = (8 + 18 + 12 + 9 + 24)/72 = 71/72 < 1.

So, it's possible.

Therefore, the condition sum_{j=1 to n} (1/k_j) < 1 determines whether it's possible or not.

If sum_{j=1 to n} (1/k_j) < 1, then it's possible; otherwise, it's impossible.

Now, assuming sum_{j=1 to n} (1/k_j) < 1, how to find the x_i's?

Earlier, I considered setting x_i = m / k_i, where m = LCM of k_i's.

But in the first test case, with k=[3,2,7], LCM of 3,2,7 is 42.

Then x_i = [42/3, 42/2, 42/7] = [14,21,6].

Total sum s = 14+21+6=41.

Check for each i:

k_i * x_i = 3*14=42 >41

2*21=42>41

7*6=42>41

So, it works.

But in the sample output, x_i=[27,41,12], which also works, but my calculation gives [14,21,6].

Both are valid solutions.

So, setting x_i = m / k_i where m = LCM of k_i's is one possible solution.

But is there a smaller m that can be used?

Well, m needs to be a common multiple of all k_i's, but using LCM minimizes m.

But in the sample output, m seems to be larger than LCM.

Wait, in the first test case, m=42, but in the sample output, m=81.

Wait, no, in the first test case, m=42, but in the sample, x_i=[27,41,12], sum=80.

Wait, but according to my earlier calculation, m=42, x_i=[14,21,6], sum=41.

But in the sample, sum=80.

So, it's possible to have larger sums, but the minimal sum would be achieved with m=LCM.

But in this problem, we don't care about minimality, just to find any solution where sum(x_i) < min(k_i * x_i).

So, using m=LCM seems fine.

But in the code provided, it sets m=1 initially, then for each k_i, multiplies m by k_i.

Wait, that's m = product of all k_i's, which is much larger than LCM.

Then, it calculates c_i = m / k_i for each i.

Then, it calculates the GCD of all c_i's and divides each c_i by that GCD to get the minimal possible x_i's.

Wait, let's see.

In the code:

m = 1

for i in range(n):

m = m * k[i]

So, m is the product of all k_i's.

Then, c_i = m / k_i for each i.

Then, hcf = func_1(c), where func_1 is the GCD of all c_i's.

Then, c_i = c_i / hcf for each i.

Finally, if sum(c_i) >= m / hcf, then output -1, else output c_i's.

Wait, in the first test case:

k=[3,2,7]

m = 3*2*7 = 42

c = [42/3, 42/2, 42/7] = [14,21,6]

hcf = GCD of [14,21,6]

GCD of 14 and 21 is 7, GCD of 7 and 6 is 1.

So, hcf=1

Then, c_i remains [14,21,6]

sum(c_i)=41

m / hcf = 42 /1 =42

sum(c_i)=41 <42, so it outputs [14,21,6]

But in the sample output, it's [27,41,12], which also works.

So, both are valid.

But in the code, it checks if sum(c_i) >= m / hcf, then output -1, else output c_i's.

Wait, in the first test case, sum(c_i)=41 <42, so it outputs [14,21,6]

But in the sample output, it's [27,41,12]

So, the code's approach seems correct, but the sample output shows a different solution.

Does that matter? No, because there can be multiple solutions.

Now, let's see why this approach works.

m is initially set to product of all k_i's, which is certainly a common multiple of all k_i's, but not necessarily the LCM.

Wait, the product of all k_i's is always a common multiple, but LCM is the smallest such number.

By using product, m is larger than necessary, but it still works.

Then, c_i = m / k_i

Then, hcf is the GCD of all c_i's.

Then, c_i = c_i / hcf

This effectively reduces the c_i's to the smallest integers that maintain the ratios.

Then, it checks if sum(c_i) >= m / hcf, then output -1, else output c_i's.

Wait, in the first test case, sum(c_i)=41 <42, which is m/hcf=42/1=42, so it outputs [14,21,6]

But in the sample output, it's [27,41,12], which also works.

So, both are valid.

Now, why does this work?

Because by setting x_i = c_i, and s = sum(c_i), we have for each i, k_i * x_i = k_i * (m / k_i) / hcf = m / hcf

And we need m / hcf > s = sum(c_i)

Which is exactly the condition being checked.

So, if sum(c_i) < m / hcf, then it's possible, else not.

But in the code, it's sum(c_i) >= m / hcf, then -1, else output c_i's.

Wait, in the first test case, sum(c_i)=41 <42, so it outputs c_i's.

In the third test case, n=5, k=[5,5,5,5,5]

m=5^5=3125

c_i=[3125/5,3125/5,3125/5,3125/5,3125/5]=[625,625,625,625,625]

hcf=625

c_i=[1,1,1,1,1]

sum(c_i)=5

m/hcf=3125/625=5

sum(c_i)=5 >=5, so output -1

Which matches the sample output.

So, the code seems correct.

But let's check another test case.

Fourth test case:

n=6

k=[7,9,3,17,9,13]

m=7*9*3*17*9*13= (let's calculate)

7*9=63

63*3=189

189*17=3213

3213*9=28917

28917*13=375921

c_i=[375921/7,375921/9,375921/3,375921/17,375921/9,375921/13]

Which is [53703,41769,125307,22113,41769,28917]

hcf=GCD of these numbers.

Let's see, GCD of these numbers.

First, GCD of 53703 and 41769.

Let's calculate GCD(53703,41769)

53703 = 41769 * 1 + 11934

41769 = 11934 * 3 + 5967

11934 = 5967 * 2 + 0

So, GCD is 5967.

Next, GCD(5967,125307)

125307 / 5967 = 20.99 (approx), remainder =125307 - 20*5967=125307-119340=5967

So, GCD is 5967.

Next, GCD(5967,22113)

22113 / 5967 = 3.7, remainder =22113 -3*5967=22113-17901=4212

Now, GCD(5967,4212)

5967 =4212 *1 +1755

4212=1755*2 +696

1755=696*2 +363

696=363*1 +333

363=333*1 +30

333=30*11 +3

30=3*10 +0

So, GCD is 3.

Next, GCD(3,41769)=3

GCD(3,28917)=3

So, hcf=3

Then, c_i = [53703/3,41769/3,125307/3,22113/3,41769/3,28917/3] = [17901,13923,41769,7371,13923,9639]

sum(c_i)=17901+13923+41769+7371+13923+9639=104526

m/hcf=375921/3=125307

sum(c_i)=104526 <125307, so it outputs [17901,13923,41769,7371,13923,9639]

But in the sample output, it's [1989,1547,4641,819,1547,1071]

Which is also a valid solution, but smaller.

So, the code's approach gives a valid solution, but not necessarily the minimal one.

But the problem allows any valid solution, so it's fine.

Now, let's check the time constraints.

Constraints:

t <=10^4

n <=50

k_i <=20

Sum of n over all test cases <=2*10^5

So, the code needs to be efficient.

In the code, for each test case, it calculates m as product of all k_i's, which for n=50 and k_i=20, m can be very large, up to 20^50, which is way beyond standard integer types.

But Python handles big integers well, so it's fine.

Then, it calculates c_i = m / k_i for each i.

Then, it calculates hcf = GCD of all c_i's.

Then, it divides each c_i by hcf.

Then, checks if sum(c_i) >= m / hcf, if yes, output -1, else output c_i's.

This seems correct.

But is there a better way?

Well, as we saw earlier, the condition sum_{j=1 to n} (1/k_j) <1 determines possibility.

In the code, it's effectively checking sum(c_i) < m / hcf.

Given that c_i = m / k_i / hcf, and hcf is GCD of all m / k_i's.

Wait, let's see.

m is product of all k_i's.

c_i = m / k_i / hcf

hcf is GCD of all m / k_i's.

Since m is product of all k_i's, m / k_i is product of all k_j for j !=i.

So, c_i = product of all k_j for j !=i / hcf.

But hcf is GCD of all such c_i's.

In reality, hcf would be equal to product of all k_j for j !=i / LCM of all k_j for j !=i.

Wait, this seems complicated.

But in the code, it's working correctly, as per the sample inputs.

So, I think the code is correct.

Hence, Correctness: **True**

**Final Solution**

To solve this problem, we need to determine how to distribute coins among various outcomes in a game such that, regardless of which outcome wins, the returned coins are more than the total coins bet. 

## Approach

1. **Problem Understanding**:
    - We have `n` outcomes, each with a multiplier `k_i`.
    - We need to bet `x_i` coins on each outcome such that the total coins bet is less than the coins received for any winning outcome.
  
2. **Key Insight**:
    - For each outcome `i`, the condition is `k_i * x_i > sum of all x_j`.
    - We need to find integers `x_i` that satisfy this condition for all `i`.

3. **Mathematical Formulation**:
    - Let `s` be the sum of all `x_j`.
    - For each `i`, `k_i * x_i > s`.
    - This can be rephrased using the Least Common Multiple (LCM) of `k_i`.

4. **Algorithm**:
    - Compute the product `m` of all `k_i` (since Python handles big integers well).
    - Calculate `c_i = m / k_i` for each `i`.
    - Find the Greatest Common Divisor (GCD) of all `c_i`.
    - Divide each `c_i` by this GCD to get the minimal integers satisfying