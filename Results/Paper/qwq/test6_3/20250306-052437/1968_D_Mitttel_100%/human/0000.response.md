Alright, I've got this problem to solve. Let's see what it's about. So, there's this game called "Permutation game" where Bodya and Sasha have a permutation and an array. They start at certain positions in the permutation and make moves for a fixed number of turns. Each turn, they can choose to stay or move to another position based on the permutation, and they gain some score based on the array at their current position. After a fixed number of turns, the one with the higher score wins, or it's a draw if scores are equal.

First, I need to understand the input and what's being asked. The input consists of multiple test cases. For each test case, I get the size of the permutation (n), the number of turns (k), and the starting positions for Bodya (P_B) and Sasha (P_S). Then, there's the permutation itself, which is a list of integers from 1 to n, and an array a with n elements, each between 1 and 1e9.

The players make moves simultaneously for k turns. Each turn, they can choose to stay or move to the position indicated by the permutation. Their score increases by the value of a at their current position.

The goal is to determine who wins the game if both players play optimally, meaning they both try to maximize their own scores.

Okay, so I need to figure out the optimal strategy for both players and see who ends up with a higher score.

Let me think about how the game progresses. Each player has a choice each turn: stay or move. Since they make decisions simultaneously and don't affect each other's positions, their choices are independent.

Given that, I can model the game for each player separately and compute their maximum possible score.

So, for Bodya starting at position P_B, and Sasha starting at P_S, I need to compute their scores over k turns, making optimal choices each turn.

Now, the key here is to realize that the permutation defines a structure where each position points to another position. Since it's a permutation, it forms cycles.

In permutation theory, a permutation can be decomposed into disjoint cycles. For example, if n=4 and p=[2,1,4,3], then there are two cycles: 1->2->1 and 3->4->3.

Knowing the cycle structure can help in determining the long-term behavior of the players' positions.

Let's consider that each player can choose to stay or move each turn. If they stay, they remain at their current position and collect the a value there. If they move, they go to the position indicated by the permutation.

The players can choose to stay or move in any combination over the k turns. The goal is to maximize their total score.

This seems like a dynamic programming problem, where for each player, I need to compute the maximum score over k turns, considering the choices to stay or move.

However, since n can be up to 2e5 and k up to 1e9, a standard DP approach would be too slow. I need a smarter way to compute the maximum score for each player.

Let me think about the behavior in cycles. If a player is in a cycle, eventually they will keep looping within that cycle.

Suppose a player is in a cycle of length m. Then, after m moves, they return to the same position.

But since they can choose to stay or move each turn, it's not straightforward.

Wait a minute, perhaps I can model the possible positions a player can be in after k turns.

But that seems complicated. Let's think differently.

Another approach is to consider that each player can choose to stay at any position in their accessible path defined by the permutation.

Wait, but they have to move according to the permutation if they choose to move.

Let me try to model the possible sequences of positions a player can be in.

Suppose a player starts at position s.

In turn 1:

- Stay at s, score a[s]

- Move to p[s], score a[p[s]]

In turn 2:

- If stayed at s in turn 1:

- Stay at s again, score a[s] again

- Move to p[s], score a[p[s]]

- If moved to p[s] in turn 1:

- Stay at p[s], score a[p[s]]

- Move to p[p[s]], score a[p[p[s]]]

And so on.

So, for each turn, the player can choose to stay at their current position or move to the next position in the permutation.

This looks like the player can choose to stay at any position in their trajectory defined by the permutation.

In other words, the player can choose to stay at any position in the sequence s, p[s], p[p[s]], etc., for up to k turns.

But since they can choose to stay at any of these positions in any turn, it's equivalent to choosing a sequence of positions where each position is either the same as the previous one or the next in the permutation.

This seems complex to compute directly for large n and k.

Is there a pattern or a mathematical way to compute the maximum possible score?

Let me consider that the player can choose to stay at any position in their cycle for any number of turns.

Wait, but it's not exactly a single cycle; it could be multiple cycles.

Actually, in a permutation, the structure is a disjoint union of cycles.

So, the permutation can be decomposed into cycles, and each cycle is independent of the others.

But in this problem, since the player can choose to stay or move each turn, it's not clear how the cycle structure directly helps.

Perhaps I need to consider the cycle containing the starting position.

Let me consider that.

For a given starting position s, I can find the cycle that s belongs to.

Suppose the cycle is of length m, and it's a cycle s -> p[s] -> p[p[s]] -> ... -> s.

Then, if the player keeps moving, they will cycle through these m positions periodically with period m.

However, the player can choose to stay at any position in the cycle for any number of turns.

So, in k turns, the player can choose to stay at certain positions and move at others.

This seems too vague. Let's think differently.

Maybe I can model this as a Markov decision process, where at each step, the player has two choices: stay or move.

But again, for large n and k, this is not feasible.

I need a better approach.

Let me consider that the player can choose to stay at any position in their trajectory for any number of consecutive turns before moving again.

In other words, the player can choose to stay at a position for several turns, then move to the next position, stay there for some turns, and so on.

Given that, the total number of moves (i.e., transitions to the next position in the permutation) can be from 0 to k.

Wait, perhaps I can consider the number of moves the player makes.

Let’s denote the number of moves the player makes as m, where 0 ≤ m ≤ k.

Then, the player spends (k - m) turns staying at certain positions.

But this seems too broad. I need to find a way to maximize the score based on the choices.

Maybe I can think in terms of the positions the player can reach.

Starting from s, after m moves, the player is at position p^m[s], where p^m denotes applying the permutation m times.

At each turn, the player can choose to stay at the current position or move to the next position in the permutation.

So, in turn t, the player is at position x_t, and x_{t+1} is either x_t (if staying) or p[x_t] (if moving).

The score at turn t is a[x_t].

This seems like a walk on a graph where each node has two outgoing edges: one that stays and one that moves.

But again, building such a graph is not practical for large n and k.

I need a smarter way to compute the maximum possible score for each player.

Let me consider that the player can choose to stay at any position in their trajectory for any number of turns.

Given that, the player can accumulate the sum of a[x] for any positions x in their trajectory, with possible repetitions.

But I need to maximize the sum over k turns.

Wait, perhaps I can consider that the player can choose to stay at the position with the highest a value for as many turns as possible.

But, if there are multiple positions with higher a values, they might want to move to those.

Wait, perhaps the optimal strategy is to stay at the position with the maximum a value in the entire trajectory.

Because, by staying there, the player maximizes the score per turn.

Yes, that makes sense.

So, for each player, the optimal strategy is to find the position in their trajectory that has the maximum a value and stay there for all k turns.

Wait, but is that always possible?

Wait, no. Because if the player moves to a position with a higher a value, they might be able to get a higher score.

But, if they stay at the position with the maximum a value, they get a_max * k, which seems optimal.

But, perhaps there are cases where moving to another position, even if a is lower, could lead to a higher total score.

Wait, no. If a player stays at the position with the maximum a value, that should be the optimal strategy, because a_max is the highest possible score per turn, and multiplying by k gives the maximum possible total score.

Wait, but in the example provided in the problem, that's not what happened.

In the first example:

n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3] (1-based index, so p[1]=4, p[2]=1, p[3]=2, p[4]=3)

a = [7,2,5,6]

So, Bodya starts at position 3, a=5

Sasha starts at position 2, a=2

In the first turn:

- Bodya can stay at 3, score +5

- Sasha can move to p[2]=1, a=7

In the second turn:

- Bodya stays at 3, score +5

- Sasha stays at 1, score +7

Total scores:

- Bodya: 5 + 5 = 10

- Sasha: 2 + 7 = 9

So, Bodya wins.

But, according to my earlier thought, the optimal strategy is to stay at the position with the maximum a in the trajectory.

For Bodya, starting at 3, p[3]=2, p[2]=1, p[1]=4, p[4]=3, so the cycle is 3->2->1->4->3

a[3]=5, a[2]=2, a[1]=7, a[4]=6

So, the maximum a in Bodya's trajectory is a[1]=7.

So, if Bodya moves to position 2, then to position 1, and stays there, would that be better?

Let's see:

Option 1: Stay at 3 for both turns: 5 + 5 = 10

Option 2: Move to 2 first, then stay at 2: a[2] + a[2] = 2 + 2 = 4

Option 3: Move to 2, then move to 1: a[2] + a[1] = 2 + 7 = 9

Option 4: Stay at 3, then move to 2: a[3] + a[2] = 5 + 2 = 7

Option 5: Move to 2, then move to 1: same as option 3, 2 + 7 = 9

Option 6: Move to 2, then move to 1, then stay at 1 if k were larger, but k=2.

So, the maximum for Bodya is indeed staying at 3 for both turns, getting 10.

But according to my earlier thought, the optimal is to stay at the position with the maximum a in the trajectory, which is position 1 with a=7.

But to reach position 1, Bodya would need to move twice: 3->2->1, and then stay there.

But in k=2 turns, moving twice would mean:

Turn 1: move to 2, score a[2]=2

Turn 2: move to 1, score a[1]=7

Total: 2 + 7 = 9, which is less than staying at 3 and getting 10.

So, in this case, staying at the position with the maximum a is better than trying to reach a position with higher a by moving.

Hence, my earlier thought might not be completely accurate.

Wait, perhaps the optimal strategy is to find the position in the trajectory with the maximum a and stay there for as many turns as possible, but considering the cost of moving to reach that position.

In the above example, to reach position 1, Bodya needs to move twice, which costs a[2] and a[1], totaling 2 + 7 = 9, which is less than staying at position 3 and getting a[3] + a[3] = 5 + 5 = 10.

So, in this case, staying at position 3 is better.

But, if k were larger, say k=3:

Option: stay at 3 for all three turns: 5 + 5 + 5 = 15

Option: move to 2, then to 1, then stay at 1: 2 + 7 + 7 = 16

So, in this case, moving to reach position 1 and staying there gives a higher score.

Hence, for larger k, moving to the position with the highest a in the trajectory and staying there might be better.

So, perhaps the optimal strategy is:

- Identify the position in the trajectory with the maximum a value.

- Determine the minimal number of moves required to reach that position.

- If k is larger than the number of moves required to reach it, then spend the remaining turns staying at that position.

- Otherwise, if k is less than or equal to the number of moves required to reach it, choose the best possible sum within k turns.

This seems more accurate.

So, for each player, I need to:

1. Find the cycle that the starting position belongs to.

2. Find the position within that cycle with the maximum a value.

3. Compute the minimal number of moves required to reach that position from the starting position.

4. If k is greater than or equal to the number of moves required to reach it, then the score is (k - moves) * a[max] + sum of a values during the moves.

5. If k is less than the number of moves required to reach it, then choose the best possible sum within k turns.

Wait, this seems a bit messy. Maybe there's a better way.

Let me consider that in the trajectory, the player can choose any sub-sequence of positions, with possible repetitions, of length k, where each position is either the same as the previous one or the next in the permutation.

Given that, the player can choose to stay at any position in the trajectory for any number of consecutive turns.

So, the problem reduces to selecting a sequence of positions where each position is either the same as the previous one or the next in the permutation, and maximizing the sum of a values over k turns.

This sounds similar to finding the maximum possible sum in a path where you can choose to stay or move to the next node.

Perhaps I can model this as a graph where each node has two outgoing edges: one that stays and one that moves, and find the path of length k with the maximum sum.

But again, for large n and k, this is not feasible.

I need a mathematical insight here.

Let me consider that the trajectory forms a cycle, and within that cycle, the player can choose to stay at any position for any number of turns.

So, for a cycle of length m, the player can choose to stay at any position in the cycle for any number of turns, but the total number of turns is k.

Wait, but in reality, the trajectory might not be a single cycle; it could be a chain or multiple cycles.

Wait, in a permutation, every element is part of some cycle, and cycles are disjoint.

So, from the starting position, the player can follow the cycle: s -> p[s] -> p[p[s]] -> ... -> s.

Within this cycle, the player can choose to stay at any position in the cycle for any number of turns.

Given that, the player can choose to stay at the position with the maximum a value in the cycle for as many turns as possible, after reaching it.

So, for each player, I need to:

- Find the cycle that the starting position belongs to.

- Find the maximum a value in that cycle.

- Find the minimal number of moves required to reach that position from the starting position.

- If k is greater than or equal to the number of moves required to reach it, then the score is (k - moves) * a[max] + sum of a values during the moves.

- If k is less than the number of moves required to reach it, then the score is the sum of the a values along the path for k moves.

Wait, but this still seems complicated.

Let me try to formalize it.

Let’s define for a player starting at position s:

- Let’s find the position t in the cycle containing s such that a[t] is maximum.

- Let’s find the minimal number of moves required to reach t from s, say m moves.

- Then, if k >= m, the player can reach t in m moves and stay there for the remaining (k - m) moves.

- The total score would be sum of a values during the m moves plus (k - m) * a[t].

- If k < m, the player cannot reach t and has to choose the best possible sum within k moves.

So, for each player, I need to:

1. Find the cycle containing the starting position.

2. Find the position t in the cycle with the maximum a value.

3. Find the minimal number of moves to reach t from s.

4. Compute the score based on whether k is greater than or equal to m.

Wait, but in the cycle, there can be multiple positions with the same maximum a value. I need to choose the one that can be reached with the minimal number of moves.

So, I need to find the position t with maximum a[t], and among those, the one with the smallest distance from s.

Distance here is the number of moves required to reach from s to t.

So, for each player, I need to find the position in their cycle with the maximum a value and the minimal distance from the starting position.

Then, compute the score based on whether k is greater than or equal to that distance.

This seems manageable.

Now, to implement this efficiently, considering that n can be up to 2e5 and k up to 1e9, I need an efficient way to find the cycle, find the position with the maximum a value and the minimal distance from s.

An efficient way to find the cycle is to follow the permutation from s until we return back to s.

During this process, I can keep track of the positions visited, the a values, and find the position with the maximum a value and the minimal distance from s.

Then, for each player, I can compute the score as follows:

- If k >= minimal distance to t, then score = (k - m) * a[t] + sum of a values from s to t in m moves.

- If k < minimal distance to t, then score is the maximum possible sum within k moves.

Wait, but in the first case, it's not just the sum from s to t, because the player can choose to stay at intermediate positions.

Wait, no, actually, the player chooses to move directly to t in minimal moves, and then stay at t.

So, the sum would be the a values along the path from s to t, plus (k - m) * a[t].

But in reality, the player can choose to stay at any position for any number of turns, but to maximize the score, it's best to reach the position with the maximum a as soon as possible and then stay there.

Hence, the minimal distance m is the minimal number of moves to reach t from s, and then stay at t for the remaining turns.

So, the total score is sum of a values along the path from s to t in m moves plus (k - m) * a[t].

But actually, since the player can choose to stay at any position, they might choose to stay at positions with high a values before reaching t, but in order to maximize the total score, it's better to reach t as quickly as possible and then stay there.

Because a[t] is the maximum a in the cycle, any other position has a <= a[t].

Hence, staying at intermediate positions would not be beneficial; it's better to reach t and stay there.

Therefore, the optimal strategy is to reach t in minimal moves and then stay at t.

Hence, for each player, compute:

- t: position with maximum a in the cycle

- m: minimal distance from s to t

- If k >= m, score = (k - m) * a[t] + sum of a values along the path from s to t

- If k < m, score is the maximum possible sum within k moves without reaching t.

Wait, but in the earlier example, when k=2, for Bodya, m=2 to reach position 1, but k=2 >= m, so score = (2 - 2) * 7 + (5 + 2) = 0 * 7 + 7 = 7, but in the example, staying at 3 gives 10, which is better.

Wait, there's inconsistency here.

In the example, m=2 to reach position 1, a=7, but sum of a values along the path from s=3 to t=1 is a[3] + a[2] = 5 + 2 = 7, then stay at t=1 for (k - m) = 0 turns, so total score = 7, which is less than staying at 3 for both turns, getting 5 + 5 = 10.

Hence, in this case, staying at s is better than moving to t.

So, my previous assumption is incorrect.

Hence, perhaps the optimal strategy is:

- If a[s] >= a[t], then stay at s for all k turns.

- Else, reach t in m moves and stay there for the remaining turns.

Wait, in the example, a[s]=5, a[t]=7, so a[s] < a[t], hence should reach t and stay there.

But as shown, reaching t in m=2 moves gives a sum of 5 + 2 + (k - m) * 7, but k=2, so sum = 5 + 2 + 0 * 7 = 7, which is less than staying at s for k=2 turns: 5 + 5 = 10.

Hence, in this case, staying at s is better.

So, the previous strategy is not always optimal.

Hence, perhaps the optimal strategy is:

- Compute the maximum a value in the cycle, a_max.

- Find the minimal distance from s to any position with a = a_max.

- If k >= minimal distance, then score = (k - m) * a_max + sum of a values along the path from s to t in m moves.

- If k < minimal distance, then find the maximum possible sum within k moves.

But in the example, a_max=7, minimal distance m=2, k=2, sum along the path = 5 + 2 =7, which is less than staying at s for k=2 turns: 5 + 5 =10.

Hence, in this case, staying at s is better.

So, perhaps the optimal strategy is:

- Find all positions in the cycle with a = a_max.

- For each such position, compute the minimal distance from s.

- Then, for each such position, compute the score if the player reaches it in minimal distance and stays there for the remaining turns.

- Choose the maximum among these scores.

- Additionally, consider the option of staying at s for all k turns.

- Choose the maximum among these options.

In the example, positions with a_max=7 are position 1.

Minimal distance from s=3 to t=1 is m=2.

Score if reach t and stay: (k - m) * a_max + sum from s to t = (2 - 2) * 7 + (5 + 2) = 7

Score if stay at s for k turns: k * a[s] = 2 * 5 =10

So, the better option is to stay at s, getting 10.

Hence, the optimal strategy is:

- Find a_max in the cycle.

- Find the minimal distance m from s to any position with a = a_max.

- Compute score1 = (k - m) * a_max + sum of a values along the path from s to t in m moves.

- Compute score2 = k * a[s]

- Choose the maximum of score1 and score2.

Wait, but in the example, score1=7 and score2=10, so choose score2=10.

Hence, for each player, compute both score1 and score2, and choose the maximum.

This seems to be the optimal strategy.

Now, to implement this efficiently, I need to:

- For each player, find the cycle containing their starting position.

- Find a_max in that cycle.

- Find the positions in the cycle with a = a_max.

- For each such position, find the minimal distance from s.

- Compute score1 for the position with the smallest m.

- Compute score2 = k * a[s]

- Choose the maximum of score1 and score2.

Now, to find the cycle, I can follow the permutation from s until I return back to s, keeping track of the positions and a values.

To find a_max, I can keep track of the maximum a value in the cycle.

To find the positions with a = a_max, I can store them in a list.

Then, for each such position, compute the distance from s.

Find the minimal distance m among them.

Then, compute sum_path, which is the sum of a values along the path from s to t in m moves.

Then, score1 = (k - m) * a_max + sum_path

Score2 = k * a[s]

Choose the maximum of score1 and score2.

Return the maximum between score1 and score2 for each player.

This seems efficient enough, as finding the cycle can be done in O(n) time, and since n is up to 2e5, and t is up to 1e4, I need to make sure that the total time is acceptable.

Wait, but t can be up to 1e4, and n up to 2e5, but the sum of n over all test cases does not exceed 2e5, so it should be fine.

Now, in the code provided, there's a function func_1(a, p, s, k):

It seems to implement some kind of traversal of the permutation, keeping track of visited positions and computing some maximum score.

But, I need to verify if this function correctly implements the optimal strategy I just described.

Looking at the function:

def func_1(a, p, s, k):

n = len(p)

mx = 0

cur = 0

vis = [0 for _ in range(n)]

while not vis[s] and k > 0:

vis[s] = 1

mx = max(mx, cur + k * a[s])

cur += a[s]

k -= 1

s = p[s]

return mx

So, what this function does is:

- It starts at position s.

- It keeps moving to p[s] unless it has visited that position before.

- For each position, it keeps adding a[s] to cur.

- At each step, it computes cur + k * a[s] and keeps the maximum.

- Finally, it returns the maximum mx.

So, it seems to be considering the sum of a[s] for the positions it visits, plus the remaining k moves staying at the last position.

But, this doesn't align with the optimal strategy I described earlier.

In the earlier strategy, we need to consider:

- Finding the cycle containing s.

- Finding a_max in the cycle.

- Finding the minimal distance m to a position with a = a_max.

- Computing score1 = (k - m) * a_max + sum of a values along the path from s to t in m moves.

- Computing score2 = k * a[s]

- Choosing the maximum of score1 and score2.

But in the provided function, it seems to be traversing the permutation, keeping track of visited positions, and computing the maximum of cur + k * a[s] at each step.

This seems to be attempting to find the best point to stay at a position for the remaining moves.

But, it's not explicitly finding the cycle, finding a_max, and computing the minimal distance m.

However, perhaps it's a more optimized way to compute the maximum score.

Let me see.

In the while loop:

- It marks s as visited.

- Computes mx = max(mx, cur + k * a[s])

- Adds a[s] to cur.

- Decrements k.

- Moves to s = p[s]

So, it's traversing the permutation from s, keeping track of the sum cur, and at each step, considering staying at the current position for the remaining k moves.

Then, mx keeps the maximum of cur + k * a[s] at each step.

Finally, it returns the maximum mx.

So, it's considering, at each step, the sum of a values up to that point plus staying at the current position for the remaining moves.

Hence, it's effectively choosing to move to the next position and then stay there for the remaining moves, for each possible position in the trajectory.

Then, it takes the maximum among these choices.

Wait, but in the earlier example, when k=2, s=3, p[3]=2, p[2]=1.

So, the trajectory is 3 -> 2 -> 1.

In the first iteration:

- vis[3] = 1

- mx = max(0 + 2 * a[3]) = 2 * 5 =10

- cur += a[3] =5

- k =1

- s =2

Second iteration:

- vis[2] =1

- mx = max(10, 5 +1 * a[2]) = max(10, 5 + 2) =10

- cur += a[2] =7

- k=0

- s=1

Third iteration:

- vis[1] =1

- mx = max(10, 7 +0 * a[1]) = max(10,7)=10

- cur += a[1]=13

- k=-1, stop

So, mx=10, which matches the score of staying at s=3 for both turns: 5 +5=10.

Hence, in this case, it correctly computed the maximum score.

Let me check another case.

Suppose n=3, k=3, s=1, p=[2,3,1], a=[1,2,3]

Cycle: 1->2->3->1

a_values: 1,2,3

a_max=3, at position 3.

Minimal distance from 1 to 3 is 2 moves: 1->2->3.

So, score1 = (3 - 2) * 3 + a[1] + a[2] =1*3 +1+2=6

Score2 =3 * a[1]=3*1=3

Maximum is 6.

According to the function:

Iteration 1:

- vis[1]=1

- mx = max(0 +3*1)=3

- cur +=1=1

- k=2

- s=2

Iteration 2:

- vis[2]=1

- mx = max(3,1 +2*2)= max(3,1+4)=5

- cur +=2=3

- k=1

- s=3

Iteration 3:

- vis[3]=1

- mx = max(5,3 +1*3)= max(5,3+3)=6

- cur +=3=6

- k=0

- s=1 (but k=0, stop)

So, mx=6, which matches the expected score1=6.

Hence, in this case, it also correctly computed the maximum score.

So, perhaps this function is correctly implementing the optimal strategy.

Let me see how it works in general.

In the while loop, it's traversing the permutation, accumulating cur += a[s], and at each step, considering staying at the current position for the remaining k moves.

Hence, mx = max(mx, cur + k * a[s])

This effectively considers the sum of a values up to the current position plus staying at s for the remaining k moves.

So, it's considering all possible points where the player stops moving and stays at that position for the remaining moves.

Hence, it's considering all possible points to switch from moving to staying.

In the first example, it considered:

- Stay at s=3 for both turns: cur + k * a[3] =0 +2*5=10

- Move to s=2, stay at s=2 for remaining 1 turn: cur=5, k=1, cur + k * a[2]=5 +1*2=7

- Move to s=1, stay at s=1 for remaining 0 turns: cur=7, k=0, cur + k * a[1]=7 +0*7=7

Hence, the maximum is 10, which is correct.

In the second example:

- Stay at s=1 for all 3 turns: cur + k * a[1]=0 +3*1=3

- Move to s=2, stay at s=2 for remaining 2 turns: cur=1, k=2, cur + k * a[2]=1 +2*2=5

- Move to s=3, stay at s=3 for remaining 1 turn: cur=1+2=3, k=1, cur + k * a[3]=3 +1*3=6

Hence, the maximum is 6, which is correct.

So, it seems that this function correctly computes the maximum possible score for each player by considering all possible points to switch from moving to staying.

Hence, the provided program is correct.

Therefore, the answer is Correctness: **True**

**Final Answer**

\boxed{\text{Correctness: True}}