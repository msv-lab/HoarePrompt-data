Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and there are multiple queries. Each query gives me a range within this array, and I need to find two indices within that range such that the elements at those indices are different. If such a pair doesn't exist, I should return -1 -1.

First, I need to understand the input format. The input consists of multiple test cases. Each test case starts with an integer t, indicating the number of test cases to follow. For each test case, there's an integer n, which is the length of the array, followed by the array itself, then an integer q, which is the number of queries, and finally q lines each containing two integers l and r, which define the range for each query.

My task is to process each query and find a pair of indices within the specified range where the elements are different. If no such pair exists, I should output -1 -1.

Let me think about how to approach this efficiently, especially considering the constraints. The sum of n across all test cases is up to 2*10^5, and the same for q. So, I need an efficient solution that can handle up to 2*10^5 queries on an array of up to 2*10^5 elements.

One straightforward way is to, for each query, iterate through the range from l to r and check if there are any two different elements. However, this would be O(q * n), which could be up to 4*10^10 operations, which is way too slow.

I need a smarter approach. Let's think about precomputing some information about the array that can help me answer the queries quickly.

One idea is to precompute for each position the next position where a different element occurs. That way, for each query, I can find the smallest possible pair of indices with different elements.

But maybe there's a better way. Another approach is to use a prefix array that keeps track of the number of unique elements up to each position. Then, for each query, I can compute the number of unique elements in the range l to r by subtracting the prefix values. If the number of unique elements is greater than 1, then there exists at least one pair of different elements in that range.

Wait, but the problem requires me to actually output the indices of such a pair, not just whether it exists. So, while the prefix unique count can tell me if such a pair exists, I still need a way to find the actual indices.

Let me consider another approach. I can preprocess the array to find all positions where the element changes. That is, for each position i, find the smallest j > i such that a[j] != a[i]. Then, for each query, I can find the smallest such j within the range l to r.

But I need to optimize this further. Maybe I can use a segment tree or a sparse table to answer range queries efficiently.

Wait, but perhaps there's a simpler way. Since the problem allows me to output any pair of indices with different elements within the range, I don't necessarily need to find the smallest or any specific pair, just any pair that satisfies the condition.

So, for each query, I can iterate through the range l to r and find the first pair of consecutive elements that are different. That would be efficient enough, as it's O(q * n), but as I thought earlier, that's too slow for the given constraints.

Hmm, maybe I can preprocess the array to store for each position the next position where a different element occurs. Then, for each query, I can check if there's any position within the range that has a next different element also within the range.

But I'm overcomplicating this, I think. Let's consider that if there are at least two different elements in the range, then there must be at least one pair of indices with different elements.

So, perhaps I can precompute for each possible range the number of unique elements, but that seems too memory-intensive.

Wait, maybe I can sort the queries and process them using a sliding window approach, keeping track of the unique elements in the current window.

But considering the constraints, with q up to 2*10^5 per test case, and multiple test cases, I need something more efficient.

Let me think differently. For each query, if I can find the first and last positions in the range where the element is different from the first element, then I can use those positions as the pair.

Wait, but that might not always work. Let me consider an example.

Suppose the array is [1, 1, 2, 1, 1], and the query is [1, 5]. The first element is 1, and the third element is 2, which is different. So, I can output indices 1 and 3.

Another query is [1, 2]. Both elements are 1, so no such pair exists, and I output -1 -1.

Another query is [1, 3]. Elements are [1, 1, 2]. Here, indices 1 and 3 have different elements.

So, in general, for each query, I can iterate through the range and find the first pair of consecutive elements that are different. If no such pair is found, then all elements in the range are the same, and I output -1 -1.

But as I thought earlier, this would be O(q * n), which is too slow.

Is there a way to speed this up? Maybe I can preprocess the array to find for each position the next position where a different element occurs, and then for each query, check if there's any such position within the query range.

Wait, but that still seems like it would require O(q + n) time, which might still be too slow.

Alternatively, perhaps I can use a sparse table to find the minimum and maximum elements in the range quickly. If the minimum and maximum are different, then there exists at least one pair of different elements in the range.

But again, the problem requires me to output the actual indices of such a pair, not just whether it exists.

So, perhaps I can modify the sparse table to store not just the min and max, but also their positions. Then, for each query, if the min and max are different, I can output the positions stored in the sparse table.

But sparse tables are usually used for range minimum queries, and building one for both min and max would require more memory and time.

Wait, maybe there's a better way. Let's consider that for each query, I can find the first position in the range where the element is different from the first element. If such a position exists, I can pair the first position with that position.

If no such position exists, then all elements in the range are the same, and I output -1 -1.

This seems promising. So, I can preprocess an array that for each position i, stores the smallest j > i such that a[j] != a[i].

Then, for each query [l, r], I can check if a[l] != a[l+1], a[l+1] != a[l+2], and so on, up to a[r-1] != a[r]. If any of these are true, I can output l and j where j is the first position where a[j] != a[l].

But again, this seems similar to the initial approach, which is too slow.

Wait, perhaps I can preprocess for each position i, the next position j where a[j] != a[i]. I can compute this using a simple loop.

Here's how I can do it:

Initialize a list next_diff of size n, where next_diff[i] is the smallest j > i such that a[j] != a[i], or j = n if no such position exists.

To compute next_diff:

Initialize next_diff[i] = i + 1 for all i from 0 to n-2.

Set next_diff[n-1] = n.

Then, iterate from i = 0 to n-2:

If a[i] != a[i+1], set next_diff[i] = i+1.

Else, set next_diff[i] = next_diff[i+1].

This way, next_diff[i] will be the smallest j > i where a[j] != a[i].

Now, for each query [l, r], check if next_diff[l-1] <= r. If it is, output l and next_diff[l-1]. Otherwise, output -1 -1.

This seems efficient, as preprocessing next_diff is O(n), and answering each query is O(1).

Let me verify this with an example.

Take the first test case:

n = 5

a = [1, 1, 2, 1, 1]

Compute next_diff:

Initialize next_diff = [1, 2, 3, 4, 5]

Then:

i=0: a[0]=1, a[1]=1 → a[0]==a[1], so next_diff[0] = next_diff[1]

i=1: a[1]=1, a[2]=2 → a[1]!=a[2], so next_diff[1] = 2

i=2: a[2]=2, a[3]=1 → a[2]!=a[3], so next_diff[2] = 3

i=3: a[3]=1, a[4]=1 → a[3]==a[4], so next_diff[3] = next_diff[4] = 5

So, next_diff = [2, 2, 3, 5, 5]

Now, for query [1,5]:

l=1, r=5

next_diff[0]=2 <=5, so output 1 and 2

For query [1,2]:

l=1, r=2

next_diff[0]=2 >2, so output -1 -1

For query [1,3]:

l=1, r=3

next_diff[0]=2 <=3, so output 1 and 2

Wait, but in the example output, for the first test case, the outputs are:

2 3

-1 -1

1 3

Hmm, in my approach, I output 1 2 for the first query, but in the example, it's 2 3. Is there an issue?

Wait, no, the problem says "output two integers separated by space: i and j (l ≤ i, j ≤ r), for which a_i ≠ a_j. If such a pair does not exist, output i=-1 and j=-1."

So, for the first query [1,5], any pair where a_i ≠ a_j is acceptable. So, 1 2 is also correct, as a[1]=1 and a[2]=1 are equal, but a[2]=1 and a[3]=2 are different. So, 2 3 is also correct. The problem allows any such pair.

So, my approach needs to be adjusted. In my earlier thought process, I planned to output l and next_diff[l-1], but in the first query, l=1, next_diff[0]=2, but a[1]=1 and a[2]=1 are equal, which is incorrect.

Wait, there's a mistake here. In my earlier computation of next_diff, I set next_diff[i] to the smallest j > i where a[j] != a[i]. In the array [1,1,2,1,1], next_diff[0]=2 because a[2]=2 != a[0]=1.

So, in the first query [1,5], l=1, next_diff[0]=2, which is within the range [1,5], so I should output 1 and 2. But a[1]=1 and a[2]=1 are equal, which is incorrect.

Wait, that can't be right. According to my definition, next_diff[i] is the smallest j > i where a[j] != a[i]. In this case, next_diff[0]=2 because a[2]=2 != a[0]=1.

But a[1]=1 == a[0]=1, so why is next_diff[0]=2?

Wait, no, in my earlier step, I set next_diff[0] = next_diff[1], which is 2, because a[0]==a[1].

But a[2]=2 != a[0]=1, so next_diff[0]=2.

But a[1]=1 == a[0]=1, so outputting 1 and 2 would be incorrect because a[1]=a[2].

So, my approach has a flaw here.

Let me rethink this.

I need to ensure that the pair I output has different elements.

In the array [1,1,2,1,1], for the range [1,5], a[1]=1, a[2]=1, a[3]=2, a[4]=1, a[5]=1.

So, pairs like (1,3), (2,3), (3,4), etc., have different elements.

So, in my approach, if I output l and next_diff[l-1], but next_diff[l-1] is the first position where a[j] != a[l-1], which might not necessarily be different from a[l].

Wait, perhaps I need to adjust my approach.

Let me try this:

For each query [l, r], find the smallest j > l where a[j] != a[l]. If such a j exists within [l, r], output l and j. Otherwise, output -1 -1.

This way, I ensure that a[l] != a[j].

To preprocess, I can compute for each position i, the smallest j > i where a[j] != a[i].

Then, for each query [l, r], check if next_diff[l-1] <= r. If yes, output l and next_diff[l-1]. Else, output -1 -1.

In the earlier example, for l=1, next_diff[0]=2, but a[1]=1 and a[2]=1 are equal, which is incorrect. So, my approach is flawed.

Wait, no. According to my definition, next_diff[i] is the smallest j > i where a[j] != a[i].

In the array [1,1,2,1,1]:

- next_diff[0]=2, because a[2]=2 != a[0]=1

- next_diff[1]=2, because a[2]=2 != a[1]=1

- next_diff[2]=3, because a[3]=1 != a[2]=2

- next_diff[3]=4, because a[4]=1 != a[3]=1

- next_diff[4]=5, because a[5] doesn't exist

So, for query [1,5], l=1, next_diff[0]=2, but a[1]=1 and a[2]=1 are equal, which contradicts my definition.

Wait, that can't be. According to my definition, next_diff[i] is the smallest j > i where a[j] != a[i].

In this case, a[0]=1, a[1]=1, a[2]=2. So, next_diff[0] should be 2, since a[2]=2 != a[0]=1.

But a[1]=1 == a[0]=1, so next_diff[0]=2 makes sense.

But if I output l=1 and j=2, a[1]=1 and a[2]=1 are equal, which is incorrect.

So, my approach is wrong here.

Wait, perhaps I need to output j=next_diff[l-1], and find i such that a[i] != a[j].

In the above case, j=2, a[2]=2, and I need to find i in [1,5] where a[i] != 2.

Wait, that's not what the problem asks. The problem asks for any two indices i and j in [l,r] where a_i != a_j.

So, in the above case, for [1,5], I can output 1 and 3, since a[1]=1 and a[3]=2 are different.

So, perhaps my approach should be:

For each query [l, r], find the first position j in [l+1, r] where a[j] != a[l]. If such a j exists, output l and j. Otherwise, output -1 -1.

This way, I ensure that a[l] != a[j].

This seems correct.

Implementing this naively would be too slow, as it would be O(q * n).

So, I need a way to find, for each query [l, r], the smallest j > l where a[j] != a[l], and check if j <= r.

To do this efficiently, I can preprocess for each position i, the smallest j > i where a[j] != a[i].

Then, for each query [l, r], check if next_diff[l-1] <= r. If yes, output l and next_diff[l-1]. Else, output -1 -1.

In the earlier example, next_diff[0]=2, but a[1]=1 == a[0]=1, which would lead to outputting l=1 and j=2, which are equal.

Wait, that's incorrect.

Wait, no, according to my definition, next_diff[i] is the smallest j > i where a[j] != a[i].

So, in the array [1,1,2,1,1]:

- next_diff[0]=2, because a[2]=2 != a[0]=1

- next_diff[1]=2, because a[2]=2 != a[1]=1

- next_diff[2]=3, because a[3]=1 != a[2]=2

- next_diff[3]=4, because a[4]=1 != a[3]=1

- next_diff[4]=5, because a[5] doesn't exist

So, for query [1,5], l=1, next_diff[0]=2, but a[1]=1 and a[2]=1 are equal, which contradicts.

Wait, no, a[2]=2 != a[0]=1, but a[1]=1 == a[0]=1.

So, next_diff[0]=2 means that a[2]=2 != a[0]=1, but a[1]=1 == a[0]=1.

So, outputting l=1 and j=2 would be incorrect because a[1]=a[2].

So, my approach is flawed.

Alternative approach: For each position i, find the smallest j > i where a[j] != a[i].

Then, for each query [l, r], find the smallest j where l <= j < next_diff[l-1].

Wait, perhaps I need to find the smallest j >= l where a[j] != a[l].

Wait, maybe I should iterate from l to r and find the first j where a[j] != a[l].

To do this efficiently, I can preprocess for each position i, the smallest j >= i where a[j] != a[i].

Let me define next_diff[i] as the smallest j >= i where a[j] != a[i].

Then, for each query [l, r], check if next_diff[l] <= r. If yes, output l and next_diff[l]. Else, output -1 -1.

In the earlier example:

a = [1,1,2,1,1]

next_diff = [1, 2, 2, 3, 4]

Wait, let's compute next_diff[i] as the smallest j >= i where a[j] != a[i]:

- i=1: a[1]=1, a[2]=1, a[3]=2 != a[1], so next_diff[1]=3

- i=2: a[2]=1, a[3]=2 != a[2], so next_diff[2]=3

- i=3: a[3]=2, a[4]=1 != a[3], so next_diff[3]=4

- i=4: a[4]=1, a[5]=1 == a[4], so next_diff[4]=5

- i=5: a[5]=1, no further elements, so next_diff[5]=5

Wait, in code, indices start from 0, but in the problem, indices start from 1.

So, in code, a[0] corresponds to a_1.

I need to be careful with 0-based and 1-based indexing.

Let me adjust my previous thought.

In code:

a = [1,1,2,1,1] # a[0] is a_1

next_diff = [2, 2, 3, 4, 4]

Where next_diff[i] is the smallest j > i where a[j] != a[i], or n if no such j exists.

Then, for query [1,5]: l=1, r=5

next_diff[0]=2 <=5, so output l=1 and j=2

But a[1]=1 and a[2]=1 are equal, which is incorrect.

Wait, that's the same issue as before.

So, my approach is still flawed.

Perhaps I need to adjust how I compute next_diff.

Wait, maybe I need to find for each position i, the smallest j > i where a[j] != a[i].

But in the above example, for i=0 (a_1=1), the smallest j >0 where a[j] != a[0] is j=2 (a[2]=2).

Similarly, for i=1 (a_2=1), j=2 (a[2]=2).

For i=2 (a_3=2), j=3 (a[3]=1).

And so on.

So, in code, next_diff[0]=2, next_diff[1]=2, next_diff[2]=3, next_diff[3]=4, next_diff[4]=5.

Then, for query [1,5], l=1, r=5, next_diff[0]=2 <=5, so output l=1 and j=3.

Wait, j=next_diff[l-1]=2, but a[1]=1 and a[2]=1 are equal, which is incorrect.

I need to output l=1 and j=3, where a[1]=1 and a[3]=2 are different.

So, perhaps I need to set j=next_diff[l-1], and i=l.

But in this case, a[l] and a[j] may not be different if there are multiple consecutive elements equal to a[l].

Wait, in the above example, next_diff[0]=2, which points to a[3]=2 != a[1]=1.

So, outputting l=1 and j=3 is correct.

But how do I generalize this?

Wait, perhaps I need to set j=next_diff[l-1], and then check if a[j] != a[l].

If a[j] != a[l], output l and j.

Else, set j=next_diff[j], and repeat until j > r.

This seems a bit involved, and may not be efficient enough for q up to 2e5.

Is there a better way?

Let me consider another approach: For each query [l, r], find the minimum and maximum values in the range [l, r]. If min != max, then there exists at least one pair of different elements. To find such a pair, I can find the leftmost position where a[j] != min, and output l and that j.

But finding the min and max for each query would require a range minimum/maximum query structure, like a segment tree, which is feasible.

But again, building a segment tree for each test case might be too slow if t is up to 1e4.

Wait, t is up to 1e4, and n and q are up to 2e5 in total across all test cases. So, the total time should be O(2e5 log 2e5), which should be acceptable.

So, here's a plan:

For each test case:

- Build a segment tree for the array a to answer range min and max queries.

- For