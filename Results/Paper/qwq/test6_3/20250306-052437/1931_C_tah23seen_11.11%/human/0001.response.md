Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers: i, j, and x, where 1 ≤ i ≤ j ≤ n, and then setting all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is essentially the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I have to spend to achieve this. It's guaranteed that it can always be done, so I don't need to worry about cases where it's impossible.

First, I need to understand the operation clearly. I can choose a subarray from i to j and set all its elements to x, and this costs (j - i + 1) burles. I can do this operation at most once. After performing this operation (or choosing not to), all elements in the array should be equal.

Let me think about some examples to grasp this better.

Example 1:

Input: [1, 2, 3, 4, 5, 1]

Output: 4

Explanation: By setting elements from index 2 to 4 to 1, the array becomes [1,1,1,1,1,1], which costs 3 burles. But the output is 4, so maybe there's a better way.

Wait, maybe setting elements from index 2 to 5 to 1: [1,2,3,4,5,1] -> [1,1,1,1,1,1], which costs 4 burles. Is there a way to do it with less cost? If I set elements from index 1 to 6 to 1, that would cost 6 burles, which is worse. So, 4 seems reasonable.

Example 2:

Input: [1,1,1,1,1,1,1]

Output: 0

Explanation: All elements are already equal, so no operation is needed.

Example 3:

Input: [8,8,8,1,2,8,8,8]

Output: 2

Explanation: Set elements from index 4 to 5 to 8: [8,8,8,1,2,8,8,8] -> [8,8,8,8,8,8,8,8], which costs 2 burles.

Is there a better way? If I set from index 3 to 6 to 8, that would cost 4 burles, which is worse. So, 2 is better.

Example 4:

Input: [1]

Output: 0

Explanation: Only one element, already equal.

Example 5:

Input: [1,2]

Output: 1

Explanation: Set either element to match the other. For example, set index 2 to 1: [1,1], cost 1 burle.

Example 6:

Input: [1,2,3]

Output: 2

Explanation: Set index 2 and 3 to 1: [1,1,1], cost 2 burles.

Alternatively, set index 1 and 2 to 3: [3,3,3], cost 2 burles.

So, the minimal cost is 2.

Example 7:

Input: [4,3,2,7,1,1,3]

Output: 6

Explanation: Maybe set from index 1 to 6 to 3: [3,3,3,3,3,3,3], cost 6 burles.

Is there a better way? If I set from index 2 to 7 to 1: [4,1,1,1,1,1,3], which still has different elements, so that doesn't work.

Wait, I need to make all elements equal in one operation or without any operation.

Example 8:

Input: [9,9,2,9,2,5,5,5,3]

Output: 7

Explanation: Not sure, but presumably by setting a certain subarray to make all elements equal.

Alright, now I need to find a general approach to solve this problem.

First, I need to consider that I can perform at most one operation, which allows me to set a subarray to a single value, and I need to minimize the cost, which is the length of the subarray being set.

My goal is to make all elements equal. There are a few scenarios to consider:

1. All elements are already equal. In this case, the cost is 0.

2. Not all elements are equal, and I need to perform an operation to make them equal.

In the second case, I need to choose a subarray to set to a value such that, after setting, all elements become equal. I need to choose the subarray and the value wisely to minimize the cost.

One approach is to choose a value that is already present in the array and set the minimal possible subarray to that value to make all elements equal.

Wait, but I can choose any value x, not necessarily present in the array.

But if I choose a value not present in the array, I might have to set larger subarrays, which could increase the cost.

So, it's probably better to choose a value that is already present in the array to minimize the subarray that needs to be set.

Let me think differently.

Suppose I choose a value x that I want all elements to be equal to. Then, I need to set all elements that are not equal to x to x, but I can do this in one operation by selecting the subarray that covers all positions where the elements are not equal to x.

But the problem is that I can only perform one operation, and I need to minimize the length of the subarray I set.

Wait, but if I set a subarray to x, elements outside this subarray remain unchanged. So, to make all elements equal to x, I need to ensure that all elements not equal to x are covered by this subarray.

In other words, the subarray I set should include all positions where the original array has values not equal to x.

So, for a chosen x, the minimal subarray that covers all positions where a[i] != x is the minimal subarray from the leftmost position where a[i] != x to the rightmost position where a[j] != x.

Then, the cost is (j - i + 1).

My task is to choose x such that this cost is minimized.

So, the strategy is:

- Choose x as one of the values in the array.

- Find the leftmost position where a[i] != x.

- Find the rightmost position where a[j] != x.

- The minimal subarray to set is from i to j, with cost (j - i + 1).

- Choose x such that this cost is minimized.

Wait, but I need to consider that after setting this subarray to x, the elements in this subarray become x, and the elements outside remain as they are, which should already be equal to x.

So, in other words, the elements outside this subarray should already be equal to x.

Therefore, to minimize the cost, I need to choose x such that the number of elements equal to x is maximized, and the subarray to set is minimized.

Wait, perhaps I need to choose x that appears the most, and then set the subarray that covers all positions where a[i] != x.

Let me think about the earlier example:

[1,2,3,4,5,1]

If I choose x=1, then positions where a[i] != 1 are 2,3,4,5.

So, from index 2 to 5, which is 4 elements, cost=4.

If I choose x=2, positions where a[i] != 2 are 1,3,4,5,6.

Cost=6.

Similarly for x=3: positions 1,2,4,5,6.

Cost=6.

x=4: positions 1,2,3,5,6.

Cost=6.

x=5: positions 1,2,3,4,6.

Cost=6.

So, choosing x=1 gives the minimal cost of 4.

Another example:

[8,8,8,1,2,8,8,8]

Choose x=8:

Positions where a[i] != 8 are 4 and 5.

Set subarray from 4 to 5, cost=2.

Choose x=1:

Positions where a[i] !=1 are 1,2,3,5,6,7,8.

Cost=8.

Similarly for x=2:

Positions where a[i] !=2 are 1,2,3,4,6,7,8.

Cost=7.

So, choosing x=8 is better.

Therefore, the strategy is to choose the value that appears the most in the array, and set the subarray that covers all positions where the array differs from this value.

Wait, but in the first example, x=1 appears twice, while x=2,3,4,5 appear once each. So, choosing x=1 is the best.

In the second example, x=8 appears 6 times, x=1 and x=2 appear once each.

So, choosing x=8 minimizes the cost.

Wait, but in the first example, choosing x=1, the subarray to set is from index 2 to 5, which is 4 elements.

But, is there a way to choose x such that the subarray to set is smaller?

Wait, maybe I can choose x to be a value that appears in the array, and the subarray to set is the minimal coverage of positions where a[i] != x.

But perhaps there's a smarter way.

Wait, maybe I can find the minimal subarray such that, when set to a certain value, makes the entire array equal to that value.

So, I need to find a subarray [i,j] and set it to x, such that all elements outside [i,j] are already equal to x.

So, the elements before i and after j should already be equal to x.

And within [i,j], after setting to x, everything is x.

Hence, the minimal cost is the minimal length of [i,j] such that:

- All elements before i are equal to x.

- All elements after j are equal to x.

- Within [i,j], we set all elements to x.

To minimize the cost, which is (j - i + 1), I need to maximize the prefix and suffix that are already equal to x.

So, for each possible x, I can find:

- The maximal prefix length where a[1] == a[2] == ... == a[p] == x.

- The maximal suffix length where a[n - s + 1] == ... == a[n] == x.

Then, the minimal subarray to set is from p+1 to n - s, and the cost is (n - s - p).

Wait, but I need to make sure that between p and n - s, all elements are set to x.

Wait, perhaps I need to find for each x:

- The maximal prefix length that is equal to x.

- The maximal suffix length that is equal to x.

Then, the minimal subarray to set is from the end of the prefix to the start of the suffix, and the cost is (n - prefix - suffix).

But I need to make sure that between the prefix and the suffix, all elements are set to x.

Wait, perhaps I can think of it as:

- Find the longest prefix that is equal to x.

- Find the longest suffix that is equal to x.

- Then, the subarray to set is from the end of the prefix to the start of the suffix.

- The cost is (n - prefix - suffix).

- Choose x such that this cost is minimized.

Yes, that seems correct.

Let me test this with the first example:

[1,2,3,4,5,1], n=6

Choose x=1:

- Prefix: a[1]=1, a[2]=2 → prefix=1

- Suffix: a[6]=1, a[5]=5 → suffix=1

- Cost: 6 - 1 -1 =4

Choose x=2:

- Prefix: a[1]=1 !=2 → prefix=0

- Suffix: a[6]=1 !=2 → suffix=0

- Cost: 6 -0 -0 =6

Similarly for x=3,4,5:

- All have prefix=0, suffix=0

- Cost=6

Hence, minimal cost is 4.

Another example:

[8,8,8,1,2,8,8,8], n=8

Choose x=8:

- Prefix: a[1]=8, a[2]=8, a[3]=8, a[4]=1 → prefix=3

- Suffix: a[8]=8, a[7]=8, a[6]=8, a[5]=2 → suffix=3

- Cost: 8 -3 -3 =2

Choose x=1:

- Prefix: 0

- Suffix: 0

- Cost:8

Choose x=2:

- Prefix:0

- Suffix:0

- Cost:8

Hence, minimal cost is 2.

This seems correct.

So, the algorithm is:

- For each possible x (from 1 to n, since a_i ∈ [1,n])

- Find the maximal prefix length where a[i]==x

- Find the maximal suffix length where a[i]==x

- Compute cost = n - prefix - suffix

- Choose the minimal cost among all x

- If there exists an x with prefix + suffix >= n, then cost=0

Wait, if prefix + suffix >=n, then cost is 0, because the overlapping part in the middle is already covered by the prefix and suffix being equal to x.

Wait, no. Because prefix and suffix are disjoint, unless there is an overlap.

Wait, actually, prefix and suffix might overlap if prefix + suffix > n.

But in practice, we just compute n - prefix - suffix.

If prefix + suffix >=n, then n - prefix - suffix <=0, but cost can't be negative, so cost=0.

Hence, in that case, cost is 0.

Which makes sense, because if prefix + suffix >=n, it means the entire array is equal to x.

Hence, no operation is needed.

So, in code, I need to ensure that cost is at least 0.

Now, to implement this efficiently, considering that t can be up to 10^4 and n up to 2*10^5, with total n across all test cases up to 2*10^5, I need an efficient algorithm, O(n) per test case.

So, for each test case, I need to:

- Find, for each possible x, the maximal prefix and suffix where a[i]==x.

- Compute the minimal cost over all x.

But iterating over all possible x from 1 to n for each test case would be O(n^2), which is too slow.

Hence, I need a smarter way.

Wait, perhaps I can find the maximal prefix and suffix for each x separately.

But that would still be O(n^2).

Wait, no, n is up to 2*10^5 and t up to 10^4, but total n across all test cases is up to 2*10^5, so overall time complexity should be O(n*t) which is acceptable, since n*t=2*10^5 *10^4=2*10^9, which is too much.

Wait, no, the problem states that the sum of n over all test cases does not exceed 2*10^5, so overall time complexity can be O(n), where n is the total number of elements across all test cases.

Hence, I need an efficient way to compute this for all test cases within 2*10^5 operations.

So, I need to find a way to compute the minimal cost for each test case in O(n) time overall.

Wait, perhaps I can iterate through the array once for each test case, finding the maximal prefix and suffix for each possible x.

But that would still be O(n^2) per test case.

Wait, perhaps there is a better way.

Let me think differently.

I need to make all elements equal, with at most one operation.

An operation consists of setting a subarray to a certain value, with a cost equal to the length of the subarray.

I need to minimize this cost.

An alternative way to look at it is:

- Choose a value x that will be the final value of all elements.

- Identify the subarray that needs to be set to x to make the entire array equal to x.

- The subarray to set is from the first element that is not equal to x to the last element that is not equal to x.

- The cost is the length of this subarray.

- Choose x such that this subarray is as short as possible.

Hence, I need to choose x such that the number of elements that are not equal to x is minimized, and those elements are covered by the subarray being set.

Wait, but I need to cover all elements that are not equal to x by the subarray being set.

Hence, the minimal subarray to set is from the leftmost element not equal to x to the rightmost element not equal to x.

Hence, for each x, the cost is the number of elements not equal to x, unless there are elements equal to x outside this subarray.

Wait, perhaps I'm complicating it.

Let me consider that:

- If I choose x, and there are elements not equal to x, I need to set a subarray that covers all these elements.

- The minimal subarray that covers all elements not equal to x is from the leftmost element not equal to x to the rightmost element not equal to x.

- Hence, the cost is the number of elements between these two positions, inclusive.

- If all elements are equal to x, then the cost is 0.

Hence, for each x, compute the positions of elements not equal to x, find the minimal subarray that covers all of them, which is from the minimal position to the maximal position, and compute its length.

Then, choose the x that minimizes this length.

This seems correct.

Now, to implement this efficiently, I need to:

- For each x, find the positions where a[i] != x.

- Find the minimal subarray that covers all these positions.

- The cost is (max_position - min_position +1).

- Choose the x that minimizes this cost.

But iterating over all x from 1 to n for each test case would be too slow, since n can be up to 2*10^5 and t up to 10^4.

Wait, but the problem states that the sum of n over all test cases is up to 2*10^5, so overall time complexity should be O(n).

Hence, I need a way to compute this efficiently without iterating over all x for each test case.

Perhaps I can find the x that appears the most in the array, and then set the subarray that covers all positions where a[i] != x.

The cost would be the number of elements not equal to x.

But is this the minimal cost?

Wait, in the first example, x=1 appears twice, and the cost is 4.

But x=1 is not the most frequent element, since it appears only twice.

Wait, in that example, x=1 appears twice, x=2 to x=5 appear once each.

So, x=1 is the most frequent.

Wait, but in the third example:

[8,8,8,1,2,8,8,8]

x=8 appears 6 times, x=1 and x=2 appear once each.

Choosing x=8, cost is 2.

If I choose x=1, cost is 7.

If I choose x=2, cost is 7.

Hence, choosing x=8 minimizes the cost.

So, it seems that choosing x as the most frequent element minimizes the cost.

Wait, but is this always true?

Let me check another example.

Consider [1,2,3,4,5], n=5.

Each element appears once.

If I choose any x, say x=1, positions where a[i] !=1 are 2,3,4,5.

Cost=4.

Similarly for any x, cost=4.

Hence, choosing any x, the cost is 4.

But in this case, there is no most frequent element.

Hence, choosing any x gives the same cost.

Hence, choosing the most frequent element seems to minimize the cost.

In cases where multiple elements have the same frequency, choosing any of them gives the same cost.

Hence, a general approach is:

- Find the frequency of each element in the array.

- Choose the element(s) with the highest frequency.

- For that x, compute the minimal subarray to set as described.

- The cost is (n - frequency[x]).

Wait, why n - frequency[x]?

Because the number of elements not equal to x is n - frequency[x], and setting the subarray from the first to the last position where a[i] != x covers all these elements.

Hence, the cost is (last_position_where_a[i]!=x - first_position_where_a[i]!=x +1).

But in the earlier examples, this seems to be equal to n - frequency[x].

Wait, in the first example:

n=6, frequency[1]=2, n - frequency[1]=4, which matches the cost.

In the second example:

n=7, frequency[1]=7, n - frequency[1]=0, which matches.

In the third example:

n=8, frequency[8]=6, n - frequency[8]=2, which matches.

Hence, it seems that the minimal cost is n - frequency[x], where x is the most frequent element.

Hence, the minimal cost is n - max_frequency.

Hence, the minimal cost is n - max frequency of any element in the array.

This seems to hold for all examples.

Hence, the algorithm is:

- For each test case:

- Read n and the array a.

- Find the maximum frequency of any element in a.

- Compute the cost as n - max_frequency.

- Output the cost.

This is efficient, as it only requires counting the frequency of each element in the array, which can be done in O(n) time per test case.

Now, looking at the given program:

t = int(input())

while t:

n = int(input())

arr = [int(x) for x in input().split(' ')]

print(func_1(arr))

t -= 1

def func_1(arr):

i = 0

j = len(arr) -1

while i <=j:

if arr[i] == arr[j]:

i +=1

j -=1

else:

break

if i >j:

return 0

while arr[i] == arr[i+1]:

i +=1

if j != len(arr)-1:

return j -i +1

return j -i

This seems to be attempting to find some subarray to set, but it's not clear what exactly it's doing.

Let's analyze it step by step.

First, it has a function func_1(arr):

- It initializes i=0 and j=len(arr)-1.

- It has a while loop that runs as long as i <= j and arr[i] == arr[j], incrementing i and decrementing j each time.

- If after this loop i > j, it means the entire array is symmetric and all elements are equal, so it returns 0.

- Otherwise, it finds the first position i where arr[i] != arr[i+1].

- Then, if j != len(arr)-1, it returns j - i +1.

- Else, it returns j - i.

Wait, this seems confused.

In the first while loop, it's checking if the array is symmetric, i.e., a[i] == a