Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n ships, each with some durability a_i, and the Kraken attacks them k times. The attacks alternate between the first and last ship, reducing their durability by 1 each time, and if a ship's durability drops to 0, it sinks and is no longer attacked.

I need to figure out how many ships are sunk after k attacks.

First, I need to understand the sequence of attacks. The Kraken starts by attacking the first ship, then the last, then the first again, and so on. Each attack reduces the durability of the targeted ship by 1.

If a ship's durability reaches 0, it sinks and is removed from the list, which affects future attacks because the first and last ships might change.

My goal is to simulate this process efficiently, given that n can be up to 2*10^5 and k can be up to 10^15, and there are up to 10^4 test cases.

Simulating each attack one by one would be too slow because k can be very large. So, I need a smarter way to handle this.

Let me think about it. The attacks alternate between the first and last ships. So, in each pair of attacks (except possibly the last one if k is odd), the Kraken attacks the first and then the last ship.

I can think of this in terms of rounds, where each round consists of attacking the first and the last ship once. In each round, both ships lose 1 durability each, unless one of them has already sunk.

If I can calculate how many full rounds can be performed before k runs out or ships start sinking, I can speed up the process.

Let's consider that in each full round (two attacks), the first and last ships each lose 1 durability. So, the total durability lost per full round is 2.

But, if one of the ships has less durability than the other, it will sink first. For example, if the first ship has durability 1 and the last has durability 3, after one full round, the first ship sinks, and then in the next attack, the Kraken attacks the new first ship.

Wait, no. Actually, if the first ship sinks, the list of ships is reduced, and the new first ship is the next one in line.

This seems a bit tricky to simulate step by step, especially with large n and k.

Maybe I can find a way to calculate how many ships will be sunk without simulating each attack.

Let me consider that in each full round, the first and last ships lose 1 durability each. If both have enough durability, they continue. If one sinks, it's removed, and the next first or last ship takes its place.

I need to find a way to handle this efficiently.

Perhaps I can use two pointers, one for the first ship (left pointer) and one for the last ship (right pointer), and iterate until k is exhausted or all ships are sunk.

Yes, that sounds promising.

I'll initialize l = 0 and r = n-1, representing the first and last ships.

Then, in each step, I'll determine how much durability to remove from both ships in a way that minimizes the number of operations.

Wait, but I need to alternate between attacking the first and the last ship.

So, for each attack, I alternate between attacking the first and the last ship.

But handling k attacks one by one would be too slow for large k.

So, maybe I can handle multiple attacks at once when the pattern is consistent.

Let me think differently.

Suppose I have a list of ships from l to r.

In each full cycle (first then last), I can reduce the durability of both ships by 1, provided they both have positive durability.

If one of them sinks (durability reaches 0), I remove it and update the pointers.

But even this seems too slow for n up to 2e5 and k up to 1e15.

I need a better approach.

Let me consider that in each full cycle (two attacks), both ships lose 1 durability each.

So, the number of full cycles I can perform is limited by the minimum durability of the first and last ships.

Wait, not exactly. Because k could be less than the sum of durabilities, and also, ships can sink in between.

Wait, perhaps I can calculate how many full cycles I can perform before one of the ships sinks.

Let's say I have ships from l to r.

The number of full cycles I can perform is min(a[l], a[r]).

But, if k is larger than the sum of min(a[l], a[r]) over all possible cycles, I need to account for that.

Wait, perhaps I can calculate how many full cycles I can perform before either a[l] or a[r] reaches 0.

So, in each full cycle, both a[l] and a[r] decrease by 1.

The number of full cycles I can perform is min(a[l], a[r]).

After that, one of the ships sinks, and I update the pointers accordingly.

Then, I can repeat this process until k is exhausted or all ships are sunk.

This seems better.

Let me try to formalize this.

Initialize l = 0, r = n-1

Initialize ans = 0 (number of sunk ships)

While l < r and k > 0:

    If a[l] == 0:

        l += 1

        Continue

    If a[r] == 0:

        r -= 1

        Continue

    mi = min(a[l], a[r])

    If mi * 2 <= k:  # Can perform mi full cycles

        a[l] -= mi

        a[r] -= mi

        k -= mi * 2

        If a[l] == 0:

            ans += 1

            l += 1

        If a[r] == 0:

            ans += 1

            r -= 1

    Else:

        # Not enough k to perform mi full cycles

        t = k // 2

        a[l] -= t

        a[r] -= t

        k -= t * 2

        if a[l] == 0:

            ans += 1

            l += 1

        if a[r] == 0:

            ans += 1

            r -= 1

        # Remaining k is k % 2

        if k == 1:

            if l <= r:

                if l == r:

                    if a[l] > 0:

                        a[l] -= 1

                        if a[l] == 0:

                            ans += 1

                else:

                    if a[l] > a[r]:

                        if a[r] > 0:

                            a[r] -= 1

                            if a[r] == 0:

                                ans += 1

                    else:

                        if a[l] > 0:

                            a[l] -= 1

                            if a[l] == 0:

                                ans += 1

        break

After the loop, if l == r and k > 0:

    if a[l] <= k:

        ans += 1

Finally, print ans.

Wait, I need to think carefully about the else part when mi * 2 > k.

In this case, k is not enough to perform mi full cycles.

So, I need to see how many attacks I can perform with the remaining k.

Since attacks alternate between first and last, I can perform k attacks, alternating between them.

But since k can be up to 1e15, I need to handle this efficiently.

Wait, perhaps I can calculate how many attacks I can perform on each ship before k runs out.

But it's getting complicated.

Maybe I should just handle the full cycles where both ships lose mi durability, and then handle the remaining k attacks separately.

Wait, perhaps I can think in terms of the number of attacks per ship.

But I need to ensure that I alternate between first and last ships.

This is getting messy.

Let me look for a better way.

I recall that in similar problems, we can handle multiple operations at once by calculating how much we can reduce from both ends simultaneously.

Given that k can be very large, I need to find a way to handle it in O(1) per operation or as efficiently as possible.

Let me try to think differently.

Suppose I have a list of ships from l to r.

I can calculate how many attacks I can perform on the first and last ships before one of them sinks.

Then, I can remove the sunk ship(s) and repeat the process.

But with n up to 2e5 and k up to 1e15, I need this to be efficient.

Wait, perhaps I can calculate the total number of attacks needed to sink all ships and compare it with k.

But I need to consider the order of attacks.

Wait, maybe I can calculate the number of attacks required to sink each ship, considering their positions.

But I'm not sure.

Let me consider that in each cycle of two attacks, the first and last ships each lose 1 durability.

So, the number of such cycles is the minimum of a[l] and a[r], provided l < r.

After that, one or both ships may sink, and I update l and r accordingly.

I can repeat this process until l >= r or k is exhausted.

Then, if l == r and k > 0, I can perform k more attacks on the remaining ship.

This seems manageable.

Let me try to implement this logic step by step.

Initialize l = 0, r = n-1, ans = 0

While l < r and k > 0:

    If a[l] == 0:

        l += 1

        Continue

    If a[r] == 0:

        r -= 1

        Continue

    mi = min(a[l], a[r])

    If mi * 2 <= k:

        a[l] -= mi

        a[r] -= mi

        k -= mi * 2

        If a[l] == 0:

            ans += 1

            l += 1

        If a[r] == 0:

            ans += 1

            r -= 1

    Else:

        t = k // 2

        a[l] -= t

        a[r] -= t

        k -= t * 2

        if a[l] == 0:

            ans += 1

            l += 1

        if a[r] == 0:

            ans += 1

            r -= 1

        # Remaining k is k % 2

        if k == 1:

            if l <= r:

                if a[l] > 0 and a[r] > 0:

                    if a[l] <= a[r]:

                        a[l] -= 1

                        if a[l] == 0:

                            ans += 1

                    else:

                        a[r] -= 1

                        if a[r] == 0:

                            ans += 1

                elif a[l] > 0:

                    a[l] -= 1

                    if a[l] == 0:

                        ans += 1

                elif a[r] > 0:

                    a[r] -= 1

                    if a[r] == 0:

                        ans += 1

        break

After the loop, if l == r and k > 0:

    if a[l] <= k:

        ans += 1

Finally, print ans.

This seems to cover the cases.

Let me test this logic with the sample input.

Sample Input:

6

4 5

1 2 4 3

4 6

1 2 4 3

5 20

2 7 1 8 2

2 2

3 2

2 15

1 5

2 7

5 2

Sample Output:

2

3

5

0

2

2

Let's take the first test case:

n=4, k=5, a=[1,2,4,3]

Step 1:

mi = min(1,3) = 1

Since 1*2 <= 5, subtract 1 from a[0] and a[3]

a = [0,2,4,2]

k = 5 - 2 = 3

ans +=1, l=1, r=2

Step 2:

a[l]=2, a[r]=4

mi=2

2*2 <=3, subtract 2 from a[1] and a[2]

a = [0,0,2,2]

k=3-4=-1 (wait, k=5-2=3, then subtract 4, which is not possible)

Wait, k=5-2=3, then mi=1, since mi*2=2 <=3

So, a[0]-=1 (but a[0] is already 0), a[3]-=1 (now 2-1=1)

Wait, no, in step 1, a[0] becomes 0, so l +=1

Then in step 2, a[l]=2, a[r]=3

mi=2

2*2=4 <=5-2=3? Wait, k=5-2=3, but mi*2=4 >3

So, t=k//2=1

a[l]-=1 (2-1=1), a[r]-=1 (3-1=2)

k -=2, k=1

If a[l]==0: no

If a[r]==0: no

Remaining k=1, which is odd, so perform one more attack on the first ship (a[l]=1-1=0)

ans +=1, l +=1

Now l=2, r=2

k=0, so no more attacks

Total ans=2

Which matches the sample output.

Good.

Another test case:

n=4, k=6, a=[1,2,4,3]

Step 1:

a[0]=1, a[3]=3, mi=1

1*2=2 <=6, subtract 1 from a[0] and a[3]

a=[0,2,4,2], k=6-2=4, ans+=1, l=1, r=2

Step 2:

a[1]=2, a[2]=4, mi=2

2*2=4 <=4, subtract 2 from a[1] and a[2]

a=[0,0,2,2], k=4-4=0, ans+=1 (for a[1]=0), l=2, r=1

But l=2 and r=1, which means l > r, so stop

Total ans=2+1=3

Which matches the sample output.

Another test case:

n=5, k=20, a=[2,7,1,8,2]

Step 1:

a[0]=2, a[4]=2, mi=2

2*2=4 <=20, subtract 2 from a[0] and a[4]

a=[0,7,1,8,0], k=20-4=16, ans+=1 (a[0]=0), l=1, r=2

Step 2:

a[1]=7, a[2]=1, mi=1

1*2=2 <=16, subtract 1 from a[1] and a[2]

a=[0,6,0,8,0], k=16-2=14, ans+=1 (a[2]=0), r=1

Now l=1, r=1

Step 3:

l == r, and k=14 > a[l]=6

So, ans +=1, total ans=3+1=4?

Wait, no, in the sample output, it's 5.

Wait, perhaps I missed some steps.

Wait, in step 2, after a[2]=0, r=1

So, now l=1, r=1

k=14, a[l]=6

So, k >= a[l], ans +=1, total ans=3+1=4

But sample output is 5.

Wait, perhaps I need to consider that a[r] is also 6, but r=1 is the same as l=1.

Wait, perhaps I need to adjust the logic.

Wait, perhaps when l == r, and k >= a[l], ans +=1

But in this case, a[l]=6, k=14, so ans +=1, total ans=4

But sample output is 5.

Wait, maybe I need to consider that a[4]=0 after step 1, but it was already set to 0.

Wait, perhaps I need to check all ships that have durability >0 and are not yet sunk.

Wait, maybe I need to count all ships that have durability <=k, but I need to follow the attack sequence.

This seems tricky.

Maybe my approach is missing something.

Wait, perhaps I need to consider that after l > r, no more attacks can be performed.

But in the sample input, the output is 5, which suggests that all ships are sunk.

Wait, in the first test case with n=5, k=20, a=[2,7,1,8,2]

After step 1: a=[0,7,1,8,0], l=1, r=2

After step 2: a=[0,6,0,8,0], l=1, r=1

Then, l == r, k=14 >= a[l]=6, so ans +=1, total ans=4

But sample output is 5, so perhaps I need to continue.

Wait, maybe after l > r, if k is still remaining, I need to check if there are any remaining ships that can be sunk with the remaining k attacks.

But according to the problem, once l > r, all ships have been considered, and any remaining k doesn't affect the count.

But the sample output is 5, which suggests that all ships are sunk.

Wait, perhaps in the initial steps, some ships are sunk that I didn't account for.

Wait, let's see:

Initial a=[2,7,1,8,2]

Step 1: attack first (2->1), last (2->1), k=4

Step 2: attack first (1->0), last (1->0), sink first and last, a=[7,1,8], k=3

Step 3: attack first (7->6), last (8->7), k=1

Step 4: attack first (6->5), k=0

So, sunk ships: first and last in step 2, total ans=2

But sample output is 5, which doesn't match.

Wait, perhaps I misread the sample input.

Wait, no, for n=5, k=20, a=[2,7,1,8,2], output is 5.

Wait, perhaps the Kraken continues attacking until k=0.

In the above steps, after step 4, l=1, r=2, a=[5,1,7], k=16

Then continue:

Step 5: attack first (5->4), last (7->6), k=14

Step 6: attack first (4->3), last (6->5), k=12

Step 7: attack first (3->2), last (5->4), k=10

Step 8: attack first (2->1), last (4->3), k=8

Step 9: attack first (1->0), sink first, l=2, r=2, a=[0,1,3], k=7

Step 10: attack last (3->2), k=6

Step 11: attack first (1->0), sink first, l=2, r=1, l > r, stop

Total sunk ships: first, last in step 2, first in step 9, last in step 10, first in step 11, total ans=5

Okay, so my initial approach missed these steps.

I need to handle the attacks more carefully, especially when ships are sinking in between.

This suggests that my initial approach of handling full cycles is not sufficient, and I need a better way to handle the attacks.

Given the time constraints, perhaps I need to find a mathematical way to calculate the number of sunk ships without simulating each attack.

But I'm not sure how to do that.

Alternatively, I can try to handle the attacks in batches, reducing the durability of the first and last ships by the minimum possible until one of them sinks, then updating the pointers.

But with k up to 1e15, I need to handle this efficiently.

Let me try to formalize the process.

Initialize l=0, r=n-1, ans=0

While l <= r and k > 0:

    If l == r:

        if a[l] <= k:

            ans +=1

            break

        else:

            break

    else:

        mi = min(a[l], a[r])

        if mi * 2 <= k:

            a[l] -= mi

            a[r] -= mi

            k -= mi *2

            if a[l] ==0:

                ans +=1

                l +=1

            if a[r] ==0:

                ans +=1

                r -=1

        else:

            t = k // 2

            a[l] -= t

            a[r] -= t

            k -= t *2

            if a[l] ==0:

                ans +=1

                l +=1

            if a[r] ==0:

                ans +=1

                r -=1

            if k ==1:

                if l <= r:

                    if a[l] >0:

                        a[l] -=1

                        if a[l] ==0:

                            ans +=1

                    else:

                        if a[r] >0:

                            a[r] -=1

                            if a[r] ==0:

                                ans +=1

            break

After the loop, print ans.

Wait, in the earlier example, this seems to work.

In the first test case, n=4, k=5, a=[1,2,4,3]

Step 1:

mi = min(1,3)=1

1*2=2 <=5, a=[0,2,4,2], k=3, ans+=1, l=1, r=2

Step 2:

mi = min(2,4)=2

2*2=4 <=