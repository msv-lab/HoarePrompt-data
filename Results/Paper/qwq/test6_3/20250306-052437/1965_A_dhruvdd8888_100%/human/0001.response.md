Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual. On each turn, a player chooses a positive integer k that is less than or equal to the smallest pile and removes k stones from every non-empty pile. The player who can't make a move loses, which means all piles are empty.

First, I need to understand the game mechanics thoroughly. So, each move affects all non-empty piles by removing the same number of stones from each. This is different from standard Nim game where you remove stones from one pile at a time.

Let me think about the example given:

In the first test case, there are 5 piles, each with 3 stones. So, piles: 3,3,3,3,3.

Alice can choose k=3, remove 3 stones from each pile, making all piles empty in one move. So, Alice wins.

In the second test case, piles: 1,7.

Alice must choose k=1 (since the smallest pile is 1), removes 1 from each pile, resulting in piles: 0,6.

Now, Bob chooses k up to the smallest non-empty pile, which is 6. He chooses k=6, removes 6 from the pile of 6, making it empty. Now, all piles are empty, so Bob wins.

In the third test case: 1,3,9,7,4,2,100.

This seems more complex. I need to find a general strategy.

I recall that in games like Nim, the concept of Nim-sum (XOR of all pile sizes) is used to determine the winner. But in this game, moves affect all piles simultaneously, so it's different.

I need to find the game's Grundy number or mex value for the current position.

Let me try to model this.

Consider that each move consists of choosing a k <= the smallest pile and removing k stones from every non-empty pile.

This is equivalent to choosing k and subtracting k from each non-zero pile.

I need to see how this affects the game state.

Let's think recursively. The game ends when all piles are empty, which is a losing position for the player who faces it.

So, if a player can force the game into a position where the next player loses, they win.

I need to find a pattern or a mathematical way to determine the winner based on the initial pile sizes.

Let me consider small cases.

Case 1: One pile of size 1.

Alice must choose k=1, removes 1 stone, making the pile empty. Bob faces all piles empty, so Alice wins.

Case 2: One pile of size 2.

Alice can choose k=1 or k=2.

If k=1: removes 1 stone, pile becomes 1. Bob chooses k=1, removes 1 stone, pile becomes 0. Alice faces empty pile and loses.

If k=2: removes 2 stones, pile becomes 0. Bob faces empty pile and loses.

So, Alice can choose to win immediately by taking k=2.

Therefore, Alice wins.

Case 3: Two piles of size 1 and 1.

Alice can choose k=1, removes 1 from each, making both piles empty. Bob loses.

Alice wins.

Case 4: Two piles of size 1 and 2.

Alice can choose k=1, removes 1 from each, piles become 0 and 1.

Now, Bob chooses k up to the smallest non-empty pile, which is 1. So, k=1, removes 1 from the pile of 1, making it empty. Now, only one pile of size 1 remains. Alice faces one pile of 1, chooses k=1, removes it, Bob faces empty pile and loses.

Wait, in this scenario, Alice could have chosen k=1 initially, leading to Bob winning as in the previous reasoning. But according to this, Alice wins.

Wait, maybe I need to think differently.

Let me try another approach.

I found that this game is similar to a game called "Subtract Square", but in this case, it's subtracting the same k from all piles.

I need to find the mex of possible moves.

Wait, perhaps I should consider the mex of the possible next positions.

But this seems too vague.

Let me look for a pattern in the pile sizes.

In the first test case, all piles are equal, and Alice can win by taking all stones at once.

In the second test case, piles are different, and Bob wins.

I need to see if there's a way to sort the piles and find a pattern.

Looking at the provided program, it seems to sort the piles and then do some operations.

Let me look at the program step by step.

First, it reads the number of test cases, t.

Then, for each test case, it reads n (number of piles) and the pile sizes a1, a2, ..., an.

It adds 0 to the set of piles and sorts them.

Then, it seems to accumulate the differences between consecutive piles.

Wait, let's look at the code:

nums = set(input().split())

nums.add('0')

nums = sorted(map(int, nums))

ls = 0

for i in range(len(nums)):

nums[i] -= ls

ls += nums[i]

So, it's sorting the unique pile sizes plus 0, and then adjusting nums[i] to be the frequency of that size.

Wait, no. map(int, nums) converts the pile sizes to integers, including 0.

Then, it iterates through the sorted unique pile sizes, subtracting the accumulated sum ls from each nums[i], and adding the original nums[i] to ls.

This seems like it's calculating the frequency of each pile size.

Wait, perhaps it's trying to group the pile sizes.

But I'm not sure.

Then, it sets nw = True and cw = True.

Then, it iterates from len(nums)-2 to 0 in steps of -1:

if nums[i] == 1:

cw = not nw

else:

cw = True

nw = cw

Finally, if cw is True, print "Alice", else "Bob".

I need to understand what this is doing.

It seems to be iterating through the sorted unique pile sizes and updating some flags based on the frequency of each size.

But I don't understand the logic behind it.

Perhaps there's a better way to approach this problem.

I recall that in impartial games, the Grundy number can determine the game's outcome.

The Grundy number for a game state is the mex (minimum excludant) of the Grundy numbers of the positions reachable in one move.

In this game, the moves affect all piles simultaneously by removing the same k from each non-empty pile.

This seems similar to the Nim game with a twist.

Wait, perhaps I can think of it in terms of Nimbers.

Let me consider that choosing k affects all piles, which is equivalent to subtracting k from each pile, which is similar to performing a parallel subtraction.

But standard Nim is about XORing the pile sizes.

Maybe there's a way to reduce this game to standard Nim.

I found a similar problem where the game is equivalent to standard Nim played on the differences between the pile sizes.

Wait, perhaps I should consider the sorted pile sizes and look at the differences.

Let me try that.

Take the sorted pile sizes and compute the differences between consecutive piles.

Then, play standard Nim on these differences.

Wait, not sure.

Let me try with the first test case: 3,3,3,3,3.

Sorted: 3,3,3,3,3.

Differences: 0,0,0,0.

XOR of 0 is 0, which is losing for Alice. But in reality, Alice wins by taking k=3.

So, this approach is incorrect.

Another idea: since all piles are equal, Alice can take k equal to that value and win immediately.

In the second test case: 1,7.

Sorted:1,7.

Differences:6.

XOR of 6 is 6, which is a winning position for Alice, but in reality, Bob wins.

This is confusing.

Wait, maybe I need to consider the number of piles at each size.

Let me look back at the code.

It sorts the unique pile sizes and adds 0 to the set.

Then, it seems to calculate the frequency of each pile size.

Wait, no, it's sorting the pile sizes including 0, and then adjusting nums[i] to be the frequency of that size.

But I'm not sure.

Perhaps I should consider the game as equivalent to Nim with heap sizes being the frequencies of each pile size.

Wait, not sure.

Let me try to think differently.

Suppose I have pile sizes a1, a2, ..., an.

A move consists of selecting k >=1, k <= min of the piles, and subtracting k from each pile.

This is equivalent to replacing each ai with ai - k.

This is similar to simultaneous subtraction from all piles.

I need to find the game's Grundy function.

Let me try to find the Grundy number for a single pile.

Wait, but since moves affect all piles, it's not straightforward.

Let me consider the mex rule.

The Grundy number of the game state is mex of the Grundy numbers of the positions reachable in one move.

So, for the current state, g(s) = mex{ g(s - k) for all k in [1, min_pile] }.

But this seems recursive and may be complicated.

Perhaps there's a pattern or a formula that can directly determine the winner.

Let me consider the minimal excludant concept.

Alternatively, maybe I can think in terms of binary representations or something.

Wait, perhaps I should look for the maximum k that can be subtracted, which is the smallest pile.

So, the game state is determined by the smallest pile.

Wait, but piles can have different sizes.

Let me consider that the game can be represented by the sorted pile sizes.

Let me sort the piles in non-decreasing order: a1 <= a2 <= ... <= an.

Each move consists of selecting k <= a1 and subtracting k from each ai.

After the move, the new piles are a1 - k, a2 - k, ..., an - k, and any pile that becomes zero is removed.

Wait, but in the problem, even if a pile becomes zero, it's still considered, but perhaps it's easier to think of it as removing k from all non-empty piles.

Wait, the problem says "remove k stones from each nonempty pile at once".

So, piles that become zero are still considered as empty piles.

The game ends when all piles are empty.

I need to see if there is a way to simplify this.

I found that this game is similar to a game called "Nim with a pass", but I'm not sure.

Alternatively, perhaps it's equivalent to standard Nim under certain transformations.

Let me try to see if there's a way to map this game to standard Nim.

Suppose I have piles a1, a2, ..., an.

After sorting them, a1 <= a2 <= ... <= an.

Each move consists of subtracting k from each ai where k <= a1.

This is similar to subtracting k from each pile, which is like performing a parallel subtraction.

I recall that in standard Nim, subtracting the same amount from all piles doesn't change the XOR value.

Wait, but in this case, it's not exactly the same.

Wait, perhaps I can consider the differences between the piles.

Let me try with an example.

Take the second test case: piles 1,7.

Sorted:1,7.

Alice chooses k=1, subtracts 1 from each, resulting in 0,6.

Bob chooses k=6, subtracts 6 from each, resulting in 0,0.

Alice faces all piles empty, so Bob wins.

Alternatively, if Alice chooses k=1, but perhaps there are other choices.

Wait, according to the problem, Alice must choose k<= the smallest pile, which is 1, so only k=1 is possible.

Another example: piles 1,3,5.

Alice chooses k=1, subtracts 1 from each, resulting in 0,2,4.

Bob chooses k up to the smallest non-empty pile, which is 2, so he can choose k=1 or 2.

If he chooses k=2, subtracts 2 from each non-empty pile, resulting in 0,0,2.

Alice then chooses k up to 2, chooses k=1 or 2.

If she chooses k=1, subtracts 1 from each, resulting in 0,0,1.

Bob chooses k=1, subtracts 1 from the last pile, resulting in all zeros. Alice loses.

If Alice chooses k=2, subtracts 2 from the last pile, but since it's only 1, she can't do that.

Wait, in this scenario, Alice can only choose k=1, leading to the same as before.

This seems complicated.

Let me consider the binary representation or look for a mathematical pattern.

I need to find a way to determine the winner without simulating the entire game.

Looking back at the provided program, it seems to sort the unique pile sizes, add 0, sort them, and then adjust the frequencies.

Then, it iterates from the second last to the first, updating some flags based on whether the frequency is 1 or not.

Finally, it decides who wins based on the flag's value.

I need to verify if this logic is correct.

But I'm not entirely sure about the correctness of this approach.

Perhaps I should look for an alternative way.

I found that this game is similar to Octal games, where moves affect multiple heaps in a specific way.

But Octal games are usually played with heaps where you can remove a certain number of stones and possibly divide the remaining stones.

Not sure.

Alternatively, perhaps I can think of this game as equivalent to Nim with the pile sizes being the binary representations and performing some operations.

Wait, perhaps there's a way to calculate the mex of the pile sizes.

Let me try that.

In the first test case, piles:3,3,3,3,3.

mex of {3} is 0, which is not helpful.

Wait, maybe I need to consider the pile sizes differently.

Alternatively, perhaps the game can be transformed into a standard Nim game with certain heap sizes.

I need to find a way to map this game to standard Nim.

Let me consider the following:

Sort the pile sizes in non-decreasing order: a1 <= a2 <= ... <= an.

Define the "gap" between consecutive piles: g_i = a_{i+1} - a_i for i from 1 to n-1.

Also, consider g_0 = a1 - 0 = a1.

Then, the game is equivalent to a Nim game with heap sizes g_0, g1, ..., g_{n-1}.

Wait, let's try this with the first test case: piles:3,3,3,3,3.

g0 = 3 - 0 = 3

g1 = 3 - 3 = 0

g2 = 3 - 3 = 0

g3 = 3 - 3 = 0

g4 = 3 - 3 = 0

Nim sum: 3 XOR 0 XOR 0 XOR 0 XOR 0 = 3, which is non-zero, so Alice wins.

In the second test case: piles:1,7.

g0 =1 -0=1

g1 =7 -1=6

Nim sum:1 XOR 6 =7, which is non-zero, so Alice wins.

But according to the example, Bob wins.

So, this approach is incorrect.

Hmm.

Perhaps I need to adjust the way I calculate the gaps.

Let me try another way.

Consider the sorted pile sizes: a1 <= a2 <= ... <= an.

Define the differences as d_i = a_i - a_{i-1} for i=1 to n, with a0=0.

Then, the Nim sum of d_i's determines the winner.

In the first test case: d1=3, d2=0, d3=0, d4=0, d5=0. Nim sum:3 XOR 0 XOR 0 XOR 0 XOR 0 =3, which is non-zero, so Alice wins.

In the second test case: d1=1, d2=6. Nim sum:1 XOR 6=7, which is non-zero, so Alice wins.

But according to the example, Bob wins in the second test case.

So, this approach is incorrect.

Wait, maybe I need to consider only the non-zero differences.

But in the second test case, both differences are non-zero.

Wait, perhaps this approach is not correct.

Let me think differently.

I recall that in games where moves affect multiple heaps, the Grundy number can be calculated based on the mex of the possible moves.

In this case, choosing k affects all piles simultaneously.

So, perhaps the Grundy number of the game is the mex of the Grundy numbers of the positions after any legal move.

But calculating this directly seems infeasible for large pile sizes.

I need a smarter way.

Let me consider the minimal pile size.

In each move, k must be at most the smallest pile.

So, the possible moves are k from 1 to the smallest pile.

After choosing k, all piles are reduced by k.

This is similar to a game where you're reducing all piles by the same amount.

Wait, perhaps I can think of the game in terms of the number of moves.

Each move reduces all piles by k, where k is at least 1 and at most the smallest pile.

The game ends when all piles are empty.

This seems like the number of moves is equal to the number of times you can subtract k from all piles until they are all empty.

But I need to relate this to who makes the last move.

In standard Nim, if the Nim sum is non-zero, the first player wins; otherwise, the second player wins.

But in this game, it's different because moves affect all piles at once.

I need to find a way to reduce this game to standard Nim or find an equivalent game.

Let me consider the following:

- Sort the pile sizes in non-increasing order.

- Define the game in terms of the number of times you can subtract k from all piles.

- The game ends when all piles are empty.

- The player who cannot make a move loses.

This seems similar to the game of "Subtract Square", but in this case, you're subtracting the same k from all piles.

Wait, perhaps I can think in terms of the mex of the exponents in the binary representation or something.

This is getting too vague.

Let me look for patterns in small cases.

Case 1: One pile of size 1.

Alice takes k=1, piles become empty. Bob loses.

Alice wins.

Case 2: One pile of size 2.

Alice can take k=1 or k=2.

If k=1: piles become 1. Bob takes k=1, piles become 0. Alice loses.

If k=2: piles become 0. Bob loses.

So, Alice can choose to win immediately by taking k=2.

Alice wins.

Case 3: Two piles of size 1 and 1.

Alice takes k=1, both piles become 0. Bob loses.

Alice wins.

Case 4: Two piles of size 1 and 2.

Alice can take k=1:

Piles become 0 and 1.

Bob takes k=1:

Piles become 0 and 0.

Alice loses.

Alternatively, if Alice takes k=2:

But k cannot be 2 because the smallest pile is 1.

So, only k=1 is possible.

Thus, Alice loses.

Wait, in this case, according to earlier reasoning, Alice can choose k=1, leading to Bob winning.

But in reality, Alice has no choice but to choose k=1, leading to Bob winning.

So, in this case, Bob wins.

Wait, but according to the earlier general approach, it might suggest Alice wins, but actually Bob wins.

So, perhaps my earlier approach is flawed.

Let me consider another perspective.

I found that this game is similar to the game of "Nim with a pass", where a player can choose to pass their turn under certain conditions.

But in this game, passing is not allowed; the player must choose a positive integer k.

Wait, perhaps I need to consider the binary representations of the pile sizes and find the XOR.

But as earlier examples show, that doesn't align with the actual outcomes.

Let me try another test case.

Case 5: Three piles of size 1,2,3.

Alice can choose k=1:

Piles become 0,1,2.

Bob chooses k up to the smallest non-empty pile, which is 1.

So, k can be 1.

Bob chooses k=1:

Piles become 0,0,1.

Alice chooses k=1:

Piles become 0,0,0.

Bob loses.

So, Alice wins.

Alternatively, if Alice chooses k=2:

But k cannot be 2 because the smallest pile is 1.

Wait, no, the smallest pile is 1, so k must be <=1.

So, only k=1 is allowed.

Thus, Alice chooses k=1, leading to piles 0,1,2.

Bob chooses k=1:

Piles become 0,0,1.

Alice chooses k=1:

Piles become 0,0,0.

Bob loses.

So, Alice wins.

Another way: if Alice chooses k=1 initially, she can force Bob into a losing position.

So, Alice wins.

This matches the example output.

Wait, in the example, for piles 1,2,3, it says Alice wins, which matches this.

Another case: Piles 1,3,5.

As I simulated earlier, Alice chooses k=1, leading to 0,2,4.

Bob chooses k=2, leading to 0,0,2.

Alice chooses k=1, leading to 0,0,1.

Bob chooses k=1, leading to 0,0,0.

Alice loses.

So, Bob wins.

But according to the earlier approach, using Nim sum of differences, it would be d1=1, d2=2, d3=2.

Nim sum:1 XOR 2 XOR 2 =1, which suggests Alice wins, but actually Bob wins.

So, this approach is incorrect.

I need to find another way.

Let me consider the number of distinct pile sizes.

In the first test case, all piles are equal, so only one distinct size.

Alice can win by taking k equal to that size.

In the second test case, two distinct sizes:1 and 7.

Alice must take k=1, leading to all piles being 0 and 6.

Bob then takes k=6, leading to all piles being 0 and 0.

Alice loses.

In the third test case, multiple distinct sizes:1,3,9,7,4,2,100.

This is complex, but according to the example, Alice wins.

I need to find a pattern based on the number of distinct pile sizes or something else.

Wait, perhaps it's about the number of piles that have unique sizes.

No, that doesn't seem consistent.

Let me consider the binary representations again.

Wait, maybe I need to look at the pile sizes in terms of their binary representations and find a way to calculate the Grundy number.

But this seems too time-consuming for large pile sizes.

Let me think about the game in terms of its impartiality.

Since the game is impartial, the outcome depends on the Grundy numbers.

But calculating Grundy numbers for each possible state is not feasible due to the large pile sizes.

I need a smarter way.

Let me consider the minimal excludant of the possible moves.

In each move, k can be from 1 to the smallest