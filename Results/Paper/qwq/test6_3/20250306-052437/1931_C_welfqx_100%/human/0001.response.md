Alright, I have this problem to solve. Let's understand what it's asking for. I have an array of integers, and I can perform at most one operation where I select three integers i, j, and x, and set all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles. My goal is to make all elements of the array equal with the least amount of burles spent.

First, I need to understand the operation. I can choose any contiguous subarray and set all its elements to any value x, and the cost is the length of that subarray. I can do this operation at most once.

So, the question is, how can I make all elements equal with at most one operation?

Let me think about some examples.

Example 1:

Input: [1, 2, 3, 4, 5, 1]

Output: 4

Explanation: By setting indices 2 to 4 to 8, the array becomes [1,8,8,8,5,1]. Then, to make all elements equal, I can set the entire array to 8, which would cost 6 burles. But the output is 4, so there must be a better way.

Wait, perhaps the operation can be used to minimize the cost. Let's see.

If I set indices 1 to 5 to 1, the array becomes [1,1,1,1,1,1], costing 5 burles. But the output is 4, so there's a better approach.

Alternatively, set indices 2 to 5 to 1, making it [1,1,1,1,1,1], costing 4 burles. Yeah, that matches the sample output.

So, the strategy is to choose a value and set a subarray to that value to minimize the cost.

Wait, but I can only perform this operation once.

So, I need to find a way to make all elements equal with at most one operation.

Another sample input:

Input: [1,1,1,1,1,1,1]

Output: 0

Because all elements are already equal.

Another one:

Input: [8,8,8,1,2,8,8,8]

Output: 2

Probably by setting indices 4 and 5 to 8, costing 2 burles.

Input: [1]

Output: 0

Single element is already equal.

Input: [1,2]

Output: 1

Set one of them to the other's value, costing 1 burle.

Input: [1,2,3]

Output: 2

Set one of the elements or a subarray to make all equal.

Input: [4,3,2,7,1,1,3]

Output: 6

Not sure, but the operation allows me to set a subarray to a single value.

Input: [9,9,2,9,2,5,5,5,3]

Output: 7

Again, need to find the minimal cost.

So, general approach: make all elements equal with at most one operation, minimizing the cost.

I need to find a way to make all elements equal, possibly using one operation to set a subarray to a certain value.

Wait, but I can also choose not to perform any operation if the array is already uniform.

First, check if the array is already uniform. If yes, cost is 0.

If not, I need to perform one operation to make all elements equal.

I need to choose a value x and a subarray [i,j] to set to x, such that after this operation, all elements become equal, and the cost (j - i + 1) is minimized.

Wait, but I can choose x to be any value, not necessarily existing in the array.

Wait, looking back at the problem statement: x can be any integer between 1 and n, inclusive, since a_i is between 1 and n.

But actually, x can be any integer, no restrictions given in the problem. Wait, the problem says "assign all elements ... the value x (1 ≤ a_i ≤ n)", but actually, x can be any integer, as per the sample input where x=8 is used for an array with values up to 5.

Wait, no, in the problem statement, it says "assign all elements of the array with indexes from i to j the value x (1 ≤ a_i ≤ n)", but actually, x can be any integer, as per the sample input.

Wait, the constraints say "1 ≤ a_i ≤ n", but x can be any integer, I think.

But to be safe, I'll assume x can be any integer.

So, I need to choose x and a subarray [i,j], set all elements in [i,j] to x, and make the entire array equal to x.

Wait, but that would mean setting the entire array to x, which would cost n burles.

But perhaps there's a smarter way.

Wait, another way to think about it: after the operation, the array should be uniform.

So, suppose I set a subarray to x, and the rest remains as is.

For the entire array to be equal to x, the rest of the array must already be equal to x.

Wait, that seems promising.

So, if I set a subarray [i,j] to x, then for the entire array to be equal to x, the parts before i and after j must already be equal to x.

So, I need to choose x such that the parts before i and after j are already x, and set [i,j] to x.

Wait, but in the sample input [1,2,3,4,5,1], setting [2,4] to 8 makes it [1,8,8,8,5,1], which is not uniform.

Wait, perhaps I need to set the entire array to x, but that would be costly.

Wait, perhaps I need to find the largest subarray such that setting it to x makes the entire array equal to x.

Wait, perhaps I need to find the intersection of possible intervals.

Wait, maybe a better approach is to find the minimal cost to make the entire array equal to some value x.

I can choose x to be any value.

Suppose I choose x to be a value that appears in the array.

Then, I need to set all other elements to x.

The cost would be the number of elements not equal to x.

But I can perform one operation, setting a subarray to x, and the cost is the length of that subarray.

So, perhaps I can choose x to be the most frequent value in the array, and set the subarray that contains the least frequent elements to x.

Wait, but it's not that straightforward.

Wait, perhaps I need to find the minimal cost to make the array uniform, allowing one operation of setting a subarray to a value.

I need to minimize the cost, which is the length of the subarray I choose to set.

So, to make the array uniform, I need to choose a value x, and set a subarray to x, such that the remaining parts are already equal to x.

So, the cost is the length of the subarray that is not already equal to x.

Wait, perhaps it's better to think in terms of the largest contiguous subarray that is already equal to x, and set the rest to x.

Wait, but I can only perform one operation.

Wait, perhaps the minimal cost is n minus the maximum number of consecutive elements that are equal to some value x.

So, in other words, find the maximum number of consecutive elements that are equal, and the cost is n minus that number.

Because I can set the remaining elements to that x, which would cost n - k, where k is the length of the longest consecutive sequence of equal elements.

Let me check this hypothesis with the sample inputs.

Sample Input 1:

6

1 2 3 4 5 1

The longest consecutive sequence of equal elements is 1 (any single element), so cost would be 6 - 1 = 5, but the sample output is 4.

Hmm, doesn't match.

Wait, perhaps it's not the longest run of equal elements.

Sample Input 2:

7

1 1 1 1 1 1 1

Longest run is 7, cost is 7 - 7 = 0, matches the sample output.

Sample Input 3:

8

8 8 8 1 2 8 8 8

Longest run is 3 (eighties at positions 1-3 and 6-8), so cost would be 8 - 3 = 5, but sample output is 2.

Doesn't match.

Wait, perhaps it's the maximum number of consecutive elements that are equal, plus any prefixes or suffixes that are equal to that value.

Wait, in the third sample, if I set indices 4 and 5 to 8, then the array becomes all 8's, costing 2 burles, which matches the sample output.

So, perhaps I need to consider the maximum sequence of equal elements, and see if extending it to the left or right reduces the cost further.

Wait, in the first sample, [1,2,3,4,5,1], the longest run is 1, but if I set [2,4] to 1, making it [1,1,1,1,5,1], then set [4,5] to 1, but I can only perform one operation.

Wait, no, I can only perform one operation.

Wait, perhaps I need to find the minimal cost by choosing a value x and a subarray to set to x, such that the entire array becomes x.

So, the cost is the length of the subarray set to x.

I need to choose x and the subarray in such a way that the remaining parts are already equal to x.

So, to minimize the cost, I need to maximize the length of the subarray that needs to be set to x.

Wait, that seems counterintuitive.

Wait, actually, to minimize the cost, I need to minimize the length of the subarray set to x, meaning I need to maximize the number of elements that are already equal to x.

So, I need to choose x such that the number of elements already equal to x is maximized, and then set the remaining elements to x, which would cost n - k, where k is the number of elements already equal to x.

Wait, but I can perform only one operation, which is setting a subarray to x.

So, it's not just setting the elements that are not x, but setting a subarray to x.

So, perhaps I need to find the minimal subarray to set to x such that, after setting, the entire array becomes x.

That would be the subarray that covers all elements that are not equal to x.

So, the cost would be the length of the subarray that covers all non-x elements.

I need to choose x such that the subarray covering all non-x elements is minimized.

Wait, perhaps I need to choose x that appears the most, and find the minimal subarray that covers all non-x elements.

So, in other words, find the minimal subarray that includes all positions where a_i != x.

That would be the minimal subarray that covers all non-x elements.

So, for each possible x, find the minimal subarray that covers all a_i != x, and then choose the x that minimizes the cost, which is the length of that subarray.

But this seems inefficient, especially since n can be up to 2e5.

Is there a better way?

Wait, perhaps I can think of it differently.

Suppose I choose x to be the value that appears the most in the array.

Then, the minimal subarray that covers all a_i != x would be the minimal subarray that includes all elements not equal to x.

So, I need to find the minimal subarray that covers all non-x elements.

This would be the minimal subarray that starts at the first a_i != x and ends at the last a_i != x.

So, for each x, find the minimal subarray that covers all a_i != x, which is from the first a_i != x to the last a_i != x.

But if x is the most frequent, then the number of a_i != x is minimized.

Wait, but the minimal subarray covering all a_i != x would be from the first to the last non-x element.

So, the cost would be the position of the last non-x element minus the position of the first non-x element plus one.

But I need to minimize this cost over all possible x.

Wait, perhaps.

Let me try with the first sample input:

[1,2,3,4,5,1]

Let's choose x=1.

First non-1 is at position 2, last non-1 is at position 5.

So, subarray from 2 to 5, cost=4.

Which matches the sample output.

Another sample:

[8,8,8,1,2,8,8,8]

Choose x=8.

First non-8 is at position 4, last non-8 is at position 5.

Subarray from 4 to 5, cost=2.

Matches the sample output.

Another sample:

[1,2]

Choose x=1.

First non-1 is at position 2, last non-1 is at position 2.

Subarray from 2 to 2, cost=1.

Matches the sample output.

Another sample:

[1,2,3]

Choose x=1.

First non-1 is at position 2, last non-1 is at position 3.

Subarray from 2 to 3, cost=2.

Matches the sample output.

Seems consistent.

So, the strategy is:

- Find the value x that appears in the array.

- For each such x, find the minimal subarray that covers all a_i != x, which is from the first a_i != x to the last a_i != x.

- The cost is the length of this subarray.

- Choose the x that minimizes this cost.

- If all elements are already equal, cost is 0.

- If there are multiple x with the same minimal cost, choose any.

Wait, but x doesn't have to be an existing element in the array.

Wait, in the problem statement, x can be any integer.

So, x can be a value not in the array.

But in the sample input, x=8 was used for [1,2,3,4,5,1], which doesn't contain 8.

So, x can be any integer, not necessarily in the array.

But probably, choosing x not in the array would lead to setting the entire array to x, costing n burles, which is not optimal unless n=1.

So, it's better to choose x to be a value that exists in the array.

Wait, but if x is not in the array, then the minimal subarray to set to x is the entire array, costing n.

So, it's never better to choose x not in the array, as choosing x in the array would at least cover some elements.

Therefore, it's sufficient to consider only x that appear in the array.

So, the approach is:

- Find all unique values in the array.

- For each unique value x:

- Find the first position where a_i != x.

- Find the last position where a_i != x.

- The minimal subarray to set to x is from first_non_x to last_non_x.

- The cost is last_non_x - first_non_x + 1.

- Choose the x with the minimal such cost.

- If the array is already uniform, cost is 0.

Edge cases:

- n=1: cost is 0.

- All elements equal: cost is 0.

- All elements different: choose x to be any value, cost is n - 1 (since first_non_x to last_non_x is from 1 to n).

Wait, no. If x is not in the array, cost is n.

If x is in the array, say x=a_k, then first_non_x to last_non_x is the range covering all a_i != x.

So, cost is last_non_x - first_non_x + 1.

But in the case where x appears multiple times, I need to make sure that all a_i != x are set to x.

Wait, actually, no. Once I set the subarray from first_non_x to last_non_x to x, then the entire array becomes x.

Because all a_i == x remain x, and all a_i != x are set to x.

So, the cost is last_non_x - first_non_x + 1.

Hence, for each x, find the minimal subarray that covers all a_i != x.

Which is from the first a_i != x to the last a_i != x.

Then, choose the x that minimizes this cost.

Implementing this efficiently is key, given the constraints.

Constraints:

- t <= 10^4

- n <= 2e5 per test case

- sum of n over t <= 2e5

So, per test case, n can be up to 2e5, but t is up to 1e4.

Wait, but sum of n over all test cases is <= 2e5, so it's manageable.

So, for each test case, I need to process the array efficiently.

First, find all unique values in the array.

But since n can be up to 2e5, and t up to 1e4, but sum of n <= 2e5, it's manageable.

But need an efficient way to find, for each x, the first and last position where a_i != x.

One way is:

- Find the overall first and last positions where a_i != x, for each x.

But to do this efficiently, I need to iterate through the array once per x, which would be O(n * number of unique x), which in the worst case is O(n^2), which is too slow for n=2e5.

So, need a better approach.

Alternative approach:

- Find the overall first and last positions where a_i != x, for each x.

- To optimize, find the intersection of intervals where a_i == x, for all x.

Wait, perhaps not.

Wait, another way: find the minimal subarray that covers all a_i != x.

This is equivalent to the range from the first a_i != x to the last a_i != x.

So, for each x, find the first a_i != x and the last a_i != x.

Then, the cost is last - first + 1.

Choose the minimal such cost over all x.

To implement this efficiently, I can:

- Find the overall first and last positions where a_i != x, for each x.

But iterating over all x would be too slow if done naively.

So, perhaps find the overall first and last positions where a_i != x, but in a way that reuses computations.

Wait, perhaps:

- Find the first position where a_i != mode, and the last position where a_i != mode, where mode is the most frequent element.

But no, I need to consider all possible x.

Wait, perhaps find the minimal last - first + 1 over all x.

To optimize, I can:

- Find all positions where a_i != x, for each x.

But that's still O(n * number of unique x).

Wait, perhaps find the positions where a_i changes value.

Wait, perhaps use prefix sums or something similar.

Wait, perhaps collect for each x, the positions where a_i == x.

Then, for each x, the first a_i != x is the first position before the first a_i == x, and the last a_i != x is the last position after the last a_i == x.

Wait, perhaps.

Let me try.

For each x, find the positions where a_i == x.

Then, the first a_i != x is position 1 if a_1 == x, else position 1.

Wait, it's easier to find the first and last positions where a_i != x.

Wait, perhaps find the minimal range that covers all a_i != x.

This is equivalent to the range from the first a_i != x to the last a_i != x.

So, for each x, find the minimal subarray to set to x to make the entire array equal to x.

Which is setting from the first a_i != x to the last a_i != x to x.

So, for each x, cost is last_not_x - first_not_x + 1.

Then, choose the x that minimizes this cost.

To implement this efficiently:

- Find the overall first and last positions where a_i != x, for each x.

But doing this for each x separately is inefficient.

So, perhaps find a way to compute this for all x at once.

Wait, perhaps find the intersection of all intervals where a_i != x for all x.

Wait, not sure.

Alternative idea:

- Find the minimal subarray such that, when set to some x, the entire array becomes equal to x.

So, find the minimal subarray that covers all positions where a_i != x, for some x.

Wait, but x is not fixed.

This is getting complicated.

Perhaps think differently.

Suppose I choose to set a subarray [L, R] to some value x.

After this operation, the entire array should be equal to x.

So, for all positions i < L and i > R, a_i must already be equal to x.

Because I can only set the subarray [L, R] to x, and the rest must already be x.

Wait, that's an important insight.

So, to make the entire array equal to x, I need to set a subarray [L, R] to x, and ensure that for all i < L and i > R, a_i == x.

So, L must be the first position where a_i != x, and R must be the last position where a_i != x.

Hence, for each x, the minimal subarray to set is from the first a_i != x to the last a_i != x.

So, the cost is last_not_x - first_not_x + 1.

Then, choose the x that minimizes this cost.

So, to implement this efficiently:

- Find, for each x, the first position where a_i != x and the last position where a_i != x.

- Then, compute the cost as last - first + 1.

- Choose the minimal such cost.

To optimize, I can:

- Find the overall first and last positions where a_i != x, for each x.

But doing this separately for each x would be O(n * number of unique x), which is too slow for n=2e5.

So, need a smarter way.

Alternative approach:

- Find the minimal length of the union of the ranges where a_i != x, over all x.

Wait, but since x can be any value, the union would be the entire array.

Wait, not helpful.

Wait, perhaps find the minimal length of the range that covers all positions where a_i != x, for some x.

Which is equivalent to the minimal length of the range from first_not_x to last_not_x, over all x.

So, to minimize last_not_x - first_not_x + 1 over all x.

So, to find the x that minimizes the range covering all a_i != x.

So, to find the x that minimizes the distance between the first and last a_i != x.

Which is equivalent to maximizing the length of the interval where a_i == x.

Wait, no.

Wait, actually, the cost is n - k, where k is the length of the longest subarray where a_i == x.

Wait, perhaps.

Wait, in the first sample, n=6, k=1 (longest subarray of equal elements is 1), cost=5, but sample output is 4.

Doesn't match.

Wait, perhaps it's n - number of elements equal to x.

No, in the first sample, number of 1's is 2, n - 2 = 4, which matches the sample output.

In the second sample, number of 1's is 7, n - 7 = 0, matches the sample output.

In the third sample, number of 8's is 5, n - 5 = 3, but sample output is 2.

Hmm, doesn't match.

Wait, perhaps it's n - maximum number of consecutive elements equal to x.

In the first sample, n=6, max consecutive equals is 1, n - 1 = 5, doesn't match sample output 4.

Wait, perhaps it's n - maximum number of elements equal to x.

In the first sample, n=6, max number of 1's is 2, n - 2 = 4, matches sample output.

In the third sample, number of 8's is 5, n - 5 = 3, but sample output is 2.

So, doesn't match.

Wait, perhaps it's n - maximum number of consecutive elements equal to x, but considering overlaps.

Wait, perhaps not.

Wait, perhaps it's n - the sum of the lengths of the largest blocks of equal elements.

Wait, no, that seems overly complicated