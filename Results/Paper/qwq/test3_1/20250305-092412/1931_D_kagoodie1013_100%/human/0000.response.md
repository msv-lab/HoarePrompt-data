Alright, I've got this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices <i, j> (where i < j) beautiful if two conditions are met:

1. The sum of the elements at positions i and j is divisible by x.

2. The difference of the elements at positions i and j is divisible by y.

My task is to find out how many such beautiful pairs exist in the array for each test case.

First, I need to understand what it means for a sum or difference to be divisible by certain numbers. Let's recall that if a number a is divisible by another number b, it means a % b == 0.

So, for the sum a_i + a_j to be divisible by x, (a_i + a_j) % x should be 0.

Similarly, for the difference a_i - a_j to be divisible by y, (a_i - a_j) % y should be 0.

I need to find pairs where both these conditions hold true.

Let me think about how to approach this efficiently, especially since the constraints mention that n can be up to 2*10^5 and there can be up to 10^4 test cases, but the sum of n across all test cases is 2*10^5. So, I need an algorithm that's linear or linearithmic in n.

I recall that for problems involving counting pairs with certain properties related to modulo, using frequency maps based on residues can be helpful.

Let me consider the residues of the elements modulo x and y.

But since we have conditions involving both sum and difference, I need to find a way to relate these residues.

Let's consider the residues of a_i and a_j separately and see how their residues affect the sum and difference.

Let me denote:

r_i_x = a_i % x

r_i_y = a_i % y

Similarly for j:

r_j_x = a_j % x

r_j_y = a_j % y

Now, (a_i + a_j) % x = (r_i_x + r_j_x) % x

And (a_i - a_j) % y = (r_i_y - r_j_y) % y

We need both of these to be zero.

So, (r_i_x + r_j_x) % x == 0 and (r_i_y - r_j_y) % y == 0

Let's think about what these conditions imply.

First, (r_i_x + r_j_x) % x == 0 implies that r_j_x == (-r_i_x) % x

Similarly, (r_i_y - r_j_y) % y == 0 implies that r_j_y == r_i_y % y

So, for two elements a_i and a_j to form a beautiful pair, a_j must satisfy:

- a_j % x == (-a_i % x) % x

- a_j % y == a_i % y

This seems like a good lead. So, for each a_i, I can look for a_j's that have a specific residue modulo x and y.

To optimize this, I can precompute the frequency of each possible pair of residues (res_x, res_y), where res_x = a % x and res_y = a % y.

Then, for each a_i, I can compute the required res_x and res_y for a_j, and look up how many such a_j's exist in the frequency map.

But I need to be careful to avoid counting pairs where i >= j, since the problem specifies i < j.

So, I need to make sure that I don't count a pair twice or include invalid pairs.

Let me think about the implementation.

I'll iterate through the array, and for each element a_i, I'll compute the required res_x and res_y for a_j, and add the frequency of such a_j's to the count.

Then, I'll update the frequency map with the residues of a_i.

But I need to make sure that I don't count the element itself or any element that comes after it.

Wait, no. I need to count pairs where i < j, so I should first process the frequency map up to i-1, then add the frequency of valid a_j's, and then update the frequency map with a_i.

Wait, actually, a better way is to maintain a frequency map as I iterate through the array, keeping track of the elements processed so far.

For each a_i, I can compute how many elements before it satisfy the conditions, i.e., have the required residues.

Then, I can update the frequency map with a_i's residues.

This way, I ensure that i < j for all pairs counted.

Let me try to formalize this.

Initialize a frequency map, initially empty.

Initialize a count of beautiful pairs to zero.

For each a_i in the array:

Compute required r_x = (-a_i % x) % x

Compute required r_y = (a_i % y)

Look up the frequency of (r_x, r_y) in the frequency map, and add this frequency to the count.

Then, compute the residues of a_i: res_x = a_i % x, res_y = a_i % y

Update the frequency map with (res_x, res_y)

Proceed to the next element.

This seems correct.

Let me verify this with the example given.

Example:

n=6, x=5, y=2

a = [1,2,7,4,9,6]

Let's list the residues:

a1: 1 % 5 = 1, 1 % 2 = 1 -> (1,1)

a2: 2 % 5 = 2, 2 % 2 = 0 -> (2,0)

a3: 7 % 5 = 2, 7 % 2 = 1 -> (2,1)

a4: 4 % 5 = 4, 4 % 2 = 0 -> (4,0)

a5: 9 % 5 = 4, 9 % 2 = 1 -> (4,1)

a6: 6 % 5 = 1, 6 % 2 = 0 -> (1,0)

Now, let's iterate through the array:

i=1: a1=(1,1)

Required for a_j: r_x = (-1 % 5) % 5 = 4, r_y = 1

Look for (4,1) in frequency map: empty -> 0

Add (1,1) to frequency map: {(1,1):1}

i=2: a2=(2,0)

Required for a_j: r_x = (-2 % 5) % 5 = 3, r_y = 0

Look for (3,0) in frequency map: not present -> 0

Add (2,0) to frequency map: {(1,1):1, (2,0):1}

i=3: a3=(2,1)

Required for a_j: r_x = (-2 % 5) % 5 = 3, r_y = 1

Look for (3,1) in frequency map: not present -> 0

Add (2,1) to frequency map: {(1,1):1, (2,0):1, (2,1):1}

i=4: a4=(4,0)

Required for a_j: r_x = (-4 % 5) % 5 = 1, r_y = 0

Look for (1,0) in frequency map: not present -> 0

Add (4,0) to frequency map: {(1,1):1, (2,0):1, (2,1):1, (4,0):1}

i=5: a5=(4,1)

Required for a_j: r_x = (-4 % 5) % 5 = 1, r_y = 1

Look for (1,1) in frequency map: frequency=1 -> add 1 to count

Add (4,1) to frequency map: {(1,1):1, (2,0):1, (2,1):1, (4,0):1, (4,1):1}

i=6: a6=(6,0)

Required for a_j: r_x = (-1 % 5) % 5 = 4, r_y = 0

Look for (4,0) in frequency map: frequency=1 -> add 1 to count

Add (1,0) to frequency map: {(1,1):1, (2,0):1, (2,1):1, (4,0):1, (4,1):1, (1,0):1}

Total count: 2

Which matches the example.

Great, so this approach seems correct.

Now, I need to implement this efficiently.

Given that n can be up to 2*10^5 and there are up to 10^4 test cases, but the sum of n across all test cases is 2*10^5, I need an implementation that processes each test case in linear time relative to n.

I should read all input at once for efficiency, especially since n can be large.

I can read all input data at once using sys.stdin.read(), split it into tokens, and process them accordingly.

I need to handle multiple test cases, so I'll collect all test cases first, then process them one by one.

For each test case, I'll extract n, x, y, and the array a.

Then, I'll apply the frequency map approach as described.

I need to be careful with the modulo operations, ensuring that negative residues are handled correctly by using the positive equivalent.

Also, since x and y can be 1, I need to handle cases where all elements have residue 0 for x or y.

I should use a dictionary to store the frequency of (res_x, res_y) tuples.

To optimize, I can use a defaultdict from the collections module to avoid checking if a key exists before incrementing its count.

Alternatively, I can use a regular dictionary and use the get method to handle missing keys.

I think defaultdict would make the code cleaner.

But since the number of unique (res_x, res_y) pairs can be up to n, and n can be up to 2*10^5, it should be manageable.

Let me outline the steps in code:

- Read all input data at once.

- Split the data into tokens.

- Process the number of test cases t.

- For each test case:

- Read n, x, y.

- Read the next n tokens as the array a.

- Initialize a frequency map (e.g., defaultdict(int)).

- Initialize count to 0.

- For each element in a:

- Compute required r_x and r_y for a_j.

- Add the frequency of (r_x, r_y) to count.

- Compute the residues of the current element.

- Update the frequency map with the current element's residues.

- Append the count to the results list.

- After processing all test cases, print the results separated by newlines.

I need to make sure that I handle the indices correctly while reading the input, to avoid mixing up the data between test cases.

Also, since n can be up to 2*10^5 and t up to 10^4, I need to make sure that the loop is efficient.

Using a generator for reading input or processing tokens in a list should be fine.

Let me consider the time complexity:

- For each test case, we iterate through the array once, performing O(1) operations for each element.

- So, overall time complexity is O(sum of n over all test cases), which is O(2*10^5), which is acceptable.

Now, let's think about edge cases:

- n=2: smallest possible array.

- x=1 or y=1: all sums and differences are divisible by 1.

- All elements are equal.

- All elements have the same residue modulo x and y.

- x and y are equal or different.

- Negative residues: ensure that residues are always non-negative.

- Large values of a_i: up to 10^9, but since we're taking modulo x and y, it's manageable.

Let me consider n=2:

If n=2, there's only one possible pair: <1,2>.

I need to check if a1 + a2 is divisible by x and a1 - a2 is divisible by y.

Using the frequency map approach, for a1, we look for a_j with res_x = (-a1 % x) % x and res_y = a1 % y.

Then, we add the frequency of (res_x, res_y), which is initially 0, since only a1 has been processed so far.

Then, we add a1's residues to the frequency map.

Next, for a2, we look for a_j with res_x = (-a2 % x) % x and res_y = a2 % y.

At this point, the frequency map contains a1's residues.

So, if a1's residues match the required residues for a2, we'll count 1; otherwise, 0.

Which is correct, since there's only one possible pair.

Another edge case: x=1, y=1.

In this case, all sums and differences are divisible by 1, so all pairs are beautiful.

The number of beautiful pairs should be the number of ways to choose 2 elements out of n, which is n*(n-1)/2.

Let me verify with n=3: should be 3 pairs.

With our approach:

- For a1: look for a_j with res_x=0 and res_y=0 (since -a1%1=0 and a1%1=0), but frequency map is empty -> 0

- Add a1's residues (0,0) to frequency map: {(0,0):1}

- For a2: look for a_j with res_x=0 and res_y=0, frequency=1 -> add 1 to count

- Add a2's residues (0,0) to frequency map: {(0,0):2}

- For a3: look for a_j with res_x=0 and res_y=0, frequency=2 -> add 2 to count

- Total count: 0 + 1 + 2 = 3, which is correct.

Good.

Another edge case: all elements are equal.

Suppose n=4, x=2, y=2, a=[1,1,1,1]

Residues: all (1%2=1,1%2=1) -> (1,1)

For each a_i:

- Required res_x = (-1 % 2) % 2 = 1

- Required res_y = 1

- Look for (1,1) in frequency map.

- For a1: frequency=0

- Add (1,1) to frequency map: {(1,1):1}

- For a2: frequency=1 -> count +=1

- Add (1,1) to frequency map: {(1,1):2}

- For a3: frequency=2 -> count +=2

- Add (1,1) to frequency map: {(1,1):3}

- For a4: frequency=3 -> count +=3

- Total count: 0+1+2+3=6, which is n*(n-1)/2=6, which is correct since all pairs are beautiful.

Perfect.

Another case: n=3, x=2, y=2, a=[1,2,3]

Residues:

a1: (1,1)

a2: (0,0)

a3: (1,1)

Processing:

i=1: required (1,1) -> frequency=0; add (1,1) to frequency map: {(1,1):1}

i=2: required (0,0) -> frequency=0; add (0,0) to frequency map: {(1,1):1, (0,0):1}

i=3: required (1,1) -> frequency=1; add 1 to count; add (1,1) to frequency map: {(1,1):2, (0,0):1}

Total count: 1

Looking at the pairs:

<1,2>: 1+2=3 not divisible by 2; 1-2=-1 not divisible by 2 -> not beautiful

<1,3>: 1+3=4 divisible by 2; 1-3=-2 divisible by 2 -> beautiful

<2,3>: 2+3=5 not divisible by 2; 2-3=-1 not divisible by 2 -> not beautiful

So, only one beautiful pair, which matches the count.

Good.

Another case: n=4, x=3, y=2, a=[1,2,4,5]

Residues:

a1: (1,1)

a2: (2,0)

a3: (1,0)

a4: (2,1)

Processing:

i=1: required (2,1); frequency=0; add (1,1) to frequency map: {(1,1):1}

i=2: required (1,0); frequency=1 (from a1); count +=1; add (2,0) to frequency map: {(1,1):1, (2,0):1}

i=3: required (1,0); frequency=1 (from a1); count +=1; add (1,0) to frequency map: {(1,1):1, (2,0):1, (1,0):1}

i=4: required (1,1); frequency=1 (from a1); count +=1; add (2,1) to frequency map: {(1,1):1, (2,0):1, (1,0):1, (2,1):1}

Total count: 0 + 1 + 1 + 1 = 3

Looking at the pairs:

<1,2>: 1+2=3 divisible by 3; 1-2=-1 not divisible by 2 -> not beautiful

<1,3>: 1+4=5 not divisible by 3; 1-4=-3 divisible by 2 -> not beautiful

<1,4>: 1+5=6 divisible by 3; 1-5=-4 divisible by 2 -> beautiful

<2,3>: 2+4=6 divisible by 3; 2-4=-2 divisible by 2 -> beautiful

<2,4>: 2+5=7 not divisible by 3; 2-5=-3 divisible by 2 -> not beautiful

<3,4>: 4+5=9 divisible by 3; 4-5=-1 not divisible by 2 -> not beautiful

So, only <1,4> and <2,3> are beautiful, but according to the count, it's 3. That's inconsistent.

Wait, perhaps I miscounted.

Let me re-examine:

From the frequency map approach, we have count=3, but manually, I only see two beautiful pairs.

This suggests an error in the approach.

Wait, perhaps the frequency map approach is overcounting.

Let me re-examine the approach.

In the frequency map, we're looking for pairs where a_j has res_x = (-a_i % x) % x and res_y = a_i % y.

But in reality, a_j's res_x is (-a_i % x) % x, and res_y is a_i % y.

But in the example above, for a1=1: res_x=1, res_y=1

Required for a_j: res_x= (-1 % 3) % 3 = 2, res_y=1

Looking for (2,1) in frequency map: empty -> 0

Add (1,1) to frequency map.

For a2=2: res_x=2, res_y=0

Required for a_j: res_x= (-2 % 3) % 3 = 1, res_y=0

Looking for (1,0) in frequency map: frequency=0 -> 0

Add (2,0) to frequency map.

For a3=4: res_x=1, res_y=0

Required for a_j: res_x= (-1 % 3) % 3 = 2, res_y=0

Looking for (2,0) in frequency map: frequency=1 (from a2) -> count +=1

Add (1,0) to frequency map: {(1,1):1, (2,0):1, (1,0):1}

For a4=5: res_x=2, res_y=1

Required for a_j: res_x= (-2 % 3) % 3 =1, res_y=1

Looking for (1,1) in frequency map: frequency=1 (from a1) -> count +=1

Add (2,1) to frequency map: {(1,1):1, (2,0):1, (1,0):1, (2,1):1}

Total count: 0 + 0 +1 +1=2, which matches the manual count of 2 beautiful pairs.

Earlier, I mistakenly thought the count was 3, but actually, it's 2.

So, the approach is correct.

I must have made a mistake in simulating the frequency map.

Therefore, the approach is solid.

I need to implement this carefully in code, ensuring that I correctly compute the required residues and look them up in the frequency map.

Now, let's consider the implementation details.

I need to read all input at once for efficiency.

I can use sys.stdin.read() to read all input data.

Then, split the data into tokens.

Then, process the number of test cases.

For each test case, read n, x, y, and then the next n elements as the array a.

Then, apply the frequency map approach as described.

I need to collect the results for all test cases and print them at the end.

To handle large inputs efficiently, I should use a defaultdict for the frequency map.

Also, since the residues can be up to x and y, which are up to 10^9, but since we're using a frequency map, the memory should be manageable as long as n is up to 2*10^5 per test case.

I need to make sure that I don't have any off-by-one errors in indexing or in computing residues.

Also, ensure that negative residues are handled correctly by using the positive equivalent.

In Python, a negative number modulo x is x - (-num % x), but in Python, -num % x already gives a positive residue, so (-num % x) % x is safe.

Wait, in Python, the modulo operation with a negative numerator yields a result with the same sign as the denominator.

Since x is positive, (-num % x) will be non-negative, so (-num % x) % x is redundant but safe.

To summarize, in Python, (-num % x) is equivalent to x - (num % x) if num % x != 0, else 0.

But in the context of residues, it's correct to use (-num % x) % x to get a positive residue.

But actually, in Python, (-num % x) already gives a residue in the range [0, x-1], so (-num % x) % x is equal to (-num % x).

Hence, it's safe to use (-num % x) directly.

Let me confirm:

For num=1, x=5: -1 % 5 = 4, which is correct.

num=2, x=5: -2 % 5 = 3, which is correct.

num=5, x=5: -5 % 5 = 0, which is correct.

Good.

Now, for implementation, I need to process multiple test cases efficiently.

I can collect all test cases first, then process them one by one.

Alternatively, I can process them on the fly, but collecting them first is simpler.

Once I have all test cases, I can define a function, say func_1, that takes the list of test cases and returns a list of results.

Then, I can print the results separated by newlines.

Let me consider defining func_1 as follows:

def func_1(test_cases):

results = []

for (n, x, y, arr) in test_cases:

count = 0

residue_map = {}

for num in arr:

r_x = (-num % x) % x

r_y = num % y

count += residue_map.get((r_x, r_y), 0)

current_key = (num % x, num % y)

residue_map[current_key] = residue_map.get(current_key, 0) + 1

results.append(count)

return results

This seems straightforward.

Now, in the main part of the code, I need to read all input data, split it into tokens, and process them accordingly.

I need to handle multiple test cases correctly, ensuring that I read the correct number of elements for each test case.

To manage indices properly, I can use a index variable that tracks my position in the token list.

For example:

data = sys.stdin.read().split()

t = int(data[0])

index = 1

test_cases = []

for _ in range(t):

(n, x, y) = map(int, data[index:index+3])

index += 3

arr = list(map(int, data[index:index+n]))

index += n

test_cases.append((n, x, y, arr))

Then, results = func_1(test_cases)

print('\n'.join(map(str, results)))

This should work.

I need to make sure that all variables are correctly referenced and that there are no off-by-one errors in indexing.

Also, ensure that all input data is consumed correctly.

Let me think about possible error-prone parts.

- Ensuring that the residues are computed correctly, especially for negative numbers.

- Handling the frequency map updates correctly to avoid counting invalid pairs.

- Managing the indices correctly while reading the input data.

- Ensuring that the frequency map uses tuples of (res_x, res_y) as keys.

Also, since x and y can be 1, I need to handle residues of 0 correctly.

Additionally, since a_i can be up to 10^9, I need to make sure that the modulo operations don't cause integer overflow, but in Python, integers can be arbitrarily large, so it's not an issue.

I should also consider using a defaultdict for the residue map to simplify the code.

Using collections.defaultdict(int), I can avoid using get method and directly increment the count.

So, the func_1 can be rewritten as:

from collections import defaultdict

def func_1(test_cases):

results = []

for (n, x, y, arr) in test_cases:

count = 0

residue_map = defaultdict(int)

for num in arr:

r_x = (-num % x) % x

r_y = num % y

count += residue_map[(r_x, r_y)]

current_key = (num % x, num %