Alright, I have this problem to solve. Let's understand what's being asked.

We have a village with n houses, and there's a big road that will divide the village into left and right sides. Each resident has a preference: they want to live on either the left (0) or the right (1) side of the road.

The road can be built between any two houses, or before the first house or after the last house. So, the positions where the road can be built are from position 0 (before the first house) to position n (after the last house).

For each possible position i where the road is built, the houses from 1 to i are on the left side, and the houses from i+1 to n are on the right side.

The goal is to choose the position i such that:

- At least half of the residents on the left side are satisfied with being on the left side.

- At least half of the residents on the right side are satisfied with being on the right side.

And among all such positions, we need to choose the one that is as close as possible to the middle of the village. If there are multiple positions with the same minimum distance to the middle, we choose the smaller i.

The input consists of multiple test cases, and for each test case, we have the number of houses n and a string of length n consisting of 0s and 1s representing the preferences of the residents.

First, I need to make sure I understand the problem correctly.

Let's look at the example provided:

Input:

7

3

101

6

010111

6

011001

3

000

3

110

3

001

4

1100

Output:

2

3

2

3

0

1

0

So, for n=3 and a="101", the output is 2. That means the road is built after house 2.

Let's verify:

- Left side: houses 1 and 2 with preferences 1 and 0. So, out of 2 houses, 1 wants to be on the left. Since ceil(2/2)=1, at least 1 resident is satisfied.

- Right side: house 3 with preference 1. So, out of 1 house, 1 wants to be on the right. ceil(1/2)=1, so at least 1 resident is satisfied.

This seems correct.

Another example: n=6, a="010111", output=3.

- Left side: houses 1 to 3 with preferences 0,1,0. Out of 3 houses, 2 want left (0). ceil(3/2)=2, so at least 2 satisfied.

- Right side: houses 4 to 6 with preferences 1,1,1. Out of 3 houses, all 3 want right (1). ceil(3/2)=2, so at least 2 satisfied.

Good.

Now, I need to find a way to efficiently determine the best position i for the road for any given n and a.

Constraints:

- Number of test cases t <= 2*10^4

- For each test case, 3 <= n <= 3*10^5

- Sum of n over all test cases <= 3*10^5

So, the total time complexity should be O(T*N), where T is the number of test cases and N is the average n per test case. Given T can be up to 2*10^4 and N up to 3*10^5, but sum of N over all test cases is 3*10^5, it's manageable.

I need an efficient way to compute the number of satisfied residents on both sides for each possible i.

Let's think about how to calculate the number of satisfied residents on each side.

For the left side (houses 1 to i):

- Count the number of 0s (residents who want left).

- Need at least ceil(i/2) zeros.

Similarly, for the right side (houses i+1 to n):

- Count the number of 1s (residents who want right).

- Need at least ceil((n-i)/2) ones.

I need to iterate over all possible i from 0 to n and check these conditions.

But iterating over all i for each test case would be too slow because T*N is up to 2*10^4 * 3*10^5 = 6*10^9 operations, which is too much.

I need a smarter way to find the suitable i without checking all possibilities.

Wait, maybe I can precompute prefix sums for the number of 0s on the left and the number of 1s on the right.

Let me define:

- left_zeros[i]: number of 0s in houses 1 to i.

- right_ones[i]: number of 1s in houses i+1 to n.

Then, for each i, check:

- left_zeros[i] >= ceil(i/2)

- right_ones[i] >= ceil((n-i)/2)

To compute left_zeros and right_ones efficiently, I can use prefix sums.

Let's define prefix_sum[j] as the cumulative count of 0s up to house j.

So, left_zeros[i] = prefix_sum[i]

right_ones[i] = (total 1s in the string) - (number of 1s up to house i)

Wait, actually, since a[j] is either 0 or 1, I need to handle it properly.

Let me define:

- prefix_zero[j]: number of 0s in a[1] to a[j]

- prefix_one[j]: number of 1s in a[1] to a[j]

Then:

- left_zeros[i] = prefix_zero[i]

- right_ones[i] = (total ones) - prefix_one[i]

Wait, total ones is prefix_one[n]

But a[j] is either '0' or '1', so I need to count them correctly.

Let me adjust that.

Given a string a of length n, with characters '0' or '1'.

Define prefix_zero[j] = number of '0's in a[1] to a[j]

prefix_one[j] = number of '1's in a[1] to a[j]

Then:

- left_zeros[i] = prefix_zero[i]

- right_ones[i] = (prefix_one[n] - prefix_one[i])

Because prefix_one[i] is the number of '1's up to house i, so the number of '1's from i+1 to n is prefix_one[n] - prefix_one[i]

Now, for each i from 0 to n:

- If i == 0:

- Left side: 0 houses

- Right side: n houses, need at least ceil(n/2) ones.

- If i == n:

- Left side: n houses, need at least ceil(n/2) zeros.

- Right side: 0 houses

- For 0 < i < n:

- Left side: i houses, need at least ceil(i/2) zeros.

- Right side: n - i houses, need at least ceil((n-i)/2) ones.

I need to find the i where both conditions are satisfied and minimize |n/2 - i|.

If multiple i satisfy the condition with the same |n/2 - i|, choose the smaller i.

I need to implement this efficiently.

Given that sum of n over all test cases is 3*10^5, I can afford O(n) per test case.

Let's outline the steps for each test case:

1. Read n and the string a.

2. Compute prefix_zero and prefix_one arrays.

3. Iterate through all possible i from 0 to n:

a. For i == 0:

- Left side: 0 houses

- Right side: n houses, check if (prefix_one[n] >= ceil(n/2))

b. For i == n:

- Left side: n houses, check if (prefix_zero[n] >= ceil(n/2))

- Right side: 0 houses

c. For 0 < i < n:

- Left side: i houses, check if prefix_zero[i] >= ceil(i/2)

- Right side: n - i houses, check if (prefix_one[n] - prefix_one[i]) >= ceil((n-i)/2)

4. Collect all i that satisfy the conditions.

5. Among these i, find the one with the minimal |n/2 - i|.

6. If there are multiple, choose the smallest i.

7. Output i.

Now, I need to implement this efficiently.

But iterating through all i from 0 to n for each test case would be O(n) per test case, which is acceptable since sum of n over all test cases is 3*10^5.

However, in the initial code provided, it seems there's a function func_1() that attempts to solve this.

Let's look at the provided code:

from heapq import heappush, heappop, heapify

from collections import defaultdict, deque,Counter

from math import ceil, floor, sqrt, factorial,gcd,cos,sin,pi

from itertools import permutations, combinations,product

from bisect import bisect_left, bisect_right

from copy import deepcopy

from fractions import Fraction

import sys

vector1 = [[0, -1], [1, 0], [0, 1], [-1, 0]]

vector2 = [[0, 1], [1, 0], [-1, 0], [0, -1], [1, -1], [-1, 1], [1, 1], [-1, -1]]

if __name__ == '__main__':

func_2()

def func_1():

n = int(input())

a = input()

S = [[0, 0]]

for s in a:

(x, y) = S[-1]

if s == '0':

x += 1

else:

y += 1

S.append([x, y])

ans = -1

for i in range(n + 1):

left = S[i][0]

lsum = i

right = S[-1][1] - S[i][1]

rsum = n - i

if left * 2 < lsum or right * 2 < rsum:

continue

elif abs(n / 2 - i) < abs(n / 2 - ans):

ans = i

print(ans)

def func_2():

for _ in range(int(input())):

func_1()

So, func_2() reads the number of test cases and calls func_1() for each test case.

func_1() reads n and the string a, computes prefix sums for 0s and 1s in S, and then iterates through all possible i from 0 to n to find the best position.

It seems correct at first glance.

Let's verify it with the first test case:

n=3, a="101"

S = [[0,0]]

For s='1': y +=1 => [0,1]

For s='0': x +=1 => [0,1] -> [1,1]

For s='1': y +=1 => [1,2]

So S = [[0,0], [0,1], [1,1], [1,2]]

Now, iterate i from 0 to 3:

i=0:

left = S[0][0] = 0

lsum = 0

right = S[-1][1] - S[0][1] = 2 - 0 = 2

rsum = 3 - 0 = 3

Check if 0*2 < 0 or 2*2 < 3, which is 0 < 0 or 4 < 3, both false, so continue.

Since neither condition is true, proceed.

abs(3/2 - 0) = 1.5 < abs(3/2 - (-1)) = 1.5, so ans = 0

i=1:

left = S[1][0] = 0

lsum = 1

right = 2 - 1 = 1

rsum = 2

Check if 0*2 < 1 or 1*2 < 2, which is 0 < 1 or 2 < 2, so 0 < 1 is true, continue.

So, this i doesn't satisfy.

i=2:

left = S[2][0] =1

lsum =2

right =2 -1=1

rsum=1

Check if 1*2 <2 or 1*2 <1, which is 2 <2 or 2<1, both false, so proceed.

abs(3/2 -2)=0.5 < abs(3/2 -0)=1.5, so ans=2

i=3:

left=S[3][0]=1

lsum=3

right=2-2=0

rsum=0

Check if 1*2 <3 or 0*2 <0, which is 2<3 or 0<0, 2<3 is true, so continue.

But in the code, it's "or", so if either condition is true, it continues.

Here, 2<3 is true, so it continues, meaning it doesn't consider i=3.

But in the example, i=2 is chosen, which is correct.

So, the code seems to be working correctly for this case.

Another test case: n=6, a="010111"

Compute S:

S = [[0,0]]

s='0': x+=1 => [1,0]

s='1': y+=1 => [1,1]

s='0': x+=1 => [2,1]

s='1': y+=1 => [2,2]

s='1': y+=1 => [2,3]

s='1': y+=1 => [2,4]

So S = [[0,0], [1,0], [1,1], [2,1], [2,2], [2,3], [2,4]]

Now, iterate i from 0 to 6:

i=0:

left=0

lsum=0

right=4-0=4

rsum=6

Check 0*2 <0 or 4*2 <6, which is 0<0 or 8<6, both false, proceed.

abs(6/2 -0)=3 < abs(6/2 -(-1))=3, so ans=0

i=1:

left=1

lsum=1

right=4-0=4

rsum=5

Check 1*2 <1 or 4*2 <5, which is 2<1 or 8<5, both false, proceed.

abs(3-1)=2 < abs(3-0)=3, so ans=1

i=2:

left=1

lsum=2

right=4-1=3

rsum=4

Check 1*2 <2 or 3*2 <4, which is 2<2 or 6<4, both 2<2 is false (since 2==2), so proceed.

abs(3-2)=1 < abs(3-1)=2, so ans=2

i=3:

left=2

lsum=3

right=4-1=3

rsum=3

Check 2*2 <3 or 3*2 <3, which is 4<3 or 6<3, both false, proceed.

abs(3-3)=0 < abs(3-2)=1, so ans=3

i=4:

left=2

lsum=4

right=4-2=2

rsum=2

Check 2*2 <4 or 2*2 <2, which is 4<4 or 4<2, both false, proceed.

abs(3-4)=1 > abs(3-3)=0, so no change, ans=3

i=5:

left=2

lsum=5

right=4-3=1

rsum=1

Check 2*2 <5 or 1*2 <1, which is 4<5 or 2<1, 4<5 is true, continue.

i=6:

left=2

lsum=6

right=4-4=0

rsum=0

Check 2*2 <6 or 0*2 <0, which is 4<6 or 0<0, 4<6 is true, continue.

So, the code would output 3 for this case, but the example output is 3, which matches.

Wait, but in the example, it's outputting 3 for n=6, a="010111", which matches.

Another test case: n=6, a="011001"

Compute S:

S = [[0,0]]

s='0': x+=1 => [1,0]

s='1': y+=1 => [1,1]

s='1': y+=1 => [1,2]

s='0': x+=1 => [2,2]

s='0': x+=1 => [3,2]

s='1': y+=1 => [3,3]

So S = [[0,0], [1,0], [1,1], [1,2], [2,2], [3,2], [3,3]]

Iterate i from 0 to 6:

i=0:

left=0

lsum=0

right=3-0=3

rsum=6

Check 0*2 <0 or 3*2 <6, which is 0<0 or 6<6, both false, proceed.

abs(3-0)=3 < abs(3-(-1))=3, so ans=0

i=1:

left=1

lsum=1

right=3-0=3

rsum=5

Check 1*2 <1 or 3*2 <5, which is 2<1 or 6<5, both false, proceed.

abs(3-1)=2 < abs(3-0)=3, so ans=1

i=2:

left=1

lsum=2

right=3-1=2

rsum=4

Check 1*2 <2 or 2*2 <4, which is 2<2 or 4<4, both false, proceed.

abs(3-2)=1 < abs(3-1)=2, so ans=2

i=3:

left=1

lsum=3

right=3-2=1

rsum=3

Check 1*2 <3 or 1*2 <3, which is 2<3 or 2<3, both true, so continue.

Wait, but in the code, it's "or", so if either is true, it continues.

Here, both are true, so it continues, meaning it doesn't consider i=3.

But according to the example, the output should be 2, which matches.

Proceeding:

i=4:

left=2

lsum=4

right=3-2=1

rsum=2

Check 2*2 <4 or 1*2 <2, which is 4<4 or 2<2, both false, proceed.

abs(3-4)=1 == abs(3-2)=1, but since ans=2 is smaller, no change.

i=5:

left=3

lsum=5

right=3-3=0

rsum=1

Check 3*2 <5 or 0*2 <1, which is 6<5 or 0<1, 0<1 is true, continue.

i=6:

left=3

lsum=6

right=3-3=0

rsum=0

Check 3*2 <6 or 0*2 <0, which is 6<6 or 0<0, both false, proceed.

abs(3-6)=3 > abs(3-2)=1, so no change.

Thus, ans=2, which matches the example.

Seems correct.

Another test case: n=3, a="000"

Compute S:

S = [[0,0]]

s='0': x+=1 => [1,0]

s='0': x+=1 => [2,0]

s='0': x+=1 => [3,0]

S = [[0,0], [1,0], [2,0], [3,0]]

Iterate i from 0 to 3:

i=0:

left=0

lsum=0

right=0-0=0

rsum=3

Check 0*2 <0 or 0*2 <3, which is 0<0 or 0<3, 0<3 is true, continue.

i=1:

left=1

lsum=1

right=0-0=0

rsum=2

Check 1*2 <1 or 0*2 <2, which is 2<1 or 0<2, 0<2 is true, continue.

i=2:

left=2

lsum=2

right=0-0=0

rsum=1

Check 2*2 <2 or 0*2 <1, which is 4<2 or 0<1, 0<1 is true, continue.

i=3:

left=3

lsum=3

right=0-0=0

rsum=0

Check 3*2 <3 or 0*2 <0, which is 6<3 or 0<0, both false, proceed.

abs(1.5-3)=1.5 < abs(1.5-(-1))=2.5, so ans=3

So, output is 3, which matches the example.

Another test case: n=3, a="110"

Compute S:

S = [[0,0]]

s='1': y+=1 => [0,1]

s='1': y+=1 => [0,2]

s='0': x+=1 => [1,2]

S = [[0,0], [0,1], [0,2], [1,2]]

Iterate i from 0 to 3:

i=0:

left=0

lsum=0

right=2-0=2

rsum=3

Check 0*2 <0 or 2*2 <3, which is 0<0 or 4<3, both false, proceed.

abs(1.5-0)=1.5 < abs(1.5-(-1))=2.5, so ans=0

i=1:

left=0

lsum=1

right=2-1=1

rsum=2

Check 0*2 <1 or 1*2 <2, which is 0<1 or 2<2, 0<1 is true, continue.

i=2:

left=0

lsum=2

right=2-2=0

rsum=1

Check 0*2 <2 or 0*2 <1, which is 0<2 or 0<1, both true, continue.

i=3:

left=1

lsum=3

right=2-2=0

rsum=0

Check 1*2 <3 or 0*2 <0, which is 2<3 or 0<0, 2<3 is true, continue.

So, only i=0 satisfies, output is 0, which matches the example.

Another test case: n=3, a="001"

Compute S:

S = [[0,0]]

s='0': x+=1 => [1,0]

s='0': x+=1 => [2,0]

s='1': y+=1 => [2,1]

S = [[0,0], [1,0], [2,0], [2,1]]

Iterate i from 0 to 3:

i=0:

left=0

lsum=0

right=1-0=1

rsum=3

Check 0*2 <0 or 1*2 <3, which is 0<0 or 2<3, 2<3 is true, continue.

i=1:

left=1

lsum=1

right=1-0=1

rsum=2

Check 1*2 <1 or 1*2 <2, which is 2<1 or 2<2, both false, proceed.

abs(1.5-1)=0.5 < abs(1.5-0)=1.5, so ans=1

i=2:

left=2

lsum=2

right=1-0=1

rsum=1

Check 2*2 <2 or 1*2 <1, which is 4<2 or 2<1, both false, proceed.

abs(1.5-2)=0.5 == abs(1.5-1)=0.5, choose smaller i, so ans=1

i=3:

left=2

lsum=3

right=1-1=0

rsum=0

Check 2*2 <3 or 0*2 <0, which is 4<3 or 0<0, both false, proceed.

abs(1.5-3)=1.5 > abs(1.5-1)=0.5, so no change.

Thus,