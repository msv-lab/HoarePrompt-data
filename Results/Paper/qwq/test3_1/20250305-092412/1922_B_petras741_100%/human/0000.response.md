Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a certain number, specifically 2^{a_i} for each stick i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which in terms of side lengths translates to the triangle inequality holding: the sum of any two sides must be greater than the third side.

So, my task is to count the number of ways to choose 3 sticks such that they satisfy the triangle inequality.

First, I need to understand the input and output format. There are multiple test cases, and for each test case, I get n, the number of sticks, and a list of n integers a_i, where each a_i corresponds to the exponent in the length of the stick, which is 2^{a_i}.

Constraints:

- Number of test cases t: 1 ≤ t ≤ 10^4

- For each test case:

- n: 1 ≤ n ≤ 3⋅10^5

- a_i: 0 ≤ a_i ≤ n

- Sum of n over all test cases does not exceed 3⋅10^5

Output:

- For each test case, print the number of ways to choose 3 sticks that can form a triangle.

Example:

Input:

4

7

1 1 1 1 1 1 1

4

3 2 1 3

3

1 2 3

1

1

Output:

35

2

0

0

In the first test case, all sticks have the same length 2^1 = 2. So, any three sticks will form an equilateral triangle, and the number of ways to choose 3 sticks out of 7 is C(7,3) = 35.

In the second test case, lengths are 2^3=8, 2^2=4, 2^1=2, 2^3=8. The possible triangles are:

- Sticks 1, 3, 4: lengths 8, 2, 8 → sums: 8+2>8, 8+8>2, 2+8>8 → valid

- Sticks 1, 2, 4: lengths 8, 4, 8 → sums: 8+4>8, 8+8>4, 4+8>8 → valid

So, total of 2 valid triangles.

In the third test case, lengths are 2, 4, 8. Let's check if they can form a triangle:

- 2 + 4 = 6, which is not greater than 8. So, no triangle can be formed.

In the fourth test case, only one stick, which is less than 3, so no triangle can be formed.

Alright, now to think about how to approach this problem.

First, I need to generate the lengths of the sticks based on the exponents provided. However, since the lengths are powers of 2, and powers of 2 are unique and non-overlapping in their binary representations, I need to see if there's a smart way to utilize this property.

Wait, powers of 2 are distinct in that no two powers of 2 add up to another power of 2. For example, 2^1 + 2^1 = 2^2, but since all sticks have unique indices, and the exponents can be repeated, I need to consider the multiset of exponents.

Let me think about the triangle inequality in terms of exponents.

Given three exponents a, b, c where a ≤ b ≤ c, the triangle inequality requires that 2^a + 2^b > 2^c.

Because 2^c is the largest, we only need to check if 2^a + 2^b > 2^c.

Given that 2^a + 2^b ≤ 2^c when a and b are less than or equal to c.

Wait, but in the case where a = b = c, 2^a + 2^b = 2^(a+1) > 2^c if a < c.

Wait, no. If a = b = c, then 2^a + 2^b = 2^(a+1), which is equal to 2^(c + 1), but 2^(c + 1) > 2^c, so it satisfies the inequality.

Wait, but in general, for a ≤ b ≤ c, 2^a + 2^b > 2^c if and only if b < c.

Wait, is that true?

Let's see:

If a ≤ b < c, then 2^a + 2^b ≤ 2^(b+1).

If b < c, then 2^(b+1) ≤ 2^c only if b+1 ≤ c.

So, 2^a + 2^b ≤ 2^(b+1) ≤ 2^c.

But we have equality only if a = b and b + 1 = c.

Wait, but in general, 2^a + 2^b ≤ 2^(b+1), and 2^(b+1) ≤ 2^c if b + 1 ≤ c.

So, 2^a + 2^b ≤ 2^c if b + 1 ≤ c.

Therefore, 2^a + 2^b > 2^c if b + 1 > c, which implies b ≥ c.

But b ≤ c, so b = c.

Therefore, 2^a + 2^b > 2^c if and only if b = c.

Wait, but in that case, 2^a + 2^b = 2^a + 2^c.

If a < c, then 2^a + 2^c = 2^a + 2^c, which is greater than 2^c only if 2^a > 0, which is always true.

Wait, no.

Wait, 2^a + 2^c > 2^c is equivalent to 2^a > 0, which is always true since a ≥ 0.

Wait, but that can't be right.

Wait, for example, take a = 0, b = 0, c = 1.

Then, 2^0 + 2^0 = 1 + 1 = 2, which is equal to 2^1 = 2.

So, 2^a + 2^b = 2^c when a = b = c - 1.

So, in general, 2^a + 2^b > 2^c if and only if a + b > c when a, b, c are exponents.

Wait, is that correct?

Wait, 2^a + 2^b > 2^c is equivalent to 2^a + 2^b > 2^c.

Taking logarithms doesn't directly help because of the addition.

Wait, perhaps it's better to think in terms of the exponents.

Let me consider that all lengths are powers of 2, so they are distinct in their binary representations.

I need to find triplets where the sum of any two is greater than the third.

Given that powers of 2 are distinct, perhaps there's a smart way to count the valid triplets.

First, I should sort the exponents, so that I can easily identify the largest side and check the triangle inequality.

Let me sort the exponents in non-decreasing order.

Let’s denote the sorted exponents as a1 ≤ a2 ≤ ... ≤ an.

For any triplet (ai, aj, ak) where i < j < k, we have ai ≤ aj ≤ ak.

The triangle inequality requires that ai + aj > ak.

Given that all lengths are powers of 2, I can exploit properties of powers of 2 to optimize the counting.

One approach is to iterate over all possible ak and count the number of pairs (ai, aj) where ai and aj are before ak in the sorted list and ai + aj > ak.

But with n up to 3e5, a naive O(n^3) approach is too slow.

I need a more efficient way.

Let’s think about the properties of powers of 2.

We know that 2^x + 2^y, if x ≠ y, is equal to 2^max(x,y) + 2^min(x,y).

Specifically, if x < y, then 2^x + 2^y = 2^y + 2^x = 2^y + 2^x.

But in terms of comparing with 2^z, we can see that:

2^x + 2^y > 2^z if and only if x + y > z + K, where K is some constant.

Wait, perhaps I need to think in terms of inequalities of exponents.

Wait, 2^x + 2^y > 2^z.

If x < y < z, then 2^x + 2^y > 2^z if and only if y >= z.

Wait, but y < z, so y >= z is impossible.

Wait, no, y < z.

Wait, perhaps I need to consider the difference between y and z.

Wait, 2^x + 2^y > 2^z.

If x <= y < z, then 2^x + 2^y <= 2^(y+1).

So, 2^(y+1) > 2^z implies y + 1 > z, which is impossible since y < z.

Wait, y < z implies y + 1 <= z.

So, 2^(y+1) <= 2^z.

Therefore, 2^x + 2^y <= 2^(y+1) <= 2^z.

So, 2^x + 2^y <= 2^z.

Wait, but in the case where x = y and y = z - 1, 2^x + 2^y = 2^(y+1) = 2^z, which is equal, not greater.

So, in general, for x <= y < z, 2^x + 2^y <= 2^z.

Therefore, the only way to have 2^x + 2^y > 2^z is if y >= z.

But y < z, so that's impossible.

Wait, but in the earlier example, when a = b = c, 2^a + 2^b = 2^(a+1) > 2^c if a < c.

Wait, but if a = b = c, then 2^a + 2^b = 2^(a+1) > 2^c = 2^a only if a + 1 > c, which is only true if c = a.

Wait, but 2^(a+1) > 2^a is always true, but in this case, c = a, so it's not strictly greater.

Wait, no, if a = b = c, then 2^a + 2^b = 2^(a+1), which is equal to 2^c only if a + 1 = c, which is only possible if a + 1 = a, which is impossible.

Wait, there's confusion here.

Let me think again.

Suppose a <= b <= c.

We need 2^a + 2^b > 2^c.

Case 1: a < b < c.

Then, 2^a + 2^b <= 2^(b+1) <= 2^c, so 2^a + 2^b <= 2^c.

So, 2^a + 2^b > 2^c is impossible in this case.

Case 2: a < b = c.

Then, 2^a + 2^b = 2^a + 2^c.

If a < c, then 2^a + 2^c = 2^c + 2^a > 2^c, since 2^a > 0.

So, in this case, 2^a + 2^b > 2^c.

Case 3: a = b < c.

Similarly, 2^a + 2^b = 2^(a+1).

We need 2^(a+1) > 2^c, which is only possible if a + 1 > c.

But since a < c, a + 1 <= c, so this is impossible.

Wait, but if a < c, a + 1 <= c, so 2^(a+1) <= 2^c.

Hence, 2^a + 2^b <= 2^c.

So, only case where 2^a + 2^b > 2^c is when a < b = c.

Similarly, a = b < c is not possible, and a = b = c is a special case.

Wait, if a = b = c, then 2^a + 2^b = 2^(a+1) > 2^c = 2^a, which is true since 2^(a+1) > 2^a.

So, in this case, it's valid.

Wait, but in the earlier case, if a < b = c, it's valid only if a < b = c.

Wait, I need to sort this out.

Let me rephrase.

Given a <= b <= c:

- If a < b < c: 2^a + 2^b <= 2^c (since 2^a + 2^b <= 2^(b+1) <= 2^c)

- If a < b = c: 2^a + 2^b = 2^a + 2^c > 2^c (since 2^a > 0)

- If a = b < c: 2^a + 2^b = 2^(a+1) <= 2^c (since a + 1 <= c)

- If a = b = c: 2^a + 2^b = 2^(a+1) > 2^c = 2^a

So, in summary:

- Triplet is valid if:

- a < b = c

- a = b = c

Now, I need to count the number of triplets where:

- a < b = c

- or a = b = c

Wait, but in the case where a = b = c, it's included in a < b = c?

No, because a < b = c implies a < b = c, whereas a = b = c implies a = b = c.

So, they are separate cases.

Wait, no.

If a = b = c, then a < b = c is not applicable because a is not less than b.

Wait, no, if a = b = c, then a < b is false.

So, a < b = c is different from a = b = c.

Hence, I need to consider both cases separately.

So, the triplet is valid if:

- a < b = c

- or a = b = c

Therefore, I need to count the number of triplets where:

- Two sticks have the same length, and the third is shorter than them.

- Or all three sticks have the same length.

Now, to optimize the counting, I can group the sticks by their lengths.

Let’s denote the frequency of each length.

Let’s sort the unique lengths in increasing order.

For each unique length, I can have its frequency, i.e., how many sticks have that length.

Now, for the case where a < b = c:

- Choose two sticks with length c and one stick with length less than c.

For the case where a = b = c:

- Choose three sticks with the same length c.

So, I can iterate over each unique length c, and for each c, count the number of ways to choose two sticks of length c and one stick with length less than c.

Plus, for each c, count the number of ways to choose three sticks of length c.

Wait, but in the case where a = b = c, it's already included in choosing three sticks of the same length.

So, overall, for each c, the number of ways is:

- C(freq_c, 2) * (total sticks with length < c)

- Plus C(freq_c, 3)

Where C(n, k) is the combination of n things taken k at a time.

To compute this efficiently, I can sort the unique lengths in increasing order, and keep a running total of the frequencies of lengths less than c.

Let’s outline the steps:

1. Read the number of test cases t.

2. For each test case:

a. Read n.

b. Read the list of a_i.

c. Create a frequency map for the exponents a_i, since the lengths are 2^{a_i}, and powers of 2 are unique.

d. Sort the unique exponents in increasing order.

e. Initialize a running total of frequency for lengths less than the current c.

f. For each unique c in sorted order:

i. freq_c = frequency of c

ii. sticks_less_than_c = running total before c

iii. Add C(freq_c, 2) * sticks_less_than_c to the result

iv. Add C(freq_c, 3) to the result

3. Output the result for each test case.

Now, to implement this efficiently, considering that n can be up to 3e5 and t up to 1e4, but the sum of n over all test cases does not exceed 3e5, I need to make sure that my solution is O(n log n) per test case.

Implementing frequency maps and sorting unique exponents should be manageable.

Also, I need to handle large factorials for C(n, k), but since n can be up to 3e5, precomputing factorials might not be feasible due to time and space constraints.

Instead, I can compute C(n, k) on the fly using a function that calculates combinations without precomputing factorials.

Wait, but computing combinations for large n and k each time would be inefficient.

Alternatively, I can implement a function to compute C(n, k) efficiently, perhaps using the formula C(n, k) = n*(n-1)*...*(n-k+1)/(k*(k-1)*...*1)

This can be done in O(k) time, which for k=2 or 3 is acceptable.

Given that, I can proceed with this approach.

Let me think about potential edge cases:

- n < 3: cannot form a triangle, output 0

- All a_i are the same: if a_i are all equal, then a = b = c, and C(freq_c, 3) is the number of ways

- For example, in the first test case, all a_i are 1, so freq_1 = 7, and C(7, 3) = 35

- In the second test case, a_i = [3, 2, 1, 3], sorted exponents are [1, 2, 3, 3]

- For c=2: freq=1, sticks less than 2: freq_1=1, C(1,2)=0, so 0

- For c=3: freq=2, sticks less than 3: freq_1 + freq_2 = 1 + 1 = 2, C(2,2)*2 + C(2,3)=1*2 + 0=2, which matches the sample output

- In the third test case, a_i = [1,2,3], sorted exponents [1,2,3], no c where freq_c >=2, so output 0

- In the fourth test case, n=1, output 0

Seems consistent.

Another thing to consider is that a_i can be 0, which means a stick of length 1.

But since 2^0 = 1, it's valid.

Also, a_i can be up to n, which for n=3e5, a_i can be up to 3e5, meaning lengths up to 2^{3e5}, but since we're dealing with exponents, we don't need to worry about overflow, as we're only comparing exponents.

Wait, but in terms of frequencies, since exponents can be up to n, and n can be up to 3e5, I need to make sure that my frequency map can handle exponents up to 3e5.

In Python, dictionaries can handle that.

Also, sorting exponents up to 3e5 is manageable.

Time constraints should be okay, as per the constraints.

Now, to implement this in code.

I need to read t test cases, and for each test case, read n and the list a_i.

Then, create a frequency map for a_i.

Then, sort the unique a_i in increasing order.

Initialize a running total of frequencies for lengths less than c.

Then, for each c in sorted order:

- freq_c = frequency of c

- sticks_less_than_c = running total before c

- Add C(freq_c, 2) * sticks_less_than_c to the result

- Add C(freq_c, 3) to the result

Where C(n, k) is the combination function.

I need to implement C(n, k) efficiently.

In Python, I can define a function comb(n, k) that computes n! / (k! (n - k)!), but computing factorials for large n is not efficient.

Instead, I can compute comb(n, k) as n * (n - 1) * ... * (n - k + 1) / (k * (k - 1) * ... * 1)

For k=2: n*(n-1)/2

For k=3: n*(n-1)*(n-2)/6

This can be computed directly.

In code:

def comb(n, k):

if k == 0:

return 1

if k == 1:

return n

if k == 2:

return n * (n - 1) // 2

if k == 3:

return n * (n - 1) * (n - 2) // 6

# and so on for higher k, but in this problem, k is either 2 or 3

This should be efficient enough.

Now, let's think about implementing this.

Also, to optimize, since k is only 2 or 3, I can hardcode the formulas.

Now, considering that, I can proceed to code this solution.

But first, I need to make sure that I handle the input correctly, especially since t can be up to 1e4, but the sum of n over all test cases does not exceed 3e5, so input reading should be efficient.

In Python, reading input efficiently is important for large inputs.

I can read all input at once and process it accordingly.

But for simplicity, since n is up to 3e5 and t up to 1e4, but sum of n <= 3e5, I can read each test case one by one.

Now, looking at the provided program, let's see if it implements this logic correctly.

Looking at the code:

def func():

t = int(input())

buffer = []

for i in range(t):

n = int(input())

w = [int(k) for k in input().split()]

if n >= 3:

q = [0 for j in range(n + 1)]

for j in range(n):

q[w[j]] += 1

eta = []

for j in range(n + 1):

if q[j] > 0:

eta.append(j)

eta_ln = len(eta)

rho = q[eta[0]]

if eta_ln == 1:

print(n * (n - 1) * (n - 2) // 6)

else:

res = q[eta[0]] * (q[eta[0]] - 1) * (q[eta[0]] - 2) // 6

for j in range(1, eta_ln):

res += q[eta[j]] * (q[eta[j]] - 1) * (q[eta[j]] - 2) // 6

res += q[eta[j]] * (q[eta[j]] - 1) // 2 * rho

rho += q[eta[j]]

print(res)

else:

print(0)

Explanation:

- Read t, the number of test cases.

- For each test case:

- Read n.

- Read the list w of exponents a_i.

- If n < 3, print 0.

- Else:

- Create a frequency list q of size n+1, initialized to 0.

- Populate q with the frequency of each a_i.

- Create a list eta of unique exponents that appear in w.

- Sort eta implicitly by iterating from 0 to n.

- Initialize rho with q[eta[0]], which is the frequency of the smallest exponent.

- If there's only one unique exponent (eta_ln == 1):

- Compute C(n, 3) = n*(n-1)*(n-2)/6 and print it.

- Else:

- Initialize res with C(q[eta[0]], 3).

- For each unique exponent eta[j] from the second one to the last:

- Add C(q[eta[j]], 3) to res.

- Add C(q[eta[j]], 2) * rho to res.

- Update rho by adding q[eta[j]] to it.

- Print res.

Analysis:

This seems to implement the logic I described earlier.

- eta is the list of unique exponents in sorted order (from 0 to n).

- rho keeps track of the total frequency of exponents less than the current eta[j].

- For each unique exponent eta[j], it adds C(q[eta[j]], 3) to account for triplets where all three sticks have the same exponent.

- It also adds C(q[eta[j]], 2) * rho to account for triplets where two sticks have exponent eta[j] and one stick has an exponent less than eta[j].

This should correctly count the number of valid triplets.

In the sample input, for the first test case:

n=7, w=[1,1,1,1,1,1,1]

eta=[1], rho=q[1]=7

Since eta_ln==1, print C(7,3)=35

Second test case:

n=4, w=[3,2,1,3]

eta=[1,2,3]

rho=q[1]=1

res = C(1,3)=0

j=1, eta[j]=2, q[2]=1

res += C(1,3)=0 + C(1,2)*1=0*1=0 → res=0

j=2, eta[j]=3, q[3]=2

res += C(2,3)=0 + C(2,2)*rho=1*2=2 → res=2

Print res=2

Third test case:

n=3, w=[1,2,3]

eta=[1,2,3]

rho=q[1]=1

res = C(1,3)=0

j=1, eta[j]=2, q[2]=1

res += C(1,3)=0 + C(1,2)*1=0*1=0 → res=0

j=2, eta[j]=3, q[3]=1

res += C(1,3)=0 + C(1,2)*rho=0*2=0 → res=0

Print res=0

Fourth test case:

n=1, w=[1]

Print 0

Which matches the sample output.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{true}} \]