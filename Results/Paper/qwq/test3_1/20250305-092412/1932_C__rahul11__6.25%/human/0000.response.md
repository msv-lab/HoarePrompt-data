Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, a positive integer m, and a string of commands consisting of 'L's and 'R's. For each command in the string, I need to output the product of the current array elements modulo m, and then remove either the leftmost or the rightmost element of the array based on whether the command is 'L' or 'R'.

First, I need to understand the process step by step. Let's consider the first test case from the example:

Input:

4

4 6

3 1 4 2

LRRL

So, n=4, m=6, array=[3,1,4,2], and commands='LRRL'.

The expected output is: 0 2 4 1

Let's see how this works:

1. Initial array: [3,1,4,2]

Product: 3*1*4*2 = 24

24 mod 6 = 0

Output: 0

Then, first command is 'L', so remove the leftmost element (3).

Array becomes: [1,4,2]

2. New array: [1,4,2]

Product: 1*4*2 = 8

8 mod 6 = 2

Output: 0 2

Next command is 'R', so remove the rightmost element (2).

Array becomes: [1,4]

3. New array: [1,4]

Product: 1*4 = 4

4 mod 6 = 4

Output: 0 2 4

Next command is 'R', so remove the rightmost element (4).

Array becomes: [1]

4. New array: [1]

Product: 1

1 mod 6 = 1

Output: 0 2 4 1

That matches the example output. So, the process seems clear.

Now, I need to implement this efficiently, especially since n can be up to 2*10^5 and t can be up to 10^4, but the total sum of n across all test cases is up to 2*10^5.

First thoughts:

- For each test case, calculating the product each time would be too slow because n can be large, and doing this for multiple test cases would exceed time limits.

- I need a way to efficiently compute the product modulo m after each removal.

Ideas:

1. Precompute the product of the entire array, then, based on the command, divide the product by the element being removed, and take modulo m.

- However, division in modular arithmetic is tricky because m might not be prime, so I might not always have modular inverses.

- But in this problem, m is given as a positive integer up to 10^4, and the array elements are up to 10^4, so I need a general approach that works for any m.

2. Keep track of the product and update it by division whenever an element is removed.

- But direct division might not work in modular arithmetic if the element is not coprime with m.

3. Another approach is to precompute the prefix and suffix products modulo m, and based on the sequence of 'L's and 'R's, determine which elements are still in the array at each step.

- This might be complicated to implement efficiently.

4. Use a sliding window approach, but it's not straightforward here because the window is changing based on 'L' and 'R' commands.

Wait, perhaps I can simulate the process using two pointers, one for the left and one for the right of the array, and keep track of the current product.

Let me think about that.

Initialize:

- left pointer at 0

- right pointer at n-1

- current product as product of all elements in the array.

Then, for each command:

- Output current product modulo m.

- If command is 'L', remove the leftmost element (at left pointer), update the product by dividing by that element.

- If command is 'R', remove the rightmost element (at right pointer), update the product by dividing by that element.

- Move the respective pointer.

But again, division in modular arithmetic is tricky.

Alternative idea:

Instead of dividing, keep track of the product and the elements that have been removed.

But with removals from either end, it's not straightforward.

Wait, perhaps I can keep the product and, when removing an element, multiply by its modular inverse if it exists.

But as m may not be prime, and the elements may not be coprime with m, modular inverses may not exist.

Is there a way to handle this?

Let's recall that in modular arithmetic, division is multiplication by the inverse.

But if the element is not invertible modulo m, we cannot directly divide.

However, in this problem, perhaps I can compute the product modulo m at each step without actually performing division.

Wait, perhaps I can maintain the product as I remove elements, but handle the modulo correctly.

But I'm not sure.

Let me consider another approach.

Since we need to output the product modulo m at each step, and then remove an element based on 'L' or 'R', maybe I can precompute the product and then adjust it as I remove elements.

But again, removing elements requires dividing the product by the removed element, which is problematic in modular arithmetic.

Another idea: Since m can be up to 10^4, which is small, perhaps factorize m into its prime factors and handle each prime power separately, then combine the results using the Chinese Remainder Theorem.

But this seems too complicated for this problem, and might be overkill.

Wait, perhaps I can compute the product modulo m directly, and handle the division by removing the contribution of the removed element.

But I'm going in circles here.

Let me look at the constraints again.

n can be up to 2*10^5, and t up to 10^4, but the total n across all test cases is up to 2*10^5.

So, I need an O(n) per test case solution.

Let me consider that m is small (up to 10^4), and n can be up to 2*10^5.

Perhaps I can compute the product modulo m, and keep track of the exponents of the prime factors in m.

Wait, perhaps not.

Another idea: Since m is small, I can compute the product modulo m directly, but handle the division by precomputing inverses for elements that are coprime with m.

But again, elements may not be coprime with m.

Wait, perhaps I can compute the product and handle the division by removing the factor of the removed element.

But I'm stuck.

Let me consider a different approach.

Perhaps I can precompute the prefix products and suffix products, and based on the sequence of 'L's and 'R's, determine which elements are still in the array at each step, and compute the product accordingly.

For example, keep track of the current left and right boundaries, and compute the product of the subarray from left to right.

But for n up to 2*10^5, this might be too slow if done naively.

Wait, but if I precompute the prefix products, I can compute the product of any subarray in O(1) time.

Let me think about that.

Compute prefix products:

prefix[i] = a[0] * a[1] * ... * a[i-1] mod m

Similarly, suffix[i] = a[i] * a[i+1] * ... * a[n-1] mod m

Then, at each step, depending on the sequence of 'L's and 'R's, the current array is a subarray of the original array.

But it's not that straightforward because the removals are from either end based on 'L' and 'R' commands.

Wait, actually, each 'L' removes the leftmost element, and each 'R' removes the rightmost element.

So, the remaining array after k commands is the subarray from left to right, where left and right are determined by the sequence of 'L's and 'R's.

Wait, but it's not a simple subarray because the removals can be from either end.

For example, if commands are 'L', 'R', 'L', then:

- After 'L': remove leftmost, remaining is a[1:] to a[n-1]

- After 'R': remove rightmost, remaining is a[1:] to a[n-2]

- After 'L': remove leftmost, remaining is a[2:] to a[n-2]

So, the remaining array is a[2:n-1]

So, in this case, the remaining elements are from index 2 to n-2.

So, in general, after k commands, the remaining array is a[l:r+1], where l and r are updated based on the commands.

So, perhaps I can keep track of l and r, and compute the product of a[l:r+1] modulo m at each step.

But computing the product of a subarray a[l:r+1] each time would be O(n) per step, which is too slow for n up to 2*10^5.

Wait, but if I precompute the prefix products, I can compute the product of a[l:r+1] in O(1) time.

Let me recall that prefix[r] * inverse(prefix[l-1]) mod m would give me the product of a[l:r+1], assuming a[l-1] is invertible.

But again, elements may not be invertible.

This seems problematic.

Wait, perhaps I can compute the product of a[l:r+1] directly by dividing the prefix[r] by prefix[l-1], but again, division in modular arithmetic is tricky.

Alternative idea: Since m is small, factorize m into its prime factors, and compute the exponents of each prime in the product.

Then, when removing an element, subtract its exponents.

Finally, compute the product modulo m from the exponents.

But this seems complicated and may not be efficient enough.

I need a better approach.

Let me look at the sample input and output again to see if there's a pattern.

Sample Input:

4

4 6

3 1 4 2

LRRL

Output:

0 2 4 1

Let's see:

Initial product: 3*1*4*2 = 24, 24 mod 6 = 0

After removing 3 (L), product: 1*4*2 = 8, 8 mod 6 = 2

After removing 2 (R), product: 1*4 = 4, 4 mod 6 = 4

After removing 4 (R), product: 1, 1 mod 6 = 1

Seems correct.

Another sample input:

5 1

1 1 1 1 1

LLLLL

Output:

0 0 0 0 0

Since any product modulo 1 is 0.

Another sample input:

6 8

1 2 3 4 5 6

RLLLRR

Output:

0 0 0 4 4 4

Let's verify:

Initial product: 1*2*3*4*5*6 = 720, 720 mod 8 = 0

Command 'R': remove last element (6), product: 1*2*3*4*5 = 120, 120 mod 8 = 0

Command 'L': remove leftmost element (1), product: 2*3*4*5 = 120, 120 mod 8 = 0

Command 'L': remove leftmost element (2), product: 3*4*5 = 60, 60 mod 8 = 4

Command 'L': remove leftmost element (3), product: 4*5 = 20, 20 mod 8 = 4

Command 'R': remove rightmost element (5), product: 4, 4 mod 8 = 4

Command 'R': remove rightmost element (4), empty array, product is 1, 1 mod 8 = 1

Wait, but the output is 0 0 0 4 4 4, which suggests that for the last step, it's 4, but according to my calculation, it should be 1.

Wait, perhaps the array becomes empty after removing 4, so product is 1.

But in the output, it's 4, which might be a mistake in the sample output, or I'm misunderstanding something.

Wait, no, the sample output is 0 0 0 4 4 4, but according to my calculation, it should be 0 0 0 4 4 1.

Maybe it's a typo in the sample output, or I'm missing something.

Wait, perhaps the problem states that after removing all elements, the array is empty, and the product is 1, but in the last step, it's still 4.

Wait, I need to check the problem statement again.

"after processing all commands, it will be empty.

Write a program that will process all commands in the order they are written in the string s (from left to right).

Output

For each test case, output n integers b_1, b_2, …, b_n, where b_i is the remainder when dividing the product of all elements of the current state of the array a by m at the beginning of the execution of the i-th command."

So, for each command, output the product of the current array modulo m, and then remove the element based on the command.

After all commands, the array should be empty.

In the third test case, the output is 0 0 0 4 4 4, which might have a typo, or I'm missing something.

Wait, perhaps the product becomes 1 when the array is empty, but in the output, it's still 4.

Maybe the problem doesn't require outputting for the empty array, only for the non-empty arrays.

Wait, no, the problem says to output n integers, one for each command.

Wait, in the third test case, n=6, and output is 0 0 0 4 4 4.

But according to my calculation, it should be 0 0 0 4 4 1.

Maybe it's a mistake in the sample output.

I need to be careful about that.

Another sample input:

1 10000

10000

R

Output:

0

Initial product: 10000, 10000 mod 10000 = 0

Remove 10000 (R), array becomes empty, product is 1, but since it's the last command, maybe don't output anything.

Wait, but the output has one element: 0

Perhaps for the last command, the array is already empty, so no product to output.

Wait, no, the problem says to output n integers, where n is the number of commands.

In this case, n=1, output is 0.

So, for the third test case, perhaps the last output is 4, but according to my calculation, it should be 1.

I need to clarify this.

Wait, perhaps the problem considers the product of an empty array to be 1, but in the output, it's already considered.

Wait, I'm getting confused.

Let me look back at the first sample.

In the first sample, after all commands, the array is empty, but the output has four numbers, corresponding to the four commands.

Similarly, in the third test case, output has six numbers.

So, for each command, output the product modulo m before removing the element.

Hence, for the third test case, the last output should correspond to the product after removing elements as per the first five commands and before removing the sixth.

Wait, perhaps I miscounted.

Wait, in the third test case:

Commands: R L L L R R

After first 'R': remove last element (6), array: [1,2,3,4,5], product:1*2*3*4*5=120,120 mod 8=0

After 'L': remove first element (1), array: [2,3,4,5], product:2*3*4*5=120,120 mod 8=0

After 'L': remove first element (2), array: [3,4,5], product:3*4*5=60,60 mod 8=4

After 'L': remove first element (3), array: [4,5], product:4*5=20,20 mod 8=4

After 'R': remove last element (5), array: [4], product:4,4 mod 8=4

After 'R': remove last element (4), array: [], product:1,1 mod 8=1

But the sample output is: 0 0 0 4 4 4

So, perhaps the problem doesn't require outputting for the empty array, or there's a different consideration.

Wait, perhaps the problem states to output n integers, but the product is considered only when the array is non-empty.

But in the last step, the array is empty, so perhaps the product is not defined, or it's considered to be 1, but the output is still 4.

I'm confused.

Wait, perhaps the product of the empty array is considered to be 1, and it's included in the output.

But in the first sample, after the last command, the array is empty, but the output has four numbers, corresponding to the four commands.

So, perhaps the product is always computed before removing the element, even if after removal the array is empty.

Hence, in the third sample, the last output should be 4, which corresponds to the product before removing the last element.

Wait, but according to my calculation, before the last 'R', the array is [4], product is 4, 4 mod 8=4.

Then, remove 4, array becomes empty.

Hence, the last output is 4, which matches the sample output.

So, my earlier mistake was considering that after removing the last element, the array is empty, and product is 1, but actually, the product is computed before removing the element.

Hence, the last output is 4, and after that, the array becomes empty.

Got it.

So, the key is to compute the product modulo m before removing the element as per the command.

Hence, for each command:

- Compute the product of the current array modulo m.

- Output that value.

- Then, remove the element from the left or right as per the command.

Now, I need to find an efficient way to compute the product modulo m at each step without recomputing it from scratch.

Given that n can be up to 2*10^5 and t up to 10^4, with total n across all test cases up to 2*10^5, I need an O(n) per test case solution.

One possible approach is to keep track of the current product, and update it as elements are removed.

But, as mentioned earlier, removing an element requires dividing the product by that element, which is problematic in modular arithmetic.

Alternative idea: Since m can be small (up to 10^4), perhaps I can handle the product modulo m by keeping the product and updating it incrementally as elements are removed.

But again, division is tricky.

Wait, perhaps I can keep the product and, when removing an element, multiply by its inverse if it exists, or handle the non-invertible cases separately.

But this seems error-prone.

Another idea: Precompute the prefix and suffix products modulo m, and based on the sequence of 'L's and 'R's, determine which elements are still in the array at each step.

Wait, perhaps I can simulate the process using two pointers, one for the left and one for the right, and keep track of the current product.

Initialize:

- left = 0

- right = n-1

- current product = product of a[left] to a[right]

Then, for each command:

- Output current product modulo m.

- If command is 'L', remove a[left], update the product by dividing by a[left].

- If command is 'R', remove a[right], update the product by dividing by a[right].

But again, division is problematic.

Alternative: Keep track of the product and a list of removed elements, and handle the division by removing the factors of the removed elements.

But this seems too slow and error-prone.

Wait, perhaps I can compute the product of all elements, and then, for each removal, divide by the removed element.

But in modular arithmetic, division is not straightforward.

Wait, perhaps I can compute the product modulo m, and keep track of the exponents of the prime factors.

But m can be up to 10^4, and factorizing m for each test case might be time-consuming.

Alternative idea: Since m is small, precompute the multiplicative inverses for elements that are coprime with m, and handle the non-coprime cases differently.

But this still seems complicated.

Wait, perhaps I can consider that m is small, and compute the product modulo m directly, without worrying about division.

But I still need a way to update the product efficiently when removing elements.

Another idea: Use logarithms to convert multiplication to addition, but in modular arithmetic, this is not straightforward.

Wait, perhaps I can work with the exponents of the prime factors of m.

Factorize m into its prime factors, and for each prime power, keep track of the exponents in the product.

Then, when removing an element, subtract its exponents.

Finally, compute the product using the exponents modulo m.

But this seems too involved for this problem.

I need a simpler approach.

Let me consider that m is small, and n is large.

Perhaps I can precompute the product of all elements, and then, for each removal, divide by the removed element, taking care to handle the division correctly in modular arithmetic.

But I still need a way to perform this division.

Wait, perhaps I can compute the product modulo m, and keep track of the greatest common divisor (gcd) between the removed element and m, to handle the division correctly.

Let me think about that.

Suppose I have the current product p, and I remove an element x.

I need to compute p / x mod m.

If x and m are coprime, I can multiply p by the inverse of x modulo m.

If x and m are not coprime, I need another way.

Let me recall that if x and m are coprime, then x has an inverse modulo m, and p / x ≡ p * x^{-1} mod m.

If x and m are not coprime, but x divides p, then p / x is an integer, and I can compute it directly.

But in modular arithmetic, division is defined only when x and m are coprime.

In other cases, it's not straightforward.

Given that, perhaps I can factorize m into its prime factors, and for each prime power, compute the exponents in p and x, and update them accordingly.

Then, combine the results using the Chinese Remainder Theorem.

But this seems too complex for this problem.

I need a better way.

Let me consider that m is small, and n is large, but n is up to 2*10^5, which is manageable if I can process each step in constant time.

Wait, perhaps I can precompute the exponents of each prime factor of m in the product, and update them as I remove elements.

Then, at each step, compute the product modulo m based on the current exponents.

This might work, but it's complicated.

Let me try to implement this idea step by step.

First, factorize m into its prime factors.

For example, if m=6, its prime factors are 2 and 3.

Then, for each prime, keep track of the exponent in the current product.

For example, in the first sample:

m=6=2*3

Initial array: [3,1,4,2]

Product: 3*1*4*2=24

Exponents:

- 2: 24 has 2^3 (since 8*3=24)

- 3: 24 has 3^1

So, current exponents: exp2=3, exp3=1

When removing an element, say 3, which has 3^1, update the exponents:

exp2 remains 3, exp3 becomes 0.

Then, the product is 2^3 * 3^0 = 8 * 1 = 8, 8 mod 6=2

Next, remove 2, which has 2^1 and 3^0.

So, exp2=2, exp3=0

Product: 2^2 * 3^0 = 4, 4 mod 6=4

Next, remove 4, which has 2^2 and 3^0.

So, exp2=0, exp3=0

Product: 2^0 * 3^0 = 1, 1 mod 6=1

This seems to work.

Hence, a possible approach is:

- Factorize m into its prime factors.

- For each prime factor, keep track of its exponent in the current product.

- For each removal, subtract the exponents of the removed element.

- At each step, compute the product modulo m from the current exponents.

This seems promising.

But factorizing m for each test case might be time-consuming if m is up to 10^4 and t is up to 10^4.

However, m up to 10^4 is manageable for factorization.

Let me think about how to implement this.

First, factorize m into its prime factors.

Store the prime factors and their exponents.

Then, for the initial product, compute the exponents of each prime factor in the product of all elements.

Then, for each removal:

- If the command is 'L', remove a[left], subtract its exponents.

- If the command is 'R', remove a[right], subtract its exponents.

- At each step, compute the product from the current exponents and take modulo m.

But computing the product from exponents could be time-consuming if done naively.

Wait, but m is small, so the exponents are small.

Alternatively, for each prime factor, keep track of its exponent in the current product, and when computing the product modulo m, multiply the prime powers accordingly.

This might work, but it's a bit involved.

Let me consider that m can be factorized into prime powers, and compute the product modulo each prime power, then use the Chinese Remainder Theorem to combine them.

But again, this seems too slow for the time constraints.

I need a simpler approach.

Wait, perhaps I can compute the product modulo m directly, and handle the division by removing the factors of the removed element.

But I'm stuck.

Let me consider that m is small, and precompute the product modulo m, and handle the division by multiplying with inverses when possible.

For elements that are coprime with m, I can multiply by their inverses.

For elements that share a factor with m, I need to handle those cases separately.

This seems manageable.

Let me outline the steps:

- For each test case:

- Factorize m into its prime factors.

- Compute the exponents of each prime in m.

- Compute the exponents of each prime in the product of all elements.

- For each command:

- Output the current product modulo m.

- Remove the element as per the command.

- Update the exponents of each prime accordingly.

- Compute the new product modulo m based on the exponents.

But this still seems too slow, especially with factorizing m for each test case.

Wait, but m can be up to 10^4, and n up to 2*10^5, with t up to 10^4, but total n across all test cases is up to 2*10^5.

I need an O(n) per test case solution, possibly with O(m) precomputation.

Alternative idea: Since m is small, precompute the inverses for all elements that are coprime with m.

For elements that are not coprime with m, handle them differently.

But this still seems complicated.

Wait, perhaps I can compute the product modulo m, and keep track of the product divided by the removed element, handling the non-invertible cases separately.

But I'm going in circles.

Let me consider that m is small, and precompute the product modulo m, and handle the division by removing the factors of the removed element.

But I need a better way.

Let me think differently.

Suppose I compute the product of all elements, and then, for each removal, divide by the removed element, taking modulo m.

But again, division is problematic.

Wait, perhaps I can compute the product modulo m, and keep track of the product divided by the removed element, but only when the element is invertible.

For non-invertible elements, I need to handle them differently.

Wait, perhaps I can separate the product into parts that are invertible and non-invertible.

But this seems too involved.

Let me consider that m is small, and precompute the product modulo m, and handle the division by multiplying with the inverse when possible.

For elements that are not invertible, perhaps I can keep track of their exponents separately.

This might work, but it's getting too complicated.

I need a better approach.

Let me consider that m is small, and precompute the product modulo m, and handle the division by removing the factors of the removed element.

But I'm stuck.

Wait, perhaps I can consider that m is small, and compute the product modulo m directly, without worrying about division.

But I still need a way to update the product when removing elements.

Another idea: Since m is small, and n is large, perhaps I can compute the product modulo m by considering only the exponents of the prime factors of m in the product.

Then, when removing an element, subtract its exponents.

Finally, compute the product modulo m from the exponents.

This seems similar to my earlier idea.

Let me try to implement this.

First, factorize m into its prime factors.

For example, m=6=2*3

Then, for each element in the array, factorize it into its prime factors and compute the exponents.

For example, array=[3,1,4,2]

Exponents:

- 3: {3:1}

- 1: {}

- 4: {2:2}

- 2: {2:1}

Initial exponents:

- 2: 2+1=3

- 3:1

So, product is 2^3 * 3^1 =8*3=24, 24 mod 6=0

Then, remove 'L': 3, exponents: {3:1}

Update exponents:

- 2:3

- 3:0

Product: 2^3 * 3^0 =8*1=8, 8 mod 6=2

Next, remove 'R':2, exponents: {2:1}

Update exponents:

- 2:3-1=2

- 3:0

Product:2^2 *3^0=4*1=4, 4 mod 6=4

Next, remove 'R':4, exponents: {2:2}

Update exponents:

- 2:2-2=0

- 3:0

Product:2^0 *3^0=1*1=1,1 mod 6=1

This seems to work.

Hence, a possible approach is:

- Factorize m into its prime factors.

- For each element in the array, compute the exponents of these prime factors.

- Keep a running total of the exponents for each prime.

- For each command:

- Output the current product modulo m.

- Remove the element as per the command, and subtract its exponents from the total exponents.

This seems efficient, as m is small, and factorizing m and the array elements is manageable.

Let me think about how to implement this.

First, factorize m into its prime factors.

Store the prime factors and their exponents.

Then, for each element in the array, compute the exponents of these prime factors in the element.

Keep a running total of the exponents for each prime in the current product.

Then, for each command:

- Output the current product modulo m.

- Remove the element as per the command, and subtract its exponents from the total exponents.

- Update the current product accordingly.

But I need a way to compute the product from the exponents efficiently.

Since m is small, I can precompute the powers of each prime factor up to their exponent in m.

Wait, but m can have multiple prime factors, and I need to compute the product of their powers.

This seems feasible.

Let me try to write some pseudocode.

Factorize m into prime factors: p1^e1 * p2^e2 * ... * pk^ek

Compute the exponents of each pi in the product of all elements.

Then, for each removal:

- If removing 'L', subtract the exponents of a[left].

- If removing 'R', subtract the exponents of a[right].

- Compute the product as p1^(c1) * p2^(c2) * ... * pk^(ck), where c_i is the current exponent for pi.

- Take this product modulo m.

This should work, but I need to ensure that the exponents don't go negative, and handle the case when some exponents are zero.

Also, I need to compute the product modulo m efficiently.

Let me think about how to compute the product from the exponents.

I can precompute the power of each prime factor up to their exponent in m.

Then, multiply them together, taking modulo m.

But m is small, so this should be fast.

Let me consider an example.

m=6=2*3

Exponents for 2 and 3.

Initial product:24=2^3 *3^1

Current exponents: exp2=3, exp3=1

Compute product: (2^3 %6) * (3^1 %6) =8%6=2 * 3=6%6=0

Which matches 24 mod 6=0

Next, remove 'L':3, which has exp3=1

Update exponents: exp2=3, exp3=0

Compute product: (2^3 %6) * (3^0 %6)=8%6=2 *1=2%6=2

Which matches the expected output.

Next, remove 'R':2, which has exp2=1

Update exponents: exp2=3-1=2, exp3=0

Compute product: (2^2 %6)=4 * (3^0 %6)=1 =>4%6=4

Next, remove 'R':4, which has exp2=2

Update exponents: exp2=2-2=0, exp3=0

Compute product: (2^0 %6)=1 * (3^0 %6)=1 =>1%6=1

This works.

Hence, this approach seems correct.

Now, I need to implement this efficiently.

First, factorize m into its prime factors.

Then, for each element in the array, compute the exponents of these prime factors in the element.

Keep a running total of the exponents for each prime in the current product.

Then, for each command:

- Output the current product modulo m.

- Remove the element as per the command, and subtract its exponents from the total exponents.

- Update the current product accordingly.

I need to handle this efficiently, especially since n can be up to 2*10^5.

To optimize, I can precompute the exponents of the prime factors for all elements in the array.

Then, use two pointers to keep track of the current subarray, and maintain the exponents accordingly.

Wait, but the removals are from either end based on 'L' and 'R', so it's not a standard sliding window.

I need to simulate the process.

Let me think about using a queue or deque to handle the removals from either end.

But since I need to remove from the left or right based on 'L' or 'R', a deque seems appropriate.

I can store the exponents of each element in the deque.

Then, for each command:

- Output the current product modulo m.

- Remove an element from the left or right, and subtract its exponents from the total.

This seems efficient.

Let me try to implement this.

First, factorize m into its prime factors.

Store the prime factors in a list, say primes.

Then, for each element in the array, compute a dictionary or list of exponents for these primes.

Store these exponents in a deque.

Initialize the total exponents by summing up the exponents of all elements.

Then, for each command:

- Output the current product modulo m.

- Remove an element from the left or right of the deque, and subtract its exponents from the total exponents.

- Update the current product based on the total exponents.

This should work.

Now, I need to compute the product from the exponents modulo m.

I can precompute the power of each prime raised to its exponent, modulo m, and multiply them together, taking modulo m.

Since m is small, this is efficient.

Let me write some code to test this.

First, a function to factorize m into its prime factors.

I can write a function to factorize m.

Then, for each element in the array, compute the exponents of these prime factors.

Then, keep a running total of these exponents.

For each command, output the product from the current exponents modulo m, then remove the exponents of the element being removed.

This seems manageable.

Let me think about edge cases.

Edge Cases:

1. m=1: Any product modulo 1 is 0.

2. m is prime: Simplifies the factorization.

3. m is a prime power: Only one prime factor.

4. Elements that are 1: Don't change the product.

5. Elements that are 0: Make the product 0.

Wait, according to the problem, elements are at least 1, so no zeros.

But if m divides any element, then the product will be 0 modulo m.

Wait, m can divide some elements, making their exponents in m's prime factors exceed those in m.

I need to handle that.

Specifically, if an element has a prime factor of m with an exponent greater than or equal to m's exponent for that prime, then the product will be divisible by m, hence product modulo m is 0.

Similarly, if any element is divisible by m, then the product will be 0 modulo m.

Wait, but in the problem, m can be up to 10^4, and elements up to 10^4, so m can divide elements.

Hence, in such cases, the product will be 0 modulo m.

I need to handle this correctly.

In the approach above, when computing the exponents, if for any prime factor, the total exponent is greater than or equal to m's exponent for that prime, then the product is 0 modulo m.

Hence, I can set a flag indicating whether the product is 0 modulo m.

But actually, in the earlier example, even if exponents exceed m's exponents, the product is computed correctly.

For example, m=6=2^1 * 3^1

If the exponents in the product are exp2=3, exp3=1, then the product is 2^3 * 3^1 =8*3=24, which is 0 modulo 6.

Similarly, if exp2=2, exp3=1, product is 4*3=12, which is 0 modulo 6.

Only when exp2 <1 or exp3 <1, the product is not divisible by m.

Wait, in the first sample, exp2=3, exp3=1, which are both greater than or equal to m's exponents (1 for both), so product is 0 modulo m.

Similarly, after removing 'L', exp2=3, exp3=0, since exp3 <1, product is 2^3=8, which is 2 modulo 6.

Similarly, after removing 'R', exp2=2, exp3=0, product is 4 modulo 6=4.

After removing 'R', exp2=0, exp3=0, product is 1 modulo 6=1.

Hence, I can see that when all exponents are at least m's exponents, the product is 0 modulo m.

Otherwise, compute the product from the exponents.

Hence, in implementation, for each step, check if any prime factor's exponent in the product is less than m's exponent for that prime.

If for all prime factors, the exponent in the product is at least m's exponent, then product is 0 modulo m.

Otherwise, compute the product from the exponents.

Wait, no.

Actually, for each prime factor, the exponent in the product modulo m is min(exponent in product, m's exponent).

Hence, in computation, for each prime factor, use exponent = min(exponent in product, m's exponent).

Then, multiply them together modulo m.

Wait, but in the first sample, exp2=3, exp3=1, m=6=2^1 * 3^1

So, product modulo m is (2^min(3,1)) * (3^min(1,1)) =2^1 *3^1=6, which is 0 modulo 6.

Similarly, after removing 'L', exp2=3, exp3=0

Product: 2^min(3,1) *3^min(0,1)=2^1 *3^0=2*1=2 modulo 6=2

Which matches the sample.

Similarly, after removing 'R', exp2=2, exp3=0

Product:2^min(2,1)*3^min(0,1)=2^1 *3^0=2*1=2 modulo 6=2

Wait, but in the earlier calculation, it was 4.

Wait, perhaps I'm misunderstanding.

Wait, no, min(2,1)=1, so 2^1 *3^0=2*1=2 modulo 6=2

But earlier, I calculated it as 4.

Wait, perhaps I made a mistake in the earlier calculation.

Wait, in the earlier manual calculation, for exp2=2, exp3=0, product should be 2^2=4, but according to this, it's 2^1=2.

Wait, perhaps my approach is incorrect.

Wait, no, according to the approach, when computing the product modulo m, for each prime factor, use min(exponent in product, m's exponent