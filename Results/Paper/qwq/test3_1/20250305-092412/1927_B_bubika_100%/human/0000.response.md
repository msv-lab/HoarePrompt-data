Alright, I have this problem to solve. Let's see what it's asking for. So, Polycarp lost a string, but he has its "trace." The trace is an array of integers that correspond to the original string's positions. Specifically, for each position i in the string, a_i is the number of earlier positions j (where j < i) that have the same character as position i.

For example, in the string "abracadabra," the trace is [0,0,0,1,0,2,0,3,1,1,4]. This makes sense because:

- The first 'a' has no previous 'a's, so 0.

- The first 'b' has no previous 'b's, so 0.

- The first 'r' has no previous 'r's, so 0.

- The second 'a' has one previous 'a', so 1.

- And so on.

Given this trace, I need to reconstruct any string that could have produced this trace. The problem guarantees that a valid string exists for the given trace.

First, I need to understand the input and output formats. The input consists of multiple test cases. Each test case starts with an integer n, the length of the string, followed by a list of n integers representing the trace.

My task is to output a string for each test case that corresponds to the given trace.

Constraints:

- Number of test cases t is up to 10^4.

- Length of the string n can be up to 2*10^5.

- Sum of n over all test cases doesn't exceed 2*10^5.

Given these constraints, efficiency is important, especially since t can be up to 10^4, but the total sum of n is manageable at 2*10^5.

Now, thinking about how to approach this.

I need to map each position in the string to a character based on the trace values. The trace values indicate how many times a particular character has appeared before the current position.

One way to think about this is to keep track of the frequency of each character up to each position.

I need to assign characters to positions such that for each position i, the number of earlier positions with the same character is equal to a_i.

Since there are 26 lowercase letters, I can maintain a frequency array for each letter, tracking how many times it has been used so far.

For each position in the string, I need to find a character that has been used exactly a_i times before.

This seems feasible.

Let me try to outline an algorithm:

1. Read the number of test cases t.

2. For each test case:

a. Read n, the length of the string.

b. Read the list of integers a (the trace).

c. Initialize a frequency array for 26 letters, all set to 0.

d. Initialize an empty string r to build the result.

e. For each a_i in the trace:

i. Find the first letter whose current frequency matches a_i.

ii. Append that letter to r.

iii. Increment the frequency of that letter.

f. Print the resulting string r.

This seems straightforward. Let's see if this works with the example provided.

Take the first example:

n = 11

a = [0,0,0,1,0,2,0,3,1,1,4]

Initialize frequency array: [0,0,0,...] for 26 letters.

Process each a_i:

- a_1 = 0: Find the first letter with frequency 0, which is 'a'. Set r = 'a', increment freq['a'] to 1.

- a_2 = 0: Find the next letter with frequency 0, which is 'b'. r = 'ab', freq['b'] = 1.

- a_3 = 0: Next letter with freq 0 is 'r'. r = 'abr', freq['r'] = 1.

- a_4 = 1: Find a letter with freq 1, which is 'a'. r = 'abra', freq['a'] = 2.

- a_5 = 0: Next letter with freq 0 is 'c'. r = 'abrac', freq['c'] = 1.

- a_6 = 2: Find a letter with freq 2, which is 'a'. r = 'abracad', freq['a'] = 3.

- a_7 = 0: Next letter with freq 0 is 'd'. r = 'abracad', freq['d'] = 1.

- a_8 = 3: Find a letter with freq 3, which is 'a'. r = 'abracadabra', freq['a'] = 4.

- a_9 = 1: Find a letter with freq 1, which is 'c'. r = 'abracadabrac', but wait, the original string is "abracadabra", so it should be 'abracadabral'... Hmm, maybe I need to choose 'b' or another letter. Wait, no, in the original trace, a_9 = 1, and 'd' has freq 1, but in the original string, it's 'a' with freq 4, 'b' with freq 2, 'r' with freq 2, 'c' with freq 1, etc. So, choosing 'd' is valid.

Wait, but in the original string, it's 'abracadabra', so position 9 is 'a', which has freq 4, but a_9 = 1, which doesn't match. Wait, maybe I'm misunderstanding the trace.

Wait, no, in the trace [0,0,0,1,0,2,0,3,1,1,4], position 9 is a_9 = 1, which corresponds to the 9th character in "abracadabra", which is 'a', but 'a' has appeared 4 times before position 9. This seems inconsistent.

Wait, maybe I miscounted the positions. Let's look at the positions:

0. a (0)

1. b (0)

2. r (0)

3. a (1)

4. c (0)

5. a (2)

6. d (0)

7. a (3)

8. b (1)

9. r (1)

10. a (4)

Wait, in position 8 (0-based index 8), a_8 = 1, which corresponds to 'b', which has appeared once before at position 1.

So, in my algorithm, when a_i = 1, I need to find a letter that has been used once before.

In my earlier steps, I had freq['a'] = 4, freq['b'] = 2, freq['r'] = 2, freq['c'] = 1, freq['d'] = 1.

At position 8, a_8 = 1, so I can choose either 'c' or 'd' or 'b' (since 'b' has freq 2, which is greater than 1). Wait, no, 'b' has freq 2, which is greater than 1, but I need exactly 1.

Wait, perhaps I need to ensure that I choose the letter that has exactly a_i occurrences before.

In this case, 'c' has freq 1, 'd' has freq 1, and 'b' has freq 2.

So, I can choose 'c' or 'd', but in the original string, it's 'b', which has freq 2, which doesn't match a_i = 1.

Wait, maybe I'm misunderstanding the trace.

Wait, perhaps the trace represents the number of times the same character has appeared before, including case.

Wait, in "abracadabra", position 8 is 'a', which has appeared 4 times before, but a_8 = 1, which doesn't match.

Wait, perhaps I misread the positions.

Wait, in the problem statement, it says "the trace of the string s is an array a of n integers, where a_i is the number of such indices j (j < i ) that s_i = s_j."

So, for each position i (starting from 1), a_i is the count of previous positions where the character is the same as s_i.

In "abracadabra":

- Position 1: 'a', no previous 'a', so a_1 = 0

- Position 2: 'b', no previous 'b', so a_2 = 0

- Position 3: 'r', no previous 'r', so a_3 = 0

- Position 4: 'a', one previous 'a', so a_4 = 1

- Position 5: 'c', no previous 'c', so a_5 = 0

- Position 6: 'a', two previous 'a's, so a_6 = 2

- Position 7: 'd', no previous 'd', so a_7 = 0

- Position 8: 'a', three previous 'a's, so a_8 = 3

- Position 9: 'b', one previous 'b', so a_9 = 1

- Position 10: 'r', one previous 'r', so a_10 = 1

- Position 11: 'a', four previous 'a's, so a_11 = 4

But in the example trace provided: [0,0,0,1,0,2,0,3,1,1,4], which matches the above counts.

But in my earlier steps, when reconstructing, I had some confusion about choosing the correct letter for a given a_i.

Perhaps I need a better way to track which letters have been used how many times.

Let me think differently.

I can iterate through the positions, and for each a_i, find a letter that has been used exactly a_i times so far.

To do this efficiently, I can maintain a list of frequencies for each letter.

Since there are only 26 letters, I can have a list of size 26, each element representing the frequency of that letter.

For each position, I look for the first letter whose frequency matches a_i, append that letter to the result, and increment its frequency.

This should work efficiently since n can be up to 2e5, and t up to 1e4, but the total sum of n is 2e5, so it's manageable.

Let me try this approach with the first example.

Initialize frequency array: [0,0,0,...] for 'a' to 'z'.

Positions:

1. a_i = 0: Find the first letter with freq 0, which is 'a'. Set r = 'a', freq['a'] = 1.

2. a_i = 0: Next letter with freq 0 is 'b'. r = 'ab', freq['b'] = 1.

3. a_i = 0: Next letter with freq 0 is 'r'. r = 'abr', freq['r'] = 1.

4. a_i = 1: Find a letter with freq 1, which is 'a'. r = 'abra', freq['a'] = 2.

5. a_i = 0: Next letter with freq 0 is 'c'. r = 'abrac', freq['c'] = 1.

6. a_i = 2: Find a letter with freq 2, which is 'a'. r = 'abracad', freq['a'] = 3.

7. a_i = 0: Next letter with freq 0 is 'd'. r = 'abracad', freq['d'] = 1.

8. a_i = 3: Find a letter with freq 3, which is 'a'. r = 'abracadabra', freq['a'] = 4.

9. a_i = 1: Find a letter with freq 1, which is 'b' or 'c' or 'd'. Let's choose 'b'. r = 'abracadab', freq['b'] = 2.

10. a_i = 1: Find a letter with freq 1, which is 'c' or 'd'. Let's choose 'r'. Wait, 'r' has freq 1. r = 'abracadabrar', freq['r'] = 2.

11. a_i = 4: Find a letter with freq 4, which is 'a'. r = 'abracadabrar', freq['a'] = 5.

Wait, but in the original string, it's 'abracadabra', which ends with 'a'.

But in my reconstruction, I have 'abracadabrar', which is different.

Wait, perhaps the choice of letters matters.

In the trace, a_i represents the number of previous occurrences of the same letter.

So, for position 9, a_i = 1: there should be one previous 'b', which is at position 2.

Similarly, for position 10, a_i = 1: there should be one previous 'r', which is at position 3.

For position 11, a_i = 4: there should be four previous 'a's, which are at positions 1,4,6,8.

So, in my reconstruction, I need to ensure that for each position, the chosen letter has exactly a_i previous occurrences.

In my earlier steps, I chose 'b' for position 9 (a_i=1), which is correct.

For position 10 (a_i=1), I chose 'r' (which has freq 1), which is correct.

For position 11 (a_i=4), I chose 'a' (which has freq 4), which is correct.

So, 'abracadabrar' is also a valid string for the given trace.

But in the sample output, it's 'abracadabra'.

So, multiple strings can correspond to the same trace, as long as the frequency conditions are met.

Therefore, my approach seems valid.

Let me check another sample input.

Second test case:

n = 10

a = [0,0,0,0,0,1,0,1,1,0]

One possible string is 'codeforces'.

Let's verify:

- c: 0

- o: 0

- d: 0

- e: 0

- f: 0

- o: 1 (one previous 'o')

- r: 0

- c: 1 (one previous 'c')

- e: 1 (one previous 'e')

- s: 0

This matches the trace [0,0,0,0,0,1,0,1,1,0].

In my algorithm, I would choose letters with the required frequencies step by step.

Third test case:

n = 1

a = [0]

Only one character, which has no previous occurrences. So, any letter, say 'a'.

Fourth test case:

n = 8

a = [0,1,2,3,4,5,6,7]

This means:

- First character: 0 previous same characters

- Second character: 1 previous same character

- ...

- Eighth character: 7 previous same characters

So, all characters are the same, since each one has one more previous occurrence than the last.

Thus, the string would be 'aaaaaaaa'.

Fifth test case:

n = 8

a = [0,0,0,0,0,0,0,0]

Each character has no previous occurrences, so all characters are distinct.

A possible string is 'dijkstra', but any permutation of 8 distinct letters would work.

Now, looking at the provided program:

def func():

a = 'abcdefghijklmnopqrstuvwxyz'

for t in range(int(input())):

b = [0] * 26

n = int(input())

s = list(map(int, input().split()))

r = ''

for i in s:

x = b.index(i)

r += a[x]

b[x] += 1

print(r)

This seems to implement the approach I outlined.

It initializes a frequency list b for 26 letters, all set to 0.

For each test case:

- Read n and the trace s.

- Initialize an empty string r.

- For each a_i in s:

- Find the index x of the first letter in b that has frequency a_i.

- Append the corresponding letter from 'a' to r.

- Increment the frequency of that letter by 1.

- Print the resulting string r.

This should work correctly, as demonstrated in the examples.

Therefore, the program is correct.

## Final Solution
To solve this problem, we need to reconstruct the original string from its trace. The trace is an array where each element `a_i` indicates the number of previous occurrences of the character at position `i` in the string.

### Approach

1. **Initialization**:
   - We maintain a frequency array `b` of size 26, each element corresponding to a lowercase letter from 'a' to 'z', initialized to 0.

2. **Reconstructing the String**:
   - For each position `i` in the string, we find the first letter whose current frequency matches `a_i`.
   - We append this letter to the result string and increment its frequency.

3. **Efficiency**:
   - Since there are only 26 possible letters, finding the first letter with the required frequency is efficient.
   - This approach ensures that we can handle the input constraints efficiently.

### Solution Code

```python
def func():
    a = 'abcdefghijklmnopqrstuvwxyz'
    for t in range(int(input())):
        b = [0] * 26
        n = int(input())
        s = list(map(int, input().split()))
        r = ''
        for i in s:
            x = b.index(i)
            r += a[x]
            b[x] += 1
        print(r)

func()
```

### Explanation

1. **Reading Input**:
   - We read the number of test cases `t`.
   - For each test case, we read the length of the string `n` and the trace array `s`.

2. **Frequency Array**:
   - We use a list `b` of size 26 to keep track of the frequency of each letter from 'a' to 'z'.

3. **Building the String**:
   - For each element `a_i` in the trace array `s`, we find the first letter whose current frequency matches `a_i`.
   - We append this letter to the result string `r` and increment its frequency in `b`.

4. **Output**:
   - We print the reconstructed string `r` for each test case.

This method ensures that the reconstructed string matches the given trace, adhering to the frequency conditions specified by the trace array.