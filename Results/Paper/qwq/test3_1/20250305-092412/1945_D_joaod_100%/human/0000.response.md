Alright, I've got this problem to solve. Let's see what it's asking for.

So, there's this queue of n people, and Kirill comes in and stands at the end, making it n+1 people in line. But Kirill doesn't want to wait too long, he wants to be among the first m people in the queue. To do that, he can bribe people ahead of him to swap places.

Each person in the queue has two values associated with them: a_i and b_i.

- a_i is the cost for Kirill to bribe person i to swap places with him.

- b_i is the cost for Kirill to bribe person i to just let him pass through them, meaning Kirill moves forward without swapping, but instead just inserting himself ahead of person i.

Wait, actually, reading the problem again, it seems that the operation is not about passing through but swapping with person j and paying a_j, and additionally paying b_k for all k between j and i.

Let me understand the operation clearly:

- Kirill is at position i.

- He can choose any j < i and swap places with person j.

- When he does this, he pays a_j to person j.

- Additionally, for every person k between j and i (j < k < i), he pays b_k to each of them.

- He can do this operation any number of times.

His goal is to end up at a position <= m with the minimum total cost.

First, I need to model this operation in a way that I can compute the minimal cost.

Let's think about what this operation allows Kirill to do.

Each operation allows him to swap with someone ahead of him, but it costs him a_j to swap with j, plus b_k for each position he "jumps over".

So, it's like moving from position i to position j, paying a_j plus sum of b_k from k=j+1 to i-1.

Wait, positions are from 1 to n+1, since Kirill is at position n+1 initially.

But in the code, it seems like the queue is indexed from 0 to n-1, and Kirill starts at position n.

Wait, no, in the code, it's a bit confusing.

Let me look at the code provided.

The function reads t, the number of test cases, then for each test case, it reads n and m, then two lists a and b of length n.

Then, it sets na_frente = n - 1 and pos_final = m - 1.

Wait, no, in the code:

na_frente = n - 1

pos_final = m - 1

But in the comments, it says na_frente -=1 and pos_final -=1, but in the code, it's na_frente -=1 and pos_final -=1, making them n-1 and m-1 respectively.

Then, it initializes total = 0 and best = sys.float_info.max

Then, it loops from v = na_frente down to 0:

if v <= pos_final:

if best > total + a[v]:

best = total + a[v]

if a[v] < b[v]:

total += a[v]

else:

total += b[v]

else:

if a[v] < b[v]:

total += a[v]

else:

total += b[v]

Finally, it prints best.

Wait, but in the code, it's na_frente -=1 and pos_final -=1, making na_frente = n-2 and pos_final = m-2.

Wait, no, in the code, it's:

na_frente -=1

pos_final -=1

So, na_frente becomes n-1 -1 = n-2

pos_final becomes m-1 -1 = m-2

But this seems off.

Wait, perhaps the indexing is off.

Let me double-check.

The problem says:

- Queue starts with person 1 to n, Kirill is at position n+1.

- Positions are 1-indexed.

In the code, a and b are 0-indexed lists of length n.

So, position 1 corresponds to index 0 in a and b, position 2 corresponds to index 1, and so on, up to position n at index n-1.

Kirill starts at position n+1, which is index n in the list.

But in the code, na_frente is set to n-1, which is position n, and pos_final is set to m-1, which is position m.

Wait, but in the code, it's na_frente -=1, making it n-2, which seems incorrect.

Wait, perhaps the author made a mistake with indexing.

Let me try to understand.

Maybe it's better to think of positions from 0 to n, with Kirill starting at position n.

Then, na_frente would be n-1, which is position n-1.

Wait, but in the code, na_frente is set to n-1, then na_frente -=1, making it n-2.

This seems inconsistent.

Maybe I should ignore the code for now and try to solve the problem myself.

Let's model the queue as positions 0 to n, with Kirill starting at position n.

He wants to reach a position <= m-1.

He can perform operations where he chooses j < i, swaps with j, paying a_j, and paying b_k for all k between j and i.

Wait, more precisely, from the problem:

- He is at position i.

- He chooses j < i.

- He swaps with j, paying a_j.

- For each k such that j < k < i, he pays b_k.

- He can do this any number of times.

His goal is to be at a position <= m-1 with minimal total cost.

First, I need to find a sequence of operations that moves Kirill from position n to some position <= m-1, minimizing the total cost.

Let me think about what's the best way to model this.

Maybe I can model this as a graph where each position is a node, and there are edges from position i to position j < i with cost a_j + sum of b_k for k from j+1 to i-1.

Then, the problem reduces to finding the minimum cost path from position n to some position <= m-1.

But with n up to 2e5, building a graph explicitly is not feasible.

I need a better way to compute this efficiently.

Perhaps I can use dynamic programming.

Let dp[i] be the minimal cost to reach position i from position n.

Then, dp[i] = min over j > i of dp[j] + a_i + sum of b_k from k=i+1 to j-1.

But this still seems too slow because n is large.

I need a smarter way to compute this.

Wait, maybe I can think of this as Kirill moving left in the queue by swapping with people ahead of him.

Each swap with person j < i costs a_j plus the sum of b_k for k from j to i-1.

Wait, actually, the problem says j < i, and pays a_j and for each k such that j < k < i, pays b_k.

So, the cost to swap from i to j is a_j + sum_{k=j+1}^{i-1} b_k.

I need to minimize the total cost to reach any position <= m-1.

I need an efficient way to compute this.

Let me try to find a pattern or a way to compute dp[i] efficiently.

Let's consider dp[i] as the minimal cost to reach position i from position n.

Then, dp[i] = min over j > i of dp[j] + a_i + sum_{k=i+1}^{j-1} b_k.

Wait, no, dp[i] should be dp[j] + a_j + sum_{k=j+1}^{i-1} b_k.

Wait, I'm getting confused.

Let me define dp[i] as the minimal cost to reach position i from position n.

Then, to reach position i, Kirill can come from any position j where j > i.

The cost to move from j to i is a_i (to swap with i) plus sum_{k=i+1}^{j-1} b_k (to pay the people between i and j).

Wait, no, more carefully:

- Kirill is at position j.

- He chooses to swap with position i, where i < j.

- He pays a_i to person i.

- He pays b_k for each k from i+1 to j-1.

So, the cost to move from j to i is a_i + sum_{k=i+1}^{j-1} b_k.

Hence, dp[i] = min over j > i of dp[j] + a_i + sum_{k=i+1}^{j-1} b_k.

This seems correct.

But computing this directly is too slow for large n.

I need a way to optimize this.

Let me see if I can find a way to compute dp[i] without iterating over all j > i.

Maybe I can rearrange the terms.

dp[i] = a_i + min over j > i of dp[j] + sum_{k=i+1}^{j-1} b_k.

Note that sum_{k=i+1}^{j-1} b_k = prefix_sum_b[j-1] - prefix_sum_b[i]

Assuming prefix_sum_b[i] is the sum of b[0] to b[i].

Wait, I need to define prefix sums appropriately.

Let me define prefix_sum_b[i] as the sum of b[0] to b[i-1].

Then, sum_{k=i+1}^{j-1} b_k = prefix_sum_b[j-1] - prefix_sum_b[i]

So, dp[i] = a_i + min over j > i of dp[j] + prefix_sum_b[j-1] - prefix_sum_b[i]

This can be written as:

dp[i] = a_i - prefix_sum_b[i] + min over j > i of (dp[j] + prefix_sum_b[j-1])

Let me denote temp[j] = dp[j] + prefix_sum_b[j-1]

Then, dp[i] = a_i - prefix_sum_b[i] + min_temp[j for j > i]

So, I can precompute min_temp[j] for j > i.

Wait, but min_temp[j] for j > i would require looking ahead.

This seems tricky.

Maybe I can compute dp[i] iteratively, starting from i = n-1 down to 0.

Let me try that.

Initialize dp[n] = 0, since Kirill starts at position n.

Then, for i from n-1 down to 0:

dp[i] = a_i + min over j > i of dp[j] + sum_{k=i+1}^{j-1} b_k

Wait, sum_{k=i+1}^{j-1} b_k = prefix_sum_b[j-1] - prefix_sum_b[i]

So, dp[i] = a_i + min over j > i of dp[j] + prefix_sum_b[j-1] - prefix_sum_b[i]

Let me rearrange:

dp[i] = a_i - prefix_sum_b[i] + min over j > i of (dp[j] + prefix_sum_b[j-1])

So, if I keep track of the minimum of (dp[j] + prefix_sum_b[j-1]) for j > i, I can compute dp[i].

I can maintain this minimum as I iterate from higher i to lower i.

Let me try to implement this logic.

First, compute prefix_sum_b.

prefix_sum_b[0] = 0

prefix_sum_b[1] = b[0]

prefix_sum_b[2] = b[0] + b[1]

...

prefix_sum_b[n] = sum of b[0] to b[n-1]

Then, initialize dp[n] = 0

Initialize min_temp = dp[n] + prefix_sum_b[n-1] if n > 0 else 0

Then, for i from n-1 down to 0:

dp[i] = a_i - prefix_sum_b[i] + min_temp

Then, update min_temp = min(min_temp, dp[i] + prefix_sum_b[i-1])

Wait, let's verify this.

At each step, min_temp is the minimum of (dp[j] + prefix_sum_b[j-1]) for j > i.

When I move from i to i-1, j > i includes j > i-1 as well.

So, min_temp should be the minimum of current min_temp and dp[i] + prefix_sum_b[i-1]

Yes, that makes sense.

Let me test this logic with the first sample input.

Sample Input 1:

4

4 2

7 3 6 9

4 3 8 5

So, n=4, m=2

a = [7,3,6,9]

b = [4,3,8,5]

Compute prefix_sum_b:

prefix_sum_b[0] = 0

prefix_sum_b[1] = 4

prefix_sum_b[2] = 4+3=7

prefix_sum_b[3] = 4+3+8=11

prefix_sum_b[4] = 4+3+8+5=20

Initialize dp[4] = 0

min_temp = dp[4] + prefix_sum_b[3] = 0 + 11 = 11

Now, for i=3 (positions start from 0):

dp[3] = a[3] - prefix_sum_b[3] + min_temp = 9 - 11 + 11 = 9

Then, update min_temp = min(min_temp, dp[3] + prefix_sum_b[2]) = min(11, 9 + 7) = min(11,16) = 11

Next, i=2:

dp[2] = a[2] - prefix_sum_b[2] + min_temp = 6 -7 +11 =10

Update min_temp = min(11, 10 + prefix_sum_b[1]) = min(11,10+4)=min(11,14)=11

Next, i=1:

dp[1] = a[1] - prefix_sum_b[1] + min_temp = 3 -4 +11 =10

Update min_temp = min(11,10 + prefix_sum_b[0])=min(11,10+0)=10

Next, i=0:

dp[0] = a[0] - prefix_sum_b[0] + min_temp =7 -0 +10 =17

Now, Kirill wants to be at position <= m-1 =1, which are positions 0 and 1.

So, the minimal dp[i] for i from 0 to 1 is min(dp[0], dp[1]) = min(17,10)=10

But in the sample output, it's 14.

Wait, that's not matching.

Hmm, perhaps I made a mistake in the calculation.

Let me double-check.

Wait, perhaps I misindexed the arrays.

In Python, lists are 0-indexed.

In the problem, positions are 1-indexed.

In the sample input, n=4, m=2, a=[7,3,6,9], b=[4,3,8,5]

positions:

position 1: a[0]=7, b[0]=4

position 2: a[1]=3, b[1]=3

position 3: a[2]=6, b[2]=8

position 4: a[3]=9, b[3]=5

Kirill starts at position 5.

He wants to be at position <=2.

So, positions 1 and 2.

I need to compute dp[0] and dp[1], and take the minimum.

In my earlier calculation, I got dp[0]=17 and dp[1]=10, minimum is 10, but sample output is 14.

So, perhaps my logic is incorrect.

Let me try to simulate the operations.

Option 1:

Kirill starts at position 5.

Swap with position 4, paying a_4=9, and paying b_5 to b_4, but b is only defined up to 4.

Wait, positions are 1 to 5.

b_k is for k between j and i.

Wait, in the problem, b_k is for j < k < i.

So, swapping from 5 to 4: pay a_4=9, and since k=4 < i=5, pay b_4=5.

Total cost: 9 + 5 =14.

Then, swap from 4 to 3: pay a_3=6, pay b_3=8.

Total cost: 14 +6 +8=28.

This is worse than 14.

Option 2:

Swap from 5 to 3: pay a_3=6, pay b_4=5.

Total cost:6+5=11.

Then, swap from 3 to 2: pay a_2=3, pay b_3=8.

Total cost:11 +3 +8=22.

Worse than 14.

Option 3:

Swap from 5 to 2: pay a_2=3, pay b_3 and b_4:8 +5=13.

Total cost:3 +13=16.

Worse than 14.

Option 4:

Swap from 5 to 1: pay a_1=7, pay b_2, b_3, b_4:3 +8 +5=16.

Total cost:7 +16=23.

Worse than 14.

Option 5:

Swap from 5 to 4: pay a_4=9, pay b_4=5. Total 14.

Swap from 4 to 2: pay a_2=3, pay b_3=8.

Total additional 3 +8=11.

Total 14 +11=25.

Worse than 14.

Option 6:

Swap from 5 to 4: pay 9 +5=14.

Swap from 4 to 1: pay a_1=7, pay b_2, b_3:3 +8=11.

Total additional 7 +11=18.

Total 14 +18=32.

Worse.

Seems like the minimal is 14.

But according to my earlier dp calculation, dp[1]=10, which is less than 14.

But according to the simulation, 14 is the minimal possible.

So, perhaps my dp calculation is incorrect.

Let me check the dp calculation again.

prefix_sum_b:

prefix_sum_b[0] =0

prefix_sum_b[1] =4

prefix_sum_b[2] =4+3=7

prefix_sum_b[3] =4+3+8=11

prefix_sum_b[4] =4+3+8+5=20

dp[4]=0

min_temp = dp[4] + prefix_sum_b[3] =0 +11=11

dp[3]=a[3]-prefix_sum_b[3]+min_temp=9-11+11=9

min_temp = min(11, dp[3] + prefix_sum_b[2])=min(11,9+7)=min(11,16)=11

dp[2]=6-7+11=10

min_temp = min(11,10+prefix_sum_b[1])=min(11,10+4)=min(11,14)=11

dp[1]=3-4+11=10

min_temp = min(11,10+prefix_sum_b[0])=min(11,10+0)=10

dp[0]=7-0+10=17

Then, minimal dp[i] for i=0 and i=1 is min(17,10)=10, but according to the sample, it's 14.

So, perhaps I need to adjust the dp calculation.

Wait, maybe I need to consider that when Kirill reaches position i, he can choose to stop there, paying the cost to reach i, but perhaps there's an additional cost.

Wait, no, the cost to reach i is dp[i], and that's the total cost to reach i.

In the simulation, the minimal cost is 14, but according to dp, it's 10.

So, perhaps dp[i] doesn't accurately reflect the cost.

Wait, perhaps I need to consider that when Kirill reaches position i, he has to pay a_i to swap with i, and then pay b_k for k between j and i.

But in the dp definition, dp[i] includes the cost to swap with i.

Wait, perhaps I need to think differently.

Let me try to redefine dp[i].

Let dp[i] be the minimal cost to reach position i from position n.

To reach i from some j > i, the cost is a_i + sum_{k=i+1}^{j-1} b_k.

So, dp[i] = min over j > i of dp[j] + a_i + sum_{k=i+1}^{j-1} b_k.

This seems correct.

Let me try to compute dp[1]:

dp[1] = min over j=2,3,4 of dp[j] + a[1] + sum_{k=2}^{j-1} b_k

So, for j=2:

dp[2] + a[1] + sum_{k=2}^{1} b_k = dp[2] + 3 + 0 (since k=2 to 1 is empty) =10 +3 +0=13

for j=3:

dp[3] + a[1] + sum_{k=2}^{2} b_k =9 +3 +3=15

for j=4:

dp[4] + a[1] + sum_{k=2}^{3} b_k =0 +3 +3+8=14

So, dp[1] should be min(13,15,14)=13

But in my earlier calculation, dp[1]=10, which is less than 13.

So, perhaps there's a mistake in the dp definition.

Wait, perhaps dp[i] includes the cost a_i to swap with i.

Wait, no, in the operation, Kirill pays a_j to swap with j, and b_k for k between j and i.

Wait, I'm getting confused with the indices.

Let me try to think differently.

Let me consider that Kirill is moving from position n to some position <=m.

Each move is from i to j, where j < i.

The cost is a_j + sum_{k=j+1}^{i-1} b_k.

I need to find the minimal cost to reach any position <=m.

This seems like a shortest path problem, where positions are nodes, and there are directed edges from i to j (j < i) with cost a_j + sum_{k=j+1}^{i-1} b_k.

But with n up to 2e5, I need a better way to compute this.

Let me consider that sum_{k=j+1}^{i-1} b_k is the sum of b from j+1 to i-1.

If I precompute the prefix sums of b, say prefix_b[k] = sum of b[0] to b[k-1].

Then, sum_{k=j+1}^{i-1} b_k = prefix_b[i-1] - prefix_b[j]

So, the cost to move from i to j is a_j + (prefix_b[i-1] - prefix_b[j])

Therefore, cost = a_j + prefix_b[i-1] - prefix_b[j]

Let me define for each position j, the cost to move to j from i is a_j + prefix_b[i-1] - prefix_b[j]

Wait, perhaps I can rearrange this.

Let me fix i and consider j < i.

Then, cost to move from i to j is a_j + prefix_b[i-1] - prefix_b[j]

So, dp[j] = min over i > j of dp[i] + a_j + prefix_b[i-1] - prefix_b[j]

This seems complicated.

Let me try to fix j and look for i > j.

dp[j] = min over i > j of dp[i] + a_j + prefix_b[i-1] - prefix_b[j]

This is still not helpful.

Maybe I can think of dp[j] as dp[j] = a_j - prefix_b[j] + min over i > j of dp[i] + prefix_b[i-1]

Then, dp[j] = a_j - prefix_b[j] + min_over_i>j (dp[i] + prefix_b[i-1])

So, I can compute min_temp = min over i > j of dp[i] + prefix_b[i-1]

Then, dp[j] = a_j - prefix_b[j] + min_temp

Then, I can iterate j from n-1 down to 0, keeping track of min_temp.

Initialize min_temp = dp[n] + prefix_b[n-1]

Then, for j from n-1 down to 0:

dp[j] = a_j - prefix_b[j] + min_temp

Then, min_temp = min(min_temp, dp[j] + prefix_b[j-1])

Wait, but in the earlier calculation, this gave dp[1]=10, which doesn't match the sample's 14.

Perhaps there's a mistake in this approach.

Let me try to see what's wrong.

Looking back at the operation: when Kirill moves from i to j, he pays a_j and sum_{k=j+1}^{i-1} b_k.

Wait, in the sample, moving from 5 to 4: pay a_4=9 and sum_{k=5 to 4} b_k, which is only b_4=5, so total 14.

Another way: move from 5 to 3: pay a_3=6 and sum_{k=4}^{4} b_k=5, total 11.

Then, from 3 to 2: pay a_2=3 and sum_{k=3}^{3} b_k=8, total 11+3+8=22, which is worse than 14.

Another way: from 5 to 4:14, then from 4 to 2: pay a_2=3 and sum_{k=3}^{3} b_k=8, total 14+3+8=25, worse.

From 5 to 4:14, then from 4 to 1: pay a_1=7 and sum_{k=2}^{3} b_k=3+8=11, total 14+7+11=32, worse.

From 5 to 3:11, then from 3 to 1: pay a_1=7 and sum_{k=2}^{2} b_k=3, total 11+7+3=21, worse.

From 5 to 2: pay a_2=3 and sum_{k=3}^{4} b_k=8+5=13, total 16.

Better than 14, but still worse.

From 5 to 1: pay a_1=7 and sum_{k=2}^{4} b_k=3+8+5=16, total 23.

Worse.

So, the minimal is indeed 14.

But according to my dp calculation, dp[1]=10, which is less than 14, but in reality, 14 is the minimal cost.

So, perhaps my dp definition is incorrect.

Let me try to think differently.

Maybe I need to consider that dp[i] is the minimal cost to reach position i, and then, to reach any position <=m, I need to consider the minimal dp[i] for i<=m.

But in this case, dp[1]=10, but actually, it's not possible to achieve 10.

Perhaps I need to adjust the dp calculation to ensure that it reflects the actual minimal cost required.

Wait, perhaps I need to consider that dp[i] includes the cost to swap to i, but in reality, I might need to swap through i without stopping there.

Wait, maybe I need to consider that dp[i] is the minimal cost to reach position i, but not necessarily stop there.

Wait, perhaps I need to think in terms of reaching position i and stopping there.

Then, the minimal cost to have Kirill among the first m positions is the minimal dp[i] for i from 0 to m-1.

But in the sample, dp[1]=10, but actual minimal is 14.

So, perhaps dp[i] needs to include some additional constraints.

Wait, maybe dp[i] should be the minimal cost to reach position i and stop there, meaning no further operations.

But in the simulation, dp[1]=10, but actual minimal is 14.

So, perhaps dp[i] should also consider the cost to reach i and then stop there, meaning no further operations, so no need to pay for any further b_k.

Wait, perhaps I need to add an additional cost when stopping at position i.

Wait, the problem says that Kirill can perform the operation any number of times, and he wants to end up at a position <=m.

So, perhaps dp[i] should be the minimal cost to reach position i and stop there, meaning no further operations.

But in the simulation, reaching position 1 with dp[1]=10, but actually, to reach position 1, perhaps there are additional costs.

Wait, maybe I need to consider that to stop at position i, Kirill needs to pay a_i to swap with i, and then pay b_k for all k between j and i for each operation.

But in the dp definition, dp[i] includes a_i, but perhaps it's not accounting for all the b_k correctly.

Wait, maybe I need to think in terms of the final position.

When Kirill stops at position i, he doesn't need to pay any more b_k, but he has to pay a_i to swap with i.

In the dp calculation, dp[i] = a_i - prefix_b[i] + min_temp, where min_temp is the minimal dp[j] + prefix_b[j-1] for j > i.

Wait, perhaps I need to adjust the dp formula.

Let me try to think differently.

Let me consider that dp[i] is the minimal cost to reach position i, including the cost to swap with i.

Then, to reach position i, Kirill can come from any position j > i, paying dp[j] + a_i + sum_{k=i+1}^{j-1} b_k.

So, dp[i] = a_i + min over j > i of dp[j] + sum_{k=i+1}^{j-1} b_k.

Using prefix sums, sum_{k=i+1}^{j-1} b_k = prefix_b[j-1] - prefix_b[i]

So, dp[i] = a_i + min over j > i of dp[j] + prefix_b[j-1] - prefix_b[i]

Let me rearrange:

dp[i] = a_i - prefix_b[i] + min over j > i of (dp[j] + prefix_b[j-1])

So, I can keep a running minimum of dp[j] + prefix_b[j-1] for j > i.

Let me initialize dp[n] = 0, since starting at n.

Then, for i from n-1 down to 0:

compute dp[i] = a_i - prefix_b[i] + min_temp

where min_temp is the minimal dp[j] + prefix_b[j-1] for j > i.

Then, update min_temp = min(min_temp, dp[i] + prefix_b[i-1])

Wait, in the earlier calculation, dp[1]=10, but actual minimal is 14.

Perhaps I need to adjust for the fact that when Kirill stops at position i, he doesn't need to pay b_k for k > i.

Wait, no, b_k is only paid when jumping over k.

But in the dp definition, dp[i] includes the cost to reach i from some j > i, paying a_i and sum_{k=i+1}^{j-1} b_k.

Wait, perhaps I need to consider that dp[i] is the minimal cost to reach position i from position n, allowing for further operations.

But in reality, when Kirill stops at position i, he shouldn't have any further operations.

Wait, maybe I need to consider that dp[i] is the minimal cost to reach position i, and then stop there.

In that case, dp[i] should be the minimal cost to reach i, and then no further operations.

So, the minimal cost to have Kirill among the first m positions is min(dp[i] for i from 0 to m-1).

But in the sample, dp[1]=10, but actual minimal is 14.

So, perhaps dp[i] is not correctly reflecting the minimal cost.

Wait, maybe I need to consider that dp[i] includes the cost a_i only once.

Wait, perhaps I need to ensure that a_i is only paid once when swapping to i.

Wait, in the dp definition, dp[i] = a_i + min over j > i of dp[j] + sum_{k=i+1}^{j-1} b_k

This seems correct.

Let me try to compute dp[1] again.

dp[1] = a[1] + min over j=2,3,4 of dp[j] + sum_{k=2}^{j-1} b_k

So, for j=2:

dp[2] + sum_{k=2}^{1} b_k =10 +0=10

for j=3:

dp[3] + sum_{k=2}^{2} b_k =9 +3=12

for j=4:

dp[4] + sum_{k=2}^{3} b_k =0 +3+8=11

So, dp[1] = 3 + min(10,12,11)=3+10=13

Wait, but earlier I had dp[1]=10, which is less than 13.

So, perhaps my dp calculation is wrong.

Wait, perhaps dp[i] should be dp[i] = a_i + min over j > i of dp[j] + sum_{k=i+1}^{j-1} b_k

Then, dp[1] = 3 + min(10,12,11)=3+10=13

But in my earlier dp calculation, dp[1]=3-4+11=10, which is different.

So, perhaps the dp formula I used earlier is incorrect.

Wait, perhaps the dp formula should be dp[i] = a_i + min over j > i of dp[j] + sum_{k=i+1}^{j-1} b_k

And using prefix sums, sum_{k=i+1}^{j-1} b_k = prefix_b[j-1] - prefix_b[i]

So, dp[i] = a_i + min over j > i of dp[j] + prefix_b[j-1] - prefix_b[i]

Which is dp[i] = a_i - prefix_b[i] + min over j > i of (dp[j] + prefix_b[j-1])

Then, I can keep a variable min_temp that stores the minimal dp[j] + prefix_b[j-1] for j > i.

So, starting from i=n-1 down to 0:

dp[i] = a_i - prefix_b[i] + min_temp

Then, min_temp = min(min_temp, dp[i] + prefix_b[i-1])

In the sample:

Initialize dp[4]=0

min_temp = dp[4] + prefix_b[3] =0 +11=11

i=3:

dp[3]=9 -11 +11=9

min_temp = min(11,9 + prefix_b[2])=min(11,9+7)=min(11,16)=11

i=2:

dp[2]=6 -7 +11=10

min_temp = min(11,10 +7)=min(11,17)=11

i=1:

dp[1]=3 -4 +11=10

min_temp = min(11,10 +4)=min(11,14)=11

i=0:

dp[0]=7 -0 +11=18

Then, minimal dp[i] for i=0 and i=1 is min(18,10)=10, but actual minimal is 14.

So, perhaps dp[i] is not correctly reflecting the minimal cost to reach position i.

Wait, perhaps I need to consider that dp[i] includes the cost a_i only once.

Wait, perhaps dp[i] should be the minimal cost to reach position i, including the cost to swap with i.

But in the simulation, to reach position 1 with dp[1]=10, but actual cost is 14.

So, perhaps dp[i] needs to include some additional costs.

Wait, maybe dp[i] should be the minimal cost to reach position i and stop there.

In that case, dp[i] should be the minimal cost to reach i, including a_i, and no further operations.

But according to the simulation, dp[1]=10 is less than the actual minimal cost of 14.

So, perhaps dp[i] is underestimating the cost.

Wait, maybe I need to adjust dp[i] to include the cost of b_k for k > i.

Wait, no, because b_k is only paid when jumping over k.

Wait, perhaps I need to consider that dp[i] includes the cost to reach i from n, including all the b_k for k between i and n.

But in the dp calculation, it seems to be missing some b_k payments.

Wait, perhaps I need to think in terms of the total cost to reach i, which includes a_i and the sum of b_k for all k that are jumped over in the path from n to i.

In the dp calculation, dp[i] = a_i - prefix_b[i] + min_temp, where min_temp is the minimal dp[j] + prefix_b[j-1] for j > i.

This seems to account for the sum of b_k from i+1 to j-1 as prefix_b[j-1] - prefix_b[i].

But perhaps it's not accounting for all the b_k correctly.

Wait, maybe I need to consider that when Kirill moves from j to i, he pays a_i and sum_{k=i+1}^{j-1} b_k.

So, in dp[i], it should be a_i plus the minimal dp[j] plus sum_{k=i+1}^{j-1} b_k over all j > i.

Which is dp[i] = a_i + min over j > i of dp[j] + prefix_b[j-1] - prefix_b[i]

Which is dp[i] = a_i - prefix_b[i] + min over j > i of (dp[j] + prefix_b[j-1])

Then, maintaining a running min_temp of dp[j] + prefix_b[j-1] for j > i.

This seems correct, but in the sample, it's giving dp[1]=10, which is less than the actual minimal cost of 14.

So, perhaps I need to adjust the dp formula.

Wait, maybe I need to consider that dp[i] is the minimal cost to reach position i and stop there, meaning no further operations.

But in reality, to reach position i, Kirill might have to perform operations that involve paying b_k for positions between j and i for each operation.

Perhaps I need to think in terms of the total sum of b_k for all positions jumped over in the entire path from n to i.

In the sample, to reach position 1 via position 4, paying a_4=9 and b_4=5, then stopping at position 4 is not useful.

Wait, no, Kirill wants to reach position <=m.

So, in the sample, m=2, positions 0 and 1.

So, in the simulation, moving from 5 to 4: pay 9+5=14, then stop at position 4, which is not <=m.

So, need to move further.

From position 4 to position 2: pay a_2=3 and b_3=8, total additional 11, making 25.

Which is worse than 14.

So, perhaps in dp[i], I need to consider that if i > m, then dp[i] is not a final position, and I need to continue moving.

Wait, perhaps I need to set dp[i] for i > m to infinity, since Kirill doesn't want to stop there.

Wait, no, Kirill can go through positions > m, but he has to end up at positions <=m.

So, perhaps dp[i] should be set to infinity for i > some value.

Wait, perhaps I need to adjust the dp calculation to only consider positions <=m as final positions.

Wait, no, Kirill can go through positions > m, but must end up at positions <=m.

So, dp[i] is the minimal cost to reach position i, and then the minimal dp[i] for i <=m-1 is the answer.

But in the sample, dp[1]=10, but actual minimal is 14.

So, perhaps dp[i] is not correctly accounting for the total cost.

Wait, perhaps I need to consider that dp[i] includes the cost to reach i from n, but doesn't account for the cost of b_k for positions between n and i that are not directly jumped over.

This is getting too complicated.

Let me try to think of another approach.

Maybe I can model this as a graph where each position is a node, and there are edges from i to j for j < i with cost a_j + sum_{k=j+1}^{i-1} b_k.

Then, I can compute the minimal cost to reach any position <=m-1 from position n.

But with n up to 2e5, building such a graph is not feasible.

So, perhaps I need to find a way to compute this efficiently.

Looking back at the dp approach, perhaps I need to adjust the dp formula.

Let me consider that dp[i] is the minimal cost to reach position i, including the cost to swap with i and pay all necessary b_k.

In the sample, dp[1]=10, but actual minimal is 14.

So, perhaps dp[i] needs to include some additional cost when i is not the final position.

Wait, maybe I need to consider that dp[i] is the minimal cost to reach position i and then pay the necessary b_k to move to any position <=m.

But this seems too vague.

Let me try to think differently.

Suppose Kirill moves from position n to position j1, paying a_j1 + sum_{k=j1+1}^{n-1} b_k.

Then, from j1 to j2, paying a_j2 + sum_{k=j2+1}^{j1-1} b_k.

And so on, until reaching a position <=m.

Perhaps I can find a way to select a sequence of swaps that minimizes the total cost.

This seems too vague.

Wait, perhaps I can think in terms of the minimal cost to reach position i, and then consider that to reach any position <=m, I need to consider the minimal dp[i] for i<=m.

But in the sample, dp[1]=10, but actual minimal is 14.

So, perhaps dp[i] is underestimating the cost.

Wait, perhaps I need