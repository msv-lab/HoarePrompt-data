Alright, I have this problem to solve. Let's see what it's about. So, I'm given an array of integers, and I can perform a certain operation on it multiple times to maximize the sum of the array elements. The operation involves choosing a subarray, computing its MEX, and then setting all elements in that subarray to that MEX value. I need to find the maximum possible sum and also provide a sequence of operations that achieve this sum.

First, I need to understand what MEX means. MEX stands for "minimum excludant," which is the smallest non-negative integer not present in a given set. For example, the MEX of [0, 1, 3] is 2, because 2 is the smallest non-negative integer not in the set.

So, the operation allows me to choose any subarray, compute its MEX, and set all elements in that subarray to that MEX value. I can do this up to 5*10^5 times, but I don't need to minimize the number of operations, just ensure that I don't exceed the limit.

My goal is to maximize the sum of the array after performing these operations.

Let's consider some examples to get a better understanding.

Example 1:

Input:

2

0 1

Output:

4 1

1 2

Explanation:

After applying the operation on the entire array, the MEX of [0,1] is 2. So, set both elements to 2, making the array [2,2], sum=4.

It's mentioned that this is the maximum possible sum.

Example 2:

Input:

3

1 3 9

Output:

13 0

Explanation:

The initial sum is 13, and no operations are needed because it's already the maximum.

Example 3:

Input:

4

1 100 2 1

Output:

105 2

3 3

3 4

Explanation:

After the first operation on the third element, set it to MEX of [2], which is 0, making the array [1,100,0,1].

Then, apply the operation on the third and fourth elements, set them to MEX of [0,1], which is 2, making the array [1,100,2,2], sum=105.

It's stated that this is the maximum sum.

Example 4:

Input:

1

0

Output:

1 1

1 1

Explanation:

Apply the operation on the single element, set it to MEX of [0], which is 1, making the array [1], sum=1.

Alright, so from these examples, I can see that applying the operation can increase the sum by setting elements to a higher value, which is the MEX of the subarray.

Now, I need to find a way to maximize the sum. To do that, I need to strategically choose subarrays and apply operations to increase the values in a way that maximizes the total sum.

Constraints:

- The array length n is up to 18, which is relatively small. This suggests that exponential time solutions might be feasible.

- Each a_i can be up to 10^7, but since we can perform operations to change them, their initial values might not be directly relevant to the final sum.

Given that n is small (n <= 18), I can consider dynamic programming approaches where I keep track of subarrays and their possible operations.

Let me think about the DP state.

I can consider dp[l][r], which represents the maximum sum achievable for the subarray from index l to r.

But since n is up to 18, and subarrays would involve O(n^2) states, which is acceptable.

However, in each state, I need to consider all possible operations that can be performed on the subarray from l to r.

Wait, but the operation allows me to choose any subarray within l to r and set it to its MEX. This seems a bit tricky.

Alternatively, perhaps I can think about covering the entire array with multiple operations, where each operation sets a subarray to its MEX, and I need to maximize the sum.

But this seems complicated.

Let me think differently.

What if I consider that, by applying operations, I can set the entire array to a certain value.

But the value is determined by the MEX of the subarray I choose.

Wait, but MEX depends on the current values in the subarray.

This seems too vague.

Maybe I need to find a way to increase the values in the array by applying operations in a specific order.

Another idea: Since n is small, maybe I can consider all possible partitions of the array and compute the MEX for each partition.

Wait, but operations can be applied multiple times, so it's not just about partitioning.

I need a better approach.

Let me consider that each operation can be seen as replacing a subarray with its MEX.

And I can perform this operation up to 5*10^5 times, which is a lot, so I don't need to worry about minimizing the number of operations.

Given that, perhaps I can model this as a DP where I consider all possible ways to split the array and apply operations.

Wait, perhaps I can model this using intervals and considering the MEX of those intervals.

But I need to think more carefully.

Let me consider that for any subarray, its MEX is determined by the elements present in it.

And by setting the entire subarray to its MEX, I'm effectively changing all elements in that subarray to the same value, which is the MEX.

So, perhaps I can think about covering the array with multiple such operations, where each operation sets a subarray to its MEX, and I need to maximize the sum.

But overlapping operations might be an issue, as they can interfere with each other.

Alternatively, perhaps I can think about applying operations in a way that each element is eventually set to a certain value, and I need to find the optimal value for each element.

But this seems too vague.

Wait, perhaps I can consider that, for a given subarray, applying an operation can increase the values in that subarray to their MEX, which might be higher than some of the original values.

So, by applying operations on appropriate subarrays, I can maximize the sum.

But how do I choose which subarrays to operate on?

I need a systematic way to determine the optimal operations.

Let me consider that the MEX of a subarray is determined by the elements present in it.

So, if a subarray contains all numbers from 0 to k-1, its MEX would be k.

If it's missing some numbers in that range, the MEX would be the smallest missing number.

So, by applying an operation on a subarray, I'm setting all elements in that subarray to the smallest non-negative integer not present in it.

I need to maximize the sum, so I should aim to set as many elements as possible to higher values.

But how?

One idea: Start with the entire array and compute its MEX, set the entire array to that MEX. Then, within that array, choose a subarray and set it to its MEX, which might be higher than the current MEX, and so on.

But this seems too vague and may not lead to the optimal solution.

Perhaps I need to consider the array as a whole and find a sequence of operations that progressively increases the values.

But this is still not concrete enough.

Let me consider the problem in terms of DP.

Suppose I have a DP state dp[l][r], which represents the maximum sum achievable for the subarray from index l to r.

Then, I can consider all possible ways to split this subarray into smaller subarrays, apply operations on them, and combine their results.

Wait, but operations can be applied to any subarray, not just splits at specific points.

This is getting complicated.

Let me look at the problem differently.

Suppose I fix the value that a subarray is set to, which is its MEX.

Then, I need to ensure that this MEX is as large as possible, since higher MEX values would contribute more to the sum.

But MEX is determined by the elements in the subarray, so to maximize MEX, I need to have subarrays that contain as many consecutive small integers as possible.

Wait, but I can apply operations multiple times, so perhaps I can iteratively increase the values in the array.

But I need a better strategy.

Let me consider that, for a given subarray, its MEX is the smallest non-negative integer not present in it.

So, if I have a subarray with elements [0,1,2], its MEX is 3.

If I set this subarray to 3, then in subsequent operations, the MEX of this subarray would be 0, since 3 is already present.

Wait, no.

Wait, after setting it to 3, all elements in the subarray are 3.

Then, the MEX of this subarray would be 0, since 0 is not present.

Wait, no.

MEX is the smallest non-negative integer not present in the set.

If all elements are 3, then the set is {3}, so MEX is 0, since 0 is not present.

Wait, but 3 is present, but MEX is 0.

Wait, no, MEX is the smallest non-negative integer not in the set.

So, if the set is {3}, then MEX is 0, because 0 is not in the set.

But if I set the subarray to 3, and then apply another operation on the same subarray, I would set it to MEX of {3}, which is 0.

Then, the subarray becomes {0}, and its MEX would be 1.

So, I could repeatedly apply operations to increase the value.

Wait, but this seems cyclical.

From {3}, MEX is 0.

Set to 0.

Then, MEX is 1.

Set to 1.

Then, MEX is 2.

Set to 2.

Then, MEX is 3 again.

So, it cycles.

This suggests that repeatedly applying operations to the same subarray won't lead to higher and higher values; it will cycle.

Therefore, I need to be careful about which subarrays I choose to operate on.

This seems tricky.

Perhaps I need to find a way to arrange the array such that each subarray is set to a value that is higher than its original values, but without causing cycling.

Wait, perhaps I need to think in terms of intervals and the MEX values they can achieve.

Alternatively, perhaps I can think about the final array configuration that maximizes the sum, and then find a sequence of operations that leads to that configuration.

But how do I determine the optimal final configuration?

Let me consider that, in the final array, each element is set to some value, and I need to maximize the sum of these values.

But the value of each element is constrained by the operations I can perform.

Each operation sets a subarray to the MEX of that subarray.

So, the final value of an element depends on the operations applied to the subarrays containing that element.

This seems too vague.

Let me consider that, for a subarray, if I set it to its MEX, and then no further operations are performed on any subarray containing that subarray, then its value remains.

But if I perform operations on larger subarrays that include it, its value can be changed again.

This seems complicated.

Perhaps I need to consider the operations in a specific order, from smaller subarrays to larger ones.

Alternatively, perhaps I can model this problem using graph theory or some other approach.

Wait, perhaps I can think in terms of the maximum possible value each element can reach.

Given that, for any element, I can apply operations on subarrays containing it, setting it to the MEX of that subarray.

But determining the sequence of operations to achieve the highest possible values seems non-trivial.

Let me consider that, for a single element, I can apply an operation on that single element, setting it to its MEX.

Then, I can apply another operation on that element again, setting it to the new MEX, and so on.

But as I saw earlier, this can lead to cycling between values.

For example, starting with 0:

- Operation on [0]: MEX({0}) = 1, set to 1.

- Operation on [1]: MEX({1}) = 0, set to 0.

- Operation on [0]: MEX({0}) = 1, set to 1.

And so on.

So, it alternates between 0 and 1.

Similarly, starting with 1:

- Operation on [1]: MEX({1}) = 0, set to 0.

- Operation on [0]: MEX({0}) = 1, set to 1.

- And so on.

So, for a single element, the optimal value seems to be 1, by setting it to MEX once.

In the first example, with n=2 and array [0,1], applying the operation on the entire array sets both to 2, which is better than setting each to 1 individually.

So, operations on larger subarrays can lead to higher values.

Wait, but in this case, setting both to 2 gives a higher sum than setting them individually to 1.

So, perhaps there is potential in operating on larger subarrays.

But in the third example, with array [1,100,2,1], applying operations on subarrays [2], setting it to 0, and then [2,3], setting them to 2, leads to a sum of 105.

This seems better than operating on larger subarrays directly.

So, perhaps a combination of operations on different subarrays is needed.

This is getting complicated.

Given that n is small (n <= 18), perhaps I can consider all possible sequences of operations, but that would be computationally expensive even for n=18, given that operations can be up to 5*10^5.

But since n is small, perhaps I can consider DP where I keep track of the MEX values for different subarrays.

Wait, perhaps I can model this using DP where I consider masks or something similar.

But I need to think carefully.

Let me consider that, for a subarray from l to r, its MEX is determined by the elements in it.

So, if I know the set of elements in the subarray, I can compute its MEX.

Then, by setting the subarray to its MEX, I'm effectively replacing all elements in it with that MEX value.

Then, for the next operation, the MEX of any subarray would be determined by the current values.

But since operations can be applied multiple times, it's not clear how to model this.

Wait, perhaps I can consider that, after setting a subarray to its MEX, I can no longer change it, or something like that.

But that doesn't seem right, because operations can be applied multiple times.

This seems too convoluted.

Let me try to think differently.

Suppose I fix the final array configuration that maximizes the sum.

Each element in the final array is set to some value, and I need to ensure that this configuration is achievable through a sequence of operations.

But how do I ensure that?

Wait, perhaps I can model this as a graph where nodes represent subarrays, and edges represent the dependencies between operations.

But this seems too vague.

Another idea: perhaps I can consider that, for a given subarray, its MEX is determined by the minimal value not present in it.

So, to maximize the sum, I need to maximize the MEX of the largest possible subarrays.

Wait, but MEX is about the smallest missing non-negative integer.

Wait, perhaps I can think about the frequency of numbers in the array.

But I'm not sure.

Let me consider that, for a subarray, its MEX is at least the smallest non-negative integer not present in it.

So, if a subarray contains all numbers from 0 to k-1 except one, its MEX would be that missing number.

But this seems too involved.

Let me consider that, for a subarray, its MEX is at least the number of unique elements in it plus one, under certain conditions.

But this is still not helpful.

Wait, perhaps I can consider that, for a subarray, its MEX is at least the number of elements in it if all elements are distinct and consecutive starting from 0.

Wait, if a subarray contains all numbers from 0 to k-1 without duplicates, its MEX is k.

So, for such a subarray, setting it to k would increase the sum if k is larger than the current elements.

But this is only for specific cases.

In general, it's complicated.

Let me consider that, for a subarray of length l, the maximum MEX it can have is l if it contains all elements from 0 to l-1.

Otherwise, its MEX is less than l.

So, to maximize the sum, I need to maximize the MEX of the subarrays I choose to operate on.

But again, operations can be applied multiple times, so I need to find an order that leads to the highest possible sum.

This seems too vague.

Let me consider that, for a subarray, its MEX is determined by the minimal excluded integer.

So, to maximize the MEX, I need to have as many small integers present in the subarray as possible.

Wait, but in practice, setting a subarray to its MEX might not necessarily increase the sum, depending on the current values.

Wait, actually, since MEX is the smallest non-negative integer not present in the subarray, and non-negative integers start from 0, MEX will always be >=0.

Given that, if I have a subarray with all elements >=1, its MEX would be 0.

Setting it to 0 might decrease the sum.

Wait, but in the operation, I set the subarray to its MEX, which could be 0, which might not always be beneficial.

Wait, in the first example, [0,1], MEX is 2, which is higher than both elements, so setting both to 2 increases the sum.

In the third example, [1,100,2,1], setting the third element to MEX(2) which is 0 decreases the sum temporarily, but then setting [3,4] to MEX(0,1)=2 increases the sum.

So, sometimes, operations might decrease some elements temporarily to increase others.

This seems tricky to model.

Given that n is small, maybe I can consider all possible sequences of operations, but that would be inefficient.

Alternatively, perhaps I can consider that the maximum sum is achieved when each element is set to the highest possible value, which would be the MEX of the entire array after some operations.

But again, it's not clear.

Wait, perhaps I can consider that the maximum possible sum is n times the MEX of the entire array, but that doesn't seem right, because operations can be applied to subarrays, not just the entire array.

Wait, in the first example, n=2, array=[0,1], MEX is 2, set both to 2, sum=4.

In the second example, n=3, array=[1,3,9], MEX is 0, but setting to 0 decreases the sum, so it's better to do nothing.

In the third example, n=4, array=[1,100,2,1], after operations, sum=105.

Wait, perhaps the maximum sum is achieved when each subarray is set to its MEX in a way that maximizes the overall sum.

But I need a systematic way to compute this.

Let me consider that, for a subarray from l to r, its MEX is x, and by setting it to x, I can consider it as a new subarray with all elements equal to x.

Then, I can apply operations on larger subarrays containing it.

But this seems too vague.

Wait, perhaps I can model this using DP where dp[l][r] represents the maximum sum achievable for the subarray from l to r.

Then, for each subarray from l to r, I can choose to either:

1. Do nothing and keep the current sum of elements from l to r.

2. Apply an operation on the entire subarray from l to r, setting it to its MEX, and then consider the sum as (r - l + 1) * MEX.

3. Split the subarray into smaller subarrays and apply operations on them separately.

But this seems incomplete.

Wait, perhaps I can consider that, for dp[l][r], I can choose to apply an operation on the entire subarray, or not apply any operation on it, or apply operations on parts of it.

But this is still not precise.

Let me think about the DP transition.

Suppose dp[l][r] is the maximum sum achievable for the subarray from l to r.

Then, I can choose to:

- Do nothing: sum(arr[l..r])

- Apply an operation on the entire subarray: (r - l + 1) * MEX(arr[l..r])

- Apply operations on subarrays within [l, r]: for any l <= i < j <= r, apply an operation on [l, i], [i+1, j], and [j+1, r], and sum their dp values.

But this seems too broad.

Wait, perhaps I can consider that, for dp[l][r], I can choose to:

- Not apply any operation on [l, r], in which case the sum is sum(arr[l..r])

- Apply an operation on [l, r], setting it to MEX(arr[l..r]), and the sum becomes (r - l + 1) * MEX(arr[l..r])

- Or, split [l, r] into smaller subarrays, apply operations on them separately, and take the sum of their dp values.

But I need to consider that operations can be applied multiple times, so it's not just a single choice.

This seems too involved.

Alternatively, perhaps I can consider that, for dp[l][r], the maximum sum is the maximum over:

- sum(arr[l..r])

- (r - l + 1) * MEX(arr[l..r])

- all possible splits of [l, r] into [l, k] and [k+1, r], and take dp[l][k] + dp[k+1][r]

But again, this seems incomplete.

Wait, perhaps I can consider that, for dp[l][r], the maximum sum is the maximum over:

- sum(arr[l..r])

- (r - l + 1) * MEX(arr[l..r])

- for all l <= k < r, dp[l][k] + dp[k+1][r]

This might be a way to model it.

Let me try to formalize this.

Define dp[l][r] as the maximum sum achievable for the subarray from l to r.

Then, dp[l][r] = max(

sum(arr[l..r]),

(r - l + 1) * MEX(arr[l..r]),

max over k=l to r-1 of dp[l][k] + dp[k+1][r]

)

This seems plausible.

Then, I can compute dp[l][r] for all l, r using this recurrence.

Additionally, I need to keep track of the operations used to achieve this sum.

Given that n is up to 18, dp[l][r] would involve O(n^2) states, and each state considers O(n) splits, so it's manageable.

Now, I need to implement this DP approach.

But, in the provided code, it seems like there's a different approach being taken.

Looking at the provided code:

- It reads n and arr.

- It initializes a dictionary res_dict.

- It defines func_1(start_index, end_index) which seems to compute the maximum sum for the subarray from start_index to end_index.

- It defines func_2(start_index, end_index) which seems to construct the sequence of operations to achieve the maximum sum.

- There's also a make_stairs(i) function, which seems to be related to making a sequence of increasing values.

But, upon closer inspection, the code seems incomplete or incorrect.

Firstly, in func_1, it computes dp[l][r] using a similar approach to what I thought of.

dp[l][r] = max(

sum(arr[l..r]),

(r - l + 1) ** 2,

max over i in l to r-1 of dp[l][i-1] + dp[i+1][r] + arr[i]

)

Wait, this seems different from what I had in mind.

Here, it's considering (r - l + 1) ** 2 as one of the options, which is unclear.

Also, it's considering splits where it takes dp[l][i-1] + dp[i+1][r] + arr[i].

This seems arbitrary.

Moreover, in func_2, it tries to reconstruct the operations based on the dp values, but it seems to have some issues.

Also, make_stairs(i) is trying to set a subarray to a specific sequence, but it's not clear how it fits into the overall approach.

Given that, I suspect that the provided code might not be correct.

Let me consider the first example:

n=2, arr=[0,1]

According to the code:

func_1(0,1) would compute:

- sum(arr[0..1]) = 1

- (2)^2 = 4

- for i=1: dp[0][0] + dp[2][1] + arr[1] → dp[0][0] + 0 + 1 = dp[0][0] +1

dp[0][0] = max(1, arr[0]) = max(1,0)=1

So, dp[0][1] = max(1,4,1+1=2) = 4

Which matches the expected sum of 4.

Then, func_2(0,1) would see that 4 == 2^2, so it would call make_stairs(1), which would set the subarray [0,1] to 2, which is correct.

So, in this case, it works.

Second example:

n=3, arr=[1,3,9]

func_1(0,2):

- sum(arr[0..2])=13

- (3)^2=9

- for i=1: dp[0][0]+dp[2][2]+arr[1]=max(1,arr[0])+max(1,arr[2])+arr[1]=1+9+3=13

- for i=2: dp[0][1]+dp[3][2]+arr[2]=dp[0][1](which is 4 from previous)+0+9=13

So, dp[0][2]=max(13,9,13,13)=13

Which is correct.

func_2(0,2) would see that 13 == sum(arr), so it returns no operations, which is correct.

Third example:

n=4, arr=[1,100,2,1]

func_1(0,3):

- sum(arr[0..3])=1+100+2+1=104

- (4)^2=16

- for i=1: dp[0][0]+dp[2][3]+arr[1]=1 + dp[2][3] +100

dp[2][3]=max(sum(arr[2..3])=2+1=3, 2^2=4, dp[2][2]+dp[3][3]+arr[3]=max(1,2)+max(1,1)+1=1+1+1=3 → so dp[2][3]=4

So, dp[0][0]+dp[2][3]+arr[1]=1 +4 +100=105

- for i=2: dp[0][1]+dp[3][3]+arr[2]=dp[0][1]+1+2

dp[0][1]=max(sum(arr[0..1])=1+100=101, 2^2=4, dp[0][0]+dp[1][1]+arr[1]=1 + max(1,3)+100=1+3+100=104 → dp[0][1]=104

So, dp[0][1]+dp[3][3]+arr[2]=104 +1 +2=107

Wait, but in the example, they achieved 105 with two operations.

According to the DP, dp[0][3]=max(104,16,105,107)=107

But in the example, they achieved 105 with two operations.

So, perhaps my DP is missing something.

Wait, perhaps I miscounted.

Wait, in the third example, they achieved 105, but according to the DP, it's possible to achieve 107.

How is that possible?

Wait, perhaps there's a mistake in my DP calculation.

Let me recalculate dp[0][3]:

sum(arr[0..3])=1+100+2+1=104

(r-l+1)^2=16

for i=1: dp[0][0]+dp[2][3]+arr[1]=1 + dp[2][3] +100

dp[2][3]=max(sum(arr[2..3])=3, 4, dp[2][2]+dp[3][3]+arr[3]=max(1,2)+max(1,1)+1=1+1+1=3 → dp[2][3]=4

So, dp[0][0]+dp[2][3]+arr[1]=1+4+100=105

for i=2: dp[0][1]+dp[3][3]+arr[2]=dp[0][1]+1+2

dp[0][1]=max(sum(arr[0..1])=101, 4, dp[0][0]+dp[1][1]+arr[1]=1 + max(1,3)+100=1+3+100=104 → dp[0][1]=104

So, dp[0][1]+dp[3][3]+arr[2]=104 +1 +2=107

for i=3: dp[0][2]+dp[4][3]+arr[3]=dp[0][2]+0+1

dp[0][2]=max(sum(arr[0..2])=1+100+2=103, 9, dp[0][0]+dp[2][2]+arr[1]=1 + max(1,2)+100=1+2+100=103 → dp[0][2]=103

So, dp[0][2]+dp[3][3]+arr[3]=103 +1 +1=105

Therefore, dp[0][3]=max(104,16,105,107)=107

So, according to the DP, the maximum sum is 107, which is higher than the example's 105.

But in the example, they achieved 105 with two operations, but according to the DP, it's possible to achieve 107.

How is that possible?

Let me see.

If dp[0][3]=107, then there must be a way to achieve 107.

Looking back, dp[0][3]=107 comes from dp[0][1]+dp[2][3]+arr[1]=104 +4 +100=104 +100 +4 seems off.

Wait, no, dp[0][1]=104, dp[2][3]=4, arr[1]=100, so 104 +4 +100=208, which is not matching.

Wait, perhaps I miscalculated.

Wait, in the for loop for i=1 to r-1, it's dp[l][i-1] + dp[i+1][r] + arr[i]

So, for i=1: dp[0][0] + dp[2][3] + arr[1]=1 +4 +100=105

for i=2: dp[0][1] + dp[3][3] + arr[2]=104 +1 +2=107

for i=3: dp[0][2] + dp[4][3] + arr[3]=103 +0 +1=104

So, dp[0][3]=max(104,16,105,107)=107

So, according to the DP, the maximum sum is 107.

But in the example, they achieved 105 with two operations.

So, perhaps there is a way to achieve 107 with more operations.

But in the example, they only used two operations to achieve 105.

So, perhaps the DP is correct, and there is a way to achieve 107 with more operations.

Let me think about how to achieve 107.

If dp[0][1]=104, which comes from dp[0][0]+dp[2][1]+arr[1]=1 + dp[2][1] +100

dp[2][1]=dp[2][1], but indices are off.

Wait, dp[l][r] where l and r are inclusive.

Wait, perhaps there's confusion in the indices.

Wait, in Python, list indices start from 0.

Wait, in func_1, it's defined as start_index and end_index, both inclusive.

So, arr[start_index:end_index+1].

Wait, in the for loop, it's for i in range(start_index+1, end_index):

So, i ranges from start_index+1 to end_index-1.

Wait, in the third example, n=4, indices 0 to 3.

So, for dp[0][3], it considers i=1 and i=2.

for i=1: dp[0][0] + dp[2][3] + arr[1]=1 +4 +100=105

for i=2: dp[0][1] + dp[3][3] + arr[2]=104 +1 +2=107

So, dp[0][3]=max(104,16,105,107)=107

Now, to achieve this sum, I need to perform operations accordingly.

Perhaps, the sequence of operations would be:

- Apply operation on [2], set it to MEX([2])=0, arr becomes [1,100,0,1]

- Apply operation on [3], set it to MEX([1])=0, arr becomes [1,100,0,0]

- Apply operation on [2,3], set to MEX([0,0])=1, arr becomes [1,100,1,1], sum=103

- Apply operation on [1,2], set to MEX([100,1])=0, arr becomes [1,0,1,1], sum=3

This doesn't make sense.

Wait, perhaps I need to choose different subarrays.

Wait, maybe:

- Apply operation on [1,2], set to MEX([100,2])=0, arr becomes [1,0,0,1]

- Apply operation on [2,3], set to MEX([0,1])=2, arr becomes [1,0,2,2], sum=5

Still less than 107.

Wait, perhaps I need more operations.

Alternatively, maybe:

- Apply operation on [0,1], set to MEX([1,100])=0, arr becomes [0,0,2,1]

- Apply operation on [2,3], set to MEX([2,1])=0, arr becomes [0,0,0,0], sum=0

Not better.

Wait, perhaps I need to choose different subarrays.

Wait, maybe:

- Apply operation on [1], set to MEX([100])=0, arr becomes [1,0,2,1]

- Apply operation on [2], set to MEX([2])=0, arr becomes [1,0,0,1]

- Apply operation on [0,1], set to MEX([1,0])=2, arr becomes [2,2,0,1]

- Apply operation on [2,3], set to MEX([0,1])=2, arr becomes [2,2,2,2], sum=8

Still less than 107.

So, it seems like achieving 107 is not possible, at least not with the operations I'm trying.

Perhaps there's a mistake in the DP approach.

Let me think again.

Maybe the DP is incorrect because it assumes that splitting the array and applying operations on parts can lead to higher sums, but in reality, there might be dependencies between operations that aren't accounted for.

Alternatively, perhaps the DP is overestimating the achievable sum.

Given that, perhaps the DP needs to be adjusted.

Looking back at the DP definition:

dp[l][r] = max(

sum(arr[l..r]),

(r - l + 1) ** 2,

max over i in l+1 to r-1 of dp[l][i-1] + dp[i+1][r] + arr[i]

)

I'm not sure where the (r - l + 1) ** 2 comes from.

In the first example, (2)^2=4, which matches the expected sum.

In the second example, (3)^2=9, which is less than the sum of 13, so it's not chosen.

In the third example, (4)^2=16, which is less than 104, so it's not chosen.

But in the third example, dp[0][3]=107, which seems unrealistic based on manual calculations.

Perhaps, instead of (r - l + 1) ** 2, it should be (r - l + 1) * MEX(arr[l..r]).

But in the first example, (2)*MEX([0,1])=2*2=4, which matches.

In the second example, (3)*MEX([1,3,9])=3*0=0, which is less than the sum of 13, so it's not chosen.

In the third example, (4)*MEX([1,100,2,1])=4*0=0, which is less than 104, so it's not chosen.

But in the code, it's using (r - l + 1) ** 2, which coincidentally worked in the first example but not in the third.

This suggests that there's a mistake in the code.

Perhaps the code should use (r - l + 1) * MEX(arr[l..r]) instead of (r - l + 1) ** 2.

Let me check the code again.

In func_1, it has:

res = (end_index - start_index + 1) ** 2

Then, it considers other options and takes the maximum.

But in reality, it should be (end_index - start_index + 1) * MEX(arr[start_index:end_index+1])

So, perhaps the code is incorrect here.

Wait, but in the first example, (2)^2=4, which matches the expected sum, but in the third example, (4)^2=16, which is less than the sum of 104, so it's not chosen, and the DP still overestimates.

Wait, perhaps the issue is elsewhere.

Alternatively, perhaps the DP is correct, and there exists a way to achieve 107, but I'm not seeing it.

Let me consider that, perhaps, with multiple operations, I can achieve higher sums than what's intuitive.

But in practice, I'm having trouble finding a sequence of operations that achieves 107 for the third example.

Given that, perhaps the DP is flawed.

Let me consider an alternative approach.

Suppose I consider that, for any subarray, setting it to its MEX increases the sum only if the MEX is higher than the average of the subarray's elements.

But this is still not precise.

Alternatively, perhaps I can consider that the maximum sum is achieved when the entire array is set to the highest possible MEX.

But the MEX is determined by the elements in the subarray, so I need to maximize the MEX.

But