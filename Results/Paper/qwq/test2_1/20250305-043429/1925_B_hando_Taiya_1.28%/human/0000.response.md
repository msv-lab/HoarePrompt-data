Alright, I have this problem to solve. Let's read it carefully.

So, Jay created a problem of difficulty x and wants to make it the second problem for a Codeforces round. But Yash is worried that this might make the contest unbalanced, so he decides to break this problem into n sub-problems. Each sub-problem must have a positive integer difficulty, and the sum of all these sub-problems' difficulties should equal x.

Now, the coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems.

Our task is to find the maximum balance Yash can achieve by optimally choosing the difficulties of the sub-problems.

First, I need to understand what GCD is. GCD of a set of numbers is the largest number that divides all of them without leaving a remainder.

So, if Yash breaks down the problem into n sub-problems with difficulties a1, a2, ..., an, such that a1 + a2 + ... + an = x, we need to maximize the GCD of these ai's.

I need to think about how to maximize this GCD.

Let's consider an example from the problem:

Test case 1:

x = 10, n = 3

One possible way is to have sub-problems with difficulties 4, 2, and 4. The GCD of these is 2.

Is there a way to get a higher GCD? Let's see.

If I choose 3, 3, and 4, GCD is 1.

Or 2, 2, and 6, GCD is 2.

Or 5, 2, and 3, GCD is 1.

So, the maximum GCD achievable is 2.

Another test case:

x = 5, n = 5

Only way is to have all sub-problems with difficulty 1, so GCD is 1.

Third test case:

x = 420, n = 69

Somehow, the answer is 6.

I need to find a general approach to solve this for any x and n.

Let's think about the properties of GCD.

If all ai are multiples of some number d, then d divides x, because x is the sum of ai's.

So, d must be a divisor of x.

Moreover, since there are n sub-problems, and each ai >=1, then x >= n.

Otherwise, it's impossible to have n sub-problems each with difficulty at least 1.

So, if x < n, it's impossible, but according to the problem, inputs are valid, so x >= n.

Given that, d must be a divisor of x, and we need to choose d as large as possible.

But we also need to ensure that it's possible to have n sub-problems with difficulty being multiples of d, summing up to x.

Let’s denote d as the GCD.

Then, each ai is a multiple of d, say ai = d * bi, where bi are positive integers.

Then, the sum becomes d*(b1 + b2 + ... + bn) = x.

So, d must divide x, and b1 + b2 + ... + bn = x/d.

Now, since each bi >=1, the sum b1 + b2 + ... + bn >= n.

But x/d must be at least n, because b1 + b2 + ... + bn = x/d.

So, x/d >= n.

Therefore, d <= x/n.

Also, d must be a divisor of x.

So, to maximize d, we need to find the largest divisor of x that is less than or equal to x/n.

That makes sense.

So, the approach is:

- Find all divisors of x.

- Find the largest divisor d such that d <= x/n.

- That's the maximum possible GCD.

Let's verify this with the examples.

First test case:

x = 10, n = 3

Divisors of 10: 1, 2, 5, 10

x/n = 10/3 ≈ 3.333

So, the largest divisor <=3 is 2.

Which matches the answer.

Second test case:

x = 5, n =5

Divisors of 5: 1,5

x/n =5/5=1

So, the largest divisor <=1 is 1.

Which matches the answer.

Third test case:

x=420, n=69

Divisors of 420: 1, 2, 3, 4, 5, 6, 7, 10, 12, 14, 15, 20, 21, 28, 30, 35, 42, 60, 70, 84, 105, 140, 210, 420.

x/n =420/69 ≈ 6.087

So, the largest divisor <=6 is 6.

Which matches the answer.

Great, this seems correct.

Now, how to implement this efficiently, especially since x can be up to 10^8 and t can be up to 10^3.

Finding all divisors of x for each test case could be time-consuming if done naively.

I need an efficient way to find all divisors of x up to floor(x/n).

An optimized approach is needed.

Let’s think about how to find all divisors of x efficiently.

I know that divisors of x come in pairs.

For example, if d is a divisor of x, then x/d is also a divisor.

So, I can iterate from 1 to sqrt(x), and for each i, if i divides x, then both i and x/i are divisors.

Then, among these, I need to find the largest d such that d <= floor(x/n).

So, in code, for each test case, I need to:

- Read x and n.

- If n > x, it's impossible because each ai >=1, so sum would be at least n.

But according to the problem, inputs are valid, so x >=n.

- Find all divisors of x.

- Find the largest d among these divisors where d <= floor(x/n).

- Print d.

To optimize, I need an efficient way to find divisors of x.

Let’s think about the implementation.

I can write a function to find all divisors of x.

But since t can be up to 10^3 and x up to 10^8, I need to make sure it's optimized.

Iterating up to sqrt(x) is efficient enough, since sqrt(10^8) is 10^4, which is acceptable.

So, for each test case, I can:

- Read x and n.

- Compute max_d = floor(x/n).

- Find all divisors d of x where d <= max_d.

- Among these, choose the maximum d.

That should work.

Looking back at the given code:

from math import *

tc = int(input())

for _ in range(tc):

func_1()

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

elif n <= i:

ans = max(ans, x // i)

print(ans)

Let's analyze this code.

It seems to be implementing the logic we just discussed.

It iterates from 1 to sqrt(x), checks if i is a divisor of x.

If i is a divisor, it checks:

- If n <= x // i, it sets ans to max(ans, i)

- Else if n <= i, it sets ans to max(ans, x // i)

Wait, this seems a bit confusing.

Let me think.

We need d <= floor(x/n), right?

So, for each divisor i:

- If i <= floor(x/n), then consider i.

- Also, x/i is a divisor.

- If x/i <= floor(x/n), then consider x/i.

But I need to make sure that I'm choosing the correct one.

Let me take an example.

Take x=10, n=3

floor(x/n)=3

Divisors:1,2,5,10

So, among these, 1 and 2 are <=3.

So, ans should be 2.

In the code:

for i in 1,2 (since sqrt(10)=3.162, int is 3, but range is 1 to 4)

i=1:

x%1==0 -> n=3 <= x//i=10//1=10 -> ans=max(0,1)=1

i=2:

x%2==0 -> n=3 <= x//2=5 -> ans=max(1,2)=2

i=3:

x%3!=0 -> skip

So, ans=2, which is correct.

Another example: x=5,n=5

floor(x/n)=1

Divisors:1,5

Only 1 <=1, so ans=1

Code:

i=1:

x%1==0 -> n=5 <= x//1=5 -> ans=max(0,1)=1

i=2:

x%2!=0 -> skip

i=3:

x%3!=0 -> skip

i=4:

x%4!=0 -> skip

i=5:

x%5==0 -> n=5 <= x//5=1? No, because 5<=1 is False.

So, ans=1, which is correct.

Third example: x=420,n=69

floor(x/n)=6

Divisors:1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420

Among these, the largest <=6 is 6.

In the code:

for i from 1 to isqrt(420)=20.49, so up to 21

Check i=1 to 21:

i=1: x%1==0 -> n=69 <= x//1=420 -> ans=max(0,1)=1

i=2: x%2==0 -> n=69 <= x//2=210 -> ans=max(1,2)=2

...

i=6: x%6==0 -> n=69 <= x//6=70 -> ans=max(2,6)=6

i=7: x%7==0 -> n=69 <= x//7=60? 69<=60 is False.

So, no update.

i=10: x%10==0 -> n=69 <= x//10=42? 69<=42 is False.

i=12: x%12==0 -> n=69 <= x//12=35? 69<=35 is False.

i=14: x%14==0 -> n=69 <= x//14=30? 69<=30 is False.

i=15: x%15==0 -> n=69 <= x//15=28? 69<=28 is False.

i=20: x%20==0 -> n=69 <= x//20=21? 69<=21 is False.

i=21: x%21==0 -> n=69 <= x//21=20? 69<=20 is False.

So, ans=6, which is correct.

Seems like the code is correctly implementing the logic.

But let's see if there's any edge case where it might fail.

Consider x=1, n=1

Divisors of 1:1

floor(x/n)=1

So, ans=1

Code:

i=1: x%1==0 -> n=1 <= x//1=1 -> ans=max(0,1)=1

Correct.

Another case: x=1, n=1

Only possibility.

Another case: x=2, n=1

Divisors:1,2

floor(2/1)=2

So, ans=2

Code:

i=1: x%1==0 -> n=1 <=2 -> ans=1

i=2: x%2==0 -> n=1 <=1 -> ans=2

Correct.

Another case: x=2, n=2

floor(2/2)=1

Divisors:1,2

Only 1 <=1

So, ans=1

Code:

i=1: x%1==0 -> n=2 <=2 -> ans=1

i=2: x%2==0 -> n=2 <=1 -> no update

So, ans=1

Correct.

Seems solid.

Another consideration: When x is divisible by n.

For example, x=10, n=5

floor(10/5)=2

Divisors:1,2,5,10

Possible d=1,2

So, ans=2

Because:

Subproblems: 2,2,2,2,2 -> sum=10, GCD=2

Or 1,2,3,4,0 -> invalid, as ai must be positive.

So, must be 2,2,2,2,2.

Yes.

Another case: x=8, n=4

floor(8/4)=2

Divisors:1,2,4,8

Possible d=1,2

But, can have subproblems:2,2,2,2 -> GCD=2

Or 1,1,3,3 -> GCD=1

So, ans=2

Code:

i=1: n=4 <=8 -> ans=1

i=2: n=4 <=4 -> ans=2

i=4: n=4 <=2? No

i=8: n=4 <=1? No

So, ans=2

Correct.

Seems like the code is correct.

Time constraints:

t <=10^3, x <=10^8

For each test case, iterating up to sqrt(x), which is up to 10^4, so total operations are around 10^7, which is acceptable.

Hence, the given code is correct and efficient enough.

**Final Answer**

\[ \boxed{2} \]