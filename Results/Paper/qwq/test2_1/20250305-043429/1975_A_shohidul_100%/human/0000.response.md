Alright, I have this problem to solve. Let's see what it's asking for. So, Mocha has an array of positive integers, and she can perform this specific operation on it any number of times. The operation is to split the array into a prefix and a suffix, swap them, and concatenate them back together. For example, if the array is [3,1,4,1,5], she can choose prefix [3,1] and suffix [4,1,5], swap them to get [4,1,5,3,1]. The goal is to determine whether, after performing this operation any number of times, the array can become sorted in non-decreasing order.

First, I need to understand the operation clearly. The operation allows splitting the array at any index i, taking the first i elements as prefix x and the remaining as suffix y, and then swapping them to get y + x. For example, with n=5 and array [1,2,3,4,5], if I choose i=2, x=[1,2], y=[3,4,5], swapping gives [3,4,5,1,2]. I can perform this operation multiple times.

I need to figure out if, by doing this operation any number of times, I can make the array sorted in non-decreasing order.

Let me think about what this operation does. Swapping prefix and suffix is similar to rotating the array. In fact, it's equivalent to rotating the array left or right by certain positions. For example, rotating left by i positions is like taking the first i elements as prefix and the rest as suffix, then swapping.

Wait, but in rotation, each rotation moves the elements in a circular fashion, whereas here, swapping prefix and suffix is a different operation. In rotation, shifting left by one would change [1,2,3,4,5] to [2,3,4,5,1], whereas swapping prefix x=[1,2] and suffix y=[3,4,5] gives [3,4,5,1,2], which is not the same as a single rotation.

Actually, swapping prefix and suffix is similar to reversing a window in the array, but not exactly. It's more like exchanging two blocks.

I need to see if repeated such operations can sort the array.

Let me consider the properties of this operation. Each operation is reversible because swapping prefix and suffix again would bring back the original array. So, the operations form a group of permutations.

But maybe I don't need to go that deep.

Let me consider small examples to see a pattern.

Take n=2, array [2,1]. If I swap prefix [2] and suffix [1], I get [1,2], which is sorted. So, in this case, one operation is enough.

Another n=3, array [3,1,2]. If I swap prefix [3] and suffix [1,2], I get [1,2,3], which is sorted. So again, one operation suffices.

Another example from the problem: n=6, [1,1,4,5,1,4]. The answer is 'No', meaning no matter how many operations I perform, I can't sort it.

Wait, why is that? Let's see.

If I try to swap prefix [1,1,4] and suffix [5,1,4], I get [5,1,4,1,1,4]. Not sorted.

If I swap prefix [1,1] and suffix [4,5,1,4], I get [4,5,1,4,1,1]. Not sorted.

If I swap prefix [1] and suffix [1,4,5,1,4], I get [1,4,5,1,4,1]. Not sorted.

Seems like no matter how I split and swap, I can't get it sorted.

Another test case: n=5, [7,9,2,2,3]. The explanation says that by swapping x=[7] and y=[9,2,2,3], we get [9,2,2,3,7], and then swapping x=[9] and y=[2,2,3,7], we get [2,2,3,7,9], which is sorted.

So, in this case, two operations are enough to sort the array.

Another test case: n=3, [1,2,3], already sorted, so 'Yes'.

From these examples, it seems that if the array is already sorted, answer is 'Yes'. If not, we need to check if it can be sorted by swapping prefix and suffix.

But the problem allows performing this operation any number of times, so it's not just one swap.

I need to find a way to check if, through a series of such swaps, I can sort the array.

Let me think about the properties of these operations.

Each operation is swapping a prefix and a suffix, and since the array is split into prefix and suffix, and they are swapped, it's like reversing a substring, but not exactly.

Wait, it's not reversing, it's swapping.

For example, in [1,2,3,4,5], swapping prefix [1,2] and suffix [3,4,5] gives [3,4,5,1,2]. It's like rotating, but not a standard rotation.

I need to see if repeated such operations can achieve a sorted array.

Maybe I can think in terms of permutation groups. Each operation is a permutation of the array, and repeated operations generate a group of permutations.

But that might be too complicated for this problem.

Let me consider the sorted version of the array and see if it can be reached from the original array using these operations.

Wait, but sorting is a specific permutation, and I need to see if it's achievable through these operations.

Alternatively, maybe I can look for some invariant that remains unchanged through these operations, and check if the sorted array satisfies that invariant.

An invariant is something that doesn't change under the operation.

For example, in bubble sort, the number of inversions changes in a specific way.

But here, the operation is swapping prefix and suffix.

Let me see what happens to the array when I perform this operation.

Suppose I have array a = [a1, a2, ..., an].

I choose to split at position i, so x = [a1, a2, ..., ai], y = [ai+1, ..., an], and swap to get y + x = [ai+1, ..., an, a1, a2, ..., ai].

So, it's like rotating the array to the left by i positions.

Wait, no. Rotating left by i positions would be moving the first i elements to the end, in the same order.

But here, it's swapping prefix and suffix, which is different.

For example, with n=4, a=[1,2,3,4], splitting at i=2, x=[1,2], y=[3,4], swapping gives [3,4,1,2].

Rotating left by 2 would give [3,4,1,2], which matches this operation.

So, in this case, the operation is equivalent to rotating left by i positions.

But wait, in general, is it always equivalent to rotating left by i positions?

Wait, in rotation, the elements are shifted circularly, whereas in this operation, it's swapping prefix and suffix.

In the example above, it matches rotation left by i, but let's check another example.

Take n=5, a=[1,2,3,4,5], split at i=1, x=[1], y=[2,3,4,5], swap to get [2,3,4,5,1]. This is same as rotating left by 1.

Another split at i=3, x=[1,2,3], y=[4,5], swap to get [4,5,1,2,3]. This is same as rotating left by 3.

So, it seems that swapping prefix of length i and suffix of length n-i is equivalent to rotating the array left by i positions.

Therefore, this operation is equivalent to rotating the array left by i positions, for any i from 0 to n.

Wait, i can be from 0 to n-1, since prefix can be empty to entire array except last element.

But rotating left by 0 positions keeps the array as is, and rotating left by n positions also keeps it as is.

So, performing this operation is equivalent to rotating the array in steps of i positions.

But in the problem, they allow any number of operations, so we can perform rotations multiple times.

But since rotating left by i and then rotating left by j is equivalent to rotating left by (i+j) mod n, then any sequence of rotations can be reduced to a single rotation.

Wait, but in this problem, the operation is to choose any i and rotate left by i, not fixed i.

So, if I can rotate left by any i, then I can generate any cyclic shift of the array.

But sorting the array requires that the elements are in non-decreasing order.

So, if the array can be sorted by some rotation, then the answer is 'Yes'.

But in the first test case, n=6, a=[1,1,4,5,1,4], and it's said that it's 'No', meaning that no rotation can sort it.

Let me check if any rotation can sort it.

Let's list all possible rotations:

Original: [1,1,4,5,1,4]

Rotate left by 1: [1,4,5,1,4,1]

Rotate left by 2: [4,5,1,4,1,1]

Rotate left by 3: [5,1,4,1,1,4]

Rotate left by 4: [1,4,1,1,4,5]

Rotate left by 5: [4,1,1,4,5,1]

None of these are sorted in non-decreasing order.

So, indeed, 'No'.

In the second test case, n=5, a=[7,9,2,2,3].

Possible rotations:

Original: [7,9,2,2,3]

Rotate left by 1: [9,2,2,3,7]

Rotate left by 2: [2,2,3,7,9] â€” this is sorted.

So, 'Yes'.

In the third test case, n=3, a=[1,2,3], already sorted, so 'Yes'.

So, it seems that the problem reduces to checking if there exists a rotation of the array that is sorted in non-decreasing order.

In other words, check if the array is a rotation of a sorted array.

This is a standard problem in array manipulation.

So, to solve this, I can check if the array is sorted, and if not, check if it's a rotation of a sorted array.

But how to efficiently check if an array is a rotation of a sorted array?

One way is to find the minimum element in the array and see if the array is sorted in non-decreasing order starting from that element.

For example, in the second test case, [7,9,2,2,3], the minimum element is 2. If I start from the first 2, the array becomes [2,2,3,7,9], which is sorted.

In the first test case, [1,1,4,5,1,4], the minimum element is 1. Starting from the first 1, it's [1,1,4,5,1,4], which is not fully sorted. Starting from the second 1, it's [1,4,5,1,4,1], not sorted. Starting from the third 1, it's [1,4,1,4,1,1], not sorted. So, 'No'.

This seems to work.

So, the algorithm is:

1. Find the minimum element in the array.

2. Find all positions where this minimum element occurs.

3. For each such position, check if the array is sorted in non-decreasing order when starting from that position.

4. If any such rotation is sorted, output 'Yes'; otherwise, 'No'.

This should work because if the array is a rotation of a sorted array, there must be at least one rotation where it is sorted.

Now, let's look at the provided program and see if it implements this logic correctly.

The program is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

check_all = all([a[i - 1] <= a[i] for i in range(1, n)])

if check_all:

print('YES')

else:

for i in range(1, n):

if a[i - 1] > a[i]:

new = a[i:]

check_all_new = all([a[0] >= new[i] for i in range(len(new))])

new_all = all([new[i - 1] <= new[i] for i in range(1, len(new))])

if check_all_new and new_all:

print('YES')

break

else:

print('NO')

break

So, it first checks if the array is already sorted. If yes, prints 'YES'.

If not, it iterates through the array, finds the first position where a[i-1] > a[i], and then checks some conditions on the suffix starting from that position.

Specifically, it takes the suffix starting from position i, checks if it's sorted, and also checks if the first element of the array is greater than or equal to all elements in this suffix.

If both conditions are satisfied, it prints 'YES'; otherwise, 'NO'.

Wait, but in the earlier approach I thought about finding the minimum element and checking rotations starting from its positions.

Is this program doing something similar?

Let me see.

In the second test case, [7,9,2,2,3], the first position where a[i-1] > a[i] is i=2 (9 > 2).

Then, it takes the suffix starting from i=2, which is [2,2,3], checks if it's sorted (which it is), and checks if a[0] >= all elements in this suffix. a[0]=7 >= 2,2,3, which is true. So, 'YES'.

In the first test case, [1,1,4,5,1,4], the first position where a[i-1] > a[i] is i=5 (5 > 1).

Then, suffix starting from i=5 is [1,4], which is sorted, and a[0]=1 >=1 and 1>=4 is false, so check_all_new is False, so 'NO'.

Which matches the expected output.

In the third test case, [1,2,3], already sorted, so 'YES'.

So, it seems to work for these cases.

But is this logic general?

Let me think about another example.

Suppose n=4, a=[2,2,1,1]. The minimum element is 1, and rotations starting from the positions of 1 are [1,1,2,2] and [1,2,2,1].

Only the first rotation [1,1,2,2] is sorted.

According to the program, it would find the first position where a[i-1] > a[i], which is i=2 (2>1).

Then, suffix starting from i=2 is [1,1], which is sorted, and a[0]=2 >=1 and 2>=1, so 'YES', which is correct.

Another example: n=4, a=[3,4,5,1,2]. The minimum element is 1, and rotation starting from 1 is [1,2,3,4,5], which is sorted.

The program would find a[3]=5 > a[4]=1, so i=4.

Then, suffix starting from i=4 is [2], which is sorted, and a[0]=3 >=2, so 'YES'.

But wait, in this case, n=5, a=[3,4,5,1,2], and rotation to [1,2,3,4,5] is possible.

But in the first test case, n=6, a=[1,1,4,5,1,4], rotation to [1,1,1,4,5,4], which is not sorted, and other rotations are not sorted either.

So, the program seems to correctly identify such cases.

But I need to make sure that this logic is correct in general.

Let me try to understand why this logic works.

So, the program looks for the first descent in the array, i.e., the first position i where a[i-1] > a[i].

Then, it takes the suffix starting from position i and checks two things:

1. The suffix is sorted in non-decreasing order.

2. The first element of the array is greater than or equal to all elements in this suffix.

If both are true, it prints 'YES'; otherwise, 'NO'.

Why does this work?

Well, if such a position i exists, and the suffix is sorted and the first element is greater than or equal to all elements in the suffix, then swapping the prefix and suffix would result in the suffix coming first, followed by the prefix.

Since the suffix is sorted and the prefix elements are all greater than or equal to the suffix elements, the combined array would be sorted.

Wait, but in the operation described, we are swapping prefix x and suffix y, where a = x + y, and after swapping, it becomes y + x.

So, if y is sorted and all elements in x are greater than or equal to all elements in y, then y + x would be sorted.

Yes, that makes sense.

But, in the operation, we can perform this swap any number of times.

The program only checks one such swap, but allows multiple operations.

Wait, but in the example given in the problem, they performed two operations to sort the array.

So, does this program account for multiple operations?

In the program, it only checks one possible swap that can sort the array.

But in the problem, multiple operations might be needed.

Wait, but in the problem's second test case, they performed two operations to sort the array.

However, in the program, it seems to check only one operation.

But in that case, the program would find i=1 (7 > 9), take suffix [9,2,2,3], which is not sorted, so check_all_new would be False (since 9 > 2), so it would print 'NO', which contradicts the sample output 'YES'.

Wait, but in the sample input, for the second test case, it's 'YES', but according to this program, it should print 'NO', which is incorrect.

Wait, maybe I'm misunderstanding the program.

Let me look again.

In the second test case, n=5, a=[7,9,2,2,3].

The program iterates through i from 1 to 5.

At i=1: a[0]=7 <= a[1]=9, so no descent.

At i=2: a[1]=9 > a[2]=2, so descent found.

Then, new = a[2:] = [2,2,3].

check_all_new = all([a[0] >= new[i] for i in range(len(new))]) = all([7 >= 2, 7 >= 2, 7 >= 3]) = True.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) = all([2 <= 2, 2 <= 3]) = True.

So, both conditions are True, so it prints 'YES'.

Wait, in my earlier thought process, I mistakenly thought that [9,2,2,3] is the suffix, but actually, for i=2, suffix is a[2:] = [2,2,3].

So, yes, the program correctly identifies it as 'YES'.

So, it does work for that case.

Another example: n=4, a=[3,4,5,1,2].

As I thought earlier, at i=4, a[3]=5 > a[4]=1.

new = a[4:] = [2], which is sorted, and a[0]=3 >=2, so 'YES'.

So, it seems to work.

But is this always correct?

Let me think about an array that requires more than one operation to sort.

Suppose n=6, a=[4,5,6,1,2,3].

First, find the first descent at i=4 (6>1).

Then, new = a[4:] = [1,2,3], which is sorted, and a[0]=4 >=1,2,3, so 'YES'.

Indeed, rotating left by 3 positions gives [1,2,3,4,5,6], which is sorted.

So, it works.

Another example: n=5, a=[2,3,1,1,2].

First descent at i=2 (3>1).

new = a[2:] = [1,1,2], which is sorted, and a[0]=2 >=1,1,2, so 'YES'.

Rotation would be [1,1,2,2,3], which is sorted.

Good.

But what if the array has multiple descents?

Suppose n=5, a=[2,3,1,4,5].

First descent at i=3 (3>1).

new = a[3:] = [4,5], which is sorted, and a[0]=2 >=4? No, 2 >=4 is False, so 'NO'.

Indeed, no rotation can sort this array.

Because the array is [2,3,1,4,5], and possible rotations:

Original: [2,3,1,4,5]

Rotate left by 1: [3,1,4,5,2]

Rotate left by 2: [1,4,5,2,3]

Rotate left by 3: [4,5,2,3,1]

Rotate left by 4: [5,2,3,1,4]

None of these are sorted, so 'NO' is correct.

So, the program seems to be working correctly for these cases.

But is there any case where the program might give a wrong answer?

Let me think about an array that requires more than one operation to sort.

Take n=4, a=[3,4,1,2].

First descent at i=3 (4>1).

new = a[3:] = [2], which is sorted, and a[0]=3 >=2, so 'YES'.

But let's see possible rotations:

Original: [3,4,1,2]

Rotate left by 1: [4,1,2,3]

Rotate left by 2: [1,2,3,4] â€” sorted.

So, 'YES' is correct.

In this case, one operation doesn't sort it, but two operations do.

But the program only checks one operation, yet it still says 'YES'.

Wait, in this case, the program finds i=3, new=[2], which is sorted, and 3 >=2, so 'YES'.

So, it correctly identifies that it can be sorted with multiple operations.

So, perhaps checking one such swap is sufficient to determine if it can be sorted, even if multiple operations are needed.

Another example: n=5, a=[5,1,2,3,4].

First descent at i=1 (5>1).

new = a[1:] = [1,2,3,4], which is sorted, and a[0]=5 >=1,2,3,4, so 'YES'.

Indeed, rotating left by 1 gives [1,2,3,4,5], which is sorted.

So, 'YES' is correct.

Seems consistent.

But what if there are multiple descents?

Take n=6, a=[4,5,2,3,1,2].

First descent at i=3 (5>2).

new = a[3:] = [3,1,2], which is not sorted, so 'NO'.

But let's check possible rotations:

Original: [4,5,2,3,1,2]

Rotate left by 1: [5,2,3,1,2,4]

Rotate left by 2: [2,3,1,2,4,5]

Rotate left by 3: [3,1,2,4,5,2]

Rotate left by 4: [1,2,4,5,2,3]

Rotate left by 5: [2,4,5,2,3,1]

None of these are sorted, so 'NO' is correct.

So, again, the program gives the correct answer.

Another test case: n=5, a=[1,3,2,4,5].

First descent at i=2 (3>2).

new = a[2:] = [2,4,5], which is sorted, and a[0]=1 >=2? No, 1 >=2 is False, so 'NO'.

Indeed, possible rotations:

Original: [1,3,2,4,5]

Rotate left by 1: [3,2,4,5,1]

Rotate left by 2: [2,4,5,1,3]

Rotate left by 3: [4,5,1,3,2]

Rotate left by 4: [5,1,3,2,4]

None of these are sorted, so 'NO' is correct.

So, the program seems to be working correctly for these cases.

But is there any case where the program might give a wrong answer?

Let me think about an array that can be sorted with multiple operations, but the program's single check would fail.

Suppose n=6, a=[3,4,5,1,2,3].

First descent at i=4 (5>1).

new = a[4:] = [1,2,3], which is sorted, and a[0]=3 >=1,2,3, so 'YES'.

Indeed, rotating left by 3 positions gives [1,2,3,3,4,5], which is sorted.

So, 'YES' is correct.

Another case: n=5, a=[2,3,1,2,2].

First descent at i=3 (3>1).

new = a[3:] = [2,2], which is sorted, and a[0]=2 >=2,2, so 'YES'.

Rotation left by 2 positions: [1,2,2,2,3], which is sorted.

So, 'YES' is correct.

Seems consistent.

Wait, what if the array has multiple descents, but the suffix is sorted and a[0] >= all elements in the suffix?

For example, n=6, a=[3,1,2,4,5,1].

First descent at i=2 (1>2)? Wait, 3>1 is descent at i=2.

new = a[2:] = [2,4,5,1], which is not sorted, so 'NO'.

Indeed, possible rotations:

Original: [3,1,2,4,5,1]

Rotate left by 1: [1,2,4,5,1,3]

Rotate left by 2: [2,4,5,1,3,1]

Rotate left by 3: [4,5,1,3,1,2]

Rotate left by 4: [5,1,3,1,2,4]

Rotate left by 5: [1,3,1,2,4,5]

None of these are sorted, so 'NO' is correct.

Another case: n=5, a=[1,2,3,2,2].

First descent at i=4 (3>2).

new = a[4:] = [2,2], which is sorted, and a[0]=1 >=2? No, so 'NO'.

Indeed, possible rotations:

Original: [1,2,3,2,2]

Rotate left by 1: [2,3,2,2,1]

Rotate left by 2: [3,2,2,1,2]

Rotate left by 3: [2,2,1,2,3]

Rotate left by 4: [2,1,2,3,2]

None are sorted, so 'NO' is correct.

So, the program seems to be correctly identifying whether the array can be sorted with the given operations.

Therefore, I conclude that the given program is correct.

**Final Answer**

\[ \boxed{\text{Correct}} \]

