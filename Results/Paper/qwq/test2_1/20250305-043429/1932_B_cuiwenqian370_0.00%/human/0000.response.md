Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign appears every a_i years. The signs have to occur sequentially, meaning that after the first sign appears, we start waiting for the second sign in the next year after the first one appeared, and so on.

Okay, so I need to find out in which year the nth sign will occur, considering this sequential dependency.

Let me try to understand this with the first example provided:

Input:

6

3 2 4 5 9 18

Output:

36

So, there are 6 signs with periods 3, 2, 4, 5, 9, and 18 years.

Let's see:

- The first sign occurs every 3 years: years 3, 6, 9, 12, etc.

- After the first sign occurs, say in year 3, we start waiting for the second sign in year 4.

- The second sign occurs every 2 years: years 2, 4, 6, 8, etc. But since we start waiting from year 4, the next occurrence is in year 4.

- After the second sign in year 4, we start waiting for the third sign in year 5.

- The third sign occurs every 4 years: years 4, 8, 12, etc. The next occurrence after year 5 is in year 8.

- After the third sign in year 8, we start waiting for the fourth sign in year 9.

- The fourth sign occurs every 5 years: years 5, 10, 15, etc. The next occurrence after year 9 is in year 10.

- After the fourth sign in year 10, we start waiting for the fifth sign in year 11.

- The fifth sign occurs every 9 years: years 9, 18, 27, etc. The next occurrence after year 11 is in year 18.

- After the fifth sign in year 18, we start waiting for the sixth sign in year 19.

- The sixth sign occurs every 18 years: years 18, 36, 54, etc. The next occurrence after year 19 is in year 36.

So, the nth sign, which is the sixth sign, occurs in year 36.

That makes sense. Now, I need to generalize this for any n and any list of a_i.

Let me think about how to approach this.

I need to keep track of the year when each sign occurs, considering that we start waiting for the next sign immediately after the previous one.

So, for each sign, I need to find the smallest year that is greater than the year when the previous sign occurred, and is a multiple of its period.

Wait, not exactly a multiple, but rather a year where the sign occurs, which is at years that are multiples of its period.

Wait, more precisely, the sign i occurs in years that are multiples of a_i, i.e., a_i, 2*a_i, 3*a_i, etc.

Given that, for each sign, I need to find the smallest year that is greater than the year when the previous sign occurred, and is a multiple of a_i.

So, for sign i, find the smallest year y such that y > year when sign i-1 occurred, and y is a multiple of a_i.

Then, set the year for sign i to be y.

Repeat this for all signs from 1 to n.

Finally, the year when the nth sign occurs is the answer.

Okay, that seems straightforward.

Now, how do I implement this efficiently, especially considering that n can be up to 100 and a_i can be up to 10^6.

I need to handle up to 1000 test cases, each with up to 100 signs.

So, time efficiency is important.

Let's think about how to find the smallest y > prev_year where y is a multiple of a_i.

Well, for any a_i, the smallest multiple of a_i that is greater than prev_year is ceil(prev_year / a_i + 1) * a_i.

Alternatively, y = ((prev_year // a_i) + 1) * a_i.

This will give the smallest y that is a multiple of a_i and greater than prev_year.

Perfect, that's efficient.

So, for each test case, I can iterate through the signs, maintaining the current year where the previous sign occurred.

For each sign, calculate the next occurrence year using the above formula, and update the current year to that value.

Finally, output the year for the nth sign.

Let me verify this with the first example.

Test case 1:

n = 6

a = [3, 2, 4, 5, 9, 18]

Initialize prev_year = 0

For sign 1:

y = ((0 // 3) + 1) * 3 = (0 + 1) * 3 = 3

Set prev_year = 3

For sign 2:

y = ((3 // 2) + 1) * 2 = (1 + 1) * 2 = 4

Set prev_year = 4

For sign 3:

y = ((4 // 4) + 1) * 4 = (1 + 1) * 4 = 8

Set prev_year = 8

For sign 4:

y = ((8 // 5) + 1) * 5 = (1 + 1) * 5 = 10

Set prev_year = 10

For sign 5:

y = ((10 // 9) + 1) * 9 = (1 + 1) * 9 = 18

Set prev_year = 18

For sign 6:

y = ((18 // 18) + 1) * 18 = (1 + 1) * 18 = 36

Set prev_year = 36

Output: 36

Matches the example.

Let's check another example.

Test case 2:

n = 5

a = [1, 2, 3, 4, 5]

Initialize prev_year = 0

For sign 1:

y = ((0 // 1) + 1) * 1 = (0 + 1) * 1 = 1

Set prev_year = 1

For sign 2:

y = ((1 // 2) + 1) * 2 = (0 + 1) * 2 = 2

Set prev_year = 2

For sign 3:

y = ((2 // 3) + 1) * 3 = (0 + 1) * 3 = 3

Set prev_year = 3

For sign 4:

y = ((3 // 4) + 1) * 4 = (0 + 1) * 4 = 4

Set prev_year = 4

For sign 5:

y = ((4 // 5) + 1) * 5 = (0 + 1) * 5 = 5

Set prev_year = 5

Output: 5

Matches the example.

Test case 3:

n = 5

a = [1, 1, 1, 1, 1]

Initialize prev_year = 0

For sign 1:

y = ((0 // 1) + 1) * 1 = 1

Set prev_year = 1

For sign 2:

y = ((1 // 1) + 1) * 1 = (1 + 1) * 1 = 2

Set prev_year = 2

For sign 3:

y = ((2 // 1) + 1) * 1 = (2 + 1) * 1 = 3

Set prev_year = 3

For sign 4:

y = ((3 // 1) + 1) * 1 = (3 + 1) * 1 = 4

Set prev_year = 4

For sign 5:

y = ((4 // 1) + 1) * 1 = (4 + 1) * 1 = 5

Set prev_year = 5

Output: 5

Matches the example.

Test case 4:

n = 6

a = [50, 30, 711, 200, 503, 1006]

Initialize prev_year = 0

For sign 1:

y = ((0 // 50) + 1) * 50 = (0 + 1) * 50 = 50

Set prev_year = 50

For sign 2:

y = ((50 // 30) + 1) * 30 = (1 + 1) * 30 = 60

Set prev_year = 60

For sign 3:

y = ((60 // 711) + 1) * 711 = (0 + 1) * 711 = 711

Set prev_year = 711

For sign 4:

y = ((711 // 200) + 1) * 200 = (3 + 1) * 200 = 800

Set prev_year = 800

For sign 5:

y = ((800 // 503) + 1) * 503 = (1 + 1) * 503 = 1006

Set prev_year = 1006

For sign 6:

y = ((1006 // 1006) + 1) * 1006 = (1 + 1) * 1006 = 2012

Set prev_year = 2012

Output: 2012

Matches the example.

Seems correct.

Now, let's think about edge cases.

Edge case 1: n = 1

If n = 1, then the apocalypse happens in year a_1.

For example:

n = 1

a = [10]

Then, output should be 10.

Edge case 2: n = 2, a = [1, 1]

Initialize prev_year = 0

For sign 1: y = 1, prev_year = 1

For sign 2: y = 2, prev_year = 2

Output: 2

Edge case 3: n = 2, a = [2, 2]

Initialize prev_year = 0

For sign 1: y = 2, prev_year = 2

For sign 2: y = 4, prev_year = 4

Output: 4

Edge case 4: n = 3, a = [2, 3, 4]

Initialize prev_year = 0

For sign 1: y = 2, prev_year = 2

For sign 2: y = 3, prev_year = 3

For sign 3: y = 4, prev_year = 4

Output: 4

Edge case 5: n = 3, a = [3, 2, 4]

Initialize prev_year = 0

For sign 1: y = 3, prev_year = 3

For sign 2: y = 4, prev_year = 4

For sign 3: y = 4, prev_year = 4

Wait, y = ((4 // 4) + 1) * 4 = (1 + 1) * 4 = 8

Wait, no. The third sign occurs at years 4, 8, 12, etc.

But the previous sign occurred in year 4, so we start waiting from year 5.

So, the next occurrence after year 4 is year 8.

Wait, but according to the formula:

y = ((prev_year // a_i) + 1) * a_i

With prev_year = 4, a_i = 4:

y = ((4 // 4) + 1) * 4 = (1 + 1) * 4 = 8

So, prev_year = 8

Output: 8

Seems correct.

Another edge case: n = 2, a = [1, 1000000]

Initialize prev_year = 0

For sign 1: y = 1, prev_year = 1

For sign 2: y = ((1 // 1000000) + 1) * 1000000 = (0 + 1) * 1000000 = 1000000

Set prev_year = 1000000

Output: 1000000

Seems correct.

Another edge case: n = 2, a = [1000000, 1]

Initialize prev_year = 0

For sign 1: y = 1000000, prev_year = 1000000

For sign 2: y = ((1000000 // 1) + 1) * 1 = (1000000 + 1) * 1 = 1000001

Set prev_year = 1000001

Output: 1000001

Seems correct.

Another edge case: n = 2, a = [2, 1]

Initialize prev_year = 0

For sign 1: y = 2, prev_year = 2

For sign 2: y = ((2 // 1) + 1) * 1 = (2 + 1) * 1 = 3

Set prev_year = 3

Output: 3

Seems correct.

Another edge case: n = 2, a = [1, 2]

Initialize prev_year = 0

For sign 1: y = 1, prev_year = 1

For sign 2: y = ((1 // 2) + 1) * 2 = (0 + 1) * 2 = 2

Set prev_year = 2

Output: 2

Seems correct.

Another edge case: n = 1, a = [1]

Initialize prev_year = 0

For sign 1: y = 1, prev_year = 1

Output: 1

Seems correct.

Another edge case: n = 1, a = [1000000]

Initialize prev_year = 0

For sign 1: y = 1000000, prev_year = 1000000

Output: 1000000

Seems correct.

Okay, seems like the approach is solid.

Now, let's think about the implementation.

I need to read t test cases, each consisting of n and then a list of n integers a_i.

For each test case, I need to compute the year when the nth sign occurs, as described.

I need to be careful with the input reading, making sure that I read the correct number of elements for each test case.

Also, since t can be up to 1000 and n up to 100, efficiency should not be a problem.

I need to make sure that I handle the input correctly, especially since all test cases are provided in a single input string.

I should read all input at once and then process it accordingly.

In Python, I can read all input using sys.stdin.read(), split it into tokens, and then process them one by one.

I need to keep track of the current index in the list of tokens and advance it as I process each test case.

I should also make sure that I don't have any off-by-one errors in indexing.

Now, let's think about the implementation in code.

First, read all input:

import sys

data = sys.stdin.read().split()

Then, read the number of test cases t = int(data[0])

Then, for each test case, read n = int(data[index])

Then read the next n elements as a list a = list(map(int, data[index+1:index+1+n]))

Then, compute the year when the nth sign occurs.

Initialize prev_year = 0

For each a_i in a:

y = ((prev_year // a_i) + 1) * a_i

prev_year = y

Finally, output y for each test case.

I need to make sure that this is implemented correctly.

Also, I should consider the case when a_i = 1, which is handled correctly in the examples above.

Additionally, I need to make sure that there are no divisions by zero, but since a_i >=1 as per the constraints, that's not an issue.

Also, need to ensure that the input is read correctly for all test cases.

Let me think about the implementation step by step.

Initialize index = 1, since data[0] is t.

For each test case:

n = int(data[index])

index +=1

a = [int(data[index + i]) for i in range(n)]

index += n

Then, compute the year:

prev_year = 0

for ai in a:

y = ((prev_year // ai) + 1) * ai

prev_year = y

print(y)

Seems straightforward.

Let me test this logic with the first example:

data = ["4", "6", "3","2","4","5","9","18", "5", "1","2","3","4","5", "5", "1","1","1","1","1", "6", "50","30","711","200","503","1006"]

Processing test case 1:

n=6

a=[3,2,4,5,9,18]

Compute y as above, should get 36.

Processing test case 2:

n=5

a=[1,2,3,4,5]

Compute y as above, should get 5.

Processing test case 3:

n=5

a=[1,1,1,1,1]

Compute y as above, should get 5.

Processing test case 4:

n=6

a=[50,30,711,200,503,1006]

Compute y as above, should get 2012.

All match the example outputs.

Seems correct.

I should also consider the constraints:

- 1 <= t <= 1000

- 1 <= n <= 100

- 1 <= a_i <= 10^6

So, I need to make sure that my code handles large inputs efficiently, but since each test case is processed in O(n) time and n is small (100), it should be fine.

I should also make sure that I don't have any integer overflow issues, but in Python, integers can be arbitrarily large, so that's not a concern.

I should also ensure that I handle the cases where a_i divides prev_year exactly.

For example, if prev_year is a multiple of a_i, then the next occurrence is prev_year + a_i.

But in the formula y = ((prev_year // a_i) + 1) * a_i, if prev_year is a multiple of a_i, then (prev_year // a_i) is an integer, and adding 1 gives the next multiple.

For example, prev_year=10, a_i=5:

y = (10//5 + 1) * 5 = (2 + 1) * 5 = 15

Which is correct, since 10 is already a multiple of 5, so the next occurrence is at 15.

Another example: prev_year=10, a_i=3:

y = (10//3 + 1) * 3 = (3 + 1) * 3 = 12

Which is correct, since 10 is not a multiple of 3, the next multiple is 12.

Seems correct.

I think this approach is solid.

Now, I need to implement this in code.

I need to make sure that I read the input correctly, handling all test cases properly.

Also, I need to make sure that I don't have any off-by-one errors in indexing.

Let me write a small test in code to verify.

Test case 1:

t=4

test_case1:

n=6

a=[3,2,4,5,9,18]

Expected output: 36

test_case2:

n=5

a=[1,2,3,4,5]

Expected output:5

test_case3:

n=5

a=[1,1,1,1,1]

Expected output:5

test_case4:

n=6

a=[50,30,711,200,503,1006]

Expected output:2012

Implementing this in code should yield these outputs.

I should also consider the minimal and maximal values for a_i and n to ensure there are no overflows or performance issues.

Given that a_i can be up to 10^6 and n up to 100, and t up to 1000, it should be manageable in Python.

I should also make sure that I don't use any unnecessary memory, but since the inputs are small, it's not a concern.

I think I've covered all the bases here.

## Final Solution
To solve this problem, we need to determine the year in which the nth sign of the apocalypse occurs, considering that each sign appears periodically and sequentially.

### Approach
1. **Input Structure**:
   - The input consists of multiple test cases.
   - Each test case starts with an integer \( n \) (1 ≤ \( n \) ≤ 100), representing the number of signs.
   - This is followed by \( n \) integers \( a_1, a_2, \ldots, a_n \) (1 ≤ \( a_i \) ≤ 1,000,000), representing the periodicity of each sign.

2. **Sequential Occurrence**:
   - The first sign occurs in year \( a_1 \).
   - For each subsequent sign \( i \) (2 to \( n \)), we wait for the next occurrence of that sign after the year the previous sign occurred.

3. **Calculating Next Occurrence**:
   - For each sign \( i \), calculate the smallest year \( y \) that is greater than the year the previous sign occurred and is a multiple of \( a_i \).
   - This can be computed using the formula: \( y = ((\text{prev\_year} // a_i) + 1) * a_i \).

4. **Output**:
   - For each test case, output the year in which the nth sign occurs.

### Solution Code
```python
def main():
    import sys
    data = sys.stdin.read().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        index += 1
        a = list(map(int, data[index:index + n]))
        index += n
        prev_year = 0
        for ai in a:
            y = ((prev_year // ai) + 1) * ai
            prev_year = y
        print(y)

if __name__ == "__main__":
    main()
```

### Explanation
1. **Reading Input**:
   - Read all input data at once and split it into tokens for easy access.
   - The first token is the number of test cases \( t \).

2. **Processing Each Test Case**:
   - For each test case, read \( n \) and the array \( a \) of size \( n \).
   - Initialize `prev_year` to 0.

3. **Calculating the Year for Each Sign**:
   - For each sign's periodicity \( a_i \), calculate the next occurrence year using the formula \( y = ((\text{prev\_year} // a_i) + 1) * a_i \).
   - Update `prev_year` to this new year \( y \) for the next iteration.

4. **Output the Result**:
   - After processing all signs in a test case, print the year \( y \) when the nth sign occurs.

This approach ensures that we correctly determine the year of the nth sign's occurrence by sequentially calculating the next occurrence of each sign based on the previous one.