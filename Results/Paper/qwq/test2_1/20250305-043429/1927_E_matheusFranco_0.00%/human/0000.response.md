Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given two integers, n and k, with the condition that k is less than or equal to n, and k is even. I need to construct a permutation of length n that is k-level. A k-level permutation is one where, among all the sums of continuous segments of length k, any two sums differ by no more than 1. That means the maximum difference between any two such sums should be at most 1.

First, I need to understand what a permutation is. A permutation of length n is just an arrangement of the numbers from 1 to n in any order, without any repeats. So, for n=3, possible permutations are [1,2,3], [1,3,2], [2,1,3], etc.

Now, the task is to create such a permutation where the sums of all consecutive segments of length k have sums that are very close to each other, differing by at most 1. That sounds pretty tight, especially since k can be up to n.

Given that k is even, maybe there's some property about even lengths that I can exploit.

Let me think about small examples to get a feel for this.

Take n=2, k=2.

Possible permutations:

[1,2]: sum of [1,2] is 3.

[2,1]: sum of [2,1] is 3.

So both are valid since there's only one sum, and 3-3=0 which is less than or equal to 1.

Next, n=3, k=2.

Possible permutations:

[1,2,3]:

sums: 1+2=3, 2+3=5. Difference is 2, which is greater than 1. Not good.

[1,3,2]:

sums: 1+3=4, 3+2=5. Difference is 1, which is acceptable.

[2,1,3]:

sums: 2+1=3, 1+3=4. Difference is 1, acceptable.

[2,3,1]:

sums: 2+3=5, 3+1=4. Difference is 1, acceptable.

[3,1,2]:

sums: 3+1=4, 1+2=3. Difference is 1, acceptable.

[3,2,1]:

sums: 3+2=5, 2+1=3. Difference is 2, not acceptable.

So, in this case, some permutations work, others don't.

Looking at the sample output for n=3, k=2, it's [1,3,2], which we've already seen works.

Now, for n=10, k=4, the sample output is [1,8,4,10,2,7,5,9,3,6].

Let's check the sums:

[1,8,4,10]: sum=23

[8,4,10,2]: sum=24

[4,10,2,7]: sum=23

[10,2,7,5]: sum=24

[2,7,5,9]: sum=23

[7,5,9,3]: sum=24

[5,9,3,6]: sum=23

The sums alternate between 23 and 24, so the difference is 1, which satisfies the condition.

Another test case: n=13, k=4, permutation [4,10,1,13,5,9,2,12,6,8,3,11,7].

Let's compute the sums:

[4,10,1,13]: sum=28

[10,1,13,5]: sum=29

[1,13,5,9]: sum=28

[13,5,9,2]: sum=29

[5,9,2,12]: sum=28

[9,2,12,6]: sum=29

[2,12,6,8]: sum=28

[12,6,8,3]: sum=29

[6,8,3,11]: sum=28

[8,3,11,7]: sum=29

Again, sums alternate between 28 and 29, difference of 1.

Last example: n=7, k=4, permutation [1,6,3,7,2,5,4].

Sums:

[1,6,3,7]: sum=17

[6,3,7,2]: sum=18

[3,7,2,5]: sum=17

[7,2,5,4]: sum=18

Difference is 1, which is acceptable.

From these examples, it seems like the strategy is to arrange the numbers in such a way that the sums of every k consecutive elements alternate or stay very close to each other.

But how to construct such a permutation in general?

Let me think about the properties needed.

Given that k is even, maybe pairing high and low numbers in a specific pattern would help.

In the sample inputs, we see that numbers are interleaved in a way that high and low values are mixed to balance the sums.

For example, in n=10, k=4: [1,8,4,10,2,7,5,9,3,6]

Here, 1 and 8 are paired, then 4 and 10, then 2 and 7, etc.

Similarly, in n=13, k=4: [4,10,1,13,5,9,2,12,6,8,3,11,7]

It's like alternating between higher and lower numbers.

Perhaps a general strategy is to split the numbers into two groups: lower half and upper half, and then interleave them.

But I need to confirm if this approach works in general.

Let me try to construct a permutation for n=5, k=4.

Numbers: 1,2,3,4,5.

If I interleave lower and upper: [1,4,2,5,3]

Sums:

[1,4,2,5]: sum=12

[4,2,5,3]: sum=14

Difference is 2, which is not acceptable.

Hmm, doesn't work.

Alternative approach: [1,5,2,4,3]

Sums:

[1,5,2,4]: sum=12

[5,2,4,3]: sum=14

Again, difference is 2.

Not good.

Alternative: [2,4,1,5,3]

Sums:

[2,4,1,5]: sum=12

[4,1,5,3]: sum=13

Difference is 1, which works.

So, [2,4,1,5,3] is a valid k-level permutation for n=5, k=4.

But how to generalize this?

Let me think about the positions.

In the first example that worked for n=5, k=4: [2,4,1,5,3]

It seems like placing slightly higher numbers first and then balancing with lower ones.

Is there a pattern here?

Another idea: arrange numbers in a specific order, like sorting and then rearranging in a certain way.

Wait, in the sample inputs, it seems like smaller numbers are placed between larger ones to balance the sums.

For example, in n=10, k=4: [1,8,4,10,2,7,5,9,3,6]

1 is between 8 and 4, then 8 is between 1 and 10, and so on.

Maybe a more systematic way is needed.

Let me consider the sum of each k-segment.

I need all these sums to be as close as possible, differing by at most 1.

Given that k is even, perhaps there's a way to pair high and low numbers to balance the sums.

Another thought: since k is even, the number of elements in each sum is even, so maybe pairing high and low numbers in each window can help balance the sum.

But I need a more concrete approach.

Let me consider the total sum S of all numbers from 1 to n, which is S = n*(n+1)/2.

The number of k-segment sums is n - k + 1.

I need these sums to be as equal as possible, with differences at most 1.

So, ideally, each sum should be approximately S / (n - k + 1).

But I need to ensure that the actual sums are either floor(S / (n - k + 1)) or ceil(S / (n - k + 1)).

Wait, but in this problem, it's not about distributing the sums as evenly as possible in terms of averaging the total sum, but rather ensuring that any two sums of k-consecutive elements differ by at most 1.

It's a bit different.

I need to minimize the variation between any two k-sums.

Given that, perhaps focusing on the differences between consecutive k-sums could help.

When you look at consecutive k-sums, they differ by only one element: the new element entering the window and the old element leaving the window.

So, s_{i+1} = s_i - p_i + p_{i+k}.

Given that, the difference between s_{i+1} and s_i is p_{i+k} - p_i.

To keep the difference between any two s_i's at most 1, perhaps I need to ensure that p_{i+k} - p_i is either 0 or 1 for all i.

But that seems too restrictive, especially since p_i are distinct integers.

Wait, no, p_i are distinct integers from 1 to n, so p_{i+k} - p_i cannot be 0.

So, differences between p_{i+k} and p_i must be either 1 or -1, but since they are distinct integers, that's not possible unless p_{i+k} = p_i Â±1.

But that would require that consecutive elements in the permutation differ by exactly 1, which might not be feasible for all n and k.

Wait, maybe not consecutive elements, but elements k positions apart.

This seems complicated.

Let me try another approach.

Perhaps I can think about the permutation as a sequence where the sum of every k consecutive elements is either m or m+1, for some integer m.

Given that, I need to arrange the numbers such that the sums are as balanced as possible.

One way to achieve this is to arrange the numbers in a way that high and low numbers are distributed evenly across the segments.

For example, interleaving high and low numbers.

Let me try to formalize this.

Suppose I split the numbers from 1 to n into two groups: low = [1, 2, ..., n//2], high = [n//2 +1, n//2 +2, ..., n].

Then, interleave them in some pattern to balance the sums.

For example, for n=10, k=4, interleave low and high numbers.

Let's try: [1,9,3,10,2,8,4,7,5,6]

Sums:

[1,9,3,10]: sum=23

[9,3,10,2]: sum=24

[3,10,2,8]: sum=23

[10,2,8,4]: sum=24

[2,8,4,7]: sum=21

[8,4,7,5]: sum=24

[4,7,5,6]: sum=22

Difference between max and min sums: 24 - 21 = 3, which is greater than 1.

Not good.

Alternative interleaving: [1,10,3,9,2,8,4,7,5,6]

Sums:

[1,10,3,9]: sum=23

[10,3,9,2]: sum=24

[3,9,2,8]: sum=22

[9,2,8,4]: sum=23

[2,8,4,7]: sum=21

[8,4,7,5]: sum=24

[4,7,5,6]: sum=22

Difference: 24 - 21 = 3, still greater than 1.

Not working.

Alternative approach: arrange the numbers in increasing order.

For n=10, k=4: [1,2,3,4,5,6,7,8,9,10]

Sums:

[1,2,3,4]: sum=10

[2,3,4,5]: sum=14

[3,4,5,6]: sum=18

[4,5,6,7]: sum=22

[5,6,7,8]: sum=26

[6,7,8,9]: sum=30

[7,8,9,10]: sum=34

Difference: 34 - 10 = 24, way too big.

Not good.

Alternative: arrange in decreasing order.

[10,9,8,7,6,5,4,3,2,1]

Sums:

[10,9,8,7]: sum=34

[9,8,7,6]: sum=30

[8,7,6,5]: sum=26

[7,6,5,4]: sum=22

[6,5,4,3]: sum=18

[5,4,3,2]: sum=14

[4,3,2,1]: sum=10

Difference: 34 - 10 = 24, again too big.

Same problem.

Alternative idea: arrange numbers in a way that the sum of every k elements is as close as possible.

Maybe arrange them in a specific pattern where high and low numbers are spaced out.

Wait, since k is even, maybe arrange the numbers in a pattern where every k/2 low numbers are followed by k/2 high numbers, and repeat.

Let me try for n=10, k=4.

k/2 = 2.

So, group low and high in blocks of 2.

Low numbers: [1,2,3,4,5]

High numbers: [6,7,8,9,10]

Arrange in blocks of 2 low and 2 high.

For example: [1,2,9,10,3,4,7,8,5,6]

Sums:

[1,2,9,10]: sum=22

[2,9,10,3]: sum=24

[9,10,3,4]: sum=26

[10,3,4,7]: sum=24

[3,4,7,8]: sum=22

[4,7,8,5]: sum=24

[7,8,5,6]: sum=26

Difference: 26 - 22 = 4, which is still greater than 1.

Not good enough.

Alternative arrangement: [1,6,3,8,2,7,4,9,5,10]

Sums:

[1,6,3,8]: sum=18

[6,3,8,7]: sum=24

[3,8,7,4]: sum=22

[8,7,4,9]: sum=28

[7,4,9,5]: sum=25

[4,9,5,10]: sum=28

Difference: 28 - 18 = 10, still too big.

Not working.

Maybe I need a different strategy.

Let me think about the problem differently.

Suppose I fix the first k elements to have a certain sum, and then ensure that each subsequent k-sum differs by at most 1.

Given that s_{i+1} = s_i - p_i + p_{i+k}, I can control the difference between s_{i+1} and s_i by controlling p_{i+k} - p_i.

To have s_{i+1} - s_i = p_{i+k} - p_i be either 0 or 1 or -1, but since p_i are distinct integers, p_{i+k} - p_i cannot be 0.

But p_{i+k} - p_i being 1 or -1 would require that p_{i+k} = p_i +1 or p_i -1, which might not be possible for all i.

This seems too restrictive.

Maybe instead of trying to make s_{i+1} - s_i = 1 or -1, I can accept that the difference can be larger, but ensure that overall, the maximum and minimum sums differ by at most 1.

This seems complicated.

Let me look for another approach.

I recall that in some problems, to make sums as equal as possible, we can arrange the numbers in a specific order, like the method used in creating a balanced sequence.

One such method is the "snake" order, where you alternate between low and high numbers.

For example, for n=10, arrange as [1,10,2,9,3,8,4,7,5,6].

Let's try this for n=10, k=4.

Permutation: [1,10,2,9,3,8,4,7,5,6]

Sums:

[1,10,2,9]: sum=22

[10,2,9,3]: sum=24

[2,9,3,8]: sum=22

[9,3,8,4]: sum=24

[3,8,4,7]: sum=22

[8,4,7,5]: sum=24

[4,7,5,6]: sum=22

Difference: 24 - 22 = 2, which is still greater than 1.

Not good enough.

Alternative idea: maybe arrange the numbers in a way that the sum of every k elements is exactly the same or differs by at most 1.

Given that, perhaps arranging the numbers in an increasing order, but adjusting the increments to balance the sums.

Wait, maybe use the concept of arithmetic progressions or something similar.

But I'm not sure.

Let me think differently.

Suppose I fix the first k elements to have a certain sum, and then each subsequent element is chosen such that the new sum is either the same or differs by 1.

Given that s_{i+1} = s_i - p_i + p_{i+k}, I can control p_{i+k} to adjust s_{i+1}.

But I need to ensure that for all possible i, the difference between any two s_i's is at most 1.

This seems too vague.

Let me consider a different perspective.

Suppose I arrange the numbers in such a way that the difference between p_i and p_{i+1} is small.

Like arranging them in ascending or descending order, but as we've seen, that leads to large differences in sums.

Alternatively, arrange them in a way that adjacent numbers differ by at most 1, but that's not possible since we're dealing with distinct integers.

Wait, no, in permutations, adjacent numbers can differ by more than 1.

Wait, in fact, in a permutation of 1 to n, the minimal difference between adjacent numbers is 1, and the maximal is n-1.

But arranging them in order of increasing or decreasing doesn't help, as we've seen.

Maybe I need to arrange them in a way that the sum of every k consecutive numbers is as close as possible.

Another idea: arrange the numbers in a way that the average of every k consecutive numbers is stable.

But I need to find a way to construct such a permutation systematically.

Looking back at the sample inputs, perhaps there's a pattern in how the numbers are arranged.

In n=10, k=4: [1,8,4,10,2,7,5,9,3,6]

Looking at positions:

pos 1:1, pos 2:8, pos 3:4, pos4:10, pos5:2, pos6:7, pos7:5, pos8:9, pos9:3, pos10:6

Is there a pattern here?

It's not strictly increasing or decreasing.

It's not alternating high and low in a simple way.

Maybe the numbers are arranged in a way that the sum of every 4 consecutive numbers is either 23 or 24.

But how to generalize this?

Let me consider that in the sample input, the sums alternate between two values, differing by 1.

Is there a way to arrange the numbers so that the sums cycle between two values?

If so, perhaps I can arrange the numbers in a pattern that achieves this.

For example, for n=10, k=4:

sums: 23,24,23,24,23,24,23

If I can arrange the sums to alternate between 23 and 24, then the difference between any two sums is at most 1.

Similarly, in n=13, k=4, sums alternate between 28 and 29.

So, perhaps a general strategy is to arrange the permutation such that the k-sums alternate between two values differing by 1.

But how to achieve that?

Let me think about the differences between consecutive sums.

Given that s_{i+1} = s_i - p_i + p_{i+k}, to have s_{i+1} = s_i + delta, where delta is either 0 or 1 or -1, I need p_{i+k} - p_i to be delta.

But since p_i are distinct integers, p_{i+k} - p_i cannot be 0.

So, p_{i+k} - p_i must be either 1 or -1.

But again, with distinct integers, that's only possible if p_{i+k} = p_i +1 or p_i -1.

This seems too restrictive for larger n and k.

Perhaps this approach isn't feasible.

Let me consider another angle.

Suppose I fix the first k elements to have a certain sum, and then for each subsequent element, I choose a number that minimizes the difference in sums.

This sounds like a greedy approach.

But implementing this would be complex, especially since I need to ensure that all numbers from 1 to n are used exactly once.

Moreover, with n up to 2e5 and t up to 1e4, time efficiency is crucial.

I need a more efficient way to construct the permutation.

Let me consider the properties of k being even.

Since k is even, perhaps pairing numbers in a specific way can help balance the sums.

For example, pairing a high number with a low number in each window.

But I'm not sure how to apply this systematically.

Another idea: arrange the numbers in a way that the sum of every two consecutive elements is as close as possible.

Since k is even, the sum of k elements can be thought of as the sum of k/2 pairs, each pair being two consecutive elements.

If each pair has a similar sum, then the sum of k/2 such pairs would also be similar.

Let me try this for n=10, k=4.

Arrange pairs to have similar sums.

For example, pairs: (1,10),(2,9),(3,8),(4,7),(5,6)

Each pair sums to 11.

Then, arrange these pairs in order:

[1,10,2,9,3,8,4,7,5,6]

As before, the sums of every 4 consecutive elements are 22 and 24, which differ by 2.

Not good enough.

Alternative arrangement: [1,10,3,8,2,9,4,7,5,6]

Sums:

[1,10,3,8]: 22

[10,3,8,2]: 23

[3,8,2,9]: 22

[8,2,9,4]: 23

[2,9,4,7]: 22

[9,4,7,5]: 25

[4,7,5,6]: 22

Difference: 25 - 22 = 3, still too big.

Not working.

Alternative arrangement: [1,9,2,10,3,8,4,7,5,6]

Sums:

[1,9,2,10]: 22

[9,2,10,3]: 24

[2,10