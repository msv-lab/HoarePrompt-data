Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual. On each turn, a player chooses a positive integer k that is less than or equal to the smallest pile and removes k stones from every non-empty pile. The player who can't make a move loses, which means all piles are empty.

So, Alice goes first, and both play optimally. I need to figure out who wins each game for multiple test cases.

First, I need to understand the game mechanics deeply. The key here is that each time a player chooses k, they remove k stones from every non-empty pile. This is different from standard Nim or other stone-pile games where stones are removed from a single pile.

Let me try to see what happens in a simple case. Suppose there is only one pile with, say, 5 stones. Alice can choose k from 1 to 5. If she chooses k=1, she removes 1 stone from the pile, leaving 4. Bob then can choose k up to 4, and so on. But actually, since there's only one pile, choosing k stones to remove from it is straightforward. Wait, but the rule says to remove k stones from each non-empty pile. With only one pile, it's similar to just removing k stones from that pile.

But in this specific case, since there's only one pile, the game is equivalent to a standard Nim game with one pile, where the first player can always take all stones and win immediately. So, for a single pile, Alice can always win by taking all stones at once.

Looking back at the example in the problem, the first test case has 5 piles, each with 3 stones. Alice can choose k=3 and remove 3 stones from each pile, emptying all piles and winning immediately.

In the second test case, there are 2 piles: 1 and 7. Alice must choose k=1 (since the smallest pile has only 1 stone), and removes 1 stone from each pile, leaving piles of 0 and 6. Now, Bob chooses k up to 6 (the smallest non-empty pile is 6), and removes 6 stones from each pile, but since one pile is already empty, he removes 6 from the pile of 6, making it empty. Now, only one pile is left, which is empty, so Alice can't make a move and loses.

Wait, but according to the output, it's "Bob", which matches this reasoning.

In the third test case, 7 piles with sizes 1,3,9,7,4,2,100. Let's see:

Alice can choose k up to the smallest pile, which is 1. So, she must choose k=1 and remove 1 stone from each pile, making the piles: 0,2,8,6,3,1,99.

Now, Bob can choose k up to 1 (the smallest non-empty pile is 1), removes 1 from each non-empty pile: 0,1,7,5,2,0,98.

Alice now can choose k up to 1, removes 1 from each non-empty pile: 0,0,6,4,1,0,97.

Bob chooses k=1, removes 1 from each non-empty pile: 0,0,5,3,0,0,96.

Alice chooses k=1, removes 1 from each non-empty pile: 0,0,4,2,0,0,95.

Bob chooses k=1, removes 1 from each non-empty pile: 0,0,3,1,0,0,94.

Alice chooses k=1, removes 1 from each non-empty pile: 0,0,2,0,0,0,93.

Bob chooses k=1, removes 1 from each non-empty pile: 0,0,1,0,0,0,92.

Alice chooses k=1, removes 1 from each non-empty pile: 0,0,0,0,0,0,91.

Now, all piles are empty, so Alice loses. But according to the output, it's "Alice" which seems contradictory to this simulation. Wait, maybe I made a mistake in simulation.

Wait, perhaps there is a better way to approach this game rather than simulating each move, especially since n can be up to 2*10^5 and t up to 10^4, which would make simulation too slow anyway.

I need a smarter way to determine the winner.

Let me think about the game in terms of game theory, specifically impartial games like Nim. In standard Nim, the winning strategy is based on the XOR of pile sizes. But here, the moves affect all piles at once, which is different.

I need to find the game's nimber or Sprague-Grundy function to determine the overall game's winner.

But calculating the Grundy function for such large pile sizes (up to 10^9) seems infeasible directly.

Is there a pattern or a mathematical formula that can determine the winner without simulating the game?

Looking back at the problem, it seems that the key is to find the mex (minimum excludant) of the possible moves.

Wait, maybe I should think differently. Since each move consists of choosing a k up to the smallest pile and removing k stones from each non-empty pile, this is equivalent to reducing the size of each pile by k, but only if the pile has at least k stones.

Wait, no. If a pile has fewer than k stones, and we choose k, we just remove all stones from it.

Actually, in each move, for a chosen k, every pile that has at least k stones will have k stones removed, and piles with fewer than k stones will be emptied.

Wait, no. The problem says "remove k stones from each nonempty pile at once". So, from each non-empty pile, exactly k stones are removed, unless the pile has fewer than k stones, in which case it's emptied.

So, it's a uniform removal of k stones from all non-empty piles, to the extent that each pile allows.

This seems similar to a variant of Nim where stones are removed from all piles simultaneously.

I need to find a way to model this.

Perhaps, the game can be modeled by considering the sorted pile sizes.

Let me sort the piles in non-decreasing order: a1 ≤ a2 ≤ ... ≤ an.

Now, the smallest pile is a1.

The player can choose k from 1 to a1.

After choosing k, every pile will have k stones removed, or be emptied if k ≥ ai.

So, the new pile sizes would be:

For each pile ai:

- If ai >= k, ai becomes ai - k

- If ai < k, ai becomes 0

So, the next position is {ai - k if ai >= k else 0} for all i.

I need to see if there is a pattern or a mathematical way to determine the game's outcome without simulating all possible moves.

I recall that in impartial games, the mex of the Grundy values of the positions after possible moves gives the Grundy value of the current position. If the Grundy value is 0, the position is losing for the current player.

But calculating the Grundy values for large n and large ai seems impractical.

Is there a way to simplify this?

Looking at the example where all piles are equal, Alice can win by choosing k equal to the pile size, thus emptying all piles.

In the second example, with piles 1 and 7, Alice must choose k=1, which removes 1 from each, leaving piles 0 and 6. Then Bob chooses k=6, removes 6 from the pile of 6, leaving piles 0 and 0, so Alice loses.

In the third example, it's more complicated, but according to the output, Alice wins.

I need to find a general rule.

Let me think about the minimal excludant (mex) concept.

If I sort the piles in increasing order: a1 ≤ a2 ≤ ... ≤ an.

Let's define mex as the smallest positive integer not present in the pile sizes.

Wait, not exactly. In standard game theory, mex is used in the context of the Grundy function.

But perhaps there's a connection.

Wait, perhaps I can think of the game in terms of the number of non-empty piles after each move.

Each move reduces the size of all non-empty piles by k, or empties them if k is at least their size.

This is similar to a misère game, but I'm not sure.

Alternatively, maybe I can think in terms of the number of piles that are greater than or equal to a certain value.

Wait, perhaps I should consider the minimal value that is not achievable as a pile size.

Let me try to find a pattern.

Suppose I have piles sorted as a1 ≤ a2 ≤ ... ≤ an.

The smallest pile is a1.

Alice can choose k from 1 to a1.

After choosing k, the new pile sizes are:

- For each ai, if ai >= k, ai becomes ai - k

- If ai < k, ai becomes 0

So, the number of non-empty piles after this move is equal to the number of piles with ai >= k.

Alice can choose k such that the number of piles with ai >= k is minimized, or optimized in some way.

Wait, perhaps I should look at the pile sizes in terms of how many piles are larger than certain values.

Let me consider the sorted pile sizes.

Let's define b_j as the number of piles with size at least j, for j from 1 to max(a_i).

For example, for piles [1,3,9,7,4,2,100], after sorting: [1,2,3,4,7,9,100]

b_1 = 7 (all piles have at least 1 stone)

b_2 = 6 (all except the pile of 1)

b_3 = 5 (all except piles of 1 and 2)

b_4 = 4

b_5 = 3 (piles of 7,9,100)

b_6 = 3 (same as above, since piles of 7,9,100 are all >=6)

b_7 = 3

b_8 = 2 (piles of 9 and 100)

b_9 = 2

b_10 = 1 (pile of 100)

b_11 = 1

...

b_100 = 1

b_101 = 0

and so on.

Now, when Alice chooses k, she is effectively reducing the pile sizes by k, or emptying them if k >= ai.

So, after choosing k, the new pile sizes are:

- For each ai, ai - k if ai >= k, else 0.

This is equivalent to all piles having their sizes reduced by k, with piles smaller than k being emptied.

So, the new b_j' after choosing k would be:

- For j < k, b_j' = number of piles with ai - k >= j, which is number of piles with ai >= j + k

- For j >= k, b_j' = number of piles with ai - k >= j, which is number of piles with ai >= j + k

Wait, actually, it's simpler:

After choosing k, the new pile sizes are ai - k for ai >= k, and 0 otherwise.

So, the number of piles with size at least j after choosing k is equal to the number of piles with ai - k >= j, which is the number of piles with ai >= j + k.

So, b_j' = number of ai >= j + k.

Now, the next player faces a position where the pile sizes are ai - k for ai >= k, and 0 otherwise.

This seems complex to handle directly.

Is there a way to find the game's nimber based on the sequence of b_j?

Alternatively, perhaps I can think in terms of the mex of the possible moves.

Wait, perhaps I should consider the minimal value that is not present in the pile sizes.

Let me try to see.

In the first test case, all piles are 3. So, sorted a = [3,3,3,3,3]

The mex would be the smallest positive integer not in a, which is 1 (since 1 is not in a).

But according to the program, it's checking mexsize and maxsize.

Wait, let's look at the program.

The program does the following:

- For each test case:

- Read n

- Read the array a of n integers

- Find the maximum value in a (maxsize)

- Sort a in increasing order

- Initialize mexsize = 1

- Iterate through the sorted a:

- For each sz in a:

- If sz == mexsize:

- Increment mexsize by 1

- After iterating through a, compare mexsize with maxsize:

- If mexsize > maxsize:

- Print "Alice" if mexsize % 2 == 0 else "Bob"

- Else:

- Print "Alice" if mexsize % 2 == 1 else "Bob"

So, what is mexsize here?

mexsize is essentially the smallest positive integer not present in a.

For example, in the first test case, a = [3,3,3,3,3], sorted is same. mexsize starts at 1.

Since 1 is not in a, mexsize remains 1.

So, mexsize = 1, maxsize = 3.

Since mexsize <= maxsize, it falls into the else clause.

Print "Alice" if mexsize % 2 == 1 (which it is), else "Bob". So, prints "Alice".

But according to the example, Alice wins by choosing k=3 and emptying all piles.

So, in this case, the program correctly prints "Alice".

In the second test case, a = [1,7], sorted [1,7].

mexsize =1, which is equal to a[0]=1, so mexsize becomes 2.

Check if 2 is in a? No, so mexsize=2.

maxsize=7.

Since mexsize <= maxsize, else clause:

Print "Alice" if mexsize % 2 ==1 else "Bob". Here, mexsize=2, which is even, so print "Bob".

Which matches the example output.

In the third test case, a = [1,3,9,7,4,2,100], sorted [1,2,3,4,7,9,100].

mexsize=1, which is in a, so mexsize=2

2 is in a, so mexsize=3

3 is in a, so mexsize=4

4 is in a, so mexsize=5

5 is not in a, so mexsize=5

maxsize=100

mexsize=5 > maxsize=100? No, so else clause:

Print "Alice" if mexsize %2 ==1 else "Bob". 5 is odd, so "Alice"

But according to the example output, it's "Alice", which matches.

Wait, earlier in my simulation, I thought Alice would lose, but according to the program and the example, Alice wins.

So, perhaps the program is correct.

Let me see another test case.

Fourth test case: n=3, a=[1,2,3], sorted [1,2,3]

mexsize=1 is in a, so mexsize=2

2 is in a, so mexsize=3

3 is in a, so mexsize=4

4 is not in a, so mexsize=4

maxsize=3

mexsize=4 > maxsize=3, so if clause:

Print "Alice" if mexsize %2 ==0 else "Bob". 4 is even, so "Alice"

Which matches the example output.

Fifth test case: n=6, a=[2,1,3,4,2,4], sorted [1,2,2,3,4,4]

mexsize=1 is in a, so mexsize=2

2 is in a, so mexsize=3

3 is in a, so mexsize=4

4 is in a, so mexsize=5

5 is not in a, so mexsize=5

maxsize=4

mexsize=5 > maxsize=4, if clause:

Print "Alice" if mexsize %2 ==0 else "Bob". 5 is odd, so "Bob"

Which matches the example.

Sixth test case: n=8, a=[5,7,2,9,6,3,3,2], sorted [2,2,3,3,5,6,7,9]

mexsize=1 is in a? No, so mexsize=1

So, mexsize=1, maxsize=9

mexsize=1 <= maxsize=9, else clause:

Print "Alice" if mexsize %2 ==1 else "Bob". 1 is odd, so "Alice"

Which matches the example.

Seventh test case: n=1, a=[1000000000], sorted [1000000000]

mexsize=1 is not in a, so mexsize=1

maxsize=1000000000

mexsize=1 <= maxsize, else clause:

Print "Alice" if mexsize %2 ==1 else "Bob". 1 is odd, so "Alice"

Which matches the example.

So, the program seems to be correct for all the given test cases.

But I need to understand why this logic works.

Let me try to understand the logic behind the program.

The program computes mexsize, which is the smallest positive integer not present in the sorted array a.

Then, it compares mexsize with maxsize.

If mexsize > maxsize, it prints "Alice" if mexsize is even, else "Bob".

Else, it prints "Alice" if mexsize is odd, else "Bob".

I need to see how this relates to the game's outcome.

Let me think about the game in terms of mexsize.

The mexsize represents the smallest positive integer that is not present in the pile sizes.

In the game, the player can choose k up to the smallest pile size.

If mexsize > maxsize, it means that all numbers from 1 to maxsize are present in the pile sizes.

In other words, the pile sizes contain all integers from 1 up to maxsize.

In this case, the game might have a certain property that determines the winner based on the parity of mexsize.

Similarly, if mexsize <= maxsize, the pile sizes miss some number below maxsize, and again, the winner is determined by the parity of mexsize.

I need to see if this makes sense.

Let me consider some examples.

First test case: a=[3,3,3,3,3], sorted [3,3,3,3,3]

mexsize=1, maxsize=3

mexsize <= maxsize, and mexsize is odd, so "Alice"

Which is correct, as Alice can choose k=3 and win immediately.

Second test case: a=[1,7], sorted [1,7]

mexsize=2, maxsize=7

mexsize <= maxsize, mexsize is even, so "Bob"

Which is correct, as Alice must choose k=1, leading to Bob winning.

Third test case: a=[1,2,3,4,7,9,100], sorted [1,2,3,4,7,9,100]

mexsize=5, maxsize=100

mexsize <= maxsize, mexsize is odd, so "Alice"

Which matches the example.

Fourth test case: a=[1,2,3], sorted [1,2,3]

mexsize=4, maxsize=3

mexsize > maxsize, mexsize is even, so "Alice"

Which matches the example.

Fifth test case: a=[2,1,3,4,2,4], sorted [1,2,2,3,4,4]

mexsize=5, maxsize=4

mexsize > maxsize, mexsize is odd, so "Bob"

Which matches the example.

Sixth test case: a=[5,7,2,9,6,3,3,2], sorted [2,2,3,3,5,6,7,9]

mexsize=1, maxsize=9

mexsize <= maxsize, mexsize is odd, so "Alice"

Which matches the example.

Seventh test case: a=[1000000000], sorted [1000000000]

mexsize=1, maxsize=1000000000

mexsize <= maxsize, mexsize is odd, so "Alice"

Which matches the example.

So, the program seems to be correct for all the given test cases.

But to be thorough, I need to see if this logic holds in general.

Let me try to think of a scenario where this logic might fail.

Suppose n=1, a=[1], sorted [1]

mexsize=2, maxsize=1

mexsize > maxsize, mexsize is even, so "Alice"

But in this case, Alice chooses k=1, empties the pile, and wins. So, correct.

Another case: n=2, a=[1,2], sorted [1,2]

mexsize=3, maxsize=2

mexsize > maxsize, mexsize is odd, so "Bob"

Let's simulate:

Alice must choose k=1, removes 1 from each pile, leaving [0,1]

Bob chooses k=1, removes 1 from the remaining pile, leaving [0,0], so Alice loses. So, "Bob" is correct.

Another case: n=3, a=[1,1,1], sorted [1,1,1]

mexsize=2, maxsize=1

mexsize > maxsize, mexsize is even, so "Alice"

Alice chooses k=1, removes 1 from each pile, leaving [0,0,0], so Alice wins.

Correct.

Another case: n=4, a=[1,2,2,2], sorted [1,2,2,2]

mexsize=3, maxsize=2

mexsize > maxsize, mexsize is odd, so "Bob"

Let's simulate:

Alice chooses k=1, removes 1 from each pile, leaving [0,1,1,1]

Bob chooses k=1, removes 1 from each non-empty pile, leaving [0,0,0,0], so Alice loses. Correct.

Seems like the program's logic is consistent with the game's outcome in these cases.

I can't find a counterexample where the program's output differs from the actual game's outcome.

Therefore, I conclude that the program is correct.

**Final Answer**

\[ \boxed{\text{The given program is correct.}} \]

**Correctness: True**