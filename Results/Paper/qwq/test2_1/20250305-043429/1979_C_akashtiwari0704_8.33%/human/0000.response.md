Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome. The goal is to distribute the coins in such a way that no matter which outcome wins, the total coins I get back are more than the total coins I bet.

First, I need to understand the constraints. For each test case, I'm given n (the number of outcomes), and then a list of k_i values. I need to output the bets x_i for each outcome such that the sum of all x_i is less than k_i * x_i for every i. Because only one outcome will win, and I need to ensure that for whichever outcome wins, the return is greater than the total bet.

So, mathematically, I need to find x_i such that for all i:

sum of all x_j < k_i * x_i

Where j goes from 1 to n.

Let me rearrange this inequality:

sum of all x_j - k_i * x_i < 0

Or

sum of x_j for j ≠ i < (k_i - 1) * x_i

Hmm, this seems a bit tricky. I need to find values x_i that satisfy this condition for all i.

I need to find a way to assign x_i such that for each i, the sum of all other bets is less than (k_i - 1) times the bet on i.

This seems like a system of inequalities that needs to be satisfied simultaneously.

Let me think about the example given:

In the first test case:

n = 3

k = [3, 2, 7]

The solution provided is x = [27, 41, 12]

Let's check if this satisfies the condition:

Total sum = 27 + 41 + 12 = 80

For outcome 1:

3 * 27 = 81 > 80

For outcome 2:

2 * 41 = 82 > 80

For outcome 3:

7 * 12 = 84 > 80

Yes, it satisfies.

Now, how was this solution arrived at?

Looking at the code provided:

def func():

t = int(input())

for T in range(t):

bets = int(input())

a = [int(x) for x in input().split()]

prod = 1

for i in range(bets):

prod *= a[i]

sumo = 0

for i in range(bets):

a[i] = prod // a[i]

sumo += int(a[i])

if sumo >= prod:

print(-1)

else:

ans = ''

for i in range(bets):

ans += str(a[i]) + ' '

print(ans)

So, the approach in the code is:

1. Calculate the product of all k_i, let's call it P.

2. For each x_i, set x_i = P / k_i

3. Calculate the sum of all x_i

4. If the sum of x_i is greater than or equal to P, output -1

Else, output the x_i values.

Let me see if this makes sense.

Given that x_i = P / k_i

Then, sum of x_j for j ≠ i is sum_{j≠i} (P / k_j)

We need sum_{j≠i} (P / k_j) < (k_i - 1) * (P / k_i)

Simplify the right side:

(k_i - 1) * (P / k_i) = P * (k_i - 1)/k_i = P * (1 - 1/k_i)

So, sum_{j≠i} (P / k_j) < P * (1 - 1/k_i)

Divide both sides by P (since P > 0):

sum_{j≠i} (1 / k_j) < 1 - 1/k_i

Which can be written as:

sum_{j=1 to n} (1 / k_j) - 1/k_i < 1 - 1/k_i

sum_{j=1 to n} (1 / k_j) < 1

So, the condition simplifies to:

sum_{j=1 to n} (1 / k_j) < 1

If this is true, then the x_i = P / k_i is a valid solution.

Because in that case, sum_{j≠i} (P / k_j) < P * (1 - 1/k_i) = P * (k_i - 1)/k_i = (k_i - 1) * (P / k_i)

Which is exactly the condition we need.

Moreover, in the code, it checks if sum_{j=1 to n} (P / k_j) >= P

Which is equivalent to sum_{j=1 to n} (1 / k_j) >= 1

Because sum_{j=1 to n} (P / k_j) = P * sum_{j=1 to n} (1 / k_j)

So, if sum_{j=1 to n} (1 / k_j) >= 1, it outputs -1

Else, it outputs x_i = P / k_i

This makes sense based on the earlier derivation.

Therefore, the code is correct in its approach.

Let me verify with the first test case:

n=3, k=[3,2,7]

sum of 1/k_i = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 < 1

So, it should have a solution.

P = 3*2*7 = 42

x_i = [42/3, 42/2, 42/7] = [14, 21, 6]

But in the example, it's [27,41,12]. So, why is that?

Wait, maybe there are multiple solutions, and the code's solution is just one possible way.

But in the code, for the first test case, it should output [14,21,6], but in the example, it's [27,41,12]. So, perhaps there's something else going on.

Wait, perhaps the code is not matching the example output.

Looking back at the code:

It calculates P = product of all k_i

Then, for each x_i, sets x_i = P // k_i

Then, sums up all x_i

If sum(x_i) >= P, outputs -1

Else, outputs x_i

In the first test case:

P = 3*2*7 = 42

x_i = [42//3, 42//2, 42//7] = [14,21,6]

sum(x_i) = 14+21+6 = 41 < 42, so it should output 14 21 6

But in the example output, it's 27 41 12

So, either the code is incorrect, or the example is wrong, or there are multiple solutions.

Wait, the problem says "if there are multiple solutions, output any of them"

So, both [14,21,6] and [27,41,12] are valid solutions.

But the code outputs [14,21,6], which is correct, but the example shows [27,41,12]

So, perhaps the code is correct, and [27,41,12] is just another possible solution.

But according to the code, it should output [14,21,6]

Wait, maybe the code is not matching the example, but it's still correct, since multiple solutions exist.

In any case, as long as the solution satisfies the condition, it's acceptable.

Now, let's check the second test case:

n=2, k=[3,3]

sum of 1/k_i = 1/3 + 1/3 = 2/3 < 1

So, solution exists.

P = 3*3 = 9

x_i = [9/3, 9/3] = [3,3]

sum(x_i) = 6 < 9, which is correct.

In the example, it outputs 1 1

Wait, 1 1 would give sum=2, P=9, which is 2 < 9, and for each outcome:

3*1 = 3 > 2, so it's valid.

But the code would output 3 3, which is also valid.

So, again, multiple solutions exist.

Third test case:

n=5, k=[5,5,5,5,5]

sum of 1/k_i = 5*(1/5) = 1

So, sum = 1, which is not less than 1, so output -1

Which matches the example output.

Fourth test case:

n=6, k=[7,9,3,17,9,13]

sum of 1/k_i = 1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13

Let's calculate:

1/3 ≈ 0.3333

1/7 ≈ 0.1429

1/9 ≈ 0.1111, and there are two 1/9

1/13 ≈ 0.0769

1/17 ≈ 0.0588

Sum ≈ 0.3333 + 0.1429 + 0.1111 + 0.1111 + 0.0769 + 0.0588 ≈ 0.8341 < 1

So, solution exists.

P = 7*9*3*17*9*13 = let's not calculate, but according to the code, it should compute P and set x_i = P // k_i

And sum(x_i) < P, which is true here.

Fifth test case:

n=3, k=[6,3,2]

sum of 1/k_i = 1/6 + 1/3 + 1/2 = 1/6 + 2/6 + 3/6 = 6/6 = 1

So, sum = 1, which is not less than 1, so output -1

Which matches the example.

Sixth test case:

n=5, k=[9,4,6,8,3]

sum of 1/k_i = 1/9 + 1/4 + 1/6 + 1/8 + 1/3

Let's calculate:

1/3 ≈ 0.3333

1/4 = 0.25

1/6 ≈ 0.1667

1/8 = 0.125

1/9 ≈ 0.1111

Sum ≈ 0.3333 + 0.25 + 0.1667 + 0.125 + 0.1111 ≈ 0.9861 < 1

So, solution exists.

According to the example, it outputs 8 18 12 9 24

Let's check:

P = 9*4*6*8*3 = let's calculate:

9*4=36

36*6=216

216*8=1728

1728*3=5184

x_i = [5184//9, 5184//4, 5184//6, 5184//8, 5184//3] = [576, 1296, 864, 648, 1728]

But the example outputs 8,18,12,9,24

Which are much smaller, but still valid as long as sum(x_i) < P.

But according to the code, it should output [576,1296,864,648,1728]

Sum = 576+1296=1872+864=2736+648=3384+1728=5112 < 5184, which is correct.

But the example outputs smaller numbers, which are also valid.

So, again, multiple solutions exist.

Now, to verify the correctness of the code:

Does it always find a solution if one exists?

According to the earlier reasoning, if sum(1/k_i) < 1, then setting x_i = P / k_i is a valid solution, where P is the product of all k_i.

Moreover, since P is integer, and k_i divides P, x_i is integer.

Also, sum(x_i) = P * sum(1/k_i), which is less than P, as sum(1/k_i) < 1.

Therefore, the solution is valid.

Hence, the code is correct in finding a solution when it exists.

Moreover, when sum(1/k_i) >=1, it correctly outputs -1, as no solution exists.

Therefore, the given program is correct.

**Final Answer**

\boxed{\text{True}}