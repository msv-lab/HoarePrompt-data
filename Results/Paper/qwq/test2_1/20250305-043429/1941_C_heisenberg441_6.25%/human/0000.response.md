Alright, I have this problem to solve. Let's see what it's asking for. So, Rudolf has a string, and he thinks it's ugly if it contains the substrings "pie" or "map". Otherwise, it's beautiful. I need to make the string beautiful by removing the least number of characters possible, specifically targeting those ugly substrings.

First, I need to understand what it means for a string to be ugly. It's ugly if it contains either "pie" or "map" as consecutive characters. So, for example, "ppiee" is ugly because it contains "pie", and "mmap" is ugly because it has "map". Even if there are multiple occurrences, as long as one of these substrings is present, the whole string is considered ugly.

My task is to make it beautiful by removing the minimum number of characters. That means I need to eliminate all occurrences of "pie" and "map" by deleting as few characters as possible.

Looking at the example provided:

- "mmapnapie" with n=9. The output is 2.

- "azabazapi" with n=9. The output is 0, meaning it's already beautiful.

- "mappppie" with n=8. The output is 2.

- A longer string "mapmapmapmapmapmap" with n=18. The output is 6.

- A single character "p" with n=1. The output is 0.

- "pppiepieeee" with n=11. The output is 2.

I need to figure out a general approach that can handle any string within the given constraints.

Constraints:

- Number of test cases, t, is up to 10^4.

- String length, n, can be up to 10^6 per test case.

- Sum of n over all test cases doesn't exceed 10^6, which is good for time complexity.

Given that, I need an efficient solution, preferably linear time per test case.

Let's think about how to approach this.

One way is to iterate through the string and identify occurrences of "map" and "pie", then decide which characters to remove to eliminate these substrings.

But simply counting the occurrences might not be enough because removing one character could eliminate multiple substrings.

For example, in "mapie", removing the 'p' would eliminate both "map" and "pie".

So, I need a way to handle overlapping substrings efficiently.

Another approach could be to build a new string by skipping certain characters that are part of the ugly substrings.

But that might be inefficient for large strings.

Looking at the provided program, it defines a function func_1(s) that seems to handle this.

Let's see what it's doing.

It first checks if s is exactly 'mapie', and if so, returns 1. I'm not sure why this special case is here, but perhaps it's a specific optimization.

Then, it initializes ans = 0 to count the number of deletions.

It enters a loop where it finds the first occurrence of 'map' and removes the first two characters of that substring, effectively deleting the 'ma' part and keeping the 'p'.

It increments ans by 1 for each such deletion.

Then, it does the same for 'pie', removing the first two characters, 'pi', and keeping the 'e'.

Again, increments ans by 1.

It continues these loops until there are no more 'map' or 'pie' substrings in s.

Finally, it returns the total number of deletions ans.

Let me test this logic with the first example: "mmapnapie"

Initial string: mmapnapie

First, look for 'map':

- Positions: 0-2: 'mma' (not 'map')

- Positions: 1-3: 'map' (found)

Remove s[1:3], which is 'ap', so the string becomes: m mnape

Wait, that doesn't seem right.

Wait, s.find('map') returns the starting index of the first occurrence, which is 1.

Then, s = s[:1] + s[1+2:] = s[:1] + s[3:] = m + nape = mnape

ans = 1

Now, s = mnape

Look for 'pie':

- Positions: 2-4: 'ape' (not 'pie')

- Positions: 1-3: 'na' (not 'pie')

- Positions: 0-2: 'mn' (not 'pie')

No 'pie' found.

So, ans remains 1.

But according to the sample input, the expected output is 2.

Hmm, seems like the function is incorrect.

Let me try another example: "mappppie"

Initial string: m a p p p p i e

Look for 'map':

- Positions: 0-2: 'map' (found)

Remove s[0:2], which is 'ma', so s = ppppie

ans = 1

Now, s = ppppie

Look for 'pie':

- Positions: 4-6: 'pie' (found)

Remove s[4:6], which is 'pi', so s = pppie

ans = 2

Now, s = pppie

Look for 'pie':

- Positions: 3-5: 'pie' (found again)

Remove s[3:5], 'pi', so s = ppee

ans = 3

Now, s = ppee

Look for 'pie':

- Positions: 2-4: 'pe' (not 'pie')

- Positions: 1-3: 'pp' (not 'pie')

- Positions: 0-2: 'pp' (not 'pie')

No 'pie' found.

So, final ans = 3, but the sample output is 2.

This suggests that the function is not optimal.

Wait, perhaps removing different characters could lead to fewer deletions.

In "mappppie", maybe removing only two characters can eliminate both 'map' and 'pie' occurrences.

For example, remove the 'm' and one 'p', so s becomes apppie, which doesn't contain 'map', and then remove one 'p' to break the 'pie', but that seems messy.

Wait, actually, in "mappppie", removing the 'm' and one 'p' could make it apppie, which still contains 'pie'.

Wait, maybe removing the 'm' and the 'i' would make it appppe, which doesn't contain 'map' or 'pie'.

So, ans = 2, matching the sample output.

But the function is returning 3, which is suboptimal.

Hence, the function is incorrect.

Another issue: in the function, it first removes all 'map' substrings and then removes all 'pie' substrings, but this sequential approach doesn't guarantee the minimal number of deletions, as it doesn't consider overlapping occurrences optimally.

Moreover, the special case for 'mapie' returning 1 seems arbitrary and not generalized.

I need a better approach.

Let's think differently.

I need to eliminate all 'map' and 'pie' substrings with minimal deletions.

One way to think about it is to find a sequence of characters to keep such that neither 'map' nor 'pie' appears as a substring in the resulting string.

This sounds like finding the longest subsequence that doesn't contain these substrings and then calculating the number of deletions as n minus the length of this subsequence.

But finding such a subsequence directly might be tricky.

An alternative is to model this problem using a finite state machine (FSM) where certain states correspond to partial matches of the forbidden substrings, and transitions are based on adding characters to the string.

By keeping track of the states that avoid the forbidden substrings, I can determine the minimal number of deletions.

However, implementing an FSM for this might be complex, especially considering the constraints on n.

Let's see if there's a simpler way.

Another approach is to iterate through the string and identify positions where 'map' or 'pie' occur, and decide which characters to remove to break these substrings.

But ensuring that removals are minimal and that overlapping substrings are handled correctly is non-trivial.

Perhaps using dynamic programming (DP) could be a good way to go.

Let's consider a DP approach.

Define dp[i] as the minimum number of deletions needed to make the substring s[0:i] beautiful.

Our goal is to compute dp[n].

Initialization:

- dp[0] = 0 (empty string is beautiful)

- dp[1] = 0 (a single character can't form 'map' or 'pie')

- dp[2] = 0 (two characters can't form 'map' or 'pie')

For i >= 3:

We need to check if s[i-3:i] forms 'map' or 'pie'.

If s[i-3:i] is not 'map' or 'pie', then dp[i] = dp[i-1] (no additional deletions needed).

If s[i-3:i] is 'map' or 'pie', then we need to delete at least one character in this substring.

But simply deleting one character might not be sufficient if there are overlapping occurrences.

To handle this properly, we need to consider all possible ways to break the 'map' or 'pie' substring.

One way is to consider deleting one character and see what effect it has on the substring.

However, this can be inefficient for large n.

A better way is to keep track of the last few characters to detect the forbidden substrings and decide which characters to delete accordingly.

Let's try to formalize the DP transition.

Define dp[i] as the minimum number of deletions needed for s[0:i].

We can consider two options for each character s[i-1]:

1. Keep it: if keeping it doesn't form a forbidden substring with the previous characters.

2. Delete it: which costs one deletion.

But this is a bit vague. Let's think in terms of states.

We can keep track of the last few characters to detect potential forbidden substrings.

Specifically, we need to track the last two characters to check for 'map' or 'pie'.

Wait, for 'map', we need to track three characters, but since we're dealing with overlapping substrings, it's getting complicated.

Maybe I should look for a different approach.

Let's consider the greedy approach.

A greedy approach could be to iterate through the string and whenever we find 'map' or 'pie', remove the minimum number of characters to break it, and continue.

But this might not be optimal due to overlapping substrings.

For example, in "mapie", removing 'm' breaks both 'map' and 'pie', which is better than removing one character from each.

So, a greedy approach needs to be careful about overlapping substrings.

One way to implement this is to iterate through the string and use a sliding window to check for 'map' and 'pie', and when found, remove the character that breaks both if possible.

But this is still vague.

Let me think about it differently.

Suppose I have a string and I want to keep track of positions where 'map' or 'pie' start.

I can iterate through the string and mark these positions.

Then, for each marked position, I need to decide which character to remove to break the forbidden substring.

To minimize the total deletions, I should try to cover as many forbidden substrings as possible with each deletion.

This sounds like a interval covering problem, where each forbidden substring is an interval, and I need to cover these intervals with as few deletions as possible.

In interval covering, the optimal strategy is to select deletions that cover the most intervals.

But implementing this for strings might be complex.

Alternatively, I can model this as a graph where characters are nodes, and edges represent forbidden substrings, and then find a minimal vertex cover or something similar.

But that might be overkill.

Let's see if there's a simpler way.

Another idea is to build a new string by skipping characters that are part of forbidden substrings.

But again, determining which characters to skip optimally is challenging.

Wait, perhaps using regular expressions to find and remove 'map' and 'pie' substrings, but that might not lead to the minimal number of deletions.

I need to find a way that ensures I'm making the minimal number of deletions.

Looking back at the DP approach, maybe I can define dp[i] as the minimum deletions for the first i characters, and keep track of the last few characters to ensure that no forbidden substrings are formed.

Let's try to define the states more carefully.

Define dp[i] as the minimum deletions for s[0:i], and keep track of the last one or two characters to ensure no 'map' or 'pie' is formed.

Wait, since 'map' and 'pie' are three characters long, I need to track the last two characters to detect potential forbidden substrings.

So, I can keep track of dp[i][j], where j represents the last two characters of the kept string.

But with 26 letters, tracking all possible pairs would be O(n * 26^2), which is acceptable since 26^2 * 10^6 is about 7 * 10^8 operations, which might be too slow for time limits, but let's see.

Alternatively, I can try to optimize it.

Wait, perhaps I can track the state based on the last two characters, and transition based on whether adding the current character would form a forbidden substring.

But this seems complicated.

Let me see if there's a better way.

I recall that in some string problems, it's useful to use automata or suffix structures, but I'm not sure.

Alternatively, maybe I can preprocess the string to find all positions where 'map' or 'pie' occur, and then find the minimal set of deletions that cover all these positions.

This sounds similar to the interval covering problem.

Let's try to formalize this.

First, find all starting indices where 'map' or 'pie' appear.

For each such occurrence, mark the positions that form the substring.

Then, for each marked position, decide which character to delete to break the forbidden substring.

To minimize deletions, I should aim to cover multiple forbidden substrings with a single deletion if possible.

For example, in "mapie", deleting 'm' breaks both 'map' and 'pie'.

So, I need to find a set of positions to delete such that every forbidden substring is broken by at least one deletion.

This is equivalent to covering all forbidden substrings by deleting at least one character from each.

This is similar to a set cover problem, which is NP-hard, but perhaps there's a greedy approximation that works well here.

Given the constraints, I need an efficient solution, so a greedy approach might be acceptable.

Here's an idea:

- Collect all positions where 'map' or 'pie' occur.

- For each such occurrence, consider the positions that can break it (i.e., any position within the substring).

- Then, select the position that covers the most uncovered forbidden substrings, delete that position, and repeat until all forbidden substrings are covered.

This is a greedy approach to set cover, which has a logarithmic approximation ratio, but given the constraints, it might be too slow.

Moreover, implementing this efficiently is challenging.

I need a better way.

Let me think about this differently.

Suppose I iterate through the string and try to build a new string by skipping characters that are part of forbidden substrings.

But I need to skip characters in a way that minimizes the total number of skips.

This sounds like a greedy approach where I prioritize skipping characters that are part of multiple forbidden substrings.

But again, it's not straightforward to implement efficiently.

Wait, perhaps I can use a sliding window of size 3 and check for 'map' and 'pie' at each step, and decide which character to skip in the window to break the forbidden substring.

But this might not be optimal, especially with overlapping substrings.

Let me consider a different perspective.

I need to ensure that no 'map' or 'pie' appears in the final string.

So, I can think of the problem as finding a subsequence of the string that doesn't contain 'map' or 'pie' as substrings.

My goal is to maximize the length of this subsequence, and then the number of deletions is n minus this length.

This is similar to finding the longest subsequence without certain forbidden substrings.

Such problems can often be solved using DP, where the state keeps track of the last few characters to ensure no forbidden substring is formed.

Given that 'map' and 'pie' are both of length 3, I can keep track of the last two characters in the DP state.

Let's define dp[i][j], where i is the current position in the string, and j is a pair representing the last two characters in the current subsequence.

Then, dp[i][j] would be the length of the longest subsequence up to position i with the last two characters being j.

The answer would be the maximum dp[n][j] over all possible j, and the number of deletions would be n minus that maximum.

But implementing this would require tracking a lot of states, specifically 26 * 26 = 676 possible pairs, which is manageable.

Let's formalize this.

Define dp[i][j], where i is the current position (0 to n), and j is a tuple representing the last two characters (or a special value for fewer than two characters).

Initialize dp[0][j] = 0 for all j.

For each position i from 0 to n-1:

For each possible last two characters j:

If including s[i] doesn't form a forbidden substring with j, update dp[i+1][ (j[1], s[i]) ].

Else, skip s[i].

Wait, perhaps it's better to iterate through the string and for each position, update the DP based on the previous state.

Let's try to implement this step by step.

First, define the forbidden substrings:

forbidden = {'map', 'pie'}

Define a DP array dp[i][j], where i is the current position, and j is a tuple of the last two characters.

Initialize dp[0][initial] = 0, where initial represents no characters.

For each position i from 0 to n-1:

For each state j (last two characters):

If including s[i] doesn't form a forbidden substring:

Update dp[i+1][ (j[1], s[i]) ] = dp[i][j] + 1

Else:

Option 1: Skip s[i], so dp[i+1][j] = dp[i][j]

Option 2: Include s[i], but this would form a forbidden substring, so not allowed.

Wait, this seems too vague.

Let me try to define it more carefully.

Define states based on the last two characters.

Initialize dp[-1] with an initial state representing no characters.

For each position i from 0 to n-1:

For each state j (last two characters):

If adding s[i] to j doesn't form a forbidden substring, then:

new_state = (j[1], s[i])

dp[i][new_state] = dp[i-1][j] + 1

Else:

Cannot add s[i], so skip it.

Also, for each i, take the maximum over all j.

Wait, this seems computationally intensive for n up to 10^6.

I need a better way to implement this.

Perhaps I can optimize the DP by using the fact that there are only 26 * 26 = 676 possible states for the last two characters.

Then, I can iterate through the string and update the DP for each state accordingly.

Here's a more concrete plan:

- Initialize a dictionary or array to keep track of the maximum subsequence length for each possible pair of last two characters.

- Iterate through each character in the string and update the states accordingly.

- Finally, take the maximum over all states.

But implementing this efficiently requires careful management of the states.

Given time constraints, perhaps there's a simpler, more efficient way.

Let me consider that 'map' and 'pie' are the only forbidden substrings, and think about building the string while avoiding these.

I can keep track of the last two characters added to the new string and decide whether to add the current character or not based on whether it would form a forbidden substring.

This is similar to the DP approach but might be more efficient to implement.

Here's a sketch:

Initialize an empty string new_s.

Initialize a variable last_two = '' (empty string, representing no characters yet).

Iterate through each character in s:

If adding the current character to last_two doesn't form 'map' or 'pie', then add it to new_s and update last_two.

Else, skip the character and do not update last_two.

This seems too simplistic and might not handle overlapping substrings correctly.

Wait, for example, in "mapie", adding 'm' to an empty string is fine, then 'a' is fine, but adding 'p' would make 'ap', which isn't forbidden yet, but adding 'i' would make 'api', which doesn't contain forbidden substrings, and so on.

Wait, this might not capture all cases correctly.

Let me try with "map":

Start with empty new_s.

Add 'm', new_s = 'm', last_two = 'm'

Add 'a', new_s = 'ma', last_two = 'ma'

Add 'p', new_s = 'map', last_two = 'ap' -> but 'map' is forbidden, so I cannot add 'p'.

So, skip 'p', new_s remains 'ma', last_two = 'ma'

Continue with the next character.

This approach seems to handle individual forbidden substrings but might not be optimal in terms of minimizing deletions, especially when substrings overlap.

I need a way to handle overlapping substrings efficiently.

Let me consider another approach: using a sliding window to keep track of the last three characters and decide whether to delete the current character based on whether it forms a forbidden substring with the previous two.

This way, I can handle overlapping substrings by looking at each three-character window and deciding which character(s) to delete in that window.

Here's a possible algorithm:

Initialize a counter for deletions.

Initialize a pointer i to 0.

While i < n - 2:

Check if s[i:i+3] is 'map' or 'pie'.

If it is, increment deletions by 1, and move i by 1 (since deleting one character might be sufficient to break the substring).

Else, move i by 1.

After the loop, if there are remaining characters that could form a forbidden substring with previous characters, handle them accordingly.

But this might not be fully correct, as it doesn't account for overlapping substrings properly.

For example, in "mapie", s[0:3] = 'map' -> delete one character, say 'm', so s becomes 'apie'.

Now, s[1:4] = 'pie' -> delete one character, say 'p', so s becomes 'aie'.

No more forbidden substrings. Total deletions = 2.

This matches the sample output.

But in the initial function, it was deleting three characters, which is suboptimal.

So, perhaps in the loop, after deleting a character, I need to reset the pointer to check the new substring formed after deletion.

However, this could be inefficient for large n.

An alternative is to use a while loop to process the string, keeping track of the last positions where deletions were made.

But this is getting complicated.

Let me consider that each deletion can potentially break multiple forbidden substrings, so I need to maximize the coverage of each deletion.

This sounds like a greedy approach where I select the deletion that covers the most forbidden substrings at each step.

I can represent the forbidden substrings as intervals of length 3, and then select deletions that cover the maximum number of intervals.

This is similar to the interval covering problem, which can be solved greedily by always selecting the deletion that covers the most intervals.

But implementing this efficiently is challenging, especially with n up to 1e6.

Given time constraints, perhaps I need to accept a less optimal but efficient solution.

An acceptable approach might be to iterate through the string and delete characters that are part of forbidden substrings, prioritizing deletions that break multiple forbidden substrings.

To implement this efficiently, I can precompute for each position, the number of forbidden substrings that include that position.

Then, iteratively delete the character with the highest number of forbidden substrings it participates in.

This is a heuristic approach that should work well in practice.

However, implementing this for large n requires efficiency.

Given the time constraints, perhaps the initial function's approach, despite being suboptimal, is acceptable if it's efficient.

But according to the sample inputs, it's not correct.

So, I need to find a better way.

Let me consider that 'map' and 'pie' are the only forbidden substrings, and think about building a new string by skipping characters that are part of these substrings.

To minimize the number of deletions, I should prioritize skipping characters that are part of multiple forbidden substrings.

One way to do this is to iterate through the string and keep track of the forbidden substrings encountered, and decide which character to skip based on how many forbidden substrings it's part of.

But this is still vague.

Let me try to implement a DP solution with states based on the last two characters.

Given that there are only 676 possible states, and n can be up to 1e6, this should be efficient enough.

Here's a plan:

- Define dp[i][j], where i is the current position, and j is a tuple representing the last two characters.

- Initialize dp[-1][('','')] = 0 (empty string).

- For each position i from 0 to n-1:

For each state j:

If adding s[i] to j doesn't form a forbidden substring:

new_state = (j[1], s[i])

dp[i][new_state] = max(dp[i][new_state], dp[i-1][j] + 1)

- The answer is the maximum dp[n-1][j] over all j, and the number of deletions is n - that maximum.

To implement this efficiently, I can use a dictionary to track the states.

But with n up to 1e6 and 676 states, this should be manageable.

Let's try to implement this logic.

First, define the forbidden substrings.

forbidden = {'map', 'pie'}

Then, initialize a DP array.

To optimize, I can use two arrays: previous_dp and current_dp.

Each dp can be a dictionary with keys as tuples of last two characters and values as the length of the subsequence.

Initialize previous_dp with the initial state.

Iterate through each character, update the current_dp based on previous_dp, and then swap.

Finally, take the maximum value in the last dp array.

This seems feasible.

Let's try to implement this logic in code.

But since I'm analyzing the given program, I need to determine if it's correct or not.

Given that the provided function is not producing the correct output for the sample input, I can conclude that it's incorrect.

Therefore, Correctness: **False**

**Final Solution**
To solve this problem, we need to make sure that the given string is beautiful by removing the minimum number of characters such that neither "pie" nor "map" appears as a substring in the string.

### Approach

1. **Problem Understanding:** We need to ensure that the string does not contain "pie" or "map" as substrings. If it does, we have to remove the least number of characters to eliminate these substrings.

2. **Dynamic Programming (DP) Approach:** We can use a DP approach where we track the last two characters to decide whether adding the current character would form a forbidden substring.

3. **DP State Definition:** `dp[i][j]` represents the minimum deletions required for the first `i` characters with the last two characters being `j`.

4. **Transitions:** For each character, we check if adding it to the last two characters forms a forbidden substring. If not, we consider adding it; otherwise, we skip it.

5. **Optimization:** Track the last two characters using a tuple to manage the DP states efficiently.

### Solution Code

```python
def min_deletions_to_beautiful(s):
    forbidden = {'map', 'pie'}
    n = len(s)
    # Initialize DP with defaultdict for easy management
    prev_dp = {}
    prev_dp[('', '')] = 0  # Initial state with no characters

    for i in range(n):
        current_dp = {}
        char = s[i]
        for (last1, last2), count in prev_dp.items():
            # Form the new state
            new_last1 = last2
            new_last2 = char
            new_state = (new_last1, new_last2)
            substring = last1 + last2 + char
            if substring not in forbidden:
                # If no forbidden substring, add the character
                if new_state not in current_dp or current_dp[new_state] < count + 1:
                    current_dp[new_state] = count + 1
            # Always have the option to skip the character
            if (last1, last2) not in current_dp or current_dp[(last1, last2)] < count:
                current_dp[(last1, last2)] = count
        prev_dp = current_dp
    
    # The maximum length of a beautiful substring
    max_beautiful_length = max(prev_dp.values())
    # The minimum deletions required
    min_deletions = n - max_beautiful_length
    return min_deletions

# Read input
import sys
input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
for _ in range(t):
    n = int(data[index])
    s = data[index + 1]
    print(min_deletions_to_beautiful(s))
    index += 2
```

### Explanation

1. **DP Initialization:** We start with an empty state and iteratively build up the DP table.
2. **State Transitions:** For each character, we consider adding it to the current subsequence only if it doesn't form a forbidden substring with the last two characters.
3. **Skip Option:** We always have the option to skip the current character without adding it to the subsequence.
4. **Final Calculation:** The minimum deletions are calculated by subtracting the length of the longest beautiful subsequence from the original string's length.

This approach ensures that we handle overlapping substrings efficiently and find the optimal solution within acceptable time limits.