Alright, I've got this problem to solve. Let's see what it's asking for. So, Monocarp wants to throw a party and he has n friends. He wants at least 2 of them to come to the party. Each friend has a best friend, and these best friends are specified in this list p, where p_i is the best friend of the i-th friend. The conditions are that all p_i are distinct and p_i is never equal to i, which makes sense because someone's best friend can't be themselves.

Now, Monocarp can send invitations to some of his friends. The interesting part is that a friend will only come to the party if both they and their best friend receive an invitation. So, for friend i to come, both friend i and friend p_i must receive invitations.

The goal is to find the minimum number of invitations Monocarp has to send so that at least 2 friends come to the party.

First, I need to understand how these friendships are structured. Since each friend has a unique best friend and no one is their own best friend, this forms pairs or cycles among the friends.

For example, if n=4 and p=[2,1,4,3], then friend 1's best friend is 2, and friend 2's best friend is 1, so they form a cycle of length 2. Similarly, friend 3's best friend is 4, and friend 4's best friend is 3, forming another cycle of length 2.

In another case, if n=4 and p=[2,3,4,1], then friend 1's best friend is 2, friend 2's best friend is 3, friend 3's best friend is 4, and friend 4's best friend is 1, forming a single cycle of length 4.

So, the friendships can form cycles, and the key is to identify these cycles and see how to minimize the number of invitations while ensuring that at least 2 friends come to the party.

Let's think about the example given in the problem:

First test case:

n=5

p=[3,1,2,5,4]

So, friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

This forms two cycles: one cycle of length 3 (1->3->2->1) and one cycle of length 2 (4->5->4).

In this case, the answer is 2, meaning Monocarp can send invitations to just 2 friends to get at least 2 friends to come to the party.

From the explanation, if he sends invitations to friends 4 and 5, both will come because each has their best friend invited.

Similarly, in the second test case:

n=4

p=[2,3,4,1]

This forms a single cycle of length 4: 1->2->3->4->1.

The answer is 3, meaning he needs to send invitations to 3 friends to get at least 2 to come.

And in the third test case:

n=2

p=[2,1]

This is a cycle of length 2.

The answer is 2, meaning he sends invitations to both friends, and both will come.

So, I need to find a general way to determine the minimum number of invitations needed based on the cycle structure.

Let's consider that in a cycle of length k, to get one friend to come, Monocarp needs to send invitations to two adjacent friends in the cycle because only then will one friend come (since both the friend and their best friend are invited).

But the problem requires at least two friends to come.

So, in a cycle of length k, how many invitations are needed to get at least two friends to come?

Let's think about it.

In a cycle of length k, to get one friend to come, you need to invite two adjacent friends. To get a second friend to come, you need to invite two more adjacent friends who are not already invited.

Wait, no. In the first test case, with two cycles: one of length 3 and one of length 2, sending invitations to two friends from the length 2 cycle makes both friends from that cycle come, so that's at least two friends coming.

In the second test case, with a single cycle of length 4, to get two friends to come, you need to invite three friends. For example, invite friends 1, 2, and 3. Then, friends 1 and 2 will come because both 1 and 2 are invited, and 2 and 3 are invited. So, friend 1 and friend 2 will come.

Wait, but according to the problem's explanation, it's not possible to do it with fewer than 3 invitations.

Wait, but maybe there's a better way.

Wait, if I invite friends 1, 3, and 4.

Then, friend 1 and friend 3 will come because 1 and 2 are invited, and 3 and 4 are invited.

So, yes, at least two friends come.

Seems like in a cycle of length 4, you need to invite at least 3 friends to get at least two friends to come.

Similarly, in a cycle of length 3, to get two friends to come, you might need to invite 3 friends.

Wait, but in the first test case, there's a cycle of length 3 and one of length 2. By inviting two friends from the length 2 cycle, you get two friends to come, so you don't need to invite anyone from the length 3 cycle.

So, perhaps the strategy is to identify cycles and see how many invitations are needed per cycle to get at least a certain number of friends to come.

But the problem is to get at least two friends from all friends, not necessarily from the same cycle.

So, perhaps the minimal number of invitations is determined by the smallest cycle.

Wait, but in the first test case, there's a cycle of length 2 and one of length 3. By inviting two friends from the cycle of length 2, you get two friends to come, which satisfies the condition.

In the second test case, there's only one cycle of length 4, so you need to invite 3 friends to get at least two to come.

In the third test case, there's only one cycle of length 2, so inviting two friends makes both come.

So, perhaps the general approach is:

- Identify all cycles in the friendship graph.

- For each cycle, determine the minimal number of invitations needed to get at least one friend to come, and then see how many such minimal invitations across cycles are needed to reach at least two friends coming.

Wait, but it's a bit more nuanced because you can have multiple cycles, and you need to ensure that at least two friends come from the overall friendship graph, not necessarily one from each cycle.

So, perhaps the minimal number of invitations is the minimal number needed to get at least two friends to come from any combination of cycles.

Wait, perhaps there's a better way to think about it.

Let me consider that each pair of friends in a cycle who are best friends can be invited together to make one friend come.

So, in a cycle of length k, the number of such pairs is k.

But to get at least two friends to come, you might need to invite multiple such pairs.

Wait, maybe inclusion-exclusion is getting too complicated.

Let me look for a different approach.

Looking back at the problem, perhaps I can model this as a graph where friends are nodes and best friendships are edges.

Given that p_i is the best friend of i, and p_i != i and all p_i are distinct, this forms a graph where each connected component is a cycle.

Since p_i are distinct and p_i != i, this is a disjoint set of cycles.

So, the graph is a disjoint union of cycles.

Given that, I need to select a set of edges (invitations) such that for at least two nodes, both ends of their best friendship edge are invited.

Wait, but in this problem, inviting a friend corresponds to selecting a node, not an edge.

Wait, no, actually, inviting a friend is selecting a node, but for a friend to come, both the friend and their best friend need to be invited, which means both nodes in that edge need to be invited.

So, it's like selecting a set of nodes such that for at least two nodes, both the node and its neighbor (best friend) are in the set.

Hmm.

Wait, perhaps I can think of it in terms of selecting pairs.

Wait, maybe I should consider that to make a friend come, you need to invite both the friend and its best friend.

So, in terms of edges, you need to select both endpoints of an edge to make one friend come.

But you need at least two friends to come, so you need at least two such pairs.

Wait, but in the first test case, by inviting two friends from the cycle of length 2, you get two friends to come, which is more efficient.

Wait, perhaps the minimal number of invitations is equal to the minimal number of pairs needed to get at least two friends to come, multiplied by two.

But that doesn't seem right, because in the second test case, inviting three friends allows two friends to come.

Wait, perhaps I need to think in terms of selecting invitations such that the number of friends who have both them and their best friend invited is at least two.

So, define S as the set of invited friends.

Then, the number of friends who come is the number of friends f in S such that p_f is also in S.

We need this count to be at least two.

So, we need |{f | f in S and p_f in S}| >= 2.

And we need to minimize |S|.

This sounds like a set cover problem or something similar.

Maybe I can look for the smallest S such that the number of friends in S who also have their best friend in S is at least two.

This seems a bit tricky.

Let me consider some small examples.

First test case:

n=5

p=[3,1,2,5,4]

So, the cycles are:

1->3->2->1 (cycle of length 3)

4->5->4 (cycle of length 2)

By inviting friends 4 and 5, both will come because 4 and 5 are invited, and their best friends 5 and 4 are also invited.

So, with 2 invitations, we get 2 friends to come.

Second test case:

n=4

p=[2,3,4,1]

Cycle: 1->2->3->4->1 (cycle of length 4)

To get two friends to come, we need to invite three friends.

For example, invite 1,2,3.

Then, friend 1 and friend 2 will come because 1 and 2 are invited, and 2 and 3 are invited.

So, friends 1 and 2 will come.

Third test case:

n=2

p=[2,1]

Cycle: 1->2->1 (cycle of length 2)

Invite both 1 and 2, and both will come.

So, with 2 invitations, get 2 friends.

So, in general, for cycles of length 2, inviting both friends makes both come.

For cycles of length greater than 2, inviting k friends can make floor(k/2) friends come, I think.

Wait, in the second test case, inviting 3 friends makes 2 friends come, which is floor(3/2)=1.5, rounded down to 1, but actually 2 friends come.

Hmm, maybe that's not the right way to think about it.

Wait, perhaps in a cycle of length k, to get m friends to come, you need to invite at least k - (k - m*2) friends or something like that.

This seems complicated.

Let me think differently.

Suppose there are multiple cycles. To minimize the number of invitations, perhaps it's best to focus on the smallest cycles first.

In the first test case, there's a cycle of length 2 and one of length 3.

By inviting 2 friends from the cycle of length 2, we get 2 friends to come, which is sufficient.

In the second test case, there's only one cycle of length 4, so we need to invite 3 friends to get 2 friends to come.

In the third test case, only one cycle of length 2, so inviting 2 friends makes both come.

So, perhaps the minimal number of invitations is the minimal number required to get at least two friends to come from the smallest cycles first.

But I need a general approach.

Let me consider that in a cycle of length 2, inviting both friends makes both come, so 2 invitations for 2 friends coming.

In a cycle of length 3, inviting 2 friends makes only one friend come (since only one pair is invited), so need to invite 3 friends to make 2 friends come.

In a cycle of length 4, inviting 3 friends makes 2 friends come.

So, in general, for a cycle of length k, the number of invitations needed to get m friends to come is ?

I need to find, for each cycle, the minimal number of invitations needed to get at least m friends to come.

But this seems too involved.

Wait, maybe I can think in terms of selecting pairs.

In a cycle of length k, the number of possible pairs is k, since each friend and their best friend form a pair.

To get one friend to come, you need to select one pair.

To get two friends to come, you need to select two pairs that don't share a friend.

Wait, in a cycle of length 3, selecting two pairs would necessarily share a friend, so you can't get two friends to come with less than 3 invitations.

In a cycle of length 4, selecting two pairs that don't share a friend would require inviting 3 friends.

Wait, for example, in cycle 1-2-3-4-1, selecting pairs (1,2) and (3,4) would require inviting friends 1,2,3,4, but that's 4 invitations, which is more than needed.

Wait, no, to make two friends come, you need to have two pairs where each pair is invited.

But in the second test case, inviting 3 friends makes two friends come, so perhaps there's a better way.

Wait, perhaps in a cycle of length k, the minimal number of invitations to get at least two friends to come is ceil(2k/(k+1)) or something like that.

This is getting too complicated.

Let me look for a different approach.

Perhaps I can consider that in any cycle, to get one friend to come, you need to invite a pair.

To get the second friend to come, you need to invite another pair that doesn't completely overlap with the first pair.

In a cycle of length 2, inviting both makes both come, so 2 invitations for 2 friends.

In a cycle of length 3, inviting any two friends makes only one friend come, so need to invite all three to make two friends come.

In a cycle of length 4, inviting any three friends makes at least two friends come.

So, perhaps in general, for cycles of length 2, 2 invitations suffice to get 2 friends to come.

For cycles of length greater than 2, inviting k-1 friends is not enough to get two friends to come, but inviting k friends is enough.

Wait, in the second test case, inviting 3 out of 4 friends is enough to get two friends to come.

Wait, but in a cycle of length 4, inviting any 3 friends will always make at least two friends come.

Because in a cycle of length 4, selecting any 3 friends will cover at least two pairs.

Wait, no. For example, in cycle 1-2-3-4-1, inviting 1,2,3:

- Friend 1 and 2 are invited, so friend 1 comes.

- Friend 2 and 3 are invited, so friend 2 comes.

So, friends 1 and 2 come.

Similarly, inviting 1,3,4:

- Friend 1 and 4 are invited, but friend 1's best friend is 2, who is not invited, so friend 1 doesn't come.

- Friend 3 and 4 are invited, so friend 3 comes.

- Friend 4's best friend is 1, who is invited, so friend 4 comes.

So, friends 3 and 4 come.

Wait, but in this case, friend 4 comes because 4 and 1 are invited, but friend 1 doesn't come because friend 2 isn't invited.

Wait, no, friend 4 comes because friend 4 and friend 1 are invited, and friend 1's best friend is friend 2, who isn't invited, but that doesn't affect friend 4's attendance.

Wait, according to the problem, friend i comes only if both friend i and friend p_i are invited.

So, friend 4 comes because friend 4 and friend 1 are invited.

Friend 1 doesn't come because friend 2 isn't invited.

So, only friend 4 comes in this scenario.

Wait, that seems contradictory to the earlier statement.

Wait, no, in the second test case, inviting friends 1,2,3 makes friends 1 and 2 come.

But inviting friends 1,3,4 makes only friend 4 come, because friend 1 doesn't have friend 2 invited.

Wait, perhaps I miscalculated.

Wait, in the second test case, p=[2,3,4,1]

So, p_1=2, p_2=3, p_3=4, p_4=1

So, friend 1's best friend is 2.

friend 2's best friend is 3.

friend 3's best friend is 4.

friend 4's best friend is 1.

Now, if Monocarp invites friends 1,3,4:

- friend 1 is invited, and friend 2 (p_1) is not invited, so friend 1 doesn't come.

- friend 3 is invited, and friend 4 (p_3) is invited, so friend 3 comes.

- friend 4 is invited, and friend 1 (p_4) is invited, so friend 4 comes.

So, friends 3 and 4 come.

Wait, but according to the problem's explanation, it's not possible to have at least two friends come with fewer than 3 invitations.

So, in this case, with 3 invitations, we can have at least two friends come.

Hence, the minimal number of invitations is 3.

So, in general, for cycles of length k:

- For k=2: inviting 2 friends makes both come.

- For k>=3: inviting k friends makes all friends come, but to get at least two friends to come, inviting k-1 friends might not be sufficient, as seen in the cycle of length 4.

Wait, in cycle of length 4, inviting 3 friends makes at least two friends come.

Similarly, in cycle of length 3, inviting 3 friends makes all three come.

So, perhaps for cycles of length k, the minimal number of invitations to get at least two friends to come is:

- For k=2: 2 invitations.

- For k>=3: k invitations.

But in the second test case, with k=4, the answer is 3, not 4.

Wait, that contradicts.

So, perhaps for k>=3, inviting k-1 friends is sometimes enough to get at least two friends to come.

Wait, in cycle of length 4, inviting any 3 friends makes at least two friends come.

Similarly, in cycle of length 3, inviting any 2 friends makes only one friend come, so need to invite all 3.

Hence, perhaps for k=2: 2 invitations.

For k=3: 3 invitations.

For k>=4: k-1 invitations.

But in the second test case, k=4, and the answer is 3, which matches k-1.

But in the first test case, there's a cycle of length 3 and one of length 2.

By inviting 2 friends from the cycle of length 2, we get 2 friends to come, which is sufficient.

Hence, the minimal number of invitations is 2.

Similarly, in the third test case, with only a cycle of length 2, inviting 2 friends makes both come.

So, perhaps the general approach is:

- If there are cycles of length 2, then inviting 2 friends from any cycle of length 2 makes 2 friends come.

- Otherwise, for cycles of length k>=3, inviting k-1 friends makes at least two friends come.

Hence, the minimal number of invitations is:

- If there exists a cycle of length 2, then 2.

- Else, for the smallest cycle of length k>=3, invite k-1 friends.

In the second test case, there's only one cycle of length 4, so invite 3 friends.

In the first test case, there's a cycle of length 2, so invite 2 friends.

In the third test case, there's only one cycle of length 2, so invite 2 friends.

This seems consistent with the examples.

So, the strategy is:

- Check if there exists a cycle of length 2.

- If yes, then the minimal number of invitations is 2.

- If no, then for each cycle of length k, invite k-1 friends.

- Since we need at least two friends to come, and in cycles of k>=3, inviting k-1 friends makes at least two friends come, we can take the minimal k-1 among all cycles.

But in the second test case, there's only one cycle of length 4, so k-1=3.

Hence, the answer is 3.

So, generalizing:

- If there exists a cycle of length 2, answer is 2.

- Else, answer is k-1 for the smallest cycle of length k>=3.

But in the second test case, there's only one cycle of length 4, so k-1=3.

Hence, answer is 3.

In the first test case, there's a cycle of length 2, so answer is 2.

In the third test case, there's only one cycle of length 2, so answer is 2.

Hence, the program should check for cycles of length 2, and if present, output 2, else output k-1 for the smallest cycle.

But in the problem's sample input, t=3, with n=5, p=[3,1,2,5,4], n=4, p=[2,3,4,1], n=2, p=[2,1], and output is 2,3,2, which matches our earlier analysis.

So, in terms of implementation, we need to detect cycles in the friendship graph.

But since all p_i are distinct and p_i != i, the graph is a disjoint union of cycles.

Hence, we can perform a graph traversal to identify the cycles.

But given the constraints (n<=50), and t<=5000, we need an efficient implementation.

But since n is small, even O(n^2) per test case should be acceptable.

But perhaps we can do better.

Wait, n<=50 and t<=5000, so total operations should be under 2.5e6, which is acceptable.

So, in each test case, we need to:

- Read n.

- Read the list p, where p_i is the best friend of i.

- Identify if there exists a cycle of length 2.

- If yes, output 2.

- Else, find the smallest cycle length k>=3 and output k-1.

But in the second test case, k=4, so k-1=3.

Hence, the minimal number of invitations is 3.

Wait, but in the first test case, there's a cycle of length 2, so output 2.

In the third test case, only cycle of length 2, so output 2.

Hence, the program should check for the presence of a cycle of length 2, and if present, output 2, else find the smallest cycle and output k-1.

But in the second test case, there's only one cycle of length 4, so output 3.

Hence, the program should:

- For each test case:

- Read n.

- Read p, where p_i is the best friend of i.

- Check if there exists a cycle of length 2.

- If yes, print 2.

- Else, find the smallest cycle length k>=3 and print k-1.

But to implement this efficiently, perhaps we can iterate through the friends and track the cycle lengths.

But since all p_i are distinct and p_i != i, we can treat this as a permutation where each cycle is a disjoint cycle.

Wait, but in permutations, cycles can be of any length, but here, since p_i are distinct and p_i != i, we have cycles of length at least 2.

Hence, we can perform a graph traversal to find the cycle lengths.

But perhaps there's a smarter way.

Wait, in the program provided, it seems to be written in Python, but it's incomplete.

Let me look at the given program:

def func():

n = int(input())

for i in range(n):

x = int(input())

l = list(map(int, input().strip().split()))

for i in range(0, x):

if l[l[i]-1]==i+1:

flag=True

print(2)

break

else:

print(3)

This seems to read t, then for each test case, read n, then read p as a list.

Then, for each friend i from 0 to n-1, check if l[l[i]-1]==i+1, which checks if the best friend of p_i is i, meaning a cycle of length 2.

So, it's checking for the presence of a cycle of length 2.

If it finds any such pair, it prints 2.

Else, it prints 3.

But according to our