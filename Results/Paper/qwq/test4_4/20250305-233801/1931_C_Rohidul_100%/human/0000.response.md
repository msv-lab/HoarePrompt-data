Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers: i, j, and x, where i and j are indices between 1 and n (the size of the array), and x is any integer. Then, I set all elements from index i to j (inclusive) to the value x. The cost of this operation is (j - i + 1) burles, which is basically the number of elements I'm changing.

My goal is to make all elements of the array equal, and I need to find the minimum cost to do this.

First, I need to understand what it means to make all elements equal. If I can choose a subarray and set all its elements to a certain value, I might be able to reduce the number of operations needed or minimize the cost.

Let me consider some examples to get a better grasp.

Take the first example from the problem:

n = 6

a = [1, 2, 3, 4, 5, 1]

I need to make all elements equal with at most one operation. If I choose i=2, j=4, and x=8, the array becomes [1,8,8,8,5,1]. But that's not all equal yet. I can only perform one operation, so I need to find a single operation that minimizes the cost while making the array uniform.

Another example:

n = 7

a = [1,1,1,1,1,1,1]

Here, all elements are already equal, so the cost is 0.

And another one:

n = 8

a = [8,8,8,1,2,8,8,8]

I might need to set the subarray from index 4 to 5 to 8, which would cost 2 burles, making the array [8,8,8,8,8,8,8,8].

From these examples, it seems like I need to find the largest contiguous subarray(s) that already have the same value and try to minimize the cost by maximizing the length of such subarrays.

Wait, but I can set any subarray to any value x, not necessarily to an existing value in the array.

So, perhaps I should think differently. If I can perform at most one operation, I can choose to set a certain part of the array to a specific value x, and the rest will remain as they are. But the goal is to make the entire array equal to x.

Wait, no. If I set a subarray to x, the rest of the array remains as is, but I need the whole array to be equal to x. So, unless the rest of the array is already equal to x, I need to set them to x as well.

But I can only perform one operation, which means I can only set one subarray to x. So, I need to choose x such that the rest of the array is already equal to x, or I need to find a way to cover the entire array with one operation.

Wait, but that seems too restrictive. Maybe I need to choose x and then select a subarray to set to x in such a way that the entire array ends up being equal to x.

Actually, if I choose x and set the entire array to x in one operation, the cost would be n burles. But maybe I can do better by choosing a subarray that doesn't need to be set to x, but somehow make the array uniform.

Hmm, maybe I need to think about the frequency of elements in the array.

Wait, but the problem allows me to set any subarray to any value x, and I can do this only once. So, after this operation, the entire array should be equal.

Let me consider that I set a subarray to a certain value x, and the rest of the array remains as is. But for the array to be uniform, the rest of the array must already be equal to x.

So, if I choose x to be the value that appears most frequently in the array, and find the longest subarray that needs to be set to x to make the whole array equal to x, then the cost would be the length of that subarray.

Wait, I'm getting confused.

Let me try to think differently. Suppose I want the entire array to be equal to some value x. Then, I need to set all elements that are not equal to x to x. If I can perform multiple operations, I could set each non-x element individually, but since I can only perform one operation, I need to cover all non-x elements in one subarray.

Wait, but I can choose any subarray and set it to x. So, if I choose a subarray that contains all the elements that are not equal to x, and set that subarray to x, then the entire array will be equal to x.

The cost would be the length of that subarray.

But I need to minimize the cost, which is the length of the subarray.

So, for a chosen x, the minimal subarray that needs to be set to x is the subarray that contains all the elements not equal to x.

So, the minimal cost for a chosen x is the length of the minimal subarray that covers all elements not equal to x.

Wait, but how do I find that subarray?

Let me think about it.

First, I choose an x.

Then, I identify all positions where a[i] != x.

I need to cover all these positions with a single subarray.

The minimal subarray that covers all these positions is from the minimum index where a[i] != x to the maximum index where a[i] != x.

So, for each x, the cost is the difference between the maximum index and the minimum index where a[i] != x, plus one.

But I need to minimize this cost over all possible x.

Wait, but there might be multiple x values to choose from.

Wait, no. I need to choose one x and make the entire array equal to that x.

So, I need to choose x such that the subarray that needs to be set to x is minimized.

Wait, but actually, I need to minimize the cost, which is the length of the subarray I set to x.

So, for each possible x, calculate the minimal subarray that needs to be set to x to make the entire array equal to x, and then choose the x that gives the minimal subarray length.

Yes, that seems correct.

Let me formalize this.

For a given x, find the minimal j - i + 1 such that all elements not equal to x are within the subarray from i to j.

This is equivalent to finding the minimal subarray that covers all positions where a[k] != x.

But, in practice, for each x, I can find the leftmost position where a[k] != x and the rightmost position where a[k] != x, and set the subarray from leftmost to rightmost to x.

Then, the cost is rightmost - leftmost + 1.

If there are no positions where a[k] != x, then the cost is 0.

So, for each x, compute the minimal subarray length that covers all a[k] != x.

Then, choose the x that minimizes this length.

Wait, but in the problem, I can perform at most one operation. So, I can choose to set a subarray to x, and the rest remains as is.

But, to make the entire array equal to x, the rest must already be equal to x.

So, perhaps another way to think about it is:

- Choose x.

- Find the minimal subarray that covers all elements that are not equal to x.

- Set this subarray to x.

- The cost is the length of this subarray.

- The array will then be all x.

So, to minimize the cost, I need to choose x such that the subarray covering all non-x elements is as small as possible.

Therefore, I should choose x such that the non-x elements are as closely grouped as possible.

Wait, but in practice, I need to find, for each x, the minimal subarray that covers all a[k] != x, and then choose the x for which this subarray is the smallest.

But iterating over all possible x might be inefficient, especially since n can be up to 2e5 and t up to 1e4.

Wait, but in the problem, a[i] can be up to n, and n can be up to 2e5, so iterating over all possible x values directly might not be efficient.

I need a better approach.

Let me consider that the minimal subarray that needs to be set to x is from the leftmost a[k] != x to the rightmost a[k] != x.

So, for each x, find the leftmost position where a[k] != x and the rightmost position where a[k] != x.

Then, the cost is rightmost - leftmost + 1.

I need to minimize this over all x.

Alternatively, if all elements are already equal to x, then the cost is 0.

So, the minimal cost is the minimal rightmost - leftmost + 1 over all x, or 0 if all elements are equal to x for some x.

Wait, but I need to consider that for different x, the leftmost and rightmost positions where a[k] != x may vary.

I need to find, among all possible x, the one where the span of a[k] != x is minimized.

Wait, but to compute this efficiently, perhaps I can find the minimal span that covers all unique elements except one.

Wait, maybe think in terms of the maximum frequency of any x, and then the cost is n - frequency[x].

Wait, that might be a better way.

Let me think about it.

If I choose x to be the most frequent element in the array, then the number of elements that are not x is n - frequency[x], and the minimal subarray that covers all a[k] != x is at least n - frequency[x], but possibly more.

Wait, but in reality, it's exactly n - frequency[x], because I need to cover all elements that are not x.

But, in the earlier approach, for a given x, the minimal subarray that covers all a[k] != x is from the leftmost a[k] != x to the rightmost a[k] != x, which may be less than n - frequency[x], depending on the distribution.

Wait, no. The number of a[k] != x is n - frequency[x], but the span of these elements could be less than n - frequency[x] if they are not spread out.

Wait, no, the span is the difference between the maximum and minimum indices plus one where a[k] != x.

Which may be less than n - frequency[x], depending on how the elements are arranged.

For example, if all a[k] != x are consecutive, then the span is minimal.

So, for each x, the minimal subarray to cover all a[k] != x is the span from the leftmost to the rightmost a[k] != x.

I need to minimize this span over all x.

So, to compute this efficiently, I can:

- Find the frequency of each x.

- For each x, find the leftmost and rightmost positions where a[k] != x.

- Then, the cost for x is rightmost - leftmost + 1.

- Choose the x with the minimal such cost.

But to optimize this, I need a way to compute this without iterating over all x.

Given the constraints, with t up to 1e4 and n up to 2e5, I need an efficient way to compute this.

Let me consider that the minimal span over all x is equivalent to the minimal span that covers all elements that are not the mode (the most frequent element).

Wait, but not necessarily, because the x that minimizes the span may not be the mode.

Wait, perhaps I need to consider multiple x values.

Alternatively, perhaps I can find the minimal window that covers all unique elements except one.

But this seems complicated.

Let me consider another approach.

Suppose I fix x and try to find the minimal subarray that covers all a[k] != x.

To do this efficiently, I can precompute the leftmost and rightmost positions for each x.

But since n can be up to 2e5 and t up to 1e4, I need an efficient way.

An alternative idea:

- Find the leftmost and rightmost positions for each unique value in the array.

- Then, for each unique value x, calculate the span from the leftmost a[k] != x to the rightmost a[k] != x.

- Choose the x that minimizes this span.

But this still seems inefficient for large n and t.

Wait, perhaps I can think differently.

If I choose x to be the value that appears the most frequently at the beginning and end of the array, I might minimize the span.

Wait, maybe I need to look for the longest prefix and suffix that are already equal to some x.

Let me think about the given solution to see if it makes sense.

Looking at the provided program:

def func():

for _ in range(int(input())):

n = int(input())

a = list(map(int, input().split()))

le = len(a)

(l, r) = (0, n - 1)

(st, end) = (1, 1)

while l < r and a[l] == a[l + 1]:

l += 1

st += 1

while r > l and a[r] == a[r - 1]:

r -= 1

end += 1

ans = le - max(st, end)

if a[0] == a[-1]:

ans = max(0, le - (st + end - 1))

print(ans)

So, what is this code doing?

It seems to be trying to find some kind of prefix and suffix that are equal and then calculating the answer based on their lengths.

Specifically:

- It initializes l=0 and r=n-1.

- It has st and end initialized to 1.

- It then extends st as long as a[0] == a[1] == ... == a[l], incrementing l and st.

- Similarly, it extends end as long as a[n-1] == a[n-2] == ... == a[r], decrementing r and incrementing end.

- Then, it sets ans = le - max(st, end).

- If a[0] == a[-1], it sets ans = max(0, le - (st + end - 1)).

I need to understand why this works.

Let me consider the examples provided.

First example:

n=6

a=[1,2,3,4,5,1]

- l starts at 0, a[0]=1, a[1]=2 != a[0], so st=1.

- r starts at 5, a[5]=1, a[4]=5 != a[5], so end=1.

- ans = 6 - max(1,1) = 5.

- a[0] == a[-1], so ans = max(0, 6 - (1+1-1)) = max(0, 6-1) = 5.

But according to the sample output, the answer should be 4.

Wait, perhaps I'm misunderstanding something.

Wait, maybe I misread the sample output. Let's check the sample input and output again.

Sample Input:

8

6

1 2 3 4 5 1

7

1 1 1 1 1 1 1

8

8 8 8 1 2 8 8 8

1

1

2

1 2

3

1 2 3

7

4 3 2 7 1 1 3

9

9 9 2 9 2 5 5 5 3

Sample Output:

4

0

2

0

1

2

6

7

So, for the first test case, the answer is 4, not 5.

Hmm, perhaps I miscalculated.

Let me run the code with the first test case.

n=6

a=[1,2,3,4,5,1]

- l=0, a[0]=1, a[1]=2 != a[0], so st=1.

- r=5, a[5]=1, a[4]=5 != a[5], so end=1.

- ans=6 - max(1,1)=5.

- a[0]==a[-1], so ans=max(0, 6 - (1+1-1))=max(0,6-1)=5.

But the sample output is 4.

There's a discrepancy here.

Maybe the code is incorrect.

Wait, perhaps I need to understand the logic better.

Let me consider another test case.

Second test case:

n=7

a=[1,1,1,1,1,1,1]

- l=0, a[0]=1, a[1]=1 == a[0], so l=1, st=2.

- Continue: a[1]=1, a[2]=1 == a[1], l=2, st=3.

- a[2]=1, a[3]=1 == a[2], l=3, st=4.

- a[3]=1, a[4]=1 == a[3], l=4, st=5.

- a[4]=1, a[5]=1 == a[4], l=5, st=6.

- a[5]=1, a[6]=1 == a[5], l=6, st=7.

- Now, r=5, a[5]=1, a[4]=1 == a[5], r=4, end=2.

- a[4]=1, a[3]=1 == a[4], r=3, end=3.

- a[3]=1, a[2]=1 == a[3], r=2, end=4.

- a[2]=1, a[1]=1 == a[2], r=1, end=5.

- a[1]=1, a[0]=1 == a[1], r=0, end=6.

- ans=7 - max(7,6)=7-7=0.

- a[0]==a[-1], so ans=max(0,7-(7+6-1))=max(0,7-12)=max(0,-5)=0.

Which matches the sample output.

Third test case:

n=8

a=[8,8,8,1,2,8,8,8]

- l=0, a[0]=8, a[1]=8 == a[0], l=1, st=2.

- a[1]=8, a[2]=8 == a[1], l=2, st=3.

- a[2]=8, a[3]=1 != a[2], stop. st=3.

- r=7, a[7]=8, a[6]=8 == a[7], r=6, end=2.

- a[6]=8, a[5]=8 == a[6], r=5, end=3.

- a[5]=8, a[4]=1 != a[5], stop. end=3.

- ans=8 - max(3,3)=8-3=5.

- a[0]==a[-1], so ans=max(0,8-(3+3-1))=max(0,8-5)=3.

But the sample output is 2, not 3.

Another discrepancy.

Wait, perhaps there's a mistake in understanding the code.

Let me look at the code again.

The code does:

if a[0] == a[-1]:

ans = max(0, le - (st + end - 1))

else:

ans = le - max(st, end)

In the third test case, a[0]==a[-1]==8, so ans=max(0,8-(3+3-1))=max(0,8-5)=3.

But sample output is 2.

So, the code seems incorrect.

Wait, maybe I need to think differently.

Perhaps the correct approach is to find the minimal subarray that needs to be set to x to make the entire array equal to x, for some x, and choose the x that minimizes this subarray length.

An optimal choice of x might be a value that already appears frequently at both ends of the array.

Wait, perhaps the correct approach is to find the maximum length of prefix and suffix that are equal to some x, and then the answer is n - (prefix + suffix - overlap).

Wait, perhaps inclusion-exclusion is needed.

Let me consider that I choose x to be a[0].

Then, I need to set the subarray from the leftmost a[k] != x to the rightmost a[k] != x to x.

Similarly, if I choose x to be a[-1], I need to set the subarray from the leftmost a[k] != x to the rightmost a[k] != x to x.

Then, the minimal cost is the minimal length of such subarrays over all x.

But implementing this efficiently is tricky.

An alternative approach is to find the maximum length of a prefix and a suffix that have the same value, and then the minimal subarray to set is the middle part.

Wait, perhaps.

Let me try.

Choose x = a[0].

Find the leftmost a[k] != a[0] and rightmost a[k] != a[0].

Then, the subarray to set is from leftmost to rightmost.

Similarly for x = a[-1].

Then, take the minimal of these.

But in the first test case, a[0]=1, a[-1]=1.

Leftmost a[k] != 1 is index 1 (a[1]=2), rightmost a[k] !=1 is index 4 (a[4]=5).

So, subarray from 1 to 4, length 4.

Hence, ans=4.

Which matches the sample.

In the third test case, a[0]=8, a[-1]=8.

Leftmost a[k] !=8 is index 3 (a[3]=1), rightmost a[k] !=8 is index 4 (a[4]=2).

So, subarray from 3 to 4, length 2.

Hence, ans=2.

Which matches the sample.

In the second test case, all a[k]=1, so leftmost a[k] !=1 does not exist, hence ans=0.

Which matches.

In the fourth test case, n=1, a=[1], ans=0.

In the fifth test case, n=2, a=[1,2], choose x=1, subarray from 2 to 2, length 1.

Alternatively, choose x=2, subarray from 1 to 1, length 1.

Hence, ans=1.

In the sixth test case, n=3, a=[1,2,3], choose x=1, subarray from 2 to 3, length 2.

Choose x=2, subarray from 1 to 1 and 3 to 3, but since only one operation, it's not possible.

Wait, no. With one operation, I can set a subarray to x.

So, choose x=1, set subarray from 2 to 3 to 1, making [1,1,1].

Cost=2.

Similarly, choose x=3, set subarray from 1 to 2 to 3, making [3,3,3].

Cost=2.

Hence, ans=2.

Seventh test case, n=7, a=[4,3,2,7,1,1,3].

Choose x=1, set subarray from 0 to 3 and 6 to 6 to 1.

But only one operation, so set from 0 to 6 to 1, cost=7.

Choose x=3, set from 0 to 4 and 5 to 5 to 3, cost=6.

Choose x=2, similar cost.

Hence, minimal cost is 6.

Which matches the sample.

Eighth test case, n=9, a=[9,9,2,9,2,5,5,5,3].

Choose x=9, set from 2 to 8 to 9, cost=7.

Choose x=5, set from 0 to 3 and 5 to 8 to 5, but only one operation, so set from 0 to 8 to 5, cost=9.

Choose x=3, set from 0 to 7 to 3, cost=8.

Minimal is 7.

Which matches the sample.

So, the correct approach is:

- Choose x to be a[0] or a[-1].

- Find the leftmost and rightmost positions where a[k] != x.

- The subarray to set is from leftmost to rightmost.

- The cost is rightmost - leftmost + 1.

- If a[0] == a[-1], then the overlap at a[0] should be considered.

Wait, but in the code, it seems to handle a[0] == a[-1] differently.

Let me see.

In the code:

if a[0] == a[-1]:

ans = max(0, le - (st + end - 1))

else:

ans = le - max(st, end)

In the first test case:

a[0]=1, a[-1]=1, so ans = max(0,6 - (3 + 2 -1)) = max(0,6-4)=2.

But according to the sample, it should be 4.

Wait, there's inconsistency here.

Wait, perhaps I miscalculated st and end.

In the first test case:

a=[1,2,3,4,5,1]

- l=0, a[0]=1, a[1]=2 !=1, so st=1.

- r=5, a[5]=1, a[4]=5 !=1, so end=1.

- ans=6 - max(1,1)=5.

- Since a[0]==a[-1], ans=max(0,6 - (1+1-1))=max(0,6-1)=5.

But sample output is 4.

So, the code seems incorrect.

Wait, perhaps the logic is different.

Wait, perhaps st is the length of the prefix equal to a[0], and end is the length of the suffix equal to a[-1].

In the first test case:

a=[1,2,3,4,5,1]

- st=1 (only a[0]=1)

- end=1 (only a[5]=1)

- Since a[0]==a[-1], ans=max(0,6 - (1+1 -1))=max(0,6-1)=5.

But sample output is 4.

So, perhaps the formula is incorrect.

Wait, perhaps it's le - (st + end - overlap).

But I'm getting confused.

Let me think differently.

If I choose x=a[0], then I need to set all a[k] != a[0] to a[0].

The minimal subarray to cover all a[k] != a[0] is from the leftmost a[k] != a[0] to the rightmost a[k] != a[0].

In the first test case, leftmost !=1 is index 1, rightmost !=1 is index 4.

So, subarray from 1 to 4, length=4.

Hence, ans=4.

Similarly, if I choose x=a[-1]=1, same as above.

Hence, ans=4.

In the third test case:

a=[8,8,8,1,2,8,8,8]

Choose x=8:

leftmost !=8 is index 3, rightmost !=8 is index 4.

Subarray from 3 to 4, length=2.

Hence, ans=2.

In the second test case:

a=[1,1,1,1,1,1,1]

Choose x=1:

No need to set any subarray, ans=0.

In the fourth test case:

n=1, a=[1], ans=0.

In the fifth test case:

a=[1,2]

Choose x=1:

Set subarray from 1 to1 (a[1]=2) to 1, length=1.

Choose x=2:

Set subarray from 0 to0 (a[0]=1) to 2, length=1.

Hence, ans=1.

In the sixth test case:

a=[1,2,3]

Choose x=1:

Set subarray from 1 to 2 to 1, length=2.

Choose x=2 or x=3:

Similar length.

Hence, ans=2.

In the seventh test case:

a=[4,3,2,7,1,1,3]

Choose x=1:

Set subarray from 0 to 3 and 6 to 6 to 1.

But only one operation, so set from 0 to 6 to 1, length=7.

Choose x=3:

Set subarray from 0 to 4 and 5 to 5 to 3.

Only one operation, set from 0 to 6 to 3, length=7.

Choose x=2:

Similar.

But in the sample, ans=6.

So, perhaps there's a better choice.

Wait, choose x=1:

Set subarray from 0 to 3 and 6 to 6 to 1.

But only one operation, so set from 0 to 6 to 1, cost=7.

But sample output is 6.

Wait, maybe set from 0 to 4 to 1, and 5 to 6 are already 1, but only one operation, so can't do that.

Wait, no. With one operation, I can set any subarray to x.

So, set from 1 to 6 to 1, cost=6.

Then, the array becomes [4,1,1,1,1,1,1].

Then, set [0] to 1, but that's a second operation, which is not allowed.

Wait, no. I can only perform one operation.

So, set from 0 to 4 to 1, cost=5.

Then, the array is [1,1,1,1,1,1,3].

Then, set [6] to 1, but that's a second operation.

So, with one operation, set from 0 to 6 to 1, cost=7.

But sample output is 6.

Wait, maybe set from 1 to 6 to 1, cost=6.

Then, array becomes [4,1,1,1,1,1,1].

Not all equal.

Wait, need to set from 0 to 6 to 1, cost=7.

Wait, perhaps I misread the sample output.

Wait, sample output for the seventh test case is 6.

But according to this, setting from 1 to 6 to 1, cost=6, array becomes [4,1,1,1,1,1,1].

Then, set [0] to 1 in a second operation, but only one operation is allowed.

So, I need to set a subarray that covers all elements that are not equal to x.

In this case, if I choose x=1, I need to set elements at positions where a[k] !=1, which are positions 0,1,2,3,4,6.

To cover all these positions with one subarray, I need to set from 0 to 6 to 1, cost=7.

But sample output is 6.

So, perhaps there's a better choice of x.

Wait, choose x=3:

Set subarray from 0 to 5 to 3, cost=6.

Array becomes [3,3,3,3,3,3,3].

All equal.

Hence, cost=6.

Similarly, choosing x=1, cost=7.

Hence, minimal cost is 6.

So, the correct approach is:

- Choose x such that the subarray covering all a[k] != x is minimized.

- To find this, for each x, find the leftmost and rightmost positions where a[k] != x.

- Then, the cost is rightmost - leftmost +1.

- Choose the x that gives the minimal such cost.

But to implement this efficiently, I need to do it in linear time per test case.

An efficient way is:

- Find the leftmost and rightmost positions for each unique x.

- Then, for each unique x, calculate the cost as rightmost[x] - leftmost[x] +1.

- Choose the minimal such cost.

- If there exists an x where leftmost[x] > rightmost[x], meaning all elements are equal to x, then cost=0.

But to optimize, I can consider only x that are equal to a[0] or a[-1], as they provide the maximum coverage.

Wait, in the first test case, x=1, leftmost[a[k]!=1]=1, rightmost[a[k]!=1]=4, cost=4.

In the third test case, x=8, leftmost[a[k]!=8]=3, rightmost[a[k]!=8]=4, cost=2.

In the seventh test case, x=1, leftmost[a[k]!=1]=0, rightmost[a[k]!=1]=6, cost=7.

x=3, leftmost[a[k]!=3]=0, rightmost[a[k]!=3]=6, cost=7.

x=2, leftmost[a[k]!=2]=0, rightmost[a[k]!=2]=6, cost=7.

x=7, leftmost[a[k]!=7]=0, rightmost[a[k]!=7]=6, cost=7.

x=5, leftmost[a[k]!=5]=0, rightmost[a[k]!=5]=6, cost=7.

Wait, but earlier I saw that choosing x=3 and setting from 1 to 6 to 3, cost=6.

Wait, perhaps I miscalculated.

If x=3, then a[k] !=3 are positions 0,1,2,4,5,6.

Leftmost=0, rightmost=6, cost=7.

Wait, but earlier I thought setting from 1 to 6 to 3, which would make a[1 to 6]=3, so a=[4,3,3,3,3,3,3].

Then, set a[0] to 3 in a second operation, but only one operation is allowed.

So, with one operation, setting from 1 to 6 to 3, cost=6, array becomes [4,3,3,3,3,3,3].

Not all equal.

Wait, perhaps I need to set from 0 to 6 to 3, cost=7.

Wait, but sample output is 6.

Wait, maybe I'm misunderstanding the operation.

Wait, the operation is to set a subarray to x, not necessarily making the whole array equal to x in one operation.

But the goal is to make the entire array equal to x with at most one operation.

So, if I set a subarray to x, the rest of the array remains as is.

But for the entire array to be equal to x, the rest must already be equal to x.

Hence, I need to choose x and set a subarray to x such that the rest is already x.

So, the subarray should cover all elements that are not equal to x.

Hence, the subarray should be from the leftmost a[k] != x to the rightmost a[k] != x.

Hence, the cost is rightmost - leftmost +1.

So, for x=3 in the seventh test case:

leftmost[a[k]!=3]=0, rightmost[a[k]!=3]=6, cost=7.

But according to the sample, it's 6.

So, perhaps there's a mistake in the sample or my understanding.

Wait, perhaps I can choose x=1 in the seventh test case:

leftmost[a[k]!=1]=1, rightmost[a[k]!=1]=6, cost=6.

Then, set subarray from 1 to 6 to 1, making a=[4,1,1,1,1,1,1].

Then, set a[0] to 1 in a second operation, but only one operation is allowed.

Wait, no. With one operation, I can only set one subarray to x.

So, if I set from 1 to 6 to 1, then the array becomes [4,1,1,1,1,1,1].

Not all equal.

Hence, I need to set from 0 to 6 to 1, cost=7.

But sample output is 6.

Wait, perhaps I'm missing something.

Wait, maybe the operation can be setting a subarray that includes the entire array.

Wait, n=7, set from 0 to 6 to x, cost=7.

But sample output is 6.

Wait, perhaps the operation can be setting a subarray that covers all a[k] != x, but perhaps there's a smarter way.

Wait, perhaps choosing x=1, set from 1 to 5 to 1, cost=5.

Then, array becomes [4,1,1,1,1,1,3].

Then, set [0] and [6] to 1 in separate operations, but only one operation is allowed.

Hence, with one operation, set from 0 to 5 to 1, cost=6.

Array becomes [1,1,1,1,1,1,3].

Then, set [6] to 1 in a second operation, but only one operation is allowed.

Hence, cost=6.

Wait, but according to the problem, I can only perform one operation.

Hence, set from 1 to 6 to 1, cost=6, array becomes [4,1,1,1,1,1,1].

Then, the array is not all 1's.

Wait, perhaps I need to choose x=3 and set from 1 to 6 to 3, cost=6.

Array becomes [4,3,3,3,3,3,3].

Then, set [0] to 3 in a second operation, but only one operation is allowed.

Hence, the array is not fully equal.

Wait, perhaps I need to choose x=1 and set from 0 to 6 to 1, cost=7.

Then, array becomes [1,1,1,1,1,1,1].

All equal.

But sample output is 6.

So, perhaps there's a better choice.

Wait, maybe choosing x=1 and setting from 1 to 6 to 1, cost=6.

Array becomes [4,1,1,1,1,1,1].

Then, set [0] to 1 in a second operation, but only one operation is allowed.

Hence, it's invalid.

Wait, perhaps I need to choose x=3 and set from 1 to 5 to 3, cost=5.

Array becomes [4,3,3,3,3,1,3].

Not all equal.

Hence, with one operation, it's not possible to make the array all equal to 3.

Wait, perhaps I need to choose x=1 and set from 1 to 5 to 1, cost=5.

Array becomes [4,1,1,1,1,1,3].

Then, set [0] and [6] to 1 in separate operations, but only one operation is allowed.

Hence, it's invalid.

Wait, perhaps the minimal cost is indeed 6, by setting from 1 to 6 to 1, cost=6, and accepting that the array becomes [4,1,1,1,1,1,1], which is not fully equal.

But according to the problem, I need to make all elements equal.

Hence, I need to set from 0 to 6 to 1, cost=7.

But sample output is 6.

Wait, perhaps I'm misunderstanding the operation.

Wait, re-reading the problem:

"You can no more than once apply the following operation: select three integers i, j, x (1 ≤ i ≤ j ≤ n) and assign all elements of the array with indexes from i to j the value x. The price of this operation depends on the selected indices and is equal to (j - i + 1) burles."

"make all the elements of the array equal."

Hence, after performing this operation once, the entire array must be equal.

Hence, setting from 1 to 6 to 1, cost=6, doesn't make the entire array equal, as a[0]=4 and a[6]=3 remain.

Hence, to make the entire array equal to 1, I need to set from 0 to 6 to 1, cost=7.

But sample output is 6.

So, perhaps there's a mistake in the sample explanation.

Wait, perhaps I need to choose x=1 and set from 0 to 5 to 1, cost=6.

Then, array becomes [1,1,1,1,1,1,3].

Then, set [6] to 1 in a second operation, but only one operation is allowed.

Hence, invalid.

Wait, perhaps choosing x=3 and setting from 1 to 5 to 3, cost=5.

Array becomes [4,3,3,3,3,1,3].

Then, set [0] and [5] to 3 in separate operations, but only one operation is allowed.

Hence, invalid.

Wait, perhaps the minimal cost is indeed 7, but sample output is 6.

Wait, perhaps I'm misunderstanding the operation.

Wait, perhaps the operation allows setting the subarray to x, and the rest of the array is set to x automatically.

But no, the problem says "assign all elements of the array with indexes from i to j the value x. The price of this operation depends on the selected indices and is equal to (j - i + 1) burles."

Hence, only elements from i to j are set to x, and the rest remain as is.

Hence, to make the entire array equal to x, I need to set a subarray that covers all elements not equal to x to x.

Hence, the minimal subarray that