Alright, I've got this problem to solve. Let's see what it's about. So, there's this game called "Permutation game" where Bodya and Sasha have a permutation and an array. They start at certain positions in the permutation and play a game that lasts for k turns. Each turn, they can choose to stay at their current position or move to the position specified by the permutation. Each time they are at a position, they get points based on the array a. The one with the most points after k turns wins.

First, I need to understand the input and what's being asked. The input consists of multiple test cases. For each test case, I get n (the length of the permutation and array), k (the number of turns), and the starting positions for Bodya and Sasha (P_B and P_S). Then, I get the permutation p and the array a.

I need to determine who wins the game: Bodya or Sasha, or if it's a draw. They both play optimally, meaning they try to maximize their own scores.

Okay, so the key here is to figure out the optimal strategy for both players. Since they make moves simultaneously and independently, each player can decide their own moves without knowing the other's move for that turn.

But wait, the problem says they make moves simultaneously. Does that mean their moves don't affect each other directly? Yes, because they are independent in their choices to stay or move.

So, for each turn, both players decide whether to stay or move to their respective p[x].

But, since they make decisions simultaneously, I don't think one's choice affects the other's choice directly. So, perhaps I can model the game for each player separately and then compare their scores after k turns.

Wait, but the problem says they make moves simultaneously. Does that impose any constraints? I think not, because their choices are independent. So, I can treat each player's path independently.

But, I need to make sure that they are indeed independent. Let's see an example.

Take the first example from the input:

4 2 3 2

Permutation: 4 1 2 3

Array: 7 2 5 6

So, n=4, k=2, P_B=3, P_S=2

Indexing seems to be 1-based, so positions are from 1 to 4.

Let's see what happens in the first turn:

- Bodya is at position 3. He can choose to stay at 3 or move to p[3]=2.

- Sasha is at position 2. He can choose to stay at 2 or move to p[2]=1.

Each chooses independently.

Suppose Bodya chooses to stay at 3, gets a[3]=5 points.

Sasha chooses to move to p[2]=1, gets a[1]=7 points.

Now, for the second turn:

- Bodya is still at 3 (since he chose to stay), can choose again to stay or move to p[3]=2.

- Sasha is now at 1, can choose to stay at 1 or move to p[1]=4.

Again, they choose independently.

If Bodya stays at 3, gets another a[3]=5 points.

Sasha stays at 1, gets a[1]=7 points.

Total scores:

Bodya: 5 + 5 = 10

Sasha: 7 + 7 = 14

But according to the example, Bodya wins with 10 vs. 9. Hmm, maybe I miscounted.

Wait, in the explanation, it shows:

- First turn: Bodya stays at 3 (gets 5), Sasha moves to 1 (gets 7)

- Second turn: Bodya stays at 3 (gets 5), Sasha stays at 1 (gets 7)

Total: Bodya 10, Sasha 14, but the example says Bodya 10, Sasha 9. So, maybe Sasha chose differently.

Wait, perhaps I need to consider that they can choose differently each turn.

Wait, looking back at the problem statement, it says "the players make moves simultaneously. On each turn, two things happen to each player:

- If the current position of the player is x, his score increases by a_x.

- Then the player either stays at his current position x or moves to p_x."

So, each player, at each turn, decides whether to stay or move to p_x, independently of the other player.

The key is that they make these decisions simultaneously, but since their choices don't affect each other's choices, I can model each player's path independently.

Therefore, for each player, I need to find the optimal sequence of stays and moves to maximize their score over k turns.

But, since they are independent, I can compute the optimal score for Bodya and the optimal score for Sasha separately and then compare them.

Now, the challenge is to compute the optimal score for each player given their starting position and the permutation.

Let me think about how to compute the optimal score for one player.

Let's consider a single player starting at position x, with permutation p and array a.

At each turn, the player is at some position y, gets a[y] points, and then chooses to stay at y or move to p[y].

This continues for k turns.

I need to maximize the total points obtained over k turns.

This sounds like a dynamic programming problem.

Let me try to model it.

Define dp[y][t] as the maximum score achievable by being at position y at turn t.

But since n and k can be large (n up to 2e5 and k up to 1e9), I need a more efficient way.

Wait, perhaps I can model the sequence of positions the player can be in.

Given that the player can choose to stay or move at each turn, the sequence of positions can be modeled as a walk where at each step, the player either stays or moves to p[y].

But this seems complicated for large k.

Wait, perhaps I can think in terms of cycles in the permutation.

Permutations can be decomposed into disjoint cycles.

For example, in the first test case:

Permutation: 4 1 2 3

This is cycle: 1 -> 4 -> 3 -> 2 -> 1

So, it's a cycle of length 4.

In this cycle, positions are 1,4,3,2.

Given that, perhaps I can model the player's position over time.

Wait, maybe I should think in terms of graphs, where each position is a node, and there are edges for staying or moving.

But that might not be efficient for large n and k.

Wait, perhaps I can observe that for each player, the sequence of positions over time is determined by their choices to stay or move.

But with k up to 1e9, I need a way to compute the optimal score without simulating each turn.

Let me consider that for a fixed player, starting at position x.

At each turn, the player is at some position y, gets a[y], and then chooses to stay at y or move to p[y].

So, for turn 1:

- Stay at x, get a[x]

- Or move to p[x], get a[p[x]]

Wait, no, the move happens after getting the points.

So, at turn 1:

- Player is at x, gets a[x]

- Then chooses to stay at x or move to p[x]

- At turn 2:

- If stayed at x, gets a[x] again

- If moved to p[x], gets a[p[x]]

And so on.

So, for each turn, the player decides whether to stay or move to p[x], independently of previous choices.

This seems like the player can choose to stay forever or move every turn or some combination.

Given that, perhaps the optimal strategy is to stay at the position with the highest a[x] in their cycle.

But wait, let's consider that if the player stays, they keep getting a[x] each turn.

If they move, they get a[p[x]], and so on.

So, the player can choose to stay at any position in their cycle for any number of turns.

This seems complex to compute naively for large k.

Wait, perhaps I can compute for each player the maximum possible score by choosing to stay at the position with the maximum a[x] in their cycle for all k turns.

But is that always optimal?

Wait, no. Because maybe there are positions with higher a[x] outside their current cycle.

But, since the permutation forms disjoint cycles, the player can only stay or move within their cycle.

Wait, actually, since p is a permutation, and it's a mapping from positions to positions, the player can only be within their cycle.

So, for each player, their possible positions are limited to their cycle in the permutation.

Therefore, for each player, I can find their cycle and then choose to stay at the position within that cycle that has the maximum a[x], and stay there for all k turns to maximize their score.

Is that correct?

Wait, but in the first example, Bodya starts at 3, which is in the cycle 1-4-3-2.

So, his possible positions are 1,4,3,2.

Sasha starts at 2, which is in the same cycle.

So, for Bodya, the maximum a[x] in his cycle is max(a[1],a[4],a[3],a[2]) = max(7,10,5,2) = 10.

So, if he could stay at position 4 (a[4]=10) for all k turns, his total score would be 10*k.

Similarly, Sasha could also stay at position 4 for all k turns and get 10*k.

But in the example, Bodya's final score is 10, and Sasha's is 9.

Wait, that doesn't match.

Wait, perhaps I'm missing something.

Wait, in the first turn, Bodya is at 3, a[3]=5.

He can choose to stay at 3 or move to p[3]=2.

If he stays, he gets a[3]=5.

If he moves, he gets a[3]=5 and then moves to 2, so next turn he's at 2.

Similarly, Sasha is at 2, a[2]=2.

He can choose to stay at 2 or move to p[2]=1.

If he stays, he gets a[2]=2.

If he moves, he gets a[2]=2 and then moves to 1.

In the second turn:

- If Bodya stayed at 3, he gets a[3]=5 again.

- If he moved to 2, he gets a[2]=2.

Similarly for Sasha.

So, the optimal for Bodya is to stay at 3, getting 5+5=10.

For Sasha, he can choose to move to 1 in the first turn, getting a[2]=2, then move to 1, and in the second turn, stay at 1 and get a[1]=7, total 2+7=9.

Alternatively, if Sasha stays at 2 for both turns, he gets 2+2=4.

So, moving to 1 and staying there is better for him, totaling 9.

Hence, Bodya gets 10, Sasha gets 9, Bodya wins.

So, in this case, it's not just about staying at the position with the maximum a[x] in the cycle.

Because if Bodya stayed at 3, getting 5 each turn, total 10, which is less than what he could get if he moved to 2 and then to 1, where a[1]=7.

Wait, but in that case, if Bodya moves to 2, then to 1, he gets a[3]=5, then a[2]=2, then a[1]=7, total 5+2+7=14, which is more than 10.

But in the example, it's a 2-turn game, so he can only get a[x] twice.

Wait, perhaps I'm misunderstanding the movement.

Let me read the problem again.

"On each turn, two things happen to each player:

- If the current position of the player is x, his score increases by a_x.

- Then the player either stays at his current position x or moves to p_x."

So, at each turn, the player is at x, gets a[x], then chooses to stay at x or move to p[x].

So, in a 2-turn game:

Turn 1:

- Bodya is at 3, gets a[3]=5, then chooses to stay at 3 or move to p[3]=2.

- Sasha is at 2, gets a[2]=2, then chooses to stay at 2 or move to p[2]=1.

Turn 2:

- Bodya, if he stayed at 3, gets a[3]=5 again, or if he moved to 2, gets a[2]=2.

- Sasha, if he stayed at 2, gets a[2]=2 again, or if he moved to 1, gets a[1]=7.

So, possible totals:

- Bodya: 5+5=10 (staying at 3), or 5+2=7 (moving to 2).

- Sasha: 2+2=4 (staying at 2), or 2+7=9 (moving to 1).

So, Bodya's best is 10, Sasha's best is 9. Hence, Bodya wins.

But in the earlier thought, if Bodya moves to 2 and then to 1, getting 5 (first turn at 3), then 2 (moving to 2), then 7 (moving to 1). But since k=2, he only gets two a[x], so 5 + 2 = 7.

Wait, no, in k=2 turns, he gets a[x] twice.

So, the sequence is:

- Turn 1: at 3, get a[3]=5, then choose to stay at 3 or move to 2.

- Turn 2: if stayed at 3, get a[3]=5; if moved to 2, get a[2]=2.

Hence, total: 5+5=10 or 5+2=7.

Similarly for Sasha.

So, Bodya's best is 10, Sasha's best is 9.

Hence, Bodya wins.

So, in this case, Bodya's optimal strategy is to stay at 3, getting a[3]=5 each turn, total 10.

Sasha's optimal strategy is to move to 1 in the first turn and stay there in the second turn, getting a[2]=2 in the first turn and a[1]=7 in the second turn, total 9.

Hence, Bodya wins.

So, in general, for each player, the optimal strategy is to choose, for each turn, whether to stay or move, to maximize the sum of a[x] over k turns.

Given that, I need an efficient way to compute the maximum possible sum for each player.

Given that n can be up to 2e5 and k up to 1e9, I need an O(n) solution per test case.

First, since p is a permutation, it forms disjoint cycles.

As seen in the example, positions 1,4,3,2 form a cycle.

In general, I can find the cycle containing the starting position of each player.

Then, for each player, their possible positions are the positions in their cycle, and they can choose to stay at any of these positions in any turn.

Hence, the optimal strategy is to choose, in each turn, to stay at the position in the cycle with the maximum a[x].

Wait, but in the example, even though a[1]=7 and a[4]=10, a[3]=5, a[2]=2, Bodya starts at 3, and his best is to stay at 3 getting 5 each turn, totaling 10, while Sasha starts at 2, and his best is to move to 1 and stay there, getting 2+7=9.

But according to the earlier thought, if Sasha moves to 1 and stays there, he gets 2 (first turn at 2) + 7 (second turn at 1) = 9.

If he stays at 2 for both turns, he gets 2+2=4.

Hence, 9 is better.

But, if he could choose to stay at the position with the maximum a[x] in his cycle, which is a[1]=7, and stay there for both turns, getting 7+7=14.

But that's not possible because in the first turn, he's at 2, gets a[2]=2, then chooses to move to 1, gets a[1]=7 in the second turn.

He cannot choose to stay at 1 in the first turn because he's at 2.

Hence, his choices are limited by his current position and the choice to stay or move.

So, perhaps the optimal strategy is to move to the position with the maximum a[x] in the cycle as soon as possible and stay there for the remaining turns.

In the example, Sasha moves to 1 in the first turn and stays there in the second turn, getting 2 + 7 = 9.

If he had more turns, he could stay at 1 and accumulate more 7's.

Hence, in general, for each player, the optimal strategy is to move to the position in their cycle with the maximum a[x] as soon as possible and then stay there for the remaining turns.

Hence, the maximum sum is:

(a[x1] + a[x2] + ... + a[xm]) + max_a * (k - m)

Where m is the number of turns needed to reach the position with max_a.

But, in the cycle, m could vary.

Wait, perhaps I need to find, for each player, the minimal number of moves needed to reach the position with the maximum a[x] in their cycle, and then stay there for the remaining turns.

But in the example, Bodya starts at 3, and the position with max a[x] in the cycle is 4 with a[4]=10.

From 3, he can move to 2, then to 1, then to 4.

But k=2, so he can only move once to reach 2, then again to move to 1, but not to 4.

Hence, he cannot reach position 4 within 2 turns.

Hence, his best is to stay at 3 and get 5+5=10.

Wait, but in reality, in the first turn, he can choose to stay at 3 and get 5, or move to 2 and get 2.

If he stays at 3 for both turns, he gets 5+5=10.

If he moves to 2 in the first turn, he gets 5 (from 3) + 2 (from 2) = 7.

Hence, staying at 3 is better.

Similarly, Sasha starts at 2.

If he stays at 2 for both turns, he gets 2+2=4.

If he moves to 1 in the first turn, he gets 2 (from 2) + 7 (from 1) = 9.

Hence, moving to 1 and staying there is better.

But, in this case, he cannot reach position 4 (a[4]=10) because he would need to move from 1 to 4, but that would be in the third turn, which is beyond k=2.

Hence, for Sasha, the best is to move to 1 and stay there, getting 2 + 7 = 9.

For Bodya, staying at 3 is better, getting 5 + 5 = 10.

Hence, Bodya wins.

So, generalizing, for each player, I need to find:

- The position in their cycle with the maximum a[x].

- The minimal number of moves needed to reach that position from their starting position.

- Then, the optimal sum is:

(a[x1] + a[x2] + ... + a[xm]) + max_a * (k - m)

Where m is the number of moves needed to reach the position with max_a.

But, in the example, for Bodya, m would be 3 to reach position 4 (3 -> 2 -> 1 -> 4), but k=2, so he cannot reach it.

Hence, he has to settle for staying at 3.

Hence, perhaps I need to consider the minimal m for each player to reach the position with max_a, and if m <= k, then use the formula above, else stay at the current position.

But, in Bodya's case, m=3 > k=2, so he stays at 3 and gets a[b] * k = 5 * 2 = 10.

For Sasha, m=1 to reach position 1 (from 2 to 1), so his sum is a[2] + a[1] * (k-1) = 2 + 7 * 1 = 9.

Hence, Bodya's sum is 10, Sasha's is 9.

Hence, Bodya wins.

So, in code, for each player, I need to:

1. Find the cycle containing their starting position.

2. Find the position in that cycle with the maximum a[x].

3. Find the minimal number of moves needed to reach that position from their starting position.

4. Compute the optimal sum as:

(sum of a[x] along the path to the position with max_a) + (max_a * (k - m))

5. If m > k, then the player cannot reach the position with max_a, so they stay at their current position and get a[x] * k.

Wait, but in Bodya's case, m=3 > k=2, so he stays at 3 and gets 5*2=10.

But in reality, he can choose to stay at 3 for both turns and get 5+5=10, or make moves and get less.

Hence, staying at 3 is optimal.

Similarly, for Sasha, m=1 <= k=2, so he can move to 1 and stay there, getting 2 (first turn) + 7 (second turn) = 9.

If he tries to move again in the second turn, he would move from 1 to 4, getting a[4]=10, but that would be only if k=3.

But since k=2, he can only move once to reach 1 and stay there.

Hence, his sum is 2 + 7 = 9.

Hence, Bodya wins.

So, in code, for each player, I need to:

- Find their cycle.

- Find the position in the cycle with the maximum a[x].

- Find the number of moves needed to reach that position from their starting position.

- Compute the optimal sum as described.

- Then, compare the sums for Bodya and Sasha.

Now, to implement this efficiently, considering that n can be up to 2e5 and t up to 1e4, I need an efficient way to handle this.

First, for each test case, I have different n, k, P_B, P_S, p, and a.

But, since n can be up to 2e5 and t up to 1e4, but the sum of n over all test cases does not exceed 2e5, I can process all test cases together.

Hence, I can process all test cases in one go, reusing the same data structures.

Wait, but each test case has its own n, k, P_B, P_S, p, and a.

Hence, I need to process each test case separately.

But, to optimize, I can find cycles for all positions in O(n) time per test case.

But, since n can be up to 2e5 and t up to 1e4, that would be too slow.

Wait, no, the sum of n over all test cases does not exceed 2e5, so overall time is O(2e5), which is acceptable.

Hence, I can process all test cases in O(2e5) time.

So, in code, I can iterate through all test cases, and for each test case, find the cycles containing P_B and P_S, find the maximum a[x] in those cycles, find the minimal number of moves to reach that position, and compute the sums.

But, to optimize, perhaps I can find, for each position in the cycle, the minimal number of moves to reach the position with max_a.

But, since k can be up to 1e9, I need an efficient way to compute this.

Wait, perhaps I can observe that in a cycle of length m, the positions can reach the position with max_a in at most m moves.

But, since k can be up to 1e9, and m can be up to n (which is 2e5), I need a better approach.

Wait, perhaps I can find, for each position in the cycle, the minimal number of moves to reach the position with max_a.

Then, for each player, I can look up the minimal m for their starting position and compute the sum accordingly.

To implement this efficiently, I can, for each cycle, find the position with max_a, and then for each position in the cycle, compute the minimal number of moves to reach that position.

Given that the cycle is a circular list, I can compute the distance in both directions.

Wait, more precisely, in a cycle, say positions are c1 -> c2 -> ... -> ck -> c1.

I can find the position cm with the maximum a[cm].

Then, for each position ci in the cycle, the minimal number of moves to reach cm is the minimum of the forward and backward distances to cm.

Hence, for each ci, m_i = min((i - j + k) % k, (j - i + k) % k), where j is the index of cm in the cycle.

Then, for each player, given their starting position ci, I can look up m_i and compute the sum accordingly.

This seems efficient.

Hence,