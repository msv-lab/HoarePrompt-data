Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly X, where X can be up to 10^18. If it's not possible, I should output -1. The array elements can be anywhere from -10^9 to 10^9.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence obtained by removing some elements from the array without changing the order of the remaining elements, and the remaining elements are strictly increasing. Also, even if subsequences have the same values, if they come from different positions, they are considered different.

So, for example, if I have the array [1, 2, 3], the increasing subsequences are:

- Empty subsequence

- [1]

- [2]

- [3]

- [1,2]

- [1,3]

- [2,3]

- [1,2,3]

That's a total of 8 increasing subsequences. Wait, but the problem says that an empty subsequence is also increasing, so including the empty one, it should be 2^n, where n is the length of the array. But in this case, 2^3 = 8, which matches.

But in the example given in the problem, for X=2, the output is an array of length 1 with element 0. Let's see: the increasing subsequences would be the empty subsequence and [0], which is 2, matching X=2.

Another example is X=5. The output is an array of length 3: [0,1,0]. The increasing subsequences are:

- Empty

- [0] (first 0)

- [1]

- [0] (second 0)

- [0,1] (first 0 and 1)

That's 5 subsequences, which matches X=5.

So, I need to find an array such that the number of increasing subsequences is exactly X.

First, I need to find a way to calculate the number of increasing subsequences for a given array. But since X can be up to 10^18, and the array can have at most 200 elements, I need an efficient way to construct such an array.

I recall that in sequences where each element is larger than the previous one, the number of increasing subsequences is 2^n, where n is the length of the sequence. But in this problem, the array can have repeated elements, and the subsequences must be strictly increasing.

Wait, but in the example with [0,1,0], the subsequences are:

- Empty

- [0] (first)

- [0] (second)

- [1]

- [0,1] (first 0 and 1)

So, even though there are two 0s, they are considered different because their positions are different.

So, perhaps I can think of the array as having some "chains" of increasing elements, and the total number of increasing subsequences is the product of the number of subsequences in each chain.

Wait, maybe I should think in terms of the number of increasing subsequences ending at each position.

Let me try to formalize this.

Let dp[i] be the number of increasing subsequences ending at position i.

Then, dp[i] = 1 + sum(dp[j] for all j < i where a[j] < a[i])

The total number of increasing subsequences would be the sum of dp[i] for all i, plus 1 for the empty subsequence.

But this seems too slow if I try to construct the array step by step, because X can be up to 10^18.

I need a smarter way.

Wait, perhaps I can think in terms of binary representations.

Since X can be up to 10^18, which is around 60 bits, maybe I can represent X in binary and construct the array based on that.

Wait, but the array can have at most 200 elements, which should be sufficient, since 2^200 is way larger than 10^18.

But I need to find a way to construct the array such that the number of increasing subsequences is exactly X.

Let me think differently.

Suppose I have an array where all elements are distinct and strictly increasing. Then, the number of increasing subsequences is 2^n - 1 (excluding the empty subsequence), but including the empty subsequence, it's 2^n.

But in our problem, empty subsequence is also considered, so for a strictly increasing array with distinct elements, the number of increasing subsequences is 2^n.

But in the example with X=2, which is 2^1, the output is an array of length 1.

Similarly, for X=5, which is not a power of 2, the array is of length 3.

So, perhaps I need to represent X as a sum of powers of 2.

Wait, every number can be represented as a sum of distinct powers of 2, that's the binary representation.

But in this problem, perhaps I need to represent X in binary and construct the array accordingly.

Wait, but in the example with X=5, which is 101 in binary, the output array has length 3.

Is there a connection here?

Let me see.

If I have an array of length 3, the total number of increasing subsequences is 2^3 = 8, but in the example, it's 5.

So, maybe it's not exactly 2^n.

Wait, perhaps I need to make some elements equal so that the number of increasing subsequences is not exactly 2^n.

In the example [0,1,0], the total number is 5, which is less than 8 because some subsequences are not strictly increasing due to duplicates.

So, perhaps I can construct the array by repeating some elements in a way that reduces the total number of increasing subsequences.

But this seems tricky.

Let me think about how the number of increasing subsequences is calculated.

I found that it's equal to the sum of the number of increasing subsequences ending at each position, plus one for the empty subsequence.

So, if I can control the number of increasing subsequences ending at each position, I can control the total number.

But how?

Maybe I can build the array incrementally, adding elements in a way that the total number of increasing subsequences adds up to X.

But X can be up to 10^18, and I need to do this efficiently.

Wait, perhaps I can use the fact that the number of increasing subsequences is the sum of products of certain counts.

I need a better approach.

Let me look at the official solution or think differently.

I recall that in sequences where each element is larger than the previous one, the number of increasing subsequences is 2^n.

But if I have repeated elements, some subsequences may not be strictly increasing.

So, perhaps I can construct an array with repeated elements to reduce the total number of increasing subsequences.

Wait, in the example with X=5, the array is [0,1,0]. The increasing subsequences are:

- Empty

- [0] (first)

- [0] (second)

- [1]

- [0,1]

So, total 5.

If I had [0,1,2], it would have 2^3 = 8 increasing subsequences.

But with [0,1,0], some subsequences are excluded because [0,0] is not strictly increasing.

So, by repeating elements, I can reduce the number of increasing subsequences.

Perhaps I can think of building the array by choosing elements in a way that the number of increasing subsequences is exactly X.

But this seems too vague.

Let me consider the binary representation of X.

Since X can be represented as a sum of distinct powers of 2, maybe I can construct parts of the array that contribute exactly those powers of 2.

For example, for X=5, which is 101 in binary, or 4 + 1, perhaps I can have two separate parts in the array: one that contributes 4 and one that contributes 1.

But I need to ensure that these parts don't interfere with each other.

Wait, maybe I can have disjoint increasing subsequences.

But I need to make sure that the total number of increasing subsequences is exactly X.

This is getting complicated.

Let me look at the sample input and output again.

For X=2, output is [0], which has 2 increasing subsequences: empty and [0].

For X=5, output is [0,1,0], which has 5 increasing subsequences as listed above.

For X=13, output is [2,2,3,4,2], and for X=37, it's [-1,-1,0,0,2,3,-1].

I need to find a pattern here.

Looking at the array for X=5: [0,1,0]

It has two 0's and one 1.

The increasing subsequences are those that select either one of the 0's or both with the 1.

So, perhaps the number of increasing subsequences is the sum over all possible ways to choose one of the multiple occurrences of the same number.

But I need a general way to construct such arrays.

Wait, maybe I can use the fact that if I have a sequence with distinct elements, the number of increasing subsequences is 2^n.

If I introduce duplicates, some subsequences are no longer strictly increasing, so the total number decreases.

Perhaps I can find a way to introduce duplicates in a controlled manner to reach exactly X.

But how?

Another idea: perhaps I can build the array by starting with the smallest possible elements and introducing duplicates only when necessary.

But I need a systematic way.

Let me consider the binary representation of X again.

For X=5, which is 101 in binary, or 4 + 1, perhaps I can have two separate increasing sequences: one of length 2 (which has 4 increasing subsequences) and one of length 0 (which has 1), but that doesn't make sense.

Wait, maybe I can have a sequence that combines smaller sequences in a way that their contributions add up to X.

But I need to ensure that these smaller sequences don't interfere with each other, meaning their increasing subsequences don't mix in a way that changes the total count.

This seems challenging.

Let me think about the maximum number of increasing subsequences possible with an array of length 200.

Since 2^200 is way larger than 10^18, it's feasible in terms of sequence length.

But I need to find a way to construct the array such that the total number of increasing subsequences is exactly X.

I need a better plan.

Let me try to find a way to represent X as a sum of numbers that can be achieved by certain array configurations.

For example:

- An empty array has 1 increasing subsequence (the empty one).

- An array of length 1 has 2 increasing subsequences: empty and the single element.

- An array of length 2 with a < b has 4 increasing subsequences: empty, [a], [b], [a,b].

- If a == b, then only 3: empty, [a], [b], but [a,b] is not strictly increasing.

- Similarly, for longer sequences.

So, perhaps I can build the array by having segments where each segment contributes a certain number of increasing subsequences, and the total is X.

But I need a way to decompose X into such segments.

Wait, maybe I can use the fact that each new element can either be added to existing increasing subsequences or start new ones, depending on its value relative to previous elements.

This seems too vague.

Let me try to think recursively.

Suppose I have already built a part of the array with some number of increasing subsequences, and I add a new element. How does this affect the total number?

If I add an element that is larger than all previous elements, then it can be appended to all existing increasing subsequences, doubling the number of increasing subsequences (since each existing subsequence can choose to include or not include this new element).

But in reality, it's 2^n, where n is the length, but in this case, with possible duplicates, it's not that straightforward.

Wait, perhaps I should look for a way to represent X as a sum of powers of 2, and then construct corresponding segments in the array.

For example, for X=5, which is 101 in binary, or 4 + 1, perhaps I can have one segment that contributes 4 and another that contributes 1.

But how do I ensure that these segments don't interfere with each other?

Maybe I can separate them with elements that are decreasing between segments, so that no increasing subsequence can span across segments.

For example, if I have a segment [1,2], which has 4 increasing subsequences, and then a segment [0], which has 1 increasing subsequence, and ensure that no element in the second segment is larger than any element in the first segment, then the total number of increasing subsequences would be 4 + 1 = 5.

Wait, let's try that.

Suppose the array is [1,2,0].

The increasing subsequences are:

- Empty

- [1]

- [2]

- [1,2]

- [0]

Total: 5, which matches X=5.

Yes, that works.

So, perhaps I can split the array into segments where each segment is strictly increasing, and the elements in later segments are smaller than all elements in previous segments.

That way, no increasing subsequence can span across segments, and the total number of increasing subsequences is just the sum of the increasing subsequences in each segment.

Each segment contributes 2^{len(segment)} increasing subsequences, including the empty one.

So, for X=5, which is 101 in binary, or 4 + 1, I can have one segment of length 2 (contributing 4) and one segment of length 0 (contributing 1), but length 0 doesn't make sense.

Wait, in the example, it's [1,2,0], which are three segments: [1,2] and [0].

Wait, no. If I have [1,2,0], there are two segments: [1,2] and [0], assuming that decreasing elements separate segments.

But in reality, in this array, [1,2,0], the segments are [1,2] and [0], and the total number is 4 (from [1,2]) + 1 (from [0]) = 5.

Perfect.

So, generalizing, if I represent X in binary, each '1' in the binary representation corresponds to a segment whose length is the position of that bit.

Wait, not exactly the position, but the length that gives 2^{len} equal to the value of that bit.

For example, for X=5, which is 101 in binary, or 4 + 1, I can have one segment of length 2 (2^2 = 4) and one segment of length 0 (2^0 = 1).

But a segment of length 0 doesn't make sense in an array.

Wait, perhaps I need to adjust this.

Let me think again.

If I have segments of lengths l1, l2, ..., lk, each segment contributes 2^{l1}, 2^{l2}, ..., 2^{lk} increasing subsequences, including the empty one.

But since the empty subsequence is counted in each segment, but in the total, there should be only one empty subsequence.

So, perhaps I need to subtract the empty subsequences from each segment except one.

Wait, that seems complicated.

Alternatively, I can consider that the total number of increasing subsequences is the sum of the number of increasing subsequences in each segment, because no subsequence can span multiple segments.

In that case, if each segment is strictly increasing and separated by decreasing elements, then yes, the total number is the sum of 2^{l1} + 2^{l2} + ... + 2^{lk}.

So, to make the total number equal to X, I need to choose segments such that the sum of 2^{l1} + 2^{l2} + ... + 2^{lk} = X.

But wait, that's exactly the binary representation of X.

In binary representation, X is the sum of distinct powers of 2.

So, for X=5 = 4 + 1 = 2^2 + 2^0, I need two segments: one of length 2 and one of length 0.

But a segment of length 0 doesn't make sense in an array.

Hmm.

In practice, for a segment of length 0, I can just not include it and consider only segments of positive lengths.

Wait, but in the example for X=2, which is 10 in binary, or 2^1, the output is a single element [0], which has 2 increasing subsequences: empty and [0]. So, 2^1 = 2.

Similarly, for X=5 = 2^2 + 2^0, but since 2^0 =1 corresponds to the empty subsequence, which is already included, maybe I can ignore the 2^0 term.

Wait, that might not be accurate.

Wait, in the array [1,2,0], we have segments [1,2] and [0], contributing 4 and 1, totaling 5.

So, including a segment of length 0 would correspond to adding 1, which is the empty subsequence.

But in practice, the empty subsequence is already included in the total count, so maybe I need to handle it differently.

Let me try to formalize this.

Let S be the set of segments in the array, where each segment is strictly increasing and separated by decreasing elements.

Then, the total number of increasing subsequences is the sum over all segments s in S of 2^{len(s)}.

But, since the empty subsequence is included in each segment's count, but in the overall array, there should be only one empty subsequence.

Therefore, the total number of increasing subsequences is sum over s in S of 2^{len(s)} - |S| + 1.

Because we subtract the multiple counts of the empty subsequence and add one for the overall empty subsequence.

But this seems complicated.

Alternatively, perhaps it's easier to consider that the empty subsequence is only counted once overall, and the non-empty increasing subsequences are the sum over s in S of 2^{len(s)} -1.

But I'm getting confused.

Let me try with an example.

Take X=5, array [1,2,0]:

- Segment [1,2]: 4 subsequences (empty, [1], [2], [1,2])

- Segment [0]: 2 subsequences (empty, [0])

- Total: 4 + 2 = 6, but in reality, the total is 5.

Wait, that doesn't match.

So, perhaps my earlier assumption is wrong.

Looking back, in the array [1,2,0], the increasing subsequences are:

- Empty

- [1]

- [2]

- [1,2]

- [0]

Total: 5.

But according to my previous calculation, it should be 6.

So, perhaps there is no overlap in subsequences across segments.

Wait, but in this case, the empty subsequence is counted only once.

Wait, maybe when I sum the number of increasing subsequences from each segment, I need to subtract the empty subsequences except for one.

So, total increasing subsequences = (sum over s in S of 2^{len(s)}) - (|S| - 1).

In the above example:

sum over s: 2^2 + 2^1 = 4 + 2 = 6

number of segments: 2

total increasing subsequences: 6 - (2 - 1) = 5, which matches.

Similarly, for X=2, array [0]:

sum over s: 2^1 = 2

number of segments: 1

total: 2 - (1 - 1) = 2, which matches.

So, this seems to hold.

Therefore, to achieve X, I need to choose segments such that sum over s of 2^{len(s)} - (|S| - 1) = X.

Wait, but in the X=5 case, it's 4 + 2 -1 =5.

But 4 corresponds to 2^2, which is len(s)=2, and 2 corresponds to 2^1, which is len(s)=1.

So, sum of 2^{len(s)} is 4 + 2 =6, then subtract (2 -1)=1, to get 5.

Similarly, for X=13, which is 1101 in binary, or 8 + 4 + 1.

But according to this formula, sum of 2^{len(s)} - (|S| -1).

If X=13, then possible segments could be lengths corresponding to 8, 4, and 1.

So, lengths 3, 2, and 0.

But length 0 doesn't make sense.

Wait, perhaps I can have segments with lengths that correspond to the powers of 2 in the binary representation of X.

But adjust for the empty subsequence.

This is getting too convoluted.

Let me think differently.

Suppose I represent X as sum of distinct powers of 2, which is its binary representation.

Then, for each '1' bit in X, I can create a segment whose length corresponds to the exponent of that power of 2.

Then, arrange these segments in decreasing order of their maximum elements, ensuring that no segment's elements overlap with others.

But I need to account for the empty subsequence being counted only once.

Wait, perhaps I can arrange the segments in such a way that they don't interfere with each other, and then adjust the total count accordingly.

This seems too vague.

Let me look for a different approach.

I recall that in dynamic programming, we can calculate the number of increasing subsequences efficiently.

But in this problem, I need to construct the array based on X.

Perhaps I can build the array incrementally, choosing each element such that it adds the correct number of new increasing subsequences.

But with X up to 10^18, I need an efficient way.

Wait, perhaps I can use the fact that the number of increasing subsequences is the product of the number of choices for each element.

But I'm not sure.

Let me consider starting with the smallest possible array and increasing its size until the number of increasing subsequences reaches X.

But with X up to 10^18, this is not feasible.

I need a smarter way.

Let me consider that for an array of n elements, the number of increasing subsequences can be up to 2^n.

So, for n=200, 2^200 is way larger than 10^18.

So, n=60 would suffice since 2^60 is around 10^18.

But I need to find a way to set the array such that the number of increasing subsequences is exactly X.

Wait, perhaps I can construct the array by setting the first element to some value, and then each subsequent element is set to a value larger than all previous if I need to double the number of increasing subsequences.

Wait, no, because adding an element larger than all previous elements would double the number of increasing subsequences.

But X may not be a power of 2.

Wait, but if I add elements in a way that some of them are equal to previous elements, I can control the growth of the number of increasing subsequences.

But this seems too vague.

Let me try to think in terms of binary representation again.

Suppose X is represented in binary as a sum of distinct powers of 2.

Then, for each power of 2 in the representation, I can create a segment of the array that contributes exactly that power of 2 to the total number of increasing subsequences.

To do this, I need to ensure that segments are separated in such a way that their contributions add up without interfering.

One way to ensure no interference is to separate segments with elements that are decreasing between segments.

For example, have segments of increasing elements separated by decreasing elements.

In this way, no increasing subsequence can span multiple segments.

Then, the total number of increasing subsequences is the sum of the increasing subsequences in each segment.

Each segment being strictly increasing, its contribution is 2^{len(segment)}.

But as we saw earlier, sum of 2^{len(s)} - (|S| -1) = X.

Wait, perhaps I can set sum of 2^{len(s)} - (|S| -1) = X and solve for the lengths of the segments.

But this seems complicated.

Alternatively, perhaps I can set sum of 2^{len(s)} = X, and then adjust for the empty subsequences.

But X includes the empty subsequence, so perhaps sum of 2^{len(s)} - |S| +1 = X.

Wait, in the earlier example, sum of 2^{len(s)} =6, and |S|=2, so 6 -1 =5, which matches X=5.

So, generalizing, sum of 2^{len(s)} - (|S| -1) = X.

So, sum of 2^{len(s)} = X + (|S| -1).

But I need to choose |S| and lengths l1, l2, ..., lk such that sum of 2^{l1} + 2^{l2} + ... + 2^{lk} = X + (|S| -1).

This seems a bit messy.

Alternatively, perhaps I can represent X as a sum of distinct powers of 2, and then for each power of 2, create a segment whose length corresponds to the exponent.

But I need to adjust for the empty subsequence.

Wait, perhaps I can represent X-1 as a sum of distinct powers of 2, and then create segments corresponding to those powers.

Then, the total number of increasing subsequences would be sum of 2^{len(s)} = X -1 + |S|.

Wait, in the earlier example, X=5, X-1=4.

Then, 4 can be represented as 4, which is 2^2.

So, create a segment of length 2, which contributes 4.

Then, |S|=1, so sum of 2^{len(s)} =4, which is X-1.

But X-1=4, and sum of 2^{len(s)} =4, so X=5.

Similarly, for X=13, X-1=12, which is 8 +4, or 2^3 + 2^2.

So, create segments of lengths 3 and 2, contributing 8 and 4, sum=12.

Then, |S|=2, so total increasing subsequences =12 +2 -1=13, which matches.

Similarly, for X=37, X-1=36, which is 32 +4, or 2^5 + 2^2.

So, segments of lengths 5 and 2, contributing 32 and 4, sum=36.

|S|=2, total=36 +2 -1=37.

Perfect.

So, the general approach is:

1. Set Y = X -1.

2. Represent Y as a sum of distinct powers of 2.

3. For each power of 2 in the sum, create a segment of that length.

4. Arrange these segments in the array such that no increasing subsequence can span across segments.

5. The total number of increasing subsequences will be sum of 2^{len(s)} - (|S| -1) = Y + |S| -1 +1 = X.

Wait, let's verify:

sum of 2^{len(s)} = Y

total increasing subsequences = Y + |S| -1 +1 = Y + |S| = X.

Wait, but in the earlier examples, it worked.

Wait, in the X=5 example:

Y=4, segments of length 2, sum of 2^{2}=4

|S|=1, total=4 +1 -1 +1=5.

Wait, the formula seems inconsistent.

Let me re-express it.

Given Y = X -1.

Y = sum of 2^{len(s)} over all segments s.

Total increasing subsequences