Alright, I have this problem to solve. Let's see what it's asking for. So, Vladislav has a binary square grid of n by n cells, and on this grid, there's either a triangle or a square drawn with '1's. I need to determine which shape is drawn based on the grid provided.

First, I need to understand what constitutes a triangle and a square in this context.

For a triangle:

- It's made up of k rows (k > 1), and each row has 2*i - 1 '1's, where i is the row number.

- The central '1's are aligned in one column, meaning it's a centered triangle.

- It can be upside down, but rotations by 90 degrees aren't considered valid.

So, for example, if k=3, the triangle would look like:

Row 1: 1 '1' (2*1 -1 =1)

Row 2: 3 '1's (2*2 -1=3)

Row 3: 5 '1's (2*3 -1=5)

And it's centered, so the '1's are aligned in the center column.

An upside-down triangle would have the largest row first and decrease in size.

For a square:

- It's k rows (k >1), each with k '1's.

- The '1's in each row are positioned at an equal distance from the left edge, meaning they are aligned to the left or right or centered, but as long as the distance from the left edge is the same for each row.

So, for k=3, it would be three rows, each with three '1's, aligned in the same column positions across all rows.

Given that, I need to look at the grid and determine if the '1's form a square or a triangle.

Looking at the provided program:

def func():

a = int(input())

for i in range(a):

k = []

for _ in range(int(input())):

b = input()

if '1' in b:

k.append(b.count('1'))

if k[0] == k[1]:

print(k)

This seems incomplete. It reads the number of test cases, then for each test case, it reads n, then n lines of the grid. It collects the count of '1's in each row that contains at least one '1', and if the first two counts are equal, it prints the list k.

But this doesn't seem to be checking for the properties of a triangle or a square.

Wait, the problem says that in each test case, there's exactly one shape, either a square or a triangle, and it's made up of all the '1's in the grid.

So, I need to analyze the distribution of '1's to decide which shape it forms.

First, I need to parse the input correctly.

Given that, perhaps I should:

1. Read the number of test cases, t.

2. For each test case:

a. Read n, the size of the grid.

b. Read n lines, each containing n characters of '0's and '1's.

c. Analyze the pattern of '1's to determine if it forms a square or a triangle.

d. Output "SQUARE" or "TRIANGLE" based on the analysis.

Now, to analyze the pattern:

For a square:

- There should be k consecutive rows, each containing exactly k '1's, aligned in the same columns.

- The '1's should form a solid block of k rows and k columns, somewhere in the grid.

For a triangle:

- There should be k rows, where the i-th row has 2*i -1 '1's, centered in some column.

- Or, for an upside-down triangle, the largest row is at the top, decreasing towards the bottom.

Wait, the problem says that an upside-down triangle is also valid, but rotations by 90 degrees are not considered.

So, I need to check for both orientations: normal and upside-down triangles.

Given that, I need a way to identify these patterns in the grid.

Let me think about how to approach this.

First, I need to find the arrangement of '1's in the grid.

One way is to iterate through each row and count the number of '1's in each row.

For a square:

- There should be k consecutive rows, each with exactly k '1's, and these '1's should be aligned in the same columns across these rows.

For a triangle:

- The number of '1's in each row should follow the sequence 1,3,5,... for a normal triangle, or decreasing for an upside-down triangle.

But wait, the problem allows the triangle to be upside down, so I need to consider both increasing and decreasing sequences.

Moreover, the triangle must be centered in some column.

So, for a triangle, the '1's in each row should be centered around a specific column.

For a square, the '1's in each row should be aligned in the same columns.

Given that, perhaps I should:

1. For each test case:

a. Read the grid.

b. Find all rows that contain '1's.

c. Analyze the pattern of '1's in these rows to determine if they form a square or a triangle.

To check for a square:

- Find the number of rows with '1's, say k.

- Check if each of these k rows has exactly k '1's.

- Additionally, check that the '1's in these rows are aligned in the same columns. That is, the positions of '1's in each row should be identical.

If this condition is satisfied, it's a square.

To check for a triangle:

- For a normal triangle, the number of '1's in each row should increase by 2 each time (1,3,5,...).

- For an upside-down triangle, it should decrease by 2 each time (e.g., 5,3,1).

- Additionally, the '1's in each row should be centered around a specific column.

So, I need to check if the counts of '1's in the rows follow either an increasing or decreasing sequence of 1,3,5,..., and that they are centered.

Wait, but the problem allows the triangle to be centered in one column, so I need to ensure that the '1's in each row are centered around the same column.

Similarly, for the square, the '1's should be aligned in the same columns across all rows.

Given that, perhaps I should:

- Find all rows that contain '1's.

- Sort them to handle both normal and upside-down triangles.

- Check if the counts of '1's form an arithmetic sequence with a difference of 2 for triangles, and match the expected sequence.

- For squares, check if all rows have the same number of '1's, and that number equals the number of rows.

But, for squares, I also need to ensure that the '1's are aligned in the same columns across the rows.

Wait, perhaps a better approach is:

1. Find all rows that contain at least one '1'.

2. Count the number of such rows, let's call it k.

3. For each of these rows, count the number of '1's.

4. Analyze the pattern of these counts to decide between square and triangle.

For a square:

- All k rows should have exactly k '1's.

- Additionally, the '1's should be aligned in the same columns across these rows.

For a triangle:

- The counts should form a sequence like 1,3,5,... for k rows (normal triangle).

- Or, for an upside-down triangle, it should be decreasing: ...,5,3,1.

- Moreover, the '1's in each row should be centered around a specific column.

Given that, perhaps I can:

- Sort the counts of '1's in the rows.

- Check if they form an increasing or decreasing sequence of 1,3,5,... for triangles.

- Or, for squares, check if all counts are equal to k.

But, I also need to ensure the centering for triangles.

Wait, perhaps I should:

- For triangles, check if the counts match the sequence 1,3,5,... up to k, or decreasing sequence for upside-down triangles.

- For squares, check if all counts are equal to k.

But, to confirm the centering for triangles, I might need to find the center column and verify that the '1's are symmetric around that column in each row.

Similarly, for squares, ensure that the '1's are aligned in the same columns across all k rows.

Given time constraints, perhaps I can assume that the shapes are perfectly formed as described, and just check the counts.

But to be thorough, I should ensure the alignment and centering.

Alternatively, since the problem guarantees that there is exactly one shape per test case, and it's either a square or a triangle, containing all '1's, I can focus on the pattern of '1's.

Let me consider an example.

Example 1:

Input:

6

3

000

011

011

Output:

SQUARE

Here, n=3, grid:

000

011

011

So, rows with '1's: rows 2 and 3.

Each of these rows has 2 '1's, and there are 2 such rows.

Since k=2, and each row has k '1's, it's a square.

Example 2:

Input:

4

0000

0000

0100

1110

Output:

TRIANGLE

Here, n=4, grid:

0000

0000

0100

1110

Rows with '1's: rows 3 and 4.

Row 3: 1 '1'

Row 4: 3 '1's

This matches the triangle sequence: 1,3,5,...

With k=2 (though k can be more), but since it's increasing by 2, it's a triangle.

Example 3:

Input:

2

11

11

Output:

SQUARE

n=2, grid:

11

11

Both rows have 2 '1's, and there are 2 rows, so it's a square.

Example 4:

Input:

5

00111

00010

00000

00000

00000

Output:

TRIANGLE

n=5, grid:

00111

00010

00000

00000

00000

Rows with '1's: rows 1 and 2.

Row 1: 3 '1's

Row 2: 1 '1'

This is an upside-down triangle: 3,1, which is decreasing by 2.

Hence, triangle.

Example 5:

Input:

10

0000000000

0000000000

0000000000

0000000000

0000000000

1111111110

0111111100

0011111000

0001110000

0000100000

Output:

TRIANGLE

n=10, grid:

Many rows, but '1's are in rows 6 to 10.

Row 6: 9 '1's

Row 7: 7 '1's

Row 8: 5 '1's

Row 9: 3 '1's

Row 10: 1 '1'

This is a decreasing sequence: 9,7,5,3,1, which is a triangle.

Example 6:

Input:

3

111

111

111

Output:

SQUARE

n=3, grid:

111

111

111

All three rows have 3 '1's, which matches k=3 for a square.

Given these examples, I can see the pattern.

So, in code, I need to:

- For each test case:

- Read n.

- Read n lines of the grid.

- Collect rows that contain at least one '1'.

- Count the number of such rows, k.

- For each of these k rows, count the number of '1's.

- Analyze these counts to decide between square and triangle.

For square:

- All k rows should have exactly k '1's.

- Additionally, ensure that the '1's are aligned in the same columns across these rows.

For triangle:

- The counts should form an increasing sequence: 1,3,5,... for k rows.

- Or, a decreasing sequence: ...,5,3,1 for upside-down triangles.

- Also, ensure that the '1's in each row are centered around a specific column.

Given time constraints, perhaps I can implement the following:

- For square detection:

- Check if all k rows with '1's have exactly k '1's.

- Additionally, check that the '1's in these rows are aligned in the same columns.

- For triangle detection:

- Sort the counts of '1's in the k rows.

- Check if the sorted counts match the sequence 1,3,5,... for a normal triangle or decreasing for an upside-down triangle.

But, to handle both normal and upside-down triangles, I can check if the counts match either the increasing or decreasing sequence of 1,3,5,...

Given that, perhaps I can generate the expected sequences for both increasing and decreasing triangles for possible k values and see if the counts match any of them.

Moreover, for triangles, I need to ensure that the '1's are centered.

To check centering, I can find the column indices where '1's are present in each row and ensure that they are centered around a specific column.

But this might be time-consuming.

Alternatively, since the problem guarantees that there's exactly one shape per test case, and it's either a square or a triangle, I can rely on the counts alone, assuming that the shapes are perfectly formed.

However, to be thorough, I should consider the alignment and centering.

Given time constraints, perhaps I can implement the following simplified logic:

- For each test case:

- Read n.

- Read n rows of the grid.

- Collect rows that contain at least one '1'.

- Count the number of such rows, k.

- For each of these k rows, count the number of '1's.

- If all k rows have exactly k '1's, it's a square.

- Else, if the counts of '1's in these k rows match the sequence 1,3,5,... up to k, or the reverse sequence for upside-down triangles, it's a triangle.

- Output "SQUARE" or "TRIANGLE" based on the above checks.

But, I need to make sure that for triangles, the counts match the expected sequence.

Let me think about possible edge cases.

Edge Case 1:

n=2

Grid:

11

01

Here, rows with '1's: rows 1 and 2.

Row 1: 2 '1's

Row 2: 1 '1'

For k=2, square would require both rows to have 2 '1's, which they don't.

For triangle, the counts are 2 and 1, which doesn't match the triangle sequence 1,3,5,... or 5,3,1,...

But according to the problem, each test case contains exactly one shape, either a square or a triangle, so this shouldn't happen.

Wait, perhaps I need to consider that the triangle can be smaller than k rows.

But, given the problem's constraints, I'll proceed with the above logic.

Another edge case:

n=3

Grid:

000

010

010

Here, rows with '1's: rows 2 and 3.

Each has 1 '1'.

For k=2, square would require each row to have 2 '1's, which it doesn't.

For triangle, the counts are 1 and 1, which doesn't match the triangle sequence.

But according to the problem, there's exactly one shape per test case, so this shouldn't occur.

Given that, perhaps I need to ensure that the counts match either the square or triangle patterns perfectly.

Given time constraints, I'll proceed with the simplified logic.

So, in code, I can:

- For each test case:

- Read n.

- Read n lines of the grid.

- Collect rows that contain at least one '1'.

- Count the number of such rows, k.

- For each of these k rows, count the number of '1's.

- If all k rows have exactly k '1's, output "SQUARE".

- Else, if the sorted counts match the sequence 1,3,5,... up to k, output "TRIANGLE".

- Similarly, if the counts match the decreasing sequence for upside-down triangles, output "TRIANGLE".

Wait, for triangles, I need to check both increasing and decreasing sequences.

So, generate the expected sequence for a triangle of size k: [1,3,5,...,2*k-1] for normal, and [2*k-1,2*k-3,...,1] for upside-down.

But, I need to make sure that k is such that these sequences match the actual counts.

Wait, actually, for triangles, k represents the number of rows, and the counts should follow the pattern 1,3,5,... up to 2*k-1 for normal, and reverse for upside-down.

But, in the example where k=3 for a triangle, the counts would be 1,3,5.

But in the given examples, sometimes k might be less, depending on the actual shape.

Wait, perhaps I need to determine k based on the number of rows with '1's and see if their counts match the expected triangle sequence.

Given that, perhaps I should:

- Collect the counts of '1's in rows that contain at least one '1'.

- Sort these counts.

- Check if the sorted counts match the sequence [1,3,5,...,2*k-1], where k is the number of rows with '1's.

- If they do, it's a triangle.

- If all rows have exactly k '1's, it's a square.

- Output accordingly.

But, in the example where k=3 for a triangle, the counts should be 1,3,5.

But, for k=2, it should be 1,3.

Wait, but for k=2, 2*2-1=3, so [1,3].

Similarly, for k=3, [1,3,5], and so on.

So, for any k, the expected counts for a normal triangle are [1,3,5,...,2*k-1].

For upside-down triangles, it's the reverse: [2*k-1,2*k-3,...,1].

Given that, in code, I can generate these sequences based on k and check if the counts match either sequence.

Similarly, for squares, check if all counts are equal to k.

Given that, I can proceed to implement this logic.

Let me try to write some pseudocode.

For each test case:

Read n

Read n lines of the grid

Collect rows that contain '1's

Count k = number of such rows

If k == 0:

# But according to the problem, there's at least one '1', so this shouldn't happen.

Pass

Else:

counts = [count of '1's in each of these k rows]

If all counts == k:

Print "SQUARE"

Else:

expected_triangle = [2*i -1 for i in range(1, k+1)]

if sorted(counts) == expected_triangle or counts == expected_triangle[::-1]:

Print "TRIANGLE"

Else:

# This should not happen, as per the problem statement.

Assert False

But, to be safe, perhaps I should handle cases where it doesn't match either.

However, according to the problem, it's guaranteed to be one or the other.

Given that, I can implement the above logic.

Now, considering the time constraints, I need to implement this efficiently.

Given that n <=10, and t <=100, it's manageable.

I need to make sure that I read the inputs correctly and handle each test case properly.

Also, ensure that I reset any variables between test cases.

Given that, I can proceed to implement this logic in Python.

But, looking back at the provided program:

def func():

a = int(input())

for i in range(a):

k = []

for _ in range(int(input())):

b = input()

if '1' in b:

k.append(b.count('1'))

if k[0] == k[1]:

print(k)

This seems incomplete and incorrect.

It reads t, then for each test case, reads n, then n lines, collects counts of '1's in rows that contain '1's, and then checks if the first two counts are equal.

But, this doesn't align with the required logic for determining square or triangle.

Hence, the given program is incorrect.

Therefore, Correctness: **False**

**Final Solution**

To solve this problem, we need to determine whether a given binary grid forms a square or a triangle based on the arrangement of '1's.

### Approach

1. **Input Parsing:**
    - Read the number of test cases.
    - For each test case, read the grid size and the grid itself.

2. **Shape Identification:**
    - Collect rows that contain at least one '1'.
    - Determine the count of '1's in each of these rows.
    - For a **square**, check if all rows have the same count of '1's, equal to the number of rows with '1's.
    - For a **triangle**, check if the counts of '1's in rows match the sequence of odd numbers increasing or decreasing.

3. **Output the Result:**
    - Print "SQUARE" if the shape is a square.
    - Print "TRIANGLE" if the shape is a triangle.

### Solution Code

```python
def determine_shape():
    t = int(input())
    for _ in range(t):
        n = int(input())
        grid = [input().strip() for _ in range(n)]
        
        # Collect rows that contain '1's
        rows_with_ones = [row for row in grid if '1' in row]
        k = len(rows_with_ones)
        
        if k == 0:
            # According to the problem, there is at least one '1'
            continue
        
        # Count '1's in each relevant row
        counts = [row.count('1') for row in rows_with_ones]
        
        # Check for square
        if all(count == k for count in counts):
            print("SQUARE")
        else:
            # Generate expected triangle sequences
            expected_triangle = [2*i + 1 for i in range(k)]
            if sorted(counts) == expected_triangle or counts == expected_triangle[::-1]:
                print("TRIANGLE")
            else:
                # According to the problem, it should always match one of the shapes
                assert False

determine_shape()
```

### Explanation

1. **Input Parsing:**
    - Read the number of test cases `t`.
    - For each test case, read the grid size `n` and the grid rows.

2. **Shape Identification:**
    - Filter rows that contain at least one '1'.
    - Calculate the count of '1's in these rows.
    - If all counts equal the number of rows with '1's (`k`), it's a square.
    - Otherwise, check if the counts match the sequence of odd numbers increasing or decreasing, indicating a triangle.

3. **Output:**
    - Print "SQUARE" or "TRIANGLE" based on the identified shape.

This approach ensures that we correctly identify the shape based on the given criteria and constraints.