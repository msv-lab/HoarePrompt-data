Alright, I have this problem to solve. Let's read it carefully.

So, I have a hand of n cards, each with a number on it, and a fixed integer k. I can perform an operation any number of times, where I choose k cards that all have the same number and exchange them for k-1 cards, each with any number I choose. The goal is to find the minimum number of cards I can have in the end.

First, I need to understand the operation clearly. If I have k cards with the same number, I can replace them with k-1 cards of any numbers I choose. The key here is that the k cards must have the same number, and I can choose the numbers for the k-1 new cards.

Looking at the example provided:

Input:

7

5 3

4 1 1 4 4

1 10

7

7 2

4 2 1 100 5 2 3

10 4

1 1 1 1 1 1 1 1 1 1

5 2

3 8 1 48 7

6 2

10 20 30 10 20 40

6 3

10 20 30 10 20 40

Output:

2

1

1

3

5

1

6

From the first test case:

n=5, k=3, cards: 4,1,1,4,4

One possible sequence is shown in the picture, ending with 2 cards.

In the second test case:

n=1, k=10, cards: 7

Since n < k, no operation can be performed, so the answer is 1.

In the third test case:

n=7, k=2, cards: 4,2,1,100,5,2,3

Some operations can be performed, but the answer is 1.

I need to find a general approach to minimize the number of cards.

Let me think about the operation: exchanging k same cards for k-1 arbitrary cards.

This operation reduces the number of cards by 1 each time it's performed.

So, the more operations I can perform, the fewer cards I'll have in the end.

But I can only perform the operation if I have k cards with the same number.

So, I need to maximize the number of operations I can perform.

Each operation reduces the total number of cards by 1, so the minimum number of cards is n - m, where m is the maximum number of operations I can perform.

To maximize m, I need to perform as many operations as possible.

But performing an operation can affect the possibility of performing future operations, because the new cards I introduce could be used in future operations.

Wait, but the new cards can be any numbers I choose, so I can strategically choose numbers that allow more operations in the future.

But this seems complicated. Maybe there's a better way to look at it.

Let me consider the frequency of each number in the hand.

Suppose I have a number that appears f times.

If f >= k, I can perform the operation f // k times on this number.

Each operation reduces the count of this number by k and adds k-1 new cards.

But the new cards can be any numbers, so they could potentially be used in future operations.

Wait, but the new cards are arbitrary, so I can choose them to help in future operations.

But this seems too vague. Maybe I need to find a different approach.

Looking at the problem again, I realize that the operation allows me to reduce the number of cards by 1 each time, provided I have k cards with the same number.

I need to find the minimum number of cards left after performing as many operations as possible.

This sounds like a problem where I need to repeatedly remove k cards of the same number and add k-1 new cards, choosing the new cards optimally to allow for more operations.

But this seems iterative and complex to analyze directly.

Perhaps I can model this in a different way.

Let me consider the frequency of each number.

Suppose I have frequencies f1, f2, ..., fm for each distinct number.

Each operation can be performed on one of these frequencies, provided that frequency is at least k.

When I perform an operation, I decrease that frequency by k and increase the total number of cards by (k-1) - k = -1, meaning the total number of cards decreases by 1.

Wait, no: I'm replacing k cards with k-1 cards, so the total number of cards decreases by k - (k-1) = 1 each time.

So, each operation reduces the total number of cards by 1.

Therefore, the maximum number of operations I can perform is equal to the maximum number of times I can find a frequency that is at least k.

But the problem is that after each operation, I might be adding new cards with arbitrary numbers, which could affect future operations.

This seems tricky.

Wait, perhaps I can think of it in terms of the maximum number of operations I can perform, considering that I can choose the numbers of the new cards to optimize the number of future operations.

But this still seems too vague.

Let me try to think differently.

Suppose I ignore the ability to choose the numbers of the new cards, and just consider that each operation reduces the total number of cards by 1, provided I have at least k cards with the same number.

In that case, the minimum number of cards left would be n - m, where m is the maximum number of operations I can perform.

But m is limited by the number of sets of k cards with the same number I can find.

But since I can choose the numbers of the new cards, I might be able to create new sets for future operations.

This complicates things.

Perhaps I need to find the minimal number of cards such that no further operations can be performed.

That is, no number has at least k cards.

So, I need to reduce the hand until no number has at least k cards.

I need to remove cards (by performing operations) until no number has frequency >= k.

Each operation allows me to remove k cards of the same number and add k-1 new cards of any numbers.

Wait, but adding new cards could potentially create new frequencies that are >= k, which might allow more operations.

This seems problematic.

Let me consider a greedy approach: always perform operations on the number with the highest frequency.

But even that might not be optimal, because adding new cards could create new high frequencies.

This is getting too complicated.

Let me look at small examples to see if I can find a pattern.

First test case:

n=5, k=3, cards: 4,1,1,4,4

Frequencies: 4:3, 1:2

I can perform one operation on 4's: remove 3 fours and add 2 cards of any numbers.

Suppose I add two 1's, then the new hand is: 1,1,1,1

Now, frequencies: 1:4

I can perform another operation: remove 3 ones and add 2 cards of any numbers.

Suppose I add two 1's again, then the new hand is: 1,1,1

Now, frequency: 1:3

I can perform another operation: remove 3 ones and add 2 cards.

Now, hand has 2 cards, say 1 and 1.

No operation can be performed now since there are only 2 ones.

So, minimum is 2.

But in the explanation, it says the answer is 2, which matches this sequence.

Another test case:

n=1, k=10, cards:7

Since n < k, no operation can be performed, so minimum is 1.

Third test case:

n=7, k=2, cards:4,2,1,100,5,2,3

Frequencies: 2:2, 4:1,1:1,100:1,5:1,3:1

I can perform an operation on 2's: remove 2 twos and add 1 card of any number.

Suppose I add a 1, then the hand becomes: 1,1,100,5,3,1

Frequencies:1:3,100:1,5:1,3:1

Now, I can perform an operation on 1's: remove 2 ones and add 1 card.

Suppose I add a 1, then hand is:1,100,5,3,1

Frequencies:1:2,100:1,5:1,3:1

Again, perform an operation on 1's: remove 2 ones and add 1 card.

Add, say, a 5. Hand is:100,5,3,5

Frequencies:100:1,5:2,3:1

Perform an operation on 5's: remove 2 fives and add 1 card.

Add, say, a 3. Hand is:100,3,3

Frequencies:100:1,3:2

Perform an operation on 3's: remove 2 threes and add 1 card.

Add, say, a 100. Hand is:100,100

Frequencies:100:2

Cannot perform any more operations.

So, minimum is 2, but the output says 1.

Wait, maybe I can continue.

From hand:100,100, after adding a 100, hand is:100,100,100

Now, frequencies:100:3

Perform an operation: remove 2 hundreds and add 1 card.

Add, say, a 100. Hand is:100,100

Again, frequencies:100:2

Cannot perform more operations.

Still 2 cards.

But the output is 1, so there must be a better sequence.

Let me try a different sequence.

Starting with:4,2,1,100,5,2,3

Perform operation on 2's: remove 2 twos, add 1 card, say a 1.

Hand:4,1,1,100,5,3,1

Frequencies:1:3,4:1,100:1,5:1,3:1

Perform operation on 1's: remove 2 ones, add 1 card, say a 1.

Hand:1,100,5,3,1

Frequencies:1:2,100:1,5:1,3:1

Perform operation on 1's: remove 2 ones, add 1 card, say a 1.

Hand:1,100,5,3

Frequencies:1:1,100:1,5:1,3:1

No more operations possible.

Minimum is 4, but output is 1.

Wait, I must be missing something.

Perhaps I can choose the new cards more strategically.

Let's try again.

Starting with:4,2,1,100,5,2,3

Perform operation on 2's: remove 2 twos, add 1 card, say a 1.

Hand:4,1,1,100,5,3,1

Frequencies:1:3,4:1,100:1,5:1,3:1

Perform operation on 1's: remove 2 ones, add 1 card, say a 1.

Hand:1,1,100,5,3

Frequencies:1:3,100:1,5:1,3:1

Perform operation on 1's: remove 2 ones, add 1 card, say a 1.

Hand:1,100,5,3

Frequencies:1:1,100:1,5:1,3:1

No more operations.

Still 4 cards.

But the output is 1, so there must be a better sequence.

Wait, maybe I can choose the new cards to create higher frequencies.

Starting again:

Original hand:4,2,1,100,5,2,3

Perform operation on 2's: remove 2 twos, add 1 card, say a 1.

Hand:4,1,1,100,5,3,1

Frequencies:1:3,4:1,100:1,5:1,3:1

Perform operation on 1's: remove 2 ones, add 1 card, say a 4.

Hand:4,1,4,100,5,3

Frequencies:4:2,1:1,100:1,5:1,3:1

Perform operation on 4's: remove 2 fours, add 1 card, say a 1.

Hand:1,1,100,5,3

Frequencies:1:2,100:1,5:1,3:1

Perform operation on 1's: remove 2 ones, add 1 card, say a 100.

Hand:100,100,5,3

Frequencies:100:2,5:1,3:1

Perform operation on 100's: remove 2 hundreds, add 1 card, say a 5.

Hand:5,5,3

Frequencies:5:2,3:1

Perform operation on 5's: remove 2 fives, add 1 card, say a 3.

Hand:3,3

Frequencies:3:2

Perform operation on 3's: remove 2 threes, add 1 card, say a 3.

Hand:3

Frequencies:3:1

No more operations possible.

Minimum is 1.

Ah, so by choosing the new cards carefully, I can reduce the hand to a single card.

That's better.

So, the choice of the new cards is crucial to minimize the final number of cards.

I need to find a way to model this to compute the minimal number of cards efficiently.

Looking back at the problem, it seems that the minimal number of cards is the smallest number that cannot be reduced further, meaning no number has frequency >=k.

I need to reduce the hand until no number has frequency >=k.

Each operation reduces the total number of cards by 1 and potentially changes the frequencies.

But since I can choose the numbers of the new cards, I can strategically add numbers that are under k to avoid creating new candidates for operations.

Wait, but in the previous sequence, by choosing to add numbers that are already present, I can create new frequencies that allow more operations.

So, it's about maximizing the number of operations, which depends on how I choose the new cards.

This seems quite involved.

Let me consider the frequencies.

Suppose I have a frequency f for some number.

If f >=k, I can perform operation f//k times on it, each time reducing f by k and increasing the total number of cards by (k-1) - k = -1.

Wait, no: replacing k cards with k-1 cards reduces the total by 1.

But in terms of frequencies, each operation on a frequency f reduces it by k and adds k-1 cards, but the new cards can be assigned any numbers, which could be existing numbers or new ones.

This is getting too tangled.

Perhaps I need to consider the minimal number of cards where no frequency is >=k.

In other words, I need to distribute the cards such that no number has frequency >=k.

I need to find the minimal number of cards where the maximum frequency is less than k.

This sounds like a classic problem in combinatorics.

The minimal number of cards where no number has frequency >=k is when the frequencies are as evenly distributed as possible.

So, if I have m different numbers, the minimal number of cards is ceil(n/(m)) <=k-1.

But I'm not sure.

Wait, perhaps I can think in terms of the pigeonhole principle.

If I have more cards than (m)*(k-1), then at least one number has frequency >=k.

So, to have no number with frequency >=k, I need n <= m*(k-1).

To minimize n, I need to maximize m.

But m can be up to the number of unique numbers available, which in this problem is up to 100.

But that doesn't seem right.

Wait, perhaps I need to find the minimal n where n <= m*(k-1), with m being the number of unique numbers.

But m can be up to 100, so the minimal n is n <=100*(k-1).

But that doesn't make sense in this context.

I think I'm missing something.

Let me look at another example.

Fourth test case:

n=10, k=4, cards:1,1,1,1,1,1,1,1,1,1

Frequencies:1:10

I can perform operation 10//4=2 times.

First operation: remove 4 ones, add 3 ones.

Now, frequencies:1:9

Second operation: remove 4 ones, add 3 ones.

Now, frequencies:1:8

I can continue this process.

Each operation reduces the frequency by 4 and adds 3 ones, so effectively, the frequency decreases by 1 each operation.

Wait, no: removing 4 and adding 3 means the net decrease is by 1.

So, starting from 10, after one operation: 9

After two operations:8

And so on, until frequency is less than k=4.

So, I can perform operations until frequency <k.

In this case, I can perform operations 10 - 3 =7 times, ending with frequency 3.

So, minimum number of cards is 3.

Which matches the output.

So, in this case, it's straightforward: perform operations until the frequency is less than k.

But in earlier cases, choosing the new cards carefully allowed reducing the total number of cards further.

So, perhaps in general, the minimal number of cards is the number where no frequency is >=k, and we can achieve that by strategically choosing the new cards.

But how to compute this efficiently?

Let me consider that the new cards can be assigned to any numbers, including existing ones or new ones.

If I want to minimize the final number of cards, I need to minimize the number of unique numbers, because having more unique numbers allows higher total card counts without any single number reaching frequency k.

Wait, no: to minimize the total number of cards, I need to maximize the number of unique numbers, so that no number reaches frequency k.

But that doesn't make sense.

Wait, actually, to minimize the total number of cards, I need to have as many numbers as possible with frequencies less than k, and possibly some with frequencies up to k-1.

But I need to ensure that no number has frequency >=k.

In the previous example, with n=10, k=4, I ended up with frequency 3 for the single number.

But in other cases, I might be able to distribute the cards among more numbers to reduce the total.

Wait, no.

Wait, in the third test case, with n=7, k=2, cards:4,2,1,100,5,2,3

I was able to reduce it to 1 card by choosing the new cards carefully.

So, perhaps the minimal number of cards is 1 if n >=k.

But looking at the first test case, n=5, k=3, minimal is 2.

Wait, but in the second test case, n=1, k=10, minimal is 1.

In the third test case, n=7, k=2, minimal is 1.

Wait, but in the fourth test case, n=10, k=4, minimal is 3.

Wait, is there a pattern?

Let me see.

In the first test case, n=5, k=3.

Perform operation once: n=4

Perform operation again: n=3

Perform operation again: n=2

Cannot perform anymore.

So, minimal is 2.

In the second test case, n=1, k=10.

Cannot perform any operation.

So, minimal is 1.

In the third test case, n=7, k=2.

Perform operation: n=6

Perform operation: n=5

...

Until n=1.

So, minimal is 1.

In the fourth test case, n=10, k=4.

Perform operation: n=9

...

Until n=3.

So, minimal is 3.

Wait, but in the first test case, n=5, k=3, minimal is 2.

But according to the sequence, it seems I can perform operations until n=k-1.

Wait, k-1=2 for k=3.

But in the fourth test case, k-1=3, which matches the minimal n=3.

In the third test case, k-1=1 for k=2, which matches minimal n=1.

In the first test case, k-1=2, which matches minimal n=2.

Wait, but in the first test case, k=3, and minimal n=2, which is k-1.

In the fourth test case, k=4, minimal n=3, which is k-1.

In the third test case, k=2, minimal n=1, which is k-1.

So, is the minimal number of cards always k-1 if n >=k-1?

Wait, but in the second test case, n=1, k=10, minimal is 1, which is not k-1=9.

Wait, that doesn't match.

Wait, perhaps it's min(n, k-1).

In the second test case, min(1,9)=1.

In the first test case, min(5,2)=2.

Wait, but in the third test case, n=7, k=2, min(7,1)=1.

Which matches the output of 1.

In the fourth test case, n=10, k=4, min(10,3)=3.

Which matches the output of 3.

Wait, but in the first test case, n=5, k=3, min(5,2)=2.

Which matches the output of 2.

In the second test case, n=1, k=10, min(1,9)=1.

Matches the output of 1.

So, it seems that the minimal number of cards is min(n, k-1).

Is this always true?

Wait, but in the fifth test case, n=5, k=2, output is 5.

But min(5,1)=1, but output is 5.

Wait, that doesn't match.

Wait, perhaps I need to think differently.

Wait, in the fifth test case, n=5, k=2, cards:3,8,1,48,7.

Frequencies: all 1.

No number has frequency >=k=2, so no operations can be performed.

Therefore, minimal n is 5.

But according to min(n,k-1)=min(5,1)=1, which doesn't match.

So, min(n,k-1) is not correct.

Alternative approach needed.

Wait, perhaps it's n - floor(n/(k)) *(k -1).

Wait, not sure.

Wait, in the first test case, n=5, k=3.

floor(5/3)=1, then 5 -1*(3-1)=5-2=3, but output is 2.

Doesn't match.

Wait, perhaps n - ceil(n/(k)) *(k -1).

In the first test case, ceil(5/3)=2, then 5 -2*(3-1)=5-4=1, but output is 2.

No.

Not matching.

Wait, perhaps it's n - floor((n-1)/(k-1)) *(k -1).

Wait, trying different formulas.

This is not efficient.

Let me think differently.

Each operation reduces the number of cards by 1.

I can perform as many operations as possible until I can't perform any more.

I need to find the maximum number of operations I can perform.

Each operation requires k cards of the same number.

After performing an operation, I replace k cards with k-1 cards.

So, net reduction is 1 card.

But the new cards can be chosen arbitrarily, which could enable more operations.

I need to maximize the number of operations.

To do that, I need to always choose to perform operations on the numbers that have the highest frequencies, and choose the new cards to be numbers that have frequencies less than k, to potentially create new frequencies that reach k.

Wait, but it's still complex.

An alternative approach is to consider that the minimal number of cards is n - m, where m is the maximum number of times I can perform the operation.

But m is the number of times I can find k cards of the same number, considering that after each operation, I add k-1 new cards.

This seems too vague.

Looking back at the test cases:

First test case: n=5, k=3, output=2.

Operations performed: 5-2=3 operations.

But in the sequence shown earlier, only 3 operations were performed, ending with 2 cards.

Wait, but according to the sequence I tried earlier, I could perform operations until n=2.

Second test case: n=1, k=10, output=1.

No operations can be performed.

Third test case: n=7, k=2, output=1.

Perform operations 6 times: 7-1=6 operations, ending with 1 card.

Fourth test case: n=10, k=4, output=3.

Perform operations 7 times: 10-7=3.

Fifth test case: n=5, k=2, output=5.

No operations can be performed, as no number has frequency >=2.

Wait, in this case, minimal n is 5.

Sixth test case: n=6, k=2, cards:10,20,30,10,20,40.

Frequencies:10:2,20:2,30:1,40:1.

Perform operations on 10's: remove 2 tens, add 1 card, say a 20.

Now, hand:20,20,30,40,20.

Frequencies:20:3,30:1,40:1.

Perform operations on 20's: remove 2 twentys, add 1 card, say a 20.

Now, hand:20,30,40,20.

Frequencies:20:2,30:1,40:1.

Perform operations on 20's: remove 2 twentys, add 1 card, say a 20.

Now, hand:20,30,40.

Frequencies:20:1,30:1,40:1.

No more operations.

Minimal n=3, but output is 1.

Wait, according to the output, it's 1, but in this sequence, I have 3 cards left.

Wait, perhaps I can choose differently.

Starting again:

Original hand:10,20,30,10,20,40

Frequencies:10:2,20:2,30:1,40:1.

Perform operations on 10's: remove 2 tens, add 1 card, say a 20.

Hand:20,20,20,30,40.

Frequencies:20:3,30:1,40:1.

Perform operations on 20's: remove 2 twentys, add 1 card, say a 20.

Hand:20,20,30,40.

Frequencies:20:2,30:1,40:1.

Perform operations on 20's: remove 2 twentys, add 1 card, say a 30.

Hand:30,30,40.

Frequencies:30:2,40:1.

Perform operations on 30's: remove 2 thirties, add 1 card, say a 40.

Hand:40,40.

Frequencies:40:2.

Perform operations on 40's: remove 2 fourties, add 1 card, say a 40.

Hand:40.

Frequencies:40:1.

No more operations.

Minimal n=1.

Seventh test case: n=6, k=3, cards:10,20,30,10,20,40.

Frequencies:10:2,20:2,30:1,40:1.

Since k=3, no operations can be performed, as no number has frequency >=3.

So, minimal n=6.

This matches the output.

So, in test case 6, with k=2, I was able to reduce to 1 card, but with k=3, cannot perform any operations.

So, the minimal n is 6.

Wait, but in test case 6, k=2, minimal n=1, and in test case 7, k=3, minimal n=6.

So, the key is that when k=2, I can perform operations repeatedly until only 1 card is left, provided that I can always choose new cards to enable more operations.

But in k=3, I cannot perform any operations since no number has frequency >=3.

So, the minimal n is n itself.

Wait, but in test case 5, n=5, k=2, output=5.

But according to the sequence in test case 6, with k=2 and n=6, I can reduce to 1 card.

Why in test case 5, n=5, k=2, output=5?

Wait, in test case 5, cards are 3,8,1,48,7.

All frequencies are 1.

So, no operations can be performed.

Hence, minimal n=5.

Whereas in test case 6, frequencies are 10:2,20:2,30:1,40:1.

So, operations can be performed.

So, perhaps when there are frequencies >=k, I can perform operations until no frequency is >=k.

And the minimal n is the minimal number where no frequency is >=k.

In test case 5, frequencies are all 1, which is <k=2, so minimal n=5.

In test case 6, with k=2, I can perform operations to reduce n to 1.

Wait, but in test case 3, n=7, k=2, minimal n=1.

In test case 4, n=10, k=4, minimal n=3.

In test case 7, n=6, k=3, minimal n=6.

So, the pattern seems to be:

If there exists at least one frequency >=k, then minimal n = n - floor((n - m)/(k -1)), where m is the number of unique numbers.

But this seems arbitrary.

Alternatively, perhaps it's n - (n - m)/(k -1), but I'm not sure.

Wait, perhaps it's n - (n - m)/(k -1), but m is the number of unique numbers.

Wait, I need a better approach.

Let me consider that the minimal number of cards is the minimal n where no frequency is >=k.

To achieve this, I need to distribute the cards among as many numbers as possible, so that no number has frequency >=k.

So, the minimal n is the smallest n where n <= m*(k-1), where m is the number of unique numbers.

But m can be up to 100, so n <=100*(k-1).

But in test case 5, n=5, k=2, m=5 unique numbers, so n <=5*1=5, which it is, so minimal n=5.

In test case 6, n=6, k=2, m=4 unique numbers, 4*1=4 <6, so cannot reduce to less than 6.

Wait, but in the sequence I showed earlier, I reduced it to 1 card.

Wait, but according to the output, it's 1.

Wait, perhaps I misread the output.

Wait, the output for test case 6 is 1, but for test case 7 it's 6.

Wait, but in test case 6, k=2, and I can perform operations until only 1 card is left.

But in test case 7, k=3, and cannot perform any operations, so minimal n=6.

So, perhaps when k=2, I can reduce to 1 card, regardless of the frequencies, as long as n >=1.

Wait, but in test case 5, n=5, k=2, output=5.

Wait, perhaps there is a difference based on the frequencies.

In test case 5, frequencies are all 1, so no operations can be performed.

Hence, minimal n=5.

In test case 6, frequencies are 10:2,20:2,30:1,40:1.

So, operations can be performed.

Wait, perhaps if there exists at least one frequency >=k, then minimal n=k-1, else n.

But in test case 5, no frequency >=2, so minimal n=5.

In test case 6, frequency 10:2 >=2, so minimal n=1.

In test case 7, no frequency >=3, so minimal n=6.

This seems to hold.

So, the minimal n is:

- If there exists at least one frequency >=k, then k-1.

- Else, n.

This matches all the test cases.

First test case: frequencies 4:3,1:2, k=3, since 4:3 >=3, minimal n=2.

Second test case: frequencies 7:1, k=10, no frequency >=10, so minimal n=1.

Third test case: frequencies 2:2,1:1,100:1,5:1,3:1, k=2, since 2:2 >=2, minimal n=1.

Fourth test case: frequencies 1:10, k=4, since 1:10 >=4, minimal n=3.

Fifth test case: frequencies 3:1,8:1,1:1,48:1,7:1, k=2, no frequency >=2, minimal n=5.

Sixth test case: frequencies 10:2,20:2,30:1,40:1, k=2, since 10:2 >=2 and 20:2 >=2, minimal n=1.

Seventh test case: frequencies 10:2,20:2,30:1,40:1, k=3, no frequency >=3, minimal n=6.

Yes, this matches all the test cases.

So, the minimal number of cards is:

- If any frequency >=k, then k-1.

- Else, n.

This seems to be the correct approach.

Hence, the program should check if any frequency is >=k, and if so, output k-1, else output n.

Looking at the given program:

t = int(input())

for i in range(t):

(n, k) = map(int, input().split())

nums = list(map(int, input().split()))

if k > n:

print(n)

elif k == n:

print(k - 1)

else:

freq = func_1(nums, k)

if k in freq.values():

print(k - 1)

else:

print(n)

def func_1(arr, k):

frequency_table = {}

for num in arr:

frequency_table[num] = frequency_table.get(num, 0) + 1

if frequency_table[num] > k:

frequency_table[num] = k

return frequency_table

Wait, in the else part, it checks if k is in freq.values(), and if so, prints k-1, else prints n.

But according to our earlier reasoning, we should check if any frequency >=k.

But in the code, it's checking if any frequency is exactly k.

Wait, but in the function func_1, it caps the frequency at k.

So, frequency_table[num] = k if frequency_table[num] > k else frequency_table[num]

So, in the frequency table, frequencies are capped at k.

Then, it checks if k is in freq.values(), i.e., if any frequency is exactly k.

But according to our earlier reasoning, we should check if any frequency >=k.

But since frequencies are capped at k, if any frequency is exactly k, it means that the original frequency was >=k.

Hence, it's effectively checking if any frequency >=k.

Therefore, the program seems correct.

In the if condition, if k > n, it prints n.

Which makes sense, because if k > n, no operations can be performed, so minimal n is n.

If k == n, it prints k-1.

Which matches our earlier reasoning.

Else, it checks if any frequency >=k, and if so, prints k-1, else prints n.

Which matches our earlier reasoning.

Hence, the program is correct.

**Final Solution**
To solve this problem, we need to determine the minimum number of cards we can have in our hand after performing a series of operations as described. 

### Approach

1. **Problem Understanding**:
    - We have a hand of `n` cards, each with a number.
    - We can perform operations where we choose `k` cards with the same number and replace them with `k-1` cards of any chosen numbers.
    - Our goal is to minimize the number of cards in our hand after performing any number of such operations.

2. **Key Insight**:
    - Each operation reduces the total number of cards by 1.
    - We can perform operations until no group of `k` cards with the same number exists.
    - The minimal number of cards is `k-1` if any number appears at least `k` times; otherwise, it's the current number of cards `n`.

3. **Algorithm**:
    - Count the frequency of each card number.
    - If any number appears at least `k` times, we can reduce the hand to `k-1` cards.
    - If no number appears at least `k` times, no operations can be performed, and the hand remains with `n` cards.

### Solution Code

```python
t = int(input())
for _ in range(t):
    (n, k) = map(int, input().split())
    nums = list(map(int, input().split()))
    if k > n:
        print(n)
    elif k == n:
        print(k - 1)
    else:
        freq = func_1(nums, k)
        if k in freq.values():
            print(k - 1)
        else:
            print(n)

def func_1(arr, k):
    frequency_table = {}
    for num in arr:
        frequency_table[num] = frequency_table.get(num, 0) + 1
        if frequency_table[num] > k:
            frequency_table[num] = k
    return frequency_table
```

### Explanation

1. **Reading Input**:
    - Read the number of test cases `t`.
    - For each test case, read `n` (number of cards) and `k` (number of cards to exchange).
    - Read the list of card numbers.

2. **Edge Cases**:
    - If `k > n`, no operations can be performed, so the minimal number of cards is `n`.
    - If `k == n`, perform one operation to get `k-1` cards.

3. **Frequency Counting**:
    - Use a frequency table to count how many times each number appears.
    - Cap the frequency at `k` to optimize, as frequencies beyond `k` don't provide additional operations beyond reducing to `k-1`.

4. **Decision Making**:
    - If any frequency is exactly `k`, it implies that at least one number appears at least `k` times, allowing us to reduce to `k-1` cards.
    - If no frequency reaches `k`, output the current number of cards `n` as no operations can be performed.

This approach ensures we handle the problem efficiently and correctly, achieving the minimal number of cards possible under the given constraints.