Alright, I've got this problem to solve. Let's see what it's asking for. So, Anton has a permutation of size n and a number x that he wants to find using a binary search-like algorithm. But here's the twist: the array isn't sorted, and I can perform at most two swaps on the permutation before running this binary search to make sure that after the algorithm, p_l equals x.

First, I need to understand what a permutation is. A permutation of size n is just an array containing each number from 1 to n exactly once, but in any order. So, for example, [2, 3, 1] is a permutation of size 3.

Now, the binary search algorithm described here is a bit unusual. Normally, binary search requires a sorted array, but here, it's being applied to a potentially unsorted permutation. The steps are:

1. Initialize l = 1 and r = n + 1.

2. While r - l > 1:

a. Calculate m = floor((r + l) / 2).

b. If p_m ≤ x, set l = m; else set r = m.

After the loop, p_l should be equal to x.

Wait a minute, this is interesting. Normally, binary search on an unsorted array wouldn't work, but here, we're allowed to perform up to two swaps to make it work.

The problem also states that it can be shown that two swaps are always sufficient. That's a crucial point. So, no matter how the permutation is arranged, I can always make p_l = x after at most two swaps.

My task is to determine the correct sequence of swaps (0, 1, or 2) to achieve this.

Let's try to understand how this binary search works on a permutation.

Let's consider an example to see what's going on.

Take n = 6, x = 3, and the permutation [1, 2, 3, 4, 5, 6].

If I don't make any swaps, let's see what happens:

Initialize l = 1, r = 7.

While 7 - 1 = 6 > 1:

m = floor((1 + 7)/2) = 4.

p_4 = 4 ≤ 3? No, so r = 4.

Now, l = 1, r = 4.

m = floor((1 + 4)/2) = 2.

p_2 = 2 ≤ 3? Yes, so l = 2.

Now, l = 2, r = 4.

m = floor((2 + 4)/2) = 3.

p_3 = 3 ≤ 3? Yes, so l = 3.

Now, l = 3, r = 4.

m = floor((3 + 4)/2) = 3.

p_3 = 3 ≤ 3? Yes, so l = 3.

Now, r - l = 1, so the loop ends.

p_l = p_3 = 3, which is equal to x = 3.

So, in this case, no swaps are needed.

Another example: n = 6, x = 5, permutation [3, 1, 6, 5, 2, 4].

Let's see what happens without any swaps.

l = 1, r = 7.

m = floor((1 + 7)/2) = 4, p_4 = 5 ≤ 5? Yes, l = 4.

Now, l = 4, r = 7.

m = floor((4 + 7)/2) = 5, p_5 = 2 ≤ 5? Yes, l = 5.

Now, l = 5, r = 7.

m = floor((5 + 7)/2) = 6, p_6 = 4 ≤ 5? Yes, l = 6.

Now, l = 6, r = 7.

m = floor((6 + 7)/2) = 6, p_6 = 4 ≤ 5? Yes, l = 6.

Now, r - l = 1, stop.

p_l = p_6 = 4 ≠ 5.

So, incorrect. Need to perform swaps.

The problem allows up to two swaps. I need to perform swaps such that after the binary search, p_l = x.

Looking back at the first example, no swaps were needed because the permutation was already sorted, and the binary search worked correctly.

In the second example, the permutation isn't sorted, so the binary search didn't find the correct position for x = 5.

Wait, but the problem says that it's a permutation, so all elements are unique.

I need to find a way to adjust the permutation with at most two swaps so that the binary search algorithm ends with p_l = x.

The problem guarantees that two swaps are always sufficient. So, I need to find a strategy to determine which swaps to make.

Let me think about what the binary search is doing.

In each step, it calculates m as the floor of (l + r)/2 and checks if p_m ≤ x.

Depending on that, it updates l or r.

Eventually, it should have l pointing to the position where p_l = x.

But since the array isn't sorted, I need to adjust it so that this happens.

One approach could be to try to place x in a position where the binary search would find it.

But considering that I can only make two swaps, I need an efficient way to do this.

Let me consider the final position where l should be.

After the loop, l should be such that p_l = x.

Given that, I need to ensure that after at most two swaps, p_l = x.

Wait, but l is determined by the binary search process, which depends on the initial arrangement of the permutation.

This seems a bit circular.

Maybe I need to think differently.

Perhaps I can consider where x is currently located in the permutation and where it needs to be for the binary search to find it.

I need to bring x to the position where the binary search expects it to be, possibly by swapping it with other elements.

Since I can perform up to two swaps, I have some flexibility.

Let me consider the following strategy:

1. Determine where x is currently located in the permutation.

2. Determine where the binary search would place l if no swaps were performed.

3. If p_l != x, consider swapping x with p_l.

4. If that's not sufficient, perform a second swap to adjust another element to make the binary search work.

But this seems a bit vague. Let's try to formalize it.

Alternatively, perhaps I can think in terms of the binary search traversal path.

Each step of the binary search divides the current search space in half, depending on whether p_m ≤ x or not.

The sequence of m's chosen by the binary search defines a path that should lead to the position where p_l = x.

If the array were sorted, this would work perfectly.

But since it's not sorted, I need to adjust the array so that this path leads correctly to x.

However, since I can only perform two swaps, I need a way to make minimal adjustments to achieve this.

Another idea: perhaps I can ensure that the final l points to x by making sure that x is in a position that satisfies the conditions imposed by the binary search steps.

This sounds complicated.

Let me consider a simpler approach.

Since the problem states that two swaps are always sufficient, perhaps there is a general method that works in all cases.

Maybe I can swap x to the position where l finally is, and if necessary, perform another swap to fix any discrepancies.

Wait, in the first example, no swaps were needed because the permutation was already sorted, and the binary search found x correctly.

In the second example, swaps were needed because the permutation wasn't sorted.

Looking at the second example:

n = 6, x = 5, permutation = [3, 1, 6, 5, 2, 4]

Indices: 1:3, 2:1, 3:6, 4:5, 5:2, 6:4

Binary search steps:

l=1, r=7

m=floor((1+7)/2)=4, p_4=5 ≤5? Yes, l=4

Now l=4, r=7

m=floor((4+7)/2)=5, p_5=2 ≤5? Yes, l=5

Now l=5, r=7

m=floor((5+7)/2)=6, p_6=4 ≤5? Yes, l=6

Now l=6, r=7

m=floor((6+7)/2)=6, p_6=4 ≤5? Yes, l=6

Stop since r - l =1

p_l = p_6 =4 ≠5

So, I need to have p_6=5.

Currently, p_6=4, and p_4=5.

So, if I swap positions 4 and 6, then p_4=4 and p_6=5.

Let's see what happens then:

l=1, r=7

m=floor((1+7)/2)=4, p_4=4 ≤5? Yes, l=4

Now l=4, r=7

m=floor((4+7)/2)=5, p_5=2 ≤5? Yes, l=5

Now l=5, r=7

m=floor((5+7)/2)=6, p_6=5 ≤5? Yes, l=6

Now l=6, r=7

m=floor((6+7)/2)=6, p_6=5 ≤5? Yes, l=6

Stop, p_l =5 as required.

So, in this case, one swap sufficed: swapping positions 4 and 6.

But the problem allows up to two swaps, and in this case, one was enough.

Another example:

n=5, x=1, permutation=[3,5,4,2,1]

Indices:1:3,2:5,3:4,4:2,5:1

Binary search:

l=1, r=6

m=floor((1+6)/2)=3, p_3=4 ≤1? No, r=3

Now l=1, r=3

m=floor((1+3)/2)=1, p_1=3 ≤1? No, r=1

Now r - l =0, which is not >1, so stop.

p_l =p_1=3 ≠1

Need to have p_1=1.

So, swap position 1 and 5:

Swap 1 and 5: [1,5,4,2,3]

Now, binary search:

l=1, r=6

m=floor((1+6)/2)=3, p_3=4 ≤1? No, r=3

l=1, r=3

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

...

Wait, this seems like it's stuck in an infinite loop. But according to the problem, it should terminate when r - l =1.

Wait, in the loop condition, it's while r - l >1.

In the last step, l=1, r=3

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1, so repeat.

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Again, r - l =2 >1.

This seems like it will continue indefinitely.

Wait, perhaps I'm misunderstanding the loop condition.

Looking back at the problem statement:

"While r - l >1:

m = floor((r + l)/2)

If p_m ≤x, assign l = m, else r = m."

Then, after the loop, p_l should be equal to x.

In this case, l=1, r=3

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1, so m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

This seems like it will keep doing this forever.

But according to the problem, it should terminate when r - l =1.

Wait, perhaps there's a missing update for r.

Wait, in the loop:

"If p_m ≤x, assign l = m, otherwise r = m."

In this case, p_m ≤x, so l = m.

But r remains r.

So, if l doesn't change, and r doesn't change, r - l remains the same, and it would indeed loop indefinitely.

This seems like a potential issue.

Looking back at standard binary search, usually, when p_m ≤x, we set l = m +1, but here it's set to l = m.

Similarly, when p_m >x, set r = m.

This might lead to infinite loops in some cases.

Perhaps the problem has a mistake in the binary search description.

Alternatively, maybe it's intentional, and the loop is meant to terminate under certain conditions.

In the given example, after swapping positions 1 and 5, l=1, r=6

m=floor((1+6)/2)=3, p_3=4 ≤1? No, r=3

Now, l=1, r=3

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

...

It seems like it's stuck.

Perhaps in this case, p_l =1, which is equal to x=1, so it's acceptable.

But it's not terminating, which might be a problem.

Wait, perhaps the loop is intended to terminate when r - l =1, not necessarily breaking out earlier.

In this case, since r - l remains 2, it keeps looping, but according to the problem, it should stop when r - l =1.

Wait, but in this case, r - l =2, which is greater than 1, so it should continue looping.

But in practice, it seems like it's not making progress, which is an issue.

Perhaps the problem needs to be interpreted differently.

Alternatively, maybe I need to consider that after the loop, p_l should be equal to x, even if the loop doesn't terminate.

This is getting confusing.

Let me look at the sample input and output to understand better.

Sample Input:

5

6 3

1 2 3 4 5 6

6 5

3 1 6 5 2 4

5 1

3 5 4 2 1

6 3

4 3 1 5 2 6

3 2

3 2 1

Sample Output:

0

1

3 4

2

2 4

1 5

2

4 5

2 4

1

1 3

From the first test case:

n=6, x=3, permutation=[1,2,3,4,5,6]

No swaps needed, as it's already sorted, and binary search finds x=3 correctly.

Second test case:

n=6, x=5, permutation=[3,1,6,5,2,4]

One swap: swap positions 3 and 4, resulting in [3,1,5,6,2,4]

Then, binary search:

l=1, r=7

m=floor((1+7)/2)=4, p_4=6 ≤5? No, r=4

Now, l=1, r=4

m=floor((1+4)/2)=2, p_2=1 ≤5? Yes, l=2

Now, l=2, r=4

m=floor((2+4)/2)=3, p_3=5 ≤5? Yes, l=3

Now, l=3, r=4

m=floor((3+4)/2)=3, p_3=5 ≤5? Yes, l=3

Now, r - l =1, stop.

p_l =p_3=5, which is x=5.

So, one swap sufficed.

Third test case:

n=5, x=1, permutation=[3,5,4,2,1]

One swap: swap positions 1 and 5, resulting in [1,5,4,2,3]

Binary search:

l=1, r=6

m=floor((1+6)/2)=3, p_3=4 ≤1? No, r=3

Now, l=1, r=3

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1

m=floor((1+3)/2)=1, p_1=1 ≤1? Yes, l=1

Now, r - l =2 >1

...

It seems like it's stuck in an infinite loop, but according to the problem, it should terminate when r - l =1.

Perhaps in this case, p_l =1, which is equal to x=1, so it's acceptable.

Fourth test case:

n=6, x=3, permutation=[4,3,1,5,2,6]

Two swaps:

First swap positions 2 and 4: [4,5,1,3,2,6]

Then swap positions 1 and 5: [2,5,1,3,4,6]

Binary search:

l=1, r=7

m=floor((1+7)/2)=4, p_4=3 ≤3? Yes, l=4

Now, l=4, r=7

m=floor((4+7)/2)=5, p_5=4 ≤3? No, r=5

Now, l=4, r=5

m=floor((4+5)/2)=4, p_4=3 ≤3? Yes, l=4

Now, r - l =1, stop.

p_l =p_4=3, which is x=3.

Fifth test case:

n=3, x=2, permutation=[3,2,1]

One swap: swap positions 1 and 3, resulting in [1,2,3]

Binary search:

l=1, r=4

m=floor((1+4)/2)=2, p_2=2 ≤2? Yes, l=2

Now, l=2, r=4

m=floor((2+4)/2)=3, p_3=3 ≤2? No, r=3

Now, l=2, r=3

m=floor((2+3)/2)=2, p_2=2 ≤2? Yes, l=2

Now, r - l =1, stop.

p_l =p_2=2, which is x=2.

So, in this case, one swap sufficed.

From these examples, it seems that swapping x to the position where l finally is can work, and sometimes, it requires a second swap to adjust another element.

But I need a general strategy.

Let me think about how binary search works.

In a sorted array, binary search repeatedly divides the array into two halves and decides which half to continue searching in, based on the comparison of the middle element with x.

In this problem, since the array is not sorted, I need to make adjustments to make it behave as if it were sorted for the purpose of this specific binary search.

But making the entire array sorted might be overkill, and I only need to make sure that the binary search ends up with p_l =x.

So, perhaps I can focus on the path that the binary search takes and ensure that the comparisons lead to the correct final position.

However, this seems a bit too vague and complex for the time constraints of a programming competition.

Given that two swaps are always sufficient, perhaps there's a simpler way.

One straightforward approach could be:

1. Perform the binary search as is, without any swaps.

2. See where it ends up.

3. If p_l == x, no swaps are needed.

4. If p_l != x, swap x's current position with l's position.

5. If after this swap, the binary search now ends with p_l ==x, then one swap suffices.

6. If not, perform a second swap to adjust another element to make p_l ==x.

But this might not always work, and it's not clear how to choose the second swap.

Another idea: since the binary search modifies l based on comparisons, perhaps I can adjust the elements involved in these comparisons to guide l to the position where x is.

But again, this seems too vague.

Let me consider that in the worst case, I can always bring x to the position where l finally is, and adjust other elements accordingly.

Given that two swaps are always sufficient, perhaps I can swap x to the final l's position, and if necessary, perform another swap to fix any inconsistencies.

But I need a concrete plan.

Let me consider implementing the binary search and see where l ends up.

Then, if p_l !=x, swap x's current position with l's position.

Then, run the binary search again to see if p_l ==x.

If yes, then one swap sufficed.

If not, perform a second swap to adjust another element.

But this might not be efficient enough for the time constraints.

I need a better way.

Perhaps I can precompute where l would end up after the binary search, given the current permutation.

Then, if p_l !=x, swap p_l with x.

Then, check again.

If still not correct, perform a second swap.

But I need to be smarter about which elements to swap.

Alternatively, since the problem allows up to two swaps, I can consider all possible pairs of swaps and see which pair leads to p_l ==x.

But this is O(n^2), which is too slow for n up to 2e5.

I need a more efficient approach.

Let me consider that the binary search is deterministic based on the initial permutation.

So, for a given permutation, l will end up at a specific position.

If p_l ==x, no swaps needed.

If not, I need to adjust the permutation with at most two swaps so that p_l ==x.

One way to think about it is to consider that I can change the positions of at most two elements.

I need to change p_l to be x.

To do that, I can:

- Swap x with p_l.

If x was elsewhere, this would make p_l ==x.

But what if x was already at l? Then, no change is needed.

Wait, in that case, p_l ==x already.

So, swapping x with l would just keep it the same.

But in cases where p_l !=x, swapping x with l would make p_l ==x.

But I need to ensure that this swap doesn't disrupt the binary search in a way that l ends up elsewhere.

Wait, but in the problem, we perform the swaps first, then run the binary search.

So, after swapping, the permutation is fixed, and then the binary search is run to determine l.

So, if I swap x to position l, then run the binary search, l should point to x.

But in some cases, this might not work because the binary search path depends on the values in the permutation.

Wait, maybe I need to simulate the binary search to see where l ends up, then decide on the swaps accordingly.

But with n up to 2e5 and t up to 2e4, I need an efficient solution.

Let me consider that the binary search is essentially trying to find the right position for x, assuming the array is sorted.

Given that, perhaps I can find the position where x should be in the sorted array and try to bring x there through swaps.

But again, this seems too vague.

Let me consider that in the final permutation, I need p_l ==x.

I can find l by running the binary search.

Then, if p_l !=x, I need to swap x's current position with l's position.

Then, run the binary search again to see if p_l ==x.

If yes, one swap suffices.

If not, perform a second swap.

But I need to decide which second swap to perform.

This is getting too complicated.

Let me look back at the sample inputs and see if there's a pattern.

First test case:

n=6, x=3, permutation=[1,2,3,4,5,6]

No swaps needed.

Second test case:

n=6, x=5, permutation=[3,1,6,5,2,4]

One swap: swap 3 and 4.

Resulting permutation: [3,1,5,6,2,4]

Binary search:

l=1, r=7, m=4, p_4=6 >5, r=4

l=1, r=4, m=2, p_2=1 ≤5, l=2

l=2, r=4, m=3, p_3=5 ≤5, l=3

l=3, r=4