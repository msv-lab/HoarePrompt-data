Alright, I've got this problem to solve. Let's see what it's asking for. So, there's a 2xN grid filled with zeros and ones, and there's a grasshopper starting at the top-left cell, which is (1,1), and it wants to reach the bottom-right cell, which is (2,N). The grasshopper can only move one cell right or one cell down. For each path it takes, we can construct a binary string by collecting the numbers in the cells along that path in order. The task is to find the lexicographically smallest string among all possible paths and also count how many paths yield this smallest string.

First, I need to understand what a lexicographically smallest string is. It's basically the smallest string when comparing them character by character, starting from the left. So, for binary strings, '0' comes before '1'. That means, in the first position where two strings differ, the one with '0' is smaller than the one with '1'.

Okay, so to find the smallest possible string, I need to choose a path where the sequence of cells picked gives the smallest possible sequence when read left to right.

Given that the grid has only two rows, the paths are relatively straightforward. From (1,1), the grasshopper can either move right to (1,2) or down to (2,1), and so on, until it reaches (2,N).

I need to think about how to construct the smallest possible string. Let me consider that at each step, the grasshopper has a choice: go right or go down (except when it's at the rightmost column or bottom row, where only one move is possible).

To minimize the string lexicographically, I should try to pick '0's as early as possible in the string, especially in the earlier positions, because they have more weight in lexicographical order.

Let me consider the path choices:

- Starting at (1,1), it can go right to (1,2) or down to (2,1).

- If it goes right to (1,2), then from there it can again go right to (1,3) or down to (2,2).

- If it goes down to (2,1), then from there it can only go right to (2,2), and so on.

Similarly, from any cell (1,j), it can go right to (1,j+1) or down to (2,j), and from (2,j), it can only go right to (2,j+1).

So, the path can be represented as a sequence of moves: right (R) and down (D), with exactly one down move in the entire path.

Wait, no. Actually, there can be multiple down moves, but in this grid, since there are only two rows, there will be exactly one down move in each path, because starting from row 1 and ending at row 2.

Wait, that's not correct. Actually, from row 1, the grasshopper can make multiple down moves, but given that there are only two rows, it can only switch between row 1 and row 2.

Wait, no. Each down move takes it from row 1 to row 2 or from row 2 to row 1, but since it's a 2-row grid, moving down from row 2 would go out of bounds, so effectively, once it moves down to row 2, it has to stay in row 2 and move right until the end.

So, in reality, there is only one down move in each path, and the rest are right moves.

Wait, but actually, if it's a 2-row grid, and it starts at row 1, it can choose to move right or down at each step, but once it moves down to row 2, it can only move right thereafter.

Wait, no, in a 2-row grid, moving down from row 1 takes it to row 2, and moving down from row 2 would go out of bounds, so indeed, there's only one down move in each path.

Therefore, each path consists of moving right some number of times, then moving down from some column to row 2, and then moving right to the end.

So, the path is defined by the column where the down move occurs.

Wait, actually, no. It can interleave right and down moves, but given that moving down from row 2 is invalid, effectively, the down move can only happen once, from some column in row 1 to the corresponding column in row 2.

After that, it must move right until column N.

So, in essence, each path is defined by the column where the down move occurs.

Wait, but actually, in a 2-row grid, the grasshopper can choose to stay in row 1 and make multiple right moves, then eventually move down to row 2 and move right to the end.

Alternatively, it can move down to row 2 earlier.

So, the path is determined by the point where it moves down from row 1 to row 2.

Therefore, there are N possible down move columns, from column 1 to column N.

Wait, but in the first column, moving down from (1,1) to (2,1), or moving right from (1,1) to (1,2), and so on.

Wait, actually, in this grid, the down move can be at any column from 1 to N, but only once.

So, the path is determined by the column where the down move occurs.

Wait, but actually, it's more nuanced because the grasshopper can choose to move right or down at each step, but given the grid's structure, it's equivalent to choosing the column where the down move happens.

Wait, let's think differently.

Let's consider that the path can be represented by a sequence of moves: a series of rights and one down move, with the down move occurring at some point.

But in terms of the cells visited, the path can be seen as:

- Starting at (1,1)

- Then, a sequence of right moves in row 1, followed by one down move to row 2, followed by right moves in row 2 to reach (2,N).

So, indeed, each path corresponds to choosing the column where the down move occurs.

Wait, but actually, it's a bit more flexible. The grasshopper can choose to move down at any step, not necessarily after a series of right moves in row 1.

Wait, but given that moving down from row 2 is invalid, effectively, the down move can only happen from row 1 to row 2 at some column.

Therefore, the path is defined by the column where the down move from row 1 to row 2 occurs.

Wait, but in reality, the grasshopper can choose to move down at any time, but once it moves down to row 2, it must stay in row 2 and move right to the end.

Therefore, each path is uniquely determined by the column where the down move occurs.

Wait, but suppose it moves down at column k, then it moves right in row 2 from column k to column N.

Before that, in row 1, it moves right from column 1 to column k, then down to row 2, column k, then right to column N.

So, the path is completely determined by the value of k, the column where the down move occurs.

Therefore, there are N possible paths, corresponding to k ranging from 1 to N.

Wait, but in the first test case, where n=2, and both rows are "00", the output is "000" with 2 paths.

Wait, but according to this, there should be 2 possible down move columns: k=1 and k=2.

If k=1:

- Start at (1,1), move down to (2,1), then right to (2,2).

- The string is a_{11} a_{21} a_{22} = 0 0 0.

If k=2:

- Start at (1,1), move right to (1,2), then down to (2,2).

- The string is a_{11} a_{12} a_{22} = 0 0 0.

So, both paths give the same string "000", which is the smallest possible.

And the number of paths that give this string is 2.

So, that matches the first test case.

In the second test case, n=4, with rows "1101" and "1100".

Possible paths:

- k=1: (1,1) -> (2,1) -> (2,2) -> (2,3) -> (2,4): string = 1 1 1 0 0.

- k=2: (1,1) -> (1,2) -> (2,2) -> (2,3) -> (2,4): string = 1 1 1 0 0.

- k=3: (1,1) -> (1,2) -> (1,3) -> (2,3) -> (2,4): string = 1 1 0 0 0.

- k=4: (1,1) -> (1,2) -> (1,3) -> (1,4) -> (2,4): string = 1 1 0 1 0.

Now, among these strings:

- "11100"

- "11100"

- "11000"

- "11010"

The smallest lexicographically is "11000", which is from k=3.

And there's only one path that gives this string, which is k=3.

So, that matches the second test case.

In the third test case, n=8, with rows "00100111" and "11101101".

Possible paths:

- k=1: (1,1) -> (2,1) -> (2,2) -> ... -> (2,8): string = 0 1 1 1 0 1 1 0 1.

- k=2: (1,1) -> (1,2) -> (2,2) -> ... -> (2,8): string = 0 0 1 1 0 1 1 0 1.

- k=3: (1,1) -> (1,2) -> (1,3) -> (2,3) -> ... -> (2,8): string = 0 0 1 0 1 1 0 1.

- k=4: (1,1) -> (1,2) -> (1,3) -> (1,4) -> (2,4) -> ... -> (2,8): string = 0 0 1 0 0 1 1 0 1.

- k=5: (1,1) -> (1,2) -> (1,3) -> (1,4) -> (1,5) -> (2,5) -> ... -> (2,8): string = 0 0 1 0 0 1 1 0 1.

- k=6: (1,1) -> (1,2) -> (1,3) -> (1,4) -> (1,5) -> (1,6) -> (2,6) -> ... -> (2,8): string = 0 0 1 0 0 1 1 0 1.

- k=7: (1,1) -> (1,2) -> (1,3) -> (1,4) -> (1,5) -> (1,6) -> (1,7) -> (2,7) -> (2,8): string = 0 0 1 0 0 1 1 0 1.

- k=8: (1,1) -> (1,2) -> (1,3) -> (1,4) -> (1,5) -> (1,6) -> (1,7) -> (1,8) -> (2,8): string = 0 0 1 0 0 1 1 1 1.

Now, among these strings:

- k=1: "011101101"

- k=2: "001101101"

- k=3: "00101101"

- k=4: "001001101"

- k=5: "001001101"

- k=6: "001001101"

- k=7: "001001101"

- k=8: "001001111"

The smallest lexicographically is "001001101", which corresponds to k=4, k=5, k=6, k=7.

So, there are four paths that give this string.

Hence, the output is "001001101" and 4.

Okay, so the problem is to find the smallest such string and the number of paths that give this string.

Now, to solve this efficiently, considering that N can be up to 2*10^5 and T up to 10^4, but the total sum of N over all test cases is up to 2*10^5, we need an efficient algorithm.

First, for each test case, we need to find the smallest possible string and count the number of paths that produce it.

Given that there are only two rows, and the paths are determined by the column where the down move occurs, we can consider each possible k from 1 to N and construct the string for that k, then find the smallest one among them.

But this would be O(N^2), which is too slow for the constraints.

We need a smarter way to find the smallest possible string and count the paths that produce it.

Let's think about how the strings are formed.

For a given k, the string is a_{11} a_{12} ... a_{1k} a_{2k} a_{2(k+1)} ... a_{2N}.

So, it's the sequence:

- From row 1, columns 1 to k.

- Then row 2, columns k to N.

We need to find the k that gives the smallest possible string.

To find the smallest string, we can think of it as finding the path where the sequence of cells gives the smallest possible sequence when read left to right.

Given that, perhaps we can find a way to merge the two rows in a way that minimizes the string.

This seems similar to merging two sorted arrays, but in this case, the "sorted" is according to the lexicographical order of the strings formed by the path.

Wait, perhaps we can model this as a merge operation, choosing at each step the smallest possible character.

But we need to consider that the path must be continuous, moving only right or down.

Wait, maybe we can use dynamic programming to keep track of the smallest possible string up to each position.

But that might be too slow for the constraints.

Let me think differently.

Suppose we iterate through the columns from left to right and decide at each step whether to stay in row 1 or move to row 2.

We want to choose the path that gives the smallest possible string.

To do that, we can greedily choose the smallest available character at each step, considering the possible moves.

But we need to be careful because choosing the smallest character now might not lead to the overall smallest string if it forces suboptimal choices later on.

Wait, perhaps we can find the position where switching from row 1 to row 2 gives the smallest possible string.

Let me consider that.

At each column k from 1 to N, we can choose to switch to row 2 at that column.

Then, the string would be a_{11} to a_{1k} followed by a_{2k} to a_{2N}.

We need to find the k that minimizes this string.

To find the smallest string, we can compare the strings starting from k=1 to k=N and find the minimum.

But comparing strings directly would be too slow for large N.

We need a smarter way.

Let's consider that the string for each k is:

s_k = a_{11} a_{12} ... a_{1k} a_{2k} a_{2(k+1)} ... a_{2N}

We need to find the k that gives the smallest s_k.

To do this efficiently, we can think of it as finding the point where switching from row 1 to row 2 gives the smallest possible continuation.

Wait, perhaps we can find the k where a_{2k} is as small as possible, considering the previous choices.

But we need to consider the entire string.

Wait, maybe we can iterate through the columns and keep track of the current path and the possible switches.

Let me try to formalize this.

Let's iterate through the columns from left to right.

At each column, we have to decide whether to stay in row 1 or move to row 2.

Our goal is to build the smallest possible string.

We can maintain a current string and decide at each step which move to make.

But since we're dealing with strings, it's a bit tricky.

An alternative approach is to consider that the smallest string will be the one where we delay the down move as much as possible, but only if it doesn't cause a larger character to be included earlier.

Wait, perhaps it's better to think in terms of comparing the strings position by position.

Let's consider the strings produced by different k values and see where they differ.

For example, in the second test case:

- k=1: 1 1 1 0 0

- k=2: 1 1 1 0 0

- k=3: 1 1 0 0 0

- k=4: 1 1 0 1 0

Looking at position 1:

- All strings start with '1'.

Looking at position 2:

- All strings have '1' at position 2.

Looking at position 3:

- For k=1 and k=2: '1'

- For k=3 and k=4: '0'

So, the strings that start with '110' are smaller than those starting with '111'.

Therefore, the smallest strings are those where k=3 and k=4, but in this case, k=4 has '11010', which is larger than '11000' from k=3.

Hence, the smallest is '11000' from k=3.

So, in this case, choosing k=3 gives the smallest string because at position 3, we get a '0' instead of a '1'.

This suggests that we should choose the k where the switch to row 2 allows us to get a '0' as early as possible in the string.

But in the first test case, all strings are "000", so any k gives the same string.

In the third test case, multiple k's give the same smallest string.

So, perhaps the way to find the smallest string is to find the k where the switch to row 2 allows the earliest '0' in the string.

Wait, but that might not always be the case.

Wait, perhaps a better way is to find the point where switching to row 2 gives a smaller string than continuing in row 1.

But I need a systematic way to find this.

Let me consider that the string for k is:

s_k = a11 a12 ... a1k a2k a2(k+1) ... a2N

I need to find the k that minimizes s_k.

To do this efficiently, perhaps I can iterate through the columns and keep track of the current best string.

Let me try to simulate this.

Initialize the current smallest string as the string for k=1.

Then, for each k from 2 to N, compare the string for k with the current smallest string, and keep the smaller one.

But comparing strings directly is O(N), and with T up to 10^4 and N up to 2*10^5, this would be too slow.

I need a way to find the smallest s_k in O(N) time for all k.

Wait, perhaps I can find a way to compute the s_k strings in a cumulative way.

Let me consider that s_k can be built by taking the prefix from row 1 up to column k, and then appending the suffix from row 2 starting from column k.

So, s_k = a11 a12 ... a1k a2k a2(k+1) ... a2N

To find the smallest s_k, I can iterate through k from 1 to N and keep track of the smallest s_k.

But again, comparing strings directly is too slow.

I need a smarter way.

Let me consider that the strings differ at certain positions based on the choices made.

Perhaps I can find the position where the strings differ and choose the k that gives the smallest character at that position.

Wait, maybe I can use suffix comparisons.

Let me precompute for each k, the string s_k, but without actually storing the strings.

Wait, that's not efficient.

An alternative idea is to consider that the string s_k is a concatenation of the prefix from row 1 and the suffix from row 2 starting at column k.

So, s_k = prefix_row1[1..k] + suffix_row2[k..N]

To find the smallest s_k, I need to find the k where this concatenation is smallest.

To do this efficiently, perhaps I can find the point where switching from row 1 to row 2 gives the smallest possible continuation.

Wait, maybe I can iterate through the columns and keep track of the current smallest string by comparing the choices at each step.

Let me try to think of it step by step.

Start at (1,1).

Option 1: move right to (1,2)

Option 2: move down to (2,1)

Choose the option that leads to the smallest string.

Similarly, at each step, choose the move that gives the smallest possible next character.

This seems promising.

In other words, perform a greedy choice at each step, always choosing the smallest available character.

But in this grid, since we can only move right or down, and given the structure, we need to decide at each step whether to stay in row 1 or switch to row 2.

Wait, perhaps we can iterate through the columns, deciding at each step whether to stay in row 1 or switch to row 2.

Let me try to formalize this.

Initialize current row as row 1.

Start at column 1.

At each column, choose to stay in the current row or move to the other row, picking the option that gives the smallest next character.

Wait, but since once we move to row 2, we have to stay in row 2, as moving back to row 1 is not allowed.

So, in reality, we can choose to switch to row 2 at any column, but only once.

Therefore, we can think of it as choosing the column k where we switch to row 2, and then taking the prefix from row 1 up to k, and the suffix from row 2 starting at k.

Wait, but that's similar to what I thought earlier.

Perhaps I need to find a way to efficiently compare the s_k strings.

Wait, maybe I can iterate through the columns and keep track of the minimum difference point.

Let me consider that the strings s_k and s_{k+1} differ starting from some position.

I need to find the k where s_k is smallest.

Wait, perhaps I can find the k where a2k < a1(k+1).

Because if a2k < a1(k+1), then switching to row 2 at column k would give a smaller string than continuing in row 1.

Wait, let's think about this.

Suppose at column k, a2k < a1(k+1).

Then, switching to row 2 at column k would give a smaller string than continuing in row 1.

Because in s_k, at position k+1, it would be a2(k+1), which might be smaller than a1(k+1).

Wait, but I need to consider the entire string.

Wait, perhaps I can find the earliest column k where a2k < a1k, meaning that switching to row 2 at column k would give a smaller character at position k.

Wait, no.

Wait, let's consider that in s_k, the character at position k is a2k.

In s_{k-1}, the character at position k is a1k.

So, if a2k < a1k, then s_k would be smaller than s_{k-1} at position k.

Therefore, switching at column k is better than continuing in row 1.

Wait, but actually, in s_k, the character at position k is a2k, and in s_{k-1}, the character at position k is a1k.

Therefore, if a2k < a1k, then s_k is smaller than s_{k-1} at position k.

Hence, the smallest s_k would be the one where k is the smallest possible such that a2k < a1k, and a2k is as small as possible.

Wait, perhaps I need to find the smallest k where a2k < a1k, and among those, choose the smallest a2k.

But this might not always be the case.

Wait, maybe I need to find the k where a2k is minimized, considering the previous