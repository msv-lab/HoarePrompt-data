Alright, I've got this problem to solve. Let's read it carefully.

We have a village with n houses, and the villagers want to build a big road that divides the village into left and right sides. Each resident wants to live on either the left or the right side, which is indicated by a sequence of a_j where 0 means left and 1 means right.

The road can be built between any two houses, or before the first house or after the last house. So, possible positions for the road are between house i and i+1 for i from 0 to n (where 0 means before the first house and n means after the last house).

The goal is to choose the position for the road such that at least half of the residents on each side are satisfied with their side. Satisfied means that their preferred side matches the side they end up on.

Moreover, among all possible positions that satisfy this condition, we should choose the one that is as close as possible to the middle of the village. If there are multiple positions with the same minimum distance to the middle, we should choose the smaller one.

The input consists of multiple test cases, and for each test case, we have n and a string of 0s and 1s representing the residents' preferences.

First, I need to understand the problem fully.

Given n houses and a sequence a_1 to a_n where each a_j is 0 or 1, indicating whether the resident wants to be on the left (0) or right (1) side.

We need to choose a position to build the road such that:

1. At least half of the residents on the left side want to be on the left side.

2. At least half of the residents on the right side want to be on the right side.

And among all such positions, choose the one closest to the middle of the village.

Let's consider an example to understand better.

Take n=3, s=101.

Possible road positions:

- Position 0: entire village is on the right side.

- Position 1: house 1 on the left, houses 2 and 3 on the right.

- Position 2: houses 1 and 2 on the left, house 3 on the right.

- Position 3: entire village on the left side.

Let's check each position:

Position 0:

- Left side: none.

- Right side: houses 1,2,3 with preferences 1,0,1.

- At least half satisfied: for right side, need at least ceil(3/2)=2 satisfied residents wanting right.

- Among them, houses 1 and 3 want right, so 2 satisfied, which is enough.

Position 1:

- Left side: house 1 with preference 1. Need at least ceil(1/2)=1 satisfied.

- Right side: houses 2 and 3 with preferences 0 and 1. Need at least ceil(2/2)=1 satisfied.

- Left side: house 1 wants right, but is on left, not satisfied. So 0 satisfied, which is less than 1 required. Not valid.

Position 2:

- Left side: houses 1 and 2 with preferences 1 and 0. Need at least ceil(2/2)=1 satisfied.

- Right side: house 3 with preference 1. Need at least ceil(1/2)=1 satisfied.

- Left side: house 2 wants left, which matches, so 1 satisfied, which is enough.

- Right side: house 3 wants right, which matches, so 1 satisfied, enough.

Position 3:

- Left side: houses 1,2,3 with preferences 1,0,1. Need at least ceil(3/2)=2 satisfied.

- Right side: none.

- Left side: houses wanting left: house 2, so 1 satisfied. Need 2, which is not enough.

So, positions 0 and 2 are valid.

Among these, position 2 is closer to the middle (n=3, middle is at position 1.5, so position 2 is closer than position 0).

Hence, position 2 is the answer.

Another example:

n=6, s=010111

Possible positions: 0,1,2,3,4,5,6

Let's check position 3:

- Left side: houses 1-3 with preferences 0,1,0. Need at least ceil(3/2)=2 satisfied.

- Right side: houses 4-6 with preferences 1,1,1. Need at least ceil(3/2)=2 satisfied.

- Left side: houses 1 and 3 want left, which matches, so 2 satisfied, enough.

- Right side: all three want right, which matches, so 3 satisfied, enough.

Position 3 is valid.

Position 0:

- Left side: none.

- Right side: all six houses with preferences 0,1,0,1,1,1. Need at least ceil(6/2)=3 satisfied.

- Houses wanting right: houses 2,4,5,6 (four 1s). So, four satisfied, which is more than 3, enough.

Position 6:

- Left side: all six houses. Need at least ceil(6/2)=3 satisfied.

- Right side: none.

- Left side: houses wanting left: houses 1,3 (two 0s). Need at least 3 satisfied, which is not enough.

So, position 6 is invalid.

Position 1:

- Left side: house 1 with preference 0. Need at least ceil(1/2)=1 satisfied.

- Right side: houses 2-6 with preferences 1,0,1,1,1. Need at least ceil(5/2)=3 satisfied.

- Left side: house 1 wants left, which matches, so 1 satisfied, enough.

- Right side: houses 2,4,5,6 want right, which matches, so four satisfied, enough.

Position 2:

- Left side: houses 1 and 2 with preferences 0 and 1. Need at least ceil(2/2)=1 satisfied.

- Right side: houses 3-6 with preferences 0,1,1,1. Need at least ceil(4/2)=2 satisfied.

- Left side: house 1 wants left, which matches, so 1 satisfied, enough.

- Right side: houses 3 wants left, but is on right, not satisfied. Houses 4,5,6 want right, which matches, so three satisfied. Total three satisfied, which is more than 2, enough.

Position 3:

Already checked, valid.

Position 4:

- Left side: houses 1-4 with preferences 0,1,0,1. Need at least ceil(4/2)=2 satisfied.

- Right side: houses 5 and 6 with preferences 1,1. Need at least ceil(2/2)=1 satisfied.

- Left side: houses 1 and 3 want left, which matches, so two satisfied, enough.

- Right side: both houses want right, which matches, so two satisfied, enough.

Position 5:

- Left side: houses 1-5 with preferences 0,1,0,1,1. Need at least ceil(5/2)=3 satisfied.

- Right side: house 6 with preference 1. Need at least ceil(1/2)=1 satisfied.

- Left side: houses 1,3 want left, which matches (2 satisfied). House 5 wants right, which does not match left, not satisfied. Total 2 satisfied, which is less than 3 required. Not valid.

So, positions 0,1,2,3,4 are valid.

Now, we need to choose the one closest to the middle.

n=6, middle is at position 3.

Among positions 0,1,2,3,4, position 3 is exactly at the middle.

So, position 3 is the answer.

Another example:

n=3, s=000

Possible positions: 0,1,2,3

Position 0:

- Left side: none.

- Right side: houses 1,2,3 with preferences 0,0,0. Need at least ceil(3/2)=2 satisfied.

- Houses wanting right: none. So, 0 satisfied, which is less than 2. Invalid.

Position 1:

- Left side: house 1 with preference 0. Need at least ceil(1/2)=1 satisfied.

- Right side: houses 2,3 with preferences 0,0. Need at least ceil(2/2)=1 satisfied.

- Left side: house 1 wants left, which matches, so 1 satisfied, enough.

- Right side: houses 2 and 3 want left, which matches, so two satisfied, enough.

Position 2:

- Left side: houses 1,2 with preferences 0,0. Need at least ceil(2/2)=1 satisfied.

- Right side: house 3 with preference 0. Need at least ceil(1/2)=1 satisfied.

- Left side: houses 1 and 2 want left, which matches, so two satisfied, enough.

- Right side: house 3 wants left, which matches, so 1 satisfied, enough.

Position 3:

- Left side: houses 1,2,3 with preferences 0,0,0. Need at least ceil(3/2)=2 satisfied.

- Right side: none.

- Left side: houses 1,2,3 want left, which matches, so three satisfied, enough.

So, positions 1,2,3 are valid.

Middle is at position 1.5.

Position 1 is at distance 0.5, position 2 is at distance 0.5.

So, both positions 1 and 2 have the same distance to the middle.

We need to choose the smaller one, which is position 1.

But according to the problem, it should output 2 for this case.

Wait, in the example, for n=6, s=011001, the output is 2.

Wait, let's check the sample input and output.

Sample Input:

7

3

101

6

010111

6

011001

3

000

3

110

3

001

4

1100

Sample Output:

2

3

2

3

0

1

0

Wait, for n=3, s=101, output is 2.

For n=6, s=010111, output is 3.

For n=6, s=011001, output is 2.

For n=3, s=000, output is 3.

For n=3, s=110, output is 0.

For n=3, s=001, output is 1.

For n=4, s=1100, output is 0.

Wait, in the first case, n=3, s=101, position 2 is chosen.

In this case, positions 0 and 2 are valid, and position 2 is closer to the middle (1.5) than position 0.

Hence, position 2 is chosen.

In the third case, n=6, s=011001, positions 0,1,2,3,4 are valid, and position 2 is closer to the middle (3/2=1.5) than position 3 (which is at 1.5), but position 2 is smaller, so it's chosen.

Wait, n=6, middle is at 3, positions 0,1,2,3,4 are valid, and positions 1 and 2 are at distance 2 from the middle, positions 3 and 4 are at distance 1 and 0 from the middle.

Wait, n=6, middle is at 3, positions 0,1,2,3,4.

Position 0 is at distance 3 from the middle.

Position 1 is at distance 2 from the middle.

Position 2 is at distance 1 from the middle.

Position 3 is at distance 0 from the middle.

Position 4 is at distance 1 from the middle.

So, the closest positions are 3 and 4, with distance 0 and 1 respectively.

But in the sample output, it's 2 for n=6, s=011001.

Wait, maybe I misunderstood.

Wait, perhaps I need to consider the distance as |i - n/2|, where i is the position.

For n=6, middle is at position 3.

Positions 0,1,2,3,4 are valid.

Distances:

Position 0: |0 - 3| = 3

Position 1: |1 - 3| = 2

Position 2: |2 - 3| = 1

Position 3: |3 - 3| = 0

Position 4: |4 - 3| = 1

So, positions 3 and 4 have the smallest distance of 0 and 1.

But according to the sample output, it's 2.

Wait, maybe I need to consider the number of houses on each side.

Wait, perhaps I misread the problem.

Wait, the problem says: among all suitable positions i, minimize |n/2 - i|.

Wait, n is the number of houses, i is the position after which the road is built.

So, positions are from 0 to n.

For n=6, positions 0 to 6.

But in the sample input, for n=6, s=010111, the output is 3.

Which is correct, as positions 0,1,2,3,4 are valid, and position 3 is closest to n/2=3.

For n=6, s=011001, output is 2.

Wait, perhaps position 2 has a smaller |i - n/2| than position 3.

Wait, n=6, n/2=3.

|2 - 3|=1, |3 - 3|=0.

So, position 3 is closer, but the output is 2.

Wait, perhaps I need to consider the number of houses on each side.

Wait, maybe I need to minimize |left - right|, where left and right are the number of houses on each side.

Wait, no, the problem says to minimize |n/2 - i|.

Wait, but in the sample input, for n=6, s=011001, output is 2, but according to |i - n/2|, position 3 should be closer.

Wait, perhaps I need to minimize |left_satisfied - left/2| and |right_satisfied - right/2|.

Wait, no, the problem is to minimize |n/2 - i| among the valid positions.

But in the sample input, for n=6, s=011001, output is 2, but position 3 is closer to n/2=3.

Maybe there is a misunderstanding.

Wait, perhaps the middle is defined as floor(n/2).

Wait, no, the problem says: minimize |n/2 - i|.

So, for n=6, n/2=3, so position 3 is closest.

But in the sample input, for n=6, s=011001, output is 2.

Wait, perhaps position 3 is invalid in this case.

Wait, no, in the earlier analysis, position 3 is valid.

Wait, perhaps I need to check again.

Wait, perhaps the problem is to minimize |i - n/2|, not |n/2 - i|.

But the problem says: minimize |n/2 - i|.

Wait, in Python, |a - b| = |b - a|.

So, it's the same.

But in the sample input, for n=6, s=011001, output is 2, but according to the calculation, position 3 is closer to n/2=3.

Maybe there is a misinterpretation.

Wait, perhaps the middle is defined as n/2, and i is the number of houses on the left side.

Wait, no, i is the position after which the road is built.

Wait, perhaps I need to minimize |i - n/2|.

Wait, in the problem statement, it says: minimize |n/2 - i|.

So, it's |n/2 - i|.

For n=6, n/2=3, so |3 - i|.

Positions 0,1,2,3,4 are valid.

Positions 3 and 4 have |3 - 3|=0 and |3 - 4|=1.

But the sample output is 2, which has |3 - 2|=1.

Wait, perhaps I need to consider the number of houses on each side.

Wait, perhaps i is the number of houses on the left side.

Wait, no, the problem says: the road is built after house i, so houses 1 to i are on the left side, and houses i+1 to n are on the right side.

So, i is the number of houses on the left side.

Hence, i can be from 0 to n.

So, for n=6, i can be 0,1,2,3,4,5,6.

But in the sample input, for n=6, s=010111, output is 3, which matches i=3.

For n=6, s=011001, output is 2.

Wait, perhaps in this case, position 3 is invalid.

Wait, but earlier I thought position 3 is valid.

Wait, perhaps I made a mistake in the earlier analysis.

Let me re-examine.

For n=6, s=011001:

Positions:

0: left=None, right=all (houses 1-6: 0,1,1,0,0,1)

Need at least ceil(6/2)=3 satisfied on right.

Houses wanting right: houses 2,3,5,6 (1,1,0,1). Wait, houses 2,3,6 want right, which is three. So, three satisfied, which is enough.

Position 0 is valid.

Position 1:

Left: house1 (0), need at least ceil(1/2)=1 satisfied.

Right: houses2-6 (1,1,0,0,1), need at least ceil(5/2)=3 satisfied.

Left: house1 wants left, which matches, so 1 satisfied, enough.

Right: houses2,3,6 want right, which matches, so three satisfied, enough.

Position 1 is valid.

Position 2:

Left: houses1-2 (0,1), need at least ceil(2/2)=1 satisfied.

Right: houses3-6 (1,0,0,1), need at least ceil(4/2)=2 satisfied.

Left: house1 wants left, which matches, so 1 satisfied, enough.

Right: houses3 and6 want right, which matches, so two satisfied, enough.

Position 2 is valid.

Position 3:

Left: houses1-3 (0,1,1), need at least ceil(3/2)=2 satisfied.

Right: houses4-6 (0,0,1), need at least ceil(3/2)=2 satisfied.

Left: house1 wants left, which matches (1 satisfied). Houses2 and3 want right, which do not match left, not satisfied. So, only 1 satisfied, which is less than 2 required. Invalid.

Position 3 is invalid.

Position 4:

Left: houses1-4 (0,1,1,0), need at least ceil(4/2)=2 satisfied.

Right: houses5-6 (0,1), need at least ceil(2/2)=1 satisfied.

Left: house1 wants left, which matches (1 satisfied). House4 wants left, which matches (2 satisfied), enough.

Right: house6 wants right, which matches (1 satisfied), enough.

Position 4 is valid.

Position 5:

Left: houses1-5 (0,1,1,0,0), need at least ceil(5/2)=3 satisfied.

Right: house6 (1), need at least ceil(1/2)=1 satisfied.

Left: houses1,4,5 want left, which matches (3 satisfied), enough.

Right: house6 wants right, which matches (1 satisfied), enough.

Position 5 is valid.

Position 6:

Left: all houses, need at least ceil(6/2)=3 satisfied.

Right: none.

Left: houses1,3,4,5,6 have preferences 0,1,1,0,1. Houses1,4,5 want left, which matches (3 satisfied), enough.

Right: none.

Position 6 is valid.

So, valid positions are 0,1,2,4,5,6.

Now, we need to choose the one with the smallest |n/2 - i|, where n=6, n/2=3.

Calculate |3 - i| for each valid i:

0: |3-0|=3

1: |3-1|=2

2: |3-2|=1

4: |3-4|=1

5: |3-5|=2

6: |3-6|=3

So, positions 2 and 4 have the smallest |i - n/2|=1.

Among these, choose the smaller i, which is 2.

Hence, output is 2.

Got it. So, the middle is at n/2, and we need to choose the position i that minimizes |n/2 - i| among the valid positions.

If there are multiple, choose the smallest i.

Now, to implement this, I need an efficient way to find the valid positions and then select the one closest to n/2.

Given that n can be up to 3*10^5 and t up to 2*10^4, but the total sum of n over all test cases is up to 3*10^5, I need an efficient solution, O(n) per test case.

First, for each position i from 0 to n:

- Left side: houses 1 to i.

- Right side: houses i+1 to n.

- Calculate the number of 0s in left side and number of 1s in right side.

- Check if number of 0s in left side is at least ceil(i / 2), and number of 1s in right side is at least ceil((n - i)/2).

- Collect all i that satisfy this condition.

- Among these i, find the one with the smallest |n/2 - i|.

- If multiple, choose the smallest i.

To efficiently calculate the number of 0s in left side and number of 1s in right side for each i, I can precompute prefix sums.

Let's define:

- prefix_zero[i]: number of 0s in houses 1 to i.

- prefix_one[i]: number of 1s in houses 1 to i.

Then, for position i:

- Number of 0s in left side: prefix_zero[i]

- Number of 1s in right side: prefix_one[n] - prefix_one[i]

Then, check:

- prefix_zero[i] >= ceil(i / 2)

- (prefix_one[n] - prefix_one[i]) >= ceil((n - i)/2)

Compute ceil(x/2) as (x + 1) // 2

So, for each i from 0 to n:

- left_zeros = prefix_zero[i]

- right_ones = prefix_one[n] - prefix_one[i]

- if left_zeros >= (i + 1) // 2 and right_ones >= (n - i + 1) // 2, then i is a valid position.

Then, find the i with the smallest |n/2 - i|, and among those, the smallest i.

Implementing this efficiently is crucial given the constraints.

To handle multiple test cases efficiently, I need to read all inputs first or handle them in a loop carefully.

Now, let's think about edge cases.

Edge Cases:

1. n=3, s=101

- Valid positions: 0,2

- n/2=1.5

- |0 - 1.5|=1.5

- |2 - 1.5|=0.5

- Choose position 2.

2. n=3, s=000

- Valid positions:1,2,3

- n/2=1.5

- |1-1.5|=0.5

- |2-1.5|=0.5

- Choose position 1.

Wait, in the sample input, for n=3, s=000, output is 3.

Wait, perhaps I'm misunderstanding.

Wait, in the sample input, for n=3, s=000, output is 3.

But according to my earlier analysis, positions 1,2,3 are valid, and both positions 1 and 2 have the same distance to n/2=1.5.

But the sample output is 3.

Wait, perhaps I need to consider the distance as |i - (n+1)/2|.

Wait, n=3, (n+1)/2=2.

Then, positions:

1: |1 - 2|=1

2: |2 - 2|=0

3: |3 - 2|=1

So, position 2 is closest, but the sample output is 3.

Wait, perhaps I need to consider i as the number of houses on the left side.

Wait, perhaps the middle is defined differently.

Wait, in the problem statement, it says: minimize |n/2 - i|.

So, for n=3, n/2=1.5, positions 1,2,3 have distances:

1: |1 - 1.5|=0.5

2: |2 - 1.5|=0.5

3: |3 - 1.5|=1.5

So, positions 1 and 2 are closest.

But the sample output is 3 for n=3, s=000.

Wait, perhaps I made a mistake in the earlier analysis.

Let's check the validity for n=3, s=000.

Positions:

0: left=None, right=all (houses 1,2,3 with s=000)

- Right side: need at least ceil(3/2)=2 satisfied.

- Houses wanting right: none, since all want left.

- 0 satisfied, which is less than 2. Invalid.

Position 1:

- Left: house1 (0), need at least ceil(1/2)=1 satisfied.

- Right: houses2,3 (0,0), need at least ceil(2/2)=1 satisfied.

- Left: house1 wants left, which matches, 1 satisfied, enough.

- Right: houses2 and3 want left, which matches, 2 satisfied, enough.

Valid.

Position 2:

- Left: houses1,2 (0,0), need at least ceil(2/2)=1 satisfied.

- Right: house3 (0), need at least ceil(1/2)=1 satisfied.

- Left: houses1 and2 want left, which matches, 2 satisfied, enough.

- Right: house3 wants left, which matches, 1 satisfied, enough.

Valid.

Position 3:

- Left: all houses (0,0,0), need at least ceil(3/2)=2 satisfied.

- Right: none.

- Left: houses1,2,3 want left, which matches, 3 satisfied, enough.

Valid.

So, positions 1,2,3 are valid.

Now, minimize |n/2 - i|, where n=3, n/2=1.5.

Positions 1 and 2 have |1.5 -1|=0.5 and |1.5 -2|=0.5, which is smaller than position 3's |1.5 -3|=1.5.

So, positions 1 and 2 are closest.

But according to the sample input, for n=3, s=000, output is 3.

Wait, perhaps I need to minimize |i - floor(n/2)|.

Wait, n=3, floor(n/2)=1.

Then, positions 1,2,3 have distances:

1: |1 -1|=0

2: |2 -1|=1

3: |3 -1|=2

So, position 1 is closest.

But the sample output is 3.

Wait, perhaps there is a misunderstanding in the problem statement.

Wait, the problem says: among all suitable positions i, minimize |n/2 - i|.

But in the sample input, for n=3, s=000, output is 3.

But according to the above, positions 1 and 2 are closer to n/2=1.5 than position 3.

Perhaps the problem wants to minimize |i - (n/2)|, where i is the number of houses on the left side.

Wait, perhaps the middle is defined as floor((n+1)/2).

For n=3, floor((3+1)/2)=2.

Then, positions 1,2,3 have distances:

1: |1 -2|=1

2: |2 -2|=0

3: |3 -2|=1

So, position 2 is closest.

But in the sample input, for n=3, s=000, output is 3.

Wait, perhaps I need to minimize |i - ceil(n/2)|.

Ceil(3/2)=2.

Positions 1,2,3 have distances:

1: |1 -2|=1

2: |2 -2|=0

3: |3 -2|=1

So, position 2 is closest.

But sample output is 3.

Wait, perhaps there is a misinterpretation.

Looking back at the problem statement:

"Determine after which house i the road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible.

Formally, among all suitable positions i, minimize |n/2 - i|.

If there are multiple suitable positions i with the minimum |n/2 - i|, output the smaller one."

Wait, perhaps there is a mistake in the sample output explanation.

Wait, perhaps for n=3, s=000, the output should be 2, but it's given as 3.

Wait, perhaps I need to consider i as the number of houses on the left side.

Wait, in the problem, i is the position after which the road is built.

So, i ranges from 0 to n.

For n=3, positions 0,1,2,3.

Position 0: entire village on right side.

Position 1: house1 on left, houses2,3 on right.

Position 2: houses1,2 on left, house3 on right.

Position 3: entire village on left side.

For n=3, s=000:

Position 0:

- Right side: houses1,2,3 with s=000.

- Need at least ceil(3/2)=2 satisfied.

- All houses want left, so 0 satisfied on right side. Not enough.

Invalid.

Position 1:

- Left: house1 (0), need at least ceil(1/2)=1 satisfied.

- Right: houses2,3 (0,0), need at least ceil(2/2)=1 satisfied.

- Left: house1 wants left, satisfied.

- Right: houses2 and3 want left, but are on right side, not satisfied.

- So, 0 satisfied on right side, which is less than 1 required.

Invalid.

Wait, earlier I thought position1 was valid, but actually, on right side, houses2 and3 want left, but are on right side, so not satisfied.

Hence, position1 is invalid.

Position2:

- Left: houses1,2 (0,0), need at least ceil(2/2)=1 satisfied.

- Right: house3 (0), need at least ceil(1/2)=1 satisfied.

- Left: houses1 and2 want left, satisfied.

- Right: house3 wants left, but is on right side, not satisfied.

- So, 0 satisfied on right side, which is less than 1 required.

Invalid.

Position3:

- Left: houses1,2,3 (0,0,0), need at least ceil(3/2)=2 satisfied.

- Right: none.

- Left: houses1,2,3 want left, satisfied.

- So, 3 satisfied, which is enough.

- Right side: none, condition automatically satisfied.

Valid.

Hence, only position3 is valid.

Hence, output should be 3.

Wait, but earlier in my analysis, I thought position1 was valid, but actually, it's invalid because on the right side, houses2 and3 want left, but are on the right side, so not satisfied.

Similarly, position2 is invalid for the same reason.

Only position3 is valid, hence output is 3.

Got it, I made a mistake earlier.

So, to generalize:

- For each position i from 0 to n:

- Left side: houses 1 to i.

- Right side: houses i+1 to n.

- Calculate number of 0s in left side and number of 1s in right side.

- Check if number of 0s in left side >= ceil(i / 2)

- And number of 1s in right side >= ceil((n - i)/2)

- Collect all valid i.

- Among valid i, find the one with the smallest |n/2 - i|.

- If multiple, choose the smallest i.

Implementing this efficiently is crucial.

Given that n can be up to 3*10^5 and t up to 2*10^4, but sum of n over all test cases <= 3*10^5, we can afford O(n) per test case.

Implementing prefix sums for 0s and 1s.

Edge Cases to consider:

1. All houses want left (s=000...0):

- Only position n is valid, since left side has all houses with 0s, which satisfies the condition.

2. All houses want right (s=111...1):

- Only position 0 is valid, since right side has all houses with 1s, which satisfies the condition.

3. n is odd:

- n/2 is a float, need to handle floating points correctly when calculating |n/2 - i|.

4. Multiple positions have the same minimal |n/2 - i|:

- Choose the smallest i.

5. Only one position is valid:

- Output that position.

6. n=3, s=000:

- As above, only position3 is valid.

7. n=4, s=1100:

- Positions0,1,2,3,4 are valid.

- n/2=2, positions with |i - 2| minimal.

Implementing the solution:

- Read t.

- For each test case:

- Read n.

- Read string s of length n.

- Compute prefix_zero[i]: number of 0s in s[0 to i-1].

- Compute prefix_one[i]: number of 1s in s[0 to i-1].

- Iterate i from 0 to n:

- left_zeros = prefix_zero[i]

- right_ones = prefix_one[n] - prefix_one[i]

- left_size = i

- right_size = n - i

- if left_zeros >= ceil(left_size / 2) and right_ones >= ceil(right_size / 2):

- collect i

- Find the i in the collected list with the smallest |n/2 - i|

- If multiple, choose the smallest i

- Output i

Implementing prefix sums efficiently.

Also, to handle floating points accurately, since n can be up to 3*10^5, but i is integer, |n/2 - i| can be a float, but we can compare them as floats.

Alternatively, since we are minimizing |n/2 - i|, we can consider it as minimizing the integer distance |i - floor(n/2)| or |i - ceil(n/2)|.

Wait, but n/2 could be a float, so better to compute it as a float and calculate the absolute difference.

But in code, since i is integer, and n is integer, n/2 is a float, |n/2 - i| is a float.

We can keep track of the minimal distance found and the corresponding i.

Implementing this in code.

Also, need to handle the case when there are multiple i with the same minimal distance, choose the smallest i.

Hence, sort the valid i's based on their distance to n/2, and pick the smallest i among those with minimal distance.

Also, need to make sure that the answer always exists, as per the problem statement.

Now, let's think about the time complexity.

For each test case, O(n) time for prefix sums, O(n) time to iterate through all positions.

Given that sum of n over all test cases is up to 3*10^5, this should be efficient enough.

Now, let's think about implementing this in code.

I need to read t, then for each test case, read n and s.

Compute prefix_zero and prefix_one.

Then, iterate through i from 0 to n, check the conditions, collect valid i's.

Then, find the i with the smallest |n/2 - i|, and among those, the smallest i.

Finally, print i.

Implementing this step by step.

Also, need to handle the case when n is odd or even correctly.

Let's think about n=3, s=000:

- prefix_zero: [0,1,2,3]

- prefix_one: [0,0,0,0]

- positions:

0: left_zeros=0, right_ones=0 >= ceil(3/2)=2? No

1: left_zeros=1 >= ceil(1/2)=1, right_ones=0 >= ceil(2/2)=1? No

2: left_zeros=2 >= ceil(2/2)=1, right_ones=0 >= ceil(1/2)=1? No

3: left_zeros=3 >= ceil(3/2)=2, right_ones=0 >= ceil(0/2)=0? Yes

- Only position3 is valid.

- n/2=1.5

- |3 -1.5|=1.5

- Output 3

Another case: n=4, s=1100

- prefix_zero: [0,0,0,1,1