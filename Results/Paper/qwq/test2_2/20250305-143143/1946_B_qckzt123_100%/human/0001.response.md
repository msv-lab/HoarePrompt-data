Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly K operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. My goal is to maximize the sum of the array after K operations, and since the sum can be very large, I need to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation does. So, in one operation, I choose a contiguous subarray, compute its sum, and then insert that sum into the array at any position I like. For example, if I have an array [1, 2, 3], and I choose the subarray [2, 3] with sum 5, I can insert 5 at the beginning, end, or in between any elements. So, possible new arrays could be [5, 1, 2, 3], [1, 5, 2, 3], [1, 2, 5, 3], or [1, 2, 3, 5].

My aim is to maximize the sum of the array after performing exactly K such operations.

Let me think about how the sum changes with each operation. Initially, the sum of the array is S. When I perform an operation, I select a subarray with sum S_sub and insert it into the array. This means that the new sum becomes S + S_sub because I'm adding S_sub to the array's total sum.

Wait a minute, but I'm not removing the original subarray; I'm just inserting the sum somewhere else. So, the sum of the array increases by S_sub each time I perform an operation.

But, looking back at the problem, it says "insert the sum of this subarray anywhere in the array." So, it seems like I'm adding the sum of the subarray to the array, not replacing anything. Therefore, the total sum increases by S_sub with each operation.

Given that, to maximize the sum after K operations, I need to choose the subarray with the maximum possible sum each time and insert its sum into the array.

So, the key is to find the maximum sum of any contiguous subarray in the original array and then add this maximum sum K times to the original sum.

But, hold on, perhaps I can do better by strategically choosing which subarrays to select and where to insert their sums.

Wait, but since I can choose any contiguous subarray each time and insert its sum anywhere, maybe choosing the subarray with the maximum sum each time and inserting it at the end is the way to go.

Let me consider an example to see if there's a better strategy.

Take the first example in the input:

2 2

-4 -7

According to the explanation, the best is to take empty subarrays twice and insert zero each time, resulting in a sum of -11, which modulo 10^9 + 7 is 999,999,996.

But why would I choose empty subarrays? The maximum sum subarray here is -4, and if I choose that and insert -4, the sum becomes -4 + (-7) + (-4) = -15. That's worse than choosing empty subarrays.

Similarly, if I choose the subarray [-7], sum is -7, and insert it, sum becomes -4 + (-7) + (-7) = -18, which is even worse.

So, in this case, choosing empty subarrays is better because their sum is zero, which doesn't decrease the sum.

Hence, in cases where all subarrays have negative sums, choosing empty subarrays is optimal.

Another example:

3 3

2 2 8

The maximum sum subarray is 2 + 2 + 8 = 12.

So, in the first operation, I can insert 12, making the array [2, 2, 8, 12], sum = 24.

In the second operation, I can insert 12 again (since it's still the maximum sum subarray), making the array [2, 2, 8, 12, 12], sum = 36.

In the third operation, insert 12 again, making the array [2, 2, 8, 12, 12, 12], sum = 48.

But according to the sample output, it's 96. Wait, maybe I'm missing something.

Wait, in the explanation, they have:

[2, 2, 8] -> [2, 2, 8, 12] -> [2, 2, 8, 12, 24] -> [2, 2, 8, 12, 24, 48], sum = 96.

How did they get 24 and 48?

Wait, perhaps in each operation, they are inserting the sum of the current array.

Wait, but the problem says to insert the sum of any contiguous subarray, not necessarily the entire array.

Wait, in the explanation, they seem to be inserting the sum of the entire array each time.

But the problem allows me to choose any contiguous subarray, compute its sum, and insert that sum anywhere.

So, in the first operation, I can choose the entire array [2,2,8] with sum 12 and insert it, making the array [2,2,8,12], sum=24.

In the second operation, I can choose the entire array again, which is now [2,2,8,12], sum=24, and insert 24, making the array [2,2,8,12,24], sum=48.

In the third operation, choose the entire array [2,2,8,12,24], sum=48, and insert 48, making the array [2,2,8,12,24,48], sum=96.

So, in each operation, they are choosing the entire array, which has the current sum, and inserting that sum into the array, effectively doubling the sum each time.

Wait, but is this always possible? In the first operation, the sum of the entire array is 12, and inserting 12 makes the sum 24.

In the second operation, the sum is now 24, and inserting 24 makes it 48.

In the third operation, insert 48 to make it 96.

So, it seems like in each operation, they are adding the current sum of the array to itself.

But according to my earlier understanding, in each operation, I select a subarray, compute its sum, and insert that sum into the array, which increases the total sum by that subarray's sum.

But in this case, they are choosing the entire array each time, so the sum increases by the current sum, effectively doubling it each time.

Wait, but is this always possible? Only if I can choose the entire current array as the subarray and insert its sum.

But the problem allows me to choose any contiguous subarray, including the entire array, so yes, this seems allowed.

Hence, in each operation, I can choose the entire array, compute its sum, and insert that sum into the array, thereby adding the current sum to the total sum.

So, starting with sum S, after the first operation, sum becomes S + S = 2S.

After the second operation, sum becomes 2S + 2S = 4S.

After the third operation, sum becomes 4S + 4S = 8S, and so on.

So, after K operations, the sum would be S * 2^K.

But wait, in the first sample input, n=2, k=2, a=[-4,-7], sum S = -11.

According to this, after 2 operations, sum should be -11 * 4 = -44.

But in the sample explanation, they have 999,999,996, which is -44 modulo 10^9 + 7.

So, it seems like my initial thought is correct in this case.

But in the second sample input, n=3, k=3, a=[2,2,8], sum S=12.

According to this, after 3 operations, sum should be 12 * 8 = 96, which matches the sample output.

Wait, but in the first sample, S=-11, -11*8=-88, but the sample output is 999,999,996, which is -11*4= -44, but -44 modulo 10^9 + 7 is indeed 999,999,996, because -44 + 10^9 +7 = 999,999,996.

Wait, but according to my earlier calculation, after 2 operations, it should be S * 2^2 = S * 4 = -44.

But in the explanation, they have operations where they insert 0 twice, resulting in sum -11.

So, there's a discrepancy here.

Wait, perhaps I misread the operations in the explanation.

Looking back, in the first test case, it says:

"take an empty subarray of the array twice and insert the sum of the empty subarray (zero) anywhere, then the sum of the resulting array will be (-4) + (-7) + 0 + 0 = -11 , modulo 10^9 + 7 this is 999,999,996."

So, they are choosing the empty subarray twice, inserting 0 each time, resulting in sum -11.

But according to my earlier logic, choosing the entire array would result in sum -44.

But -44 modulo 10^9 +7 is 999,999,996, which is the same as -11 modulo 10^9 +7 because -44 + 3*10^9 +21 = -44 + 3000000021 = 2999999977, which is not matching.

Wait, no, to compute -44 modulo 10^9 +7, I need to add 10^9 +7 to -44 to make it positive, then take modulo.

So, -44 + 10^9 +7 = 999,999,996 + 10^9 = 1,999,999,996, then modulo 10^9 +7 is 999,999,996.

Wait, but in the explanation, they choose to insert 0 twice, resulting in sum -11, which is also 999,999,996 modulo 10^9 +7.

So, why is choosing the entire array and inserting its sum not better?

Because inserting the sum of the entire array would make the sum -44, which is worse than -11.

Hence, in cases where the original sum is negative, it's better to choose empty subarrays and insert zero to avoid decreasing the sum further.

Therefore, my earlier assumption that choosing the entire array and inserting its sum each time is always optimal is incorrect.

It's only optimal when the sum is positive.

If the sum is negative, choosing empty subarrays and inserting zero is better.

Wait, but even if the sum is negative, choosing a positive subarray and inserting it could potentially increase the sum.

Wait, but in the first sample, all subarrays have negative sums, so choosing any non-empty subarray would only decrease the sum further.

Hence, choosing empty subarrays with sum zero is the best option.

So, in general, to maximize the sum after K operations, I should:

- Compute the maximum sum of any contiguous subarray in the original array.

- If this maximum sum is positive, then in each operation, I can choose the entire array (which has the current sum) and insert its sum, effectively doubling the sum each time.

- If the maximum sum is negative or zero, then choosing empty subarrays and inserting zero is better, as inserting any non-empty subarray would only decrease the sum.

Wait, but in the second sample, the maximum sum subarray is 12, which is positive, so choosing to insert the entire array's sum each time is optimal.

In the first sample, the maximum sum subarray is -4, which is negative, so choosing empty subarrays is better.

Hence, the strategy should be:

- Find the maximum sum of any contiguous subarray in the original array.

- If this maximum sum is positive, then in each operation, choose the entire array and insert its sum, effectively multiplying the sum by 2 in each operation.

- If the maximum sum is non-positive, then choose empty subarrays and insert zero in each operation, so the sum remains the original sum.

Wait, but in the second sample, after the first operation, the sum becomes 24, then 48, then 96.

But if I choose to insert the maximum sum subarray (which is 12) each time, wouldn't that also lead to the same result?

Wait, but inserting the entire array's sum is equivalent to inserting the current sum, which changes in each operation.

Wait, perhaps I need to think recursively.

Let me formalize this.

Let S be the initial sum of the array.

Let M be the maximum sum of any contiguous subarray in the array.

If M > 0, then in each operation, I can choose the entire array and insert its sum, which is S, thereby adding S to the sum each time.

Wait, but in the second sample, they seem to be doubling the sum each time, which suggests that inserting the current sum S doubles the total sum.

Wait, let's see:

- Initial sum S = 12.

- After first operation: insert S=12, sum becomes 12 + 12 = 24.

- After second operation: insert current S=24, sum becomes 24 + 24 = 48.

- After third operation: insert current S=48, sum becomes 48 + 48 = 96.

So, it's effectively S * 2^K.

But is this always achievable?

Wait, but in the first operation, I can only insert the sum of any subarray of the original array, not the current sum.

Wait, no, in each operation, I can choose any subarray of the current array and insert its sum.

So, in the first operation, I can choose the entire current array, which is [2,2,8], sum=12, insert 12, making the array [2,2,8,12], sum=24.

In the second operation, the current array is [2,2,8,12], so I can choose the entire current array, sum=24, insert 24, making the array [2,2,8,12,24], sum=48.

In the third operation, current array is [2,2,8,12,24], sum=48, insert 48, making the array [2,2,8,12,24,48], sum=96.

So, yes, in each operation, I can choose the entire current array and insert its sum, effectively doubling the sum each time.

Hence, if the initial sum S is positive, the optimal strategy is to perform this operation K times, resulting in S * 2^K.

If S is non-positive, then it's better to choose empty subarrays and insert zero in each operation, so the sum remains S.

Wait, but in the first sample, S=-11, which is negative, so choosing empty subarrays and inserting zero is better, resulting in sum=-11.

If I had chosen to insert the entire array's sum each time, the sum would be -11 * 2^2 = -44, which is worse than -11.

Hence, the strategy should be:

- If the initial sum S > 0, then the maximum sum after K operations is S * 2^K.

- If S <= 0, then the maximum sum is S (by choosing empty subarrays and inserting zero in each operation).

But wait, in the second sample, S=12 >0, so maximum sum is 12 * 2^3 = 96, which matches the sample output.

In the first sample, S=-11 <0, so maximum sum is -11, which matches the sample output.

Another sample input:

5 1

4 -2 8 -12 9

Sum S=4 + (-2) + 8 + (-12) + 9 = 7.

Maximum sum subarray is, let's see: 4 + (-2) + 8 + (-12) +9 =7, but perhaps there's a better subarray.

Subarrays:

4

4 + (-2)=2

4 + (-2) +8=10

4 + (-2)+8+(-12)=-2

4 + (-2)+8+(-12)+9=7

-2

-2 +8=6

-2 +8+(-12)=-6

-2 +8+(-12)+9=7

8

8 + (-12)=-4

8 + (-12)+9=7

-12

-12 +9=-3

9

So, the maximum sum subarray is [4,-2,8] with sum 10.

Hence, in the first operation, I can choose this subarray with sum 10 and insert it into the array.

Where I insert it affects the sum, but since I'm only interested in the sum, it doesn't matter where I insert it, as long as I'm adding 10 to the sum.

So, initial sum S=7.

After one operation, sum becomes 7 + 10 =17.

Hence, the maximum sum after one operation is 17.

But according to my earlier strategy, if S >0, then S * 2^K =7 * 2^1=14, which is less than 17.

So, in this case, my earlier strategy is not giving the correct answer.

Hence, my earlier assumption is incorrect.

Wait, perhaps I need to reconsider.

In this case, K=1.

So, according to my earlier strategy, if S >0, then S * 2^K =14.

But by choosing the maximum sum subarray and inserting it, I can get 17, which is better than 14.

Hence, my earlier strategy is flawed.

So, what's the correct approach?

Let me think differently.

In each operation, I can choose any contiguous subarray (including empty) and insert its sum into the array.

I need to maximize the sum after K operations.

I need to choose which subarrays to select and where to insert their sums in each operation to maximize the total sum.

This seems dynamic programming-related, but given the constraints (n and k up to 2e5), a standard DP approach might be too slow.

Wait, perhaps I can find a mathematical formula for the maximum sum after K operations.

Let me consider that in each operation, I can choose any contiguous subarray and insert its sum into the array.

The sum of the array increases by the sum of the chosen subarray.

So, to maximize the sum after K operations, I need to maximize the sum added in each operation.

The best I can do in each operation is to choose the subarray with the maximum sum and insert it.

Hence, if I can find the maximum sum of any contiguous subarray in the original array, say M, then in each operation, I can choose that subarray and insert its sum M, thereby adding M to the total sum each time.

Hence, the total sum after K operations would be S + K*M.

But in the second sample, S=12, M=12, K=3, so S + K*M =12 +3*12=48, but the sample output is 96.

So, this approach is incorrect.

Wait, but in the second sample, by choosing the entire array each time and inserting its sum, the sum doubles each time: 12 -> 24 -> 48 -> 96.

So, it's not just adding M each time, but adding the current sum each time.

Hence, it's more like S * 2^K.

But in the earlier example with n=5, k=1, a=[4,-2,8,-12,9], S=7, M=10.

If I add M once, sum becomes 17, which is better than S * 2^K =14.

So, in this case, adding M is better than doubling S.

Hence, my previous strategies are incomplete.

I need a better way to model this.

Let me consider that in each operation, I can add any sum of a contiguous subarray to the current sum.

Hence, the sum after K operations can be S + sum1 + sum2 + ... + sumK, where each sum_i is the sum of some contiguous subarray in the (i-1)-th version of the array.

This seems complicated because the choices in earlier operations affect the choices in later operations.

Is there a way to simplify this?

Wait, perhaps I can consider that in each operation, I can add any multiple of the maximum subarray sum, but it's not straightforward.

Looking back at the second sample, starting with S=12, after first operation, sum becomes 24.

After second operation, sum becomes 48.

After third operation, sum becomes 96.

So, it seems like in each operation, they are adding the current sum, effectively doubling it.

But how is that possible?

In each operation, I can choose any contiguous subarray of the current array and insert its sum.

So, if I choose the entire current array, its sum is S, and insert it, the new sum becomes S + S =2S.

Then, in the next operation, the current sum is 2S, choose the entire array and insert 2S, making the sum 2S + 2S =4S.

And so on, up to S * 2^K.

But in the earlier example with n=5, k=1, a=[4,-2,8,-12,9], S=7.

In this case, the maximum sum subarray is [4,-2,8] with sum 10.

If I choose to insert 10, sum becomes 17.

But according to the doubling strategy, S * 2^K =7*2=14, which is less than 17.

Hence, the doubling strategy is not always optimal.

Hence, there must be a better way to approach this.

Wait, perhaps I can think in terms of the maximum sum subarray and how many times I can add it.

But it's not clear.

Let me consider that in each operation, I can add any sum of a contiguous subarray, and the sum of the array increases by that amount.

Hence, to maximize the sum after K operations, I need to maximize the total addition, which would involve choosing the maximum possible sum in each operation.

But the problem is that the choices in earlier operations affect the choices in later operations.

Hence, it's interdependent.

This seems tricky.

Let me consider a different approach.

Suppose I fix the subarrays that I choose in each operation.

Then, the sum after K operations would be S + sum of the chosen subarrays.

But I need to maximize this sum.

Hence, I need to choose K subarrays (with possible overlaps) to add their sums to the total sum.

But this seems too vague.

Wait, perhaps I can model this as adding the sum of the array K times, but that doesn't seem right.

Wait, perhaps I can think recursively.

Let me define F(K) as the maximum sum after K operations.

Then, F(K) = S + maximum sum of any contiguous subarray of the array after (K-1) operations.

But this seems circular.

Wait, more precisely, in the K-th operation, I can choose any contiguous subarray of the array after (K-1) operations and insert its sum.

Hence, to maximize F(K), I need to choose the subarray with the maximum sum in the array after (K-1) operations and insert it.

But this is still recursive and not helpful for direct computation.

Perhaps I need to find a pattern or a mathematical formula.

Looking back at the second sample, S=12, F(1)=24, F(2)=48, F(3)=96.

Similarly, in the first sample, S=-11, but choosing to insert 0 in each operation results in F(2)=-11.

Another sample input:

1 7

7

Sum S=7.

If I choose the entire array with sum 7 and insert it each time, then:

F(1)=7 +7=14

F(2)=14 +14=28

F(3)=28 +28=56

...

F(7)=7 * 2^7 =7*128=896.

Hence, in this case, F(K)=S * 2^K.

But in the earlier example with n=5, k=1, a=[4,-2,8,-12,9], S=7, M=10.

If I choose to insert M=10, F(1)=7 +10=17, which is better than S * 2^K=14.

But according to the doubling strategy, F(K)=S * 2^K.

Hence, perhaps the doubling strategy is optimal when S >0, but sometimes choosing to add M > S can be better.

Wait, in the doubling strategy, F(K)=S * 2^K.

But in the example above, S=7, K=1, F(1)=14, but by choosing to add M=10, F(1)=17 >14.

Hence, the doubling strategy is not always optimal.

Hence, perhaps the optimal strategy is:

- If M <= S, then use the doubling strategy, F(K)=S * 2^K.

- If M > S, then use the doubling strategy for (K-1) operations and add M in the last operation.

Wait, but that doesn't seem consistent.

Wait, perhaps I need to consider adding M in each operation after the first one.

But it's getting too convoluted.

Let me consider that in each operation, I can add M to the sum.

Hence, F(K)=S + K*M.

But in the second sample, S=12, M=12, K=3, F(3)=12 +3*12=48, but the sample output is 96.

Hence, this is incorrect.

Wait, but in the second sample, by choosing to add the current sum each time, we get F(K)=S * 2^K=96.

Which is better than F(K)=S + K*M=48.

Hence, perhaps choosing to add the current sum each time is better when M == S.

But in the earlier example, M > S, so adding M each time is better.

Wait, but in the second sample, M=S=12, so adding M each time gives F(K)=S + K*M =12 +3*12=48, which is less than doubling strategy F(K)=S * 2^K=96.

Hence, when M == S, doubling strategy is better.

When M > S, adding M each time is better.

Wait, but in the earlier example, M=10 > S=7, and adding M once gives 17, which is better than doubling strategy's 14.

But in the second sample, M=S=12, and doubling strategy gives better result than adding M each time.

Hence, perhaps the rule is:

- If M > S, then F(K)=S + K*M.

- Else, F(K)=S * 2^K.

But in the earlier example, M=10 > S=7, F(K)=7 +1*10=17, which is better than 7*2=14.

In the second sample, M=S=12, F(K)=12*2^3=96 > 12 +3*12=48.

Hence, perhaps the rule is:

- If M > S, then F(K)=S + K*M.

- Else, F(K)=S * 2^K.

But in the first sample, S=-11, M=-4, M > S is true (-4 > -11), but choosing to add M=-4 would make the sum worse.

Hence, in that case, choosing to add zero is better.

Hence, perhaps the rule should be:

- If M >0, then F(K)=S * 2^K.

- Else, F(K)=S + K*M.

But in the earlier example, M=10 >0, so F(K)=7*2^K=28 for K=2, but adding M each time gives 7 +2*10=27, which is less than 28.

Wait, but in the sample with K=3, 7*8=56 vs 7 +3*10=37, still 56 >37.

Hence, perhaps when M >0, doubling strategy is better.

Wait, but in the earlier example with n=5, k=1, a=[4,-2,8,-12,9], S=7, M=10.

According to doubling strategy, F(1)=14, but by adding M=10, F(1)=17 >14.

Hence, in this case, adding M is better than doubling.

Hence, perhaps the rule is:

- If M > S, then F(K)=S + K*M.

- Else, F(K)=S * 2^K.

But in the second sample, M=S=12, so M <= S, hence F(K)=12*8=96, which matches the sample output.

In the earlier example, M=10 > S=7, hence F(K)=7 +1*10=17, which is better than 7*2=14.

In the first sample, M=-4 > S=-11, so F(K)=-11 +2*(-4)=-19, which is worse than choosing to add zero, i.e., F(K)=-11.

Hence, perhaps the rule should be:

- If M >0, then F(K)=S + K*M.

- Else, F(K)=S.

But in the second sample, M=12 >0, so F(K)=12 +3*12=48, but the sample output is 96.

Hence, this is incorrect.

Wait, perhaps I need to consider that when M > S, adding M each time is better, but in the second sample, M=S=12, so M == S, so doubling strategy is better.

Hence, perhaps the rule is:

- If M > S, then F(K)=S + K*M.

- Else if M == S, then F(K)=S * 2^K.

- Else, F(K)=S.

But in the earlier example, M=10 > S=7, so F(K)=7 +1*10=17.

But according to the doubling strategy, F(K)=7*2=14, which is less.

Hence, in this case, adding M is better.

But in another sample, n=7, k=4, a=[8,14,-9,6,0,-1,3], sum S=21.

Maximum sum subarray is 8+14+(-9)+6+0+(-1)+3=21.

Hence, M=21 == S.

Hence, F(K)=21 * 2^4=21*16=336.

But according to the sample output, it's 351.

Hence, my rule is still incorrect.

Wait, perhaps I need to compute M, the maximum sum subarray.

Then, if M >0, then F(K)=S + K*M.

Else, F(K)=S.

But in this sample, M=21 >0, so F(K)=21 +4*21=105, but sample output is 351.

Hence, this is incorrect.

Wait, perhaps I need to consider that in each operation, I can add the current sum, not just M.

Wait, but in the second sample, by adding the current sum each time, F(K)=S * 2^K=12*8=96, which matches the sample.

In this sample, S=21, F(K)=21*16=336, but sample output is 351.

Hence, perhaps there's a mistake in assuming that F(K)=S * 2^K is always achievable.

Wait, perhaps in some cases, I can do better by choosing different subarrays in different operations.

In the sample with n=7, k=4, a=[8,14,-9,6,0,-1,3], S=21.

M=21.

But according to the sample output, F(K)=351, which is greater than 21*16=336.

Hence, there must be a better strategy than just doubling the sum each time.

Hence, perhaps I need to choose different subarrays in different operations to maximize the sum.

This seems complex.

Let me think differently.

Suppose I perform K operations, and in each operation, I choose a subarray and insert its sum.

Each insertion adds the sum of the chosen subarray to the total sum.

Hence, the total sum after K operations is S + sum of K chosen subarrays.

To maximize this sum, I need to maximize the sum of the K chosen subarrays.

Now, the sum of K chosen subarrays can overlap, but I need to choose them optimally.

This seems similar to choosing K non-empty contiguous subarrays with maximum total sum.

But this is a known problem: selecting K non-overlapping subarrays with maximum total sum.

Wait, but in this problem, the subarrays can overlap because the operations are performed sequentially, and the array changes after each insertion.

Wait, no, in each operation, I choose a subarray from the current array and insert its sum into the array.

Hence, the array changes after each insertion, affecting the choices for the next operations.

This seems too involved for manual computation.

Perhaps I need to find a mathematical formula that can compute the maximum sum after K operations based on S and M.

Looking back at the samples:

First sample: S=-11, M=-4, K=2.

Optimal F(K)=-11.

Second sample: S=12, M=12, K=3.

F(K)=12*8=96.

Third sample: S=7, M=10, K=1.

F(K)=7 +10=17.

Fourth sample: S=21, M=21, K=4.

F(K)=21*16=336, but sample output is 351.

Wait, perhaps I miscalculated M.

Let me recalculate M for the fourth sample.

a=[8,14,-9,6,0,-1,3]

Possible subarrays:

8

8+14=22

22-9=13

13+6=19

19+0=19

19-1=18

18+3=21

Hence, the maximum sum subarray is [8,14]=-1, which is incorrect.

Wait, 8 +14=22, 22-9=13, 13+6=19, 19+0=19, 19-1=18, 18+3=21.

Wait, the maximum is 22.

Wait, 8+14=22, 22-9=13, 13+6=19, etc.

Hence, the maximum sum subarray is [8,14] with sum 22.

Hence, M=22.

Hence, F(K)=S + K*M=21 +4*22=109, but sample output is 351.

Hence, this is not matching.

Hence, my assumption is incorrect.

Hence, perhaps the rule is:

- F(K)=S + K*M + combinations of previous sums.

But this is getting too complicated.

Let me look for a different approach.

Perhaps I can consider that in each operation, I can choose to add any sum that is a multiple of M, but that doesn't seem right.

Wait, perhaps dynamic programming can be used here, but with the constraints (n and k up to 2e5), a standard DP approach would be too slow.

Hence, there must be a smarter way to compute F(K).

Let me consider that in each operation, I can choose to add M, and by doing so, I can achieve F(K)=S + K*M.

But in the second sample, F(K)=S * 2^K=96 > S + K*M=48.

Hence, there must be a way to achieve higher sums by choosing to add the current sum each time.

Hence, perhaps the optimal strategy is:

- If M >0, then F(K)=S * (K+1).

Wait, in the second sample, S=12, K=3, F(K)=12*4=48, but sample output is 96.

Hence, incorrect.

Wait, perhaps F(K)=S * 2^K.

In the second sample, S=12, K=3, F(K)=12*8=96, which matches.

In the earlier example with S=7, K=1, F(K)=7*2=14, but by choosing to add M=10, we can get 17 >14.

Hence, this strategy is not always optimal.

Wait, perhaps the rule is:

- If M > S, then F(K)=S + K*M.

- Else, F(K)=S * 2^K.

But in the second sample, M=12 == S=12, so F(K)=12*8=96.

In the earlier example, M=10 > S=7, so F(K)=7 +1*10=17.

But in another sample with S=21, M=22 > S, F(K)=21 +4