Alright, I have this problem to solve. Let's see what it's asking for. There are n children in a class, and m pairs among them are friends with a friendship value f_i. The teacher goes on k excursions, and for each excursion, she randomly chooses a pair of children equiprobably and independently. If the pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0 that doesn't change.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, and this sum should be calculated at the time of being chosen. Also, it's given that this expected value can be expressed as a fraction p/q where p and q are coprime, and I need to compute p * q^{-1} mod (10^9 + 7).

First, I need to understand the process:

1. There are n children, and m pairs of friends with given friendship values.

2. For each excursion, a pair of children is chosen randomly and uniformly from all possible pairs (order doesn't matter, so it's combinations, not permutations).

3. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

4. The friendship value of non-friend pairs is always 0 and doesn't change.

5. I need the expected sum of the friendship values at the time each pair is chosen.

Let me think about how to approach this.

First, I need to consider that pairs are chosen independently and randomly each time, but the friendship values can increase over time if friends are chosen.

Wait, but the problem says that the choice is equiprobable and independent, but the friendship value can increase if friends are chosen, which affects future choices.

But actually, the problem states that the friendship value increases for subsequent excursions if a friend pair is chosen. So, the friendship value at the time of choice depends on how many times that particular friend pair has been chosen in the past excursions.

But computing the expected sum over k excursions seems tricky because of the dependency introduced by the increasing friendship values.

Wait, but the problem says to consider the friendship value at the time of being chosen, meaning for each excursion, whatever the current friendship value of the chosen pair is, add that to the sum.

Given that the friendship values can increase over time, this seems like it could get complicated.

Let me see if there's a smarter way to compute the expected sum without getting bogged down by the dependencies.

Perhaps I can think in terms of linearity of expectation.

Linearity of expectation allows me to compute the expected value of a sum as the sum of the expected values, even if the variables are dependent.

So, perhaps I can think of the total sum S as the sum over all k excursions of the friendship value at the time of choice, and then compute E[S] as the sum over k of E[value chosen at excursion i].

But I need to be careful because the value chosen at each excursion can depend on previous choices.

However, linearity of expectation still holds even if the variables are dependent, so E[S] = sum_{i=1 to k} E[value chosen at excursion i].

Now, I need to compute E[value chosen at excursion i] for each i from 1 to k.

But since the choices are independent and equiprobable, maybe I can find a general expression for E[value chosen at any excursion], assuming that the choices are independent.

Wait, but the friendship values increase over time if friends are chosen, so the expected value at each excursion isn't the same.

Wait, but the choices are independent and equiprobable, meaning that each pair is chosen with equal probability each time, regardless of past choices.

But the friendship values can increase based on how many times that specific friend pair has been chosen in the past.

This seems complicated because it's a random process with dependencies.

Maybe there's a better way to model this.

Let me consider that the friendship value of a friend pair increases by 1 each time it's chosen.

So, if a friend pair has been chosen t times up to the current excursion, its friendship value is f + t, where f is the initial friendship value.

But since the choices are independent, the number of times a specific pair has been chosen in previous excursions follows a binomial distribution.

Wait, but if the choices are independent and with replacement, then yes, the number of times a specific pair is chosen follows a binomial distribution.

But considering that there are m friend pairs, and each has its own binomial process, and non-friend pairs always have value 0.

So, perhaps I can think about the expected contribution of each friend pair to the total sum S.

Let me try to think in terms of the contribution of each friend pair over all k excursions.

For a specific friend pair (a, b) with initial friendship value f, let's compute its expected contribution to the total sum S.

The pair (a, b) can be chosen in some of the k excursions, and each time it's chosen, its friendship value at that time is f plus the number of times it has been chosen before.

Wait, more precisely, if the pair (a, b) is chosen t times during the k excursions, and letâ€™s denote by t_i the number of times it has been chosen in the first i excursions, then each time it's chosen, its friendship value is f plus t_i.

Wait, that might be too involved.

Perhaps a better approach is to consider that for each friend pair, the expected number of times it's chosen in k excursions is k times the probability of choosing that pair in one excursion.

Since there are C(n,2) possible pairs, the probability of choosing a specific pair is 1 / C(n,2).

So, the expected number of times a specific friend pair is chosen is k / C(n,2).

Each time it's chosen, its friendship value increases by 1 for subsequent choices.

Wait, but the problem says that when a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

But actually, reading again, "if a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions".

So, it's not that the friendship value increases by 1 each time it's chosen, but rather, it increases by 1 after it's chosen, affecting future excursions.

Wait, no, the problem says: "If a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions".

So, it's a one-time increase after being chosen.

So, for each time a friend pair is chosen, its friendship value increases by 1 for all subsequent excursions.

But the friendship value at the time of being chosen is still f, because the increase happens after being chosen.

Wait, perhaps I need to clarify this.

Let me think about an example.

Suppose n=2, m=1, k=3, and the friend pair is (1,2) with f=1.

In the first excursion, if (1,2) is chosen, its friendship value is 1, and then it increases by 1 for the next excursions, so in the second excursion, if chosen, its friendship value is 2, and so on.

So, the friendship value at the time of choice is f plus the number of times it has been chosen before.

This seems like an accumulating value.

This is getting complicated.

Maybe there's a better mathematical formulation.

Let me consider that for each friend pair, the expected sum of its contribution over all excursions is equal to the sum over all excursions of the expected friendship value at that excursion.

So, for a specific friend pair, E[sum of its friendship value over all excursions it's chosen].

But this seems messy.

Perhaps I can model this with indicator variables.

Let me try to define some variables.

Let C_ij be the indicator variable that equals 1 if the friend pair is chosen in excursion j, and 0 otherwise.

Then, the total number of times the friend pair is chosen is sum_{j=1 to k} C_ij.

And the friendship value at the time of choice in excursion j is f + sum_{l=1 to j-1} C_ij.

Wait, more precisely, at the time of choice in excursion j, the friendship value is f plus the number of times it has been chosen before excursion j.

So, it's f + sum_{l=1 to j-1} C_ij.

Therefore, the total sum S is sum_{j=1 to k} (f + sum_{l=1 to j-1} C_ij) * C_ij.

This seems complicated to compute directly.

Maybe there's a smarter way.

Wait, perhaps I can think about the expected increase in friendship value due to each choice.

Initially, each friend pair has value f.

Each time it's chosen, its value increases by 1 for future choices.

So, the first time it's chosen, its value is f, and then it increases by 1.

The second time it's chosen, its value is f + 1, and then increases by another 1, and so on.

Wait, but the problem says that the friendship value increases by 1 for all subsequent excursions.

So, the increase happens after the choice.

Therefore, at the time of choice, the friendship value is f plus the number of times it has been chosen before.

So, if a friend pair is chosen t times in k excursions, the sum of its contributions is sum_{i=1 to t} (f + (i-1)).

This is equal to t*f + sum_{i=0 to t-1} i = t*f + t*(t-1)/2.

But this seems too involved to compute directly.

Perhaps there's a better way.

Let me consider that the expected sum S is equal to the sum over all friend pairs of their expected contribution.

So, E[S] = sum over all friend pairs of E[their contribution].

Now, for each friend pair, their contribution is sum over all excursions where they are chosen of (f + number of times chosen before).

This seems complicated, but maybe I can find a formula for E[their contribution].

Alternatively, perhaps I can model this using the linearity of expectation by considering the contribution of each friend pair separately.

Let me consider one friend pair with initial friendship value f.

Let p be the probability of choosing this pair in any given excursion, which is 1 / C(n,2).

Over k independent excursions, the number of times this pair is chosen follows a binomial distribution with parameters k and p.

Letâ€™s denote by X the number of times this pair is chosen in k excursions.

Then, X ~ Binomial(k, p).

Now, the sum of the friendship values at the times chosen is sum_{i=1 to X} (f + (i-1)), because each time it's chosen, its friendship value is f plus the number of times it has been chosen before.

So, the sum is X*f + sum_{i=1 to X} (i-1) = X*f + sum_{i=0 to X-1} i = X*f + (X*(X-1))/2.

Therefore, the expected contribution of this friend pair is E[X*f + (X*(X-1))/2] = f*E[X] + (E[X^2] - E[X])/2.

Now, for a binomial random variable X ~ Binomial(k, p), E[X] = k*p and E[X^2] = k*p*(1-p) + (k*p)^2.

Wait, more precisely, for binomial distribution, E[X] = k*p and Var(X) = k*p*(1-p), and E[X^2] = Var(X) + (E[X])^2 = k*p*(1-p) + (k*p)^2.

So, plugging in, the expected contribution is:

f*k*p + (k*p*(1-p) + (k*p)^2 - k*p)/2 = f*k*p + (k*p*(1-p) + k^2*p^2 - k*p)/2 = f*k*p + (k^2*p^2 - k*p*(1-p))/2.

But this seems messy, and I have to do this for all friend pairs.

Wait, maybe there's a better way.

Alternatively, perhaps I can think about the total expected sum S as the sum over all excursions of the expected friendship value at the time of choice.

So, S = sum_{j=1 to k} E[value chosen at excursion j].

Since each excursion is independent, and the choice is equiprobable, perhaps I can find a general expression for E[value chosen at any excursion].

But actually, the choices are independent, but the friendship values can increase based on previous choices, so the expected value at each excursion isn't the same.

Wait, but the problem says that the choices are independent and equiprobable.

Wait, but the friendship values can increase based on previous choices, so the expected value at each excursion depends on the history of choices.

This seems complicated to handle directly.

Maybe I need to think about the process differently.

Let me consider that at each excursion, the expected friendship value of the chosen pair is the average of the friendship values of all possible pairs at that moment.

But since the friendship values can change based on previous choices, this seems difficult to track.

Alternatively, perhaps I can model this as a Markov process, where the state is the current friendship values of all friend pairs, and the transitions depend on which pair is chosen.

But with n up to 1e5 and m up to 1e5, this is computationally infeasible.

I need a smarter approach.

Let me try to think about the overall sum S.

S is the sum over k excursions of the friendship value at the time of choice.

I need E[S], the expected value of S.

Using linearity of expectation, E[S] = sum_{j=1 to k} E[value chosen at excursion j].

Now, for each excursion, the pair is chosen equiprobably from all possible pairs.

There are C(n,2) possible pairs.

Among these, m are friend pairs with initial friendship values f_i, and the rest are non-friend pairs with friendship value 0.

But the friendship values of friend pairs can increase over time.

So, for a given excursion, the expected value is the sum over all possible pairs of the probability of choosing that pair times its friendship value at that excursion.

This seems too involved to compute directly.

Wait, perhaps I can consider that for each friend pair, its contribution to the expected sum S is equal to its probability of being chosen in an excursion times its expected friendship value at the time of choice, summed over all excursions.

But again, this seems similar to what I had before.

Alternatively, perhaps I can think about the problem in terms of the order of choices.

But that seems too complicated.

Let me try to think about small examples to see if I can find a pattern.

Take the second example from the input:

n=2, m=1, k=10

friendship: 1-2 with f=1

So, there's only one friend pair, and C(2,2)=1 possible pair.

So, in each excursion, the same pair is chosen every time, and their friendship value increases by 1 each time.

So, the friendship values at each excursion are:

Excursion 1: 1

Excursion 2: 2

Excursion 3: 3

...

Excursion 10: 11

Total sum: 1+2+3+...+11 = 66

But in the sample input, the output is 55.

Wait, but according to the note, it's 1+2+...+10=55.

Wait, perhaps I miscounted.

If k=10, and the friendship value increases by 1 after each choice, then:

Excursion 1: value=1

After choosing, friendship value increases to 2

Excursion 2: value=2

After choosing, increases to 3

...

Excursion 10: value=10

Total sum: 1+2+...+10=55

Yes, that makes sense.

So, in this case, E[S] = 55.

Similarly, in the first test case, n=100, m=0, k=24

No friend pairs, so all pairs have friendship value 0, so sum is 0.

In the third test case, n=3, m=1, k=2

friendship: 2-1 with f=1

C(3,2)=3 possible pairs: 1-2, 1-3, 2-3

Only 1-2 is a friend pair with f=1

Probability of choosing the friend pair in any excursion is 1/3

Each time the friend pair is chosen, its friendship value increases by 1 for subsequent excursions.

So, for k=2 excursions, there are several scenarios:

1. Choose the friend pair both times:

Probability: (1/3)*(1/3) = 1/9

Sum: first choice: 1, second choice: 2 (since it increased by 1 after the first choice)

Total: 1+2=3

2. Choose the friend pair once:

- First excursion: friend pair, second: non-friend

Probability: (1/3)*(2/3) = 2/9

Sum: 1 (first choice) + 0 (second choice) = 1

- First excursion: non-friend, second: friend pair

Probability: (2/3)*(1/3) = 2/9

Sum: 0 + 1 = 1

3. Choose no friend pairs in both excursions:

Probability: (2/3)*(2/3) = 4/9

Sum: 0 + 0 = 0

Now, expected sum S = sum over all scenarios of (sum in scenario) * (probability of scenario)

= (3)*(1/9) + (1)*(2/9) + (1)*(2/9) + (0)*(4/9) = 3/9 + 2/9 + 2/9 + 0 = 7/9

According to the sample output, 777777784, which is 7/9 modulo 10^9+7.

So, that matches.

So, in this small case, I can compute E[S] directly.

But for larger cases, I need a general formula.

Looking back, in the second test case, n=2, m=1, k=10

Only one friend pair, chosen every time, with friendship value increasing from 1 to 10, sum=55.

In the third test case, n=3, m=1, k=2

Probability 1/9 of sum=3, 4/9 of sum=1, 4/9 of sum=0, expected sum=7/9.

So, I need a general way to compute E[S] for any n, m, k, and friendship values.

Going back to my earlier approach:

E[S] = sum over all friend pairs of E[their contribution]

For each friend pair, their contribution is sum over all excursions where they are chosen of (f + number of times chosen before)

Which is X*f + (X*(X-1))/2, where X is the number of times chosen.

So, E[their contribution] = f*E[X] + (E[X^2] - E[X])/2

Where X ~ Binomial(k, p), p = 1/C(n,2)

So, E[X] = k*p

E[X^2] = Var(X) + (E[X])^2 = k*p*(1-p) + (k*p)^2

Therefore, E[their contribution] = f*k*p + (k*p*(1-p) + (k*p)^2 - k*p)/2 = f*k*p + (k*p)^2/2 - k*p/2

Simplify: f*k*p + (k^2 * p^2)/2 - (k*p)/2

Now, sum over all friend pairs.

But there are m friend pairs, each with their own f.

So, total E[S] = sum over all friend pairs of [f*k*p + (k^2 * p^2)/2 - (k*p)/2]

But p = 1/C(n,2), and C(n,2) = n(n-1)/2

So, p = 2/(n(n-1))

Therefore, E[S] = sum over all friend pairs of [f*k*(2/(n(n-1))) + (k^2 * (2/(n(n-1)))^2)/2 - (k*(2/(n(n-1))))/2]

This seems messy, but perhaps it can be simplified.

Let me denote C = C(n,2) = n(n-1)/2

Then, p = 1/C

So, E[S] = sum over all friend pairs of [f*k/C + (k^2)/(2*C^2) - k/(2*C)]

But this is still complicated.

Alternatively, perhaps I can think about the expected sum S as k times the expected value of a single excursion, since excursions are independent.

But in each excursion, the expected value is the average of the current friendship values of all possible pairs.

However, the friendship values can increase over time, so this might not be directly applicable.

Wait, perhaps I can think about the expected increase in friendship values over excursions.

But I'm not sure.

Looking back, in the small example with n=3, m=1, k=2, E[S]=7/9, which matches the sample output.

So, perhaps I can compute E[S] as sum over all friend pairs of [f*P(chosen in an excursion) * k + some term accounting for the increases].

But I need to find a general formula.

Alternatively, perhaps I can model this as follows:

For each friend pair, the expected number of times it's chosen in k excursions is k*p, where p=2/(n(n-1))

Each time it's chosen, its friendship value increases by 1 for subsequent choices.

So, the first time it's chosen, its value is f, the second time it's f+1, and so on.

So, if it's chosen t times, the sum of its contributions is sum_{i=0 to t-1} (f + i) = t*f + t*(t-1)/2

Therefore, E[sum] = E[t*f + t*(t-1)/2] = f*E[t] + E[t*(t-1)/2]

Since t ~ Binomial(k, p), E[t] = k*p, E[t*(t-1)] = k*(k-1)*p^2 + k*p*(1-p)

Wait, more precisely, for binomial distribution, E[t*(t-1)] = Var(t)*k*p + (E[t])^2 = k*(k-1)*p^2 + k*p

But actually, Var(t) = k*p*(1-p), and E[t*(t-1)] = E[t^2] - E[t] = Var(t) + (E[t])^2 - E[t] = k*p*(1-p) + k^2*p^2 - k*p = k*(k-1)*p^2

So, E[t*(t-1)] = k*(k-1)*p^2

Therefore, E[t*(t-1)/2] = (k*(k-1)*p^2)/2

So, E[sum] = f*k*p + (k*(k-1)*p^2)/2

Therefore, for each friend pair, its expected contribution is f*k*p + (k*(k-1)*p^2)/2

Then, the total E[S] is sum over all friend pairs of [f*k*p + (k*(k-1)*p^2)/2]

Given that p = 2/(n*(n-1)), we can plug this in.

So, E[S] = sum over all friend pairs of [f*k*(2/(n*(n-1))) + (k*(k-1)*(2/(n*(n-1)))^2)/2]

Simplify the second term: (k*(k-1)*(4)/(n^2*(n-1)^2))/2 = (k*(k-1)*4)/(2*n^2*(n-1)^2) = (k*(k-1)*2)/(n^2*(n-1)^2)

So, E[S] = sum over all friend pairs of [2*f*k/(n*(n-1)) + 2*k*(k-1)/(n^2*(n-1)^2)]

But this still seems messy.

Wait, but in the sample input 3, n=3, m=1, k=2, f=1

So, E[S] = [2*1*2/(3*2) + 2*2*1/(9*4)] = [4/6 + 4/36] = [2/3 + 1/9] = (6/9 + 1/9) = 7/9, which matches the sample output.

So, this formula seems correct.

But for larger n and m, I need to compute this efficiently.

Given that m can be up to 1e5 and t up to 5e4, with sum of n over all test cases up to 1e5, and sum of m up to 1e5, and sum of k up to 2e5, I need an efficient way to compute this.

Let me see if I can precompute some terms.

Let me denote:

p = 2/(n*(n-1))

Then, for each friend pair, its expected contribution is:

f*k*p + k*(k-1)*p^2 / 2

So, E[S] = sum over all friend pairs of [f*k*p + k*(k-1)*p^2 / 2]

But p is the same for all friend pairs, so:

E[S] = p * sum over all friend pairs of f*k + (k*(k-1)*p / 2) * m

Wait, no.

Wait, p is 2/(n*(n-1))

So, E[S] = sum over all friend pairs of [f*k*(2/(n*(n-1))) + (k*(k-1)*(2/(n*(n-1)))^2)/2]

Which is:

sum over all friend pairs of f*k*(2/(n*(n-1))) + sum over all friend pairs of (k*(k-1)*2)/(n^2*(n-1)^2)

Wait, no, the second term has p^2 / 2, which is (2/(n*(n-1)))^2 / 2 = (4)/(n^2*(n-1)^2)/2 = 2/(n^2*(n-1)^2)

So, E[S] = sum over all friend pairs of [2*f*k/(n*(n-1)) + 2*k*(k-1)/(n^2*(n-1)^2)]

But sum over all friend pairs of 2*k*(k-1)/(n^2*(n-1)^2) is m * 2*k*(k-1)/(n^2*(n-1)^2)

And sum over all friend pairs of 2*f*k/(n*(n-1)) is (2*k/(n*(n-1))) * sum over all friend pairs of f

So, E[S] = (2*k/(n*(n-1))) * sum f + (2*k*(k-1)*m)/(n^2*(n-1)^2)

Let me denote sum_f = sum of all f_i for friend pairs.

Then, E[S] = (2*k*sum_f)/(n*(n-1)) + (2*k*(k-1)*m)/(n^2*(n-1)^2)

This seems manageable.

Now, I need to compute this expression modulo 1e9+7, expressed as p * q^{-1} mod (1e9+7), where p/q is the reduced form of E[S].

But since E[S] is a fraction, I need to compute it as p/q mod 1e9+7.

So, I need to compute E[S] as a fraction and then find p * q^{-1} mod 1e9+7.

Given that n, m, k are up to 1e5, and f_i up to 1e9, I need to handle large numbers and modular arithmetic carefully.

First, I need to compute the numerator and denominator separately, then reduce the fraction to its lowest terms, and compute p * q^{-1} mod 1e9+7.

But given the constraints, it's better to compute the entire expression under modulo, using modular inverses.

But since the denominator is n^2*(n-1)^2, and n can be up to 1e5, I need to compute inverses modulo 1e9+7 for these terms.

Given that 1e9+7 is a prime, I can compute inverses using Fermat's Little Theorem.

So, I need to compute E[S] as (2*k*sum_f)/(n*(n-1)) + (2*k*(k-1)*m)/(n^2*(n-1)^2)

To compute this modulo 1e9+7, I need to handle the divisions properly using modular inverses.

Let me denote MOD = 1e9+7

Then, I can compute:

denom1 = n * (n - 1) % MOD

inv_denom1 = pow(denom1, MOD-2, MOD)

first_term = (2 * k * sum_f % MOD) * inv_denom1 % MOD

denom2 = n * n * (n - 1) * (n - 1) % MOD

inv_denom2 = pow(denom2, MOD-2, MOD)

second_term = (2 * k * (k - 1) * m % MOD) * inv_denom2 % MOD

Then, E[S] mod MOD = (first_term + second_term) % MOD

But I need to make sure that this is indeed p * q^{-1} mod MOD, where p/q is the reduced form of E[S].

Given that, this should work.

Now, I need to implement this efficiently.

Given that sum of n and m over all test cases is up to 1e5, and sum of k is up to 2e5, this should be efficient enough.

I need to read t test cases, each with n, m, k, followed by m lines of friend pairs with their f_i.

For each test case, compute sum_f, then compute the first term and second term as above, and sum them modulo MOD.

Finally, print the result for each test case.

I need to be careful with overflow and modular arithmetic.

Also, since n can be up to 1e5, and m up to 1e5, but sum over all test cases is up to 1e5, I need to make sure that my code handles multiple test cases efficiently.

I should read all input at once and process it accordingly.

Alternatively, since the constraints allow sum of n and m over all test cases to be up to 1e5, and sum of k up to 2e5, I can process each test case separately without worrying about time limits, as long as my code is O(m) per test case.

Now, let's look at the provided program and see if it's correct.

## Final Solution
To solve this problem, we need to determine the expected value of the sum of friendship values of all pairs of children chosen for the excursions, considering the dynamic increase in friendship values for friend pairs selected during the excursions.

### Approach

1. **Problem Analysis**:
   - We have `n` children, `m` friend pairs with initial friendship values, and `k` excursions.
   - In each excursion, a pair of children is chosen randomly and uniformly.
   - If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.
   - Non-friend pairs have a friendship value of 0 that never increases.
   - We need to compute the expected sum of friendship values at the time of choice for all `k` excursions.

2. **Insight**:
   - Use linearity of expectation to compute the expected contribution of each friend pair to the total sum.
   - For each friend pair, compute the expected sum of their friendship values over all excursions they are chosen.

3. **Mathematical Formulation**:
   - Let `p` be the probability of choosing a specific pair in one excursion, which is `2 / (n * (n - 1))`.
   - For each friend pair, the expected contribution is `f * k * p + (k * (k - 1) * p^2) / 2`.
   - Sum these contributions over all friend pairs and simplify.

4. **Efficient Calculation**:
   - Compute the sum of friendship values (`sum_f`) for all friend pairs.
   - Use modular inverses to handle division under modulo `10^9 + 7`.

### Solution Code

```python
MOD = 10**9 + 7

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        m = int(data[idx + 1])
        k = int(data[idx + 2])
        idx += 3
        sum_f = 0
        for _ in range(m):
            a = int(data[idx])
            b = int(data[idx + 1])
            f = int(data[idx + 2])
            sum_f += f
            idx += 3
        # Compute first term: (2 * k * sum_f) / (n * (n - 1))
        denom1 = n * (n - 1) % MOD
        inv_denom1 = pow(denom1, MOD - 2, MOD)
        first_term = (2 * k * sum_f % MOD) * inv_denom1 % MOD
        # Compute second term: (2 * k * (k - 1) * m) / (n^2 * (n - 1)^2)
        denom2 = n * n * (n - 1) * (n - 1) % MOD
        inv_denom2 = pow(denom2, MOD - 2, MOD)
        second_term = (2 * k * (k - 1) * m % MOD) * inv_denom2 % MOD
        # Compute total expected sum modulo MOD
        result = (first_term + second_term) % MOD
        print(result)

if __name__ == '__main__':
    main()
```

### Explanation

1. **Reading Input**:
   - Read all input data at once for efficiency.
   - Parse the number of test cases `t`.

2. **Processing Each Test Case**:
   - For each test case, read `n`, `m`, and `k`.
   - Read the friend pairs and accumulate the sum of their friendship values (`sum_f`).

3. **Computing the Expected Sum**:
   - Calculate the first term: `(2 * k * sum_f) / (n * (n - 1))` using modular inverse.
   - Calculate the second term: `(2 * k * (k - 1) * m) / (n^2 * (n - 1)^2)` using modular inverse.
   - Sum the two terms and take modulo `10^9 + 7` to get the final result.

4. **Output**:
   - Print the result for each test case.

This approach ensures efficient computation within the given constraints, leveraging mathematical insights and modular arithmetic to handle large numbers and multiple test cases effectively.