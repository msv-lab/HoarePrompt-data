Alright, I have this problem to solve. Let's see what it's asking for. There are n children in a class, and m pairs among them are friends with a friendship value f_i. The teacher goes on k excursions, and for each excursion, she randomly chooses a pair of children equiprobably and independently. If the pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0 that doesn't change.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, and this sum should be calculated at the time of being chosen. Also, it's given that this expected value can be expressed as a fraction p/q where p and q are coprime, and I need to compute p * q^{-1} mod (10^9 + 7).

First, I need to understand the process:

1. There are n children, and m pairs of friends with given friendship values.

2. For each excursion, a pair of children is chosen randomly and uniformly from all possible pairs.

3. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

4. The friendship value of non-friend pairs is always 0 and doesn't change.

5. I need to find the expected sum of the friendship values of all k chosen pairs at the time they are chosen.

Let me think about how to approach this.

First, I need to consider that pairs are chosen independently, but the friendship values can increase over time if friends are chosen. So, the choice in one excursion can affect the values in subsequent excursions.

But wait, the problem says to consider the friendship value at the time of being chosen. So, for each excursion, I need to consider the current friendship value of the chosen pair at that moment.

Given that, I need to compute the expected sum of these values over k excursions.

Let me consider the friendship values over time.

Let’s denote the set of friend pairs as F, where each pair has an initial friendship value f_i.

For each excursion, a pair is chosen uniformly at random from all possible pairs.

If the chosen pair is in F, their friendship value increases by 1 for all subsequent excursions.

Non-friend pairs always have a friendship value of 0.

I need to find the expected sum of the friendship values of the chosen pairs at the time of choice over k excursions.

Let me try to model this.

Let’s consider that in each excursion, the chosen pair could be either a friend pair or a non-friend pair.

For non-friend pairs, their friendship value is always 0.

For friend pairs, their friendship value increases by 1 each time they are chosen.

But the increase affects subsequent excursions.

Wait, but the problem says that when a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, if a friend pair is chosen in excursion t, their friendship value increases by 1 starting from excursion t+1.

But for the sum, I need to consider the friendship value at the time of choice.

So, for each excursion, the friendship value of a friend pair is equal to the number of times they have been chosen in previous excursions.

Wait, no.

Let’s think carefully.

Initially, each friend pair has a friendship value f_i.

Each time a friend pair is chosen, their friendship value increases by 1 for all subsequent choices.

So, at the time of choice, their friendship value is f_i plus the number of times they have been chosen in previous excursions.

Wait, but the problem says that when a pair of friends is chosen, their friendship value increases by 1 for all subsequent excursions.

So, at the time of being chosen, their friendship value is still f_i plus the number of times they have been chosen in previous excursions.

Wait, but the problem says that the friendship value increases by 1 for all subsequent excursions.

So, at the time of being chosen, it's still the value before the increase.

Wait, maybe I need to clarify.

Let me consider that when a friend pair is chosen in excursion t, their friendship value is f_i plus the number of times they have been chosen in previous excursions (i.e., times chosen in excursions 1 to t-1).

Then, their friendship value increases by 1, effective from excursion t+1 onwards.

So, at the time of being chosen in excursion t, their friendship value is f_i plus the number of times they have been chosen in excursions 1 to t-1.

I need to sum this value over all k excursions.

This seems complicated because it involves tracking how many times each friend pair has been chosen up to each excursion.

This seems like a dynamic programming problem, where I need to keep track of the number of times each friend pair has been chosen up to the current excursion.

But given the constraints, with t up to 5*10^4, n up to 10^5, m up to 10^5, and k up to 2*10^5 per test case, I need an efficient solution.

I need to find a way to compute the expected sum without simulating each excursion.

Let me think about the expectation.

The expected sum is the sum over all excursions of the expected friendship value of the chosen pair at that excursion.

So, expected sum = sum_{t=1 to k} E[value at time t]

Since each choice is independent, I can compute E[value at time t] for each t and sum them up.

Now, E[value at time t] = probability of choosing a friend pair times the expected friendship value of that pair at time t.

But this seems tricky because the friendship value of a pair depends on how many times it has been chosen in previous excursions.

This seems to involve some recursive dependency.

Maybe I can model this differently.

Let me consider that for each friend pair, their friendship value at time t is f_i plus the number of times they have been chosen in previous excursions.

But summing this over k excursions seems messy.

Perhaps I can think in terms of linearity of expectation.

Let me consider that for each friend pair, and for each excursion, their contribution to the total sum.

But it's not clear yet.

Wait, maybe I can think of the total sum as the sum over all excursions of the friendship value at the time of choice.

Given that, and using linearity of expectation, perhaps I can find an expression for the expected sum.

Let me try to model the process.

Let’s denote:

- Let P be the set of all possible pairs of children. There are C(n,2) = n(n-1)/2 possible pairs.

- Let F be the set of friend pairs, with |F| = m.

- Each friend pair i has an initial friendship value f_i.

- Non-friend pairs have friendship value 0, which never changes.

Now, in each excursion, a pair is chosen uniformly at random from P.

If the chosen pair is in F, their friendship value increases by 1 for all subsequent excursions.

I need to compute the expected sum of the friendship values of the chosen pairs at the time of being chosen, over k independent excursions.

Given the independence of excursions, I can treat each excursion separately and sum their expected values.

So, the total expected sum is k times the expected friendship value of a single excursion.

Wait, is that correct?

Wait, but the friendship values can increase over time, so choices in earlier excursions can affect the friendship values in later excursions.

Therefore, the excursions are not entirely independent; there is some dependency through the friendship values.

So, I need to model how the choices in earlier excursions affect the friendship values in later excursions.

This seems complicated.

Let me think differently.

Let me consider the process over time.

At time t=0, before any excursion, all friend pairs have their initial friendship values f_i.

At each time t=1 to k, a pair is chosen uniformly at random from P.

If the chosen pair is a friend pair, their friendship value increases by 1 for all subsequent times.

I need to sum the friendship values of the chosen pairs at the time of being chosen.

So, for each t from 1 to k:

- Choose a pair uniformly at random from P.

- If the pair is a friend pair, add its current friendship value to the sum and then increase its friendship value by 1 for future times.

- If the pair is not a friend pair, add 0 to the sum.

Given that, I need to compute the expected value of the total sum over k excursions.

This seems tricky because the friendship values are changing over time based on the choices made.

I need a way to compute this expectation efficiently.

Let me try to think about the expected contribution of each friend pair over all excursions.

Let’s consider a single friend pair j with initial friendship value f_j.

I need to compute the expected sum of its contribution over all excursions where it is chosen.

Each time pair j is chosen, its friendship value at that time is f_j plus the number of times it has been chosen in previous excursions.

Wait, let’s formalize this.

Let X_t be the friendship value of the pair chosen at time t, at the time of being chosen.

Then, the total sum S = sum_{t=1 to k} X_t.

I need E[S] = sum_{t=1 to k} E[X_t].

Now, E[X_t] = probability that a friend pair is chosen at time t times the expected friendship value of that friend pair at time t.

But this still seems complicated.

Let me think about the process in another way.

Let’s consider that for each friend pair j, the number of times it is chosen in k excursions follows a binomial distribution with parameters k and p_j, where p_j is the probability of choosing pair j in a single excursion.

Since there are C(n,2) possible pairs, p_j = 1 / C(n,2).

Given that, let’s denote N_j as the number of times pair j is chosen in k excursions.

Then, N_j ~ Binomial(k, p_j).

Now, the total sum S = sum over all excursions t of X_t, where X_t is the friendship value of the pair chosen at time t.

For a friend pair j, each time it is chosen, its friendship value at that time is f_j plus the number of times it has been chosen before.

So, if N_j = n, then the friendship value at the first choice is f_j + 0, at the second choice is f_j + 1, at the third choice is f_j + 2, and so on, up to the n-th choice, which is f_j + (n-1).

Therefore, the total contribution of pair j to the sum S is sum_{i=0 to n-1} (f_j + i) = n * f_j + sum_{i=0 to n-1} i = n * f_j + n*(n-1)/2.

But N_j is random, following a binomial distribution.

Therefore, the expected contribution of pair j to S is E[n * f_j + n*(n-1)/2], where n ~ Binomial(k, p_j).

Similarly, non-friend pairs contribute 0 each time they are chosen.

Therefore, the total expected sum E[S] = sum over all friend pairs j of E[n * f_j + n*(n-1)/2], where n ~ Binomial(k, p_j).

Now, I need to compute this expectation.

First, E[n] = k * p_j = k / C(n,2).

Second, E[n*(n-1)] = E[n*(n-1)] = Var(n) + E[n]*(E[n] - 1).

But for binomial distribution, Var(n) = k * p_j * (1 - p_j).

Therefore, E[n*(n-1)] = k * p_j * (1 - p_j) + E[n]*(E[n] -1).

Wait, actually, for binomial distribution, E[n*(n-1)] = k*(k-1)*p_j^2.

But let me verify:

For binomial distribution, E[n] = k * p_j.

E[n*(n-1)] = E[n^2 - n] = E[n^2] - E[n] = Var(n) + (E[n])^2 - E[n] = k * p_j * (1 - p_j) + (k * p_j)^2 - k * p_j.

Simplify: k * p_j * (1 - p_j) + k^2 * p_j^2 - k * p_j = k * p_j - k * p_j^2 + k^2 * p_j^2 - k * p_j = (k^2 - k) * p_j^2.

So, E[n*(n-1)] = (k*(k-1)) * p_j^2.

Therefore, E[n * f_j + n*(n-1)/2] = E[n] * f_j + E[n*(n-1)/2] = (k * p_j) * f_j + ((k*(k-1)) * p_j^2)/2.

Therefore, the total expected sum E[S] = sum over j=1 to m of [(k * p_j) * f_j + ((k*(k-1)) * p_j^2)/2].

Now, p_j = 1 / C(n,2), since each pair is chosen uniformly at random.

C(n,2) = n*(n-1)/2.

Therefore, p_j = 2 / (n*(n-1)).

Therefore, E[S] = sum over j=1 to m of [k * (2 / (n*(n-1))) * f_j + (k*(k-1)) * (4 / (n*(n-1))^2)/2].

Wait, let's compute p_j^2:

p_j^2 = (2 / (n*(n-1)))^2 = 4 / (n*(n-1))^2.

Therefore, E[S] = sum over j=1 to m of [k * (2 / (n*(n-1))) * f_j + (k*(k-1)) * (4 / (n*(n-1))^2)/2].

Simplify the second term:

(k*(k-1)) * (4 / (n*(n-1))^2)/2 = (k*(k-1)) * (2 / (n*(n-1))^2) = 2*k*(k-1) / (n*(n-1))^2.

Therefore, E[S] = sum over j=1 to m of [ (2*k*f_j)/(n*(n-1)) ) + (2*k*(k-1))/(n*(n-1))^2 ) ].

Wait, but this seems off because the second term doesn't depend on j.

Wait, no, it does depend on j through p_j^2, but in this case, p_j is the same for all friend pairs.

Wait, no, p_j is the probability of choosing pair j, which is the same for all pairs since they are chosen uniformly at random.

Therefore, p_j is the same for all j.

Therefore, the sum over j=1 to m of [(k * p_j) * f_j + ((k*(k-1)) * p_j^2)/2].

So, since p_j is the same for all j, I can factor it out.

But actually, since p_j is the same for all j, and there are m friend pairs, I can write:

E[S] = m * [ (k * p_j) * average_f_j + ((k*(k-1)) * p_j^2)/2 ].

But perhaps it's better to keep it in sum form.

Alternatively, I can write E[S] as:

E[S] = (k * p_j) * sum over j=1 to m of f_j + ( (k*(k-1)) * p_j^2 )/2 * m.

Wait, no, the second term was ((k*(k-1)) * p_j^2)/2 per friend pair, so sum over j=1 to m of [(k * p_j) * f_j + ((k*(k-1)) * p_j^2)/2 ].

Therefore, E[S] = (k * p_j) * sum over j=1 to m of f_j + ( (k*(k-1)) * p_j^2 )/2 * m.

Let me denote sum over j=1 to m of f_j as F_total.

Therefore, E[S] = k * p_j * F_total + (k*(k-1)) * p_j^2 * m / 2.

Now, p_j = 2 / (n*(n-1)).

Therefore, E[S] = k * (2 / (n*(n-1))) * F_total + (k*(k-1)) * (4 / (n*(n-1))^2) * m / 2.

Simplify the second term:

(k*(k-1)) * (4 / (n*(n-1))^2) * m / 2 = (k*(k-1)) * (2 / (n*(n-1))^2) * m = 2*k*(k-1)*m / (n*(n-1))^2.

Therefore, E[S] = (2*k*F_total)/(n*(n-1)) + (2*k*(k-1)*m)/(n*(n-1))^2.

This seems manageable.

Now, I need to compute this expression for each test case, and output p * q^{-1} mod (10^9 + 7), where E[S] = p/q with p and q coprime.

First, I need to compute E[S] as a fraction, then reduce it to p/q, and then compute p * q^{-1} mod (10^9 + 7).

Given the constraints, I need an efficient way to compute this for multiple test cases.

Let me outline the steps:

1. For each test case:

a. Read n, m, k.

b. Read m lines, each containing a_i, b_i, f_i.

c. Compute F_total = sum of f_i for all m friend pairs.

d. Compute p_j = 2 / (n*(n-1)).

e. Compute E[S] = (2*k*F_total)/(n*(n-1)) + (2*k*(k-1)*m)/(n*(n-1))^2.

f. Simplify E[S] to p/q, where p and q are coprime.

g. Compute p * q^{-1} mod (10^9 + 7), where q^{-1} is the modular inverse of q modulo 10^9+7.

2. Repeat for all t test cases.

Now, I need to implement this efficiently.

Given that t can be up to 5*10^4, and m up to 10^5 per test case, I need to make sure that the per-test-case time is low.

Let me see how to compute E[S] efficiently.

First, compute F_total = sum of f_i for all m friend pairs.

Then, compute the two terms:

Term1 = (2*k*F_total)/(n*(n-1))

Term2 = (2*k*(k-1)*m)/(n*(n-1))^2

So, E[S] = Term1 + Term2

Now, to compute this as a fraction, I need to have a common denominator.

Let’s find a common denominator for Term1 and Term2.

Term1 denominator: n*(n-1)

Term2 denominator: (n*(n-1))^2

So, the common denominator is (n*(n-1))^2.

Therefore, E[S] = [Term1 * (n*(n-1)) + Term2] / (n*(n-1))^2

Wait, let's compute it properly.

E[S] = Term1 + Term2 = [2*k*F_total * (n*(n-1)) + 2*k*(k-1)*m] / (n*(n-1))^2

Wait, no.

Wait, Term1 = (2*k*F_total)/(n*(n-1))

Term2 = (2*k*(k-1)*m)/(n*(n-1))^2

So, E[S] = Term1 + Term2 = [ (2*k*F_total)*(n*(n-1)) + 2*k*(k-1)*m ] / (n*(n-1))^2

Wait, no, that's not correct.

Wait, to add fractions:

Term1 = A / B

Term2 = C / D

Where B = n*(n-1), D = B^2 = (n*(n-1))^2

So, E[S] = (A*D + C*B) / (B*D)

But actually, since D = B^2, then E[S] = (A*B + C) / B^2

In this case, A = 2*k*F_total, B = n*(n-1), C = 2*k*(k-1)*m, D = B^2

Therefore, E[S] = (A*B + C) / B^2 = [2*k*F_total * n*(n-1) + 2*k*(k-1)*m] / (n*(n-1))^2

Wait, no.

Wait, A = 2*k*F_total, B = n*(n-1)

Term1 = A / B

Term2 = C / D = 2*k*(k-1)*m / B^2

So, E[S] = Term1 + Term2 = (A*D + C*B) / (B*D)

Since D = B^2, then E[S] = (A*B^2 + C*B) / (B^3)

Simplify numerator and denominator by B:

E[S] = (A*B + C) / B^2

Therefore, E[S] = [2*k*F_total * n*(n-1) + 2*k*(k-1)*m] / (n*(n-1))^2

Wait, no, 2*k*F_total / B + 2*k*(k-1)*m / B^2 = [2*k*F_total * B + 2*k*(k-1)*m] / B^2

Yes, that's correct.

So, E[S] = [2*k*F_total * n*(n-1) + 2*k*(k-1)*m] / (n*(n-1))^2

Now, I need to compute this fraction p/q, where p = 2*k*F_total * n*(n-1) + 2*k*(k-1)*m, and q = (n*(n-1))^2.

Then, reduce p and q to their lowest terms and compute p * q^{-1} mod (10^9 + 7).

Given the constraints, I need to handle large numbers and modular arithmetic carefully.

Let me see if I can simplify this expression.

First, factor out 2*k from the numerator:

p = 2*k * [F_total * n*(n-1) + (k-1)*m]

q = (n*(n-1))^2

So, E[S] = 2*k * [F_total * n*(n-1) + (k-1)*m] / (n*(n-1))^2

Now, I need to compute this fraction modulo 10^9+7.

Given that, I need to compute p = 2*k * [F_total * n*(n-1) + (k-1)*m]

And q = (n*(n-1))^2

Then, find p * q^{-1} mod (10^9 + 7)

Given that 10^9 + 7 is a prime, I can compute q^{-1} using Fermat's Little Theorem: q^{-1} = q^{MOD-2} mod MOD

Now, I need to implement this efficiently.

Given the constraints, I need to make sure that the computations are done efficiently, especially since t can be up to 5*10^4.

Also, n can be up to 10^5, and m up to 10^5, but since per test case operations are simple, it should be manageable.

Let me outline the steps in code:

1. Read t, the number of test cases.

2. For each test case:

a. Read n, m, k.

b. Read m lines, each containing a_i, b_i, f_i. Sum up all f_i to get F_total.

c. Compute p = 2 * k * (F_total * n * (n-1) + (k-1) * m)

d. Compute q = (n * (n-1)) ^ 2

e. Compute the greatest common divisor (gcd) of p and q, then divide both by gcd to get p/q in lowest terms.

f. Compute p * q^{-1} mod (10^9 + 7), where q^{-1} is q^{MOD-2} mod MOD.

g. Print the result.

However, to optimize, I can compute p and q, then compute p * q^{-1} mod MOD directly, without computing gcd, since MOD is a prime and q is invertible modulo MOD.

Therefore, I can proceed as follows:

- Compute p = 2 * k * (F_total * n * (n-1) + (k-1) * m) modulo MOD

- Compute q = (n * (n-1)) ^ 2

- Compute q_inv = q^{MOD-2} modulo MOD

- Compute result = (p * q_inv) modulo MOD

- Print result

But I need to ensure that q is not zero modulo MOD, but since n >= 2, n*(n-1) >= 2, so q is non-zero.

Also, need to handle large numbers carefully to avoid overflow.

Given that MOD is 10^9 + 7, which is a prime, and all operations are modulo MOD, I need to make sure that all intermediate computations are done modulo MOD.

Especially, n and k can be up to 10^5 and 2*10^5 respectively, and f_i up to 10^9, so F_total can be up to 10^5 * 10^9 = 10^{14}, which is manageable modulo 10^9 + 7.

Let me confirm the formula:

E[S] = 2*k*(F_total * n*(n-1) + (k-1)*m) / (n*(n-1))^2

Yes, that seems correct.

Now, to implement this efficiently, I need to compute n*(n-1), which is C(n,2)*2.

Given that, I can compute q = (n*(n-1))^2

And p = 2*k*(F_total*n*(n-1) + (k-1)*m)

Then, compute p * q^{-1} mod MOD.

Let me think about potential optimizations or simplifications.

Alternatively, I can write E[S] as:

E[S] = 2*k*F_total / (n*(n-1)) + 2*k*(k-1)*m / (n*(n-1))^2

But in modular arithmetic, division is multiplication by modular inverse.

So, implementing it as p * q^{-1} mod MOD is fine.

Now, I need to implement this in code.

I need to read t test cases, each with n, m, k, followed by m lines of a_i, b_i, f_i.

For each test case, compute F_total, then p and q as above, compute q_inv, then compute result = (p * q_inv) % MOD, and print it.

Given that t can be up to 5*10^4, and sum of m over all test cases up to 10^5, and sum of k up to 2*10^5, the total time should be acceptable.

I need to make sure that reading input is efficient, perhaps reading all input at once and processing it.

In Python, reading input efficiently is important for large inputs.

I can read all input at once using sys.stdin.read(), split it into tokens, and process them one by one.

This is faster than reading line by line using input() in a loop.

Given that, I can proceed to implement the code accordingly.

Now, I need to make sure that all computations are done modulo MOD, and that I handle large numbers correctly.

Also, need to compute q_inv = q^{MOD-2} mod MOD, which can be done efficiently using pow(q, MOD-2, MOD) in Python.

Finally, print the result for each test case.

I