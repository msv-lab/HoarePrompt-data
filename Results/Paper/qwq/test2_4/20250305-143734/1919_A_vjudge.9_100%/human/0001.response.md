Alright, I've got this problem here about Alice and Bob playing a game with their wallets. So, Alice has a certain number of coins, Bob has another number, and they take turns making moves according to some rules. The goal is to figure out who will win if both play optimally.

First, I need to understand the rules of the game. Each turn, the player can choose to either exchange wallets with the opponent or keep their current wallet. After that, they have to remove one coin from their current wallet. Importantly, the wallet can't have zero coins before removing one. The player who can't make a valid move loses.

So, let's break this down. Each player has a certain number of coins in their wallet, and they alternate turns. Alice goes first. On each turn, the player has two options: swap wallets or keep the current one, and then remove one coin from their wallet.

I need to think about what "playing optimally" means. It means that each player makes the best possible move to ensure they win, assuming the other player is also doing the same.

Given that a and b can be up to 10^9, which is a billion, I need an efficient way to determine the winner without simulating the game, as that would be too slow for such large numbers.

Let me consider some small test cases to see if I can find a pattern or a formula.

Take the first test case: a=1, b=1.

- Alice's turn: She can choose to swap or not.

- If she swaps, she has b=1, and removes one coin, so b=0.

- Now, Bob has a=0 and b=0.

- Bob can't swap because both wallets are empty, and he can't remove a coin from an empty wallet.

- So, Bob loses, meaning Alice wins. But according to the sample output, it's Bob who wins. Wait, that contradicts.

Wait, in the note, it says that in the first test case, Bob wins. So maybe I'm misunderstanding the rules.

Let me read the note again.

In the first test case:

- Alice chooses not to swap. So a=0, b=1.

- Bob chooses not to swap (since his wallet would be empty if he swaps). So a=0, b=0.

- Alice can't make a move, so Bob wins.

Okay, so in this scenario, Alice chooses not to swap, leading to a=0, b=1.

Then Bob chooses not to swap, since swapping would give him a=0, which is invalid because he has to remove one coin. So he keeps his wallet with b=1, removes one coin, making b=0.

Now, Alice has a=0 and b=0. She can't make a move, so Bob wins.

Wait, but in my earlier simulation, I thought differently. So perhaps the key is that if a player has zero coins, they can't swap because their wallet is empty.

I need to be careful about the conditions under which swapping is allowed.

Let me try to think differently.

Let me consider the number of coins each player has and see if there's a pattern based on the difference or something.

Looking at the sample input and output:

1. 1 1 → Bob

2. 1 4 → Alice

3. 5 3 → Bob

4. 4 5 → Alice

5. 11 9 → Bob

6. 83 91 → Bob

7. 1032 9307 → Alice

8. 839204 7281 → Alice

9. 1000000000 1000000000 → Bob

10. 53110 2024 → Bob

Looking at these, it seems that when a and b are equal, Bob wins, which makes sense because if a = b, the difference is zero, which is even.

Wait, the program checks if abs(a - b) % 2 == 0, then prints 'Bob', else 'Alice'.

So, if the absolute difference between a and b is even, Bob wins; otherwise, Alice wins.

Let me verify this with the sample inputs:

1. 1 1 → diff = 0, which is even → Bob

2. 1 4 → diff = 3, which is odd → Alice

3. 5 3 → diff = 2, even → Bob

4. 4 5 → diff = 1, odd → Alice

5. 11 9 → diff = 2, even → Bob

6. 83 91 → diff = 8, even → Bob

7. 1032 9307 → diff = 8275, odd → Alice

8. 839204 7281 → diff = 831923, odd → Alice

9. 1000000000 1000000000 → diff = 0, even → Bob

10. 53110 2024 → diff = 51086, even → Bob

This matches the sample output.

So, the program is checking if the absolute difference between a and b is even or odd to determine the winner.

But is this correct?

I need to think about the game mechanics to confirm.

Let me consider that the game is similar to a Nim game or some other impartial game where the number of coins represents the number of moves each player can make.

However, in this game, players can choose to swap wallets or not, and then remove one coin from their current wallet.

This swapping adds a layer of strategy.

If the difference between a and b is even, Bob wins; otherwise, Alice wins.

I need to see if this is a valid conclusion.

Let me consider the base case where a = b.

If a = b, then Alice and Bob have the same number of coins.

Alice goes first. She can choose to swap or not.

- If she chooses not to swap, she removes one coin from her wallet, so now a = a - 1, b = b.

- If she chooses to swap, she swaps wallets, so a and b are exchanged, then she removes one coin from her current wallet, which is now b - 1.

Bob then makes his move.

Wait, this seems complicated to track manually for large a and b.

Perhaps there is a mathematical way to determine the winner without simulating the game.

I recall that in impartial games, the concept of Nimbers or mex can be used to determine the game's outcome.

But in this case, the game seems a bit different because of the wallet swapping option.

Let me think differently.

Suppose I consider the total number of coins as a sum, but with the option to swap, it might not directly apply.

Wait, perhaps I can think in terms of the difference between a and b.

If the difference is even, Bob wins; if odd, Alice wins.

Is there a way to see why this might be the case?

Let me consider that the game continues until one player can't make a move.

A player can't make a move if their current wallet has zero coins, and they can't swap to the other wallet if it also has zero coins.

So, the game ends when both wallets are empty.

The player who faces this situation loses.

Now, each move reduces the number of coins by one in the current wallet.

The swapping option allows players to switch wallets, which might help in strategizing when their current wallet has fewer coins.

But in the end, the total number of moves possible is a + b.

Since players alternate turns, the player who makes the last move wins, because the other player can't make a move after that.

Wait, no.

Let's see:

- If the total number of moves is even, the second player wins.

- If the total number of moves is odd, the first player wins.

But that can't be right because swapping complicates this.

Wait, but swapping doesn't change the total number of coins; it just switches which wallet the coins are in.

But since each move removes one coin, the total number of moves is a + b.

But the swapping adds a strategic element.

Wait, maybe not.

Let me think again.

If both players play optimally, they will try to force the opponent into a losing position.

In this game, the losing position is when a player has to make a move but their wallet is empty and the other wallet is also empty.

Wait, but if a player has an empty wallet and the other has coins, they can choose not to swap and remove a coin from the non-empty wallet.

So, the game continues until both wallets are empty.

So, the total number of moves is a + b.

Since Alice starts first, if a + b is odd, Alice makes the last move, and Bob can't move, so Alice wins.

If a + b is even, Bob makes the last move, and Alice can't move, so Bob wins.

Wait, that seems straightforward.

But looking back at the program, it's checking if abs(a - b) % 2 == 0, then Bob wins, else Alice wins.

But according to my new reasoning, it should be based on a + b being even or odd.

Wait, is that correct?

Let me verify with the sample inputs.

First test case: a=1, b=1 → a+b=2, which is even → Bob wins.

Second test case: a=1, b=4 → a+b=5, odd → Alice wins.

Third test case: a=5, b=3 → a+b=8, even → Bob wins.

Fourth test case: a=4, b=5 → a+b=9, odd → Alice wins.

Fifth test case: a=11, b=9 → a+b=20, even → Bob wins.

Sixth test case: a=83, b=91 → a+b=174, even → Bob wins.

Seventh test case: a=1032, b=9307 → a+b=1032 + 9307 = 10339, odd → Alice wins.

Eighth test case: a=839204, b=7281 → a+b=846485, odd → Alice wins.

Ninth test case: a=1000000000, b=1000000000 → a+b=2000000000, even → Bob wins.

Tenth test case: a=53110, b=2024 → a+b=55134, even → Bob wins.

This matches the sample output.

So, the correct condition is if a + b is even, Bob wins; else, Alice wins.

But the given program checks if abs(a - b) is even, then Bob wins; else, Alice wins.

This seems incorrect based on my reasoning.

Wait, but let's check if abs(a - b) % 2 == a + b % 2.

Because abs(a - b) and a + b have the same parity.

Yes, because a + b and a - b have the same parity.

Proof:

Consider a and b.

- If both a and b are even:

  - a + b is even

  - a - b is even

- If both a and b are odd:

  - a + b is even

  - a - b is even

- If one is even and the other is odd:

  - a + b is odd

  - a - b is odd

Therefore, a + b and a - b have the same parity.

Hence, checking if abs(a - b) is even is equivalent to checking if a + b is even.

So, the given program is correct.

Wait, but in my initial reasoning, I thought that the total number of moves is a + b, and if a + b is even, Bob wins; else, Alice wins.

But according to the problem, Alice makes the first move.

In standard impartial games, if the total number of moves is odd, the first player wins; if even, the second player wins.

Yes, that seems correct.

Hence, the program is correct.

Therefore, the answer is True.

**Final Solution**

To solve this problem, we need to determine the winner of a game between Alice and Bob based on the number of coins they each have in their wallets, assuming both play optimally.

## Approach

1. **Problem Analysis**:
   - Alice and Bob take turns with Alice starting first.
   - Each player can choose to swap wallets or keep their current wallet and then remove one coin from their chosen wallet.
   - The game continues until a player cannot make a move, i.e., both wallets are empty.

2. **Key Insight**:
   - The total number of moves in the game is the sum of coins in both wallets (`a + b`).
   - Since Alice starts first, if the total number of moves is odd, Alice will make the last move and hence win. If it's even, Bob will make the last move and win.

3. **Optimal Solution**:
   - We observe that the parity (even or odd) of the sum of coins determines the winner.
   - Instead of calculating `a + b`, we use the fact that the parity of `a + b` is the same as the parity of `abs(a - b)` for integers.
   - Thus, we check if `abs(a - b)` is even or odd to determine the winner.

## Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        a = int(data[index])
        b = int(data[index + 1])
        index += 2
        if abs(a - b) % 2 == 0:
            print('Bob')
        else:
            print('Alice')

if __name__ == "__main__":
    main()
```

## Explanation

- **Input Handling**:
  - Read all input at once for efficiency, split it into a list, and parse the number of test cases.
  - For each test case, read the values of `a` and `b`.

- **Determine Winner**:
  - Calculate the absolute difference `abs(a - b)`.
  - Check if this difference is even or odd.
  - If even, print "Bob"; otherwise, print "Alice".

This approach ensures an efficient determination of the winner without simulating the entire game, which is crucial given the constraints (a and b can be up to 1,000,000,000).