Alright, I have this problem to solve. Let's read it carefully.

We have n signs of the apocalypse, each occurring every a_i years. So, the i-th sign occurs in years a_i, 2*a_i, 3*a_i, and so on.

The key here is that these signs must occur sequentially, meaning that after the first sign occurs, we start waiting for the second sign in the next year after the first one, and so on.

So, I need to find out in which year all n signs will have occurred in this sequential manner.

Let me try to understand with the first example:

Input:

6

3 2 4 5 9 18

According to the explanation:

- First sign occurs in year 3.

- Then we start waiting for the second sign from year 4.

- The second sign occurs in year 4 (since 2*2=4, and it's >=4).

- Then wait for the third sign from year 5.

- Third sign occurs in year 8 (since 2*4=8, and it's >=5).

- Wait for the fourth sign from year 9.

- Fourth sign occurs in year 10 (since 2*5=10, and it's >=9).

- Wait for the fifth sign from year 11.

- Fifth sign occurs in year 18 (since 2*9=18, and it's >=11).

- Wait for the sixth sign from year 19.

- Sixth sign occurs in year 36 (since 2*18=36, and it's >=19).

So, the sixth sign occurs in year 36.

Another example:

Input:

5

1 2 3 4 5

First sign in year 1.

Wait for second sign from year 2.

Second sign in year 2.

Wait for third sign from year 3.

Third sign in year 3.

Wait for fourth sign from year 4.

Fourth sign in year 4.

Wait for fifth sign from year 5.

Fifth sign in year 5.

So, the fifth sign occurs in year 5.

Another one:

Input:

5

1 1 1 1 1

Similarly, signs occur every year, so the fifth sign occurs in year 5.

Last one:

Input:

6

50 30 711 200 503 1006

Need to compute the year when the sixth sign occurs, following the same logic.

Okay, so the general approach seems to be:

1. Start from year 0.

2. For each sign, find the earliest occurrence year that is greater than the year the previous sign occurred.

3. Keep track of the current year after each sign occurs.

4. The year when the nth sign occurs is the answer.

So, for sign i, find the smallest multiple of a_i that is greater than the year the (i-1)th sign occurred.

Let me try to formalize this.

Let’s denote:

- prev_year = 0

- For each sign i from 1 to n:

- Find the smallest year k * a_i such that k * a_i > prev_year

- Set prev_year = k * a_i

- The year when the nth sign occurs is the final prev_year.

Let’s verify this with the first example:

n=6, a=[3,2,4,5,9,18]

- prev_year = 0

- Sign 1: smallest k*3 > 0 => k=1, year=3

- prev_year=3

- Sign 2: smallest k*2 > 3 => k=2, year=4

- prev_year=4

- Sign 3: smallest k*4 > 4 => k=2, year=8

- prev_year=8

- Sign 4: smallest k*5 > 8 => k=2, year=10

- prev_year=10

- Sign 5: smallest k*9 > 10 => k=2, year=18

- prev_year=18

- Sign 6: smallest k*18 > 18 => k=2, year=36

- So, final year is 36.

Seems correct.

Another example:

n=5, a=[1,2,3,4,5]

- prev_year=0

- Sign 1: smallest k*1 > 0 => k=1, year=1

- prev_year=1

- Sign 2: smallest k*2 > 1 => k=1, year=2

- prev_year=2

- Sign 3: smallest k*3 > 2 => k=1, year=3

- prev_year=3

- Sign 4: smallest k*4 > 3 => k=1, year=4

- prev_year=4

- Sign 5: smallest k*5 > 4 => k=1, year=5

- So, final year is 5.

Perfect.

Another one:

n=5, a=[1,1,1,1,1]

Similar to above, final year is 5.

Last example:

n=6, a=[50,30,711,200,503,1006]

- prev_year=0

- Sign 1: smallest k*50 > 0 => k=1, year=50

- prev_year=50

- Sign 2: smallest k*30 > 50 => k=2, year=60

- prev_year=60

- Sign 3: smallest k*711 > 60 => k=1, year=711

- prev_year=711

- Sign 4: smallest k*200 > 711 => k=4, year=800

- prev_year=800

- Sign 5: smallest k*503 > 800 => k=2, year=1006

- prev_year=1006

- Sign 6: smallest k*1006 > 1006 => k=2, year=2012

- So, final year is 2012.

Matches the example.

Alright, so the approach seems solid.

Now, I need to implement this in code.

Given that t can be up to 1000 and n up to 100, and a_i up to 10^6, efficiency should not be a big concern here.

For each test case:

- Read n

- Read the list of a_i

- Initialize prev_year = 0

- For each sign from 1 to n:

- Find the smallest k such that k * a_i > prev_year

- year = k * a_i

- Set prev_year = year

- After processing all signs, output prev_year

Now, to find the smallest k such that k * a_i > prev_year, since a_i >=1 and k is integer >=1, we can calculate k = ceil((prev_year + 1)/a_i)

Then, year = k * a_i

Let's verify this formula.

In the first example:

prev_year=0, a_i=3

k = ceil(1/3)=1, year=3

prev_year=3, a_i=2

k=ceil(4/2)=2, year=4

prev_year=4, a_i=4

k=ceil(5/4)=2, year=8

prev_year=8, a_i=5

k=ceil(9/5)=2, year=10

prev_year=10, a_i=9

k=ceil(11/9)=2, year=18

prev_year=18, a_i=18

k=ceil(19/18)=2, year=36

Perfect.

Another example:

prev_year=0, a_i=1

k=ceil(1/1)=1, year=1

prev_year=1, a_i=2

k=ceil(2/2)=1, year=2

And so on.

Looks good.

So, in code, I can use math.ceil((prev_year + 1)/a_i) to find k, then year = k * a_i

I need to make sure to handle integer division correctly.

In Python, math.ceil(x) rounds x up to the nearest integer.

But I need to be careful with integer division.

Wait, in Python, if I do (prev_year + 1) / a_i, it will be a float, and then ceil will work fine.

Then, year = k * a_i

Should be straightforward.

Edge cases to consider:

- n=1: simply output a_1

- a_i=1: signs occur every year

- a_i large: need to handle large numbers, but since a_i <=10^6 and n<=100, no issues

- prev_year +1 could be up to, say, 10^6 *100 =10^8, which is manageable

- t=1000 test cases: need to make sure code is efficient enough, but since n is small, no problems

Let me think about the code structure.

Read t from input.

For each test case:

- Read n

- Read list of a_i

- Initialize prev_year =0

- For each a in a_i:

- k = ceil((prev_year +1)/a)

- year = k * a

- Set prev_year = year

- Output prev_year for this test case

I need to read the input correctly.

In Python, I can read all input at once and split it into tokens.

Then, process them one by one using an index.

Let me write a skeleton of the code.

import sys

def main():

import sys

data = sys.stdin.read().split()

index = 0

t = int(data[index])

index +=1

for _ in range(t):

n = int(data[index])

index +=1

a = []

for _ in range(n):

a.append(int(data[index]))

index +=1

prev_year =0

for ai in a:

k = math.ceil((prev_year +1)/ai)

year = k * ai

prev_year = year

print(prev_year)

if __name__ == "__main__":

main()

Wait, I need to import math.

And ensure that math.ceil is available.

Alternatively, I can avoid math.ceil by using integer division.

In Python, to compute ceil(a/b), it's equivalent to (a + b -1)//b

So, k = ((prev_year +1) + a_i -1)//a_i

Then, year = k * a_i

This way, I can avoid importing math.

Let me verify this formula.

For prev_year=0, a_i=3

k = (1 + 3 -1)//3 =3//3=1, year=3

For prev_year=3, a_i=2

k=(4 +2 -1)//2=5//2=3//2=2, year=4

Wait, 5//2 is 2.

Yes, correct.

Another example:

prev_year=4, a_i=4

k=(5 +4 -1)//4=8//4=2, year=8

Correct.

So, this works.

Better to use integer arithmetic to avoid floating point precision issues.

So, in code:

k = ((prev_year +1 + a_i -1)//a_i)

year = k * a_i

Perfect.

Now, let's consider if n=1.

n=1, a=[x], should return x.

Yes, because first sign occurs in year x.

n=2, a=[1,1], should return 2.

Because first sign in year1, then second sign in year2.

n=2, a=[1,2], first sign in year1, second sign in year2.

n=2, a=[2,1], first sign in year2, second sign in year3.

Seems correct.

Another edge case: n=2, a=[2,3]

prev_year=0, first sign in year2.

Then, wait for second sign from year3.

Second sign occurs in year3 (since 3*1=3 >2).

So, year3.

Yes.

Another one: n=3, a=[2,2,2]

Start from year0.

First sign in year2.

Wait for second sign from year3.

Second sign in year4.

Wait for third sign from year5.

Third sign in year6.

So, year6.

Correct.

Seems solid.

I think this is the correct approach.

## Final Solution
To solve this problem, we need to determine the year in which the nth sign occurs, considering that each sign occurs at periodic intervals and must occur sequentially after the previous sign.

### Approach

1. **Understanding the Problem:**
   - Each sign occurs every `a_i` years.
   - For the signs to happen sequentially, each sign must occur after the previous one.

2. **Algorithm:**
   - Start from year 0.
   - For each sign, find the smallest multiple of its period that is greater than the year the previous sign occurred.
   - Update the year for each sign accordingly.

3. **Efficient Calculation:**
   - Use integer arithmetic to calculate the smallest multiple greater than the previous year.
   - Avoid floating-point operations to ensure precision.

### Solution Code

```python
def main():
    import sys
    data = sys.stdin.read().split()
    index = 0
    t = int(data[index])
    index += 1
    for _ in range(t):
        n = int(data[index])
        index += 1
        a = []
        for _ in range(n):
            a.append(int(data[index]))
            index += 1
        prev_year = 0
        for ai in a:
            k = ((prev_year + 1 + ai - 1)) // ai
            year = k * ai
            prev_year = year
        print(prev_year)

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input:**
   - Read the number of test cases `t`.
   - For each test case, read `n` (number of signs) and the list `a` (periods of the signs).

2. **Processing Each Test Case:**
   - Initialize `prev_year` to 0.
   - For each sign period `ai` in the list `a`:
     - Calculate the smallest integer `k` such that `k * ai > prev_year`. This is done using integer division to avoid precision issues.
     - Update `prev_year` to the year when this sign occurs (`year = k * ai`).

3. **Output the Result:**
   - After processing all signs for a test case, print the year when the nth sign occurs.

This approach ensures that we correctly determine the year of the nth sign's occurrence by sequentially accounting for each sign's periodicity.