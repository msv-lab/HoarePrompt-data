Alright, I have this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount x_i on each outcome. The condition is that no matter which outcome wins, the total coins I get back should be more than the total coins I bet.

More formally, if I bet x1, x2, ..., xn on outcomes 1 through n, then for each i from 1 to n, the condition is:

sum of all x_j (j from 1 to n) < k_i * x_i

This needs to hold for all i.

So, I need to find such x_i's that satisfy this condition for every possible winning outcome.

First, I need to understand what this means. Essentially, for each possible winning outcome, the reward from that outcome should be greater than the total bets I made on all outcomes.

Let me try to think of a small example to get a better grasp.

Suppose n=2, and k1=2, k2=3.

I need to choose x1 and x2 such that:

x1 + x2 < 2*x1 (from outcome 1)

and

x1 + x2 < 3*x2 (from outcome 2)

Let's simplify these inequalities:

From outcome 1:

x1 + x2 < 2*x1 => x2 < x1

From outcome 2:

x1 + x2 < 3*x2 => x1 < 2*x2

So, we have:

x2 < x1

and

x1 < 2*x2

These are the conditions that x1 and x2 must satisfy.

Is there a solution to this system?

Let's assume x2 = m, where m is some positive integer.

Then, from x2 < x1, x1 > m

And from x1 < 2*x2, x1 < 2*m

So, m < x1 < 2*m

This means x1 can be any integer strictly between m and 2*m.

For example, if m=1, then x1 can be 2 (since 1 < x1 < 2*1=2, but there's no integer between 1 and 2, so no solution for m=1)

Wait, that's interesting. For m=1, there's no integer x1 such that 1 < x1 < 2.

So, m must be at least 2.

For m=2, then 2 < x1 < 4, so x1=3.

So, one possible solution is x2=2, x1=3.

Check the conditions:

Total bets: 3 + 2 = 5

If outcome 1 wins: 2*3 = 6 > 5

If outcome 2 wins: 3*2 = 6 > 5

Perfect, it satisfies.

Another example: n=3, k1=3, k2=2, k3=7

Need to find x1, x2, x3 such that:

x1 + x2 + x3 < 3*x1

x1 + x2 + x3 < 2*x2

x1 + x2 + x3 < 7*x3

Simplify each:

From outcome 1:

x1 + x2 + x3 < 3*x1 => x2 + x3 < 2*x1 => x1 > (x2 + x3)/2

From outcome 2:

x1 + x2 + x3 < 2*x2 => x1 + x3 < x2 => x2 > x1 + x3

From outcome 3:

x1 + x2 + x3 < 7*x3 => x1 + x2 < 6*x3 => x3 > (x1 + x2)/6

So, we have three inequalities that need to hold simultaneously.

This seems a bit more complex. Maybe there's a general approach to find such x_i's.

Looking back at the first example with n=2, I saw that choosing x2=m and x1=m+1 satisfied the conditions as long as m is chosen appropriately.

But for larger n, this might not be efficient. I need a more systematic way.

Let me think about the general case.

Given n multipliers k1, k2, ..., kn, I need to find positive integers x1, x2, ..., xn such that for each i:

sum_{j=1 to n} x_j < k_i * x_i

One way to approach this is to consider the reciprocal of x_i and try to find a relationship.

But that might be too abstract. Maybe there's another way.

Let me consider the least common multiple or something related to the multipliers.

Wait, another idea: suppose I set x_i = L / k_i, where L is the least common multiple of the k_i's.

But since x_i need to be integers, and L/k_i might not be integer unless L is a multiple of k_i.

Wait, perhaps I need to choose L as the least common multiple of the k_i's.

But I'm not sure if that directly helps.

Let me think differently.

Suppose I fix x_i's and compute the sum S = sum x_i.

Then, for each i, S < k_i * x_i.

Which implies that x_i > S / k_i.

But since S = sum x_j, and x_i is part of this sum, this seems a bit circular.

Wait, perhaps I can use the fact that S = sum x_j = x_i + sum_{j != i} x_j.

So, S < k_i * x_i => x_i + sum_{j != i} x_j < k_i * x_i => sum_{j != i} x_j < (k_i - 1) * x_i.

This seems similar to what I had before.

Is there a way to find x_i's that satisfy this for all i?

Maybe I can assign x_i proportional to the product of k_j's divided by k_i.

Let me try that.

Suppose I let P = product of all k_j for j=1 to n.

Then, set x_i = P / k_i.

Then, sum S = sum_{j=1 to n} P / k_j.

Now, check if S < k_i * x_i for each i.

k_i * x_i = k_i * (P / k_i) = P.

So, the condition is S < P.

Therefore, sum_{j=1 to n} P / k_j < P.

Divide both sides by P: sum_{j=1 to n} 1 / k_j < 1.

So, this approach works only if sum_{j=1 to n} 1 / k_j < 1.

If this sum is less than 1, then setting x_i = P / k_i satisfies the condition.

Because S = P * sum_{j=1 to n} 1 / k_j < P, which is equal to k_i * x_i = P for each i.

Hence, the condition holds.

But if sum_{j=1 to n} 1 / k_j >= 1, then this approach doesn't work because S >= P, which would not satisfy S < P.

In that case, there might be no solution.

Wait, but is this always the case? That if sum_{j=1 to n} 1 / k_j >= 1, then there is no possible way to assign x_i's to satisfy the condition?

Let me test this with an example.

Take n=2, k1=2, k2=3.

Sum of reciprocals: 1/2 + 1/3 = 5/6 < 1.

In the earlier example, I found a solution.

Another example: n=2, k1=2, k2=2.

Sum of reciprocals: 1/2 + 1/2 = 1, which is not less than 1.

Is there a solution in this case?

Let's see.

We need x1 + x2 < 2*x1 and x1 + x2 < 2*x2.

Simplify:

From first inequality: x2 < x1

From second: x1 < x2

This implies x2 < x1 and x1 < x2, which is impossible.

Hence, no solution exists in this case, which aligns with the sum of reciprocals being equal to 1.

Another example: n=3, k1=3, k2=3, k3=3.

Sum of reciprocals: 1/3 + 1/3 + 1/3 = 1.

Again, no solution exists, as per the earlier logic.

So, it seems that if sum_{j=1 to n} 1 / k_j >= 1, then there is no solution.

Otherwise, if sum_{j=1 to n} 1 / k_j < 1, then a solution exists.

And one possible solution is to set x_i = P / k_i, where P is the product of all k_j's.

But in the problem, x_i can be up to 10^9, so we need to make sure that x_i doesn't exceed this limit.

Given that k_i <=20 and n <=50, the product P can be quite large.

But since P is divided by k_i for each x_i, it might still be manageable.

Wait, let's calculate the maximum possible P.

k_i <=20, n <=50, but in reality, n is up to 50, but k_i are up to 20.

But 20^50 is a huge number, way beyond standard integer types.

So, perhaps this approach is not practical due to integer overflow or large number issues.

Is there a better way to compute x_i's without computing the product P directly?

Yes, perhaps we can compute P as the least common multiple (LCM) of the k_i's, rather than the product.

But even then, for k_i up to 20 and n up to 50, LCM could still be large.

Wait, the LCM of numbers up to 20 is the LCM of 1 to 20, which is 232792560.

That's a big number, but it's within the range of standard integer types in Python.

But if n is up to 50, and k_i can be up to 20, but since n outcomes are independent of k_i values beyond 20, as k_i <=20, the LCM is still 232792560.

So, in Python, we can handle this.

But perhaps we can find a better approach that doesn't involve such large numbers.

Let me think differently.

Suppose I set x_i = m / k_i, where m is a common multiple of all k_i's.

But m needs to be an integer, so m should be a multiple of LCM of k_i's.

But then x_i would be integers only if m is a multiple of LCM.

This seems similar to the earlier approach.

Alternatively, perhaps I can set x_i proportional to some values that satisfy the conditions.

Wait, perhaps I can use the formula x_i = c / k_i, where c is a constant.

But x_i need to be integers, so c must be a multiple of k_i.

Wait, this is similar to the earlier approach.

Alternatively, perhaps I can set x_i = a_i * t, where t is a positive integer and a_i are some base values.

Then, S = sum a_i * t

And for each i, S < k_i * a_i * t

Which implies t * sum a_i < t * k_i * a_i

Divide both sides by t (assuming t >0):

sum a_i < k_i * a_i

Which is the same as sum a_j < k_i * a_i for all i.

This seems similar to the earlier inequalities.

So, perhaps choosing a_i proportional to 1/k_i.

But I need a_i to be positive integers.

This is getting a bit too abstract.

Let me look back at the initial approach.

If sum_{j=1 to n} 1 / k_j < 1, then set x_i = P / k_i, where P is the product of all k_j's.

This should work, as shown earlier.

And if sum_{j=1 to n} 1 / k_j >=1, then no solution exists.

So, in the code, I can compute sum of 1/k_j.

If this sum >=1, output -1.

Else, compute P = product of all k_j's.

Then, set x_i = P / k_i.

And output these x_i's.

Given that P can be large, but in Python, integers can be arbitrarily large, so it should handle it.

But in the problem, it's guaranteed that if a solution exists, there's a solution with x_i <=10^9.

So, perhaps there's a way to scale down P to a smaller value.

Wait, instead of taking P as the product of all k_j's, perhaps I can take P as the LCM of all k_j's.

This would make P smaller, and thus x_i = P / k_i would also be smaller.

Given that k_i <=20, the LCM of k_i's is the LCM of numbers up to 20, which is 232792560, as earlier.

This is acceptable in Python.

So, in the code, I can compute the sum of 1/k_j.

If this sum >=1, output -1.

Else, compute P as the LCM of all k_j's.

Then, set x_i = P / k_i.

And output these x_i's.

I need to implement LCM computation in Python.

Python has math.lcm, which can compute LCM of two or more numbers.

So, I can use that.

Let me sketch the code structure.

Read t, the number of test cases.

For each test case:

Read n.

Read list a of n integers k1 to kn.

Compute sum_s = sum of 1/k_j for j=1 to n.

If sum_s >=1:

Output -1

Else:

Compute P = lcm of all k_j's.

Then, x_i = P // k_i for each i.

Output x1 x2 ... xn

This should work.

Now, let's verify this with the example given.

First test case:

n=3

k=3,2,7

sum_s = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 <1

So, solution exists.

P = lcm of 3,2,7.

LCM of 3,2,7 is 42.

x1 = 42//3 =14

x2 =42//2=21

x3=42//7=6

Total sum S=14+21+6=41

Check:

For outcome 1: 3*14=42 >41

For outcome 2:2*21=42>41

For outcome 3:7*6=42>41

So, this works.

But in the example output, it's 27 41 12.

That's a different solution, but both are valid.

So, multiple solutions exist.

Second test case:

n=2

k=3,3

sum_s=1/3 +1/3=2/3 <1

P=lcm(3,3)=3

x1=3//3=1

x2=3//3=1

Sum S=1+1=2

Check:

Outcome1:3*1=3>2

Outcome2:3*1=3>2

Good.

Third test case:

n=5

k=5,5,5,5,5

sum_s=5*(1/5)=1 >=1

So, output -1

Fourth test case:

n=6

k=7,9,3,17,9,13

sum_s=1/7 +1/9 +1/3 +1/17 +1/9 +1/13

Let's calculate:

1/7 ≈0.1429

1/9≈0.1111

1/3≈0.3333

1/17≈0.0588

1/9≈0.1111

1/13≈0.0769

Sum≈0.1429+0.1111+0.3333+0.0588+0.1111+0.0769≈0.8341 <1

So, solution exists.

P=lcm(7,9,3,17,9,13)

LCM of 7,9,3,17,13.

First, prime factors:

7:7

9:3^2

3:3

17:17

13:13

So, LCM=3^2 *7 *13 *17= 9*7=63, 63*13=819, 819*17=13923

x1=13923//7=1989

x2=13923//9=1547

x3=13923//3=4641

x4=13923//17=819

x5=13923//9=1547

x6=13923//13=1071

Sum S=1989+1547+4641+819+1547+1071=11614

Check:

Outcome1:7*1989=13923>11614

Outcome2:9*1547=13923>11614

Outcome3:3*4641=13923>11614

Outcome4:17*819=13923>11614

Outcome5:9*1547=13923>11614

Outcome6:13*1071=13923>11614

All conditions satisfied.

Fifth test case:

n=3

k=6,3,2

sum_s=1/6 +1/3 +1/2=1/6 +2/6 +3/6=6/6=1 >=1

So, output -1

Sixth test case:

n=5

k=9,4,6,8,3

sum_s=1/9 +1/4 +1/6 +1/8 +1/3

Calculate:

1/9≈0.1111

1/4=0.25

1/6≈0.1667

1/8=0.125

1/3≈0.3333

Sum≈0.1111+0.25+0.1667+0.125+0.3333≈0.9861 <1

So, solution exists.

P=lcm(9,4,6,8,3)

Prime factors:

9:3^2

4:2^2

6:2*3

8:2^3

3:3

LCM=2^3 *3^2=8*9=72

x1=72//9=8

x2=72//4=18

x3=72//6=12

x4=72//8=9

x5=72//3=24

Sum S=8+18+12+9+24=71

Check:

Outcome1:9*8=72>71

Outcome2:4*18=72>71

Outcome3:6*12=72>71

Outcome4:8*9=72>71

Outcome5:3*24=72>71

All conditions satisfied.

So, this approach works.

Now, in the code, I need to implement this logic.

First, read t.

For each test case:

Read n.

Read list a of n integers.

Compute sum_s = sum of 1/k_j for j=1 to n.

If sum_s >=1:

Output -1

Else:

Compute P = lcm of all k_j's.

Then, x_i = P // k_i for each i.

Output x1 x2 ... xn

In Python, to compute LCM of a list of numbers, I can write a function that computes LCM of two numbers and then apply it iteratively to the list.

Python's math.lcm can take multiple arguments, so it's straightforward.

Also, since k_i >=2 and n <=50, and sum of n over all test cases <=2e5, it should be efficient enough.

Edge cases to consider:

- n=1: If k1 >1, then x1=1 satisfies since k1*x1 =k1 > x1.

But sum S=x1=1, and k1*1 >1 if k1 >1.

So, valid.

- n=1, k1=1: But k_i >=2 as per constraints, so k1=1 is not possible.

- n=2, k1=2, k2=2: sum_s=1/2 +1/2=1 >=1, so no solution.

- n=3, k1=2, k2=3, k3=6: sum_s=1/2 +1/3 +1/6=1, which is >=1, so no solution.

Wait, 1/2 +1/3 +1/6=1, not less than 1.

Hence, no solution.

Another point: since k_i >=2, the smallest sum_s is when n=1, k1=2: sum_s=1/2 <1, which has a solution.

For n=2, k1=2, k2=3: sum_s=5/6 <1, has a solution.

As n increases, sum_s increases, but since k_i >=2, sum_s can be up to n/2.

But per constraints, n<=50, k_i<=20, so sum_s <=n/2 <=25, which is way above 1, but in practice, for sum_s <1, n needs to be small or k_i's need to be large.

But in the problem, n can be up to 50, but k_i up to 20, so sum_s can be up to 50/2=25, which is much larger than 1.

Hence, only small n or large k_i's will have sum_s <1.

But per the approach, as long as sum_s <1, a solution exists.

Now, in the code, I need to ensure that I compute sum_s accurately.

Since k_i can be up to 20, and n up to 50, sum_s can be up to 50/2=25, which is fine.

I need to check if sum_s <1.

If yes, compute P=lcm of all k_i's.

Then, x_i = P // k_i.

Output x_i's.

Else, output -1.

Implementing this in code.

Also, need to handle multiple test cases efficiently.

Given that sum of n over all test cases <=2e5, and n<=50, operations are efficient.

Hence, this should work.

## Final Solution
To solve this problem, we need to determine how to distribute bets on possible outcomes in a game such that, regardless of which outcome wins, the total coins received are strictly more than the total coins bet. 

### Approach
1. **Read Inputs**: Read the number of test cases and, for each test case, read the number of outcomes and their respective multipliers.
2. **Check Feasibility**:
    - Calculate the sum of the reciprocals of the multipliers.
    - If this sum is greater than or equal to 1, it is impossible to find such a distribution, and we output `-1`.
3. **Compute Bets**:
    - If the sum is less than 1, compute the least common multiple (LCM) of the multipliers.
    - Distribute bets proportionally by setting each bet to the LCM divided by the respective multiplier.
    - Output the computed bets.

### Solution Code
```python
import math
from functools import reduce

def compute_lcm(a, b):
    return abs(a*b) // math.gcd(a, b)

def lcm_list(numbers):
    return reduce(compute_lcm, numbers)

def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        k = list(map(int, input().split()))
        sum_reciprocals = sum(1 / ki for ki in k)
        if sum_reciprocals >= 1:
            print(-1)
        else:
            P = lcm_list(k)
            x = [P // ki for ki in k]
            print(' '.join(map(str, x)))

if __name__ == "__main__":
    func()
```

### Explanation
1. **Feasibility Check**:
    - We calculate the sum of the reciprocals of the multipliers. If this sum is greater than or equal to 1, no solution exists because the total bet cannot be outweighed by any single outcome's return.
2. **Bet Calculation**:
    - Compute the least common multiple (LCM) of the multipliers.
    - Each bet is set to the LCM divided by the respective multiplier, ensuring that the return from any winning outcome exceeds the total bets.
3. **Efficiency**:
    - The LCM computation is efficient for the given constraints (n ≤ 50, k_i ≤ 20).
    - The solution handles multiple test cases efficiently, ensuring it runs within acceptable time limits.

This approach guarantees that the bets are distributed correctly to satisfy the problem's conditions, and it is implemented efficiently to handle the upper limits of the input constraints.