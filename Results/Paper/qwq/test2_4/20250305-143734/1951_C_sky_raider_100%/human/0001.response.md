Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm the CEO of a startup, and I need to buy tickets for my employees to a concert. There are n days to buy tickets, and each day has a certain price per ticket. There's a limit on how many tickets I can buy per day, which is m, and I need to buy exactly k tickets in total.

Additionally, there's this rule that if I buy x tickets on a particular day, then from the next day onwards, the price per ticket increases by x. That seems like a penalty to prevent hoarding, yeah? So, I need to be careful about how many tickets I buy each day to minimize the total cost.

First, I need to understand the problem fully. Let's look at the example to get a better grasp.

In the first test case:

4 days, m=2, k=3

Prices: 8, 6, 4, 2

The optimal way is to buy 0 on day 1, 0 on day 2, 1 on day 3, and 2 on day 4, totaling 10.

Wait, buying 0 on day 1 means no price increase for subsequent days. Then, buying 0 on day 2 again means no further increases. On day 3, buy 1 ticket at 4, and then on day 4, buy 2 tickets at 2 each, but wait, since you bought 1 on day 3, the price on day 4 increases by 1, so it's 2 + 1 = 3 per ticket.

So, cost on day 3: 1 * 4 = 4

Cost on day 4: 2 * 3 = 6

Total: 10

Okay, that makes sense.

In the second test case:

4 days, m=2, k=8

Prices: 8, 6, 4, 2

Buy 2 on day 1: cost 16, prices increase by 2 for next days: [8+2, 6+2, 4+2] = [10, 8, 6]

Buy 2 on day 2: cost 16, prices increase by 2 again: [10+2, 8+2] = [12, 10]

Buy 2 on day 3: cost 12, prices increase by 2: [12+2] = [14]

Buy 2 on day 4: cost 14

Total: 16 + 16 + 12 + 14 = 64

Seems consistent.

So, the goal is to minimize the total cost by deciding how many tickets to buy each day, given the constraints on daily purchases and the increasing prices.

Let me think about how to approach this.

First, I need to consider that buying tickets on a particular day increases the prices for all subsequent days. So, buying more on earlier days might seem costly because you're also increasing future prices, but it might be beneficial if the price on that day is significantly lower than future days.

Wait, in the first example, buying on later days when prices are lower seems better, but I have to account for the price increases on future days.

This seems like a dynamic programming problem, where I need to decide for each day how many tickets to buy, considering the impact on future days.

But given the constraints, n can be up to 3e5, and t up to 1e4, so a straightforward DP might be too slow.

I need a more efficient approach.

Let me consider that the price on day i is a_i plus the total number of tickets bought on previous days.

Wait, no. The price increase is based on the number of tickets bought on any day, not just previous days. Wait, actually, reading the problem again: "If a person purchases x tickets on day i, all subsequent days (i.e., from day i+1 onwards) will have their prices per ticket increased by x."

So, the price on day j > i is a_j plus the sum of x for all days i < j.

Wait, no. It's "from day i+1 onwards, prices are increased by x if x tickets are bought on day i."

So, the price on day j is a_j plus the sum of x for all days i < j.

Wait, more precisely, the price increase is cumulative based on the number of tickets bought on or before day i.

Wait, no. Let's clarify:

- Initially, prices are a_1, a_2, ..., a_n.

- If you buy x tickets on day i, then for all days j > i, the price per ticket becomes a_j + x.

- Moreover, this increase is additive. So, if you buy x1 on day 1, x2 on day 2, etc., then on day j, the price is a_j plus x1 + x2 + ... + x_{j-1}.

Yes, that's the cumulative sum.

So, the price on day j is a_j plus the total number of tickets bought before day j.

Given that, I need to decide how many tickets to buy each day, up to m per day, to total exactly k tickets, such that the sum of the costs is minimized.

This seems complex, but maybe there's a way to simplify it.

Let me consider that the effective price on day i is a_i plus the total number of tickets bought on previous days.

Let me denote s_i as the number of tickets bought on day i.

Then, the price per ticket on day i is a_i + sum_{j=1}^{i-1} s_j.

And s_i <= m for all i, and sum_{i=1}^n s_i = k.

The total cost is sum_{i=1}^n s_i * (a_i + sum_{j=1}^{i-1} s_j).

This seems tricky to minimize directly.

Maybe I can rearrange the terms.

Let me expand the cost:

sum_{i=1}^n s_i * a_i + sum_{i=1}^n s_i * sum_{j=1}^{i-1} s_j

The first term is straightforward, but the second term is the tricky one, as it involves the product of s_i and the sum of previous s_j.

This seems non-linear and difficult to optimize directly.

Perhaps there's a better way to approach this.

Let me think about the overall increase in price.

Since each ticket bought on a day increases the price for all future days, there is a penalty for buying tickets early.

Specifically, buying a ticket on day i imposes an additional cost of 1 for every ticket bought on all subsequent days.

Wait, no. Actually, buying x tickets on day i increases the price by x for all subsequent days.

So, the total additional cost due to buying x tickets on day i is x * (sum of s_j for j > i).

So, the total cost can be expressed as:

sum_{i=1}^n s_i * a_i + sum_{i=1}^n s_i * (sum_{j=i+1}^n s_j)

Which is sum_{i=1}^n s_i * a_i + sum_{i=1}^n sum_{j=i+1}^n s_i * s_j

This is still complicated.

Maybe I can think of it differently.

Let me consider that the total cost is equivalent to sum_{i=1}^n s_i * (a_i + t_i), where t_i is the total number of tickets bought before day i.

Wait, t_i = sum_{j=1}^{i-1} s_j.

So, cost is sum_{i=1}^n s_i * (a_i + t_i)

Let me denote t_i = sum_{j=1}^{i-1} s_j

Then, t_1 = 0

t_2 = s_1

t_3 = s_1 + s_2

...

t_n = s_1 + s_2 + ... + s_{n-1}

So, the cost is sum_{i=1}^n s_i * (a_i + t_i)

I need to minimize this sum, with sum_{i=1}^n s_i = k and s_i <= m for all i.

This seems like a problem that can be approached using priority queues or greedy algorithms, given the large constraints.

I recall that in problems where we have to minimize the sum of products with increasing penalties, a greedy approach often works.

Let me think about sorting the days in some order to minimize the cost.

If I sort the days based on their base prices, a_i, and consider buying tickets on the days with the lowest a_i first, that might be beneficial.

But I have to be careful because buying tickets on a day with a low a_i increases the prices for future days.

Wait, in the first example, buying on later days with lower a_i seems better, but the price increases for future days.

Wait, but in the first example, buying on day 3 and day 4 was better because their base prices were lower, and since I bought only 1 on day 3, the price increase for day 4 was minimal.

It's tricky.

Maybe I should consider the days in order, and decide how many tickets to buy each day, considering the cumulative increase.

Alternatively, perhaps I can consider the days in sorted order of a_i and decide how to allocate the tickets.

Wait, but the days are sequence-dependent because of the cumulative price increases.

This seems complicated.

Let me consider a different approach.

Suppose I fix the number of tickets bought on each day, s_i, and compute the total cost.

I need to choose s_i such that sum s_i = k and s_i <= m for all i.

The cost is sum s_i * (a_i + sum_{j=1}^{i-1} s_j)

This seems similar to minimizing a sum with a cumulative penalty.

Maybe I can model this as a linear assignment problem, but that seems too slow for n up to 3e5.

Wait, perhaps I can think in terms of prefix sums.

Let me denote t_i = sum_{j=1}^i s_j, the total tickets bought up to day i.

Then, t_0 = 0, t_n = k.

And the cost on day i is s_i * (a_i + t_{i-1})

So, total cost is sum_{i=1}^n s_i * (a_i + t_{i-1})

Since t_{i-1} = t_i - s_i

Wait, t_{i-1} = t_i - s_i

So, cost is s_i * (a_i + t_i - s_i) = s_i * a_i + s_i * t_i - s_i^2

Sum over all i: sum s_i * a_i + sum s_i * t_i - sum s_i^2

But t_i = t_{i-1} + s_i = (t_i - s_i) + s_i = t_i

Wait, this seems circular.

Maybe this isn't helping.

Let me try to express everything in terms of t_i.

Since t_i = sum_{j=1}^i s_j

Then, s_i = t_i - t_{i-1}

So, cost is sum_{i=1}^n (t_i - t_{i-1}) * (a_i + t_{i-1})

Let me expand this:

= sum_{i=1}^n [t_i * a_i + t_i * t_{i-1} - t_{i-1} * a_i - t_{i-1}^2]

This seems messy.

Maybe there's another way.

Let me consider the cost difference between buying a ticket on day i versus day j.

If I buy a ticket on day i, the cost is a_i + t_{i-1}, where t_{i-1} is the total tickets bought before day i.

If I buy a ticket on day j > i, the cost is a_j + t_{j-1}.

But t_{j-1} = t_{i-1} + s_i + s_{i+1} + ... + s_{j-1}

So, it's complicated.

Wait, maybe I can think in terms of the incremental cost of buying an additional ticket on a particular day.

Let me consider that for each day, I can buy up to m tickets, and each ticket bought on that day adds to the base price plus the total tickets bought before that day.

So, perhaps I should prioritize buying tickets on days where the base price plus the accumulated t is the smallest.

This sounds like a greedy approach: always buy on the day with the current lowest price plus accumulated t.

But I need to be careful because the accumulated t changes as I buy tickets on previous days.

This seems tricky to implement efficiently.

Let me think differently.

Suppose I fix the order of the days and decide how many tickets to buy on each day in that order.

I need to process the days in a specific sequence, considering the cumulative impact on future days.

Alternatively, maybe I can process the days in order, and for each day, decide how many tickets to buy, given the current cumulative increase.

But deciding the optimal number each time seems challenging.

Wait, perhaps I can model this as a minimum cost flow problem, where each day is a node, and I have edges representing the number of tickets bought each day, with costs accordingly.

But that might be too slow for n up to 3e5.

I need a smarter approach.

Let me consider the following idea:

Since the price on day i is a_i plus the total number of tickets bought before day i, which is t_{i-1}.

So, the cost of buying s_i tickets on day i is s_i * (a_i + t_{i-1}).

I need to choose s_i for each i such that sum s_i = k, s_i <= m, and the total cost is minimized.

This looks like minimizing sum s_i * (a_i + t_{i-1}), with t_i = t_{i-1} + s_i.

This seems similar to minimizing a sum with increasing coefficients.

Perhaps I can sort the days based on a_i + t_{i-1}, but t_{i-1} depends on previous s_i, so it's not straightforward.

Wait, maybe I can think of it in terms of the base price a_i and the incremental cost due to t_{i-1}.

Since t_{i-1} is the sum of s_j for j from 1 to i-1, which is accumulated as I process the days.

This seems like a dependent system.

Let me consider processing the days in order, and for each day, decide how many tickets to buy, considering the current t_{i-1}.

But how to decide optimally?

Perhaps I can maintain a priority queue of days, sorted by their current effective price (a_i + t_{i-1}), and always buy tickets on the day with the lowest current effective price.

But with the constraints on m per day, this might not be directly applicable.

Wait, but n can be up to 3e5, and t up to 1e4, so I need an efficient solution.

Let me think about the example again.

In the first example:

n=4, m=2, k=3

a = [8,6,4,2]

In the optimal solution, buy 0 on day 1, 0 on day 2, 1 on day 3, and 2 on day 4, total cost 10.

If I had bought 1 on day 1, then t would be 1, and prices for day 2 onwards would be [7,5,3]. Then, buying 1 on day 2 (cost 7), and 1 on day 3 (cost 6), total cost 8 + 7 + 6 = 21, which is worse.

So, delaying the purchases to days with lower base prices is better, as long as the accumulated t doesn't increase too much.

Wait, in this case, buying on day 4 is best because its base price is lowest, and by buying there, I minimize the impact on previous days.

But in the second example, where k=8 and m=2, buying the maximum each day is optimal,似乎与第一种情况相反。

所以，可能需要根据具体情况来决定。

让我再想想。

假设我有无限的m，可以每天买任意数量的票，那么最优策略是什么？

在这种情况下，我可以在价格最低的天买所有票，但考虑到价格是累加的，可能需要更谨慎。

但实际情况是m有限，每天最多买m张。

所以，我需要在每天买最多m张，或者买较少的张数，以平衡当前成本和未来价格的增加。

这确实很复杂。

也许我应该考虑将天数排序，根据某种关键因素，然后决定在这些排序后的天数上买多少票。

但天数是有顺序的，不能随意重新排列。

Wait, maybe I can sort the days based on a_i, and try to buy tickets on the days with the lowest a_i first, but considering the impact on future days.

但这可能不总是最优的，因为买票会增加未来日子的价格。

也许我需要找到一种方式来计算每个日子的票的真正成本，包括它对 future days 的影响。

这听起来很复杂。

让我尝试提出一种算法，然后检查它是否正确。

算法想法：

1. 按 a_i 从小到大排序日子。

2. 优先在 a_i 较低的日子购买票，但需要考虑购买票对 future days 的价格影响。

但这与日子的顺序有关，因为日子是有顺序的，不能随意排序。

Wait, maybe I can process the days in order, and for each day, decide how many tickets to buy based on the current cumulative t.

But I need to make decisions that minimize the total cost.

This seems too vague.

Let me consider the following approach:

- Initialize t = 0

- For each day i from 1 to n:

- The current price per ticket on day i is a_i + t

- Decide how many tickets to buy on day i, say s_i, where 0 <= s_i <= m

- Update t += s_i

- Ensure that the total sum of s_i equals k

The problem is to choose s_i for each day to minimize the total cost sum s_i * (a_i + t)

This seems like a dynamic programming problem, where the state is the current day and the current t.

But with n up to 3e5 and k up to 1e9, this is not feasible.

I need a better approach.

Let me consider the following observation:

The total cost can be expressed as sum s_i * a_i + sum s_i * t_{i-1}

Since t_{i-1} = sum_{j=1}^{i-1} s_j

So, the total cost is sum s_i * a_i + sum s_i * sum_{j=1}^{i-1} s_j

This can be rewritten as sum s_i * a_i + sum_{1 <= j < i <= n} s_i * s_j

This seems complicated.

Wait, perhaps I can think of the total cost as sum s_i * a_i + sum_{i=1}^n s_i * (sum_{j=1}^{i-1} s_j)

Which is sum s_i * a_i + sum_{i=1}^n s_i * t_{i-1}

Since t_{i-1} is the total tickets bought before day i.

This still seems tricky.

Let me consider that the total cost is sum s_i * (a_i + t_{i-1})

So, for each day i, the cost per ticket is a_i + t_{i-1}, and I buy s_i tickets.

I need to choose s_i <= m for each i, with sum s_i = k, to minimize sum s_i * (a_i + t_{i-1})

This seems like a linear cost minimization problem with constraints.

But with n up to 3e5, I need an efficient way to compute this.

Let me think about the greedy approach.

Suppose I always buy tickets on the day with the current lowest cost per ticket, which is a_i + t_{i-1}

So, I can process the days in order, keeping a priority queue of days based on a_i + t_{i-1}, and always buy as many tickets as possible on the day with the lowest current cost.

But I need to be careful because buying tickets on one day affects the cost on future days.

Wait, perhaps I can use a priority queue to keep track of the days sorted by their current a_i + t, and always buy tickets on the day with the lowest current cost, updating the t accordingly.

But with n up to 3e5, this might be too slow if I use a standard priority queue.

I need a more efficient way.

Let me consider sorting the days based on a_i in ascending order and decide how many tickets to buy on each day in that order.

But again, since days have a specific order and buying tickets on earlier days increases the prices for later days, this might not be directly applicable.

Wait, maybe I can sort the days based on a_i + some estimation of t, but t depends on previous decisions.

This is getting too vague.

Let me consider another angle.

Suppose I fix the number of tickets bought on each day, s_i, and I need to minimize sum s_i * (a_i + sum_{j=1}^{i-1} s_j)

Let me denote t_i = sum_{j=1}^{i-1} s_j

Then, the cost is sum s_i * (a_i + t_i)

I can think of this as sum (s_i * a_i) + sum (s_i * t_i)

I need to minimize this sum.

But t_i depends on previous s_j, so it's interconnected.

This seems like a system of equations that is hard to solve directly.

Maybe I can consider the dual problem or use some mathematical optimization technique.

But given the time constraints, I need a simpler approach.

Let me consider that the total cost is equal to sum s_i * a_i + sum_{1 <= j < i <= n} s_i * s_j

This can be rewritten as sum s_i * a_i + (sum s_i)^2 - sum s_i^2

Wait, let's see:

sum_{1 <= j < i <= n} s_i * s_j = sum_{i=1}^n s_i * sum_{j=1}^{i-1} s_j = sum s_i * t_{i-1}

But I'm not sure if that helps.

Wait, perhaps I can consider the total cost as sum s_i * a_i + sum_{i=1}^n s_i * t_{i-1}

And t_i = t_{i-1} + s_i

So, t_{i-1} = t_i - s_i

Wait, that might not lead anywhere.

Let me think differently.

Suppose I fix the total number of tickets bought up to each day, t_i.

Then, s_i = t_i - t_{i-1}

And the cost on day i is s_i * (a_i + t_{i-1})

So, total cost is sum s_i * (a_i + t_{i-1}) = sum (t_i - t_{i-1}) * (a_i + t_{i-1})

Let me expand this:

= sum (t_i * a_i + t_i * t_{i-1} - t_{i-1} * a_i - t_{i-1}^2)

This seems even more complicated.

Maybe I need to accept that this is a hard problem and look for a different strategy.

Wait, perhaps I can consider that the problem can be transformed into a minimum cost matching or something similar.

But again, with the constraints, it's unlikely.

Let me look at the provided code and see what it's doing.

The code is:

def func():

for i in range(int(input())):

(n, m, k) = map(int, input().split())

l = list(map(int, input().split()))

l.sort()

t = 0

s = 0

c = 0

for i in range(n):

s = min(m, k)

c += s * (l[i] + t)

t += s

k -= s

print(int(c))

So, it reads the input, sorts the list of prices, and then iterates through the sorted list, buying up to m tickets per day, considering the cumulative t.

Wait, but in the problem, the days have a specific order, and the price increases are based on the cumulative tickets bought up to that day.

But in the code, it sorts the list of prices and processes them in sorted order, which might not correspond to the original day order.

Is this correct?

In the first example, the prices are [8,6,4,2], which sorted become [2,4,6,8].

Then, it buys up to m=2 tickets per day.

Day 1: buy 2 tickets at 2 + 0 = 2 each, t=2, cost=4, k=1

Day 2: buy 1 ticket at 4 + 2 = 6, t=3, cost=6, k=0

Total cost=10, which matches the first example.

So, in this case, it works.

In the second example:

n=4, m=2, k=8

a=[8,6,4,2], sorted [2,4,6,8]

Day 1: buy 2 at 2 + 0 = 2, t=2, cost=4, k=6

Day 2: buy 2 at 4 + 2 = 6, t=4, cost=12, k=4

Day 3: buy 2 at 6 + 4 = 10, t=6, cost=20, k=2

Day 4: buy 2 at 8 + 6 = 14, t=8, cost=28, k=0

Total cost=4+12+20+28=64, which matches the second example.

So, in these cases, it seems to work.

But is this approach generally correct?

Let me think about what the code is doing.

It sorts the prices in ascending order and then buys up to m tickets per day, in order of the sorted prices, considering the cumulative t.

This seems to be equivalent to always buying tickets on the days with the lowest original prices, but after sorting, without considering the original day order.

But in the problem, the days have a specific sequence, and the price increases are cumulative based on previous purchases.

However, in the code, by sorting the prices and processing them in sorted order, it's effectively treating the days as if their prices were independent of their original order.

But in reality, the price increases are dependent on the day sequence.

Yet, in the examples, it seems to work.

Is there something about the problem that allows us to sort the days based on their prices and process them in that order?

Let me consider another example.

Suppose n=2, m=1, k=2

a=[1,100]

Sorted a=[1,100]

Day 1: buy 1 ticket at 1 + 0 =1, t=1, cost=1, k=1

Day 2: buy 1 ticket at 100 + 1 =101, t=2, cost=101, k=0

Total cost=102

Is this the minimal cost?

Alternative approach:

Buy 1 ticket on day 2 at 100 + 0=100, then buy 1 ticket on day 1 at 1 + 1=2, total cost=100+2=102, same as above.

So, in this case, it works.

Another example:

n=3, m=1, k=3

a=[1,2,3]

Sorted a=[1,2,3]

Day 1: buy 1 at 1 + 0=1, t=1, cost=1, k=2

Day 2: buy 1 at 2 + 1=3, t=2, cost=3, k=1

Day 3: buy 1 at 3 + 2=5, t=3, cost=5, k=0

Total cost=1+3+5=9

Alternative approach:

Buy on day 1: 1 at 1 + 0=1, t=1

Then day 2: 1 at 2 + 1=3, t=2

Day 3: 1 at 3 + 2=5, t=3

Same as above.

Seems no better way.

Another example:

n=2, m=2, k=2

a=[1,100]

Sorted a=[1,100]

Day 1: buy 2 at 1 + 0=1, t=2, cost=2, k=0

Total cost=2

Alternative approach:

Buy 1 on day 1 at 1 + 0=1, t=1, cost=1

Buy 1 on day 2 at 100 + 1=101, t=2, cost=101

Total=102, which is worse.

So, in this case, buying on the day with the lowest price is better.

Another example:

n=3, m=1, k=3

a=[3,2,1]

Sorted a=[1,2,3]

Day 1: buy 1 at 1 + 0=1, t=1, cost=1, k=2

Day 2: buy 1 at 2 + 1=3, t=2, cost=3, k=1

Day 3: buy 1 at 3 + 2=5, t=3, cost=5, k=0

Total=9

Alternative approach:

Buy 1 on day 3 at 1 + 0=1, t=1

Buy 1 on day 2 at 2 + 1=3, t=2

Buy 1 on day 1 at 3 + 2=5, t=3

Total=1+3+5=9, same as above.

Seems consistent.

Wait, but in this case, buying on the lowest price days first is better, but due to the cumulative t, it ends up the same as buying in the original day order.

It seems that sorting the days based on a_i and buying on the days with the lowest a_i first leads to the minimal cost.

But why does this work?

Because by buying on the days with the lowest a_i first, you minimize the base price, and although t increases, the impact on future days is minimized because you're buying on days with lower base prices.

Wait, but in the first example, buying on day 4 (a_i=2) first, then day 3 (a_i=4), etc., seems to work.

But in the second example, buying on day 1 (a_i=8) first would be worse.

Wait, no, in the second example, sorted a_i are [2,4,6,8], so buying on the days with a_i=2 first, then a_i=4, etc.

But in reality, day 1 has a_i=8, which is the highest, so buying there first would be bad.

Hence, sorting allows us to prioritize buying on days with the lowest a_i, regardless of their original order.

This seems to be a correct approach.

So, the code sorts the prices in ascending order and then buys up to m tickets per day, in order of the sorted prices, considering the cumulative t.

This seems to be a correct solution.

Hence, the answer is True.

## Final Solution
To solve this problem, we need to minimize the cost of purchasing exactly `k` tickets over `n` days, given that the price per ticket increases based on the number of tickets purchased on previous days. 

### Approach

1. **Input Parsing**: Read the number of test cases and, for each test case, read the values of `n`, `m`, and `k`, followed by the list of ticket prices for each day.
2. **Sorting Prices**: Sort the list of ticket prices in ascending order. This allows us to buy tickets from the cheapest days first, minimizing the overall cost.
3. **Cumulative Ticket Purchase**: Initialize variables to keep track of the total cost (`c`), the cumulative number of tickets bought (`t`), and the remaining number of tickets to buy (`k`).
4. **Iterate Through Sorted Prices**: For each day in the sorted list:
   - Determine the number of tickets to buy on that day, which is the minimum of `m` and `k`.
   - Calculate the cost for these tickets, considering the increased price due to previously purchased tickets (`t`).
   - Update the cumulative cost (`c`), the cumulative number of tickets (`t`), and the remaining tickets (`k`).
5. **Output the Result**: Print the total cost for each test case.

### Solution Code

```python
def func():
    for _ in range(int(input())):
        n, m, k = map(int, input().split())
        l = list(map(int, input().split()))
        l.sort()
        t = 0
        c = 0
        for price in l:
            s = min(m, k)
            c += s * (price + t)
            t += s
            k -= s
            if k == 0:
                break
        print(int(c))

func()
```

### Explanation

1. **Input Parsing**: The function reads the number of test cases and processes each test case one by one.
2. **Sorting Prices**: By sorting the ticket prices, we ensure that we attempt to buy tickets on the cheapest days first.
3. **Cumulative Ticket Purchase**: We use a loop to iterate through each day in the sorted order:
   - Calculate the number of tickets to buy on the current day (`s`), which is the minimum of the allowed daily maximum (`m`) and the remaining tickets (`k`).
   - Compute the cost for these tickets, considering the base price of the day plus the increment due to previously purchased tickets (`t`).
   - Update the cumulative variables: add the cost to `c`, increase `t` by `s`, and decrease `k` by `s`.
   - If all tickets are purchased (`k == 0`), break out of the loop to avoid unnecessary computations.
4. **Output the Result**: Print the total cost for each test case.

This approach ensures that we minimize the cost by prioritizing purchases on days with lower base prices, taking into account the incremental price increases due to previous purchases.