Alright, I have this problem to solve. It's about trees in graph theory, and I need to find the maximum number x such that when I remove exactly k edges from the tree, each of the resulting connected components has at least x vertices. Okay, let's break this down.

First, I need to understand what a tree is. A tree is a connected graph with no cycles, and it has exactly n-1 edges for n vertices. So, in this problem, I'm given a tree with n vertices and n-1 edges, and I need to remove k edges from it.

The goal is to remove exactly k edges so that each of the resulting connected components has at least x vertices. I need to find the maximum possible x that allows this to happen.

Let's look at the example provided to get a better understanding.

In the first test case:

n = 5, k = 1

Edges:

1-2

1-3

3-4

3-5

So, the tree looks like this:

- 1 is connected to 2 and 3

- 3 is connected to 4 and 5

If I remove the edge between 1 and 3, I get two components:

- One with vertices 1 and 2

- Another with vertices 3, 4, and 5

Both components have at least 2 vertices, so x = 2 is possible.

The problem states that x = 3 is not achievable, so the answer is 2.

From this, I can see that I need to remove edges in such a way that the smallest component has the largest possible size.

I need to maximize x, which means I need to ensure that after removing k edges, all components have at least x vertices.

This sounds like a binary search problem on x, where for each x, I check if it's possible to remove exactly k edges and have all components have at least x vertices.

So, I can perform a binary search on x, from 1 to n.

For each x, I need to check if I can remove exactly k edges such that all components have at least x vertices.

But how do I check this efficiently, especially since n can be up to 10^5 and t can be up to 10^4, with the sum of n across all test cases up to 10^5?

I need an efficient way to check for each x whether it's possible to remove exactly k edges and have all components have at least x vertices.

Let me think about the properties of trees. In a tree, removing an edge always increases the number of connected components by exactly one.

So, originally, there is one connected component. If I remove k edges, I will have k+1 connected components.

But I need to ensure that each of these components has at least x vertices.

So, the total number of vertices in all components should be n, and each component has at least x vertices.

Therefore, the number of components can be at most floor(n / x).

Wait, but I have to remove exactly k edges, which creates k+1 components.

So, k+1 <= floor(n / x)

Because each component must have at least x vertices, the number of components can't exceed n/x.

But this is a necessary condition, but is it sufficient?

Wait, no. It's possible that even if k+1 <= floor(n/x), it might not be possible to remove k edges to get components each with at least x vertices.

For example, consider a tree where one branch has fewer than x vertices, and the rest have more. If I remove an edge on that branch, I might end up with a component smaller than x.

So, I need a way to count how many edges I need to remove to ensure all components have at least x vertices.

Perhaps I can think in terms of counting the number of edges that connect a group of at least x vertices to another group.

Wait, maybe I can perform a DFS and calculate the size of each subtree, and then decide which edges to remove based on the subtree sizes.

Let me consider performing a DFS on the tree and calculating the size of each subtree.

For each edge, I can decide whether to remove it or not, based on the sizes of the subtrees it connects.

But with n up to 10^5 and t up to 10^4, I need an O(n) per test case solution, or at least O(n log n).

Given that, binary searching on x seems feasible, as long as I can check for each x in O(n) time.

So, for each x, I need to check if I can remove exactly k edges such that all components have at least x vertices.

Alternatively, I can think of it as finding the minimal number of edges to remove to ensure all components have at least x vertices, and then check if this minimal number equals k.

If the minimal number is less than or equal to k, then x is achievable, but I need exactly k edges to be removed, so I need to be careful.

Wait, actually, I need to remove exactly k edges, not necessarily the minimal number.

This seems a bit tricky.

Let me try to think differently.

Suppose I fix x and want to check if it's possible to remove exactly k edges such that all components have at least x vertices.

I can try to remove edges that, when removed, split the tree into components where each component has at least x vertices.

To maximize x, I need to ensure that the smallest component has as many vertices as possible.

This sounds like I need to remove edges that separate the tree into components of size at least x, and count how many such edges I need to remove.

But I need to remove exactly k edges, not more, not less.

Wait, maybe I can compute the number of edges that, if removed, would separate a subset of at least x vertices from the rest of the tree.

Then, I can try to remove k such edges and see if it's possible to have all components with at least x vertices.

This seems complicated.

Let me consider the following approach:

- Perform a DFS on the tree and calculate the size of each subtree.

- Then, for each edge, determine if removing it would result in two components, both with at least x vertices.

- If so, I can potentially remove that edge.

- I need to remove exactly k such edges.

But this might not be sufficient, because removing one edge might affect the sizes of the components for other edges.

Wait, perhaps I need to think in terms of the entire tree structure.

Let me consider the following plan:

- Perform a DFS to calculate the size of each subtree.

- Then, for a given x, find the minimal number of edges to remove to ensure all components have at least x vertices.

- If this minimal number is equal to k, then x is achievable.

- I need to maximize x.

To find the minimal number of edges to remove:

- I can iterate through all edges and check if removing them would result in two components, both with size at least x.

- The number of such edges that can be removed is the number of edges where both subtrees have size at least x.

- I need to remove exactly k such edges.

But this might not work, because removing one edge affects the sizes of the remaining subtrees.

Wait, perhaps I need to remove edges in a way that doesn't disconnect components that are already small.

This seems tricky.

Let me look at the reference solution to understand their approach.

In the reference solution, it seems like they are performing a binary search on x, and for each x, they are performing a DFS to count the number of cuts needed.

Specifically, in the DFS function, they are calculating the size of each subtree and deciding whether to cut the edge based on the subtree size being at least x.

Then, they are checking if the number of cuts equals k, or if it's less than k and the remaining component is at least x.

Wait, let's look at the code.

The function func_1 reads the input and iterates over t test cases.

For each test case:

- Read n and k

- Read the tree edges and build the adjacency list

- Perform a binary search on x from 1 to n

- For each x, perform a DFS to count the number of cuts needed

- If the number of cuts is greater than k, or equal to k and the remaining component is at least x, set L = x

- Otherwise, set R = x

- Finally, print L

The DFS function seems to calculate the size of subtrees and count the number of cuts needed.

Wait, in the DFS function, it's summing up the sizes of subtrees and checking if the subtree size is at least x to decide whether to make a cut.

Wait, but I need to understand this better.

Let me try to reimplement this logic step by step.

First, perform a binary search on x from 1 to n.

For each x, perform a DFS to count the number of edges that need to be removed to ensure all components have at least x vertices.

If the number of edges to be removed equals k, and the remaining components have at least x vertices, then x is achievable.

Otherwise, adjust the binary search range accordingly.

In the reference solution, they are using a global variable numCuts to count the number of cuts.

But in Python, using global variables in recursive functions can lead to issues, especially with multiple test cases.

So, I need to be careful with variable scopes.

Wait, in the provided code, numCuts is defined inside func_1, but in the DFS function, it's accessed as a global variable.

This might lead to errors if not handled properly.

I need to make sure that numCuts is reset for each test case and each binary search iteration.

Alternatively, I can pass numCuts as a parameter to the DFS function.

But that might not be efficient for large n.

Wait, perhaps I can redesign the DFS function to return the number of cuts needed and the size of the component.

Let me think about it.

I need to calculate the number of edges to remove such that all resulting components have at least x vertices.

To do this, I can perform a DFS and calculate the size of each subtree.

If a subtree has size >= x, I can consider it as a separate component by removing the edge connecting it to its parent.

Thus, the number of cuts needed would be the number of such subtrees with size >= x.

Wait, but this seems too simplistic.

Because if I remove an edge that separates a subtree of size >= x from the rest, I need to ensure that the remaining tree also has at least x vertices.

Wait, perhaps I need to count the number of subtrees with size >= x, and then see if removing the edges connecting them would result in all components having at least x vertices.

This is getting complicated.

Let me try to formalize the approach.

Define a function DFS(node, parent, x):

- Calculate the size of the subtree rooted at node.

- If the size of the subtree is >= x, then this subtree can be separated by removing the edge between node and parent.

- So, if node is not the root, increment the number of cuts by 1.

- Return the size of the subtree.

Then, for the entire tree, sum up the number of cuts needed.

If the number of cuts equals k, and the remaining component (the root's subtree) has at least x vertices, then x is achievable.

Wait, but in the reference solution, they are using a binary search to find the maximum x where the number of cuts is greater than k, or equal to k with the remaining component >= x.

Wait, in the reference solution, it seems like they are adjusting the binary search based on whether the number of cuts is greater than k, or equal to k and the remaining component is >= x.

Let me see.

In the binary search loop:

- Set x = (L + R) // 2

- Calculate numCuts by performing DFS

- If numCuts > k or (numCuts == k and leftover >= x), set L = x

- Else, set R = x

Here, leftover is the size of the root's subtree after removing the cuts.

So, if numCuts > k, meaning I need to remove more than k edges to achieve x, so I need to decrease x.

If numCuts == k and the remaining component is >= x, then x is achievable, so I can increase x.

Otherwise, decrease x.

Wait, but in the code, it's L = x when numCuts > k or (numCuts == k and leftover >= x).

This seems counterintuitive.

Wait, perhaps I need to adjust the binary search condition.

Let me think differently.

I need to find the maximum x such that the number of cuts needed is <= k, and the remaining component has at least x vertices.

Wait, but the problem requires removing exactly k edges.

So, it's a bit more nuanced.

I need to ensure that after removing k edges, all components have at least x vertices.

So, I need to find the maximum x where it's possible to remove exactly k edges and satisfy the condition.

This seems tricky to handle directly with a binary search.

Alternatively, perhaps I can compute the minimal number of edges to remove to ensure all components have at least x vertices, and then check if this number equals k.

If it's greater than k, x is too big.

If it's less than k, x is too small.

Wait, but if the minimal number of edges to remove is less than k, does that mean x is too small?

Not necessarily.

Wait, perhaps I need to think in terms of the number of components I need.

Originally, there is one component.

Each edge removal increases the number of components by one.

So, removing k edges results in k+1 components.

Each component must have at least x vertices, so k+1 <= floor(n / x)

Moreover, I need to ensure that it's possible to remove k edges in such a way that no component has fewer than x vertices.

So, perhaps I can use the inequality k+1 <= floor(n / x) as a necessary condition.

But is it sufficient?

No, because even if k+1 <= floor(n / x), it might not be possible to remove k edges to achieve that.

For example, consider a tree where one branch has fewer than x vertices, and the rest have more.

If I remove an edge on that branch, I might end up with a component smaller than x.

So, I need to ensure that all possible components after removing k edges have at least x vertices.

This seems difficult to handle directly.

Let me consider the following approach inspired by the reference solution.

Perform a binary search on x.

For each x, perform a DFS to calculate the number of edges that need to be removed to ensure all components have at least x vertices.

Specifically, in the DFS:

- Calculate the size of each subtree.

- If a subtree has size >= x, then removing the edge connecting it to its parent would separate it into a component of at least x vertices.

- Count such edges as potential cuts.

- Finally, check if the number of cuts equals k, and the remaining component also has at least x vertices.

This seems plausible.

Let me try to formalize it.

Define DFS(node, parent, x):

- Calculate the size of the subtree rooted at node.

- If the subtree size >= x and node is not the root, then count this as a cut.

- Return the subtree size.

Then, the total number of cuts is the number of edges where the subtree size on one side is >= x.

But this might overcount or undercount, depending on the tree structure.

Wait, perhaps I need to think in terms of the entire tree.

Let me consider the whole process.

Start with one component.

Each edge removal increases the number of components by one.

I need to remove k edges to get k+1 components, each with at least x vertices.

So, I need to choose k edges to remove such that all resulting components have at least x vertices.

This sounds like a constraint satisfaction problem.

But with n up to 10^5 and t up to 10^4, I need an efficient solution.

Given that, I need to find a way to check for each x whether it's possible to remove exactly k edges to satisfy the condition.

The reference solution seems to use a binary search on x, and for each x, perform a DFS to count the number of cuts needed.

In the DFS, for each node, calculate the subtree size, and if it's >= x, consider removing the edge to the parent.

Then, the number of such cuts is compared to k.

If the number of cuts > k, then x is too small, so I need to increase x.

If the number of cuts < k, then x is too big, so I need to decrease x.

Wait, but in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x).

This seems inconsistent with my previous thought.

Wait, maybe I need to think differently.

Let me look at the binary search condition.

I need to find the maximum x such that it's possible to remove exactly k edges to have all components with at least x vertices.

So, for a given x, if the number of cuts needed is > k, then x is too small, because I need to remove more edges to achieve it.

If the number of cuts needed is < k, then x is too big, because I can't remove that many edges without violating the component size.

Wait, no.

Wait, actually, if the number of cuts needed is < k, it means that I can remove more edges without violating the component size, but I need to remove exactly k edges.

So, in this case, x might still be achievable, but I need to ensure that removing exactly k edges results in all components having at least x vertices.

This is getting confusing.

Perhaps I need to consider the following:

- For a given x, find the minimal number of edges to remove to ensure all components have at least x vertices.

- If this minimal number is equal to k, then x is achievable.

- If the minimal number < k, then x is too big, because I can't remove more edges without creating smaller components.

- If the minimal number > k, then x is too small, because I need to remove more edges to achieve it.

Therefore, in the binary search:

- If the minimal number of cuts needed > k, set L = x + 1

- Else, set R = x

Wait, but in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

I need to reconcile this.

Let me try to think about the binary search condition.

I need to maximize x, so I need to find the largest x where it's possible to remove exactly k edges and have all components with at least x vertices.

So, in the binary search:

- If for a given x, the number of cuts needed > k, then x is too small. I need to increase x.

- If the number of cuts needed <= k, then x might be achievable.

- But I need to remove exactly k edges, so if the number of cuts needed < k, it might not be achievable.

Wait, but in the reference solution, they set L = x when numCuts > k or (numCuts == k and leftover >= x)

This suggests that when numCuts > k, x is achievable, which contradicts my previous thought.

Wait, perhaps I need to adjust my understanding.

Let me look at the binary search condition again.

In the reference solution:

while R - L > 1:

x = (L + R) // 2

numCuts = 0

leftover = dfs(1, 1)

if numCuts > k or (numCuts == k and leftover >= x):

L = x

else:

R = x

print(L)

So, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

Wait, perhaps the condition is that if numCuts > k, then x is too small, so I need to increase x.

If numCuts == k and the leftover >= x, then x is achievable, so I can set L = x.

Otherwise, set R = x.

Wait, but in binary search, typically, if the condition is met, I set R = x, and if not, set L = x.

But here, it's doing the opposite.

Wait, perhaps I need to adjust my understanding of binary search.

Let me recall how binary search works.

I have a search space from L to R.

I want to find the largest x where the condition is true.

So, I should initialize L and R appropriately.

In this case, L should be the minimal possible x, which is 1, and R should be the maximal possible x, which is n.

Then, in each iteration, I set x = (L + R) // 2

If the condition is true for x, I set L = x + 1

Else, I set R = x

Finally, the answer is L - 1

But in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

This seems different.

Wait, perhaps the condition is that x is achievable if numCuts > k or (numCuts == k and leftover >= x)

But this doesn't make sense intuitively.

I need to think differently.

Let me consider that for a given x, if numCuts > k, it means that to achieve x, I need to remove more than k edges, which is not possible, so x is too big.

Wait, no, if numCuts > k, it means that I need to remove more edges than k to achieve x, so x is too big, I need to decrease x.

Wait, but in the reference solution, it's setting L = x when numCuts > k

This seems incorrect.

Wait, maybe I need to adjust the binary search boundaries.

Let me try to redefine the binary search.

Initialize L = 1, R = n + 1

While L < R:

x = (L + R) // 2

if canAchieve(x):

L = x + 1

else:

R = x

print(L - 1)

Where canAchieve(x) is true if it's possible to remove exactly k edges and have all components with at least x vertices.

In this case, the maximum x is L - 1.

But in the reference solution, it's not clearly defining canAchieve(x).

Given that, perhaps I need to implement canAchieve(x) using the DFS approach.

Define canAchieve(x):

Perform DFS to count the number of cuts needed.

If the number of cuts needed == k and the remaining component >= x, return True

Else, return False

Then, in binary search:

if canAchieve(x):

L = x + 1

else:

R = x

Finally, print(L - 1)

This seems correct.

But in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

Wait, perhaps it's a mistake in the reference solution.

Let me think again.

If numCuts > k, it means that to achieve x, I need to remove more than k edges, which is not possible, so x is too big.

I need to decrease x.

So, set R = x

If numCuts <= k, and the remaining component >= x, then x is achievable, so try to increase x.

Set L = x + 1

Else, set R = x

Then, the answer is L - 1

Wait, but in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

This seems incorrect based on my previous thought.

Wait, perhaps I need to adjust the condition.

Let me consider the following:

- If numCuts > k, x is too small, set L = x + 1

- Else if numCuts < k, x is too big, set R = x

- Else if numCuts == k and leftover >= x, x is achievable, set L = x + 1

- Else, set R = x

Then, the answer is L - 1

In the reference solution, it's combining the last two conditions into one.

Wait, perhaps I need to adjust the binary search implementation.

Let me try to implement the binary search correctly.

Initialize L = 1, R = n + 1

While R - L > 1:

x = (L + R) // 2

numCuts = dfs(1, 1, x)

leftover = dfs(1, 1, x)

if numCuts > k:

L = x + 1

elif numCuts < k:

R = x

else:

if leftover >= x:

L = x + 1

else:

R = x

print(L - 1)

This seems correct.

But in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

Which is different from what I have.

Wait, perhaps there is a mistake in my reasoning.

Let me check with the example.

In the first test case:

n = 5, k = 1

Possible x values: 1, 2, 3, 4, 5

For x = 1:

numCuts = 1 (since k = 1), and leftover = 5 - subtree sizes >=1

So, numCuts == k and leftover >= x, so L = x + 1 = 2

For x = 2:

numCuts = 1, leftover = 2 (for one component), which >= x

So, L = x + 1 = 3

For x = 3:

numCuts = 0 (since subtree sizes < x), which < k, so R = x = 3

Then, L = 3, R = 3, loop exits, print L - 1 = 2, which is correct.

So, in this case, it works.

But in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

Which seems to work in this case.

Wait, but in my previous thought, I had L = x + 1 when numCuts > k or (numCuts == k and leftover >= x)

And R = x otherwise.

Then, print L - 1

But in the reference solution, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

And R = x otherwise.

Then, print L

This seems slightly different.

Wait, perhaps I need to adjust the initialization and the final output.

Let me look at the reference solution again.

In the reference solution:

L = 1

R = 1e5 + 1

while R - L > 1:

x = (L + R) // 2

numCuts = 0

leftover = dfs(1, 1)

if numCuts > k or (numCuts == k and leftover >= x):

L = x

else:

R = x

print(L)

So, it's setting L = x when numCuts > k or (numCuts == k and leftover >= x)

Else, set R = x

Finally, print L

In my earlier thought, I had L = x + 1 when numCuts > k or (numCuts == k and leftover >= x)

Else, R = x

And print L - 1

So, there is a difference.

Perhaps the reference solution is correct, and my understanding is wrong.

Let me try to see.

In the binary search, L is the lower bound, and R is the upper bound.

I need to maximize x, so I need to find the largest x where the condition is true.

In the reference solution, when numCuts > k or (numCuts == k and leftover >= x), set L = x

Else, set R = x

Then, print L

In the first iteration, with L = 1, R = 1e5 + 1, x = (1 + 1e5 + 1)//2 = 50001

Suppose for x = 50001, numCuts < k, so set R = 5000