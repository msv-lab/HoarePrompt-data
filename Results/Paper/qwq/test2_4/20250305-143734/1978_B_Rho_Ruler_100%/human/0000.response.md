Alright, I have this problem to solve. Bob has a bakery, and on the opening day, he's trying to maximize his profit by selling his buns with a special promotion. Let's understand what's being asked here.

So, Bob has n buns, each normally priced at a coins. But he's offering a promotion where he can choose some integer k (between 0 and the minimum of n and b) and sell the first k buns at a modified price. The price for the i-th bun (where i goes from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price of a coins each.

My task is to help Bob determine the maximum profit he can make by choosing the best k.

First, I need to understand the promotion clearly. If Bob chooses k = 0, he sells all n buns at the usual price a coins each. So, the total profit would be n * a.

If he chooses k = 1, he sells the first bun at b coins and the remaining (n - 1) buns at a coins each. Total profit would be b + (n - 1) * a.

If k = 2, the first two buns are sold at b and (b - 1) coins respectively, and the remaining (n - 2) buns at a coins each. Total profit would be b + (b - 1) + (n - 2) * a.

Generalizing this, for any k, the profit would be the sum of the first k terms of the sequence starting from b and decreasing by 1 each time, plus (n - k) * a.

So, the profit function can be written as:

profit(k) = sum from i=1 to k of (b - i + 1) + (n - k) * a

Simplifying the sum:

sum from i=1 to k of (b - i + 1) = k * b - sum from i=1 to k of i + sum from i=1 to k of 1 = k * b - (k * (k + 1)) / 2 + k = k * b - (k^2 + k)/2 + k = k * b - (k^2)/2 - k/2 + k = k * b - (k^2)/2 + k/2

So, profit(k) = k * b - (k^2)/2 + k/2 + (n - k) * a

But to make it easier, perhaps there's a better way to compute this.

Wait, actually, the sum of the first k terms of the sequence starting from b and decreasing by 1 each time is equivalent to the sum of an arithmetic series.

The sum of the first k terms where the first term is b and the last term is b - k + 1 is:

sum = k * (b + (b - k + 1)) / 2 = k * (2b - k + 1) / 2 = (2b k - k^2 + k)/2 = b k - (k^2 - k)/2

So, profit(k) = b k - (k^2 - k)/2 + (n - k) * a

Simplifying further:

profit(k) = b k - (k^2 - k)/2 + n a - k a = n a + k (b - a) - (k^2 - k)/2

Hmm, maybe keeping it in terms of sum is clearer.

But in the code provided, the function func_1(k, n, a, b) computes:

k * b - k * (k - 1) // 2 + (n - k) * a

Wait, let's verify if this matches the formula I derived.

From the sum earlier:

sum from i=1 to k of (b - i + 1) = k * b - (k * (k - 1)) / 2

Yes, that matches the func_1 formula.

So, profit(k) = k * b - k * (k - 1) // 2 + (n - k) * a

Now, I need to find the k that maximizes this profit, where k is between 0 and min(n, b).

Given that n, a, b can be up to 10^9, I need an efficient way to compute this.

The provided code uses a binary search approach to find the optimal k.

It defines func_2(n, a, b) which sets low = 0 and high = min(n, b), and performs a binary search to find the k that maximizes profit.

In the while loop, it calculates mid, computes profit at mid and mid + 1, updates the max_profit, and decides whether to go left or right based on whether profit at mid + 1 is greater than profit at mid.

This seems like a reasonable approach, as the profit function might be unimodal, meaning it increases up to a point and then decreases.

Binary search can be efficient for finding the maximum in such a unimodal function.

But I need to verify if the profit function is indeed unimodal.

Let's consider how profit(k) changes with k.

profit(k) = k * b - k * (k - 1) / 2 + (n - k) * a

Simplifying:

profit(k) = k * b - (k^2 - k)/2 + n * a - k * a

= n * a + k * (b - a) - (k^2 - k)/2

= n * a + k * (b - a + 0.5) - 0.5 * k^2

This is a quadratic function in terms of k: -0.5 * k^2 + (b - a + 0.5) * k + n * a

A quadratic function f(k) = A*k^2 + B*k + C, where A = -0.5 < 0, so it's a downward-opening parabola, which is unimodal. It has a maximum at k = -B/(2*A).

Therefore, the profit function is unimodal, and binary search can be used to find the maximum.

Now, I need to ensure that the implementation is correct.

First, the func_1 function seems correct as per the earlier derivation.

In func_2, it initializes low = 0 and high = min(n, b).

It initializes max_profit = 0, which seems fine.

Then, in the while loop, it calculates mid and profit at mid and mid + 1.

It updates max_profit with the maximum of current max_profit and profit_mid.

Then, if profit_next > profit_mid, it sets low = mid + 1, else high = mid - 1.

This seems like a standard binary search for finding the maximum point in a unimodal function.

However, I need to consider the boundaries.

What if the maximum is at k = 0 or k = min(n, b)?

The loop continues while low <= high, and it updates high to mid - 1 if profit_next <= profit_mid, which should eventually converge to the optimal k.

Also, it's using integer division for k * (k - 1) // 2, which is appropriate for integer inputs.

Given that n, a, b can be up to 10^9, I need to make sure there's no integer overflow.

In Python, integers can be arbitrarily large, so no worries there.

Also, the number of test cases is up to 10^4, so the solution needs to be efficient.

Binary search with log(min(n, b)) steps should be efficient enough, especially since min(n, b) can be up to 10^9, and log2(10^9) is about 30, so it's acceptable.

Let me verify with some examples.

Take the first test case:

n = 4, a = 4, b = 5

Possible k values: 0, 1, 2, 3, 4

Compute profit for each k:

k=0: 4*4 = 16

k=1: 5 + 3*4 = 5 + 12 = 17

k=2: 5 + 4 + 2*4 = 9 + 8 = 17

k=3: 5 + 4 + 3 + 1*4 = 12 + 4 = 16

k=4: 5 + 4 + 3 + 2 = 14

So, maximum is 17 at k=1 and k=2.

The code should return 17.

According to the example, it does.

Second test case:

n=5, a=5, b=9

k=0: 25

k=1:9 + 4*5=9+20=29

k=2:9+8 + 3*5=17+15=32

k=3:9+8+7 + 2*5=24+10=34

k=4:9+8+7+6 +1*5=30+5=35

k=5:9+8+7+6+5=35

Maximum is 35 at k=4 and k=5.

Code should return 35.

Third test case:

n=10, a=10, b=5

k=0:10*10=100

k=1:5 +9*10=5+90=95

k=2:5+4 +8*10=9+80=89

k=3:5+4+3 +7*10=12+70=82

k=4:5+4+3+2 +6*10=14+60=74

k=5:5+4+3+2+1=15

Maximum is 100 at k=0.

Code should return 100.

Seems correct.

Now, looking at the code:

if __name__ == '__main__':

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

print(func_2(n, a, b))

def func_1(k, n, a, b):

return k * b - k * (k - 1) // 2 + (n - k) * a

def func_2(n, a, b):

(low, high) = (0, min(n, b))

max_profit = 0

while low <= high:

mid = (low + high) // 2

profit_mid = func_1(mid, n, a, b)

profit_next = func_1(mid + 1, n, a, b)

max_profit = max(max_profit, profit_mid)

if profit_next > profit_mid:

low = mid + 1

else:

high = mid - 1

return max_profit

This looks correct.

But I need to think about edge cases.

Edge case 1: n=1, a=1, b=1

Possible k:0,1

k=0:1*1=1

k=1:1 +0*1=1

Maximum is 1.

Edge case 2: n=1, a=1, b=2

k=0:1

k=1:2 +0*1=2

Maximum is 2.

Edge case 3: n=2, a=2, b=1

k=0:4

k=1:1 +1*2=3

k=2:1+0 +0*2=1

Maximum is 4.

Edge case 4: n=0, but n >=1 as per constraints.

Edge case 5: n=10^9, a=10^9, b=10^9

Need to make sure no integer overflow, but in Python, it's handled.

Another thing to consider: when k increases, profit increases up to a point and then decreases.

The binary search will find the maximum.

I think the solution is correct.

**Final Solution**

To solve this problem, we need to maximize Bob's profit from selling his buns with a special promotion. We achieve this by selecting the optimal number of buns, \( k \), to sell at a modified price.

## Approach

1. **Problem Analysis**:
   - We have \( n \) buns, each normally priced at \( a \) coins.
   - Promotion: Sell the first \( k \) buns at prices decreasing from \( b \) to \( b - k + 1 \) coins.
   - Remaining \( n - k \) buns are sold at the normal price \( a \).
   - Objective: Choose \( k \) to maximize the total profit.

2. **Insight**:
   - The profit function is quadratic in \( k \) and forms a unimodal function (first increases, then decreases).
   - We can use binary search to efficiently find the maximum profit within the range \( k = 0 \) to \( k = \min(n, b) \).

3. **Algorithm**:
   - Define the profit function \( \text{profit}(k) = k \times b - \frac{k \times (k - 1)}{2} + (n - k) \times a \).
   - Use binary search between \( k = 0 \) and \( k = \min(n, b) \) to find the maximum profit.

## Solution Code

```python
def profit(k, n, a, b):
    return k * b - k * (k - 1) // 2 + (n - k) * a

def max_profit(n, a, b):
    low, high = 0, min(n, b)
    max_val = 0
    while low <= high:
        mid = (low + high) // 2
        mid_val = profit(mid, n, a, b)
        next_val = profit(mid + 1, n, a, b) if mid + 1 <= high else float('-inf')
        max_val = max(max_val, mid_val)
        if next_val > mid_val:
            low = mid + 1
        else:
            high = mid - 1
    return max_val

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n, a, b = map(int, input().split())
        print(max_profit(n, a, b))
```

## Explanation

- **Profit Calculation**:
  - The function `profit(k, n, a, b)` calculates the total profit for a given \( k \).
  - It sums the modified prices for the first \( k \) buns and the normal prices for the remaining \( n - k \) buns.

- **Binary Search**:
  - We initialize `low` to 0 and `high` to \( \min(n, b) \).
  - In each iteration, we calculate the profit for the midpoint \( mid \) and the next point \( mid + 1 \).
  - If the profit at \( mid + 1 \) is greater than at \( mid \), we search the higher half; otherwise, the lower half.
  - This continues until `low` exceeds `high`, ensuring we've found the maximum profit.

This approach efficiently handles the problem's constraints and finds the optimal solution using binary search on a unimodal profit function.