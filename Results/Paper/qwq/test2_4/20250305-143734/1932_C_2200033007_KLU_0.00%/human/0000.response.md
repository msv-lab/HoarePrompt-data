Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array `a` of length `n`, a positive integer `m`, and a string `s` of commands, where each command is either 'L' or 'R'. For each command in the string `s`, I need to perform two actions:

1. Output the remainder of the product of all elements in the array `a` when divided by `m`.

2. Remove the leftmost element if the command is 'L', or the rightmost element if the command is 'R'.

And I have to do this for multiple test cases, with the guarantee that the total sum of `n` across all test cases doesn't exceed 2*10^5.

First, I need to understand what the problem is really asking for. For each command in the string `s`, I have to compute the product of the current array `a` modulo `m`, output it, and then remove an element from either end of the array based on the command.

So, for each step, the array gets smaller by one element, and I need to compute the product modulo `m` each time.

Looking at the example:

Input:

4

4 6

3 1 4 2

LRRL

5 1

1 1 1 1 1

LLLLL

6 8

1 2 3 4 5 6

RLLLRR

1 10000

10000

R

Output:

0 2 4 1

0 0 0 0 0

0 0 0 4 4 4

0

In the first test case:

- Initial array: [3, 1, 4, 2]

- m = 6

- Commands: LRRL

First command 'L':

- Product: 3*1*4*2 = 24 % 6 = 0

- Remove leftmost element: [1, 4, 2]

Second command 'R':

- Product: 1*4*2 = 8 % 6 = 2

- Remove rightmost element: [1, 4]

Third command 'R':

- Product: 1*4 = 4 % 6 = 4

- Remove rightmost element: [1]

Fourth command 'L':

- Product: 1 % 6 = 1

- Remove leftmost element: []

And the output is: 0 2 4 1

That makes sense.

Now, I need to implement this efficiently, considering that n can be up to 2*10^5 and t can be up to 10^4, but the total sum of n across all test cases is up to 2*10^5.

So, time complexity is important here. I need an algorithm that is O(n) per test case, or at least O(n) overall.

Let me think about how to compute the product modulo m efficiently.

One straightforward way is to keep track of the product as I remove elements. But since elements are being removed from either end, and the removal order matters, I need to be careful.

If I just maintain the product of the current array, every time I remove an element, I can divide the product by that element. But division is tricky in modular arithmetic unless I use modular inverse, which might be too slow if done naively.

Wait, but m can be up to 10^4, and a_i can be up to 10^4 as well. So, the product can be very large, potentially exceeding the limits of standard data types if n is large. I need a way to compute the product modulo m efficiently.

Another approach is to compute the product of the entire array, then, based on the removal sequence, divide by the removed elements using modular inverse.

But modular inverse is computationally expensive if done repeatedly, especially for large n.

Is there a better way?

Let me consider the sequence of removals. Since I have to remove elements based on the command sequence 's', I can determine in advance the order in which elements are removed.

For example, in the first test case:

Commands: LRRL

Array: [3,1,4,2]

First command 'L': remove 3, so remaining: [1,4,2]

Second command 'R': remove 2, remaining: [1,4]

Third command 'R': remove 4, remaining: [1]

Fourth command 'L': remove 1, remaining: []

So, the order of removal is: 3,2,4,1

If I can determine this order beforehand, I can compute the product of the array at each step by keeping track of the product of the remaining elements.

Wait, but to compute the product modulo m at each step, I need the product of the current array modulo m.

If I can get the order of removal, then I can compute the product of the array before each removal.

Wait, perhaps it's better to think in reverse.

If I consider the removal sequence, I can think of building the array back in reverse, adding elements back in the reverse order of removal.

This might help in efficiently computing the products.

Let me try to formalize this.

Suppose I have the final empty array, with product 1 (empty product).

Then, if I add back the last removed element, say 1, the product becomes 1.

Then, add back 4, product becomes 1*4=4.

Then, add back 2, product becomes 4*2=8.

Then, add back 3, product becomes 8*3=24.

But this is building the array in reverse order of removal.

Wait, but the problem requires me to output the product at the beginning of each command, which is before the removal.

So, in the first step, the product is 3*1*4*2=24 %6=0

Then, remove 3, product is 1*4*2=8 %6=2

Then, remove 2, product is 1*4=4%6=4

Then, remove 4, product is 1%6=1

Then, remove 1, empty array product is 1 (but since it's empty, maybe 0? But in modular arithmetic, empty product is 1.

But in the output, for the last step, it's 1, which is consistent.

Wait, but in the output, for the last step, it's 1, which is the product of the single element [1] modulo 6, which is 1.

So, perhaps empty product is considered 1 in this context.

Ok, so if I think in terms of building the array back in reverse, I can compute the product step by step.

But I need to compute the product modulo m for each step.

Wait, perhaps I can compute the product of all elements, then, for each step, divide by the removed element using modular inverse.

But modular inverse is computationally expensive, especially if done repeatedly.

Is there a better way?

Let me consider that m can be up to 10^4, which is manageable, but n can be up to 2*10^5, so I need an efficient solution.

Another idea: since m is up to 10^4, I can factorize m into its prime factors and compute the product modulo each prime power, then combine them using the Chinese Remainder Theorem.

But this might be overkill and still not solve the efficiency issue.

Wait, perhaps I can precompute the product of the array, and then, for each removal, divide by the removed element modulo m using modular inverse.

But again, computing modular inverse for each removal would be O(n * log m), which might be too slow for n=2*10^5.

Is there a way to avoid using modular inverse?

Let me think differently.

Suppose I compute the product of all elements in the array modulo m.

Then, for each removal, I can divide the current product by the removed element.

But division modulo m requires modular inverse, which is slow.

Is there a way to avoid division?

Wait, maybe I can compute the product of the remaining elements without dividing.

For example, keep track of the product of the left part and the right part separately.

But I'm not sure.

Wait, perhaps I can precompute the prefix and suffix products.

Let me consider prefix products from the left and from the right.

Define prefix_L[i] as the product of the first i elements from the left.

Define prefix_R[i] as the product of the first i elements from the right.

Then, at any point, the product of the current array is prefix_L[left] * prefix_R[right], adjusted for any overlapping elements.

Wait, actually, that might not be directly applicable.

Let me think again.

Suppose I have the entire array's product.

Then, after removing some elements from the left and some from the right, the current product would be the product of the remaining elements.

If I can compute the product of the remaining elements efficiently, that would be great.

Wait, perhaps I can compute the product of the array, then keep track of the product of the removed elements, and divide the total product by the product of removed elements.

But again, division modulo m requires modular inverse.

This seems like a dead end.

Is there a way to represent the product of the remaining elements without division?

Wait, perhaps I can think in terms of logs, but that would introduce floating points and precision errors, which is not acceptable for exact results.

Another idea: since m is small (up to 10^4), I can compute the product modulo m directly, but I need to handle the removals efficiently.

Wait, perhaps I can precompute the product of all elements, then for each removal, adjust the product by dividing by the removed element.

But again, division modulo m requires modular inverse.

Is there a way to precompute the modular inverses?

Well, I can precompute the modular inverses of all a_i, but that would still require O(n) time per test case, which might be too slow for n=2*10^5.

Wait, but the total sum of n across all test cases is up to 2*10^5, and t is up to 10^4, so per test case, n can be up to 2*10^5, but the total operations are acceptable.

But I need a better approach.

Let me look at the reference solution provided.

The reference solution is:

for _ in range(int(input())):

(n, m) = map(int, input().split())

a = list(map(int, input().split()))

s = input()

print(*func_1(n, m, a, s))

def func_1(n, m, a, s):

b = []

l = 0

r = n - 1

for i in range(n):

if s[i] == 'L':

b.append(a[l])

l += 1

else:

b.append(a[r])

r -= 1

ans = []

p = 1

for v in reversed(b):

p = p * v % m

ans.append(p)

return reversed(ans)

Okay, so in this solution, they first collect the sequence of removed elements in list `b`, by iterating through the commands in `s`.

Then, they compute the product in reverse order.

Wait, let's see.

They initialize an empty list `b`.

They have pointers `l` and `r` pointing to the leftmost and rightmost elements of the array.

Then, for each command in `s`:

- If the command is 'L', they append a[l] to b and increment l.

- If the command is 'R', they append a[r] to b and decrement r.

So, `b` contains the sequence of removed elements in the order they are removed.

Then, they initialize an empty list `ans` and a variable `p` to 1.

They iterate through `b` in reverse order:

- For each v in reversed(b), they set p = (p * v) % m

- Append p to ans

Finally, they return reversed(ans).

Wait, that's interesting.

So, they are building the product in reverse order.

Let me see with the first test case:

a = [3,1,4,2]

s = LRRL

So, b = [3,2,4,1] (as we saw earlier)

Then, they set p=1

Iterate through b in reverse: 1,4,2,3

First v=1: p=1*1=1 %6=1, ans=[1]

Second v=4: p=1*4=4 %6=4, ans=[1,4]

Third v=2: p=4*2=8 %6=2, ans=[1,4,2]

Fourth v=3: p=2*3=6 %6=0, ans=[1,4,2,0]

Then, they return reversed(ans), which is [0,2,4,1], matching the first output line.

Cool, so this seems to work.

But why does this work?

Well, when they iterate through b in reverse, they are essentially building the product of the remaining elements in the array before each removal.

Wait, let's see.

At the end, after all removals, the array is empty, and the product is 1 (empty product).

Then, when they add back the last removed element, the product becomes that element.

Then, when they add back the previous removal, the product becomes the previous element multiplied by the current product, and so on.

So, by iterating in reverse and building up the product, they are effectively computing the product of the remaining elements before each removal.

And since they are working modulo m, it's efficient.

Also, multiplying by each element in reverse order and taking modulo m avoids dealing with large products.

This seems like an efficient and correct approach.

They are using O(n) time per test case, which is acceptable given that the total sum of n across all test cases is up to 2*10^5.

Space-wise, they are using O(n) space for list `b` and `ans`, which is also acceptable.

I think this solution is correct and efficient.

Therefore, the answer is Correctness: **True**

**Final Answer**

\boxed{\text{True}}