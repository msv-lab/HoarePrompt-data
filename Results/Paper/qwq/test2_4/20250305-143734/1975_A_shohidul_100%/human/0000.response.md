Alright, I have this problem to solve. Let's see what it's about. So, Mocha has an array of positive integers, and she can perform this specific operation on it any number of times. The operation is to split the array into a prefix and a suffix, swap them, and concatenate them back together. For example, if you have [3,1,4,1,5], you can split it into [3,1] and [4,1,5], then swap them to get [4,1,5,3,1]. The goal is to determine if, after performing this operation any number of times, the array can become sorted in non-decreasing order.

First, I need to understand the operation clearly. It's about splitting the array into two parts at some index and swapping those parts. So, for an array of length n, possible splits are at index 1 to n-1. For example, for n=4, possible splits are:

- Split at index 1: x=[a[0]], y=[a[1],a[2],a[3]]

- Split at index 2: x=[a[0],a[1]], y=[a[2],a[3]]

- Split at index 3: x=[a[0],a[1],a[2]], y=[a[3]]

After swapping, the array becomes y + x.

Now, the problem is to check if, by doing this operation any number of times, we can make the array sorted in non-decreasing order.

Let me think about what this operation does. Essentially, it allows us to rotate the array in a specific way. It's not a standard rotation where elements are shifted by one position, but rather a kind of reverse rotation where the prefix and suffix are swapped.

Let me consider some examples to understand the behavior.

Example 1:

n=6

a=[1,1,4,5,1,4]

The output is "No", meaning it's impossible to sort this array in non-decreasing order using the given operation.

Example 2:

n=5

a=[7,9,2,2,3]

Output is "Yes". Let's see how:

- Split at index 1: x=[7], y=[9,2,2,3] → swap to [9,2,2,3,7]

- Split at index 1 again: x=[9], y=[2,2,3,7] → swap to [2,2,3,7,9], which is sorted.

So, in two operations, we can sort the array.

Example 3:

n=3

a=[1,2,3]

It's already sorted, so "Yes".

From these examples, it seems that if the array is already sorted, we can output "Yes" immediately. Otherwise, we need to check if it's possible to sort it by performing the split-and-swap operation.

I need to find a way to determine if such a sequence of operations can lead to a sorted array.

Let me think about the properties of this operation. Each operation is reversible because swapping the same prefix and suffix again will bring the array back to its original state. So, the operations form a group in some sense.

But maybe I can think in terms of cycles or permutations.

Alternatively, perhaps there is a way to check if the array can be split into two parts such that one part is the prefix and the other is the suffix, and after swapping, the combined array is sorted.

Wait, but we can perform this operation multiple times. So, it's not just a single split and swap.

Let me consider what happens when we perform multiple split-and-swap operations.

Suppose we have an array a = [a1, a2, ..., an].

After one operation, splitting at position k (1-based index), we get [a_{k+1}, ..., a_n, a1, ..., a_k].

Then, if we perform another operation, splitting at position m, we get [a_{m+1}, ..., a_n, a1, ..., a_m].

Wait, this seems similar to rotating the array.

Actually, this operation is equivalent to rotating the array by k positions, where k is the length of the prefix.

Wait, but in standard rotation, we shift elements by k positions to the left or right, but here, it's swapping the prefix and suffix.

So, in this operation, it's not a standard rotation.

Wait, let's see:

Original array: [a1, a2, ..., ak, ak+1, ..., an]

After swapping prefix x=[a1, a2, ..., ak] and suffix y=[ak+1, ..., an], we get y + x = [ak+1, ..., an, a1, a2, ..., ak].

This is similar to rotating the array by k positions to the left.

Wait, is it equivalent to rotating left by k positions?

In a standard left rotation by k positions, the array becomes [a_{k+1}, ..., a_n, a1, ..., a_k], which is exactly what this operation does.

So, this operation is equivalent to performing a left rotation by k positions, where k is the length of the prefix.

Therefore, performing this operation multiple times allows us to perform multiple left rotations by various amounts.

Now, the question is, can we sort the array in non-decreasing order by performing left rotations?

Because each operation corresponds to a left rotation by some number of positions.

Wait, but in the example, they performed two operations:

First operation: split at index 1, which is equivalent to rotating left by 1 position.

Second operation: split at index 1 again, which is rotating left by 1 position once more.

So, in total, it's rotating left by 2 positions.

But in that case, why didn't they just rotate left by 2 positions directly?

Wait, perhaps they can choose different k for each operation.

Wait, in the first operation, they split at index 1, which is rotating left by 1 position, getting [9,2,2,3,7].

Then, in the second operation, they split at index 1 again, which is rotating left by 1 position again, getting [2,2,3,7,9].

Wait, but if they had rotated left by 2 positions directly from the original array, they would have gotten the same result.

But perhaps they could have chosen different k for different operations.

Wait, can they choose different k in different operations?

Yes, they can choose any k from 1 to n-1 for each operation.

So, it's like they can perform any sequence of left rotations by any number of positions.

But in that case, can they achieve any permutation of the array by performing such rotations?

Well, in group theory, the set of all left rotations generates the cyclic group of order n.

In other words, by performing multiple left rotations, you can achieve any cyclic permutation of the array.

But sorting the array requires that the elements are in non-decreasing order.

So, if the array can be sorted by some cyclic rotation, then the answer is "Yes".

Otherwise, it's "No".

Wait, but in the first example, [1,1,4,5,1,4], it's "No", even though perhaps some rotation makes it sorted.

Wait, let's check:

Original: [1,1,4,5,1,4]

Rotations:

- Rotate left by 1: [1,4,5,1,4,1]

- Rotate left by 2: [4,5,1,4,1,1]

- Rotate left by 3: [5,1,4,1,1,4]

- Rotate left by 4: [1,4,1,1,4,5]

- Rotate left by 5: [4,1,1,4,5,1]

None of these are sorted in non-decreasing order.

Hence, "No".

In the second example:

Original: [7,9,2,2,3]

Rotations:

- Rotate left by 1: [9,2,2,3,7]

- Rotate left by 2: [2,2,3,7,9] → sorted.

Hence, "Yes".

In the third example:

[1,2,3] is already sorted, so "Yes".

So, it seems that the problem reduces to checking if there exists a cyclic rotation of the array that is sorted in non-decreasing order.

That seems to be the case.

So, the task is to check for each test case if there exists a cyclic rotation of the array that is sorted in non-decreasing order.

If such a rotation exists, output "Yes"; otherwise, "No".

Now, how to implement this efficiently.

Given that n is up to 50 and t is up to 1000, it's feasible to check all possible rotations for each test case.

There are n possible rotations, and for each rotation, we can check if the array is sorted in O(n) time.

So, total time per test case is O(n^2), which should be acceptable since n <= 50 and t <= 1000.

But perhaps there is a smarter way.

Let me think about it.

Suppose I concatenate the array with itself, creating a new array of length 2n, where the first n elements are the original array, and the next n elements are the same.

Then, I can look for a subarray of length n in this new array that is sorted in non-decreasing order.

If such a subarray exists, then there exists a cyclic rotation that is sorted.

This approach is similar to handling circular arrays by doubling them.

So, for example, for [7,9,2,2,3], concatenating gives [7,9,2,2,3,7,9,2,2,3].

Then, looking for a subarray of length 5 that is sorted:

- [7,9,2,2,3] → not sorted

- [9,2,2,3,7] → not sorted

- [2,2,3,7,9] → sorted.

Hence, "Yes".

Similarly, for [1,1,4,5,1,4], concatenating gives [1,1,4,5,1,4,1,1,4,5,1,4].

Looking for a subarray of length 6 that is sorted:

- [1,1,4,5,1,4] → not sorted

- [1,4,5,1,4,1] → not sorted

- [4,5,1,4,1,1] → not sorted

- [5,1,4,1,1,4] → not sorted

- [1,4,1,1,4,5] → not sorted

- [4,1,1,4,5,1] → not sorted

Hence, "No".

This seems to work.

So, in code, for each test case, I can:

- Read n and the array a.

- Check if a is already sorted. If yes, output "Yes".

- If not, create a new array b of length 2n, where b[i] = a[i % n] for i from 0 to 2n-1.

- Then, iterate through all possible starting positions 0 to n-1, and check if b[i..i+n-1] is sorted in non-decreasing order.

- If any such subarray is sorted, output "Yes"; otherwise, "No".

This should work and is efficient enough.

Now, looking at the provided program, let's see if it implements this correctly.

The provided program is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

check_all = all([a[i - 1] <= a[i] for i in range(1, n)])

if check_all:

print('YES')

else:

for i in range(1, n):

if a[i - 1] > a[i]:

new = a[i:]

check_all_new = all([a[0] >= new[i] for i in range(len(new))])

new_all = all([new[i - 1] <= new[i] for i in range(1, len(new))])

if check_all_new and new_all:

print('YES')

break

else:

print('NO')

break

So, it first checks if the array is already sorted. If yes, outputs "YES".

If not, it iterates through possible split points i from 1 to n-1, where a[i-1] > a[i].

For each such i, it takes the suffix starting from i to n-1, and checks two conditions:

1. All elements in the suffix are in non-decreasing order.

2. The first element of the array is greater than or equal to all elements in the suffix.

If both conditions are satisfied for any i, it outputs "YES"; otherwise, "NO".

Wait, is this equivalent to checking for a cyclic rotation that is sorted?

Let me analyze this.

In the second test case:

a = [7,9,2,2,3]

It's not sorted, so it proceeds to the else part.

It iterates i from 1 to 4.

At i=1: a[0]=7 > a[1]=9 → condition a[i-1] > a[i] is false, skip.

At i=2: a[1]=9 > a[2]=2 → true.

Then, new = a[2:] = [2,2,3]

check_all_new = all([a[0] >= new[i] for i in range(len(new))]) → a[0]=7 >= 2, 2, 3 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 2 <= 2 and 2 <= 3 → true.

So, both conditions are true, output "YES".

This matches the expected output.

In the first test case:

a = [1,1,4,5,1,4]

It's not sorted, proceed to else.

Iterate i from 1 to 5.

At i=1: a[0]=1 <= a[1]=1 → skip.

At i=2: a[1]=1 <= a[2]=4 → skip.

At i=3: a[2]=4 <= a[3]=5 → skip.

At i=4: a[3]=5 > a[4]=1 → true.

Then, new = a[4:] = [1,4]

check_all_new = all([a[0] >= new[i] for i in range(len(new))]) → a[0]=1 >= 1 and 1 >= 4 → false.

So, condition fails.

At i=5: a[4]=1 <= a[5]=4 → skip.

Hence, no "YES" is found, so it outputs "NO".

This also matches the expected output.

In the third test case:

a = [1,2,3]

Already sorted, outputs "YES".

Seems correct.

But is this logic equivalent to checking for any cyclic rotation that is sorted?

Let me think about another example.

Consider a = [2,2,1]

It's not sorted.

Proceed to else.

Iterate i from 1 to 2.

At i=1: a[0]=2 <= a[1]=2 → skip.

At i=2: a[1]=2 > a[2]=1 → true.

new = a[2:] = [1]

check_all_new = all([a[0] >= new[i] for i in range(len(new))]) → a[0]=2 >= 1 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → no elements, trivially true.

So, outputs "YES".

But let's see if there exists a cyclic rotation that is sorted.

Original: [2,2,1]

Rotations:

- Rotate left by 1: [2,1,2]

- Rotate left by 2: [1,2,2] → sorted.

Hence, "Yes", which matches the program's output.

Another example: a = [3,1,2]

Not sorted.

Proceed to else.

Iterate i from 1 to 2.

At i=1: a[0]=3 > a[1]=1 → true.

new = a[1:] = [1,2]

check_all_new = all([a[0]=3 >= new[i] for i in range(len(new))]) → 3 >=1 and 3>=2 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 1 <= 2 → true.

So, outputs "YES".

Is there a sorted rotation?

Original: [3,1,2]

Rotations:

- Rotate left by 1: [1,2,3] → sorted.

Hence, "Yes".

Seems correct.

Another example: a = [4,5,1,2,3]

Not sorted.

Proceed to else.

Iterate i from 1 to 4.

At i=1: a[0]=4 <= a[1]=5 → skip.

At i=2: a[1]=5 > a[2]=1 → true.

new = a[2:] = [1,2,3]

check_all_new = all([a[0]=4 >= new[i] for i in range(len(new))]) → 4 >=1, 4>=2, 4>=3 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 1<=2 and 2<=3 → true.

So, outputs "YES".

Indeed, rotating left by 2: [1,2,3,4,5] → sorted.

Correct.

Another example: a = [3,4,5,1,2]

Not sorted.

Proceed to else.

Iterate i from 1 to 4.

At i=1: a[0]=3 <= a[1]=4 → skip.

At i=2: a[1]=4 <= a[2]=5 → skip.

At i=3: a[2]=5 > a[3]=1 → true.

new = a[3:] = [1,2]

check_all_new = all([a[0]=3 >= new[i] for i in range(len(new))]) → 3 >=1 and 3>=2 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 1<=2 → true.

So, outputs "YES".

Rotations:

- Rotate left by 3: [1,2,3,4,5] → sorted.

Correct.

Seems the logic holds.

But let's think about a case where the program outputs "YES", but no sorted rotation exists.

Is there any such case?

Consider a = [2,1,3]

Not sorted.

Proceed to else.

Iterate i from 1 to 2.

At i=1: a[0]=2 > a[1]=1 → true.

new = a[1:] = [1,3]

check_all_new = all([a[0]=2 >= new[i] for i in range(len(new))]) → 2 >=1 and 2 >=3 → false.

So, condition fails.

At i=2: a[1]=1 <= a[2]=3 → skip.

Hence, outputs "NO".

But let's check rotations:

Original: [2,1,3]

Rotate left by 1: [1,3,2] → not sorted.

Rotate left by 2: [3,2,1] → not sorted.

Hence, indeed no sorted rotation exists.

Correct.

Another case: a = [1,3,2]

Not sorted.

Proceed to else.

Iterate i from 1 to 2.

At i=1: a[0]=1 <= a[1]=3 → skip.

At i=2: a[1]=3 > a[2]=2 → true.

new = a[2:] = [2]

check_all_new = all([a[0]=1 >= new[i] for i in range(len(new))]) → 1 >=2 → false.

So, condition fails.

No "YES" is outputted, which is correct because no sorted rotation exists.

Rotations:

- Rotate left by 1: [3,2,1] → not sorted.

- Rotate left by 2: [2,1,3] → not sorted.

Hence, "NO".

Seems correct.

Let me think about a tricky case.

a = [1,2,1]

Already sorted? No, because [1,2,1], 2 > 1 at the end.

Proceed to else.

Iterate i from 1 to 2.

At i=1: a[0]=1 <= a[1]=2 → skip.

At i=2: a[1]=2 > a[2]=1 → true.

new = a[2:] = [1]

check_all_new = all([a[0]=1 >= new[i] for i in range(len(new))]) → 1 >=1 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → no elements, trivially true.

So, outputs "YES".

But let's check rotations:

Original: [1,2,1]

Rotate left by 1: [2,1,1] → not sorted.

Rotate left by 2: [1,1,2] → sorted.

Hence, "Yes".

Correct.

Another case: a = [2,1,1]

Not sorted.

Proceed to else.

Iterate i from 1 to 2.

At i=1: a[0]=2 > a[1]=1 → true.

new = a[1:] = [1,1]

check_all_new = all([a[0]=2 >= new[i] for i in range(len(new))]) → 2 >=1 and 2 >=1 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 1 <=1 → true.

So, outputs "YES".

Rotations:

- Rotate left by 1: [1,1,2] → sorted.

Correct.

Seems consistent.

Another case: a = [3,1,1,2]

Not sorted.

Proceed to else.

Iterate i from 1 to 3.

At i=1: a[0]=3 > a[1]=1 → true.

new = a[1:] = [1,1,2]

check_all_new = all([a[0]=3 >= new[i] for i in range(len(new))]) → 3 >=1, 3>=1, 3>=2 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 1<=1 and 1<=2 → true.

So, outputs "YES".

Rotations:

- Rotate left by 1: [1,1,2,3] → sorted.

Correct.

Another case: a = [4,1,2,3]

Not sorted.

Proceed to else.

Iterate i from 1 to 3.

At i=1: a[0]=4 > a[1]=1 → true.

new = a[1:] = [1,2,3]

check_all_new = all([a[0]=4 >= new[i] for i in range(len(new))]) → 4 >=1, 4>=2, 4>=3 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → 1<=2 and 2<=3 → true.

So, outputs "YES".

Rotations:

- Rotate left by 1: [1,2,3,4] → sorted.

Correct.

Seems the logic holds.

But let's consider a case where the suffix is sorted, and a[0] >= all elements in the suffix, but the rotation is not sorted.

Is there such a case?

For example, a = [3,1,2]

Not sorted.

Proceed to else.

At i=1: a[0]=3 > a[1]=1 → true.

new = a[1:] = [1,2]

check_all_new = all([3 >=1, 3>=2]) → true.

new_all = all([1<=2]) → true.

So, outputs "YES".

But earlier, we saw that there exists a sorted rotation.

Hence, no counterexample found yet.

Wait, what about a = [2,1,3,4]

Not sorted.

Proceed to else.

Iterate i from 1 to 3.

At i=1: a[0]=2 > a[1]=1 → true.

new = a[1:] = [1,3,4]

check_all_new = all([2 >=1, 2>=3]) → 2 >=1 is true, 2 >=3 is false → false.

So, condition fails.

At i=2: a[1]=1 <= a[2]=3 → skip.

At i=3: a[2]=3 <= a[3]=4 → skip.

Hence, outputs "NO".

But let's check rotations:

Original: [2,1,3,4]

Rotate left by 1: [1,3,4,2] → not sorted.

Rotate left by 2: [3,4,2,1] → not sorted.

Rotate left by 3: [4,2,1,3] → not sorted.

Hence, indeed no sorted rotation exists.

Correct.

Another case: a = [1,3,2,4]

Not sorted.

Proceed to else.

Iterate i from 1 to 3.

At i=1: a[0]=1 <= a[1]=3 → skip.

At i=2: a[1]=3 > a[2]=2 → true.

new = a[2:] = [2,4]

check_all_new = all([1 >=2]) → false.

So, condition fails.

At i=3: a[2]=2 <= a[3]=4 → skip.

Hence, "NO".

But rotations:

- Rotate left by 1: [3,2,4,1] → not sorted.

- Rotate left by 2: [2,4,1,3] → not sorted.

- Rotate left by 3: [4,1,3,2] → not sorted.

Hence, indeed "NO".

Seems correct.

Another case: a = [2,2,3,1]

Not sorted.

Proceed to else.

Iterate i from 1 to 3.

At i=1: a[0]=2 <= a[1]=2 → skip.

At i=2: a[1]=2 <= a[2]=3 → skip.

At i=3: a[2]=3 > a[3]=1 → true.

new = a[3:] = [1]

check_all_new = all([2 >=1]) → true.

new_all = all([]) → true.

So, outputs "YES".

But rotations:

- Rotate left by 1: [2,3,1,2] → not sorted.

- Rotate left by 2: [3,1,2,2] → not sorted.

- Rotate left by 3: [1,2,2,3] → sorted.

Hence, correct.

Seems like the program's logic is sound.

But let's see if there's any edge case where it might fail.

Edge case 1: n=2

a = [1,2] → already sorted → "YES"

a = [2,1] → not sorted.

Proceed to else.

At i=1: a[0]=2 > a[1]=1 → true.

new = a[1:] = [1]

check_all_new = all([2 >=1]) → true.

new_all = all([]) → true.

So, outputs "YES".

But rotations:

- Rotate left by 1: [1,2] → sorted.

Correct.

Another edge case: n=3

a = [1,2,3] → already sorted → "YES"

a = [1,3,2] → not sorted.

Proceed to else.

At i=1: a[0]=1 <= a[1]=3 → skip.

At i=2: a[1]=3 > a[2]=2 → true.

new = a[2:] = [2]

check_all_new = all([1 >=2]) → false.

So, "NO".

Rotations:

- Rotate left by 1: [3,2,1] → not sorted.

- Rotate left by 2: [2,1,3] → not sorted.

Hence, correct.

Another edge case: n=4

a = [4,1,2,3]

Not sorted.

Proceed to else.

At i=1: a[0]=4 > a[1]=1 → true.

new = a[1:] = [1,2,3]

check_all_new = all([4 >=1,4>=2,4>=3]) → true.

new_all = all([1<=2,2<=3]) → true.

So, "YES".

Rotations:

- Rotate left by 1: [1,2,3,4] → sorted.

Correct.

Another edge case: n=5

a = [3,4,5,1,2]

Not sorted.

Proceed to else.

At i=1: a[0]=3 <= a[1]=4 → skip.

At i=2: a[1]=4 <= a[2]=5 → skip.

At i=3: a[2]=5 > a[3]=1 → true.

new = a[3:] = [1,2]

check_all_new = all([3 >=1,3 >=2]) → true.

new_all = all([1<=2]) → true.

So, "YES".

Rotations:

- Rotate left by 3: [1,2,3,4,5] → sorted.

Correct.

Seems consistent.

What if the array has duplicates?

a = [2,2,2,1]

Not sorted.

Proceed to else.

At i=1: a[0]=2 <= a[1]=2 → skip.

At i=2: a[1]=2 <= a[2]=2 → skip.

At i=3: a[2]=2 > a[3]=1 → true.

new = a[3:] = [1]

check_all_new = all([2 >=1]) → true.

new_all = all([]) → true.

So, "YES".

Rotations:

- Rotate left by 1: [2,2,2,1] → not sorted.

- Rotate left by 2: [2,2,1,2] → not sorted.

- Rotate left by 3: [2,1,2,2] → not sorted.

Wait, in this case, no rotation is sorted, but the program outputs "YES".

Wait, is there a mistake here?

Wait, in this case, the program outputs "YES", but actually, no rotation is sorted.

Wait, let's check the conditions again.

a = [2,2,2,1]

At i=3: a[2]=2 > a[3]=1 → true.

new = a[3:] = [1]

check_all_new = all([a[0]=2 >= new[i] for i in range(len(new))]) → 2 >=1 → true.

new_all = all([new[i-1] <= new[i] for i in range(1, len(new))]) → no elements, trivially true.

Hence, outputs "YES".

But rotations:

- Rotate left by 1: [2,2,2,1] → not sorted.

- Rotate left by 2: [2,2,1,2] → not sorted.

- Rotate left by 3: [2,1,2,2] → not sorted.

Hence, no sorted rotation exists, but the program outputs "YES".

This seems like a mistake.

Wait, perhaps the program's logic is not sufficient.

What is the condition that the program checks?

It checks if there exists an index i where a[i-1] > a[i], and for the suffix starting at i, the suffix is sorted in non-decreasing order, and a[0] >= all elements in the suffix.

In the above case, a = [2,2,2,1]

At i=3: a[2]=2 > a[3]=1 → true.

new = [1]

check_all_new = 2 >=1 → true.

new_all = trivially true.

Hence, "YES".

But in reality, no rotation results in a sorted array.

Hence, the program is incorrect in this case.

So, the program is not always correct.

Wait, but in all previous cases, it seemed correct.

What's special about this case?

Wait, perhaps the condition is too lenient.

Let me think about what the program is checking.

It's checking if there exists a split point i where:

1. a[i-1] > a[i]

2. The suffix starting at i is sorted in non-decreasing order.

3. a[0] >= all elements in the suffix.

In the above case, a = [2,2,2,1]

i=3:

- a[2]=2 > a[3]=1 → true.

- new = [1]

- check_all_new = 2 >=1 → true.

- new_all = trivially true.

Hence, "YES".

But no rotation is sorted.

Hence, the program is incorrect.

So, the program is incorrect because it can output "YES" even when no sorted rotation exists.

Hence, Correctness: **False**

## Final Solution
To solve this problem, we need to determine if a given array can be sorted in non-decreasing order by performing a specific operation any number of times. The operation allows splitting the array into a prefix and a suffix, swapping them, and concatenating them back together.

### Approach

1. **Understanding the Operation**:
   - The operation is equivalent to rotating the array in a specific manner.
   - We need to check if any rotation of the array results in a non-decreasing order.

2. **Efficient Check for Sorted Rotation**:
   - Concatenate the array with itself to handle the circular nature.
   - Check for any subarray of length `n` that is sorted in non-decreasing order.

### Solution Code

```python
def can_be_sorted(a, n):
    # Check if the array is already sorted
    if all(a[i] <= a[i + 1] for i in range(n - 1)):
        return True
    # Create a concatenated array to handle rotations
    b = a + a
    # Check all possible rotations
    for i in range(n):
        # Extract the subarray of length n
        rotated = b[i:i + n]
        # Check if this rotation is sorted
        if all(rotated[j] <= rotated[j + 1] for j in range(n - 1)):
            return True
    return False

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        a = list(map(int, data[index + 1:index + 1 + n]))
        index += 1 + n
        if can_be_sorted(a, n):
            print('Yes')
        else:
            print('No')

if __name__ == "__main__":
    main()
```

### Explanation

1. **Initial Check**:
   - First, check if the array is already sorted in non-decreasing order.

2. **Concatenated Array**:
   - By concaten