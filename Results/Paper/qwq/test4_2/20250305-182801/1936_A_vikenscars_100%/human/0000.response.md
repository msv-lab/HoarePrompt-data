Alright, I've got this interactive problem to solve. Let's see what it's asking for.

So, there's a secret permutation of numbers from 0 to n-1, and I need to find two indices i and j such that the XOR of p_i and p_j is maximized. I can ask up to 3n queries to compare the OR of pairs of elements.

First, I need to understand what XOR and OR operations do. XOR gives me the bits that are different between two numbers, while OR gives me the bits that are set in either of the two numbers.

My goal is to maximize p_i XOR p_j. To do that, I need p_i and p_j to differ in the most significant bits possible. In other words, I want the leftmost bits where p_i and p_j differ to be as far left as possible.

But I don't know the actual values of p_i; I only have access to comparisons of their ORs.

Let me think about how I can use these queries to gather information about the permutation.

One idea is to find the maximum value in the permutation, because in a permutation of 0 to n-1, the maximum value is n-1. If I can find the index of n-1, that might help me.

Wait, but I need a pair of elements, not just one.

Alternatively, maybe I can find the two elements that have the highest OR, and then see what their XOR is.

But the problem is to maximize XOR, not OR.

I need to relate OR to XOR.

Let me think differently. Since XOR is about differing bits, and OR is about any set bits, maybe I can use the queries to compare bits of the numbers.

Perhaps I can try to determine the highest bit where the two numbers differ.

But how?

Let me consider the properties of XOR and OR.

For two numbers a and b:

- a OR b sets a bit if either a or b has that bit set.

- a XOR b sets a bit if a and b differ in that bit.

To maximize a XOR b, I need as many high-order bits to be different as possible.

So, if I can find two numbers that differ in the most significant bit, that would be ideal.

For example, in a 4-bit number, if one number has the highest bit 1 and the other has it 0, their XOR would have the highest bit set, which maximizes the XOR value.

So, perhaps I can try to partition the numbers based on their highest bit and find one from each partition.

But I don't know the actual values; I only know them through comparisons of their ORs.

This is tricky.

Let me consider the maximum possible XOR.

In a permutation from 0 to n-1, the maximum XOR would be between two numbers that differ in all the bits, or as many bits as possible.

For example, if n is 4 (numbers 0 to 3), the maximum XOR is between 0 (00) and 3 (11), which is 3 (11).

Another example: n=5 to 7, maximum XOR is between 6 (110) and 7 (111), which is 1 (001).

Wait, that's not correct. 6 XOR 7 is 1, but 5 XOR 7 is 2, and 5 XOR 6 is 3.

Wait, in binary:

5 is 101

6 is 110

7 is 111

5 XOR 6 is 011 which is 3

5 XOR 7 is 010 which is 2

6 XOR 7 is 001 which is 1

So, the maximum XOR is between 5 and 6, which is 3.

So, in this case, the maximum XOR is 3, which is achieved by 5 XOR 6.

How does this relate to their OR values?

5 OR 6 is 7, 5 OR 7 is 7, 6 OR 7 is 7.

So, in this case, all pairs have the same OR.

Hmm, that's interesting.

So, in this case, comparing ORs doesn't directly tell me which pairs have higher XOR.

Wait, but in this specific example, the pair with the maximum XOR is 5 and 6, which is not directly distinguishable from other pairs based on OR values.

So, maybe I need a different approach.

Let me think about the properties of XOR and OR.

I need to maximize p_i XOR p_j.

XOR is maximized when p_i and p_j differ in as many high-order bits as possible.

So, perhaps I need to find two numbers that differ in the most significant bit possible.

To do that, I need to know the most significant bit where they differ.

But I don't have direct access to the bits; I can only compare ORs of pairs.

Wait, maybe I can try to find the maximum and minimum values in the permutation, and see their XOR.

But that might not give me the maximum possible XOR.

For example, in n=4, permutation [0,1,2,3], maximum is 3 and minimum is 0.

0 XOR 3 is 3, which is the maximum possible in this case.

Similarly, in n=5 to 7, [4,5,6,7], maximum is 7 and minimum is 4.

4 XOR 7 is 3, which is the same as 5 XOR 6.

So, maybe choosing the minimum and maximum values gives me the maximum XOR.

But is that always the case?

Let's check for n=8 to 10, [8,9,10,11], maximum is 11 and minimum is 8.

8 is 1000, 11 is 1011.

8 XOR 11 is 0011 which is 3.

But 9 XOR 10 is 1001 XOR 1010 = 0011 which is also 3.

So, in this case, both pairs give the same XOR.

Another example: n=3, permutation [0,1,2], maximum is 2 and minimum is 0.

0 XOR 2 is 2.

But 1 XOR 2 is 3, which is higher.

Wait, hold on.

In n=3, numbers are 0,1,2.

0 is 00, 1 is 01, 2 is 10.

0 XOR 1 is 1, 0 XOR 2 is 2, 1 XOR 2 is 3.

So, the maximum XOR is 3, which is between 1 and 2.

But according to my earlier assumption, choosing min (0) and max (2) gives XOR 2, which is not the maximum.

So, my assumption is wrong in this case.

Hence, choosing min and max does not always give the maximum XOR.

So, I need a better strategy.

Let me think about the binary representation of the numbers.

To maximize XOR, I need the two numbers to differ in the most significant bit possible.

So, for example, if n=4, numbers are 0 (00), 1 (01), 2 (10), 3 (11).

The most significant bit where numbers differ is the second bit.

Pairs that differ in that bit are (0,2), (0,3), (1,2), (1,3).

Their XORs are:

0 XOR 2 = 2 (10)

0 XOR 3 = 3 (11)

1 XOR 2 = 3 (11)

1 XOR 3 = 2 (10)

So, the maximum XOR is 3.

Similarly, in n=5 to 7, [4,5,6,7], binary:

4: 100

5: 101

6: 110

7: 111

The most significant bit where they differ is the second bit from the left.

Pairs that differ in that bit are (4,5), (4,6), (4,7), (5,6), (5,7), (6,7).

Their XORs:

4 XOR 5 = 1 (001)

4 XOR 6 = 2 (010)

4 XOR 7 = 3 (011)

5 XOR 6 = 3 (011)

5 XOR 7 = 2 (010)

6 XOR 7 = 1 (001)

So, the maximum XOR is 3.

In this case, choosing the min and max gives 4 XOR 7 = 3, which is the maximum.

But in the earlier n=3 case, choosing min and max gives 0 XOR 2 = 2, while the actual maximum is 3.

So, perhaps I need to find a pair that differs in the most significant bit, and among those, choose the ones with the highest XOR.

But how do I do that using only comparisons of ORs?

Let me consider that OR gives me an idea of the highest set bits.

If I can find the elements with the highest set bits, that might help.

Wait, but OR is not directly giving me the XOR.

I need to think differently.

Let me consider that for any two elements, their OR will have bits set if either of them has that bit set.

While their XOR will have bits set only if they differ in that bit.

So, perhaps I can try to find elements where their OR is as large as possible, and their XOR is also large.

But I need to maximize XOR, not OR.

Wait, maybe I can find the two elements that have the highest individual values, because in a permutation, higher values have higher bits set.

But in the n=3 case, that didn't work.

Alternatively, maybe I can find the element with the highest value and pair it with the one that has the next highest value but differs in the most significant bit.

But how do I find that?

This is getting complicated.

Let me look at the given program and see what it's doing.

The program has two functions: func_1 and func_2.

func_1 takes four indices a, b, c, d, queries the comparison between (p_a OR p_b) and (p_c OR p_d), and returns '<', '>', or '='.

func_2 seems to be the main function that solves the problem for a given n.

In func_2:

- It initializes max_item_idx to 0.

- Then, it loops from i=1 to n-1, and for each i, it queries the OR of max_item_idx with itself versus the OR of i with itself.

- If the query returns '<', it updates max_item_idx to i.

- After finding this max_item_idx, it then looks for a pair_idx such that the OR of max_item_idx and pair_idx is maximized.

- It does this by comparing the OR of max_item_idx and pair_idx with the OR of max_item_idx and i for all i.

- If the OR of max_item_idx and i is greater than the current OR of max_item_idx and pair_idx, it updates pair_idx to i.

- If the ORs are equal, it compares the OR of pair_idx with itself and i with itself, and if i has a higher self-OR, it updates pair_idx to i.

- Finally, it prints the indices of max_item_idx and pair_idx.

Wait, but in the first loop, it's finding the index of the maximum p_i, because comparing p_i OR p_i is just p_i, since p_i OR p_i is p_i.

So, by comparing p_a OR p_a with p_i OR p_i, it's effectively comparing p_a with p_i, and finding the maximum p_i.

Then, in the second loop, it's trying to find a pair where the OR with this maximum p_i is as large as possible.

But, we need to maximize p_i XOR p_j, not p_i OR p_j.

Wait, but in the first step, it's finding the maximum p_i, which is n-1, since it's a permutation of 0 to n-1.

Then, in the second step, it's trying to find a p_j such that p_i OR p_j is maximized.

But p_i is already the maximum, so p_i OR p_j is p_i for any p_j, because p_i has all the bits set that are set in p_j.

Wait, is that true?

Wait, no.

If p_i is n-1, which is all bits set up to log2(n-1), then p_i OR p_j is p_i for any p_j.

Because p_i has all bits set that any p_j could have.

So, p_i OR p_j would always be p_i.

Therefore, comparing p_i OR p_j with p_i OR p_k would always be equal, since p_i OR p_j = p_i OR p_k = p_i.

So, in this case, the second loop is comparing p_i OR p_j with p_i OR p_k, which is always equal, since p_i is the maximum.

Therefore, the comparisons in the second loop don't provide any useful information, because p_i OR p_j is always p_i.

Hence, this approach is flawed.

Wait, but in the example given, it seems to work.

In the first test case, n=4, p=[0,3,1,2].

The first loop finds max_item_idx as 3, since p_3=2 is the maximum.

Wait, p_1=3 is greater than p_3=2.

Wait, no, p_1=3 is greater than p_3=2.

Wait, no, p_3=2 is not greater than p_1=3.

Wait, the permutation is p=[0,3,1,2], so p_0=0, p_1=3, p_2=1, p_3=2.

So, in the first loop, it starts with max_item_idx=0 (p_0=0).

Then, for i=1 (p_1=3), it compares p_0 OR p_0 = 0 with p_1 OR p_1 = 3.

Since 0 < 3, it sets max_item_idx=1.

Then, for i=2 (p_2=1), compares p_1 OR p_1 = 3 with p_2 OR p_2 = 1.

Since 3 > 1, no change.

For i=3 (p_3=2), compares p_1 OR p_1 = 3 with p_3 OR p_3 = 2.

Since 3 > 2, no change.

So, max_item_idx=1, which is p_1=3.

Then, in the second loop, it sets pair_idx=1.

Then, for i=0 to 3:

- i=0: compare p_1 OR p_1 = 3 with p_1 OR p_0 = 3 OR 0 = 3. Equal, so check p_1 OR p_1 vs p_0 OR p_0: 3 > 0, so no change.

- i=1: compare p_1 OR p_1 = 3 with p_1 OR p_1 = 3. Equal, no change.

- i=2: compare p_1 OR p_2 = 3 OR 1 = 3 with p_1 OR pair_idx=3. Equal, so check p_2 OR p_2 vs p_pair_idx OR p_pair_idx: 1 vs 3. Since 1 < 3, no change.

- i=3: compare p_1 OR p_3 = 3 OR 2 = 3 with p_1 OR pair_idx=3. Equal, so check p_3 OR p_3 vs p_pair_idx OR p_pair_idx: 2 vs 3. Since 2 < 3, no change.

So, pair_idx remains 1.

Then, it prints ! 1 1.

Wait, but in the example, it prints ! 3 2.

So, perhaps there's a mistake in the explanation or in my understanding.

Wait, perhaps I misread the code.

Looking back at the code:

def func_2(n):

max_item_idx = 0

for i in range(1, n):

ans = func_1(max_item_idx, max_item_idx, i, i)

if ans == '<':

max_item_idx = i

pair_idx = max_item_idx

for i in range(n):

ans1 = func_1(max_item_idx, pair_idx, max_item_idx, i)

if ans1 == '<':

pair_idx = i

elif ans1 == '=':

ans2 = func_1(pair_idx, pair_idx, i, i)

if ans2 == '>':

pair_idx = i

print(f'! {max_item_idx} {pair_idx}')

In the first loop, it's finding the index with the maximum p_i, which is correct.

Then, in the second loop, it's trying to find a p_j such that p_max OR p_j is maximized.

But as I thought earlier, since p_max is the maximum, p_max OR p_j is always p_max.

So, all comparisons in the second loop are going to be equal.

Hence, pair_idx remains max_item_idx.

So, it would print ! max_item_idx max_item_idx, which in the example is !1 1, but in the example output, it's !3 2.

So, perhaps there's a misunderstanding.

Wait, in the example, n=4, p=[0,3,1,2].

The first loop finds max_item_idx=1 (p_1=3).

Then, in the second loop:

for i in range(4):

ans1 = ? 1 1 1 i

Which is p_1 OR p_1 vs p_1 OR p_i.

Since p_1=3, p_1 OR p_i is:

- i=0: 3 OR 0 = 3

- i=1: 3 OR 3 = 3

- i=2: 3 OR 1 = 3

- i=3: 3 OR 2 = 3

So, all comparisons are equal.

Hence, pair_idx remains 1.

But in the example interaction, it seems to choose !3 2.

So, perhaps there's a mistake in the code or in the explanation.

Wait, perhaps the code is different from what I think.

Looking back, in the example interaction, the queries are:

? 0 2 3 1 -> < because (0 OR 1)=1 < (2 OR 3)=3

? 1 1 2 3 -> = because (3 OR 3)=3 == (1 OR 2)=3

? 1 2 0 3 -> > because (3 OR 1)=3 > (0 OR 3)=2

Then, it prints !3 2.

So, perhaps the code is different or there's some misinterpretation.

Wait, perhaps the code is not matching the explanation.

Looking back at the code:

def func_2(n):

max_item_idx = 0

for i in range(1, n):

ans = func_1(max_item_idx, max_item_idx, i, i)

if ans == '<':

max_item_idx = i

pair_idx = max_item_idx

for i in range(n):

ans1 = func_1(max_item_idx, pair_idx, max_item_idx, i)

if ans1 == '<':

pair_idx = i

elif ans1 == '=':

ans2 = func_1(pair_idx, pair_idx, i, i)

if ans2 == '>':

pair_idx = i

print(f'! {max_item_idx} {pair_idx}')

In the example, n=4.

First loop:

- max_item_idx=0 (p_0=0)

- i=1: ? 0 0 1 1 -> 0 < 3 -> set max_item_idx=1

- i=2: ? 1 1 2 2 -> 3 > 1 -> no change

- i=3: ? 1 1 3 3 -> 3 > 2 -> no change

So, max_item_idx=1 (p_1=3)

Then, pair_idx=1

Second loop:

for i in 0,1,2,3:

ans1 = ? 1 pair_idx=1, 1 i

So:

- i=0: ? 1 1 1 0 -> (3 OR 3)=3 vs (3 OR 0)=3 -> '='

- Then, ans2 = ? pair_idx=1 1 vs i=0 0 -> (3 OR 3)=3 > (0 OR 0)=0 -> set pair_idx=0

- i=1: ? 1 0 1 1 -> (3 OR 0)=3 vs (3 OR 1)=3 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 3 -> no change

- i=2: ? 1 0 1 2 -> (3 OR 0)=3 vs (3 OR 1)=3 -> '='

- ans2 = ? 0 0 vs 2 2 -> 0 < 1 -> no change

- i=3: ? 1 0 1 3 -> (3 OR 0)=3 vs (3 OR 2)=3 -> '='

- ans2 = ? 0 0 vs 3 3 -> 0 < 2 -> no change

So, pair_idx=0

Then, it should print !1 0

But in the example, it prints !3 2

So, either the code is different or there's a mistake.

Wait, perhaps there's a misunderstanding in the way the indices are being used.

Wait, in the example interaction, the queries are:

? 0 2 3 1 -> <

? 1 1 2 3 -> =

? 1 2 0 3 -> >

And then !3 2

So, perhaps the code is different from what I have.

Looking back, maybe the code is:

def func_2(n):

max_item_idx = 0

for i in range(1, n):

ans = func_1(max_item_idx, max_item_idx, i, i)

if ans == '<':

max_item_idx = i

pair_idx = max_item_idx

for i in range(n):

ans1 = func_1(max_item_idx, pair_idx, max_item_idx, i)

if ans1 == '<':

pair_idx = i

elif ans1 == '=':

ans2 = func_1(pair_idx, pair_idx, i, i)

if ans2 == '>':

pair_idx = i

print(f'! {max_item_idx} {pair_idx}')

But in the example, it seems to choose !3 2, but according to this code, it should choose !1 0.

So, perhaps there's a mistake in the code.

Alternatively, maybe the code is correct, and the example is just showing one possible correct answer, since multiple pairs can have the same maximum XOR.

In this case, both !1 0 and !3 2 give XOR=3, which is the maximum.

So, perhaps the code is correct, and it's choosing !1 0, which is also correct.

But in the example, it shows !3 2, which is also correct.

Hence, as long as any correct pair is chosen, it's acceptable.

But I need to ensure that the code always finds a pair with the maximum XOR.

Given that, I need to verify if this approach guarantees that.

From earlier analysis, it seems that in some cases, this approach might not choose the optimal pair.

For example, in n=3, [0,1,2], it would choose max_item_idx=1 (p_1=1), then in the second loop:

- i=0: ? 1 1 1 0 -> (1 OR 1)=1 vs (1 OR 0)=1 -> '='

- ans2 = ? 1 1 vs 0 0 -> 1 > 0 -> set pair_idx=0

- i=1: ? 1 0 1 1 -> (1 OR 0)=1 vs (1 OR 1)=1 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 1 -> no change

- i=2: ? 1 0 1 2 -> (1 OR 0)=1 vs (1 OR 2)=3 -> '<' -> set pair_idx=2

- i=3: n=3, only i=0,1,2

So, pair_idx=2

Then, print !1 2, which is correct, since 1 XOR 2 = 3.

Wait, but earlier I thought it would choose !1 0, but in this case, it chooses !1 2 because of the '<' condition.

Wait, n=3 is [0,1,2], max_item_idx=1 (p_1=1)

Second loop:

- i=0: ? 1 1 1 0 -> (1 OR 1)=1 vs (1 OR 0)=1 -> '='

- ans2 = ? 1 1 vs 0 0 -> 1 > 0 -> set pair_idx=0

- i=1: ? 1 0 1 1 -> (1 OR 0)=1 vs (1 OR 1)=1 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 1 -> no change

- i=2: ? 1 0 1 2 -> (1 OR 0)=1 vs (1 OR 2)=3 -> '<' -> set pair_idx=2

Hence, pair_idx=2

So, it chooses !1 2, which is correct.

Earlier, in n=4, p=[0,3,1,2], it chooses !1 0, but in the example, it shows !3 2, which is also correct.

So, perhaps the code is correct.

Let me see another example.

Consider n=5, p=[4,5,6,7,0]

First loop:

- max_item_idx=0 (p_0=4)

- i=1: ? 0 0 1 1 -> (4 OR 4)=4 < (5 OR 5)=5 -> set max_item_idx=1

- i=2: ? 1 1 2 2 -> (5 OR 5)=5 > (6 OR 6)=6 -> set max_item_idx=2

- i=3: ? 2 2 3 3 -> (6 OR 6)=6 < (7 OR 7)=7 -> set max_item_idx=3

- i=4: ? 3 3 4 4 -> (7 OR 7)=7 > (0 OR 0)=0 -> no change

So, max_item_idx=3 (p_3=7)

Second loop:

pair_idx=3

- i=0: ? 3 3 3 0 -> (7 OR 3)=7 vs (7 OR 0)=7 -> '='

- ans2 = ? 3 3 vs 0 0 -> 7 > 0 -> set pair_idx=0

- i=1: ? 3 0 3 1 -> (7 OR 0)=7 vs (7 OR 1)=7 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 1 -> no change

- i=2: ? 3 0 3 2 -> (7 OR 0)=7 vs (7 OR 2)=7 -> '='

- ans2 = ? 0 0 vs 2 2 -> 0 < 2 -> no change

- i=3: ? 3 0 3 3 -> (7 OR 0)=7 vs (7 OR 3)=7 -> '='

- ans2 = ? 0 0 vs 3 3 -> 0 < 7 -> no change

- i=4: ? 3 0 3 4 -> (7 OR 0)=7 vs (7 OR 0)=7 -> '='

- ans2 = ? 0 0 vs 4 4 -> 0 < 0 -> no change

So, pair_idx=0

Hence, it chooses !3 0, which is p_3=7 and p_0=4, XOR=3.

But the actual maximum XOR is between p_5=0 and p_6=1, which is 1 XOR 0=1, but n=5, p=[4,5,6,7,0]

Wait, n=5, p=[4,5,6,7,0]

Possible XORs:

4: 100

5: 101

6: 110

7: 111

0: 000

XOR pairs:

4^5=1

4^6=2

4^7=3

4^0=4

5^6=3

5^7=2

5^0=5

6^7=1

6^0=6

7^0=7

So, the maximum XOR is 7, between 7 and 0.

But the code chooses !3 0, which is 7 XOR 0 = 7, which is correct.

So, in this case, it works.

Another test case: n=3, p=[0,1,2]

First loop:

- max_item_idx=0 (p_0=0)

- i=1: ? 0 0 1 1 -> 0 < 1 -> set max_item_idx=1

- i=2: ? 1 1 2 2 -> 1 > 1 -> no change

So, max_item_idx=1 (p_1=1)

Second loop:

pair_idx=1

- i=0: ? 1 1 1 0 -> (1 OR 1)=1 vs (1 OR 0)=1 -> '='

- ans2 = ? 1 1 vs 0 0 -> 1 > 0 -> set pair_idx=0

- i=1: ? 1 0 1 1 -> (1 OR 0)=1 vs (1 OR 1)=1 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 1 -> no change

- i=2: ? 1 0 1 2 -> (1 OR 0)=1 vs (1 OR 2)=3 -> '<' -> set pair_idx=2

Hence, pair_idx=2

So, it chooses !1 2, which is 1 XOR 2 = 3, which is the maximum.

So, in this case, it works.

Another test case: n=5, p=[0,1,2,3,4]

First loop:

- max_item_idx=0 (p_0=0)

- i=1: ? 0 0 1 1 -> 0 < 1 -> set max_item_idx=1

- i=2: ? 1 1 2 2 -> 1 < 2 -> set max_item_idx=2

- i=3: ? 2 2 3 3 -> 2 < 3 -> set max_item_idx=3

- i=4: ? 3 3 4 4 -> 3 < 4 -> set max_item_idx=4

Second loop:

pair_idx=4

- i=0: ? 4 pair_idx=4, 4 0 -> (4 OR 4)=4 vs (4 OR 0)=4 -> '='

- ans2 = ? 4 4 vs 0 0 -> 4 > 0 -> set pair_idx=0

- i=1: ? 4 0 4 1 -> (4 OR 0)=4 vs (4 OR 1)=4 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 1 -> no change

- i=2: ? 4 0 4 2 -> (4 OR 0)=4 vs (4 OR 2)=4 -> '='

- ans2 = ? 0 0 vs 2 2 -> 0 < 2 -> no change

- i=3: ? 4 0 4 3 -> (4 OR 0)=4 vs (4 OR 3)=4 -> '='

- ans2 = ? 0 0 vs 3 3 -> 0 < 3 -> no change

- i=4: ? 4 0 4 4 -> (4 OR 0)=4 vs (4 OR 4)=4 -> '='

- ans2 = ? 0 0 vs 4 4 -> 0 < 4 -> no change

So, pair_idx=0

Hence, !4 0, which is p_4=4 and p_0=0, XOR=4, which is the maximum in this case.

So, seems correct.

Another test case: n=6, p=[0,1,2,3,4,5]

First loop:

- max_item_idx=0 (p_0=0)

- i=1: ? 0 0 1 1 -> 0 < 1 -> set max_item_idx=1

- i=2: ? 1 1 2 2 -> 1 < 2 -> set max_item_idx=2

- i=3: ? 2 2 3 3 -> 2 < 3 -> set max_item_idx=3

- i=4: ? 3 3 4 4 -> 3 < 4 -> set max_item_idx=4

- i=5: ? 4 4 5 5 -> 4 < 5 -> set max_item_idx=5

Second loop:

pair_idx=5

- i=0: ? 5 5 5 0 -> (5 OR 5)=5 vs (5 OR 0)=5 -> '='

- ans2 = ? 5 5 vs 0 0 -> 5 > 0 -> set pair_idx=0

- i=1: ? 5 0 5 1 -> (5 OR 0)=5 vs (5 OR 1)=5 -> '='

- ans2 = ? 0 0 vs 1 1 -> 0 < 1 -> no change

- i=2: ? 5 0 5 2 -> (5 OR 0)=5 vs (5 OR 2)=5 -> '='

- ans2 = ? 0 0 vs 2 2 -> 0 < 2 -> no change

- i=3: ? 5 0 5 3 -> (5 OR 0)=5 vs (5 OR 3)=5 -> '='

- ans2 = ? 0 0 vs 3 3 -> 0 < 3 -> no change

- i=4: ? 5 0 5 4 -> (5 OR 0)=5 vs (5 OR 4)=5 -> '='

- ans2 = ? 0 0 vs 4 4 -> 0 < 4 -> no change

- i=5: ? 5 0 5 5 -> (5 OR 0)=5 vs (5 OR 5)=5 -> '='

- ans2 = ? 0 0 vs 5 5 -> 0 < 5 -> no change

So, pair_idx=0

Hence, !5 0, which is p_5=5 and p_0=0, XOR=5, which is the maximum.

Seems correct.

Wait, but in n=3, p=[0,1,2], !1 2 gives XOR=3, which is higher than p_5=5 XOR p_0=0=5.

Wait, n=6, p=[0,1,2,3,4,5], p_5=5, p_0=0, XOR=5.

But p_2=2, p_3=3, XOR=1.

Wait, 2 XOR 3 is 1.

Wait, no, 2 is 10, 3 is 11, XOR is 01, which is 1.

Wait, but earlier I thought p_5=5 and p_0=0 gives XOR=5, which is higher than p_2=2 and p_3=3 giving XOR=1.

Hence, choosing !5 0 is correct.

Wait, but in n=3, p=[0,1,2], !1 2 gives XOR=3, which is higher than p_2=2 XOR p_3=3 would be 1, but n=3 only goes up to 2.

Wait, n=3, p=[0,1,2], p_1=1 XOR p_2=2 gives 3, which is higher than p_5=5 XOR p_0=0=5.

Wait, n=6 is p=[0,1,2,3,4,5], p_5=5 XOR p_0=0=5.

But p_2=2 XOR p_3=3=1, which is less than 5.

Hence, choosing !5 0 is correct.

So, in all these cases, the code seems to choose a correct pair.

Hence, it seems that the code is correct.

Therefore, Correctness: **True**

**Final Solution**

To solve this problem, we need to find a pair of indices in a secret permutation that maximizes the bitwise XOR of the elements at those indices. We can interact with the judge to query comparisons of bitwise OR operations between pairs of elements.

### Approach

1. **Finding the Maximum Element:**
   - We first identify the index of the maximum element in the permutation by comparing the OR of each element with itself. Since `p_i | p_i = p_i`, this step effectively finds the largest value in the permutation.

2. **Finding the Optimal Pair:**
   - Once we have the index of the maximum element, we look for another element that, when combined with the maximum element, gives us the desired properties for maximizing the XOR.
   - We iterate through all other elements, using comparisons to determine the best candidate to pair with the maximum element.

### Solution Code

```python
import sys

t = int(input())
for _ in range(t):
    n = int(input())
    func_2(n)

def func_1(a, b, c, d):
    request = f'? {a} {b} {c} {d}'
    print(request, flush=True)
    return input()

def func_2(n):
    max_item_idx = 0
    for i in range(1, n):
        ans = func_1(max_item_idx, max_item_idx, i, i)
        if ans == '<':
            max_item_idx = i
    pair_idx = max_item_idx
    for i in range(n):
        ans1 = func_1(max_item_idx, pair_idx, max_item_idx, i)
        if ans1 == '<':
            pair_idx = i
        elif ans1 == '=':
            ans2 = func_1(pair_idx, pair_idx, i, i)
            if ans2 == '>':
                pair_idx = i
    print(f'! {max_item_idx} {pair_idx}')
```

### Explanation

1. **Finding the Maximum Element:**
   - We initialize `max_item_idx` to 0 and then iterate from 1 to n-1.
   - For each index `i`, we query the comparison between `p[max_item_idx] | p[max_item_idx]` and `p[i] | p[i]`. If `p[max_item_idx] < p[i]`, we update `max_item_idx` to `i`.
   
2. **Finding the Optimal Pair:**
   - We initialize `pair_idx` to `max_item_idx`.
   - We iterate through all indices from 0 to n-1.
   - For each index `i`, we query the comparison between `p[max_item_idx] | p[pair_idx]` and `p[max_item_idx] | p[i]`.
     - If `p[max_item_idx] | p[i] > p[max_item_idx] | p[pair_idx]`, we update `pair_idx` to `i`.
     - If they are equal, we compare `p[pair_idx] | p[pair_idx]` with `p[i] | p[i]`. If `p[i] > p[pair_idx]`, we update `pair_idx` to `i`.
   
3. **Output the Result:**
   - After determining the optimal pair, we print the indices `max_item_idx` and `pair_idx` in the format `! i j`.

This approach ensures that we find a pair with the maximum possible XOR value using the allowed queries efficiently within the constraints.