Alright, I have this problem to solve. It's about trees in graph theory, which I've dealt with before, but I need to make sure I understand everything correctly. So, let's break it down step by step.

First, the problem gives me a tree with n vertices, and I need to remove exactly k edges from this tree. After removing these edges, the tree will split into several connected components, and I need to ensure that each of these components has at least x vertices. My task is to find the maximum possible x that allows me to do this.

Okay, so trees are special because they're connected graphs with no cycles, and removing any edge will split them into exactly two connected components. That's a crucial property here.

Given that, if I remove k edges, the tree will be split into k+1 connected components. Each of these components should have at least x vertices, and I need to maximize x.

So, the total number of vertices is n, and there are k+1 components after removal. If each component has at least x vertices, then (k+1)*x <= n. So, x <= n/(k+1). But since x has to be an integer, x <= floor(n/(k+1)).

Wait, but the problem seems to suggest that the answer might be higher sometimes, based on the example. So, perhaps there's more to it than just dividing n by k+1.

Looking back at the example:

Input:

5 1

1 2

1 3

3 4

3 5

If we remove the edge between 1 and 3, we get two components: one with vertices 1 and 2, and another with 3, 4, and 5. So, the sizes are 2 and 3, and the minimum is 2. Apparently, it's not possible to get x=3 because one component would have only two vertices.

Another input:

2 1

1 2

Removing the only edge gives two components, each with one vertex. So, x=1.

Another one:

6 1

1-2-3-4-5-6

Removing one edge will split it into two components, say 1-2-3 and 4-5-6, each with three vertices. So, x=3.

Wait, but in this case, n=6, k=1, so k+1=2 components. floor(6/2)=3, which matches the output.

Another one:

3 1

1-2-3

Removing one edge could result in components of size 1 and 2, so x=1.

But according to the formula floor(3/2)=1, which matches.

Next:

8 2

Removing two edges from a tree with 8 nodes will result in three components. floor(8/3)=2, which seems to match the output of 2 in the example.

And the last one:

6 2

Removing two edges from a tree with six nodes results in three components. floor(6/3)=2, but the output is 1.

Wait, why is that? Maybe because of the specific structure of the tree.

Hmm, perhaps the formula floor(n/(k+1)) is not always achievable, depending on the tree's structure.

So, maybe I need to consider the tree's structure to determine the maximum x.

I need to think about how to approach this.

I recall that in trees, we can perform depth-first search (DFS) to explore the structure and calculate the size of subtrees.

Perhaps I can consider dynamic programming or some way to partition the tree into components of at least size x.

Wait, maybe a binary search approach on x, and for each x, check if it's possible to remove k edges such that all components have at least x vertices.

Since x has to be an integer between 1 and n, I can binary search x from 1 to n.

For each x, I need to check if I can remove k edges to get components with at least x vertices.

Given that trees are trees, I can probably traverse the tree and see how many components of at least size x I can form.

Let me think about the binary search approach.

Set low = 1 and high = n.

While low <= high:

mid = (low + high) // 2

If it's possible to remove k edges such that all components have at least mid vertices:

low = mid + 1

Else:

high = mid - 1

Then, the answer is high.

Now, the key is to implement the "is possible" function efficiently.

Given that n can be up to 10^5 and t up to 10^4, but the sum of n across all test cases is up to 10^5, I need an efficient solution.

So, per test case, I need something faster than O(n^2).

I think DFS can help here.

I can perform a DFS to calculate the size of each subtree.

Then, for a given x, I can count how many edges I need to remove to separate the tree into components where each component has at least x nodes.

Wait, perhaps I need to count the number of components that would have at least x nodes, and see if the number of edges to remove is <= k.

But I need to remove exactly k edges, so I need to ensure that after removing k edges, all components have at least x nodes.

Wait, no, it's exactly k edges.

But in the problem statement, it's "exactly k edges".

Hmm, but in the example explanation, it's "at least x".

Wait, let me read the problem again.

"the size of each remaining connected component is at least x"

So, all components must have at least x nodes.

And we need to remove exactly k edges.

Wait, but in the first sample input, removing one edge results in components of size 2 and 3, and x=2.

But if I remove one edge, I have two components, and x=2.

But what if I could remove two edges and get three components of size >=2?

Wait, but the problem says to remove exactly k edges.

So, in the first sample, n=5, k=1.

If I remove one edge, I get two components, and both have at least x=2 nodes.

If I remove two edges, I get three components, but in that case, one of them might have only one node, which is less than x=2.

Wait, but in the first sample, the answer is 2, which requires removing one edge.

If I remove two edges, I might get components of sizes 1, 1, and 3, which wouldn't satisfy x=1, but the problem seems to allow x=1 in some cases.

Wait, no, in the third sample input:

6 1

1-2-3-4-5-6

If I remove one edge, say between 3 and 4, I get two components: 1-2-3 and 4-5-6, each with three nodes, so x=3.

If I remove two edges, I get three components, each with two nodes, so x=2.

But the problem says to remove exactly k edges, so in this case, k=1, so I have to remove one edge and get components with at least x=3 nodes.

But if I remove two edges, I can get x=2, but the problem specifies removing exactly k edges.

Wait, but in the third sample, n=6, k=1, and the output is 3, which matches removing one edge and getting two components of three nodes each.

In the last sample, n=6, k=2, and the output is 2, which matches removing two edges and getting three components of two nodes each.

So, in this case, removing more edges allows for smaller components, but I need to ensure that all components have at least x nodes.

Wait, but in the problem statement, it's to maximize x, given that I remove exactly k edges.

Wait, maybe I need to minimize the number of components, which would maximize x.

Wait, no, I need to maximize x such that after removing exactly k edges, all components have at least x nodes.

This seems a bit tricky.

Let me think differently.

Suppose I perform a DFS and calculate the size of each subtree.

Then, for a given x, I can count how many edges I need to remove to separate the tree into components where each component has at least x nodes.

If the number of edges I need to remove is less than or equal to k, then it's possible.

Wait, but the problem requires removing exactly k edges.

Hmm.

Wait, perhaps I need to find the maximum x such that the number of components with at least x nodes is k+1.

Because removing k edges results in k+1 components.

But I need to ensure that each of these k+1 components has at least x nodes.

Wait, perhaps I need to maximize x where the total number of components with at least x nodes is k+1.

But I need to confirm this.

Let me consider the first sample input again.

n=5, k=1.

Possible x is 2.

After removing one edge, I have two components: one with 2 nodes and one with 3 nodes, both >=2.

If I try x=3, then I need both components to have at least 3 nodes.

But in the first sample, one component has only 2 nodes, so x=3 is not possible.

Hence, x=2 is the maximum possible.

In the second sample:

n=2, k=1.

Removing one edge gives two components with one node each, so x=1.

In the third sample:

n=6, k=1.

Removing one edge gives two components with three nodes each, so x=3.

In the fourth sample:

n=3, k=1.

Removing one edge gives two components with one and two nodes, so x=1.

In the fifth sample:

n=8, k=2.

Removing two edges gives three components, and the minimum size is 2, so x=2.

In the sixth sample:

n=6, k=2.

Removing two edges gives three components with two nodes each, so x=2.

Okay, so in all these cases, the number of components is k+1, and x is the minimum size of these components.

So, perhaps I can perform a binary search on x, and for each x, count the number of components that would have at least x nodes.

If the number of components is <= k+1, then it's possible to remove k edges to achieve this.

Wait, but in the first sample, with x=2, number of components is 2, which is k+1=2.

With x=3, number of components is still 2, but one component has only 2 nodes, so it's invalid.

Wait, perhaps I need to count the number of components that have at least x nodes, and ensure that the total number of components is <= k+1.

But I need to make sure that all components have at least x nodes.

Wait, maybe I need to calculate the minimal x such that the tree can be divided into k+1 components, each with at least x nodes.

Wait, perhaps I need to maximize x where the tree can be divided into k+1 components, each with at least x nodes.

This sounds similar to balancing the components.

I think the binary search approach is viable.

Set low = 1 and high = n.

While low <= high:

mid = (low + high) // 2

If I can divide the tree into k+1 components, each with at least mid nodes:

low = mid + 1

Else:

high = mid - 1

Then, the answer is high.

Now, I need to implement the "can divide into k+1 components with at least mid nodes" efficiently.

I think I can perform a DFS and count the number of subtrees with size >= mid.

If the number of such subtrees is >= k+1, then it's possible.

Wait, but I need to ensure that after removing k edges, all components have at least mid nodes.

Wait, perhaps I need to count the number of components that have at least mid nodes, and see if this number is <= k+1.

Wait, I'm getting confused.

Let me think differently.

Suppose I perform a DFS and calculate the size of each subtree.

Then, for a given x, I can decide to cut edges that separate subtrees of size >= x.

I need to count the number of such cuts.

If the number of cuts is <= k, then it's possible to remove k edges to achieve x.

Wait, perhaps I need to find the minimal number of edges to remove to ensure all components have at least x nodes.

If this minimal number is <= k, then it's possible.

But I need to remove exactly k edges, so it's a bit different.

Wait, maybe I need to find the minimal number of edges to remove to get components with at least x nodes, and ensure that this number is <= k.

But since I have to remove exactly k edges, I need to make sure that removing k edges achieves this.

This seems tricky.

Let me look at the provided code and understand what it's doing.

Looking at the code:

It reads t test cases.

For each test case, it reads n, k, and then n-1 edges.

Then, it calls func_1(n, k, edges).

In func_1:

- It builds the adjacency list for the tree.

- It sets l = 1 and r = n // k

- It performs a binary search between l and r.

- In each step, it calls check(mid), and based on that, adjusts l or r.

- Finally, it prints r.

In check(A):

- It performs a DFS starting from node 1.

- It keeps track of the size of each subtree.

- It counts the number of subtrees with size >= A.

- If the number of such subtrees is > k or if the remaining tree has size >= A and the number of subtrees is == k, then it returns True.

Wait, I need to understand this check function better.

It seems to be counting the number of subtrees with size >= A and seeing if this count is <= k or something.

But I'm not entirely sure.

Let me try to understand the check function.

In check(A):

- It initializes a stack for DFS, starting from node 1.

- It keeps track of visited nodes and the size of each subtree.

- For each node, it explores its unvisited neighbors.

- When backtracking, it checks if the subtree size is >= A.

- If it is, it increments r (which seems to count the number of such subtrees).

- If not, it adds its size to the parent's size.

- Finally, it checks if r > k or if the remaining tree has size >= A and r == k.

This seems close to what I was thinking earlier.

Wait, perhaps r represents the number of components that have size >= A.

If r > k, it means I need to remove at least r-1 edges to separate them.

But the condition is a bit confusing.

I think I need to adjust my understanding.

Let me consider that r represents the number of components that have size >= A.

If r <= k+1, then it's possible to remove k edges to achieve this.

Wait, perhaps.

But in the code, it's checking if r > k or if d[1] >= A and r == k.

I'm getting a bit lost.

Maybe I need to think differently.

Perhaps I should consider that removing an edge separates a subtree of size s from the rest of the tree.

I need to choose k such subtrees to remove, ensuring that all remaining components have at least x nodes.

This seems complicated.

Wait, perhaps a better way is to fix x and try to remove edges to separate components of at least x nodes.

I need to ensure that after removing k edges, all resulting components have at least x nodes.

This is equivalent to partitioning the tree into k+1 components, each with at least x nodes.

So, the minimal x should be such that the tree can be partitioned into k+1 components, each with at least x nodes.

This sounds like a classic binary search problem on trees.

So, I can perform a binary search on x from 1 to n.

For each x, I need to check if the tree can be partitioned into k+1 components, each with at least x nodes.

To check this, I can perform a DFS and count the number of subtrees with size >= x.

If the number of such subtrees is >= k+1, then it's possible.

Wait, but I need to ensure that after removing k edges, all components have at least x nodes.

Wait, perhaps the number of subtrees with size >= x should be <= k+1.

Wait, I need to reconcile this.

If I have m components with size >= x, and m <= k+1, then it's possible to remove k edges to achieve this.

Wait, no.

I think I need to ensure that the number of components with size >= x is <= k+1.

But I need to make sure that all components have at least x nodes.

Wait, perhaps it's better to think in terms of the number of cuts needed.

Each time I remove an edge that separates a subtree of size >= x, I're moving towards creating a component.

So, the number of such cuts should be <= k.

Wait, perhaps the number of components that require separation is <= k+1.

I'm getting tangled here.

Let me look back at the code's check function.

In check(A):

- It performs a DFS and counts the number of subtrees with size >= A.

- If the number of such subtrees is > k, or if the remaining tree has size >= A and the number of subtrees is == k, then it returns True.

Wait, perhaps the idea is that if the number of subtrees with size >= A is > k, then it's possible to remove k edges and still have some components with size >= A.

But I'm not sure.

I think I need to adjust my approach.

Maybe I should consider that for a given x, the minimal number of edges to remove to get components with at least x nodes is equal to the number of subtrees with size >= x minus one.

Because a tree with m components requires m-1 edges to connect them.

So, if I have m subtrees with size >= x, then I need to remove m-1 edges to separate them.

So, if m-1 <= k, then it's possible to remove k edges to achieve this.

Hence, m-1 <= k implies m <= k+1.

So, if the number of subtrees with size >= x is <= k+1, then it's possible.

Wait, but in the code, it's checking if the number of subtrees with size >= A is > k, or if the remaining tree has size >= A and the number of subtrees is == k.

This seems close to what I just thought.

Wait, perhaps the condition should be that the number of subtrees with size >= x is <= k+1.

If that's the case, then in the binary search:

- If the number of subtrees with size >= x is <= k+1, then it's possible to remove <= k edges to separate them.

- So, if this is true, then x could be higher.

- Else, x needs to be lower.

Hence, in the binary search:

- If number of subtrees with size >= x <= k+1, then set low = x + 1

- Else, set high = x - 1

Then, the answer is high.

This makes sense.

So, in the check function, it should return True if the number of subtrees with size >= x <= k+1.

But in the code, it's returning True if r > k or (d[1] >= A and r == k).

Wait, perhaps the variable r is counting something differently.

I need to understand the variable r in the check function.

In check(A):

- r is initialized to 0

- During DFS, for each subtree with size >= A, r is incremented.

- Finally, it checks if r > k or (d[1] >= A and r == k)

Wait, d[1] is the size of the remaining tree after removing subtrees with size >= A.

So, if r > k, it means I have more than k+1 components with size >= A, which would require more than k edges to separate.

But in the condition, if r > k or (d[1] >= A and r == k), return True.

This seems like it's trying to say that if r > k, it's not possible, but if r == k and the remaining tree has size >= A, then it's possible.

But I'm getting confused.

Maybe I need to think differently.

Perhaps I should consider that the number of edges to remove is equal to r.

Because each time I separate a subtree with size >= A, I're removing one edge.

So, if r <= k, it's possible.

But in the code, it's checking r > k or (d[1] >= A and r == k).

Wait, perhaps r is the number of subtrees that are being separated, each requiring one edge removal.

So, if r > k, it's not possible because I need to remove more edges than allowed.

If r == k and the remaining tree has size >= A, then it's possible.

Hence, the condition is returning True if r > k or (d[1] >= A and r == k).

Wait, but in the binary search:

- If check(A) is True, set l = mid + 1

- Else, set r = mid - 1

So, if r > k or (d[1] >= A and r == k), then set l = mid + 1

Else, set r = mid - 1

Hence, the answer is r.

This seems logically consistent.

So, in this setup, it's trying to find the maximum A such that the number of subtrees with size >= A is <= k, and the remaining tree has size >= A.

This ensures that after removing k edges, all components have at least A nodes.

This makes sense.

Therefore, the provided code seems to be implementing this logic correctly.

Hence, the program is correct.

**Final Answer**

\boxed{2}