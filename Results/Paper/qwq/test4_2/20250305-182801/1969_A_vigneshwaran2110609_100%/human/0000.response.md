Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The p_i are all distinct and no one is their own best friend. Monocarp wants at least 2 friends to come to the party, and a friend comes only if both they and their best friend receive an invitation.

I need to figure out the minimum number of invitations Monocarp has to send to achieve this.

First, I need to understand the relationships between the friends. Since each friend has a unique best friend and no one is their own best friend, the friendships form pairs or cycles. For example, if friend 1's best friend is 2, and friend 2's best friend is 1, that's a cycle of length 2. If friend 1's best friend is 2, friend 2's best friend is 3, and friend 3's best friend is 1, that's a cycle of length 3, and so on.

The problem is to select a set of friends to invite such that at least 2 friends come to the party, and each coming friend has both them and their best friend invited.

Let me think about how to minimize the number of invitations.

In a cycle of length 2, say friends 1 and 2 are each other's best friends. If I invite both, then both come. If I invite only one, neither comes because the other didn't receive an invitation. So, for a cycle of 2, I need to invite both to have both come, but if I only want at least 2 friends to come, and there are only 2 friends, inviting both is necessary.

Wait, but maybe there are larger cycles, and I can find a way to invite fewer friends to have at least 2 come.

Let's consider a cycle of length 3: 1 -> 2 -> 3 -> 1.

If I invite 1 and 2, then:

- Friend 1 has friend 2 invited, and friend 2 has friend 3 invited, but friend 3 didn't receive an invitation, so friend 2 doesn't come.

Wait, according to the problem, friend 2 comes only if both friend 2 and friend 3 received invitations. So, in this case, friend 2 won't come because friend 3 didn't receive an invitation.

Similarly, friend 1 won't come because friend 2 received an invitation, but friend 2 isn't coming.

So, that doesn't work.

What if I invite 1, 2, and 3?

Then:

- Friend 1 has friend 2 invited, and friend 2 is coming because friend 3 is invited.

- Friend 2 has friend 3 invited, and friend 3 is coming because friend 1 is invited.

- Friend 3 has friend 1 invited, and friend 1 is coming because friend 2 is invited.

So, all three come. But that's more than what I need since I only need at least 2 to come.

Is there a way to invite fewer than 3 in this case? Let's see.

If I invite only 1 and 3:

- Friend 1 has friend 2 not invited, so friend 1 doesn't come.

- Friend 3 has friend 1 invited, but friend 1 isn't coming, so friend 3 doesn't come.

So, no one comes.

Not useful.

If I invite only 2 and 3:

- Friend 2 has friend 3 invited, and friend 3 has friend 1 not invited, so friend 3 doesn't come.

- Since friend 3 isn't coming, friend 2 doesn't come either.

Again, no one comes.

So, in a cycle of 3, I need to invite all 3 to have all 3 come.

Is there a way to have only 2 come with fewer invitations? Maybe not.

Wait, in the problem statement, there's an example with n=4 and p=[2,3,4,1], and the answer is 3.

In this case, it's a cycle of 4: 1->2->3->4->1.

According to the example, inviting 1,2,3 makes friends 1 and 2 come.

Wait, let's see:

- Friend 1 has friend 2 invited, and friend 2 has friend 3 invited, who has friend 4 invited.

- So, friend 2 comes because friend 3 is invited.

- Friend 1 comes because friend 2 is invited.

- Friend 3 comes because friend 4 is invited.

- Friend 4 didn't receive an invitation, so friend 3 doesn't come.

Wait, according to the problem, friend 3 comes only if both friend 3 and friend 4 received invitations.

But friend 4 didn't receive an invitation, so friend 3 doesn't come.

But in the example, it says friends 1 and 2 come.

Wait, maybe I'm misunderstanding.

Let me read the problem again.

"The i-th friend comes to the party if both the i-th friend and the p_i -th friend receive an invitation."

Wait, so for friend i to come, both friend i and friend p_i must receive invitations.

In the example:

p = [3,1,2,5,4]

So, p_1 = 3, p_2 = 1, p_3 = 2, p_4 = 5, p_5 = 4

Monocarp sends invitations to [1,2,4,5]

So, friend 1 and friend 3 receive invitations.

Wait, no. Wait, he sends invitations to friends 1,2,4,5.

So, friend 1 received an invitation, friend p_1 = 3 did not receive an invitation, so friend 1 doesn't come.

Friend 2 received an invitation, friend p_2 =1 also received an invitation, so friend 2 comes.

Friend 3 did not receive an invitation, so doesn't come.

Friend 4 received an invitation, friend p_4 =5 also received an invitation, so friend 4 comes.

Friend 5 received an invitation, friend p_5 =4 also received an invitation, so friend 5 comes.

Wait, but according to the explanation, only friends 2,4,5 come.

But the problem says that friend 1 won't come because his best friend didn't receive an invitation.

Wait, friend 1's best friend is 3, who didn't receive an invitation, so friend 1 doesn't come.

Friend 2's best friend is 1, who received an invitation, so friend 2 comes.

Friend 3 didn't receive an invitation, so doesn't come.

Friend 4's best friend is 5, who received an invitation, so friend 4 comes.

Friend 5's best friend is 4, who received an invitation, so friend 5 comes.

So, friends 2,4,5 come.

But the problem says that it's impossible to have at least 2 friends come with fewer than 3 invitations.

Wait, but in this case, they sent 4 invitations, and 3 friends came.

Maybe there's a better way.

Wait, perhaps in this case, sending invitations to friends 4 and 5 would make friends 4 and 5 come, since each has the other invited.

Wait, p_4 =5 and p_5 =4.

So, if invitations are sent to 4 and 5, both receive invitations, and each other is invited, so both come.

So, in this case, sending invitations to 4 and 5 would make 2 friends come.

But according to the example, they sent invitations to 1,2,4,5, and friends 2,4,5 come.

But according to this, sending invitations to only 4 and 5 would make 2 friends come.

So, perhaps in this case, the minimum number of invitations is 2.

But in the example, it says the answer is 3.

Wait, maybe I'm misunderstanding the example.

Wait, no, in the example, it says:

"Monocarp can send invitations to friends [1,2,4,5], then friends [2,4,5] will come to the party."

But as I thought, sending invitations only to 4 and 5 would make 2 friends come.

So perhaps the answer should be 2, but in the example, it's given as 3.

Wait, maybe I'm missing something.

Wait, perhaps in some cases, sending invitations to 2 friends isn't enough to make 2 friends come.

Wait, in the first test case, with p=[3,1,2,5,4], sending invitations to 4 and 5 makes both come, so 2 invitations.

In the second test case, with p=[2,3,4,1], the answer is 3.

Wait, in that case, p=[2,3,4,1], which is a cycle of 4.

If I send invitations to 1,2,3, then friends 1 and 2 come, as explained.

But if I send invitations to only 1 and 3, then:

- Friend 1 has friend 2 invited? No, friend 2 didn't receive an invitation, so friend 1 doesn't come.

- Friend 2 received an invitation, friend 3 is invited, so friend 2 comes.

- Friend 3 has friend 4 invited? Friend 4 didn't receive an invitation, so friend 3 doesn't come.

- Friend 4 didn't receive an invitation, so doesn't come.

So, only friend 2 comes, which is less than 2.

If I send invitations to 1,3,4:

- Friend 1 has friend 2 not invited, so doesn't come.

- Friend 3 has friend 4 invited, but friend 4 has friend 1 not invited (since friend 1 didn't receive an invitation), so friend 4 doesn't come.

- Friend 4 doesn't come, so friend 3 doesn't come.

- Friend 1 doesn't come.

- Friend 2 didn't receive an invitation, so doesn't come.

So, no one comes.

If I send invitations to 2,3,4:

- Friend 2 has friend 3 invited, so friend 2 comes.

- Friend 3 has friend 4 invited, so friend 3 comes.

- Friend 4 has friend 1 not invited, so friend 4 doesn't come.

- Friend 1 didn't receive an invitation, so doesn't come.

So, friends 2 and 3 come.

Wait, but friend 3 has friend 4 invited, and friend 4 is coming because friend 1 is invited.

Wait, no, friend 4 has friend 1 not invited, so friend 4 doesn't come.

Wait, friend 3 has friend 4 invited, but friend 4 isn't coming because friend 1 isn't invited, so friend 3 doesn't come.

Wait, I'm getting confused.

Let me re-express the condition.

Friend i comes if both friend i and friend p_i received invitations.

So, for friend 3 to come, both friend 3 and friend p_3=2 must have received invitations.

Wait, in this case, friend 3 received an invitation, and friend 2 received an invitation, so friend 3 comes.

Similarly, friend 2 received an invitation, and friend p_2=3 received an invitation, so friend 2 comes.

Friend 4 received an invitation, but friend p_4=1 didn't receive an invitation, so friend 4 doesn't come.

Friend 1 didn't receive an invitation, so doesn't come.

So, friends 2 and 3 come.

So, with 3 invitations (to 2,3,4), we have 2 friends coming.

Is there a way to have at least 2 friends come with fewer invitations?

Let's try sending invitations to 2 and 3.

- Friend 2 has friend 3 invited, so friend 2 comes.

- Friend 3 has friend 2 invited, so friend 3 comes.

- Friend 4 didn't receive an invitation, so doesn't come.

- Friend 1 didn't receive an invitation, so doesn't come.

So, friends 2 and 3 come.

Wait, that works with only 2 invitations.

But in the example, it says the answer is 3.

Wait, maybe I'm missing something.

Looking back at the example, it says:

"Monocarp can send invitations to friends [1,2,3,4], then friends [2,4,5] will come to the party."

Wait, no, in the first test case, n=5, p=[3,1,2,5,4], and sending invitations to [1,2,4,5], friends [2,4,5] come.

Then in the second test case, n=4, p=[2,3,4,1], and it says the answer is 3.

But according to my previous reasoning, sending invitations to 2 and 3 makes both come, which is at least 2, so the answer should be 2.

Maybe there's a misunderstanding.

Wait, perhaps in some cycles, sending invitations to 2 friends isn't enough.

Wait, perhaps when there are multiple cycles.

Wait, in the second test case, p=[2,3,4,1], which is a single cycle of length 4: 1->2->3->4->1.

In this case, sending invitations to any 2 consecutive friends makes both come.

Wait, as I did earlier, sending to 2 and 3 makes both come.

Similarly, sending to 1 and 2 makes both come.

So, in this case, the answer should be 2.

But in the example, it's given as 3.

Wait, perhaps I need to consider that some friends might not come even if their invitations are sent.

Wait, no, in the case of a cycle of 4, sending invitations to 2 and 3 makes both come.

So, maybe the answer is 2.

Wait, perhaps in some configurations, it's not possible to have 2 friends come with only 2 invitations.

Looking at the third test case, n=2, p=[2,1].

Sending invitations to both makes both come, and sending to only one doesn't make any come.

So, in this case, sending 2 invitations is necessary.

So, perhaps in general, for cycles of even length, you can have 2 friends come with 2 invitations, and for cycles of odd length, you need to invite more.

Wait, in the second test case, with n=4, p=[2,3,4,1], which is a cycle of 4, sending 2 invitations can make 2 friends come.

But in the example, it says the answer is 3.

Wait, maybe I'm missing some constraints.

Wait, perhaps there are multiple cycles.

Wait, in the first test case, n=5, p=[3,1,2,5,4], which is two cycles: 1->3->2->1 (cycle of 3: 1,2,3), and 4->5->4 (cycle of 2:4,5).

In this case, sending invitations to 4 and 5 makes both come, which is 2 invitations.

Similarly, in the second test case, n=4, p=[2,3,4,1], which is a single cycle of 4:1->2->3->4->1.

Sending invitations to 2 and 3 makes both come, which is 2 invitations.

But in the example, it's given as 3.

Wait, perhaps I need to ensure that at least 2 friends come, and in some cases, sending 2 invitations isn't sufficient.

Wait, in the second test case, sending invitations to 2 and 3 makes both come, so the answer should be 2.

But in the example, it's given as 3.

Wait, maybe there's a misunderstanding in the problem.

Wait, perhaps the problem is that some friends might not come even if their invitations are sent, depending on their best friends.

Wait, no, according to the condition, friend i comes only if both friend i and friend p_i received invitations.

So, in the second test case, sending invitations to 2 and 3 makes both come, since:

- friend 2 has friend 3 invited.

- friend 3 has friend 4 invited, but friend 4 didn't receive an invitation, so friend 3 doesn't come.

Wait, hold on.

If I send invitations to 2 and 3:

- friend 2 has friend 3 invited, so friend 2 comes.

- friend 3 has friend 4 invited, but friend 4 didn't receive an invitation, so friend 3 doesn't come.

- friend 4 didn't receive an invitation, so doesn't come.

- friend 1 didn't receive an invitation, so doesn't come.

So, only friend 2 comes.

Wait, so in this case, sending invitations to 2 and 3 doesn't make 2 friends come.

Only friend 2 comes.

So, that doesn't satisfy the condition of having at least 2 friends come.

Wait, perhaps I made a mistake here.

Let me check again.

If I send invitations to 2 and 3:

- friend 2 has friend p_2=3 invited, and friend 3 has friend p_3=4 invited, but friend 4 didn't receive an invitation, so friend 3 doesn't come.

- Since friend 3 isn't coming, friend 2 doesn't come because friend 3 didn't come.

Wait, no, friend 2 comes if friend 3 is invited, which is true, so friend 2 comes.

But friend 3 doesn't come because friend 4 didn't receive an invitation.

So, only friend 2 comes.

So, to have at least 2 friends come, I need to send more invitations.

For example, sending invitations to 1,2,3:

- friend 1 has friend p_1=2 invited, and friend 2 is coming because friend 3 is invited.

- friend 2 has friend p_2=3 invited, and friend 3 is coming because friend 4 is invited.

- friend 3 has friend p_3=4 invited, and friend 4 didn't receive an invitation, so friend 3 doesn't come.

- friend 4 didn't receive an invitation, so doesn't come.

Wait, in this case, friend 3 doesn't come, and friend 2 comes, and friend 1 comes.

So, friends 1 and 2 come.

So, with 3 invitations, we have 2 friends come.

If I try sending invitations to 1,2,4:

- friend 1 has friend p_1=2 invited, so friend 1 comes.

- friend 2 has friend p_2=3 invited, but friend 3 didn't receive an invitation, so friend 2 doesn't come.

- friend 4 has friend p_4=1 invited, so friend 4 comes.

- friend 3 didn't receive an invitation, so doesn't come.

So, friends 1 and 4 come.

So, with 3 invitations (1,2,4), friends 1 and 4 come.

Similarly, sending invitations to 2,3,4 makes friends 2 and 4 come.

So, in all these cases, with 3 invitations, I can have 2 friends come.

But is there a way to have 2 friends come with only 2 invitations?

From earlier, sending invitations to 1 and 2:

- friend 1 has friend p_1=2 invited, so friend 1 comes.

- friend 2 has friend p_2=3 invited, but friend 3 didn't receive an invitation, so friend 2 doesn't come.

- friend 3 didn't receive an invitation, so doesn't come.

- friend 4 didn't receive an invitation, so doesn't come.

So, only friend 1 comes.

Not enough.

Sending invitations to 1 and 4:

- friend 1 has friend p_1=2 invited, but friend 2 didn't receive an invitation, so friend 1 doesn't come.

- friend 4 has friend p_4=1 invited, so friend 4 comes.

- friend 2 didn't receive an invitation, so doesn't come.

- friend 3 didn't receive an invitation, so doesn't come.

So, only friend 4 comes.

Not enough.

Sending invitations to 2 and 4:

- friend 2 has friend p_2=3 invited, but friend 3 didn't receive an invitation, so friend 2 doesn't come.

- friend 4 has friend p_4=1 invited, but friend 1 didn't receive an invitation, so friend 4 doesn't come.

- friend 1 didn't receive an invitation, so doesn't come.

- friend 3 didn't receive an invitation, so doesn't come.

No one comes.

Not useful.

Sending invitations to 3 and 4:

- friend 3 has friend p_3=4 invited, and friend 4 has friend p_4=1 invited, but friend 1 didn't receive an invitation, so friend 4 doesn't come.

- friend 3 comes because friend 4 is invited.

- friend 4 doesn't come because friend 1 didn't receive an invitation.

So, only friend 3 comes.

Not enough.

So, with 2 invitations, it's not possible to have at least 2 friends come.

Hence, the minimum number of invitations needed is 3.

So, in this case, the answer is 3.

I must have made a mistake earlier.

So, in general, for cycles of length 3 or more, sending invitations to all friends in the cycle is necessary to have friends come.

Wait, no, in the second test case, which is a cycle of 4, sending invitations to any 3 friends makes at least 2 friends come.

Wait, but in a cycle of 3, sending invitations to all 3 makes all 3 come, but sending invitations to any 2 doesn't make any come.

Wait, in a cycle of 3, sending invitations to any 2 friends doesn't make any come, because each of those 2 friends has their best friend not invited.

Wait, in a cycle of 3: 1->2->3->1.

If I send invitations to 1 and 2:

- friend 1 has friend p_1=2 invited, so friend 1 comes.

- friend 2 has friend p_2=3 invited, but friend 3 didn't receive an invitation, so friend 2 doesn't come.

- friend 3 didn't receive an invitation, so doesn't come.

So, only friend 1 comes.

Not enough.

If I send invitations to 1 and 3:

- friend 1 has friend p_1=2 invited, but friend 2 didn't receive an invitation, so friend 1 doesn't come.

- friend 3 has friend p_3=1 invited, so friend 3 comes.

- friend 2 didn't receive an invitation, so doesn't come.

So, only friend 3 comes.

Not enough.

If I send invitations to 2 and 3:

- friend 2 has friend p_2=3 invited, so friend 2 comes.

- friend 3 has friend p_3=1 invited, but friend 1 didn't receive an invitation, so friend 3 doesn't come.

- friend 1 didn't receive an invitation, so doesn't come.

So, only friend 2 comes.

Not enough.

So, in a cycle of 3, sending invitations to any 2 doesn't make at least 2 friends come.

Only sending invitations to all 3 makes all 3 come.

Hence, for cycles of 3, the minimum number of invitations is 3.

For cycles of 4, as in the second test case, the minimum number of invitations is 3.

Wait, but in the first test case, which has a cycle of 3 and a cycle of 2, sending invitations to the cycle of 2 (4 and 5) makes 2 friends come, so the minimum is 2.

In the second test case, which is a single cycle of 4, the minimum is 3.

In the third test case, which is a cycle of 2, the minimum is 2.

So, perhaps the minimum number of invitations is:

- For cycles of 2: 2 invitations to make both come.

- For cycles of 3: 3 invitations to make all come.

- For cycles of 4: 3 invitations to make at least 2 come.

Is there a general formula?

Wait, perhaps in cycles of even length, the minimum number of invitations to make at least 2 come is 3, and in cycles of odd length, it's the length of the cycle.

Wait, no, in cycles of 2, it's 2, which is the length.

In cycles of 3, it's 3.

In cycles of 4, it's 3.

So, maybe it's the ceiling of (cycle length + 1)/2.

Wait, for cycle of 2: ceil(3/2)=2.

Cycle of 3: ceil(4/2)=2, but in reality, it's 3.

Wait, no.

Alternatively, maybe it's the minimum number of invitations is the cycle length if the cycle length is odd, and cycle length / 2 + 1 if even.

Wait, in cycle of 4, it's 3, which is cycle length -1.

Wait, perhaps it's cycle length for odd cycles, and cycle length -1 for even cycles.

Wait, in cycle of 4, it's 3, which is cycle length -1.

In cycle of 3, it's 3, which is cycle length.

In cycle of 2, it's 2, which is cycle length.

So, for even cycles, it's cycle length -1, for odd cycles, it's cycle length.

Wait, but in the first test case, which has a cycle of 3 and a cycle of 2, the minimum is 2, which is less than the sum of individual minima.

Wait, perhaps when there are multiple cycles, the minimum invitations is the minimum over the cycles of the minimum invitations needed for each cycle.

Wait, in the first test case, cycle of 3 requires 3 invitations, cycle of 2 requires 2 invitations, but by inviting 2 from the cycle of 2, you can have 2 friends come, which satisfies the condition.

Hence, the minimum is 2.

In the second test case, a single cycle of 4 requires 3 invitations to have at least 2 come.

In the third test case, a single cycle of 2 requires 2 invitations.

So, perhaps the general approach is:

- Identify all cycles in the friendship graph.

- For each cycle, determine the minimum number of invitations needed to have at least 2 friends come from that cycle.

- The overall minimum number of invitations is the minimum over all possible combinations of invitations from different cycles, ensuring that at least 2 friends come in total.

This seems complicated.

An alternative approach is:

- If there is a cycle of 2, then sending invitations to both makes 2 friends come, which is the minimum.

- For larger cycles, the minimum number of invitations is the cycle length for odd cycles, and cycle length -1 for even cycles.

- The overall minimum is the minimum of these values across all cycles, but considering that invitations across different cycles are independent.

Wait, but in the first test case, there is a cycle of 3 and a cycle of 2, and the minimum is 2, which is the minimum of 2 (from cycle of 2) and 3 (from cycle of 3).

Hence, the overall minimum is the minimum over all cycles of the minimum invitations needed for that cycle.

So, in the first test case, min(2,3) = 2.

In the second test case, single cycle of 4 requires 3 invitations.

In the third test case, single cycle of 2 requires 2 invitations.

Hence, the answer is the minimum over all cycles of the minimum invitations needed for that cycle.

So, to solve the problem, I need to:

1. Identify all cycles in the friendship graph.

2. For each cycle, determine the minimum number of invitations needed to have at least 2 friends come from that cycle.

3. The overall minimum number of invitations is the minimum of these values.

But, in practice, identifying all cycles in a graph is complicated, especially for large n.

Wait, but n is up to 50, and t is up to 5000, so I need an efficient way to compute this.

Looking back at the problem, p_i are distinct and p_i != i, and all p_i are distinct, meaning that the graph is a collection of disjoint cycles and cycles.

Wait, since p_i are distinct and p_i != i, the graph is a collection of disjoint cycles, each of length at least 2.

Because p_i are distinct, there are no multiple edges, and since p_i != i, there are no self-loops.

Hence, the graph is a disjoint union of cycles.

So, I can perform a graph traversal to find all the cycles.

But for n=50 and t=5000, I need an efficient way to do this.

Alternatively, since p_i are distinct, I can think of this as a permutation of the friends, and find the cycle structure of this permutation.

Yes, p defines a permutation of the friends, and I can find the cycle decomposition of this permutation.

Then, for each cycle, determine the minimum number of invitations needed to have at least 2 friends come from that cycle.

Then, the overall minimum is the minimum over all cycles of the minimum invitations needed for that cycle.

Wait, but in the first test case, there are two cycles: one of length 3 and one of length 2, and the minimum is 2, which comes from the cycle of 2.

So, in general, the overall minimum is the minimum over all cycles of the minimum invitations needed for that cycle.

Hence, I need to find, for each cycle, the minimum number of invitations to make at least 2 friends come from that cycle.

Wait, but in the first test case, making 2 friends come from the cycle of 2 requires 2 invitations, and making 3 friends come from the cycle of 3 requires 3 invitations.

Hence, the overall minimum is 2.

Similarly, in the second test case, with a single cycle of 4, the minimum is 3.

In the third test case, with a single cycle of 2, the minimum is 2.

So, I need to find, for each cycle of length k, the minimum number of invitations to make at least 2 friends come from that cycle.

From earlier observations:

- For a cycle of 2, minimum invitations are 2.

- For a cycle of 3, minimum invitations are 3.

- For a cycle of 4, minimum invitations are 3.

Is there a general formula for a cycle of length k?

From the earlier analysis:

- For k=2: min invitations=2

- For k=3: min invitations=3

- For k=4: min invitations=3

Wait, for k=4, it's 3, which is less than k.

Is there a pattern?

Wait, perhaps for even k, min invitations = k -1, and for odd k, min invitations = k.

Wait, for k=2: 2 == 2-1 +1 =2-1=1, but earlier I thought it's 2.

Wait, no.

Wait, perhaps for even k, min invitations = k/2 +1.

Wait, for k=4: 4/2 +1=3, which matches.

For k=2: 2/2 +1=2, which matches.

For k=3: ceil(3/2)+1=1.5+1=2.5, which should be 3, matches.

But for k=3, ceil(3/2)=2, and 2 +1=3, which matches.

So, perhaps for general k, min invitations = ceil(k/2) +1.

Wait, for k=2: ceil(2/2)=1, +1=2.

For k=3: ceil(3/2)=2, +1=3.

For k=4: ceil(4/2)=2, +1=3.

Which matches the earlier observations.

Hence, for a cycle of length k, the minimum number of invitations to make at least 2 friends come is ceil(k/2) +1.

Wait, but in the first test case, for the cycle of 3, ceil(3/2)+1=2+1=3, which matches.

For the cycle of 2, ceil(2/2)+1=1+1=2, which matches.

In the second test case, cycle of 4: ceil(4/2)+1=2+1=3, which matches.

In the third test case, cycle of 2: ceil(2/2)+1=1+1=2, which matches.

So, this seems to be a general formula.

Hence, for each cycle, calculate ceil(k/2)+1, and then take the minimum over all cycles.

Wait, but in the first test case, there are two cycles: one of length 3 and one of length 2.

According to this, the minimum invitations are min(3,2)=2, which matches the example.

In the second test case, single cycle of 4: min invitations=3.

In the third test case, single cycle of 2: min invitations=2.

Perfect.

Hence, the approach is:

- Find all cycles in the permutation p.

- For each cycle of length k, calculate ceil(k/2)+1.

- The overall minimum number of invitations is the minimum of these values over all cycles.

Hence, I need to find the cycle decomposition of p, then for each cycle, compute ceil(k/2)+1, and take the minimum.

But, in the first test case, p=[3,1,2,5,4], which is two cycles: 1->3->2->1 (cycle of 3) and 4->5->4 (cycle of 2).

Hence, min(ceil(3/2)+1, ceil(2/2)+1)=min(3,2)=2.

In the second test case, p=[2,3,4,1], which is one cycle:1->2->3->4->1 (cycle of 4).

Hence, ceil(4/2)+1=3.

In the third test case, p=[2,1], which is one cycle of 2:1->2->1.

Hence, ceil(2/2)+1=2.

So, this seems correct.

Hence, the plan is:

- For each test case:

- Read n and p.

- Find all cycles in p.

- For each cycle, compute ceil(k/2)+1.

- Take the minimum of these values.

But, in the first test case, p=[3,1,2,5,4], which is two cycles: 1->3->2->1 and 4->5->4.

Hence, min(ceil(3/2)+1, ceil(2/2)+1)=min(3,2)=2.

But, in the problem statement, it's mentioned that for the first test case, sending invitations to 4 and 5 makes 2 friends come.

Hence, the minimum is indeed 2.

Similarly, for the second test case, p=[2,3,4,1], which is one cycle of 4:1->2->3->4->1.

Hence, ceil(4/2)+1=3.

And, in the example, sending invitations to 1,2,3 makes 2 friends come.

Hence, the minimum is 3.

Similarly, for the third test case, p=[2,1], which is one cycle of 2:1->2->1.

Hence, ceil(2/2)+1=2.

Sending invitations to 1 and 2 makes both come.

Hence, the minimum is 2.

So, this seems consistent.

Hence, the formula is:

For a cycle of length k, the minimum number of invitations to make at least 2 friends come is ceil(k/2)+1.

Hence, the overall minimum is the minimum over all cycles of ceil(k/2)+1.

But, in the first test case, there are two cycles: k=3 and k=2.

ceil(3/2)+1=3, ceil(2/2)+1=2, min=2.

Which is correct.

In the second test case, one cycle of k=4, ceil(4/2)+1=3.

In the third test case, one cycle of k=2, ceil(2/2)+1=2.

Hence, this seems to be the correct approach.

Hence, I need to implement this.

But, in the program provided, it seems to be doing something else.

Looking at the program:

def func():

n = int(input())

for i in range(n):

x = int(input())

l = list(map(int, input().strip().split()))

for i in range(0, x):

if l[l[i] - 1] == i + 1:

flag = True

print(2)

break

else:

print(3)

This seems to be reading t, then for each test case, reading n and p, then iterating through p and checking if l[l[i]-1]==i+1, i.e., if friend i's best friend's best friend is i.

If that's true for any i, it prints 2, else prints 3.

But, according to our earlier analysis, in some cases, it should print 2, in some cases 3, and in some cases, it could be higher, but in this program, it only prints 2 or 3.

But, in the problem statement, n can be up to 50, and p can have cycles of up to length 50.

But, according to our formula, for k=50, ceil(50/2)+1=26.

But, in this program, it only prints 2 or 3.

Hence, it's incorrect.

Wait, but in the problem statement, t is the number of test cases, and each test case has its own n and p.

But, in the code, it reads t, then for each test case, reads n and p, then processes it.

But, according to our analysis, for general k, it should be ceil(k/2)+1.

But in the code, it only prints 2 or 3, based on whether any friend is a mutual best friend.

Wait, perhaps the code is incorrect.

Hence, the answer is False.

But, perhaps I need to think more carefully.

Wait, perhaps in some cases, it's correct.

Wait, in the second test case, p=[2,3,4,1], which is a cycle of 4.

In this case, for each i, l[l[i]-1] == i+1 is true, because:

l[0]=2, l[1]=3, l[2]=4, l[3]=1

So, l[l[0]-1]=l[1]=3 != 1

l[l[1]-1]=l[2]=4 !=2

l[l[2]-1]=l[3]=1 !=3

l[l[3]-1]=l[0]=2 !=4

Hence, in this case, it doesn't find any i where l[l[i]-1]==i+1, so it prints 3, which is correct.

In the first test case, p=[3,1,2,5,4]

l[0]=3, l[2]=2 !=1

l[1]=1, l[0]=3 !=2

l[2]=2, l[1]=1 !=3

l[3]=5, l[4]=4 !=4

l[4]=4, l[3]=5 !=5

Hence, it doesn't find any i where l[l[i]-1]==i+1, so it prints 3, but according to our analysis, the answer should be 2.

Hence, the code is incorrect in this case.

In the third test case, p=[2,1]

l[0]=2, l[1]=1 ==1, so it finds i=1 where l[l[1]-1]=l[0]=2 !=1

Wait, l[1]=1, l[0]=2 !=1

Hence, it doesn't find any i where l[l[i]-1]==i+1, so it prints 3, but according to our analysis, the answer should be 2.

Hence, the code is incorrect.

Hence, the answer is False.

But, perhaps there's a different way to interpret the code.

Wait, perhaps the code is trying to check if there are any mutual best friends, i.e., if friend a's best friend is b, and b's best friend is a, then they are mutual.

In that case, for a cycle of 2, it would print 2, else 3.

But, in the first test case, there is a cycle of 2:4 and 5.

But, in the code, it only checks if l[l[i]-1]==i+1 for any i.

In the first test case:

p=[3,1,2,5,4]

So, l[2]=2 !=1, l[0]=3 !=2, l[1]=1 !=3, l[4]=4 !=5, l[3]=5 !=4.

Hence, it doesn't find any mutual best friends, so it prints 3, but the correct answer is 2.

Hence, the code is incorrect.

Hence, the answer is False.

**Final Solution**

To solve this problem, we need to determine the minimum number of invitations Monocarp has to send to ensure that at least two friends come to the party, given the constraints of their friendships.

### Approach

1. **Understanding the Problem**:
   - Each friend has a unique best friend, and this relationship forms cycles.
   - A friend comes to the party only if both they and their best friend receive an invitation.
   - We need to find the minimum number of invitations required to get at least two friends to attend.

2. **Cycle Detection**:
   - The friendships form disjoint cycles. We need to identify these cycles to determine the minimal invitations required.
   - For each cycle of length `k`, the minimum invitations needed to ensure at least two friends come is `ceil(k / 2) + 1`.

3. **Calculate Minimum Invitations**:
   - For each cycle, compute the number of invitations using the formula `ceil(k / 2) + 1`.
   - The overall minimum number of invitations is the smallest value among all cycles.

### Solution Code

```python
def find_cycle_length(p, start, visited):
    current = start
    cycle_length = 0
    while not visited[current - 1]:
        visited[current - 1] = True
        current = p[current - 1]
        cycle_length += 1
        if current == start:
            break
    return cycle_length

def min_invitations(t):
    results = []
    for _ in range(t):
        n = int(input())
        p = list(map(int, input().strip().split()))
        visited = [False] * n
        min_invites = float('inf')
        for i in range(1, n + 1):
            if not visited[i - 1]:
                cycle_length = find_cycle_length(p, i, visited)
                min_for_cycle = (cycle_length // 2) + 1 if cycle_length % 2 == 0 else cycle_length
                if min_for_cycle < min_invites:
                    min_invites = min_for_cycle
        results.append(min_invites)
    for res in results:
        print(res)

# Example usage
t = int(input())
min_invitations(t)
```

### Explanation

1. **Finding Cycle Lengths**:
   - We use a helper function `find_cycle_length` to determine the length of each cycle in the friendship graph.
   - We track visited nodes to avoid recounting cycles.

2. **Calculating Minimum Invitations per Cycle**:
   - For even-length cycles, the formula is `(k // 2) + 1`.
   - For odd-length cycles, it's simply `k`.

3. **Determining Overall Minimum Invitations**:
   - We track the minimum invitations required across all cycles for each test case and print the result for each.

This approach ensures that we efficiently compute the required number of invitations by leveraging cycle properties in the friendship graph.