Alright, I have this problem to solve. Let's understand what's being asked here. Mocha has an array, and she can perform a specific operation on it any number of times. The operation is to split the array into two parts—a prefix and a suffix—and swap them. After performing this operation as many times as she wants, we need to determine if the array can become sorted in non-decreasing order.

First, I need to make sure I understand the operation clearly. When we split the array into a prefix and a suffix and swap them, it's like rotating the array. For example, if we have an array [3,1,4,1,5], and we choose x=[3,1] and y=[4,1,5], swapping them gives us [4,1,5,3,1]. Another way to look at it is that we're rotating the array by the length of the prefix.

Wait, actually, it's not exactly a rotation. In a standard rotation, elements are shifted by a certain number of positions, but in this operation, we're splitting into two parts and swapping them. So, for example, if we have array a = [a1, a2, a3, a4, a5], and we choose x=[a1, a2] and y=[a3, a4, a5], then y+x = [a3, a4, a5, a1, a2]. This is similar to rotating the array to the left by 2 positions.

But actually, in rotation, if you rotate left by 2, it's [a3, a4, a5, a1, a2], which is the same as splitting after the first two elements and swapping the parts. So yes, this operation is equivalent to rotating the array by the length of the prefix.

But the problem allows us to choose any prefix and suffix such that a = x + y, and then swap to make y + x. So, we can perform any number of such operations.

Now, the key is to see if, by performing such operations (rotations), we can make the array sorted in non-decreasing order.

First, I need to think about what rotations can achieve. Rotations are a type of permutation of the array elements. By performing multiple rotations, we can rearrange the elements in certain ways.

But rotations have some limitations. Not all permutations can be achieved by rotations. For example, in an array of size n, rotating the array by k positions is equivalent to applying a cyclic permutation of length n.

So, the question is: can we sort the array using rotations?

Well, in general, sorting an array using rotations is possible if the array is already rotated from its sorted position. For example, if the sorted array is [1,2,3,4,5], and we have [3,4,5,1,2], which is rotated left by 2 positions, we can rotate it right by 2 positions to get back to sorted order.

But if the array is not a rotation of the sorted array, then it's impossible to sort it using rotations alone.

So, the problem reduces to checking if the given array is a rotation of the sorted array.

Wait, but let's look at the sample input and output to verify this.

In the first test case:

6

1 1 4 5 1 4

Output: No

In the second test case:

5

7 9 2 2 3

Output: Yes

In the third test case:

3

1 2 3

Output: Yes

Let's consider the first test case: [1,1,4,5,1,4]

The sorted array would be [1,1,4,4,5,1], which is [1,1,4,4,5,1]

Wait, no. Sorted array should be [1,1,1,4,4,5]

Wait, sorted array is [1,1,1,4,4,5]

Now, is [1,1,4,5,1,4] a rotation of [1,1,1,4,4,5]? Let's see.

If we look at all possible rotations of [1,1,1,4,4,5]:

- [1,1,1,4,4,5]

- [1,1,4,4,5,1]

- [1,4,4,5,1,1]

- [4,4,5,1,1,1]

- [4,5,1,1,1,4]

- [5,1,1,1,4,4]

None of these match [1,1,4,5,1,4], so it's not a rotation of the sorted array, hence "No".

In the second test case:

5

7 9 2 2 3

Sorted array: [2,2,3,7,9]

Possible rotations:

- [2,2,3,7,9]

- [2,3,7,9,2]

- [3,7,9,2,2]

- [7,9,2,2,3]

- [9,2,2,3,7]

Looking at the original array [7,9,2,2,3], it matches one of the rotations [7,9,2,2,3], so "Yes".

In the third test case:

3

1 2 3

Sorted array: [1,2,3]

Possible rotations:

- [1,2,3]

- [2,3,1]

- [3,1,2]

The original array is [1,2,3], which is already sorted, so "Yes".

So, based on these examples, it seems that the problem is to check if the given array is a rotation of its sorted version.

But wait, in the second test case, after performing two operations, they showed intermediate steps.

Wait, in the second test case, they performed two operations:

1. Split x=[7] and y=[9,2,2,3], swap to get [9,2,2,3,7]

2. Then split x=[9] and y=[2,2,3,7], swap to get [2,2,3,7,9]

So, they performed two operations to sort the array.

This suggests that it's not just checking if it's a single rotation, but multiple rotations.

But in the first test case, even after multiple rotations, it's impossible to sort the array.

So, perhaps the problem is to check if the array can be sorted by some sequence of rotations.

But, in group theory, rotations generate a cyclic group, and applying multiple rotations is equivalent to a single rotation by the net number of positions rotated.

So, in other words, multiple rotations can be reduced to a single rotation.

Therefore, if the array isn't a rotation of the sorted array, no amount of rotations will sort it.

Wait, but in the second test case, they performed two rotations to sort the array, and it worked.

But according to the earlier logic, multiple rotations should be equivalent to a single rotation.

Let me think about that.

Suppose we have array [a,b,c,d]

A rotation left by 1: [b,c,d,a]

Another rotation left by 1: [c,d,a,b]

Which is equivalent to a single rotation left by 2.

Similarly, rotations are commutative in this sense.

So, performing multiple rotations is equivalent to a single rotation by the sum of the rotation amounts modulo n.

Therefore, regardless of the sequence of rotations, it's equivalent to a single rotation.

But in the second test case, they performed two rotations to sort the array, which seems to contradict this.

Wait, perhaps I'm missing something.

Let me look at the second test case in detail.

Original array: [7,9,2,2,3]

First operation: split x=[7], y=[9,2,2,3], swap to get [9,2,2,3,7]

Second operation: split x=[9], y=[2,2,3,7], swap to get [2,2,3,7,9]

So, this seems like they're performing rotations by different amounts each time.

Wait, splitting by x=[7] is rotating left by 1, and splitting by x=[9] is rotating left by 1 again, resulting in a total rotation left by 2, which directly from the original array would give [2,2,3,7,9].

But in this case, yes, it's equivalent to a single rotation left by 2.

But perhaps in other cases, it's not so straightforward.

Wait, but in general, any sequence of rotations is equivalent to a single rotation.

Hence, it should be sufficient to check if the sorted array is a rotation of the original array.

But in the first test case, it's not a rotation, hence "No".

In the second test case, it is a rotation, hence "Yes".

In the third test case, it's already sorted, which is a rotation (rotation by 0).

So, this seems to hold.

But let's consider another example to verify.

Suppose array [2,1,3]

Sorted array [1,2,3]

Is [1,2,3] a rotation of [2,1,3]? Yes, rotation left by 1.

Hence, "Yes".

Another example: [3,1,2]

Sorted array [1,2,3]

Is [1,2,3] a rotation of [3,1,2]? Yes, rotation left by 1.

Hence, "Yes".

Wait, but in both these cases, "Yes", but perhaps there are cases where even though it's not a direct rotation, multiple operations can achieve the sorted array.

Wait, but according to the earlier logic, multiple rotations are equivalent to a single rotation, so it shouldn't be possible to achieve more than what a single rotation can achieve.

Hence, it's sufficient to check if the sorted array is a rotation of the original array.

Therefore, in code, we can concatenate the sorted array to itself and check if the original array is a substring of this concatenated array.

Wait, actually, to check if one array is a rotation of another, a standard technique is to concatenate the sorted array to itself and see if the original array is a subarray of this concatenated array.

For example, sorted array [1,2,3], concatenated to [1,2,3,1,2,3].

Then, check if the original array is a subarray of this.

For [2,1,3], we look in [1,2,3,1,2,3], and indeed [2,1,3] is a subarray.

Similarly, for [3,1,2], it's also a subarray of [1,2,3,1,2,3].

For the first test case, sorted [1,1,1,4,4,5], concatenated to [1,1,1,4,4,5,1,1,1,4,4,5].

Original array [1,1,4,5,1,4] is not a subarray of this, hence "No".

Second test case, sorted [2,2,3,7,9], concatenated to [2,2,3,7,9,2,2,3,7,9].

Original array [7,9,2,2,3] is a subarray, hence "Yes".

Third test case, sorted [1,2,3], concatenated to [1,2,3,1,2,3].

Original array [1,2,3] is a subarray, hence "Yes".

This seems to work.

Hence, in code, for each test case, we can sort the array, concatenate it to itself, and check if the original array is a subarray of this concatenated array.

Now, looking at the given program, let's see what it's doing.

There's func_2, which reads all input at once, splits it into tokens, and processes each test case by calling func_1.

Func_1 takes the array a, sorts it, concatenates the sorted array to itself, and then checks if the original array is a subarray of this concatenated array.

Wait, actually, in func_1, it's concatenating the original array to itself, not the sorted array.

Wait, no, looking again:

def func_1(a):

n = len(a)

sorted_a = sorted(a)

concatenated_a = a + a

for i in range(n):

if concatenated_a[i:i + len(sorted_a)] == sorted_a:

return 'Yes'

return 'No'

Wait, here, concatenated_a = a + a, which is the original array concatenated to itself.

Then, it checks if sorted_a is a subarray of concatenated_a.

Wait, but according to my earlier reasoning, it should be concatenating sorted_a to itself and then checking if a is a subarray of that.

So, this seems incorrect.

It should be:

concatenated_sorted = sorted_a + sorted_a

then check if a is a subarray of concatenated_sorted.

But in the code, it's concatenating a to itself and checking if sorted_a is a subarray of that.

Which is the opposite of what it should be.

Hence, this seems incorrect.

Let me verify with the first test case.

First test case:

n=6

a=[1,1,4,5,1,4]

sorted_a=[1,1,1,4,4,5]

concatenated_a = a + a = [1,1,4,5,1,4,1,1,4,5,1,4]

Now, it checks if sorted_a=[1,1,1,4,4,5] is a subarray of concatenated_a.

Looking at concatenated_a:

Indices:

0:1, 1:1, 2:4, 3:5, 4:1, 5:4, 6:1, 7:1, 8:4, 9:5, 10:1, 11:4

Looking for [1,1,1,4,4,5]

Looking at positions:

- 0 to 5: [1,1,4,5,1,4] ≠ [1,1,1,4,4,5]

- 1 to 6: [1,4,5,1,4,1] ≠ [1,1,1,4,4,5]

- 2 to 7: [4,5,1,4,1,1] ≠ [1,1,1,4,4,5]

- 3 to 8: [5,1,4,1,1,4] ≠ [1,1,1,4,4,5]

- 4 to 9: [1,4,1,1,4,5] ≠ [1,1,1,4,4,5]

- 5 to 10: [4,1,1,4,5,1] ≠ [1,1,1,4,4,5]

- 6 to 11: [1,1,4,5,1,4] ≠ [1,1,1,4,4,5]

Hence, it would return 'No', which matches the sample output.

Second test case:

n=5

a=[7,9,2,2,3]

sorted_a=[2,2,3,7,9]

concatenated_a = a + a = [7,9,2,2,3,7,9,2,2,3]

Looking for [2,2,3,7,9]

Looking at positions:

- 2 to 6: [2,2,3,7,9] == [2,2,3,7,9]

Hence, it would return 'Yes', which matches the sample output.

Third test case:

n=3

a=[1,2,3]

sorted_a=[1,2,3]

concatenated_a = [1,2,3,1,2,3]

Looking for [1,2,3]

Found at positions 0 to 2 and 3 to 5.

Hence, return 'Yes', matches the sample output.

So, in these cases, it seems to work.

But according to my earlier reasoning, it should be concatenating the sorted array to itself and checking if the original array is a subarray of that.

But here, it's concatenating the original array to itself and checking if the sorted array is a subarray of that.

But in the first test case, the sorted array is not a subarray of the concatenated original array, hence 'No'.

In the second test case, the sorted array is a subarray of the concatenated original array, hence 'Yes'.

In the third test case, it's 'Yes'.

So, it seems to work correctly for these cases.

But is this logic generally correct?

Wait, let's think about another example.

Suppose we have array [3,1,2]

Sorted array [1,2,3]

Concatenated original array [3,1,2,3,1,2]

Is [1,2,3] a subarray of [3,1,2,3,1,2]? Yes, positions 1 to 3.

Hence, 'Yes', which is correct.

Another example: [4,5,1,2,3]

Sorted array [1,2,3,4,5]

Concatenated original array [4,5,1,2,3,4,5,1,2,3]

Is [1,2,3,4,5] a subarray? Yes, positions 2 to 6.

Hence, 'Yes'.

Another example where it should be 'No':

Array [1,3,2]

Sorted array [1,2,3]

Concatenated original array [1,3,2,1,3,2]

Is [1,2,3] a subarray? Looking at positions:

- 0 to 2: [1,3,2] ≠ [1,2,3]

- 1 to 3: [3,2,1] ≠ [1,2,3]

- 2 to 4: [2,1,3] ≠ [1,2,3]

- 3 to 5: [1,3,2] ≠ [1,2,3]

- 4 to 6: [3,2,1] ≠ [1,2,3]

Hence, 'No', which is correct.

So, this seems to work.

But according to my earlier reasoning, it should be concatenating the sorted array to itself and checking if the original array is a subarray of that.

But apparently, concatenating the original array to itself and checking if the sorted array is a subarray of that works as well.

Is this always the case?

Wait, maybe not.

Consider array [2,1,3]

Sorted array [1,2,3]

Concatenated original array [2,1,3,2,1,3]

Is [1,2,3] a subarray? Yes, positions 1 to 3.

Hence, 'Yes', which is correct.

Another example: [3,2,1]

Sorted array [1,2,3]

Concatenated original array [3,2,1,3,2,1]

Is [1,2,3] a subarray? Looking at positions:

- 0 to 2: [3,2,1] ≠ [1,2,3]

- 1 to 3: [2,1,3] ≠ [1,2,3]

- 2 to 4: [1,3,2] ≠ [1,2,3]

- 3 to 5: [3,2,1] ≠ [1,2,3]

- 4 to 6: [2,1,3] ≠ [1,2,3]

Hence, 'No', which is correct.

Seems correct.

Wait, but according to my earlier reasoning, it should be checking if the sorted array is a rotation of the original array, which is equivalent to checking if the original array is a subarray of the sorted array concatenated to itself.

But in this code, it's checking if the sorted array is a subarray of the original array concatenated to itself.

Are these two checks equivalent?

In the examples above, both seem to work.

Is there a case where they differ?

Let me think of an array where the sorted array is a subarray of the original array concatenated to itself, but the original array is not a rotation of the sorted array.

Wait, if the sorted array is a subarray of the original array concatenated to itself, does that imply that the original array is a rotation of the sorted array?

In group theory, if you concatenate the original array to itself, you're essentially covering all possible rotations.

So, if the sorted array appears as a subarray in this concatenation, it means that the original array can be rotated to match the sorted array.

Hence, it should be equivalent to checking if the sorted array is a rotation of the original array.

Therefore, the logic in the code seems correct.

Hence, the program is correct.

**Final Answer**

\[\boxed{\text{Correct}}\]