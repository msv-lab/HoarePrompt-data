Alright, I have this problem to solve. Let's understand what's being asked here. So, Polycarp has lost a string `s` of length `n` consisting only of lowercase Latin letters, but he has a trace of this string. The trace is an array `a` where each `a_i` represents the number of indices `j` (with `j < i`) such that `s_i` is equal to `s_j`. Essentially, `a_i` tells us how many times the character `s_i` has appeared before position `i` in the string.

For example, given the string "abracadabra", its trace is `[0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 4]`. Let's see why:

- The first 'a' has no previous 'a's, so 0.

- The first 'b' has no previous 'b's, so 0.

- The first 'r' has no previous 'r's, so 0.

- The second 'a' has one previous 'a', so 1.

- And so on.

Given this trace, I need to reconstruct any string `s` that could have produced this trace. The problem guarantees that a valid string exists for the given trace.

Input:

- The first line contains an integer `t` (1 ≤ t ≤ 10^4), the number of test cases.

- For each test case:

- The first line contains an integer `n` (1 ≤ n ≤ 2*10^5), the length of the string.

- The second line contains `n` integers `a1, a2, ..., an` (0 ≤ ai < n), the trace of the string.

Output:

- For each test case, output a string `s` that corresponds to the given trace.

Constraints:

- The sum of `n` over all test cases does not exceed 2*10^5.

- It's guaranteed that a valid string exists for each test case.

Example:

Input:

5

11

0 0 0 1 0 2 0 3 1 1 4

10

0 0 0 0 0 1 0 1 1 0

1

0

8

0 1 2 3 4 5 6 7

8

0 0 0 0 0 0 0 0

Output:

abracadabra

codeforces

a

aaaaaaaa

dijkstra

Approach:

To solve this problem, we need to reconstruct the original string from its trace. The trace provides information about how many times each character has appeared before its current position in the string.

### Approach Explanation

1. **Initialization**:
   - We maintain a list `b` of size 26, initialized to 0, to keep track of the count of each lowercase letter from 'a' to 'z'.
   - We also have a string `a` containing all lowercase letters for reference.

2. **Processing Each Test Case**:
   - For each test case, read the integer `n` (length of the string) and the list of integers `s` (the trace).
   - Initialize an empty string `r` to build the result.

3. **Reconstructing the String**:
   - For each value `i` in the trace `s`:
     - Find the index `x` in `b` where the count matches `i`.
     - Append the corresponding character from `a` at index `x` to the result string `r`.
     - Increment the count of that character in `b` to reflect its new occurrence.

4. **Output the Result**:
   - Print the constructed string `r` for each test case.

### Solution Code

```python
def func():
    a = 'abcdefghijklmnopqrstuvwxyz'
    b = [0] * 26
    for t in range(int(input())):
        n = int(input())
        s = list(map(int, input().split()))
        r = ''
        for i in s:
            x = b.index(i)
            r += a[x]
            b[x] += 1
        print(r)

if __name__ == "__main__":
    func()
```

### Explanation of the Solution

1. **Initialization**:
   - `a = 'abcdefghijklmnopqrstuvwxyz'`: This string contains all lowercase letters.
   - `b = [0] * 26`: This list keeps track of the count of each letter in the alphabet.

2. **Processing Each Test Case**:
   - Read the number of test cases `t`.
   - For each test case:
     - Read the length of the string `n`.
     - Read the trace `s` as a list of integers.

3. **Reconstructing the String**:
   - For each value `i` in the trace `s`:
     - Use `b.index(i)` to find the first letter in `a` that has appeared `i` times so far.
     - Append this letter to the result string `r`.
     - Increment the count of this letter in `b`.

4. **Output**:
   - Print the constructed string `r` for each test case.

This approach ensures that the constructed string matches the given trace by carefully selecting characters based on their previous occurrences.