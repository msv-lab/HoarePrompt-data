Alright, I have this problem to solve. Let's see what it's asking for. Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. The usual price for each bun is a coins. But to attract customers, he's offering a promotion where he can choose some integer k (between 0 and the minimum of n and b) and sell the first k buns at a modified price. The price for the i-th bun (where i goes from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price a coins each.

My task is to help Bob determine the maximum profit he can obtain by selling all n buns.

First, I need to understand the promotion clearly. So, if Bob chooses k = 0, he sells all n buns at price a coins each. If he chooses k = 1, he sells the first bun at price b coins and the remaining (n - 1) buns at price a coins each. If he chooses k = 2, he sells the first bun at price b coins, the second at (b - 1) coins, and the remaining (n - 2) buns at price a coins each. This pattern continues up to k = min(n, b), where he sells k buns with decreasing prices starting from b down to (b - k + 1) coins, and the remaining (n - k) buns at price a coins each.

The goal is to maximize the total profit, which is the sum of the prices of all buns sold.

I need to find the optimal k that maximizes this total profit.

Let me think about different scenarios.

**Case 1: b <= a**

If the modified price for the first bun (which is b coins) is less than or equal to the usual price a coins, then there's no benefit in choosing any k greater than 0 because selling any bun at a modified price lower than or equal to a would not increase the profit. In fact, it would decrease it or keep it the same. So, the maximum profit would be achieved by choosing k = 0, selling all n buns at price a coins each, resulting in a total profit of n * a coins.

**Case 2: b > a**

If b is greater than a, then there might be some benefit in choosing k > 0 because selling some buns at prices higher than a would increase the total profit.

But I need to find the optimal k that maximizes the profit.

Let's consider that for k buns, the prices are b, (b - 1), (b - 2), ..., (b - k + 1) coins respectively.

The sum of these prices is the sum of an arithmetic series where the first term is b and the last term is (b - k + 1), with k terms.

The sum S of the first k terms is:

S = k * (b + (b - k + 1)) / 2 = k * (2b - k + 1) / 2

The remaining (n - k) buns are sold at price a coins each, so their total sum is a * (n - k).

Therefore, the total profit P for a given k is:

P = S + a * (n - k) = k * (2b - k + 1) / 2 + a * (n - k)

I need to maximize P with respect to k.

Given that k can be up to min(n, b), but since n and b can be up to 10^9, I need an efficient way to find the optimal k without iterating through all possible k values.

Let me consider the difference in profit when increasing k by 1.

Let’s compute P(k+1) - P(k):

P(k+1) = (k + 1) * (2b - (k + 1) + 1) / 2 + a * (n - (k + 1))

P(k) = k * (2b - k + 1) / 2 + a * (n - k)

So, P(k+1) - P(k) = [(k + 1)(2b - k) / 2 + a(n - k - 1)] - [k(2b - k + 1)/2 + a(n - k)]

Let’s simplify this:

= [(k + 1)(2b - k)/2 + a(n - k - 1)] - [k(2b - k + 1)/2 + a(n - k)]

= [(k + 1)(2b - k) - k(2b - k + 1)] / 2 + a(n - k - 1 - n + k)

= [ (2b(k + 1) - k(k + 1)) - (2bk - k(k) + k) ] / 2 + a(-1)

= [ 2b k + 2b - k^2 - k - 2b k + k^2 - k ] / 2 - a

= [2b - 2k] / 2 - a

= (b - k) - a

= b - k - a

So, P(k+1) - P(k) = b - k - a

This difference tells me whether increasing k by 1 increases or decreases the profit.

- If b - k - a > 0, then P(k+1) > P(k), meaning that increasing k increases the profit.

- If b - k - a = 0, then P(k+1) = P(k), meaning that increasing k doesn't change the profit.

- If b - k - a < 0, then P(k+1) < P(k), meaning that increasing k decreases the profit.

So, to maximize P, I should increase k as long as b - k - a > 0, which is equivalent to k < b - a.

When k = b - a, P(k+1) - P(k) = b - (b - a) - a = 0, so P(k+1) = P(k).

For k > b - a, P(k+1) - P(k) < 0, so P decreases.

Therefore, the optimal k is k = b - a, as long as b - a <= min(n, b).

But k cannot exceed min(n, b), so the actual optimal k is min(b - a, min(n, b)).

Wait, min(n, b) is already the upper limit for k, and b - a could be larger or smaller than that.

Wait, no. Since k can be at most min(n, b), and b - a could be larger or smaller than min(n, b), I need to consider:

- If b - a <= min(n, b), then the optimal k is k = b - a.

- If b - a > min(n, b), then the optimal k is k = min(n, b).

Wait, but in the case where b - a > min(n, b), k cannot exceed min(n, b), so k = min(n, b).

But let's verify this with an example.

Take the first test case:

n = 4, a = 4, b = 5

Compute k = b - a = 1

Since 1 <= min(4, 5) = 4, optimal k = 1

Total profit = sum of first k buns + a * (n - k) = (5) + 4 * 3 = 5 + 12 = 17

Which matches the sample output.

Second test case:

n = 5, a = 5, b = 9

k = b - a = 4

Since 4 <= min(5, 9) = 5, optimal k = 4

Total profit = sum of first 4 buns + a * (5 - 4) = (9 + 8 + 7 + 6) + 5 * 1 = 30 + 5 = 35

Which matches the sample output.

Third test case:

n = 10, a = 10, b = 5

Since b <= a, optimal k = 0

Total profit = 10 * 10 = 100

Which matches the sample output.

Fourth test case:

n = 5, a = 5, b = 11

k = b - a = 6

But min(n, b) = 5, so optimal k = 5

Total profit = sum of first 5 buns + a * (5 - 5) = (11 + 10 + 9 + 8 + 7) + 5 * 0 = 45 + 0 = 45

Which should match the sample output, but the sample output is not provided for this specific case, but based on the pattern, it seems correct.

Fifth test case:

n = 1000000000, a = 1000000000, b = 1000000000

Since b == a, optimal k = 0

Total profit = n * a = 1000000000 * 1000000000 = 1000000000000000000

Which matches the sample output.

Sixth test case:

n = 1000000000, a = 1000000000, b = 1

Since b < a, optimal k = 0

Total profit = n * a = 1000000000 * 1000000000 = 1000000000000000000

Which matches the sample output.

Seventh test case:

n = 1000, a = 1, b = 1000

k = b - a = 999

min(n, b) = min(1000, 1000) = 1000

But k = 999 <= 1000, so optimal k = 999

Total profit = sum of first 999 buns + a * (1000 - 999) = sum from 1000 down to 1000 - 999 + 1 = 1000 down to 2, plus 1 * 1 = sum from 2 to 1000 + 1

Wait, actually, the first bun is sold at b = 1000, second at 999, ..., 999th at 1000 - 999 + 1 = 2 coins, and the remaining 1 bun at a = 1 coin.

So, sum from 1000 down to 2 is an arithmetic series with first term 1000, last term 2, number of terms 999.

Sum S = 999 * (1000 + 2) / 2 = 999 * 1002 / 2 = 999 * 501 = 500500 - 999 = 500500 - 999 = 499501 + 999 = 500500

Wait, calculation mistake.

Wait, 999 * 501 = 999 * 500 + 999 * 1 = 499500 + 999 = 500499

Plus the remaining bun at 1 coin: 500499 + 1 = 500500

Which matches the sample output.

So, the formula seems correct.

Now, let's look at the provided program and see if it implements this logic correctly.

The program is:

def func():

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n / 2))

else:

print(int((b - a) / 2 * (b - a + 1) + a * n))

Let's analyze this.

First, it reads the number of test cases t.

Then, for each test case, it reads n, a, b.

Then, it has an if-elif-else structure:

if b <= a:

print(n * a)

This matches case 1 I considered earlier, where choosing k = 0 is optimal.

elif b - a >= n:

print(int((2 * b - n + 1) * n / 2))

else:

print(int((b - a) / 2 * (b - a + 1) + a * n))

I need to understand what's happening in these cases.

First, the elif condition is b - a >= n.

What does this mean?

From earlier, the optimal k is k = b - a, but k cannot exceed min(n, b).

If b - a >= n, then k = n, because k cannot exceed n.

Wait, but min(n, b) could be b if b < n, but in this case, b - a >= n, and since b >= a + n, and n can be up to 10^9, but b can also be up to 10^9.

Wait, perhaps I need to think differently.

Wait, if b - a >= n, then k = min(b - a, min(n, b)) = min(b - a, n), since b - a >= n, and min(n, b) could be n or b, but since b - a >= n, and b >= a + n, then min(b - a, n) = n.

Therefore, k = n.

So, in this case, k = n, meaning sell the first n buns at modified prices.

But wait, k can be up to min(n, b), so if b < n, then k = b.

Wait, but in the condition b - a >= n, and b <= n, then k = b.

Wait, perhaps I need to consider subcases.

Let me consider two subcases within b - a >= n:

1. b <= n

In this case, k = min(b - a, b) = b - a, but since b - a >= n, and b <= n, then b - a <= b, so k = b - a.

But wait, if b - a >= n and b <= n, then b - a <= b is always true.

Wait, but b - a >= n and b <= n implies b - a <= b, which is always true since a >= 0.

Wait, but a can be up to 10^9, and b can be up to 10^9, but n can be up to 10^9.

Wait, perhaps I need to consider the constraints more carefully.

Wait, if b - a >= n and b <= n, then b - a <= b is always true.

So, k = b - a.

But in this case, sum of first k buns is sum from b down to b - k + 1 = b down to a + 1.

Wait, b - k + 1 = b - (b - a) + 1 = a + 1.

So, sum from b down to a + 1, which is an arithmetic series with first term b, last term a + 1, number of terms k = b - a.

Sum S = (b + a + 1) * (b - a) / 2

Then, the remaining buns are n - k = n - (b - a)

But wait, in this case, n can be larger than b, but b - a >= n, which implies b >= a + n.

But if b >= a + n, and n <= b, then n - k = n - (b - a)

But b >= a + n, so b - a >= n, so n - k = n - (b - a) <= 0

Wait, but n - k cannot be negative, so perhaps I need to set k = min(b - a, n)

Wait, but in this case, b - a >= n, so k = n.

Wait, but n - k = n - n = 0, meaning all n buns are sold at modified prices.

Wait, but in the program, when b - a >= n, it prints int((2 * b - n + 1) * n / 2)

Let me compute what this expression is.

Sum of first k = n buns at modified prices:

Sum S = sum from i = 1 to n of (b - i + 1) = sum from i = 1 to n of (b + 1 - i) = n*(b + 1) - sum from i=1 to n of i = n*(b + 1) - n*(n + 1)/2

So, S = n*(b + 1) - n*(n + 1)/2 = n*(b + 1 - (n + 1)/2) = n*(b - n/2)

Wait, simplifying:

S = n*(b + 1) - n*(n + 1)/2 = n*(b + 1 - (n + 1)/2) = n*(2(b + 1) - (n + 1))/2 = n*(2b + 2 - n - 1)/2 = n*(2b - n + 1)/2

Which matches the expression in the program: (2 * b - n + 1) * n / 2

So, in the case when b - a >= n, the program correctly calculates the sum of the first n buns at modified prices.

Else, when b - a < n, the program calculates (b - a)/2 * (b - a + 1) + a * n

Which, as per earlier reasoning, is the sum of the first k = b - a buns at modified prices plus a * (n - k)

Wait, but earlier I thought k = b - a, but need to ensure that k <= min(n, b)

But in this case, since b - a < n and b - a <= b, then k = b - a

So, sum of first k = b - a buns at modified prices: sum from b down to b - k + 1 = b down to a + 1

Sum S = (b + a + 1) * (b - a) / 2

And remaining buns: n - k = n - (b - a)

So, total profit P = S + a * (n - k) = (b + a + 1)*(b - a)/2 + a*(n - b + a)

But in the program, it's (b - a)/2 * (b - a + 1) + a * n

Wait, is this equivalent?

Let me compute (b - a)/2 * (b - a + 1) + a * n

This is (b - a)(b - a + 1)/2 + a * n

Which is the sum of first (b - a) natural numbers plus a * n

But according to earlier, the sum S should be (b + a + 1)*(b - a)/2

Wait, there's a discrepancy here.

Wait, perhaps I made a mistake in calculating S.

Let me recalculate sum from b down to a + 1, number of terms k = b - a

Sum S = (b + (a + 1)) * (b - a) / 2 = (b + a + 1) * (b - a) / 2

But in the program, it's (b - a) * (b - a + 1) / 2 + a * n

Wait, these are different.

Wait, perhaps I need to verify with an example.

Take the first test case:

n = 4, a = 4, b = 5

k = b - a = 1

Program's output: (1 * 2 / 2) + 4 * 4 = 1 + 16 = 17, which matches.

Another example:

n = 5, a = 5, b = 9

k = 4

Sum S = (9 + 6 + 7 + 8) wait, no, from b=9 down to a+1=6, k=4

Sum S = 9 + 8 + 7 + 6 = 30

Remaining buns: n - k = 1, sold at a=5

Total profit: 30 + 5 = 35

According to program: (4 * 5 / 2) + 5 * 5 = 10 + 25 = 35, which matches.

Another example:

n = 1000, a = 1, b = 1000

k = b - a = 999

Sum S = sum from 1000 down to 2, which is (1000 + 2)*999/2 = 1002*999/2 = 1002*499.5 = 500500

Program's output: (999*1000/2) + 1*1000 = 499500 + 1000 = 500500, which matches.

So, the program seems to be correctly implementing the formula in this case.

Therefore, I conclude that the given program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]