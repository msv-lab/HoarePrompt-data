Alright, I've got this problem to solve. Let's see what it's about. So, there's this game between Alice and Bob involving an array of integers. Alice starts with an empty array 'c' and they take turns playing, with Alice going first. On Alice's turn, she picks an element from 'a', appends it to 'c', and deletes it from 'a'. Bob, on his turn, picks an element from 'a', and just deletes it from 'a'. The game ends when 'a' is empty, and the score is the MEX of 'c', which is the smallest non-negative integer not present in 'c'. Alice wants to maximize the score, and Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand the MEX concept clearly. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, the goal is to find the MEX of array 'c' after the game ends, with both players playing optimally. Alice wants to maximize this MEX, and Bob wants to minimize it.

Let me think about how the game progresses. Alice and Bob alternate turns, with Alice starting. Alice appends an element to 'c' and deletes it from 'a', while Bob just deletes an element from 'a'. The game ends when 'a' is empty.

I need to consider how the elements are chosen and deleted by both players and how that affects the final composition of 'c', which in turn affects the MEX.

Let me consider a simple example to get a feel for the problem.

Take the first test case from the example:

Input:

3

4

0 0 1 1

So, t=3 (number of test cases), n=4, arr=[0,0,1,1]

According to the explanation, the output for this is 2.

In the explanation, there's a possible game where:

1. Alice chooses 1 → a=[0,0,1], c=[1]

2. Bob chooses 0 → a=[0,1], c=[1]

3. Alice chooses 0 → a=[1], c=[1,0]

4. Bob chooses 1 → a=[], c=[1,0]

So, c=[1,0], MEX is 2.

But I need to confirm if this is indeed the optimal play for both.

Wait, let's see if there's a way for Bob to force a lower MEX or for Alice to achieve a higher MEX.

Suppose Alice chooses 0 first:

1. Alice chooses 0 → a=[0,1,1], c=[0]

2. Bob chooses 0 → a=[1,1], c=[0]

3. Alice chooses 1 → a=[1], c=[0,1]

4. Bob chooses 1 → a=[], c=[0,1]

Here, c=[0,1], MEX is 2 again.

Another scenario:

1. Alice chooses 1 → a=[0,0,1], c=[1]

2. Bob chooses 1 → a=[0,0], c=[1]

3. Alice chooses 0 → a=[0], c=[1,0]

4. Bob chooses 0 → a=[], c=[1,0]

Again, MEX is 2.

Seems like regardless of how they play, MEX is 2.

Let me check another test case.

Second test case:

4

0 1 2 3

Output:1

So, n=4, arr=[0,1,2,3], output=1

Let's simulate the game.

Possible game:

1. Alice chooses 0 → a=[1,2,3], c=[0]

2. Bob chooses 1 → a=[2,3], c=[0]

3. Alice chooses 2 → a=[3], c=[0,2]

4. Bob chooses 3 → a=[], c=[0,2]

MEX of c=[0,2] is 1.

Another game:

1. Alice chooses 1 → a=[0,2,3], c=[1]

2. Bob chooses 0 → a=[2,3], c=[1]

3. Alice chooses 2 → a=[3], c=[1,2]

4. Bob chooses 3 → a=[], c=[1,2]

MEX of c=[1,2] is 0.

Wait, but the output is 1, so maybe in optimal play, MEX is 1.

But in the second game, MEX is 0, which is lower.

So, perhaps depending on how Alice and Bob play, different MEX values can be achieved.

Given that Alice wants to maximize MEX and Bob wants to minimize it, I need to find the MEX that would result when both play optimally.

In this case, it's 1.

So, perhaps in the first game I simulated, MEX=1 is achievable, but in the second game, MEX=0 is possible.

But according to the output, it's 1, so maybe 1 is the optimal MEX.

Wait, I need to think differently.

Perhaps, I need to find the minimal MEX that Bob can force, given that Alice is trying to maximize it.

So, in this case, Bob can't force MEX to be less than 1, but Alice can ensure that MEX is at least 1.

Hence, the final MEX is 1.

Wait, but in one of the games, MEX=0 was achieved.

So, maybe Bob can force MEX to be 0.

But according to the output, it's 1.

So, perhaps there's something wrong with my simulation.

Wait, let's think differently.

Let's consider that Alice can choose elements in such a way that she includes certain numbers to maximize MEX, while Bob tries to disrupt that.

In the second test case, arr=[0,1,2,3], n=4.

If Alice wants to maximize MEX, she would try to include as many small integers as possible in 'c'.

But Bob can delete elements that Alice wants to include, or elements that would help Alice maximize MEX.

Wait, but Bob can only delete elements, not append them to 'c'.

So, Bob can remove elements that Alice might want to include in 'c', but he can't add elements to 'c'.

Wait, no, actually, Bob just deletes elements from 'a', he doesn't add anything to 'c'.

So, Bob can delete elements that Alice might want to include in 'c', making them unavailable.

Similarly, Alice can choose to include elements that are beneficial for maximizing MEX.

Wait, but in the first turn, Alice chooses an element to append to 'c' and delete from 'a'.

Bob then chooses an element to delete from 'a'.

So, in each of their turns, Alice adds one element to 'c' and deletes one element from 'a', and Bob deletes one element from 'a'.

So, in total, for n elements, there will be n moves: Alice makes ceil(n/2) moves of choosing and appending to 'c', and Bob makes floor(n/2) moves of just deleting.

Wait, let's think carefully about the number of moves each makes.

Total elements: n.

Each turn, one element is removed from 'a'.

So, total turns: n.

Alice starts, and alternates with Bob.

Alice's turns: 1,3,5,... (odd turns)

Bob's turns: 2,4,6,... (even turns)

On Alice's turn (odd turns):

- Choose an element from 'a', append it to 'c', and delete it from 'a'.

On Bob's turn (even turns):

- Choose an element from 'a', delete it from 'a'.

So, the number of elements Alice appends to 'c' is ceil(n/2), and the number of elements Bob deletes without appending is floor(n/2).

Wait, no.

Wait, total elements: n.

Alice appends ceil(n/2) elements to 'c', because she plays ceil(n/2) times.

Bob deletes floor(n/2) elements without appending.

But in reality, Alice appends ceil(n/2) elements to 'c', and Bob deletes floor(n/2) elements.

But wait, each time Alice plays, she deletes one element (the one she appends to 'c'), and Bob deletes one element each time he plays.

So, total elements deleted: n.

Which matches, since a has n elements.

So, c will have ceil(n/2) elements, since Alice appends ceil(n/2) elements to it.

So, in the first test case, n=4, c will have 2 elements.

In the second test case, n=4, c will have 2 elements.

In the third test case, n=2, c will have 1 element.

Wait, but in the third test case, output is 0.

So, n=2, arr=[1,1], c will have 1 element.

Possible games:

1. Alice chooses 1 → a=[1], c=[1]

2. Bob chooses 1 → a=[], c=[1]

MEX of c=[1] is 0.

Another possible game:

1. Alice chooses 1 → a=[1], c=[1]

2. Bob chooses 1 → a=[], c=[1]

Same result.

So, MEX is 0.

Hence, output is 0.

Okay, now I need to find a general strategy for both players.

Alice wants to maximize MEX of c, which means she wants c to contain as many small non-negative integers as possible.

Bob wants to minimize MEX of c, which means he wants to make sure that c misses some small non-negative integers.

So, Alice will try to include the smallest possible integers in c, while Bob will try to prevent that by deleting them or forcing Alice to include larger integers.

Wait, but Bob can only delete elements; he can't choose what Alice appends to c.

But Bob can delete elements that Alice might want to include in c, making them unavailable.

Wait, no, Alice chooses which element to append to c and then deletes it.

Bob just deletes elements from a.

So, Bob can choose to delete elements that Alice might want to include in c, making them unavailable for Alice to append.

Hence, Bob can strategically delete elements that Alice would prefer to append, forcing her to append less desirable elements.

Similarly, Alice can choose to append elements that are crucial for maximizing MEX.

I need to find a way to determine the minimal MEX that Bob can force, given that Alice is trying to maximize it.

This seems like a game where I need to find the minimal MEX that Bob can achieve despite Alice's efforts to maximize it.

So, I need to find the minimal MEX over all possible games where Alice tries to maximize MEX and Bob tries to minimize it.

This sounds like a minimax problem.

I need to find the minimal MEX that Bob can achieve, given that Alice is playing optimally to maximize MEX.

This seems complex.

Maybe there's a smarter way to approach this.

Let me think about the frequency of each number in the array.

Suppose I count the frequency of each number in the array.

Let's say, for numbers from 0 to n, I have their frequencies.

Alice wants to include as many small numbers as possible in c, while Bob tries to prevent that.

So, for each number i from 0 to n, if the frequency is sufficient, Alice can include it in c.

But Bob can try to delete those numbers to make them unavailable for Alice.

Wait, but Alice chooses which element to append to c and then deletes it.

Bob just deletes elements.

So, Alice can prioritize appending the smallest possible numbers to c, and Bob can try to delete those numbers to make them less available for Alice.

Let me consider the frequency of each number.

Suppose, for number 0, if it appears freq[0] times, then Alice can include floor(freq[0]/2) + ceil(freq[0]/2) = freq[0] instances of 0 in c, but considering the turns.

Wait, perhaps I need to think in terms of the number of times Alice can include a particular number.

Wait, perhaps it's better to think in terms of the parity of the number of players.

Wait, no.

Wait, perhaps I can think of it as:

For each number i, if freq[i] is the frequency of i in a.

Then, the number of times Alice can include i in c is ceil(freq[i]/2), because Alice gets to choose ceil(freq[i]/2) instances of i, and Bob gets to delete floor(freq[i]/2) instances of i.

Wait, but it's not exactly that, because Bob can choose to delete any element, not necessarily the ones Alice wants.

Wait, perhaps I need to think differently.

Let me consider that for each number i, the number of times it appears in a is freq[i].

Alice wants as many i's as possible in c, especially for smaller i's.

Bob wants to minimize the number of i's in c.

Given that, for each i, the number of times it can be included in c is ceil(freq[i]/2), because Alice gets to choose ceil(freq[i]/2) instances of i, and Bob can delete floor(freq[i]/2) instances of i.

Wait, perhaps that's a way to look at it.

So, for each i, the number of times it appears in c is ceil(freq[i]/2).

Then, c will contain ceil(freq[0]/2) zeros, ceil(freq[1]/2) ones, and so on.

Then, the MEX would be the smallest i where ceil(freq[i]/2) == 0.

Wait, but that might not be entirely accurate, because Bob can choose to delete elements strategically.

Wait, maybe I need to consider that for each i, if freq[i] is even, then Alice can include freq[i]/2 instances of i in c, and Bob can delete freq[i]/2 instances.

If freq[i] is odd, Alice can include ceil(freq[i]/2) = freq[i]/2 + 0.5, which rounds up to freq[i]/2 + 1 instances in c, and Bob can delete floor(freq[i]/2) instances.

Wait, but that might not be accurate, because the turns alternate.

Perhaps a better way is to sort the numbers and see which ones can be included by Alice.

Wait, maybe I should look for the smallest i such that ceil(freq[i]/2) == 0.

But ceil(freq[i]/2) == 0 only when freq[i] == 0.

Wait, that doesn't make sense.

Wait, ceil(0/2) = 0.

So, for i where freq[i] == 0, ceil(freq[i]/2) == 0.

So, MEX would be the smallest i where ceil(freq[i]/2) == 0.

But that seems too simplistic.

Wait, in the first test case, arr=[0,0,1,1], freq[0]=2, freq[1]=2, freq[2]=0, freq[3]=0.

Then, ceil(2/2)=1 for 0 and 1, ceil(0/2)=0 for 2 and 3.

So, MEX would be 2, which matches the output.

In the second test case, arr=[0,1,2,3], freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1.

Then, ceil(1/2)=1 for each, so MEX would be the smallest i with ceil(freq[i]/2)=0, which is 4.

But the output is 1.

Wait, that doesn't match.

So, my assumption is incorrect.

Hence, this approach is wrong.

Wait, perhaps I need to consider that Alice can include ceil(freq[i]/2) instances of i in c, but in the second test case, ceil(1/2)=1 for each i from 0 to 3, so c can have one of each, so c could be [0,1], or [0,2], or [0,3], etc., depending on how Alice plays.

Then, MEX would be 2,3, or 4, respectively.

But the output is 1, which doesn't align with this.

Hence, this approach is flawed.

Perhaps I need to consider the order in which elements are chosen.

This seems complicated.

Let me look for another way.

I recall that in games where one player wants to maximize and the other to minimize, often the result is determined by some kind of parity or frequency constraints.

Let me think differently.

Suppose I iterate through the numbers from 0 to n.

For each i, starting from 0, I check if freq[i] is greater than 0.

If freq[i] is greater than 0, then Alice can include ceil(freq[i]/2) instances of i in c.

If ceil(freq[i]/2) >=1, then i is included in c.

Otherwise, if ceil(freq[i]/2)==0, then i is not included in c, and hence MEX would be i.

But in the second test case, freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1.

Then, ceil(1/2)=1 for each, so c would include at least one of each 0,1,2,3.

Hence, MEX should be >=4.

But the output is 1, which contradicts this.

So, perhaps my assumption is wrong.

Wait, maybe I need to consider that Alice can include ceil(freq[i]/2) instances, but Bob can delete floor(freq[i]/2) instances.

But in reality, Bob can delete from anywhere, not necessarily from a specific i.

Hence, perhaps this approach is not accurate.

Let me consider another angle.

Suppose I sort the array a and try to include the smallest possible numbers in c.

But since Bob can delete elements, it's not straightforward.

Wait, perhaps I should consider the minimal i that freq[i] is less than the number of times Alice can include it in c.

Wait, I'm getting confused.

Let me look at the provided program and see what it's doing.

The program is:

from collections import Counter

def func():

for _ in range(int(input())):

n = int(input())

arr = list(map(int, input().split()))

mpp = Counter(arr)

first = False

for i in range(n + 1):

if i not in mpp.keys():

print(i)

break

if mpp[i] == 1 and first:

print(i)

break

if mpp[i] == 1:

first = True

So, it reads the number of test cases, then for each test case, it reads n and the array arr.

It counts the frequency of each element using Counter.

Then, it iterates from 0 to n.

If i is not in mpp.keys(), meaning freq[i] == 0, it prints i and breaks.

Else, if mpp[i] == 1 and first is True, it prints i and breaks.

Else, if mpp[i] == 1, it sets first to True.

Wait, in the first test case, arr=[0,0,1,1], mpp={0:2,1:2}.

So, for i=0: mpp[0]=2, not 1, so skip.

i=1: mpp[1]=2, not 1, so skip.

i=2: not in mpp, so print 2 and break.

Which matches the output.

In the second test case, arr=[0,1,2,3], mpp={0:1,1:1,2:1,3:1}.

i=0: mpp[0]=1, set first=True.

i=1: mpp[1]=1 and first=True, so print 1 and break.

Which matches the output.

In the third test case, arr=[1,1], mpp={1:2}.

i=0: not in mpp, so print 0 and break.

Which matches the output.

So, it seems to be working correctly for the given examples.

But is this logic correct in general?

Let me try to understand the logic.

The program checks for the smallest i that is not present in arr, and prints it.

Else, if there are multiple i with mpp[i]==1, it prints the second one encountered.

Wait, no.

It sets first=False.

For each i from 0 to n:

- If i not in mpp, print i and break.

- Else, if mpp[i]==1 and first is True, print i and break.

- Else, if mpp[i]==1, set first=True.

So, it's looking for the first i with mpp[i]==1 after encountering another mpp[j]==1.

Wait, that's not very clear.

Wait, in the second test case, arr=[0,1,2,3], mpp={0:1,1:1,2:1,3:1}.

So, for i=0: mpp[0]=1, set first=True.

i=1: mpp[1]=1 and first=True, so print 1 and break.

Hence, output is 1.

In the first test case, arr=[0,0,1,1], mpp={0:2,1:2}.

i=0: mpp[0]=2 !=1, skip.

i=1: mpp[1]=2 !=1, skip.

i=2: not in mpp, so print 2 and break.

Hence, output is 2.

In the third test case, arr=[1,1], mpp={1:2}.

i=0: not in mpp, so print 0 and break.

Hence, output is 0.

Now, I need to verify if this logic correctly determines the minimal MEX that Bob can force, given optimal play from both players.

Let me consider some more test cases.

Test case 1:

n=3

arr=[0,1,2]

mpp={0:1,1:1,2:1}

So, i=0: mpp[0]=1, set first=True.

i=1: mpp[1]=1 and first=True, print 1.

Hence, output=1.

But, let's see what the MEX would be.

Alice starts:

- Choose 0, a=[1,2], c=[0]

- Bob deletes 1, a=[2], c=[0]

- Alice chooses 2, c=[0,2]

MEX is 1.

Alternatively:

- Alice chooses 1, a=[0,2], c=[1]

- Bob deletes 0, a=[2], c=[1]

- Alice chooses 2, c=[1,2]

MEX is 0.

So, Bob can force MEX to be 0.

But according to the program, it outputs 1.

Which is incorrect in this case.

Hence, the program is wrong.

Wait, but according to the problem, Bob wants to minimize MEX, and Alice wants to maximize it.

So, in this case, Bob can force MEX to be 0, so the output should be 0.

But the program outputs 1.

Hence, the program is incorrect.

Wait, but in the second test case, it outputs 1, which matches the example.

But according to the example, output should be 1, but in this new test case, it should be 0.

Hence, the program is incorrect.

So, Correctness: False

But wait, perhaps I need to think more carefully.

In the new test case I considered, n=3, arr=[0,1,2], mpp={0:1,1:1,2:1}.

According to the program, it would output 1.

But in reality, Bob can force MEX to be 0.

Hence, the program is incorrect.

Therefore, Correctness: False

**Final Answer**

\[ \boxed{\text{False}} \]