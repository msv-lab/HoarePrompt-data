Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to handle multiple queries. Each query gives me a range [l, r], and I need to find two indices i and j within that range where the elements are different, i.e., a_i ≠ a_j. If such a pair doesn't exist, I should output -1 -1.

First, I need to understand the constraints. The array can be up to 2*10^5 elements, and there can be up to 2*10^5 queries per test case. With t test cases up to 10^4, but since n and q sums across test cases don't exceed 2*10^5 in total, I need to make sure my solution is efficient, probably O(n log n) or better.

Let me think about how to approach this. For each query, checking every pair isn't feasible due to the size of n and q. That would be O(q * n^2), which is way too slow.

An optimized way would be to preprocess the array in some manner so that each query can be answered quickly, ideally in O(1) or O(log n) time.

One idea is to find ranges where all elements are the same. If I can identify these ranges, then for any query that spans multiple such ranges, there must be at least one pair of different elements.

Wait, actually, for any query [l, r], if there are at least two distinct elements in the subarray a[l..r], then I can find such a pair. Otherwise, if all elements are the same, then no such pair exists.

So, perhaps I can precompute for each position i, the next position j where a[j] ≠ a[i]. That way, for any query [l, r], if there exists some position in [l, r] where a[j] ≠ a[l], then I can output l and j. Otherwise, output -1 -1.

But I need to make this efficient for large n and q.

Another approach could be to use a segment tree or a sparse table to find the minimum and maximum in the range [l, r]. If max != min, then there are at least two distinct elements, and I can find their indices. Otherwise, all elements are the same.

Wait, but the problem asks for specific indices i and j where a_i ≠ a_j. So, I need to not just determine if such a pair exists but also find actual indices.

Let me think about using a segment tree where each node stores the minimum and maximum values in its range, along with the indices where these values occur. Then, for each query [l, r], I can query the segment tree for the min and max in that range.

- If min != max, then I can output the indices of the min and max values.

- If min == max, then all elements are the same, so output -1 -1.

This seems promising. Let's see how to implement this.

First, build a segment tree for the array where each node stores:

- The minimum value in the range and its index.

- The maximum value in the range and its index.

Then, for each query [l, r], query the segment tree for the min and max in that range.

- If min != max, output the indices of min and max.

- Else, output -1 -1.

This should work and be efficient enough since building the segment tree is O(n), and each query is O(log n).

But perhaps there's a simpler way without using a segment tree.

Another idea is to precompute for each position i, the next position j where a[j] ≠ a[i]. Then, for each query [l, r], if the precomputed next[l] <= r, then output l and next[l]. Otherwise, output -1 -1.

This would require preprocessing the "next different" array, which can be done in O(n) time.

Let me see how to compute the "next different" array.

I can iterate through the array and group consecutive equal elements. For each group, the next different position for any element in the group would be the start of the next group.

So, first, I need to split the array into blocks of consecutive equal elements.

For example, for array [1,1,2,1,1], the blocks are:

- [1,1] from index 1 to 2

- [2] from index 3

- [1,1] from index 4 to 5

Then, for each block, the next different position is the start of the next block.

So, for block [1,1] (indices 1-2), next different is index 3.

For block [2] (index 3), next different is index 4.

For block [1,1] (indices 4-5), next different is index 6 (or beyond the array).

Then, for any query [l, r], find the block that contains l, and check if the next different position is within [l, r]. If yes, output l and next different position. If not, output -1 -1.

This seems efficient and avoids using a segment tree.

Let me try to formalize this.

1. Precompute the block starts and the next different position for each block.

- Iterate through the array and whenever a different element is found, mark the start of a new block.

- For each block, store the next different position.

2. For each query [l, r]:

- Find the block that contains l.

- Get the next different position for that block.

- If the next different position is within [l, r], output l and next different position.

- Else, output -1 -1.

This should work correctly and efficiently.

Let me see if there are any edge cases.

- If l == r, i.e., the query range has only one element, then no such pair exists. But according to the problem, l ≤ i, j ≤ r, and i and j can be the same as long as a_i ≠ a_j. But if there's only one element, no such pair exists, so output -1 -1.

- If l and r are in the same block, and all elements in [l, r] are the same, output -1 -1.

- If l and r span multiple blocks, then there must be at least two different elements.

Wait, the problem states that l ≤ i ≤ r and l ≤ j ≤ r, and a_i ≠ a_j. So, i and j can be the same as long as a_i ≠ a_j, but in the sample input, when l and r are the same, it outputs -1 -1.

Wait, in the sample input, when l and r are the same, it's not possible to have a_i ≠ a_j since i and j would have to be the same index, and a_i == a_j.

Wait, but the problem says "two indices i and j such that l ≤ i ≤ r and l ≤ j ≤ r and a_i ≠ a_j". So, i and j can be the same only if a_i ≠ a_j, which is impossible if a_i == a_j. So, effectively, i and j must be different indices.

But in the sample input, when l and r are the same, it outputs -1 -1, which makes sense.

So, in my approach, I need to ensure that i ≠ j.

In my earlier approach, when l and r are the same, the next different position would be beyond r, so correctly output -1 -1.

Also, in the case where l and r span multiple blocks, there are definitely different elements, so output l and next different position.

In the case where l and r are in the same block, and all elements are the same, output -1 -1.

Seems correct.

Another approach could be to use a prefix array to store the last position where the element changed before each position.

But I think the block approach is sufficient.

Now, looking at the given program, let's see what it's doing.

The function func_1() is defined to handle each test case.

It reads N, the array nums, and Q, the number of queries.

Then, it initializes s and e to 0, num to nums[0], and creates an empty list arr.

It appends -1 to nums, which might be for convenience in iteration.

Then, it iterates through nums from index 0 to N:

if nums[i] != num, it appends (1 + s, i, num) to arr, sets s to i, and updates num to nums[i].

After that, it sets LA to len(arr) - 1.

Then, for each query, it reads l and r, and based on some conditions, prints indices or -1 -1.

First, it seems like it's trying to group consecutive equal elements, similar to my block approach.

In arr, it's storing tuples (start, end, value) for each block where elements are equal.

Then, for each query [l, r], it uses bisect_left to find the position in arr where l would fit.

Then, it gets (s, e, _) = arr[min(eli, LA)].

Then, it checks:

- if s > l: print(s-1, s)

- elif e >= r: print(-1, -1)

- elif e < N: print(s, e+1)

- else: print(-1, -1)

This seems somewhat similar to my approach, but I need to verify if it's correct.

Let me take an example from the sample input.

Take the first test case:

n=5

a=[1,1,2,1,1]

q=3

queries: [1,5], [1,2], [1,3]

According to the sample output:

2 3

-1 -1

1 3

Let's see what the program does.

First, it groups the array into blocks:

- [1,1] from index 1 to 2

- [2] from index 3

- [1,1] from index 4 to 5

So, arr = [(1,2,1), (3,3,2), (4,5,1)]

Now, for query [1,5]:

- eli = bisect_left(arr, (1,0,0)) = 0 (since arr[0]=(1,2,1))

- (s,e,_) = arr[min(0,2)] = (1,2,1)

- s=1, l=1, so s > l is False

- e=2 < r=5, so it prints s=1 and e+1=4

But according to the sample output, it should print 2 3.

Hmm, not matching.

Wait, perhaps it's not correctly mapping to the indices.

Wait, in the sample output, for [1,5], it prints 2 3, which is within the first block and the second block.

But according to the program, it prints 1 and 4.

Wait, but in the sample output, it's 2 3, which is within the first and second blocks.

So, it's possible that the program's output is also correct because a[1]=1 and a[4]=1 are different from a[2]=1 and a[3]=2.

Wait, a[1]=1 and a[4]=1 are the same, but a[1]=1 and a[3]=2 are different.

So, printing 1 and 3 would also be correct.

But the program prints 1 and 4.

a[1]=1 and a[4]=1 are the same, so that's incorrect.

Wait, no, a[1]=1 and a[4]=1 are the same, so that's wrong.

But in the sample output, it's 2 and 3, which are different.

So, the program is incorrect in this case.

Wait, maybe the program has a mistake.

Looking back at the code:

if s > l:

if s == 1:

print(-1, -1)

else:

print(s - 1, s)

elif e >= r:

print(-1, -1)

elif e < N:

print(s, e + 1)

else:

print(-1, -1)

In the first query [1,5]:

s=1, l=1, so s > l is False

e=2 < r=5, so it prints s=1 and e+1=3

Wait, no, in the code, it's e < N, which is e < 5, so it prints s=1 and e+1=4

But in the sample output, it's 2 3.

So, there's a discrepancy.

Wait, perhaps the program is incorrect.

Let me check another query.

Take query [1,2]:

According to the sample output, -1 -1, because both a[1]=1 and a[2]=1 are the same.

According to the program:

eli = bisect_left(arr, (1,0,0)) = 0

(s,e,_) = (1,2,1)

s=1 <= l=1

e=2 >= r=2, so print -1 -1

Correct.

Another query [1,3]:

According to sample output, 1 3 (a[1]=1 and a[3]=2 are different)

According to the program:

eli = bisect_left(arr, (1,0,0)) = 0

(s,e,_) = (1,2,1)

s=1 <= l=1

e=2 < r=3

So, it would print s=1 and e+1=4

But a[1]=1 and a[4]=1 are the same, which is incorrect.

Sample output is 1 3, which is correct.

So, the program is incorrect in this case.

Hence, the program is incorrect.

Therefore, Correctness: **False**

**Final Solution**

To solve this problem, we need to determine if there are two indices within a given range of an array such that their corresponding elements are different. We need to handle multiple queries efficiently.

## Approach

1. **Precompute Block Information:**
   - We group the array into blocks of consecutive identical elements.
   - For each block, record the start and end indices along with the value of the elements in that block.

2. **Handle Queries Efficiently:**
   - For each query, determine the blocks that fall within the query range.
   - If the query range spans multiple blocks, there must be at least two different elements.
   - If the query range lies entirely within a single block, check if there are at least two distinct elements within that sub-range.

## Solution Code

```python
import sys
from bisect import bisect_left

def main():
    t = int(sys.stdin.readline())
    for _ in range(t):
        n = int(sys.stdin.readline())
        nums = list(map(int, sys.stdin.readline().split()))
        q = int(sys.stdin.readline())
        
        # Group the array into blocks of consecutive equal elements
        blocks = []
        s = 0
        for i in range(1, n + 1):
            if i == n or nums[i] != nums[s]:
                blocks.append((s + 1, i, nums[s]))
                s = i
        N = len(blocks)
        
        for _ in range(q):
            l, r = map(int, sys.stdin.readline().split())
            # Find the block that contains l
            idx = bisect_left(blocks, (l, 0, 0))
            if idx == N or blocks[idx][0] > l:
                idx -= 1
            s, e, val = blocks[idx]
            
            # If the block's end is within the query range and there's a next block
            if e < r and idx + 1 < N:
                # Different elements exist
                print(s, e + 1)
            elif s < r and e >= r:
                # Check if there are different elements within this block
                found = False
                for i in range(s + 1, r + 1):
                    if nums[i - 1] != nums[s - 1]:
                        print(s, i)
                        found = True
                        break
                if not found:
                    print(-1, -1)
            else:
                print(-1, -1)

if __name__ == "__main__":
    main()
```

## Explanation

1. **Block Creation:**
   - We iterate through the array and group consecutive identical elements into blocks. Each block is represented by a tuple `(start, end, value)`.

2. **Query Handling:**
   - For each query `[l, r]`, we use binary search (`bisect_left`) to find the block containing index `l`.
   - If the query range spans multiple blocks, we know there are different elements and print indices from different blocks.
   - If the query range lies within a single block, we check for different elements within that sub-range:
     - If different elements are found, print their indices.
     - If all elements are the same, print `-1 -1`.

This approach ensures that we handle queries efficiently while keeping the solution straightforward and easy to understand.