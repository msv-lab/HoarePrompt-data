Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to process multiple queries on this array. Each query gives me a range [l, r], and I need to find two indices i and j within this range such that a_i is not equal to a_j. If such a pair doesn't exist, I should output -1 -1.

First, I need to understand the problem thoroughly. I have to do this for multiple test cases, and there are constraints on the input sizes, so efficiency is key here.

Let me think about how to approach this. For each query, I need to check if there are at least two different elements in the subarray from index l to r. If there are, I need to output any such pair of indices; otherwise, indicate that no such pair exists.

A brute-force way would be, for each query, to iterate through the range [l, r] and check if all elements are the same. But given the constraints (n can be up to 2*10^5 and q up to 2*10^5), this would be too slow because it would be O(q * n), which could be up to 4*10^10 operations. That's not feasible.

I need a smarter way to handle this. Let's think about precomputing some information about the array that can help answer the queries quickly.

One idea is to precompute for each position the next different element. But I'm not sure if that's the best approach.

Wait, maybe I can group consecutive elements that are the same. For example, if the array is [1, 1, 2, 1, 1], I can think of it as blocks: [1,1], [2], [1,1]. Then, for a query [l, r], if it spans more than one block, there must be at least two different elements. If it's entirely within one block, then all elements are the same, so no such pair exists.

That seems promising. Let's formalize this.

I can preprocess the array to identify blocks of consecutive identical elements. I'll create a list of tuples, each containing the start and end indices of each block, along with the value of the element in that block.

For example, for the array [1, 1, 2, 1, 1], the blocks would be:

- (1, 2, 1)

- (3, 3, 2)

- (4, 5, 1)

Here, indices are 1-based.

Then, for each query [l, r], I can find the blocks that overlap with this range. If there is more than one block within [l, r], that means there are at least two different elements, and I can choose indices from two different blocks. If there's only one block, then all elements in [l, r] are the same, so I output -1 -1.

To find the blocks that overlap with [l, r], I can use binary search since the blocks are non-overlapping and sorted by start index.

Let me think about how to implement this.

First, build the block list:

- Iterate through the array, and whenever the element changes, start a new block.

- Store each block as a tuple: (start_index, end_index, value)

Then, for each query:

- Use binary search to find the first block that starts at or after l.

- Then, find the last block that ends at or before r.

- If there is more than one block in this range, output indices from the first and second blocks.

- If there's only one block, output -1 -1.

I need to handle edge cases carefully, like when l and r are at the boundaries of blocks.

Let me consider an example.

Take the array [1, 1, 2, 1, 1].

Blocks:

- (1, 2, 1)

- (3, 3, 2)

- (4, 5, 1)

Query: [1, 5]

- Blocks from 1 to 5 are all three blocks. More than one block, so different elements exist. Can choose i=2 (value 1) and j=3 (value 2).

Query: [1, 2]

- Only one block: (1, 2, 1). All elements same. Output -1 -1.

Query: [1, 3]

- Blocks: (1, 2, 1) and (3, 3, 2). Different elements. Choose i=2 (1) and j=3 (2).

This seems correct.

Another example: [30, 20, 20, 10, 10, 20]

Blocks:

- (1, 1, 30)

- (2, 3, 20)

- (4, 5, 10)

- (6, 6, 20)

Query: [1, 2]

- Blocks: (1,1,30) and (2,3,20). Different elements. Choose i=1 (30) and j=2 (20).

Query: [2, 3]

- Only one block: (2,3,20). All elements same. Output -1 -1.

Query: [2, 4]

- Blocks: (2,3,20) and (4,5,10). Different elements. Choose i=3 (20) and j=4 (10).

Query: [2, 6]

- Blocks: (2,3,20), (4,5,10), (6,6,20). Different elements. Choose i=3 (20) and j=4 (10).

Query: [3,5]

- Blocks: (3,3,20) and (4,5,10). Different elements. Choose i=3 (20) and j=4 (10).

Looks good.

Now, to implement this efficiently, I need to:

1. Build the block list in O(n) time.

2. For each query, use binary search to find the relevant blocks in O(log n) time.

3. Output the result based on the number of blocks in the range.

I need to make sure that the block list is 1-based indexed for ease of handling queries.

Also, I need to handle the cases where l and r are at the boundaries of blocks correctly.

Let me think about how to implement the binary search.

I can use the bisect module in Python, which provides binary search functions.

Specifically, for a given query [l, r], I can find the leftmost block that starts at or after l using bisect_left, and the rightmost block that ends at or before r using bisect_right.

Then, the number of blocks in the range is right - left.

If right - left >= 2, then there are at least two different blocks, hence different elements exist.

If right - left == 1, I need to check if the single block is entirely within [l, r]. If it is, then all elements are the same; otherwise, there are different elements.

Wait, no. If there's only one block in the range, and it's entirely within [l, r], then all elements in [l, r] are the same. If it's not entirely within [l, r], meaning that [l, r] spans part of this block, but since it's only one block, all elements are still the same.

Wait, actually, even if only part of a block is in [l, r], as long as it's only one block, all elements in [l, r] are the same.

So, if the number of blocks in the range is at least 2, output indices from two different blocks; else, output -1 -1.

To optimize, I can precompute for each block its start and end indices, and store them in a list of tuples.

Then, for each query, find the blocks that intersect with [l, r].

If there are at least two blocks, pick any i from the first block and j from the second block.

If there's only one block, check if it's entirely within [l, r]. If it is, output -1 -1; else, there must be different elements.

Wait, no. If there's only one block and it's entirely within [l, r], then all elements in [l, r] are the same. If it's not entirely within [l, r], but only partially, then still, all elements in [l, r] are the same because it's within one block.

Wait, actually, no. If the block starts before l and ends after r, then [l, r] is entirely within the block, so all elements are the same.

If the block starts at or after l and ends at or before r, and it's the only block in the range, then all elements in [l, r] are the same.

If there are multiple blocks in the range, then there are different elements.

So, in code, for each query [l, r]:

- Find the first block where start <= l

- Find the last block where end >= r

- If there are at least two such blocks, output indices from two different blocks.

- Else, output -1 -1.

I need to handle the block indices correctly.

Let me think about how to implement this.

I'll store the blocks in a list, where each element is a tuple: (start, end, value)

Then, for a query [l, r], I can find the leftmost block where start <= l, and the rightmost block where end >= r.

If the number of blocks between these two is at least 2, then there are different elements; else, all elements are the same.

Wait, perhaps it's better to find all blocks that intersect with [l, r] and count how many such blocks there are.

If there's only one block that covers the entire range [l, r], then all elements are the same.

If there are multiple blocks intersecting with [l, r], then there are different elements.

To optimize, I can use binary search to find the first block that starts at or after l, and the last block that ends at or before r.

Then, the number of blocks in this range will tell me if there are multiple different elements.

Wait, perhaps more precisely:

- Find the first block where start >= l

- Find the last block where end <= r

- If the number of blocks in this range is >= 2, then different elements exist.

- Else, if only one block is in this range, check if that block entirely covers [l, r]. If it does, then all elements are the same; else, there are different elements.

Wait, but if only one block is in the range and it entirely covers [l, r], then all elements are the same.

If only one block is in the range but it doesn't entirely cover [l, r], then there must be different elements outside of this block, but since the block is the only one in the range, it's unclear.

Actually, if only one block intersects with [l, r], and that block's start is <= l and its end is >= r, then [l, r] is entirely within that block, so all elements are the same.

If only one block intersects with [l, r], but it doesn't entirely cover [l, r], meaning that l is before the block's start or r is after the block's end, then there must be different elements outside of this block.

Wait, no. If only one block intersects with [l, r], but l is before the block's start or r is after the block's end, but since it's the only block in the range, it means that the elements in [l, r] are all from this block, hence all the same.

Wait, I'm getting confused.

Let me think differently.

Suppose I have the block list sorted by start index.

For a query [l, r], I can find the first block where start <= l (meaning the block includes l), and the last block where end >= r (meaning the block includes r).

If the first block and the last block are the same, then [l, r] is entirely within that block, so all elements are the same.

If the first block and the last block are different, then there are at least two different blocks in the range, hence different elements exist.

This seems correct.

So, in code:

- For each query [l, r]:

- Find the first block where block.start <= l

- Find the last block where block.end >= r

- If the first block and the last block are the same, output -1 -1

- Else, output any i from the first block and j from the second block

This should work.

Let me test this logic with the earlier example.

Array: [1,1,2,1,1]

Blocks:

- (1,2,1)

- (3,3,2)

- (4,5,1)

Query: [1,5]

- First block with start <=1: (1,2,1)

- Last block with end >=5: (4,5,1)

- They are different blocks, so different elements exist. Choose i=2 (1) and j=3 (2).

Query: [1,2]

- First block with start <=1: (1,2,1)

- Last block with end >=2: (1,2,1)

- Same block, so all elements same. Output -1 -1.

Query: [1,3]

- First block with start <=1: (1,2,1)

- Last block with end >=3: (3,3,2)

- Different blocks, so different elements exist. Choose i=2 (1) and j=3 (2).

Perfect.

Another example: [30,20,20,10,10,20]

Blocks:

- (1,1,30)

- (2,3,20)

- (4,5,10)

- (6,6,20)

Query: [2,4]

- First block with start <=2: (2,3,20)

- Last block with end >=4: (4,5,10)

- Different blocks, so different elements exist. Choose i=3 (20) and j=4 (10).

Query: [3,5]

- First block with start <=3: (2,3,20)

- Last block with end >=5: (4,5,10)

- Different blocks, so different elements exist. Choose i=3 (20) and j=4 (10).

Query: [2,3]

- First block with start <=2: (2,3,20)

- Last block with end >=3: (2,3,20)

- Same block, so all elements same. Output -1 -1.

Good.

Edge cases:

- Array with all elements the same.

- Array with all elements different.

- Queries with l=r.

- Queries with l=1 and r=n.

Let's consider array: [1,1,1,1,1]

Blocks:

- (1,5,1)

Query: [1,5]

- First block with start <=1: (1,5,1)

- Last block with end >=5: (1,5,1)

- Same block, output -1 -1.

Query: [3,4]

- First block with start <=3: (1,5,1)

- Last block with end >=4: (1,5,1)

- Same block, output -1 -1.

Another array: [1,2,3,4,5]

Blocks:

- (1,1,1)

- (2,2,2)

- (3,3,3)

- (4,4,4)

- (5,5,5)

Query: [1,5]

- First block with start <=1: (1,1,1)

- Last block with end >=5: (5,5,5)

- Different blocks, output i=1 (1) and j=2 (2).

Query: [2,4]

- First block with start <=2: (2,2,2)

- Last block with end >=4: (4,4,4)

- Different blocks, output i=2 (2) and j=3 (3).

Query: [3,3]

- First block with start <=3: (3,3,3)

- Last block with end >=3: (3,3,3)

- Same block, output -1 -1.

Looks correct.

Now, how to implement this efficiently.

I need to build the block list.

Iterate through the array, and whenever the element changes, start a new block.

Store each block as (start, end, value), 1-based indexing.

Then, for each query, find the first block with start <= l and the last block with end >= r.

If these two blocks are different, output indices from two different blocks.

Else, output -1 -1.

I need to choose i and j from different blocks.

I can choose i as any index in the first block and j as any index in the second block.

For simplicity, choose the last index of the first block and the first index of the second block.

Wait, but blocks are consecutive, so the last index of the first block is before the first index of the second block.

So, that's fine.

Let me think about implementing this in code.

I'll use Python's bisect module for binary search.

First, build the block list.

Then, for each query, use bisect_left to find the first block with start <= l.

Use bisect_right to find the last block with end >= r.

Then, check if these two blocks are different.

If they are, output indices from two different blocks.

Else, output -1 -1.

Wait, perhaps more precisely:

- Find the leftmost block where start <= l.

- Find the rightmost block where end >= r.

- If these two blocks are different, then there are at least two different blocks in the range, hence different elements exist.

- Else, only one block covers the range, so all elements are the same.

In code, I can store the block list sorted by start index.

Then, use bisect_left to find the first block with start > l, and take the previous block.

Wait, actually, bisect_left can be used to find the first block with start >= l.

Similarly, bisect_right can be used to find the first block with end > r, and take the previous block.

Then, check if these two blocks are the same or different.

Wait, perhaps it's better to iterate through the block list and find the relevant blocks.

But to optimize, I need O(log n) per query.

Let me think differently.

Suppose I have the block list sorted by start index.

For a query [l, r], I can find the first block where start >= l.

Then, among these blocks, find the last block where end <= r.

If there is more than one such block, then different elements exist.

Else, check if the single block covers [l, r] entirely.

Wait, perhaps it's getting complicated.

Let me stick to the earlier approach:

- Find the first block where start <= l.

- Find the last block where end >= r.

- If these two blocks are different, then different elements exist.

- Else, only one block covers the range, so all elements are the same.

To implement this, I can:

- Store the block list sorted by start index.

- Use bisect_left to find the first block with start >= l.

- Use bisect_right to find the last block with end <= r.

- If the first block index is less than the last block index, then there are at least two different blocks, hence different elements exist.

- Else, only one block covers the range, so all elements are the same.

Wait, perhaps I need to map the blocks to their start indices and end indices separately.

Actually, it's better to think in terms of binary search to find the relevant blocks.

Let me try to write some pseudocode.

Build blocks:

current = a[1]

start = 1

for i from 2 to n:

if a[i] != a[i-1]:

blocks.append( (start, i-1, a[i-1]) )

start = i

blocks.append( (start, n, a[n]) )

Then, for each query [l, r]:

left = bisect_left(blocks, l, key=lambda x: x[0])

right = bisect_right(blocks, r, key=lambda x: x[1])

if right - left >= 2:

# at least two different blocks

i = blocks[left][0]

j = blocks[left + 1][0]

print(i, j)

else:

print(-1, -1)

Wait, but bisect_left and bisect_right in Python are for sorted lists, and they work with the default comparison.

To use them with a specific key, I need to use bisect_left with a list of starts and a list of ends.

Alternatively, I can use the block list sorted by start index and then find the relevant blocks.

Maybe it's easier to use the start indices for bisect_left and end indices for bisect_right.

Let me see.

In Python's bisect module, bisect_left(a, x) returns the index where to insert x in list a to maintain sorted order.

Similarly, bisect_right(a, x) returns the index to insert x+1.

So, if I have a list of start indices, I can find the first block with start >= l.

Similarly, if I have a list of end indices, I can find the last block with end <= r.

Wait, but ends may not be sorted in the same order as starts.

Actually, since blocks are non-overlapping and sorted by start index, end indices are increasing.

So, I can have two lists: starts and ends, both sorted.

Then, for a query [l, r], find the index in starts where start >= l, and the index in ends where end <= r.

Then, the number of blocks in the range is determined by these indices.

Wait, perhaps it's better to store the blocks in a list where each element is (start, end, value), sorted by start.

Then, use bisect_left on the starts to find the first block with start >= l.

Use bisect_right on the ends to find the first block with end > r, then the last block with end <= r is that index - 1.

Then, if the first block index is less than or equal to the last block index, there are blocks in the range.

But I need to ensure that there are at least two different blocks.

Wait, maybe it's getting too complicated.

Let me look back at the initial approach.

Initial approach:

- For each query [l, r], find the first block with start <= l and the last block with end >= r.

- If these two blocks are different, then different elements exist.

- Else, only one block covers the range, so all elements are the same.

To implement this:

- Find the largest block index where start <= l.

- Find the smallest block index where end >= r.

- If these two indices point to different blocks, then different elements exist.

- Else, same block covers the range.

In code, I can:

- Have a list of blocks sorted by start.

- Use bisect_left to find the first block with start >= l.

- If the block before that (if any) has start <= l, use that block as the first block.

- Similarly, use bisect_right to find the first block with end > r, and take the block before that as the last block.

- If first block and last block are different, different elements exist.

- Else, same block covers the range.

Let me try to write this in code.

blocks = [(start, end, value), ...]

For a query [l, r]:

left_index = bisect_left(blocks, l, key=lambda x: x[0])

if left_index > 0:

first_block = blocks[left_index - 1]

else:

first_block = None

right_index = bisect_right(blocks, r, key=lambda x: x[1])

if right_index < len(blocks):

last_block = blocks[right_index - 1]

else:

last_block = None

if first_block and last_block and first_block != last_block:

# different blocks, different elements exist

i = first_block[0]

j = last_block[0]

print(i, j)

else:

print(-1, -1)

This seems correct.

I need to make sure that the block list is built correctly and that the indices are handled properly.

Also, need to handle cases where l or r are out of bounds, but since the constraints say 1 <= l <= r <= n, I don't need to worry about that.

Edge cases to consider:

- All elements are the same.

- All elements are different.

- Queries where l = r.

- Queries where l = 1 and r = n.

- Single element array (but n >= 2 as per constraints).

Wait, n >=2, so single element array is not possible.

Also, need to handle the block list correctly when n=2.

Let me think about n=2.

Array: [1,1]

Blocks: [(1,2,1)]

Query: [1,2]

- First block with start <=1: (1,2,1)

- Last block with end >=2: (1,2,1)

- Same block, output -1 -1.

Query: [1,1]

- First block with start <=1: (1,2,1)

- Last block with end >=1: (1,2,1)

- Same block, output -1 -1.

Query: [2,2]

- First block with start <=2: (1,2,1)

- Last block with end >=2: (1,2,1)

- Same block, output -1 -1.

Another array: [1,2]

Blocks: [(1,1,1), (2,2,2)]

Query: [1,2]

- First block with start <=1: (1,1,1)

- Last block with end >=2: (2,2,2)

- Different blocks, output i=1 and j=2.

Query: [1,1]

- First block with start <=1: (1,1,1)

- Last block with end >=1: (1,1,1)

- Same block, output -1 -1.

Query: [2,2]

- First block with start <=2: (2,2,2)

- Last block with end >=2: (2,2,2)

- Same block, output -1 -1.

Looks correct.

Now, to implement this efficiently in code.

I need to build the block list efficiently.

Iterate through the array, group consecutive identical elements.

Store each block as (start, end, value), 1-based indexing.

Then, for each query, use bisect_left and bisect_right to find the relevant blocks.

In Python, bisect module works with lists sorted in ascending order.

So, I can have a list of start indices and a list of end indices.

Wait, but it's easier to have the block list sorted by start index.

Then, use bisect_left to find the first block with start >= l.

If left_index > 0, then the block before it is the last block with start <= l.

Similarly, use bisect_right to find the first block with end > r.

Then, the block before that is the last block with end <= r.

If the first block and the last block are different, output indices from two different blocks.

Else, output -1 -1.

In code, it would look like:

from bisect import bisect_left, bisect_right

# Build blocks

blocks = []

current = a[0]

start = 1

for i in range(1, n):

if a[i] != a[i-1]:

blocks.append( (start, i, a[i-1]) )

start = i

blocks.append( (start, n, a[-1]) )

# For each query [l, r]

left_index = bisect_left(blocks, l, key=lambda x: x[0])

if left_index > 0:

first_block = blocks[left_index - 1]

else:

first_block = None

right_index = bisect_right(blocks, r, key=lambda x: x[1])

if right_index < len(blocks):

last_block = blocks[right_index - 1]

else:

last_block = None

if first_block and last_block and first_block != last_block:

# different blocks

i = first_block[0]

j = last_block[0]

print(i, j)

else:

print(-1, -1)

This should work.

I need to make sure that the block list is built correctly.

Let me test it with the earlier example.

Array: [1,1,2,1,1]

Blocks:

(1,2,1)

(3,3,2)

(4,5,1)

Query: [1,5]

left_index = bisect_left(blocks, 1, key=lambda x: x[0]) => 0

first_block = blocks[0 - 1] = None (invalid, but in code above it's handled as None)

right_index = bisect_right(blocks, 5, key=lambda x: x[1]) => 3

last_block = blocks[2] = (4,5,1)

Since first_block is None, output -1 -1 (wait, that's incorrect).

Wait, this is a mistake.

I need to adjust the logic.

If left_index == 0, it means there is no block with start <= l, which is incorrect.

Wait, in the array [1,1,2,1,1], for query [1,5]:

blocks = [(1,2,1), (3,3,2), (4,5,1)]

left_index = bisect_left(blocks, 1, key=lambda x: x[0]) => 0

since blocks[0].start ==1, which is <= l=1.

So first_block = blocks[0 - 1] = None (which is incorrect).

Wait, perhaps I need to adjust the logic.

Let me read the bisect_left documentation.

bisect_left(a, x, key) returns the leftmost index to insert x in a to maintain order, based on key.

In this case, if blocks are sorted by start, and I do bisect_left(blocks, l, key=lambda x: x[0]), it returns the index of the first block with start >= l.

If start >= l, then the first block with start >= l is blocks[left_index].

If left_index > 0, then blocks[left_index - 1] is the last block with start < l.

But in our case, we need the first block with start <= l.

Wait, perhaps I need to find the last block with start <= l.

To find the last block with start <= l, I can use bisect_right(blocks, l, key=lambda x: x[0]) - 1.

Similarly, to find the first block with end >= r, I can use bisect_left(blocks, r, key=lambda x: x[1]).

Then, check if these two blocks are different.

In code:

first_block_index = bisect_right(blocks, l, key=lambda x: x[0]) - 1

last_block_index = bisect_left(blocks, r, key=lambda x: x[1])

if first_block_index != last_block_index:

# different blocks

i = blocks[first_block_index][0]

j = blocks[last_block_index][0]

print(i, j)

else:

print(-1, -1)

Wait, let's test this with the [1,5] query.

blocks = [(1,2,1), (3,3,2), (4,5,1)]

first_block_index = bisect_right(blocks, 1, key=lambda x: x[0]) -1 => bisect_right([1,3,4],1) -1 => 0 -1 => -1 (invalid)

Wait, that doesn't work.

Wait, bisect_right(blocks, 1, key=lambda x: x[0]):

blocks starts at 1, then 3, then 4.

bisect_right([1,3,4],1) => index 1, since 1 < 3.

So first_block_index = 1 -1 =0

last_block_index = bisect_left(blocks, 5, key=lambda x: x[1]) => bisect_left([2,3,5],5) => index 2

So first_block_index =0, last_block_index=2, which are different, so different blocks exist.

Good.

Another test: query [1,2]

first_block_index = bisect_right(blocks,1,key=lambda x: x[0]) -1 =>1-1=0

last_block_index = bisect_left(blocks,2,key=lambda x: x[1]) =>0

first_block_index == last_block_index, so output -1 -1

Correct, because [1,2] is within the first block.

Another test: query [1,3]

first_block_index = bisect_right(blocks,1) -1 =>0

last_block_index = bisect_left(blocks,3,key=lambda x: x[1]) =>1

different blocks, so output indices from blocks[0] and blocks[1]

Good.

Seems correct.

I need to make sure that bisect_right and bisect_left are used correctly with the key.

In Python's bisect module, the key function is not directly supported, but I can use operators.attrgetter or lambda functions with bisect.

Alternatively, I can create separate lists for starts and ends.

Let me try that.

Define starts = [block[0] for block in blocks]

Define ends = [block[1] for block in blocks]

Then, for a query [l, r]:

first_block_index = bisect_right(starts, l) -1

last_block_index = bisect_left(ends, r)

if first_block_index != last_block_index:

i = blocks[first_block_index][0]

j = blocks[last_block_index][0]

print(i, j)

else:

print(-1, -1)

Wait, in the earlier test:

blocks = [(1,2,1),(3,3,2),(4,5,1)]

starts = [1,3,4]

ends = [2,3,5]

query [1,5]:

first_block_index = bisect_right([1,3,4],1) -1 =>1-1=0

last_block_index = bisect_left([2,3,5],5)=>2

different blocks, correct.

query [1,2]:

first_block_index =1-1=0

last_block_index=0

same block, correct.

query [1,3]:

first_block_index=0

last_block_index=1

different blocks, correct.

Good.

I think this approach is solid.

Now, to implement this efficiently in code.

Also, need to handle the case where l=1 and there is no block starting before 1.

Similarly, for r=n, ensure that the last block is handled correctly.

I need to make sure that the block list includes all elements, and that the starts and ends cover the entire array.

Another consideration is to handle the blocks correctly when n=2.

For example, array [1,2]:

blocks = [(1,1,1),(2,2,2)]

starts = [1,2]

ends = [1,2]

query [1,2]:

first_block_index = bisect_right([1,2],1) -1 =>1-1=0

last_block_index = bisect_left([1,2],2)=1

different blocks, correct.

query [1,1]:

first_block_index=1-1=0

last_block_index=bisect_left([1,2],1)=0

same block, correct.

query [2,2]:

first_block_index=bisect_right([1,2],2)-1=2-1=1

last_block_index=bisect_left([1,2],2)=1

same block, correct.

Looks good.

Now, to implement this in code.

I need to build the block list efficiently.

Iterate through the array, group consecutive identical elements.

Store each block as (start, end, value), 1-based indexing.

Then, create starts and ends lists from the blocks.

Then, for each query, use bisect_right on starts to find the first block with start > l, then take the previous block.

Use bisect_left on ends to find the first block with end >= r, which is last_block_index.

If first_block_index != last_block_index, then different blocks exist.

Else, same block.

Output accordingly.

I need to make sure that the block list is built correctly and that the indices are handled properly.

Also, need to handle the case where l=1 and there is no block starting before 1.

Similarly, for r=n, ensure that the last block is included.

I think with the above logic, it should be handled correctly.

Now, to think about the time complexity.

Building the block list takes O(n).

For each query, bisect_right and bisect_left take O(log n).

So, total time complexity is O(n + q log n), which should be efficient enough given the constraints (n and q up to 2e5).

Now, to implement this in code.

I need to be careful with 1-based vs 0-based indexing.

In Python, lists are 0-based, so need to adjust indices accordingly.

Also, need to read input efficiently since n and q can be up to 2e5.

I can use sys.stdin.readline for faster input.

Also, for large test cases, I need to make sure that I read all test cases correctly.

Given that t test cases are provided, and for each test case, I need to read n, the array, q, and then q queries.

I need to handle multiple test cases correctly.

In code, I can use a loop for t test cases, and for each test case, read n, read the array, read q, and then process q queries.

I need to make sure that I don't mix up the input between test cases.

Also, need to ensure that the block list is rebuilt for each test case.

Now, to think about the sample input and output.

Looking back at the sample input and output provided in the problem, I need to make sure that my code matches the expected output format.

Each query's output is two integers i and j, or -1 -1, separated by space.

Test cases should be separated by empty lines, but it's not mandatory.

I can choose to separate them or not, as per the problem statement.

I'll make sure to follow the output format correctly.

Also, need to handle the queries in the order they are given.

No need for sorting or any other processing.

Now, to proceed to code this solution.

I need to write the code accordingly.

## Final Solution
To solve this problem, we need to determine if there are at least two different elements within a specified range in an array for multiple queries. We need to output the indices of such elements if they exist; otherwise, indicate that no such pair exists.

### Approach

1. **Block Creation**:
    - Group consecutive identical elements into blocks. Each block records the start and end indices of the sequence of identical elements.
    
2. **Binary Search for Queries**:
    - For each query, use binary search to identify the blocks that overlap with the query range.
    - If there is more than one block within the query range, it indicates the presence of different elements.
    - If there is only one block, all elements in the range are the same.

3. **Efficiency**:
    - Precompute the blocks in linear time.
    - Answer each query efficiently using binary search on the blocks.

### Solution Code

```python
import sys
from bisect import bisect_right, bisect_left

def func_1():
    input = sys.stdin.readline
    N = int(input())
    nums = list(map(int, input().split()))
    blocks = []
    s = 0
    num = nums[0]
    for e in range(1, N):
        if nums[e] != num:
            blocks.append((s + 1, e, num))  # 1-based indexing
            s = e
            num = nums[e]
    blocks.append((s + 1, N, num))  # Add the last block

    starts = [block[0] for block in blocks]
    ends = [block[1] for block in blocks]

    Q = int(input())
    for _ in range(Q):
        l, r = map(int, input().split())
        first_block_index = bisect_right(starts, l) - 1
        last_block_index = bisect_left(ends, r)
        if first_block_index != last_block_index:
            i = blocks[first_block_index][0]
            j = blocks[last_block_index][0]
            print(i, j)
        else:
            print(-1, -1)

tc = int(sys.stdin.readline())
for _ in range(tc):
    func_1()
```

### Explanation

1. **Block Creation**:
    - We iterate through the array and group consecutive identical elements into blocks. Each block is represented as a tuple `(start, end, value)` where `start` and `end` are 1-based indices.

2. **Binary Search for Queries**:
    - For each query, we use `bisect_right` to find the last block that starts before or at `l` and `bisect_left` to find the first block that ends after or at `r`.
    - If these blocks are different, it means there are different elements in the range, and we output indices from these blocks.
    - If they are the same, it means all elements in the range are the same, and we output `-1 -1`.

3. **Efficiency**:
    - The block creation step is O(n).
    - Each query is processed in O(log n) time using binary search.
    - This ensures the solution is efficient for large input sizes, adhering to the problem's constraints.