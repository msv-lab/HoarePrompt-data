Alright, I have this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if Bob can set up the stalls and set the prices in such a way that Alice buys exactly k jewels. If it's possible, I need to output "YES", followed by the number of stalls and the prices for each stall. If it's not possible, I should output "NO".

First, I need to understand the greedy behavior of Alice. She will always buy as many jewels as possible from the current stall with her remaining coins. So, for each stall, she will buy floor(remaining_coins / price_per_jewel) jewels.

Given that Bob can set up at most 60 stalls, I need to find a sequence of up to 60 prices such that when Alice buys jewels from these stalls in order, she ends up with exactly k jewels.

I should consider how to distribute the k jewels across the stalls. One approach could be to have each stall correspond to a certain number of jewels that Alice will buy from it.

Let me think about the constraints:

- n: number of coins Alice has (1 ≤ n ≤ 10^18)

- k: number of jewels Bob wants Alice to buy (1 ≤ k ≤ 10^18)

- At most 60 stalls

- Each stall has a price between 1 and 10^18 coins

I need to make sure that the total number of jewels Alice buys is exactly k, and she doesn't buy more or less, regardless of the coins she has left after buying.

Also, it's important to note that Alice doesn't need to spend all her coins; she just needs to buy exactly k jewels.

Let me consider some examples to understand better.

Example 1:

n = 7, k = 3

One possible solution is to have 10 stalls with prices: 2,3,4,5,6,7,8,9,10,11

Alice buys:

- Stall 1: floor(7/2) = 3 jewels, remaining coins: 7 - 3*2 = 1

- Since she has only 1 coin left, she can't buy anything from the remaining stalls.

- Total jewels: 3

This matches the required k.

Example 2:

n = 6, k = 4

The output is "NO", meaning it's impossible to set up stalls such that Alice buys exactly 4 jewels.

Example 3:

n = 255, k = 8

One possible solution is to have 8 stalls with prices: 128,64,32,16,8,4,2,1

Alice buys:

- Stall 1: floor(255/128) = 1, remaining coins: 255 - 128 = 127

- Stall 2: floor(127/64) = 1, remaining coins: 127 - 64 = 63

- Stall 3: floor(63/32) = 1, remaining coins: 63 - 32 = 31

- Stall 4: floor(31/16) = 1, remaining coins: 31 - 16 = 15

- Stall 5: floor(15/8) = 1, remaining coins: 15 - 8 = 7

- Stall 6: floor(7/4) = 1, remaining coins: 7 - 4 = 3

- Stall 7: floor(3/2) = 1, remaining coins: 3 - 2 = 1

- Stall 8: floor(1/1) = 1, remaining coins: 1 - 1 = 0

- Total jewels: 8

This also matches the required k.

From these examples, it seems that the approach is to set prices in a way that Alice buys one jewel from each stall, decrementing her coins each time, until she has bought k jewels.

But in the first example, Alice buys 3 jewels from the first stall and then doesn't have enough coins for the next stalls. So, it's possible to have stalls where Alice buys multiple jewels from a single stall.

I need to generalize this.

Let me think about how to分配 stalls and their prices.

One idea is to start with the highest possible price and have Alice buy as many jewels as possible from that stall, then proceed to lower prices.

But I need to ensure that the total number of jewels bought is exactly k.

Another idea is to use a binary search approach, similar to the binary representation of numbers, where each stall corresponds to a bit.

Wait, in the third example, the prices are powers of 2, which is similar to binary representation.

But in the first example, the prices are consecutive numbers, and it still works.

I need to find a general strategy that works for any n and k, given the constraints.

Let me consider that Alice buys a certain number of jewels from each stall, and the sum of jewels from all stalls should be exactly k.

Also, the number of stalls should be at most 60.

Given that k can be up to 10^18, and n can be up to 10^18, I need an efficient way to distribute the jewels.

Let me think about the minimal number of stalls required.

In the best case, if k = 1, Alice buys one jewel, so one stall is enough.

In the worst case, k can be up to 10^18, and I have only 60 stalls, so I need to make sure that I can distribute up to 10^18 jewels across 60 stalls.

Wait, but 60 stalls can handle up to 60 different prices, but the number of jewels bought from each stall can be up to floor(n / price).

So, I need to choose prices such that the sum of floor(n_i / p_i) across all stalls equals k, where n_i is the remaining coins after previous stalls.

This seems a bit tricky.

Let me consider a greedy approach: start with the highest possible price that allows Alice to buy as many jewels as possible without exceeding k.

Wait, but in the first example, Alice buys 3 jewels from the first stall and that's it.

In the third example, she buys one jewel from each of 8 stalls.

So, perhaps I need to find a way to have Alice buy a specific number of jewels from each stall.

Let me try to formalize this.

Let s be the number of stalls, with s ≤ 60.

Let p1, p2, ..., ps be the prices for each stall.

Let b1, b2, ..., bs be the number of jewels Alice buys from each stall.

Then, we have:

sum_{i=1 to s} bi = k

And for each i, bi = floor(n_i / p_i), where n_i is the remaining coins before stall i.

This is recursive, as n_i depends on the previous stalls.

This seems complicated to handle directly.

Is there a smarter way to approach this?

Let me consider that if I set a stall with a very high price, Alice will buy fewer jewels from it, and if I set a stall with a very low price, she will buy more jewels from it.

But I need to control the total number of jewels bought.

Another idea: maybe I can set the prices in decreasing order, so that Alice buys as many as possible from the first stall, then as many as possible from the second, and so on, until she has bought k jewels.

But I need to make sure that the total is exactly k.

Wait, perhaps I can set the prices in such a way that the number of jewels bought from each stall is predetermined, and the prices are set accordingly.

For example, if I want Alice to buy b1 jewels from stall 1, b2 from stall 2, and so on, up to bs from stall s, with sum(bi) = k.

Then, for each stall i, I can set the price p_i such that:

b_i = floor(n_i / p_i)

Where n_i is the remaining coins after previous stalls.

This seems feasible, but I need to find a way to set p_i such that this holds.

Let me try to find p_i in terms of n_i and b_i.

Given b_i = floor(n_i / p_i), this means:

b_i ≤ n_i / p_i < b_i + 1

Which implies:

n_i / (b_i + 1) < p_i ≤ n_i / b_i

So, p_i can be any integer in the range (n_i / (b_i + 1), n_i / b_i ]

But p_i needs to be an integer between 1 and 10^18.

So, for each stall, I need to choose p_i within this range.

But I need to determine the b_i's first.

This seems a bit involved.

Is there a better way?

Let me consider that the minimal number of stalls required is ceil(k / max_bi per stall).

But since max_bi can be up to floor(n / p), and p can be as low as 1, the maximal bi is min(k, floor(n / 1)) = min(k, n).

But n can be up to 10^18, and k up to 10^18, so this doesn't directly help.

Wait, perhaps I can consider that in each stall, Alice can buy up to floor(n / p) jewels.

So, if I set p1 = ceil(n / k), then b1 = floor(n / p1), which would be floor(n / ceil(n / k)).

I need to recall that floor(n / ceil(n / k)) is equal to floor(n / ceil(n / k)).

This might be a way to recursively divide the problem.

Wait, this seems similar to the algorithm for distributing k items into s groups, but with some constraints.

But I need to make sure that the total number of jewels bought is exactly k, and that the number of stalls is at most 60.

Let me think differently.

Suppose I set up s stalls, with s ≤ 60.

I need to choose prices p1, p2, ..., ps such that the sum of floor(n_i / p_i) over i from 1 to s is equal to k, where n_i is the remaining coins after previous stalls.

This seems too vague.

Maybe I can consider setting the prices in decreasing order, so that Alice buys as many as possible from the first stall, then from the second, and so on.

But I need to control the total number of jewels bought.

Wait, perhaps I can use a greedy approach where I maximize the number of jewels bought from each stall, without exceeding k.

Let me try to formalize this.

Initialize remaining_k = k

Initialize remaining_n = n

Initialize an empty list for stalls

While remaining_k > 0 and remaining_n > 0:

If remaining_k >= floor(remaining_n / p):

Set bi = floor(remaining_n / p)

Else:

Set bi = remaining_k

Set p = ceil(remaining_n / bi)

Append p to the list of stalls

Set remaining_n = remaining_n - (bi * p)

Set remaining_k = remaining_k - bi

But I need to choose p such that it's an integer between 1 and 10^18.

Also, I need to ensure that the number of stalls doesn't exceed 60.

This seems promising, but I need to make sure that this approach works.

Let me try to implement this logic step by step.

First, I need to decide on the price p for each stall based on the remaining coins and the remaining number of jewels to buy.

I need to choose p such that floor(remaining_n / p) <= remaining_k

And also, p should be in [1, 10^18]

Let me consider that for each stall, I can choose p to be ceil(remaining_n / remaining_k)

This way, floor(remaining_n / p) = floor(remaining_n / ceil(remaining_n / remaining_k)) which is equal to floor(remaining_n / ceil(remaining_n / remaining_k))

I need to recall that floor(n / ceil(n / k)) is equal to floor(n / ceil(n / k))

In some cases, this can be equal to k or less.

Wait, perhaps I need to look up some properties of floor and ceil functions.

Recall that floor(n / ceil(n / k)) is equal to floor(n / ceil(n / k))

Also, ceil(n / floor(n / k)) is related.

I need to find a way to set p such that floor(n / p) is as desired.

This seems a bit complicated.

Let me consider a different approach.

Suppose I set up stalls with decreasing prices, starting from a high price and going down.

For example, in the first example, prices are from 2 to 11.

In the third example, prices are powers of 2, decreasing.

Maybe I can set prices in a geometric sequence or something similar.

But I need a general method that works for any n and k.

Let me think about the minimal number of stalls required.

If I set up one stall with p = ceil(n / k), then Alice buys floor(n / p) jewels.

But floor(n / ceil(n / k)) might be less than or equal to k.

If it's equal to k, then I'm done.

If it's less than k, then I need to set up another stall.

Wait, perhaps I can iteratively set up stalls like this:

Initialize remaining_k = k

Initialize remaining_n = n

Initialize an empty list for stalls

While remaining_k > 0:

Set p = ceil(remaining_n / remaining_k)

Set b = floor(remaining_n / p)

If b > remaining_k:

Set b = remaining_k

Append p to the list of stalls

Set remaining_n = remaining_n - (b * p)

Set remaining_k = remaining_k - b

If the number of stalls exceeds 60, output "NO"

Else, output "YES", number of stalls, and the list of p's

Wait, but in the first example, with n=7 and k=3:

- remaining_n = 7, remaining_k = 3

- p = ceil(7 / 3) = 3

- b = floor(7 / 3) = 2

- Since b < remaining_k, set b = 2

- remaining_n = 7 - (2 * 3) = 1

- remaining_k = 3 - 2 = 1

- Set p = ceil(1 / 1) = 1

- b = floor(1 / 1) = 1

- remaining_n = 1 - 1 = 0

- remaining_k = 1 - 1 = 0

- Total stalls: 2, with prices 3 and 1

But in the example, it uses 10 stalls with prices from 2 to 11.

So, my approach suggests that 2 stalls are enough for the first example.

Wait, but according to the problem, it's acceptable to use fewer than 60 stalls, as long as it's at most 60.

So, in this case, 2 stalls would suffice.

But the example provided uses 10 stalls, which is also acceptable since it's within 60.

So, my approach seems valid.

Let me check it with the third example:

n=255, k=8

- remaining_n = 255, remaining_k = 8

- p = ceil(255 / 8) = 32

- b = floor(255 / 32) = 7

- Set b = 7 (since 7 <= 8)

- remaining_n = 255 - (7 * 32) = 255 - 224 = 31

- remaining_k = 8 - 7 = 1

- p = ceil(31 / 1) = 31

- b = floor(31 / 31) = 1

- remaining_n = 31 - 31 = 0

- remaining_k = 1 - 1 = 0

- Total stalls: 2, with prices 32 and 31

But in the example, they use 8 stalls with prices 128,64,32,16,8,4,2,1

So, their approach is different, but both are valid.

This suggests that there are multiple ways to achieve the goal, and my approach is also valid, as long as the total number of stalls is at most 60.

Now, I need to consider if there are cases where this approach would fail.

Suppose n=1, k=1

- p = ceil(1 / 1) = 1

- b = floor(1 / 1) = 1

- remaining_n = 0

- remaining_k = 0

- Total stalls: 1, with price 1

This works.

Another case: n=1, k=0

Wait, k must be at least 1, as per constraints.

Another case: n=5, k=2

- p = ceil(5 / 2) = 3

- b = floor(5 / 3) = 1

- remaining_n = 5 - 3 = 2

- remaining_k = 2 - 1 = 1

- p = ceil(2 / 1) = 2

- b = floor(2 / 2) = 1

- remaining_n = 2 - 2 = 0

- remaining_k = 1 - 1 = 0

- Total stalls: 2, with prices 3 and 2

This seems correct.

Another case: n=10, k=5

- p = ceil(10 / 5) = 2

- b = floor(10 / 2) = 5

- remaining_n = 10 - 10 = 0

- remaining_k = 5 - 5 = 0

- Total stalls: 1, with price 2

Again, works.

Wait, but what if n=10, k=6

- p = ceil(10 / 6) = 2

- b = floor(10 / 2) = 5

- remaining_n = 10 - 10 = 0

- remaining_k = 6 - 5 = 1

But remaining_n is 0, but remaining_k is 1, which means it's impossible to buy more jewels, since no more coins are left.

So, in this case, it should output "NO"

Because with n=10 coins and k=6 jewels, it's impossible to make Alice buy exactly 6 jewels.

Wait, is that true?

Let me see.

If I set up one stall with p=2, Alice buys 5 jewels, and then another stall with p=1, Alice buys 0 jewels (since n=0).

Total jewels: 5, which is less than 6.

Alternatively, if I set up a stall with p=1, Alice buys 10 jewels, which is more than 6.

So, indeed, it's impossible to make Alice buy exactly 6 jewels with n=10 and k=6.

Hence, the output should be "NO"

So, my approach correctly identifies this case as impossible.

Now, let's consider n=6, k=4, which is the second example, and the output is "NO"

Let's apply my approach:

- p = ceil(6 / 4) = 2

- b = floor(6 / 2) = 3

- remaining_n = 6 - 6 = 0

- remaining_k = 4 - 3 = 1

Since remaining_n = 0 and remaining_k =1, it's impossible.

Hence, output "NO"

This matches the sample output.

Good.

Another test case: n=10^18, k=1

- p = ceil(10^18 / 1) = 10^18

- b = floor(10^18 / 10^18) =1

- remaining_n =0

- remaining_k=0

- Total stalls:1, with price 10^18

Works.

Another test case: n=1, k=10^18

- p = ceil(1 / 10^18) =1

- b = floor(1 /1) =1

- remaining_n =0

- remaining_k=10^18 -1

Since remaining_n=0 and remaining_k>0, it's impossible.

Hence, output "NO"

This makes sense.

Now, I need to make sure that the number of stalls doesn't exceed 60.

In my approach, in each iteration, I set up one stall, so the number of stalls would be equal to the number of iterations.

In the worst case, if k is large and n is small, but n is just enough to buy k jewels with low-priced stalls, the number of stalls could be up to k.

But since k can be up to 10^18, and we have a limit of 60 stalls, I need to make sure that if the number of stalls exceeds 60, I output "NO"

Wait, but in my approach, I set up one stall per iteration, and stop when remaining_k ==0.

But in cases where k is large, I might need more than 60 stalls, but in reality, I can set up stalls with higher prices to reduce the number of stalls needed.

Wait, for example, if k=100 and n=100, I can set up one stall with p=1, and Alice buys 100 jewels.

So, it's possible with one stall.

But if k=100 and n=100, and I set p=1, b=100, remaining_n=0, remaining_k=0, which is fine.

So, in this case, I need only one stall.

Another case: k=100, n=50

Then p=ceil(50/100)=1

b=floor(50/1)=50

remaining_n=0

remaining_k=50

Since remaining_n=0 and remaining_k=50>0, it's impossible.

Hence, output "NO"

So, my approach seems to handle these cases correctly.

But I need to make sure that in cases where multiple stalls are needed, the total number doesn't exceed 60.

Let me consider a case where k is large, say k=100, n=10000.

- p=ceil(10000/100)=100

- b=floor(10000/100)=100

- remaining_n=0

- remaining_k=0

- Total stalls:1, with p=100

Works.

Another case: k=100, n=99

- p=ceil(99/100)=1

- b=floor(99/1)=99

- remaining_n=0

- remaining_k=1

Impossible.

Hence, "NO"

Seems correct.

Wait, but what if k=100, n=1000000000000000000 (10^18)

- p=ceil(1e18 / 100)= floor((1e18 + 99)/100)= floor(1e18/100 + 99/100)= floor(1e16 + 99/100)=1e16

- b=floor(1e18 / 1e16)=100

- remaining_n=0

- remaining_k=0

- Total stalls:1, with p=1e16

Works.

Seems fine.

Now, what if k=100, n=101

- p=ceil(101/100)=2

- b=floor(101/2)=50

- remaining_n=101 - 100 =1

- remaining_k=100 -50=50

- p=ceil(1/50)=1

- b=floor(1/1)=1

- remaining_n=0

- remaining_k=50-1=49

Since remaining_n=0 and remaining_k=49>0, impossible.

Hence, "NO"

Correct, because with n=101, you can't buy 100 jewels if p=2 gives 50 jewels, and p=1 gives 1 jewel, total 51, which is less than 100.

Wait, but earlier I thought that p=1 would give b=floor(1/1)=1, so total jewels=50+1=51 <100.

But actually, k=100 can't be achieved with n=101 in this setup.

Hence, "NO"

Correct.

So, my approach seems to be working.

But I need to make sure that in no case does it require more than 60 stalls.

In the previous examples, it used only 1 or 2 stalls.

Let me consider a case where more stalls are needed.

Suppose n=1000, k=1000

- p=ceil(1000/1000)=1

- b=floor(1000/1)=1000

- remaining_n=0

- remaining_k=0

- Total stalls:1, with p=1

Again, works.

Another case: n=1000, k=500

- p=ceil(1000/500)=3

- b=floor(1000/3)=333

- remaining_n=1000 - 333*3=1000 -999=1

- remaining_k=500-333=167

- p=ceil(1/167)=1

- b=floor(1/1)=1

- remaining_n=0

- remaining_k=167-1=166

Since remaining_n=0 and remaining_k=166>0, impossible.

Hence, "NO"

Which is correct.

Wait, but maybe there is a better way to set up stalls to make it possible.

Let me think.

If I set p=2 for the first stall:

- b=floor(1000/2)=500

- remaining_n=0

- remaining_k=0

- Total stalls:1, with p=2

This would work.

But in my earlier approach, I set p=ceil(1000/500)=3, which led to remaining_k=166, which is impossible.

So, my earlier approach failed here.

Wait, perhaps I need to adjust my approach.

Let me see.

In this case, setting p=2 allows Alice to buy 500 jewels, which is exactly k.

So, my approach should consider that.

But in my earlier method, I set p=ceil(n / k), which is 3 in this case, leading to b=333, which is less than k.

Then, with remaining_n=1 and remaining_k=167, which is impossible.

Hence, my approach fails in this case.

But if I set p=2 manually, it works.

So, perhaps my approach needs modification.

Let me think differently.

Maybe instead of setting p=ceil(n / k), I should set p=floor(n / k)

Wait, floor(n / k) could be too low.

Let me see.

In the previous case, n=1000, k=500

- p=floor(1000 /500)=2

- b=floor(1000 /2)=500

- remaining_n=0

- remaining_k=0

- Total stalls:1, with p=2

This works.

So, perhaps setting p=floor(n / k) +1 - but wait, in this case, floor(1000 /500)=2, which works.

Wait, but in earlier cases, ceil(n /k) was used.

I need to find a consistent way to choose p.

Let me look up the formula for distributing k items into s groups with some constraints.

Alternatively, perhaps I can iterate and adjust p accordingly.

Wait, perhaps I can use the following approach:

While k >0 and n >0:

Set p = floor(n /k) if floor(n / floor(n /k)) >=k, else p = floor(n / ceil(k -1))

Wait, this is getting too complicated.

Let me look for a different strategy.

I recall that in the first example, they used multiple stalls to make Alice buy exactly 3 jewels.

Similarly, in the third example, they used multiple stalls to make Alice buy exactly 8 jewels.

Perhaps I can use a binary search approach, where each stall corresponds to a bit in the binary representation of k.

Wait, for example, in the third example, k=8, which is 1000 in binary, and they used 8 stalls with prices that are powers of 2.

But in the first example, k=3, which is 11 in binary, and they used 10 stalls with prices from 2 to 11.

This seems inconsistent.

Wait, perhaps I can set up stalls with prices that are powers of a certain base, like 2.

In the third example, they used prices that are powers of 2, decreasing.

Let me try this approach.

Set p1 = floor(n /k )

Wait, perhaps not.

Let me think differently.

Suppose I set up stalls with decreasing prices, starting from a high price and decreasing.

For example, in the first example, prices from 2 to 11.

Wait, but 2 to 11 are increasing, but in the third example, prices are powers of 2, decreasing.

Maybe I need to set prices in decreasing order.

Let me try with n=1000, k=500.

Set p1=2, then b1=500, remaining_n=0, remaining_k=0.

Works.

In the first example, n=7, k=3.

Set p1=2, b1=3, remaining_n=1, remaining_k=0.

Works.

In the second example, n=6, k=4.

Set p1=2, b1=3, remaining_n=0, remaining_k=1.

Cannot proceed, so "NO"

Seems consistent.

So, perhaps I can set p1 = floor(n /k ) ?

Wait, in n=1000, k=500, floor(n /k)=2, which works.

In n=7, k=3, floor(7/3)=2, p1=2, b1=3, remaining_n=1, remaining_k=0.

Works.

In n=6, k=4, floor(6/4)=1, p1=1, b1=6, remaining_n=0, remaining_k=-2.

Wait, remaining_k=4-6=-2, which is invalid.

Wait, but in reality, k=4, and b1=6>4, so I should set b1=4, then remaining_n=6-4*1=2, remaining_k=0.

Then, since remaining_k=0, it's okay.

But in the sample output, it's "NO"

So, there's inconsistency here.

Wait, perhaps I need to cap b1 to not exceed k.

So, in n=6, k=4, p1=1, b1=floor(6/1)=6, but set b1=4, remaining_n=6-4*1=2, remaining_k=0.

Then, I need to check if remaining_n is enough to make up the remaining_k, but here remaining_k=0, so it should be "YES"

But according to the sample, it's "NO"

So, perhaps I need to ensure that the sum of b_i's is exactly k, and that the remaining_n after all stalls is >=0.

But in this case, sum b_i=4, which is exactly k, and remaining_n=2>=0.

Why is the sample output "NO"?

Wait, perhaps because with p1=1, Alice buys 6 jewels, which is more than k=4.

But in my approach, I set b1=4, then remaining_n=2, remaining_k=0.

Is this acceptable?

Wait, according to the problem, Alice buys as many jewels as possible from each stall, in order.

So, if p1=1, Alice would buy 6 jewels from the first stall, and that's it.

She can't buy more from other stalls because she has no coins left.

So, total jewels bought:6, which is more than k=4.

Hence, it's invalid.

Therefore, my approach needs to ensure that the total jewels bought is exactly k, not more.

So, in this case, setting p1=1 is invalid because it makes Alice buy 6 jewels, which is more than k=4.

Hence, "NO"

Therefore, my earlier approach needs modification to ensure that the total jewels bought is exactly k.

Let me think again.

Perhaps I need to ensure that at each stall, the number of jewels bought doesn't exceed the remaining k.

So, when setting p_i, I need to make sure that b_i = min(floor(n_i / p_i), remaining_k)

But p_i needs to be set in such a way that the sum of b_i's is exactly k.

This seems recursive and might require backtracking, which is not efficient for large n and k.

Given the constraints (t<=1000, n and k up to 1e18), I need an efficient algorithm.

Let me consider that with s stalls, each with a price p_i, and Alice buying b_i = floor(n_i / p_i) jewels from each, the sum of b_i's should be exactly k.

Also, s <=60.

Given that s is at most 60, and n and k are up to 1e18, I need a way to distribute k jewels across up to 60 stalls.

Wait, perhaps I can represent k in binary, and set up stalls accordingly.

For example, in the third example, k=8, which is 1000 in binary, and they used 8 stalls with prices that are powers of 2.

Wait, but 8 in binary is 1000, which has only one '1' bit, but they used 8 stalls.

Wait, 128+64+32+16+8+4+2+1=255, which matches n=255.

So, in this case, each stall corresponds to a bit in the binary representation of n.

Wait, but n is 255, which is 11111111 in binary.

Each stall corresponds to a bit, with p_i=2^j.

This way, Alice buys one jewel from each stall, corresponding to each bit.

Hence, total jewels bought is 8, which matches k=8.

Similarly, in the first example, k=3, which is 11 in binary.

They used 10 stalls with prices from 2 to 11.

This seems inconsistent with the binary approach.

Wait, perhaps it's better to think in terms of the minimal number of stalls required.

But in the third example, they used 8 stalls, which is more than necessary, but still within the limit of 60.

Hence, it's acceptable.

So, perhaps I can always represent k as a sum of up to 60 numbers, each corresponding to a stall.

For example, set up s stalls with p_i=ceil(n / (k / s))

Wait, but this is too vague.

Let me think differently.

Suppose I set up s stalls with decreasing prices.

In each stall, Alice buys as many jewels as possible, up to the remaining k.

I need to make sure that the sum of jewels bought from all stalls is exactly k.

This seems similar to the way change is given in coins of different denominations.

But in this case, the prices are variable, and I need to set them appropriately.

Wait, perhaps I can set the prices such that each stall corresponds to a certain number of jewels that Alice will buy from it.

For example, set p1 such that Alice buys b1 jewels from it, p2 for b2, and so on.

But I need to determine the p_i's such that sum of b_i's is k.

This seems too vague.

Let me consider that for each stall, p_i >=1, and p_i <=1e18.

Also, s <=60.

Given that s is up to 60, and n and k are up to 1e18, I need an efficient way to set up the stalls.

Let me consider that in the worst case, k can be up to 1e18, and s is up to 60.

Hence, I need to distribute up to 1e18 jewels across up to 60 stalls.

This suggests that some stalls may have a large number of jewels bought from them.

Wait, perhaps I can set up stalls with prices that allow Alice to buy a certain number of jewels from each, such that the sum is k.

But I need a systematic way to do this.

Let me consider that in each stall, I can set p_i such that b_i = floor(n_i / p_i) is a desired number.

But determining p_i based on b_i and n_i is tricky because n_i depends on previous stalls.

An alternative approach: start with s=1, and try to set p1 such that floor(n / p1) =k.

If possible, output s=1 and p1.

Else, try s=2, and set p1 and p2 such that floor(n / p1) + floor(n - b1*p1 / p2) =k

This seems too recursive.

Perhaps I need to use the fact that floor(n / p) can be expressed in terms of p.

Wait, perhaps I can iterate and set p_i = ceil((remaining_n) / (remaining_k +1))

But I'm not sure.

Let me look for a different strategy.

I recall that in the first example, they used 10 stalls with prices from 2 to 11.

In this case, Alice buys 3 from the first stall and 0 from the rest.

In the third example, they used 8 stalls with prices that are powers of 2.

In this case, Alice buys one from each stall.

So, perhaps I can set up s stalls with prices p1, p2, ..., ps such that sum of floor(n_i / p_i) =k

But determining p_i's is tricky.

Wait, perhaps I can set p_i's in such a way that each p_i divides the remaining_n in a controlled manner.

This seems too vague.

Let me consider that for s=1, p1=ceil(n /k)

Then, b1=floor(n / p1)

If b1 ==k, then output s=1 and p1.

Else, proceed to s=2, and set p1 and p2 accordingly.

But determining p1 and p2 is not straightforward.

This seems too time-consuming for large n and k.

Given the time constraints, I need a more efficient approach.

Let me consider that if n >=k, it might be possible, else "NO"

But in the first example, n=7, k=3, n>=k, and it's possible.

In the second example, n=6, k=4, n>=k, but it's "NO"

Hence, n>=k is necessary but not sufficient.

So, I need a better condition.

Wait, perhaps I need to check if n >=k and there exists a way to distribute k jewels across up to 60 stalls.

But I need a better condition to determine if it's possible or not.

Let me think about the minimal number of stalls required.

Suppose I set up s stalls, each with p_i=1.

Then, Alice would buy b_i = floor(n_i /1)=n_i from each stall.

But this would lead to sum of b_i's =k, which might not be feasible.

Wait, perhaps not helpful.

Let me consider that the minimal number of stalls required is ceil(k / b_max)

Where b_max is the maximal number of jewels Alice can buy from a single stall.

But b_max can be up to floor(n /1)=n.

Hence, the minimal number of stalls is ceil(k /n)

Which is either 1 or more.

But in reality, it's more nuanced.

Wait, perhaps I can iterate and set p_i's in a way that minimizes the number of stalls.

But I need to ensure that the total number of stalls doesn't exceed 60.

Given the time constraints, perhaps I can implement the approach I thought earlier, with setting p_i=ceil(n / remaining_k), and b_i=floor(n_i / p_i), and proceed until remaining_k=0.

If the number of stalls exceeds 60, output "NO"

Else, output "YES" and the list of p_i's.

But in the earlier example where n=1000, k=500, using p1=ceil(1000/500)=3, leads to b1=333, remaining_n=1, remaining_k=167.

Then, p2=ceil(1/167)=1, b2=1, remaining_n=0, remaining_k=166.

Hence, "NO"

But setting p1=2 would allow b1=500, which is exactly k.

Hence, "YES" with s=1, p1=2.

So, perhaps I need to adjust the way I set p_i.

Instead of p_i=ceil(n / remaining_k), set p_i=floor(n / remaining_k)

But in the case where n=1000, k=500:

p1=floor(1000 /500)=2

b1=floor(1000 /2)=500

remaining_n=0

remaining_k=0

Which works.

In the case where n=1000, k=300:

p1=floor(1000 /300)=3

b1=floor(1000 /3)=333

But 333 >300, so set b1=300

remaining_n=1000 -300*3=1000-900=100

remaining_k=300-300=0

Hence, "YES" with s=1, p1=3

Wait, but in this case, Alice buys 300 jewels from the first stall, and remaining_k=0.

Hence, it's acceptable.

But in the earlier case with n=1000, k=500, setting p1=2 allows b1=500, which is exactly k.

Hence, "YES" with s=1, p1=2

So, perhaps setting p1=floor(n /k) works.

But in the case where n=7, k=3:

p1=floor(7 /3)=2

b1=floor(7 /2)=3

remaining_n=7 -3*2=1

remaining_k=3-3=0

Hence, "YES" with s=1, p1=2

Which matches the first example.

Another case: n=6, k=4

p1=floor(6 /4)=1

b1=floor(6 /1)=6

But 6 >4, so set b1=4

remaining_n=6 -4*1=2

