Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in the given array. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the array. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once. I need to find which number goes in each position based on the a array.

Maybe I can try to build p step by step, from p_1 to p_n, using the information from a.

Let's consider the first element, p_1. The MEX of p_1 alone is the smallest non-negative integer not equal to p_1. Since p_1 is from 0 to n-1, the MEX would be 0 if p_1 is not 0, or 1 if p_1 is 0.

Wait, no. If p_1 is 0, then MEX of [0] is 1, because 0 is present. So a_1 = 1 - p_1. If p_1 is 0, a_1 = 1 - 0 = 1.

If p_1 is 1, MEX of [1] is 0, so a_1 = 0 - 1 = -1.

If p_1 is 2, MEX of [2] is 0, so a_1 = 0 - 2 = -2.

So in general, for p_1, a_1 = MEX([p_1]) - p_1.

I need to find p_1 such that MEX([p_1]) - p_1 = a_1.

Let me try to express p_1 in terms of a_1.

If p_1 = k, then MEX([k]) = the smallest non-negative integer not equal to k.

If k = 0, MEX([0]) = 1.

If k = 1, MEX([1]) = 0.

If k = 2, MEX([2]) = 0.

Wait, actually, for k >=1, MEX([k]) is always 0, because 0 is not in the array unless k=0.

Wait, no. For k=0, MEX([0]) is 1, because 0 is present, so the smallest non-present is 1.

For k=1, MEX([1]) is 0, because 0 is not present.

For k=2, MEX([2]) is 0.

So, in general, MEX([k]) = 1 if k=0, else 0.

Therefore, a_1 = 1 - k if k=0, else 0 - k.

So a_1 = 1 - k if k=0, else -k.

So, if a_1 = 1, then k=0.

If a_1 = -1, then k=1.

If a_1 = -2, then k=2.

And so on.

So, p_1 can be determined directly from a_1.

In general, p_1 = 1 - a_1 if a_1 < 0, else 1 - a_1.

Wait, let's think again.

If a_1 = 1 - p_1, then p_1 = 1 - a_1.

Wait, yes.

So, p_1 = 1 - a_1.

Let me check with the example.

In the first test case, a = [1,1,-2,1,2]

So p_1 = 1 - 1 = 0.

Which matches the sample output p = [0,1,4,2,3]

Okay, that makes sense.

Now, for p_2.

a_2 = MEX(p_1, p_2) - p_2.

I need to find p_2 such that MEX(p_1, p_2) - p_2 = a_2.

I already know p_1, and I need to find p_2.

Let me think about what MEX(p_1, p_2) is.

MEX is the smallest non-negative integer not in {p_1, p_2}.

So, depending on what p_1 and p_2 are, MEX can be 0, 1, or higher.

Wait, in the first test case, p_1=0, p_2=1, so MEX(0,1)=2.

Wait, no, MEX(0,1) is 2 only if 2 is not in the array, but 2 is not in the array yet.

Wait, MEX is the smallest non-negative integer not in the array.

So MEX(0,1)=2, because 0 and 1 are present.

But in the sample, a_2=1, so 2 - p_2 =1, so p_2=1.

Yes, that matches.

Another example, third test case, a= [-2,1,2]

n=3

So p=[2,0,1]

a_1=-2, so p_1=1-(-2)=3, but n=3, so p_1=2.

Because in the sample output, p=[2,0,1]

Wait, n=3, p_1=2.

a_1=-2.

So MEX(2)=1, because 0 and 1 are missing, but the smallest is 0.

Wait, no.

Wait, for p=[2,0,1], MEX(2)=0, because 0 is the smallest missing.

So a_1=0 - 2 = -2, which matches.

Then p_2=0.

MEX(2,0)=1, which is not present, so a_2=1 - 0=1, which matches.

Then p_3=1.

MEX(2,0,1)=3, since 0,1,2 are present, so 3 is missing.

a_3=3 -1=2, which matches.

So, the formula seems consistent.

So, in general, a_i = MEX(p_1 to p_i) - p_i.

I need to find p_i = MEX(p_1 to p_i) - a_i.

Wait, from a_i = MEX - p_i, so p_i = MEX - a_i.

So, if I can find MEX for each i, then p_i = MEX - a_i.

But MEX depends on p_1 to p_i, which are unknowns.

So, perhaps I need to find MEX iteratively.

Let me think about the process.

I need to build p step by step.

At each step i, I need to choose p_i such that a_i = MEX(p_1 to p_i) - p_i.

Given that p is a permutation, each p_i must be unique and in 0 to n-1.

Also, since p is a permutation, all p_i are distinct.

So, as I build p, I have to ensure that p_i is not in the previous p's.

Let me try to devise an algorithm.

Initialize an empty list for p.

For each i from 1 to n:

- Determine MEX of p_1 to p_{i-1}.

- Use a_i = MEX(p_1 to p_i) - p_i.

- But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

- I need to find p_i such that MEX(p_1 to p_i) - p_i = a_i.

- So, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) depends on p_i, which is unknown.

This seems circular.

Maybe I need to find MEX(p_1 to p_{i-1}) first, and then determine p_i based on that.

Wait, MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

So, MEX(p_1 to p_i) is either MEX(p_1 to p_{i-1}) if p_i != MEX(p_1 to p_{i-1}), else MEX(p_1 to p_{i-1}) + 1.

This seems complicated.

Let me consider another approach.

Since p is a permutation, and I need to assign each p_i such that it's unique and satisfies the a_i condition.

Maybe I can keep track of the numbers used so far, and the MEX can be determined based on the unused numbers.

Wait, perhaps I can maintain a set of used numbers, and find the MEX as the smallest non-used number.

Let me try to outline the steps:

- Initialize an empty list for p.

- Initialize a set to keep track of used numbers.

- For each i from 1 to n:

- Determine MEX of p_1 to p_i, which is the smallest non-negative integer not in p_1 to p_i.

- But p_i is unknown.

- From a_i = MEX(p_1 to p_i) - p_i, so p_i = MEX(p_1 to p_i) - a_i.

- To find p_i, I need to know MEX(p_1 to p_i), which depends on p_i.

This seems tricky.

Maybe I need to consider that MEX(p_1 to p_i) is either MEX(p_1 to p_{i-1}) if p_i != MEX(p_1 to p_{i-1}), else MEX(p_1 to p_{i-1}) + 1.

Let me denote MEX(p_1 to p_{i-1}) as mex_{i-1}.

Then, MEX(p_1 to p_i) is mex_{i-1} if p_i != mex_{i-1}, else mex_{i-1} + 1.

So, in this case, a_i = MEX(p_1 to p_i) - p_i.

So, if p_i != mex_{i-1}, then a_i = mex_{i-1} - p_i.

Else, a_i = mex_{i-1} + 1 - p_i.

So, for each i, there are two possibilities:

1. p_i != mex_{i-1}: a_i = mex_{i-1} - p_i.

2. p_i == mex_{i-1}: a_i = mex_{i-1} + 1 - p_i.

So, I can solve for p_i in both cases and see which one makes sense.

Let's solve for p_i:

Case 1: p_i != mex_{i-1}

p_i = mex_{i-1} - a_i.

Case 2: p_i == mex_{i-1}

p_i = mex_{i-1} + 1 - a_i.

But p_i must be equal to mex_{i-1} in this case.

So, p_i = mex_{i-1}.

Therefore, in case 2, p_i = mex_{i-1}.

So, I can check if p_i = mex_{i-1} leads to a_i = mex_{i-1} + 1 - p_i.

Substituting p_i = mex_{i-1}, a_i should be mex_{i-1} + 1 - mex_{i-1} = 1.

So, if a_i == 1, then p_i = mex_{i-1}.

Otherwise, p_i = mex_{i-1} - a_i.

Wait, is that correct?

Let me verify with the sample input.

First test case:

n=5

a=[1,1,-2,1,2]

Let's build p step by step.

Initialize p=[], used=set()

i=1:

mex_0 = 0 (since no elements)

if a_1 == 1, then p_1 = mex_0 = 0.

Else, p_1 = mex_0 - a_1 = 0 - 1 = -1, which is invalid.

But a_1=1, so p_1=0.

Which matches the sample.

Then, used={0}

i=2:

mex_1 = smallest not in {0}, which is 1.

a_2=1.

Since a_2 ==1, p_2 = mex_1 =1.

Which matches the sample.

used={0,1}

i=3:

mex_2 = smallest not in {0,1}, which is 2.

a_3=-2.

Since a_3 !=1, p_3 = mex_2 - a_3 =2 - (-2)=4.

Which matches the sample.

used={0,1,4}

i=4:

mex_3 = smallest not in {0,1,4}, which is 2.

a_4=1.

Since a_4 ==1, p_4= mex_3=2.

Which matches the sample.

used={0,1,4,2}

i=5:

mex_4 = smallest not in {0,1,4,2}, which is 3.

a_5=2.

Since a_5 !=1, p_5= mex_4 - a_5=3-2=1.

Wait, but p_5=3-2=1, but in the sample, p_5=3.

Wait, that doesn't match.

Wait, in the sample, p_5=3.

But according to this, p_5=1.

Wait, that's a discrepancy.

Wait, no, in the sample, p=[0,1,4,2,3], a=[1,1,-2,1,2]

Let's verify a_5:

MEX(p_1 to p_5) = MEX([0,1,4,2,3])=5, since 0,1,2,3,4 are present.

So a_5=5 - p_5=5-3=2, which matches the sample.

Wait, but according to my earlier logic, for i=5:

mex_4=3 (since {0,1,4,2} missing 3)

a_5=2.

Since a_5 !=1, p_5= mex_4 - a_5=3-2=1.

But in the sample, p_5=3.

Which suggests that p_5=3 satisfies a_5=5-3=2.

But according to my earlier logic, p_5 should be 1, but in the sample, it's 3.

Wait, there's a mistake here.

Wait, MEX of [0,1,4,2,3] is 5, because 0,1,2,3,4 are present, so 5 is missing.

So a_5=5 - p_5=2 => p_5=5-2=3, which matches the sample.

So, in this case, a_i = MEX(p_1 to p_i) - p_i.

So p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

Wait, in the earlier step, for i=3:

p_1=0, p_2=1, p_3=4.

So, p_1 to p_3={0,1,4}.

MEX=2.

a_3=2 - p_3=2-4=-2, which matches.

Then, for i=4:

p_1 to p_4={0,1,4,2}.

MEX=3.

a_4=3 - p_4=3-2=1, which matches.

For i=5:

p_1 to p_5={0,1,4,2,3}.

MEX=5.

a_5=5 - p_5=5-3=2, which matches.

So, in general, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

I need to find p_i such that p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) depends on p_i.

This seems tricky.

Wait, perhaps I can iterate through the array and keep track of the used numbers and the current MEX.

Let me try to think differently.

Initialize p as an empty list.

Initialize a set used to keep track of used numbers.

Initialize mex as 0.

For each i from 1 to n:

while mex in used:

mex +=1

# Now, mex is the MEX of p_1 to p_i, because p_i is not yet added.

# From a_i = mex - p_i, so p_i = mex - a_i.

p_i = mex - a_i

# Ensure p_i is not already used.

if p_i in used or p_i <0:

# This should not happen, as per the problem, but need to handle.

# Since the input is guaranteed to be valid, this shouldn't occur.

# For now, assume it's valid.

used.add(p_i)

p.append(p_i)

This seems straightforward.

Let me test this logic with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize p=[], used={}, mex=0

i=1:

mex=0

p_1=0 -1= -1, but p_i must be >=0 and unique.

Wait, p_i=0 -1=-1, which is invalid.

Wait, that can't be right.

Wait, in the sample, p_1=0, which is valid.

Wait, according to the formula p_i=mex - a_i.

mex=0, a_1=1, so p_1=0 -1=-1, which is invalid.

But in the sample, p_1=0.

So, perhaps my approach is wrong.

Wait, perhaps I need to adjust how I calculate mex.

Wait, maybe I need to consider that mex changes based on p_i.

Wait, perhaps another way.

Let me look back at the relationship.

a_i = mex(p_1 to p_i) - p_i.

So, p_i = mex(p_1 to p_i) - a_i.

But mex(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

If I choose p_i = mex(p_1 to p_i) - a_i, I need to ensure that p_i is unique and non-negative.

But in the first step, this leads to p_1=0-1=-1, which is invalid.

So, perhaps I need to consider that when p_i = mex(p_1 to p_i), then a_i=1.

Wait, in the first test case, a_1=1, which corresponds to p_1=0, since mex([0])=1, and 1 -0=1.

Similarly, a_2=1, p_2=1, mex([0,1])=2, 2-1=1.

So, in cases where a_i=1, p_i=mex(p_1 to p_{i-1}).

Wait, in the first step, p_1=0, mex([])=0, p_1=0=0 -1, which is invalid.

Wait, maybe I need to consider that mex(p_1 to p_i) is mex(p_1 to p_{i-1}) if p_i != mex(p_1 to p_{i-1}), else mex(p_1 to p_{i-1}) +1.

Let me denote mex_i = mex(p_1 to p_i)

mex_i = mex(p_1 to p_{i-1}) if p_i != mex(p_1 to p_{i-1}), else mex(p_1 to p_{i-1}) +1.

So, a_i = mex_i - p_i.

So, p_i = mex_i - a_i.

But mex_i depends on p_i.

This is circular.

Let me try to express mex_i in terms of mex_{i-1}.

Let mex_{i-1} = mex(p_1 to p_{i-1}).

If p_i != mex_{i-1}, then mex_i = mex_{i-1}.

Else, mex_i = mex_{i-1} +1.

So, a_i = mex_i - p_i.

So, p_i = mex_i - a_i.

But p_i could be equal to mex_{i-1} or not.

So, let's consider both cases.

Case 1: p_i != mex_{i-1}.

Then, mex_i = mex_{i-1}.

So, a_i = mex_{i-1} - p_i.

Hence, p_i = mex_{i-1} - a_i.

Case 2: p_i == mex_{i-1}.

Then, mex_i = mex_{i-1} +1.

So, a_i = mex_{i-1} +1 - p_i.

But since p_i = mex_{i-1}, a_i = mex_{i-1} +1 - mex_{i-1} =1.

So, if a_i ==1, then p_i = mex_{i-1}.

Else, p_i = mex_{i-1} - a_i.

This seems to be the way to go.

So, for each i, if a_i ==1, then p_i = mex_{i-1}.

Else, p_i = mex_{i-1} - a_i.

And mex_i = mex_{i-1} if p_i != mex_{i-1}, else mex_{i-1} +1.

But since in case 2, p_i == mex_{i-1}, mex_i = mex_{i-1} +1.

In case 1, p_i != mex_{i-1}, mex_i = mex_{i-1}.

Wait, but in case 1, p_i = mex_{i-1} - a_i, which may or may not be equal to mex_{i-1}.

Wait, no, in case 1, p_i != mex_{i-1}, so mex_i = mex_{i-1}.

So, in this approach, I can keep track of mex_{i-1}, and based on a_i, determine p_i.

Let me try this with the first test case.

n=5

a=[1,1,-2,1,2]

Initialize p=[], used={}

mex_0=0

i=1:

a_1=1

Since a_1 ==1, p_1 = mex_0 =0.

used={0}

mex_1 = mex_0 +1 =1, because p_1 == mex_0.

i=2:

mex_1=1

a_2=1

Since a_2 ==1, p_2 = mex_1 =1.

used={0,1}

mex_2 = mex_1 +1 =2, because p_2 == mex_1.

i=3:

mex_2=2

a_3=-2

Since a_3 !=1, p_3 = mex_2 - a_3 =2 - (-2)=4.

used={0,1,4}

mex_3 = mex_2, because p_3 != mex_2.

i=4:

mex_3=2

a_4=1

Since a_4 ==1, p_4 = mex_3 =2.

used={0,1,4,2}

mex_4 = mex_3 +1=3, because p_4 == mex_3.

i=5:

mex_4=3

a_5=2

Since a_5 !=1, p_5 = mex_4 - a_5=3 -2=1.

But 1 is already in used. Wait, but in the sample, p_5=3.

Wait, there's a problem here.

In this step, p_5=3-2=1, but 1 is already used.

Wait, in the sample, p_5=3, which is not yet used.

So, according to my logic, p_5=1, but 1 is already used.

This suggests that my logic is flawed.

Wait, perhaps I need to ensure that p_i is not already used.

If p_i is already used, then I need to