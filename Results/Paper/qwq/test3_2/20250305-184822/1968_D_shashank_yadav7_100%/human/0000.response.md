Alright, I have this problem to solve. It's about a game played by Bodya and Sasha on a permutation and an array. They make moves simultaneously over k turns, and at each turn, they can choose to stay or move to another position based on the permutation. The goal is to see who ends up with a higher score after k turns.

First, I need to understand the problem completely. We have a permutation p of length n, and an array a of length n. Both players start at specific positions, P_B for Bodya and P_S for Sasha. They play k turns, and in each turn, both players simultaneously:

1. Add a_x to their score, where x is their current position.

2. Choose to either stay at their current position or move to p_x.

The winner is the one with the higher score after k turns. If scores are equal, it's a draw.

I need to process multiple test cases, up to 10^4, but the sum of n across all test cases is up to 2*10^5, which suggests that the per-testcase time complexity should be reasonably low, probably O(n) or O(n log n).

Looking at the example, it seems that the players can make choices independently at each turn, but since they make moves simultaneously, their choices don't affect each other directly. Each player tries to maximize their own score.

The key here is that both players are trying to win, which means they are trying to maximize their own scores. Since they make decisions independently, I can consider each player separately and calculate their maximum possible score after k turns.

So, for each player, starting from their initial position, at each turn, they can choose to stay or move to p_x. They want to choose the option that maximizes their score.

This sounds like a dynamic programming problem, where for each player, I need to keep track of their position and the number of turns left, and decide whether to stay or move.

However, since n can be up to 2*10^5 and k up to 10^9, a standard DP approach with O(n*k) time complexity won't work because it would be too slow.

I need a smarter way to compute the maximum score for each player without iterating over each turn individually.

Let me think about the permutation p. Since p is a permutation, it forms cycles. If I can find the cycles in p, I can analyze the behavior within each cycle.

For example, if a player is in a cycle of length m, then after m turns, they return to their starting position. So, their movement is periodic with period m.

Given that k can be up to 10^9, I need to find a way to compute the maximum score efficiently, possibly by exploiting the cyclic structure of p.

But this seems complicated. Maybe there's a simpler way.

Looking at the code provided, it seems to attempt a different approach.

In the code:

- It reads t, the number of test cases.

- For each test case, it reads n (length of permutation), k (number of turns), P_B (Bodya's starting position), P_S (Sasha's starting position).

- Then reads the permutation p and the array a.

- It initializes sp (Sasha's score) and bp (Bodya's score) with their starting position values.

- It also initializes bm (Bodya's maximum possible score) and sm (Sasha's maximum possible score) with k times their starting position's a value.

- Then, it enters a loop that runs up to n times:

- Decreases k by 1.

- If k == 0, breaks.

- Updates b and s to p[b] -1 and p[s] -1 (next positions).

- Updates bm and sm with the maximum of their current value and a[b]*k + bp or a[s]*k + sp.

- Adds a[b] to bp and a[s] to sp.

- After the loop, compares bm and sm to decide who wins.

I need to verify if this approach is correct.

First, let's understand what the code is trying to do.

It seems to simulate up to n steps, but not necessarily all k steps, because k can be up to 10^9, which is too large to simulate directly.

The idea might be that in a permutation, the sequence of positions each player visits will eventually cycle, and the cycle length is at most n. So, by simulating up to n steps, it can find the optimal score.

But I need to verify if this logic holds.

Let's consider that each player can choose to stay or move at each turn. The choice affects their score for that turn and their position for the next turn.

The code seems to consider two options for each player:

1. Stay at the current position for all remaining turns, adding a_x * k to the score.

2. Move to p_x and then make decisions for the remaining k-1 turns.

But in the code, it seems to accumulate sp and bp with a[s] and a[b] at each step, and update bm and sm accordingly.

I need to see if this correctly computes the maximum possible score for each player.

Let me consider a simple example.

Suppose n=1, k=1, P_B=1, P_S=1, p=[1], a=[10].

In this case, both players are at position 1, and they can choose to stay or move to p[1]=1.

So, their score would be a[1]=10.

So, both have the same score, it's a draw.

In the code, it would set sp=10, bp=10, bm=10, sm=10.

Then, k=1-1=0, so it breaks the loop and prints 'Draw', which is correct.

Another example:

n=2, k=2, P_B=1, P_S=2, p=[2,1], a=[1,2].

Player B starts at 1, can choose to stay or move to p[1]=2.

If they stay, they get a[1]=1 for both turns: total 2.

If they move to 2, they get a[2]=2 for both turns: total 4.

Similarly, player S starts at 2, can choose to stay or move to p[2]=1.

If they stay, they get 2 for both turns: total 4.

If they move to 1, they get 1 for both turns: total 2.

So, the maximum for both is 4, it's a draw.

In the code, it would set sp=2, bp=1, bm=2*2=4, sm=2*2=4.

Then, k=2-1=1, not zero, so continues.

Updates b=p[0]-1=1-1=0, s=p[1]-1=1-1=0.

bp += a[0]=1, so bp=1+1=2.

sp += a[0]=1, so sp=2+1=3.

Then, bm = max(4, a[0]*1 + 2) = max(4, 1*1 + 2) = max(4, 3) = 4.

sm = max(4, a[0]*1 + 3) = max(4, 1*1 + 3) = max(4, 4) = 4.

Then, k=1-1=0, breaks.

Prints 'Draw', which is correct.

Seems okay so far.

Another example:

n=3, k=3, P_B=1, P_S=1, p=[2,3,1], a=[1,2,3].

Player B starts at 1, can choose to stay or move to p[1]=2.

If stays both times: 1+1+1=3.

If moves to 2, then can stay or move to p[2]=3.

If moves to 2 and stays: 1 (first turn) + a[2]=2 + a[2]=2: total 5.

If moves to 2, then moves to 3: 1 (first turn) + a[2]=2 + a[3]=3: total 6.

If moves to 2, then moves to 3, and then stays: same as above.

So, maximum is 6.

Similarly, player S starts at 1, same options, maximum score 6.

So, it's a draw.

In the code:

Set sp=1, bp=1, bm=1*3=3, sm=1*3=3.

k=3-1=2, not zero.

Update b=p[0]-1=1-1=0, s=p[0]-1=1-1=0.

bp += a[0]=1, so bp=1+1=2.

sp += a[0]=1, so sp=1+1=2.

bm = max(3, a[0]*2 + 2)=max(3,1*2+2)=max(3,4)=4.

sm = max(3, a[0]*2 + 2)=max(3,1*2+2)=max(3,4)=4.

k=2-1=1, not zero.

Update b=p[0]-1=1-1=0, s=p[0]-1=1-1=0.

bp += a[0]=1, so bp=2+1=3.

sp += a[0]=1, so sp=2+1=3.

bm = max(4, a[0]*1 + 3)=max(4,1*1+3)=max(4,4)=4.

sm = max(4, a[0]*1 + 3)=max(4,1*1+3)=max(4,4)=4.

k=1-1=0, break.

Prints 'Draw', but actual maximum is 6.

Wait, this seems incorrect.

In this case, the code outputs 'Draw' with scores 4, but the actual maximum is 6.

So, the code is wrong.

Wait, maybe I misunderstood the code.

Looking back, in the loop, it updates bm and sm with the maximum of their current value and a[b]*k + bp or a[s]*k + sp.

In the first iteration, k=3-1=2.

b=p[0]-1=1-1=0, s=p[0]-1=1-1=0.

bp += a[0]=1, bp=1+1=2.

sp += a[0]=1, sp=1+1=2.

Then, bm = max(3, a[0]*2 + 1)=max(3,1*2+1)=max(3,3)=3.

sm = max(3, a[0]*2 + 1)=max(3,1*2+1)=max(3,3)=3.

Wait, in my earlier reasoning, I had bm and sm initialized to a[b]*k =1*3=3 and a[s]*k=1*3=3.

But in the loop, it's updating bm and sm to the maximum of their current value and a[b]*k + bp or a[s]*k + sp.

Wait, in the first iteration, k=2, b=0, s=0.

a[b]*k + bp = a[0]*2 + bp =1*2 +1=3.

But bp is updated to 1+1=2, so it's 1*2 +1=3.

Wait, perhaps I'm getting confused.

Wait, in the code:

bm = max(bm, a[b]*k + bp)

sm = max(sm, a[s]*k + sp)

But bp and sp are accumulated scores if they stay at their current positions for all remaining turns.

Wait, perhaps I need to trace the code more carefully.

Initialize:

sp = a[s] =1

bp = a[b] =1

sm = a[s]*k =1*3=3

bm = a[b]*k =1*3=3

First loop:

k -=1 => k=2

if k==0: no

b = p[b]-1 =p[0]-1=1-1=0

s = p[s]-1 =p[0]-1=1-1=0

bp += a[b] => bp=1 + a[0]=1+1=2

sp += a[s] => sp=1 + a[0]=1+1=2

bm = max(bm, a[b]*k + bp) = max(3, a[0]*2 +2)=max(3,1*2+2)=max(3,4)=4

sm = max(sm, a[s]*k + sp) = max(3, a[0]*2 +2)=max(3,1*2+2)=max(3,4)=4

Second loop:

k -=1 =>k=1

if k==0: yes, break

So, bm=4, sm=4

Print 'Draw'

But in reality, both players can achieve a score of 6.

So, the code is incorrect in this case.

Another example from the problem statement:

n=4, k=2, P_B=3, P_S=2, p=[4,1,2,3], a=[7,2,5,6]

Let's see what the optimal scores are.

Player B starts at 3.

Option 1: stay at 3 for both turns: 5 + 5 =10

Option 2: move to p[3]=3, so stay at 3: same as above.

Option 3: move to p[3]=3 on first turn, then stay: same.

So, maximum is 10.

Player S starts at 2.

Option 1: stay at 2 for both turns: a[2]=2 +2=4

Option 2: move to p[2]=1 on first turn, then:

- If stays at 1 on second turn: a[2]=2 + a[1]=10 =12

- If moves to p[1]=4 on second turn: a[2]=2 + a[4]=6=8

Option 3: move to p[2]=1 on first turn, then move to p[1]=4 on second turn: a[2]=2 + a[4]=6=8

So, maximum is 12.

Therefore, Sasha wins with 12 > Bodya's 10.

In the code:

Set sp=a[1]=2, bp=a[2]=5, sm=2*2=4, bm=5*2=10

First loop:

k=2-1=1

b=p[2]-1=p[2]=2-1=1

s=p[1]-1=p[1]=1-1=0

bp += a[1]=10, bp=5+10=15

sp += a[0]=7, sp=2+7=9

bm = max(10, a[1]*1 +15)=max(10,10*1 +15)=max(10,25)=25

sm = max(4, a[0]*1 +9)=max(4,7*1 +9)=max(4,16)=16

k=1-1=0, break

So, bm=25, sm=16

But in reality, Bodya's maximum is 10, Sasha's is 12.

Wait, this is different.

Wait, perhaps I made a mistake in calculating bp and sm.

Wait, a[1]=10? In the input, a=[7,2,5,6], so a[0]=7, a[1]=2, a[2]=5, a[3]=6.

Wait, p=[4,1,2,3], which is [4,1,2,3], so p[0]=4, p[1]=1, p[2]=2, p[3]=3.

Indices are 0-based, so p[2]-1=2-1=1, p[1]-1=1-1=0.

a[0]=7, a[1]=2, a[2]=5, a[3]=6.

So, bp = a[2]=5

sm = a[1]*k =2*2=4

First loop:

k=2-1=1

b=p[2]-1=2-1=1

s=p[1]-1=1-1=0

bp += a[1]=2, bp=5+2=7

sp += a[0]=7, sp=2+7=9

bm = max(10, a[1]*1 +7)=max(10,2*1 +7)=max(10,9)=10

sm = max(4, a[0]*1 +9)=max(4,7*1 +9)=max(4,16)=16

k=1-1=0, break

So, bm=10, sm=16

But according to my earlier calculation, Sasha can get 12, but sm=16 is higher than that.

Wait, perhaps the code is incorrect.

Wait, in the code, bm and sm seem to be calculated incorrectly.

Wait, maybe I need to understand the logic behind bm and sm.

bm is supposed to be the maximum score Bodya can get, and sm for Sasha.

But in the first iteration, bm is set to max of its current value and a[b]*k + bp.

What does a[b]*k + bp represent?

a[b] is the score if Bodya stays at position b for all remaining k turns: a[b]*k.

bp is the score Bodya has accumulated so far.

Wait, no, bp seems to be the score if Bodya stays at the current position for all remaining turns.

Wait, I'm getting confused.

Let me try to re-express the variables.

Perhaps, bp is the score if Bodya stays at the current position for all remaining turns.

sp similarly for Sasha.

Then, bm and sm are the maximum scores they can achieve.

In each iteration, they consider moving to p_x and then staying for the remaining k-1 turns, which would give a[b]*(k-1) + a[b] (since they move to p_x and then stay).

Wait, this is not clear.

I think the code has a mistake in how it calculates bm and sm.

In the first test case, according to the code, bm=10, sm=16, which suggests Bodya has 10 and Sasha has 16, so Sasha wins.

But according to the problem's example, Bodya has 10 and Sasha has 9, so Bodya wins.

Wait, in the problem's example, k=2, P_B=3, P_S=2, p=[4,1,2,3], a=[7,2,5,6].

From the problem's explanation:

Turn 1:

- Bodya stays at 3: score +=5, total=5

- Sasha moves to p[2]=2, score +=2, total=2

Turn 2:

- Bodya stays at 3: score +=5, total=10

- Sasha stays at 2: score +=5, total=7

So, Bodya:10, Sasha:7, Bodya wins.

But according to the code, sm=16, which is higher than bm=10, so it would print "Sasha", which is incorrect.

Hence, the code is wrong.

Therefore, the answer is:

Correctness: **False**

