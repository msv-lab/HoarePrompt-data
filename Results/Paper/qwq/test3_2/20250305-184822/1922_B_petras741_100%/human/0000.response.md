Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length that's 2 raised to the power of some a_i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which implies that the sum of any two sides must be greater than the third side. Makes sense.

So, the task is to count the number of ways to choose such triples of sticks that satisfy the triangle inequality.

First, I need to understand the input and output format. There are multiple test cases, starting with t, the number of test cases. For each test case, there's n, the number of sticks, followed by a list of a_i's, where each a_i corresponds to the exponent in the length of the stick, which is 2^{a_i}.

Constraints:

- t is up to 10^4

- n is up to 3*10^5 per test case, but the total sum of n over all test cases doesn't exceed 3*10^5.

So, it's acceptable to have an O(n^2) solution per test case, but considering t can be up to 10^4, and n can be up to 3*10^5, I need to make sure that the overall time complexity is acceptable. Given that the sum of n over all test cases is 3*10^5, it's crucial to optimize the solution.

Now, thinking about the properties of the sticks' lengths. Since lengths are of the form 2^{a_i}, they are all positive and distinct for different a_i's because 2^x is strictly increasing.

Wait, no, they're not necessarily distinct because multiple sticks can have the same a_i, meaning multiple sticks can have the same length.

Wait, but the problem says "the length of the i-th stick is 2^{a_i}", and a_i can be the same for different sticks, so yes, there can be multiple sticks with the same length.

But in terms of forming a triangle, the lengths are 2^{a_i}, and I need to choose three sticks such that the sum of any two is greater than the third.

Given that 2^{a_i} are powers of two, which are distinct for different exponents, but multiple sticks can have the same exponent, hence the same length.

I need to count the number of unique triples (i,j,k) where i < j < k, and the lengths satisfy the triangle inequality.

Wait, but the problem says "the order of choosing sticks does not matter", and "choosing the 1st, 2nd, and 4th stick is the same as choosing the 2nd, 4th, and 1st stick". So, it's combinations, not permutations.

So, I need to count the number of combinations of 3 sticks that can form a triangle.

Given that, I need an efficient way to count these combinations.

First, a brute-force approach would be to iterate through all possible combinations of three sticks and check the triangle inequality for each, but that would be O(n^3), which is too slow given n can be up to 3*10^5.

So, I need a smarter approach.

Let's recall that for three lengths to form a triangle, the sum of any two must be greater than the third. In other words, if I have sides a, b, c, with a <= b <= c, then a + b > c is the necessary and sufficient condition.

Given that, perhaps I can sort the lengths and then use two pointers or some other optimization to count the valid triples efficiently.

But since n can be up to 3*10^5, I need an O(n^2) or better solution.

Wait, but sorting n elements where n is 3*10^5 is acceptable, as sorting can be done in n log n time, which should be fine.

But perhaps there's a better way, considering that the lengths are powers of two, which have special properties.

Let me think about the properties of powers of two.

Powers of two are 1, 2, 4, 8, 16, and so on. Each power is double the previous one.

Given that, 2^{k} = 2 * 2^{k-1}, which means each length is double the previous length.

This has interesting implications for the triangle inequality.

Suppose I have three lengths: 2^a, 2^b, 2^c, with a <= b <= c.

Then, the triangle inequality requires 2^a + 2^b > 2^c.

Given that 2^a + 2^b is equal to 2^b + 2^a, and since a <= b < c, we can analyze when 2^a + 2^b > 2^c.

But given that 2^c is at least 2^b * 2, because c > b.

Wait, 2^c >= 2^{b+1} = 2 * 2^b.

So, 2^a + 2^b <= 2^b + 2^b = 2 * 2^b = 2^{b+1}.

Comparing this to 2^c, which is at least 2^{b+1}, so 2^a + 2^b <= 2^{b+1} <= 2^c.

Wait, but for the triangle inequality, we need 2^a + 2^b > 2^c.

But from above, 2^a + 2^b <= 2^c, which suggests that no such triangle can be formed.

Wait, but that contradicts the example given in the problem.

In the first test case, where all a_i are 1, so all stick lengths are 2^1 = 2.

So, choosing any three sticks, all of length 2, satisfies 2 + 2 > 2, which is true.

So, in this case, triangles can be formed.

But according to my earlier reasoning, 2^a + 2^b <= 2^c, which would suggest no triangles can be formed.

What's the issue here?

Ah, I see. In my earlier reasoning, I assumed that c > b, but in the case where all sticks have the same length, a = b = c.

Wait, but in the triangle inequality, we have a <= b <= c, and c < a + b.

In the case where a = b = c, then c = a + b is 2a, which is greater than c, so it works.

But in the general case where a < b < c, and 2^c >= 2^{b+1}, while 2^a + 2^b <= 2^{b+1}, which may or may not be greater than 2^c.

Wait, no, 2^c >= 2^{b+1}, and 2^a + 2^b <= 2^{b+1}, so 2^a + 2^b <= 2^{b+1} <= 2^c, which would imply 2^a + 2^b <= 2^c, which is not strictly greater than 2^c.

Unless 2^a + 2^b = 2^c, but in that case, it's equal, not greater.

So, in general, for a < b < c, 2^a + 2^b <= 2^c, with equality only when a = c - 1 and b = c - 1.

Wait, let's think about specific examples.

Suppose a = 1, b = 2, c = 3.

Then, 2^1 + 2^2 = 2 + 4 = 6, which is greater than 8 (2^3). No, 6 < 8.

Wait, no, 6 < 8.

Another example: a = 2, b = 3, c = 4.

2^2 + 2^3 = 4 + 8 = 12 > 16 (2^4)? No, 12 < 16.

Wait, no, 12 < 16.

Wait, actually, 2^a + 2^b = 2^b + 2^a <= 2^{b+1}, and 2^c >= 2^{b+1}, so 2^a + 2^b <= 2^c.

Hence, for a < b < c, 2^a + 2^b <= 2^c, with equality only when b = c - 1 and a = c - 1, but a <= b, so a = b = c - 1.

Wait, but if a < b < c, and b = c - 1, a = c - 1, then a = b, which contradicts a < b.

Hence, for a < b < c, 2^a + 2^b < 2^c.

Therefore, in this case, no triangle can be formed.

However, in the case where a <= b <= c, and a = b = c, then 2^a + 2^b = 2^{a+1} > 2^c = 2^a, which is true only if a + 1 > a, which is always true.

Hence, triangles can be formed only when all three sticks have the same length.

Wait, but in the second test case of the example:

n = 4

a = [3, 2, 1, 3]

Which corresponds to lengths 8, 4, 2, 8.

Possible triangles:

- 2,4,8: 2 + 4 = 6 <= 8 → not a triangle

- 2,8,8: 2 + 8 = 10 > 8 → valid

- 4,8,8: 4 + 8 = 12 > 8 → valid

So, in this case, there are two valid triangles: (2,8,8) and (4,8,8).

Wait, but according to my earlier reasoning, triangles can only be formed when all three sticks have the same length.

But in this example, (2,8,8) and (4,8,8) are valid, even though not all sticks have the same length.

So, my earlier reasoning must be incomplete.

What's happening here?

Let me check the triangle inequality for (2,8,8):

2 + 8 > 8 → 10 > 8 → true

8 + 8 > 2 → 16 > 2 → true

8 + 2 > 8 → 10 > 8 → true

So, it's a valid triangle.

Similarly, (4,8,8):

4 + 8 > 8 → 12 > 8 → true

8 + 8 > 4 → 16 > 4 → true

8 + 4 > 8 → 12 > 8 → true

Also valid.

So, triangles can be formed even when not all three sticks have the same length, as long as the sum of any two sides is greater than the third.

So, my earlier assumption was too restrictive.

Let me try to find a general condition for when three powers of two can form a triangle.

Let’s assume, without loss of generality, that a <= b <= c.

Then, the condition is 2^a + 2^b > 2^c.

Given that 2^c is the largest, we need to ensure that the sum of the other two is greater than it.

Given that 2^a + 2^b <= 2^{b+1}, and 2^c >= 2^{b+1}, in general.

But in the example above, when a < b < c, and c = b + 1, then 2^a + 2^b = 2^b + 2^a <= 2^b + 2^b = 2^{b+1}.

If c = b + 1, then 2^c = 2^{b+1}, so 2^a + 2^b <= 2^{b+1} = 2^c.

Hence, 2^a + 2^b <= 2^c, with equality only when a = b = c - 1.

But in this case, if a < b < c and c = b + 1, then 2^a + 2^b = 2^b + 2^a < 2^{b+1} = 2^c, unless a = b, which contradicts a < b.

Hence, in this scenario, 2^a + 2^b < 2^c, so no triangle.

But in the example, (2,8,8) is a valid triangle, which corresponds to a =1, b=3, c=3.

So, a < b = c.

Hence, in this case, c = b.

So, perhaps my assumption that c > b is too restrictive.

Let me consider the case where a <= b <= c, and c <= b + 1.

Wait, but in powers of two, c can be greater than b + 1.

Wait, perhaps I need to consider the minimal c for which 2^a + 2^b > 2^c.

Let’s consider a specific example.

Suppose a =1, b=3, c=3.

Then, 2^1 + 2^3 = 2 + 8 = 10 > 8 = 2^3.

Hence, it's a valid triangle.

Similarly, a=2, b=3, c=3.

2^2 + 2^3 = 4 + 8 = 12 > 8 = 2^3.

Again, valid.

But if a=1, b=3, c=4.

2^1 + 2^3 = 2 + 8 = 10 <= 16 = 2^4.

Hence, not a valid triangle.

So, in general, for a <= b <= c, and c <= b + 1, then 2^a + 2^b >= 2^{b+1} >= 2^c, with equality only in specific cases.

Wait, no, 2^a + 2^b <= 2^{b+1}, which is equal to 2^{c} if c = b + 1.

Hence, in this case, 2^a + 2^b <= 2^c, with equality only if a = b.

So, when c = b + 1 and a = b, then 2^a + 2^b = 2^{b+1} = 2^c, which is not strictly greater than 2^c.

Hence, in this case, it's still not a valid triangle.

Wait, but in the earlier example, (2,8,8), c =3, b=3, a=1.

Wait, but c =3, b=3, a=1, which doesn't satisfy c <= b +1, because c = b.

Wait, no, c can be equal to b.

Wait, perhaps I need to consider cases where c <= b + log2(1 + 2^{b - a}).

Wait, this might be too complicated.

Let me think differently.

Suppose I have a <= b <= c.

Then, 2^a + 2^b > 2^c.

I can divide both sides by 2^a, which is positive, so the inequality remains:

1 + 2^{b - a} > 2^{c - a}.

Let d = c - a, e = b - a.

Then, the inequality becomes:

1 + 2^e > 2^d.

Given that e <= d, since b <= c.

So, 1 + 2^e > 2^d, with e <= d.

This inequality holds only if d <= e.

Because 2^d <= 2^e.

Wait, no, 2^d <= 2^e implies d <= e, but in this case, e <= d.

Wait, perhaps I need to consider when 1 + 2^e > 2^d.

Let me fix e and d, with e <= d.

Then, 1 + 2^e > 2^d.

This is equivalent to 2^d - 2^e < 1.

But 2^d - 2^e = 2^e (2^{d - e} - 1).

For this to be less than 1, since 2^e is an integer (assuming e >=0), the only way is if e = 0 and d =0.

But in our earlier substitution, e = b - a, d = c - a.

Given that a <= b <= c, e >=0, d >=0.

But in the example, e can be positive.

Wait, perhaps this approach isn't leading me anywhere.

Let me consider specific cases.

Case 1: a = b = c.

Then, 2^a + 2^b = 2^{a+1} > 2^c = 2^a.

This holds since a +1 > a.

Hence, it's a valid triangle.

Case 2: a < b = c.

Then, 2^a + 2^b = 2^a + 2^b > 2^b.

Since 2^a >0, so yes, it's greater than 2^b.

Wait, no, 2^a + 2^b = 2^b + 2^a.

If a < b, then 2^a + 2^b = 2^b + 2^a < 2^{b+1}.

But 2^{b+1} = 2^{c+1} if b = c.

Wait, no, c = b.

So, 2^a + 2^b = 2^b + 2^a > 2^c = 2^b.

This holds if a >0.

Wait, 2^b + 2^a > 2^b is equivalent to 2^a >0, which is always true.

Hence, in this case, it's always a valid triangle.

Wait, but in the earlier example, a=1, b=3, c=3.

2 + 8 > 8, which is true.

Similarly, a=0, b=3, c=3.

1 + 8 > 8, which is true.

Hence, as long as a >=0, it's valid.

Wait, but in the problem statement, a_i >=0, so 2^{a_i} >=1.

Hence, 2^a + 2^b > 2^c holds whenever a <= b <= c and b = c.

Wait, but in the earlier example, a=1, b=3, c=3.

Here, a < b = c, and 2^1 + 2^3 = 2 + 8 = 10 > 8 = 2^3.

So, it's valid.

Similarly, a=2, b=3, c=3.

4 + 8 > 8.

Hence, valid.

But in the case where a < b < c, it's not valid, as shown earlier.

Hence, triangles can be formed in two scenarios:

1. All three sticks have the same length (a = b = c).

2. Two sticks have the same length, and the third is shorter (a <= b = c).

Wait, but in the second test case, (2,8,8) corresponds to a=1, b=3, c=3.

Is this allowed?

Wait, but in this case, a <= b = c, but a < b.

Is this always valid?

Wait, in general, for a <= b <= c, with b = c, is 2^a + 2^b > 2^c?

Which is 2^a + 2^b = 2^b + 2^a > 2^c = 2^b.

This simplifies to 2^a > 0, which is always true.

Hence, it's always valid when b = c, regardless of a.

But in the first test case, all a_i are 1, so all sticks have length 2.

Hence, any three sticks form a valid triangle.

In the second test case, a = [3,2,1,3], which corresponds to lengths [8,4,2,8].

Possible triangles:

- (2,4,8): 2 + 4 =6 <=8 → not valid

- (2,8,8): 2 +8 =10 >8 → valid

- (4,8,8): 4 +8 =12 >8 → valid

Hence, two valid triangles, as per the sample output.

So, in general, triangles can be formed when either all three sticks have the same length or two sticks have the same length and the third is smaller.

Wait, but in the first case, all sticks have the same length, which is a special case of two sticks having the same length and the third being smaller (since all are equal, the third is not smaller, but equal).

Wait, perhaps it's when at least two sticks have the same length, and the third stick is less than or equal to the other two.

Wait, but in the first test case, all sticks are equal, so it's valid.

In the second test case, two sticks are 8, one is 2: (2,8,8) is valid.

Similarly, (4,8,8) is valid.

Hence, the general condition is: among the three sticks, if the two larger ones are equal, then it's valid, regardless of the smallest one.

Wait, but in (2,8,8), the two larger ones are 8, which are equal, and it's valid.

In (4,8,8), same.

In (2,4,8), the two larger ones are 4 and 8, which are not equal, and it's not valid.

Hence, the condition seems to be: if the two larger sticks in the triple have the same length, then it's a valid triangle.

This seems to hold in the examples.

Hence, the condition for a valid triangle is that the two larger sticks have the same length.

This simplifies things.

Hence, in any triple where the two larger sticks have the same length, it's a valid triangle.

Otherwise, it's not.

Hence, I can count the number of such triples efficiently.

Now, to implement this efficiently, considering that n can be up to 3*10^5, I need an efficient way to count the number of triples where the two larger sticks have the same length.

First, I can count the frequency of each length.

Let’s sort the a_i's first, since the actual lengths are 2^{a_i}, and 2^x is strictly increasing, so sorting a_i's will sort the lengths.

Hence, I can sort the a_i's and then count frequencies.

Wait, but a_i can be repeated, so I need to count the frequency of each a_i.

Let’s say I have frequencies f[x], where x is the value of a_i, and f[x] is the number of sticks with a_i = x.

Then, the number of triples where all three sticks have the same length is C(f[x],3) for each x, where C(n,3) = n*(n-1)*(n-2)/6.

Similarly, the number of triples where two sticks have the same length and the third is smaller is C(f[x],2) * (total sticks with a_i < x).

Hence, total number of valid triples is sum over x of C(f[x],3) + C(f[x],2) * (total sticks with a_i < x).

Wait, but according to the earlier condition, it's valid when the two larger sticks have the same length.

Hence, in a triple, if the two larger sticks have the same length, it's valid.

Hence, for each x, the number of triples where two sticks have length x and the third has length <= x.

Wait, no.

Wait, in the triple, the two larger sticks have length x, and the smallest can be any length less than or equal to x.

Hence, for each x, the number of ways to choose two sticks of length x and one stick with length <= x.

But we have to subtract the cases where all three sticks are of length x, since they are already counted in C(f[x],3).

Wait, no.

Actually, C(f[x],2) * (total sticks with a_i <= x) gives the number of triples where two sticks have length x and the third has length <= x.

But in this count, C(f[x],3) is included, because when all three sticks have length x.

Hence, to count only the triples where exactly two sticks have length x and the third is strictly less than x, we need to subtract C(f[x],3).

Hence, for each x, the number of valid triples is C(f[x],3) + C(f[x],2) * (total sticks with a_i < x).

Wait, no, more precisely:

For each x, the number of triples where two sticks have length x and the third has length <= x is C(f[x],2) * (total sticks with a_i <= x).

But this includes the triples where all three sticks have length x, which is C(f[x],3).

Hence, to count only the triples where exactly two sticks have length x and the third is strictly less than x, we need to subtract C(f[x],3).

Hence, the total number of valid triples is sum over x of C(f[x],3) + [C(f[x],2) * (total sticks with a_i < x)].

Wait, but according to the earlier condition, any triple where the two larger sticks have the same length is valid.

Hence, in the triple, if the two larger sticks have length x, and the smallest stick has any length <= x, it's valid.

Hence, for each x, the number of such triples is C(f[x],2) * (total sticks with a_i <= x).

But this includes the triples where all three sticks have length x, which is C(f[x],3).

Hence, the total number of valid triples is sum over x of C(f[x],2) * (total sticks with a_i <= x) - sum over x of C(f[x],3).

Wait, but in the earlier reasoning, it's sum over x of C(f[x],3) + C(f[x],2) * (total sticks with a_i < x).

These two expressions are actually equivalent.

Because C(f[x],2) * (total sticks with a_i <= x) = C(f[x],2) * (total sticks with a_i < x + f[x]) = C(f[x],2) * (total sticks with a_i < x) + C(f[x],2) * f[x] = C(f[x],2) * (total sticks with a_i < x) + C(f[x],3) * 2.

Wait, no, C(f[x],2) * f[x] = C(f[x],3) * 6, which is not matching.

Wait, perhaps I need to think differently.

Let me consider that for each x, the number of triples where the two larger sticks have length x is C(f[x],2) * (total sticks with a_i <= x).

But this counts the triples where all three sticks have length x multiple times.

Wait, no, C(f[x],2) * f[x] = C(f[x],3) * 6, which is not matching.

I think it's better to think in terms of inclusion.

Total valid triples = sum over x of [C(f[x],2) * (total sticks with a_i <= x) - C(f[x],3)].

But I'm getting confused.

Let me look at it differently.

Let me sort the a_i's in non-decreasing order.

Let’s denote the sorted a_i's as a[1] <= a[2] <= ... <= a[n].

Then, for a triple (i,j,k), with i < j < k, the two larger sticks are j and k, which have a[j] and a[k].

For the triple to be valid, a[j] must be equal to a[k].

Hence, I need to count the number of triples where a[j] = a[k].

Given that, I can iterate through all possible pairs where a[j] = a[k], and for each such pair, count the number of i < j such that a[i] <= a[j].

Wait, but a[j] = a[k], and a[i] <= a[j].

Since the array is sorted, all a[i] for i < j are <= a[j].

Hence, for each pair (j,k) where a[j] = a[k], the number of valid i < j is j -1.

Hence, the total number of valid triples is sum over all pairs (j,k) where a[j] = a[k] and j < k of (j -1).

Wait, but this seems inefficient for n up to 3*10^5.

I need a better way.

Wait, perhaps I can group the indices by their a_i values.

Let’s group the indices by their a_i values.

Let’s say I have groups g[x], which is the list of indices where a_i = x.

Then, for each group g[x], the number of pairs where a[j] = a[k] = x is C(f[x],2).

For each such pair, the number of i < j where a[i] <= x is simply the number of sticks with a_i <= x that come before j.

But since the array is sorted, all sticks with a_i < x are before the first index in g[x], and sticks with a_i = x are within g[x].

Hence, for each pair in g[x], the number of i < j is the number of sticks with a_i < x plus the number of sticks with a_i = x that come before j.

Wait, this seems complicated.

Let me think differently.

Let me iterate through the sorted a_i's and keep track of frequencies.

Let’s sort the a_i's in non-decreasing order.

Then, iterate through each possible value of x, and for each x, compute C(f[x],2) * (total sticks with a_i <= x).

But total sticks with a_i <= x is the cumulative sum up to x.

Hence, I can compute the frequency f[x] for each x, and then compute the cumulative sum s[x] = sum of f[y] for y <= x.

Then, for each x, the number of valid triples is C(f[x],2) * s[x].

But this counts the triples where all three sticks have the same length C(f[x],3) times.

Hence, I need to subtract C(f[x],3) for each x.

Wait, but actually, C(f[x],2) * s[x] includes C(f[x],3) for each x.

Hence, total number of valid triples is sum over x of C(f[x],2) * s[x] - C(f[x],3).

Wait, but I need to verify this.

Wait, perhaps it's easier to think in terms of inclusion-exclusion.

Total valid triples = sum over x of [C(f[x],2) * (total sticks with a_i <= x) - C(f[x],3)].

But I need to make sure this is correct.

Wait, perhaps I can look at it differently.

Let’s consider that for any triple where the two larger sticks have the same length x, the number of such triples is C(f[x],2) * (number of sticks with a_i <= x).

But since the two larger sticks are both x, and the smallest stick can be any with a_i <= x.

But in this count, triples where all three sticks have length x are counted in C(f[x],3).

Hence, total number of valid triples is sum over x of [C(f[x],2) * (number of sticks with a_i < x) + C(f[x],3)].

Wait, no.

Wait, C(f[x],2) * (number of sticks with a_i <= x) counts all triples where two sticks have length x and the third has length <= x.

This includes the triples where all three sticks have length x, which is C(f[x],3).

Hence, total number of valid triples is sum over x of [C(f[x],2) * (number of sticks with a_i <= x) - C(f[x],3)].

Wait, but C(f[x],2) * (number of sticks with a_i <= x) = C(f[x],2) * (number of sticks with a_i < x + f[x]) = C(f[x],2) * (number of sticks with a_i < x) + C(f[x],2) * f[x] = C(f[x],2) * (number of sticks with a_i < x) + C(f[x],3) * 2.

Wait, no, C(f[x],2) * f[x] = f[x] * (f[x]-1)/2 * f[x] = f[x]^2 (f[x]-1)/2, which is not equal to C(f[x],3) * anything straightforward.

I think I'm getting tangled up here.

Let me try a different approach.

Let’s consider that for any triple where the two larger sticks have the same length x, the number of such triples is C(f[x],2) * (total sticks with a_i <= x).

But this includes the triples where all three sticks have length x, which is C(f[x],3).

Hence, to count only the triples where exactly two sticks have length x and the third is strictly less than x, I need to subtract C(f[x],3).

Hence, the total number of valid triples is sum over x of [C(f[x],2) * (total sticks with a_i <= x) - C(f[x],3)].

Wait, but in the earlier example, let's test this.

First test case: n=7, a=[1,1,1,1,1,1,1]

So, f[1] =7

Total valid triples = C(7,2) * 7 - C(7,3) = 21 *7 - 35 = 147 - 35 =112.

But according to the sample output, it's 35.

Hmm, that doesn't match.

Wait, perhaps my formula is incorrect.

Wait, in this case, all sticks have the same length, so all possible triples are valid.

The number of triples is C(7,3) =35.

But according to my formula, it's C(7,2)*7 - C(7,3) =21*7 -35=147-35=112, which is incorrect.

Hence, my formula is wrong.

Wait, perhaps I need to think differently.

Let me consider that for each pair of sticks with the same length x, the number of sticks with a_i <= x minus one (since the pair already includes two sticks of length x).

Wait, no.

Wait, perhaps it's better to iterate through the sorted a_i's and for each pair of sticks with the same a_i, add the number of sticks with a_i <= a_i.

Wait, but that seems similar to what I did earlier.

Let me try to think in terms of cumulative frequencies.

Let’s sort the a_i's in non-decreasing order.

Let’s compute the cumulative sum s[x] = number of sticks with a_i <= x.

Then, for each x, the number of valid triples is C(f[x],2) * s[x] - C(f[x],3).

But as seen in the first test case, this doesn't hold.

Hence, perhaps the formula is simply sum over x of C(f[x],2) * s[x -1] + C(f[x],3).

Where s[x -1] is the number of sticks with a_i < x.

This way, C(f[x],2) * s[x -1] counts the triples where exactly two sticks have length x and the third is less than x.

And C(f[x],3) counts the triples where all three sticks have length x.

Hence, total valid triples = sum over x of C(f[x],2) * s[x -1] + C(f[x],3).

Let’s test this with the first test case.

n=7, a=[1,1,1,1,1,1,1]

f[1]=7

s[1 -1] = s[0] =0 (since a_i >=0, but a_i=0 would correspond to length 1, but in this case, all a_i=1.

Wait, in this case, s[x -1] for x=1 is s[0]=0.

Hence, C(7,2)*0 + C(7,3)=21*0 +35=35, which matches the sample output.

Good.

Second test case: n=4, a=[3,2,1,3]

Sorted a_i's: [1,2,3,3]

f[1]=1, f[2]=1, f[3]=2

s[x] for x=1:1, x=2:2, x=3:4

Hence, for x=1: C(1,2)*0 + C(1,3)=0 +0=0

x=2: C(1,2)*1 + C(1,3)=0 +0=0

x=3: C(2,2)*3 + C(2,3)=1*3 +0=3

But according to the sample output, it's 2.

Hmm, doesn't match.

Wait, perhaps I need to adjust s[x -1].

For x=3, s[x -1] = s[2]=2

Hence, C(2,2)*2 + C(2,3)=1*2 +0=2, which matches the sample output.

Okay, so perhaps I had a mistake earlier.

Hence, the correct formula is sum over x of C(f[x],2) * s[x -1] + C(f[x],3).

Where s[x -1] is the number of sticks with a_i < x.

Hence, in the first test case, for x=1, s[x -1]=s[0]=0 (assuming a_i >=0), so C(7,2)*0 + C(7,3)=0 +35=35, which matches.

In the second test case, for x=1: C(1,2)*0 + C(1,3)=0+0=0

x=2: C(1,2)*1 + C(1,3)=0+0=0

x=3: C(2,2)*2 + C(2,3)=1*2 +0=2, which matches the sample output.

Good.

Hence, the total number of valid triples is sum over x of [C(f[x],2) * number of sticks with a_i < x] + C(f[x],3).

This seems correct.

Hence, in implementation, I can sort the a_i's, compute the frequency f[x] for each x, and compute the cumulative sum s[x -1], which is the number of sticks with a_i < x.

Then, for each x, compute C(f[x],2) * s[x -1] + C(f[x],3).

Sum these up for all x to get the total number of valid triples.

This should be efficient enough, as it operates in O(n) time per test case, given that n is up to 3*10^5 in total.

Hence, overall time complexity is acceptable.

Now, to implement this, I need to:

1. Read t, the number of test cases.

2. For each test case:

a. Read n.

b. Read the list of a_i's.

c. Sort the a_i's.

d. Count the frequency f[x] for each x.

e. Compute the cumulative sum s[x -1] for each x.

f. For each x, compute C(f[x],2) * s[x -1] + C(f[x],3), and sum them up.

g. Output the total sum.

Edge cases to consider:

- n < 3: no triples possible.

- All a_i's are the same: C(f[x],3).

- a_i's are all unique: 0.

- a_i's have varying frequencies.

- Minimum and maximum values of a_i.

- a_i can be 0: 2^0 =1.

I need to make sure that the implementation handles these cases correctly.

Also, since a_i can be up to n, and n can be up to 3*10^5, I need to handle arrays up to that size.

Implementing f[x] can be done using a list, since a_i can be up to n, which is 3*10^5, so indexing up to that is acceptable.

Similarly, s[x -1] can be computed using a prefix sum.

Hence, the implementation seems straightforward.

Hence, the given program seems to implement this logic.

In the given program:

- It reads t, the number of test cases.

- For each test case:

- Reads n.

- Reads the list w of a_i's.

- If n < 3: print 0.

- Else:

- Initializes a list q of size n+1 with zeros.

- Counts the frequency of each a_i in q.

- Creates a list eta of x where q[x] >0, sorted.

- Computes rho, which is the cumulative sum of frequencies where a_i < x.

- For each x in eta, computes C(q[x],3) and adds it to res.

- For each x in eta, adds C(q[x],2) * rho to res.

- Prints res.

This matches the logic I derived.

Hence, the program is correct.

**Final Solution**

To solve this problem, we need to determine the number of ways to choose exactly 3 sticks from a given set such that they can form a non-degenerate triangle. The lengths of the sticks are given by powers of two, specifically \(2^{a_i}\) for each stick i.

### Approach

1. **Understanding the Triangle Inequality**:
    - For three lengths to form a triangle, the sum of any two sides must be greater than the third side.
    - Given the lengths are powers of two, we leverage their properties to efficiently count valid combinations.

2. **Key Observations**:
    - If the two larger sides are equal, the triangle is valid as long as the smallest side is less than or equal to the larger sides.
    - We need to count combinations where either all three sides are equal or two sides are equal and the third is smaller.

3. **Efficient Counting**:
    - Count frequencies of each stick length.
    - Use cumulative sums to quickly calculate the number of sticks with lengths less than a given length.
    - Compute combinations using these frequencies and cumulative sums to find the total number of valid triangles.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        w = list(map(int, input().split()))
        if n < 3:
            print(0)
            continue
        q = [0] * (n + 1)
        for ai in w:
            q[ai] += 1
        eta = [x for x in range(n + 1) if q[x] > 0]
        eta.sort()
        rho = 0
        res = 0
        for x in eta:
            freq = q[x]
            if freq >= 3:
                res += (freq * (freq - 1) * (freq - 2)) // 6
            if freq >= 2:
                res += (freq * (freq - 1)) // 2 * rho
            rho += q[x]
        print(res)

if __name__ == "__main__":
    func()
```

### Explanation

1. **Reading Input**:
    - Read the number of test cases \( t \).
    - For each test case, read \( n \) (number of sticks) and the list \( w \) of exponents \( a_i \).

2. **Frequency Counting**:
    - Use a list `q` to count occurrences of each \( a_i \).

3. **Sorting and Cumulative Sum**:
    - Create a sorted list `eta` of unique \( a_i \) values that appear.
    - Use `rho` to maintain the cumulative count of sticks with lengths less than the current \(