Alright, I've got this problem to solve. It's about determining who wins in a game between Anna and Sasha based on their moves on a list of integers. Let's break it down step by step.

First, I need to understand the game rules:

1. Anna goes first.

2. On Anna's turn, she chooses one element from the list and reverses its digits, removing any leading zeros.

3. On Sasha's turn, he chooses two different elements from the list, concatenates them in any order, and inserts the result back into the list. This reduces the list size by one.

4. The game ends when there's only one number left in the list, and based on its value, either Sasha or Anna wins.

The goal is to determine who wins if both play optimally.

Okay, so I need to think about the game mechanics and how the players can influence the final number.

Let's consider the game flow:

- The game starts with n integers.

- Players alternate turns, with Anna starting.

- Each of Anna's moves reverses one number's digits.

- Each of Sasha's moves concatenates two numbers into one.

- The game ends when only one number remains, and if this number is at least 10^m, Sasha wins; otherwise, Anna wins.

I need to figure out, for given n, m, and the list of a_i, who wins.

First, I should consider the total number of moves:

- Each of Sasha's moves reduces the list size by 1.

- Anna's moves don't change the list size.

- The game ends when there's only one number left.

So, the number of Sasha's moves is (n - 1).

Anna makes a move before each of Sasha's moves, except possibly the first one.

Wait, let's think about the sequence of moves:

- Anna goes first, reverses one number.

- Then Sasha makes his move, concatenating two numbers.

- Then Anna reverses another number.

- And so on, until only one number remains.

Wait, but the problem says "players take turns", with Anna going first, but Sasha's move reduces the list size by 1.

I need to clarify the turn order:

- Anna reverses one number (list size remains the same).

- Then Sasha concatenates two numbers (list size decreases by 1).

- Then Anna reverses another number (list size remains the same again).

- Then Sasha concatenates two numbers (list size decreases by 1).

- And so on, until only one number remains.

Wait, but the problem says that after Sasha's move, the number of elements decreases by 1, which makes sense because he removes two and adds one.

But Anna's move doesn't change the list size, as she only reverses one element.

So, the game proceeds as:

1. Anna reverses one element.

2. Then Sasha concatenates two elements.

3. Repeat until only one element remains.

The game ends after Sasha's move that results in only one element left.

Wait, but if n starts at some number, and Sasha reduces the list by 1 each time, we need to see how many moves are made.

Wait, no. Sasha removes two elements and adds one, so the list size decreases by 1 each time he moves.

So, if n is the initial number of elements, the number of Sasha's moves is (n - 1), since each move reduces the list by 1, from n to 1.

And Anna makes a move before each of Sasha's moves.

So, total Sasha's moves: (n - 1).

Total Anna's moves: (n - 1), since she moves once before each of Sasha's moves.

Wait, but the problem says "players take turns, with Anna making the first move".

So, sequence is:

Anna moves.

Then Sasha moves.

Then Anna moves.

Then Sasha moves.

And so on, until Sasha's last move leaves only one element.

Wait, but Sasha's moves reduce the list size by 1 each time.

So, starting from n elements:

- Anna reverses one element (list still has n elements).

- Sasha concatenates two elements into one (list now has n - 1 elements).

- Anna reverses one element (list still has n - 1 elements).

- Sasha concatenates two elements into one (list now has n - 2 elements).

- And so on, until Sasha's last move leaves one element.

So, the number of Sasha's moves is (n - 1), and the number of Anna's moves is also (n - 1).

Each player makes (n - 1) moves.

Okay, now I need to think about the final number and who can influence it to make it greater than or equal to 10^m.

Sasha wins if the final number is >= 10^m.

Anna wins otherwise.

Both play optimally, meaning they do their best to win.

So, I need to determine, given n, m, and the list of a_i, who will win.

I need to find a strategy for both players.

First, let's consider some simple cases.

Case 1: n = 1.

If n = 1, there are no Sasha's moves possible, as he needs at least two elements to concatenate.

So, the game ends immediately with the single element, and Anna wins if it's less than 10^m, otherwise Sasha wins.

Wait, but according to the rules, the game ends after Anna's move when there's only one element left.

But if n = 1 initially, Anna reverses the single element, and then the game ends, since Sasha can't make a move.

So, if n = 1:

- Anna reverses the single element.

- If the reversed number is less than 10^m, Anna wins.

- Else, Sasha wins.

Wait, but reversing a single number can change its value.

For example, if a_1 = 12, reversing gives 21.

If a_1 = 1, reversing gives 1.

So, in this case, Anna can choose to reverse or not, but since it's the only move, she has to reverse it.

Then, compare the reversed number with 10^m.

If reversed number >= 10^m, Sasha wins; else, Anna wins.

Okay, that seems straightforward for n = 1.

Case 2: n = 2.

- Anna reverses one of the two elements.

- Then Sasha concatenates the two elements.

- Game ends.

So, Anna chooses which element to reverse, and then Sasha concatenates the two elements in some order.

Sasha wants the concatenated number to be as large as possible, so he chooses the order that maximizes the number.

Anna wants to minimize the final number, so she chooses which element to reverse to minimize the concatenated result.

Wait, but the problem says both play optimally, but it doesn't specify if their objectives are to maximize or minimize the final number.

Actually, Anna wants the final number to be less than 10^m, and Sasha wants it to be greater than or equal to 10^m.

So, Anna will play to minimize the final number, and Sasha will play to maximize it.

Therefore, in n=2:

- Anna reverses one element to minimize the final number.

- Sasha concatenates the two elements in the order that gives the largest possible number.

Wait, but Anna can choose which element to reverse to make the concatenation result as small as possible.

So, in n=2, Anna chooses to reverse one element, then Sasha concatenates the two elements in the better order for him.

I need to consider both possibilities.

Let's take an example:

n=2, m=2

a = [14, 2]

Anna can reverse 14 to 41 or reverse 2 to 2.

If she reverses 14 to 41, then Sasha concatenates 41 and 2 in some order.

If he chooses 412, which is greater than 100, so Sasha wins.

If she reverses 2 to 2, which is the same, so Sasha concatenates 14 and 2 to make 142 or 214, both greater than 100, so Sasha wins.

So, no matter what Anna does, Sasha wins.

Another example:

n=2, m=1

a = [5, 5]

Anna can reverse 5 to 5 or 5 to 5, no change.

Then Sasha concatenates 5 and 5 to make 55, which is greater than 10, so Sasha wins.

Wait, but in this case, Anna couldn't make any difference.

Another example:

n=2, m=3

a = [123, 456]

Anna can reverse 123 to 321 or 456 to 654.

Then Sasha concatenates 321 and 456 to make 321456 or 456321, both greater than 1000.

Or Anna reverses 456 to 654, and Sasha concatenates 123 and 654 to make 123654 or 654123, both greater than 1000.

So, Sasha wins.

Wait, but what if Anna can make the reversed number such that no matter how Sasha concatenates, it's less than 10^m.

But in these examples, Sasha can always make a number greater than or equal to 10^m.

So, perhaps in some cases, Anna can force the final number to be less than 10^m.

Let's think of such a case.

Suppose n=2, m=3

a = [99, 99]

Anna can reverse 99 to 99.

Then Sasha concatenates 99 and 99 to make 9999, which is greater than 1000, so Sasha wins.

Or Anna reverses one to 99 and the other is 99, same result.

So, again Sasha wins.

Another case:

n=2, m=4

a = [99, 99]

Anna reverses one to 99, the other is 99.

Sasha concatenates to make 9999, which is less than 10000.

So, in this case, Sasha wants the final number to be at least 10000, but 9999 is less, so Anna wins.

So, in this case, Anna wins.

So, in this case, Anna can force the final number to be less than 10^m.

So, it depends on the values and m.

Okay, so in general, for n=2:

- Anna reverses one element.

- Sasha concatenates the two elements in the better order for him.

- If the resulting number is >= 10^m, Sasha wins; else, Anna wins.

So, for Anna, she wants to reverse an element to minimize the final concatenated number.

For Sasha, he wants to choose the order that maximizes the concatenated number.

So, for n=2, Anna chooses which element to reverse to minimize the maximum possible concatenation.

Wait, it's a bit tricky.

Wait, perhaps another way to think about it.

In n=2, Anna reverses one element, then Sasha concatenates the two in the better order for him.

So, Anna wants to choose which element to reverse such that, no matter how Sasha concatenates, the final number is less than 10^m.

But Sasha will always choose the order that gives the larger number.

So, Anna needs to ensure that even with Sasha's optimal choice, the number is less than 10^m.

So, Anna needs to choose to reverse an element such that the largest possible concatenation is still less than 10^m.

Otherwise, Sasha wins.

Okay, that makes sense.

Now, for n > 2, it's more complicated.

Because there are multiple moves.

Each time, Anna reverses one element, then Sasha concatenates two elements.

This repeats until only one element remains.

It's getting complex.

I need a better approach.

Maybe I can think in terms of the final number being the result of multiple concatenations, with Anna reversing some elements in between.

But keeping track of all possible moves is too complicated.

Perhaps there's a pattern or a mathematical way to determine the winner without simulating all moves.

Let me think differently.

Let's consider that Anna reverses some elements, and Sasha concatenates them in a way that maximizes the final number.

I need to find out the minimal possible final number that Anna can achieve, given that Sasha is trying to maximize it.

Wait, it's a minimax problem.

Anna wants to minimize the final number, knowing that Sasha will maximize it at each step.

This seems like a game theory problem where I need to find the optimal strategy for both players.

But simulating the game for large n is not feasible due to time and computational constraints.

I need a smarter way.

Let me think about the properties of the numbers.

Reversing a number can make it larger or smaller.

Concatenating two numbers can create a very large number, depending on the order.

I need to consider the lengths of the numbers and their values.

Wait, perhaps the key is to consider the lengths of the numbers.

Because concatenating two numbers affects the order of digits significantly.

Reversing a number changes its digit order but not its length.

Wait, maybe I can think in terms of the total number of digits in the final number.

But no, because concatenations are partial, depending on Sasha's choices.

It's still too vague.

Let me consider the parity of n.

Wait, perhaps the number of moves can determine something.

Wait, in the game, Anna makes (n-1) moves, and Sasha makes (n-1) moves.

Wait, no, let's see.

Each of Sasha's moves reduces the list size by 1.

Starting from n elements, Sasha needs to make (n-1) moves to reduce it to 1 element.

And Anna makes a move before each of Sasha's moves.

So, Anna makes (n-1) moves, and Sasha makes (n-1) moves.

Total moves: 2*(n-1).

But I need to think about the sequence of moves.

Wait, perhaps I can think recursively.

Define the game state based on the current list and whose turn it is.

But with n up to 2e5, this is not practical.

I need a better approach.

Let me consider that Anna can reverse any subset of the numbers, and Sasha concatenates them in a way that maximizes the final number.

But the reverses are interleaved with concatenations.

This is getting too complicated.

Maybe I should look for patterns in the sample inputs and outputs.

Looking back at the example:

Input:

9

2 2

14 2

3 5

9 56 1

4 10

1 2007 800 1580

4 5

5000 123 30 4

10 10

6 4 6 2 3 1 10 9 10 7

1 1

6

1 1

10

8 9

1 2 9 10 10 2 10 2

4 5

10 10 10 10

Output:

Sasha

Anna

Anna

Sasha

Sasha

Anna

Anna

Anna

Sasha

Looking at these, I need to see if there's a pattern.

But it's not immediately obvious.

I need to think differently.

Perhaps I can consider that Anna can reverse any one element, and Sasha can concatenate any two in any order.

But with multiple moves, it's still tricky.

Wait, perhaps I can consider the minimal possible final number that Anna can achieve, given Sasha's attempts to maximize it.

But how to compute that?

Alternative approach: think in terms of who has the last move.

In standard such games, the player who makes the last move has an advantage.

But in this case, the last move is Sasha's, as he's the one who reduces the list to one element.

So, perhaps Sasha has an advantage.

But in some cases, Anna can force a win.

I need to find a general strategy.

Wait, perhaps I can think in terms of the total number of moves and who can control the final number.

But I'm going in circles.

Let me consider that Anna can reverse any subset of the numbers, and Sasha concatenates them in a way that maximizes the final number.

But this is not exactly accurate, as the reverses are interleaved with concatenations.

This is getting too tangled.

Maybe I should consider the game as a whole and find a way to compute the minimal possible final number that Anna can achieve.

But even that seems too complex.

Wait, perhaps I can consider that Anna can choose to reverse elements in a way that minimizes the maximum possible concatenation result.

But with multiple moves, it's still not straightforward.

Let me try to think of a simpler version of the game.

Suppose n=3.

Anna reverses one element.

Then Sasha concatenates two elements.

Then Anna reverses another element.

Then Sasha concatenates the remaining two elements.

Wait, no.

With n=3, Sasha's first move concatenates two elements, reducing the list to 2 elements.

Then Anna reverses one element.

Then Sasha concatenates the remaining two elements.

So, in total, Anna makes (n-1) reverses, and Sasha makes (n-1) concatenations.

But it's still complicated to track.

Maybe I can think in terms of the final number being the result of concatenating all numbers in some order, with Anna able to reverse some of them.

But it's not that simple, because the order of concatenations matters.

Wait, perhaps I can consider the final number as the result of a binary tree of concatenations, with Anna reversing some of the leaves and internal nodes.

But this seems too involved.

I need a better approach.

Let me consider the total number of digits in the final number.

Each concatenation combines two numbers into one, increasing the total number of digits.

But the reverses can change the digits of individual numbers.

It's still too vague.

Wait, perhaps I can think about the minimal possible final number that Anna can achieve, and see if it's less than 10^m.

But how to compute that?

Alternative idea: perhaps the game can be modeled as a game where Anna chooses to reverse some elements, and Sasha chooses the order of concatenations to maximize the final number.

If I can find the minimal possible final number that Anna can achieve, then compare it to 10^m, I can determine who wins.

But computing the minimal possible final number seems difficult.

Wait, perhaps I can sort the numbers in a certain way.

Let me consider that Anna can reverse any subset of the numbers, and Sasha concatenates them in the best possible order.

Then, Anna wants to choose which numbers to reverse to minimize the final number.

But it's still complex.

Wait, perhaps I can consider that reversing a number is equivalent to replacing it with its reverse, and then Sasha concatenates them in an order that maximizes the final number.

If I can find the minimal possible final number that Anna can achieve by choosing which numbers to reverse, then I can compare it to 10^m.

But how to compute that minimal final number?

Let me consider that Anna can choose to reverse any k numbers, and Sasha concatenates all numbers in the order that maximizes the final number.

Then, Anna wants to choose which k numbers to reverse to minimize this maximal concatenation.

This is still too involved.

I need a better strategy.

Let me think about the properties of reversing and concatenating numbers.

Reversing a number can make it smaller or larger, depending on the number.

Concatenating two numbers can create a very large number, depending on the order.

Anna wants the final number to be as small as possible, while Sasha wants it to be as large as possible.

So, Anna needs to reverse some numbers to minimize the final number, given that Sasha will concatenate them optimally.

Wait, but in the game, Anna reverses one number per move, and Sasha concatenates two numbers per move.

It's still not clear how to compute the minimal possible final number.

Alternative approach: perhaps I can consider the game in terms of the binary operation of concatenation, with Anna inserting reverses at each step.

But it's still too vague.

Let me consider the game tree, where each Anna's move is to reverse one number, and each Sasha's move is to concatenate two numbers.

But with n up to 2e5, building a game tree is impossible.

I need a smarter way.

Let me consider that the final number is determined by the order of concatenations and which numbers are reversed.

Anna can choose which numbers to reverse, and Sasha can choose the order of concatenations.

I need to find the minimal possible final number that Anna can achieve, given that Sasha will choose the best concatenation order.

This seems too complex to compute directly.

Perhaps I can find some invariant or some way to compute the minimal final number efficiently.

Wait, maybe I can consider that Anna can choose to reverse numbers such that the sorted order of the numbers (after reverses) leads to the smallest possible concatenated number.

But I need to think carefully.

Let me consider that Anna reverses some numbers to minimize the final concatenated number, and Sasha concatenates them in sorted order (either ascending or descending, depending on what maximizes the number).

Wait, but Sasha wants to maximize the final number, so he would concatenate in descending order.

So, perhaps Anna reverses some numbers so that when they are sorted in descending order, the concatenated number is as small as possible.

So, Anna wants to minimize the concatenated number when Sasha sorts the numbers in descending order for concatenation.

Wait, that might be a way to think about it.

So, if Sasha concatenates the numbers in descending order, Anna wants to reverse some numbers so that the descending order concatenation is as small as possible.

So, perhaps Anna should reverse numbers that, when reversed, make the largest numbers smaller.

Wait, it's still a bit fuzzy.

Let me try to formalize it.

Let me assume that Sasha will concatenate the numbers in descending order.

So, to minimize the final number, Anna should reverse numbers such that the largest numbers are as small as possible.

In other words, Anna should reverse numbers that, when reversed, decrease their value the most.

For example, if a number is 123, reversing gives 321, which is larger.

If a number is 321, reversing gives 123, which is smaller.

So, Anna should reverse numbers that become smaller when reversed, to minimize the final concatenated number.

Wait, but in the earlier example, reversing 2 to 2 doesn't change it, while reversing 14 to 41 makes it larger.

So, in that case, Anna might prefer to reverse the number that increases the least when reversed.

Wait, this is getting too convoluted.

Let me try to think differently.

Suppose Anna reverses some numbers, and then Sasha concatenates them in the best order for him.

I need to find the minimal possible final number that Anna can achieve.

To do this, Anna needs to choose which numbers to reverse such that, when Sasha concatenates them in the optimal order, the final number is as small as possible.

This sounds like a minimax problem.

Anna minimizes the maximal final number that Sasha can achieve.

This is similar to finding the minimal possible maximal concatenation that Anna can allow.

This seems too abstract.

Let me consider that Anna can choose to reverse any subset of the numbers.

Then, Sasha concatenates all the numbers in the order that maximizes the final number.

Anna wants to choose which numbers to reverse so that this maximal concatenation is as small as possible.

So, Anna wants to minimize the maximal concatenation possible.

Wait, perhaps I can sort the numbers after reverses and then concatenate them in a way that minimizes the final number.

But I need to consider that Sasha will choose the order that maximizes the final number.

So, Anna needs to choose which numbers to reverse such that, when Sasha sorts them in descending order and concatenates, the final number is as small as possible.

So, perhaps Anna should reverse numbers that, when reversed, are smaller than the original, to minimize the high-order digits in the final concatenation.

Wait, perhaps I can think in terms of comparing the original and reversed numbers and choosing to reverse those that lead to a smaller number.

Then, sort the reversed and non-reversed numbers and concatenate them in descending order to see the final number.

Wait, maybe that's a way.

Let me try to formalize it.

For each number a_i, Anna can choose to reverse it or leave it as is.

Let me denote b_i as the number after Anna's possible reverse.

So, b_i is either a_i or its reverse, whichever is smaller.

Then, Anna wants to choose b_i for each i such that, when the b_i's are sorted in descending order and concatenated, the final number is as small as possible.

So, Anna chooses to reverse those a_i for which the reverse is smaller than a_i, to minimize the value of b_i.

Then, she sorts the b_i in descending order and concatenates them.

If this final number is less than 10^m, Anna wins; else, Sasha wins.

Wait, but in the earlier example where n=2, a=[14,2], reversing 14 to 41 or 2 to 2.

So, b_i would be 14 or 41 for a_i=14, and 2 for a_i=2.

So, Anna chooses to reverse 14 to 41, and then Sasha concatenates 41 and 2 in descending order: 412, which is greater than 100, so Sasha wins.

Alternatively, Anna could choose not to reverse 14, keeping it as 14, and then Sasha concatenates 14 and 2 to make 142 or 214, both greater than 100.

So, in this case, Anna cannot make the final number less than 100.

Hence, Sasha wins.

Another example: n=3, a=[9,56,1].

Anna can reverse any one of them.

Let's say she reverses 56 to 65.

Then, the list becomes [9,65,1].

Sasha concatenates two of them, say 9 and 65 to make 965, and then Anna reverses 1 to 1.

Then, Sasha concatenates 965 and 1 to make 9651, which is less than 100000, so Anna wins.

Wait, but in this case, m=5, so 10^5=100000.

9651 < 100000, so Anna wins.

But is this the minimal possible final number?

Wait, maybe Anna can choose to reverse 9 to 9, 56 to 65, and 1 to 1.

Then, Sasha concatenates 9,65,1 in some way.

Wait, with n=3, Sasha first concatenates two, then Anna reverses one, then Sasha concatenates the remaining two.

It's getting complicated.

Perhaps in this case, Anna can force a win by choosing to reverse 56 to 65, and then after Sasha's concatenation, the final number is less than 10^5.

So, Anna wins.

Another example: n=4, m=10, a=[1,2007,800,1580].

I need to see what Anna can do.

If Anna reverses 1 to 1, 2007 to 7002, 800 to 008 (which is 8), and 1580 to 0851 (which is 851).

So, Anna can choose to reverse some numbers to make them smaller.

Then, Sasha concatenates them in descending order.

Anna wants the final number to be as small as possible.

So, she chooses to reverse numbers to minimize the final concatenated number.

In this case, perhaps Anna reverses 2007 to 7002, 800 to 8, 1580 to 851, and 1 to 1.

Then, the numbers are 7002,8,851,1.

Sorted descending: 7002,851,8,1.

Concatenated: 700285181, which is less than 10^10 (10000000000), so Anna wins.

Wait, but according to the sample output, it's "Anna".

So, in this case, Anna can force a win.

Another example: n=4, m=5, a=[5000,123,30,4].

Anna can reverse 5000 to 0005 (5), 123 to 321, 30 to 03 (3), 4 to 4.

So, if Anna reverses all possible, the numbers become 5,321,3,4.

Sorted descending: 321,5,4,3.

Concatenated: 321543, which is greater than 10^5 (100000), so Sasha wins.

According to the sample output, it's "Sasha".

So, in this case, Anna cannot prevent Sasha from making the final number greater than or equal to 10^5.

Hence, Sasha wins.

Wait, but Anna could choose not to reverse some numbers.

For example, if Anna doesn't reverse 5000, it remains 5000.

Then, the numbers are 5000,321,3,4.

Sorted descending: 5000,321,4,3.

Concatenated: 500032143, which is much larger than 10^5.

So, still Sasha wins.

So, in this case, Anna cannot make the final number less than 10^5.

Hence, Sasha wins.

Another example: n=1, m=1, a=[6].

Anna reverses 6 to 6.

Then, the final number is 6, which is less than 10^1=10, so Anna wins.

According to the sample input, it's "Anna".

Yes, matches the sample output.

Another example: n=1, m=1, a=[10].

Anna reverses 10 to 01 (1).

Then, the final number is 1, which is less than 10, so Anna wins.

But according to the sample input, it's "Anna".

Yes, matches.

Another example: n=8, m=9, a=[1,2,9,10,10,2,10,2].

Anna needs to reverse some numbers to minimize the final concatenated number.

Reversing 1 to 1, 2 to 2, 9 to 9, 10 to 01 (1), and so on.

So, Anna can choose to reverse some numbers to make the final concatenated number as small as possible.

Then, Sasha concatenates them in descending order.

If the final number is less than 10^9, Anna wins.

According to the sample output, it's "Anna".

So, Anna can force a win in this case.

Last example: n=4, m=5, a=[10,10,10,10].

Anna can reverse 10 to 01 (1).

So, if she reverses all, the numbers become 1,1,1,1.

Sorted descending: 1,1,1,1.

Concatenated: 1111, which is less than 10^5=100000, so Anna wins.

But according to the sample output, it's "Sasha".

Wait, but according to my reasoning, Anna should win.

Wait, perhaps I'm missing something.

Wait, in this case, Anna reverses some numbers to 1, and the rest remain 10.

So, if Anna reverses two 10's to 1, and leaves two as 10, then the numbers are 1,1,10,10.

Sorted descending: 10,10,1,1.

Concatenated: 101011, which is greater than 100000, so Sasha wins.

If Anna reverses one 10 to 1, then numbers are 1,10,10,10.

Sorted descending: 10,10,10,1.

Concatenated: 1010101, which is greater than 100000.

If Anna reverses all four to 1, then numbers are 1,1,1,1.

Sorted descending: 1,1,1,1.

Concatenated: 1111, which is less than 100000.

But Sasha can choose to concatenate in a way that maximizes the number.

Wait, but in this case, Anna can choose to reverse all to 1, leading to 1111, which is less than 100000, so Anna wins.

But according to the sample output, it's "Sasha".

Wait, perhaps I'm missing something.

Wait, maybe Anna cannot choose to reverse all in one move; perhaps she can only reverse one per move.

But in the game, Anna makes (n-1) reverses, but in this case, with n=4, she makes 3 reverses.

But she can choose which one to reverse each time.

It's getting too complicated.

Perhaps in this case, Anna cannot force a win, and Sasha can force a win.

But according to my earlier reasoning, if Anna reverses all to 1, the final number is 1111, which is less than 100000, so Anna wins.

But the sample output says "Sasha".

So, perhaps my reasoning is flawed.

I need to think differently.

Maybe I need to consider that Anna can only reverse one number per move, and Sasha can concatenate any two numbers per move.

So, the sequence of moves affects the final number.

Perhaps Anna cannot force all numbers to be reversed to 1 in time.

Wait, but with n=4, Anna makes 3 reverses.

Sasha makes 3 concatenations.

Wait, no.

Wait, with n=4, Sasha makes 3 concatenations to reduce from 4 to 1, and Anna makes 3 reverses in between.

So, the sequence is:

Anna reverses one number.

Then Sasha concatenates two numbers.

Then Anna reverses another number.

Then Sasha concatenates two numbers.

Then Anna reverses another number.

Then Sasha concatenates two numbers, leaving one number.

So, Anna reverses three numbers in total.

But she chooses which one to reverse each time.

So, perhaps Anna cannot reverse all four numbers, since she only gets to reverse three.

Wait, but she can choose which one to reverse each time.

So, perhaps she can choose to reverse the same number multiple times.

But reversing twice brings it back to original.

So, effectively, she can reverse up to three different numbers.

So, in the case where n=4 and a=[10,10,10,10], Anna can reverse three of them to 1, leaving one as 10.

Then, the numbers are 1,1,1,10.

Sorted descending: 10,1,1,1.

Concatenated: 10111, which is less than 100000.

So, Anna wins.

But according to the sample output, it's "Sasha".

So, perhaps I'm missing something.

Wait, maybe I'm misunderstanding the game rules.

Let me read the problem again carefully.

"Anna must choose an element a_i from the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of 42, it would become 24; if Anna chose the element with a value of 1580, it would become 851. Note that leading zeros are removed. After such a turn, the number of elements in the list does not change."

"on his turn, Sasha must extract two elements a_i and a_j (i â‰  j) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to 2007 and 19, he would remove these two elements from the list and add the integer 200719 or 192007. After such a turn, the number of elements in the list decreases by 1."

"Players can't skip turns. The game ends when Sasha can't make a move, i.e. after Anna's move there is exactly one number left in the list. If this integer is not less than 10^m (i.e., >=10^m), Sasha wins. Otherwise, Anna wins."

So, the game proceeds as follows:

- Anna reverses one number.

- Then Sasha concatenates two numbers.

- Repeat until only one number remains.

- Anna makes (n-1) reverses, and Sasha makes (n-1) concatenations.

But in the case where n=4, m=5, a=[10,10,10,10]:

- Anna reverses one number, say 10 to 1.

- List: [1,10,10,10]

- Sasha concatenates two numbers, say 10 and 10 to make 1010 or 1010.

- Suppose he chooses 1010.

- List: [1,1010,10]

- Anna reverses another number, say 10 to 1.

- List: [1,1010,1]

- Sasha concatenates two numbers, say 1 and 1 to make 11 or 11.

- Wait, but the list has 1,1010,1.

- Wait, Anna reversed 10 to 1, so list is [1,1010,1].

- Sasha concatenates two of them, say 1 and 1 to make 11.

- List: [1010,11]

- Anna reverses another number, say 1010 to 0101 (101).

- List: [101,11]

- Sasha concatenates 101 and 11 to make 10111 or 11101.

- The larger one is 11101, which is greater than 100000.

- So, Sasha wins.

Alternatively, Anna could choose different reverses.

But in any case, it seems that Sasha can choose the concatenation order to make the final number larger than 100000.

Hence, Sasha wins.

So, perhaps in this case, Anna cannot force a win.

I need to adjust my earlier reasoning.

So, perhaps Anna can only reverse (n-1) numbers, not n numbers.

Because she makes (n-1) moves.

In the case where n=4, she can reverse three numbers.

So, she can't reverse all four to 1.

Hence, Sasha can win.

Okay, now I need to generalize this.

It seems that Anna can reverse (n-1) numbers.

So, she can choose which (n-1) numbers to reverse.

Wait, no.

Wait, in the game, Anna reverses one number per move, and there are (n-1) moves.

But in each move, she can choose any one number to reverse.

So, she can reverse the same number multiple times, but since reversing twice brings it back to original, effectively she can choose to reverse any subset of the numbers.

Wait, no, because reversing twice brings it back to original, so effectively she can choose to reverse any (up to n-1) numbers.

But in practice, she can reverse any subset of the numbers.

So, perhaps I can consider that Anna can choose to reverse any subset of the numbers, and Sasha concatenates them in the best possible order.

Then, Anna wants to choose which subset to reverse to minimize the final concatenated number.

Then, compare it to 10^m to determine who wins.

So, to implement this, I need to:

- For each number, compute its reversed version and choose whether to reverse it or not to minimize the final concatenated number.

- Then, sort the chosen numbers in descending order and concatenate them.

- If the final number is less than 10^m, Anna wins; else, Sasha wins.

So, in code, for each test case:

- Read n, m.

- Read the list a.

- For each a_i, compute its reverse without leading zeros.

- For each a_i, choose to keep it as a_i or its reverse, whichever is smaller.

- Sort the chosen numbers in descending order.

- Concatenate them into a single number.

- If this number is less than 10^m, Anna wins; else, Sasha wins.

Wait, but in the earlier example where n=4, m=5, a=[10,10,10,10], if Anna chooses to reverse three 10's to 1, and leaves one as 10, then the numbers are [1,1,1,10], sorted descending as [10,1,1,1], concatenated as 10111, which is less than 100000, so Anna wins.

But according to the sample output, it's "Sasha", meaning Sasha wins.

So, perhaps my approach is incorrect.

Wait, perhaps I need to consider that Anna can only reverse (n-1) numbers, not up to n numbers.

So, with n=4, she can reverse three numbers.

So, she can't reverse all four to 1.

Hence, in the sample input, it's "Sasha".

Wait, but in my earlier manual calculation, if Anna reverses three 10's to 1, and leaves one as 10, the final number is 10111, which is less than 100000, so Anna wins.

But according to the sample output, it's "Sasha".

So, perhaps I'm missing something.

Wait, perhaps the problem is that Anna can choose which numbers to reverse, but Sasha can choose the concatenation order to maximize the final number.

So, perhaps in some way, Sasha can force a larger number.

Wait, but in this specific case, even if Sasha chooses to concatenate in a different order, 10111 is the same as 10111.

Wait, maybe I'm missing something.

Alternatively, perhaps I need to consider that Anna can only reverse (n-1) numbers, but in reality, she can choose which numbers to reverse, up to (n-1) times.

So, in n=4, she can reverse any three numbers.

But in this case, she can choose to reverse three 10's to 1, leaving one as 10, leading to 10111, which is less than 100000.

Hence, Anna wins.

But according to the sample output, it's "Sasha".

So, perhaps there's a mistake in my reasoning.

Wait, perhaps I need to consider that Anna's reverses are interleaved with Sasha's concatenations.

So, the order of operations matters.

Let me try to simulate the game for n=4, m=5, a=[10,10,10,10].

- Anna reverses one 10 to 1. List: [1,10,10,10]

- Sasha concatenates two 10's to make 1010. List: [1,1010,10]

- Anna reverses another 10 to 1. List: [1,1010,1]

- Sasha concatenates 1 and 1 to make 11. List: [1010,11]

- Anna reverses 1010 to 101. List: [101,11]

- Sasha concatenates 101 and 11 to make 10111 or 11101. He chooses 11101, which is greater than 100000, so Sasha wins.

So, in this case, Anna cannot force a win.

Hence, Sasha wins.

So, perhaps my earlier approach is incorrect.

Alternative approach:

- Anna can choose to reverse any (n-1) numbers.

- Sasha concatenates the numbers in a way that maximizes the final number.

- Anna wants the final number to be as small as possible.

So, Anna chooses which (n-1) numbers to reverse to minimize the maximal concatenation that Sasha can achieve.

This is still complex.

Perhaps I can consider that Anna can reverse any (n-1) numbers, and Sasha concatenates them in descending order.

So, Anna wants to choose which (n-1) numbers to reverse such that, when the numbers are sorted in descending order and concatenated, the final number is as small as possible.

Then, compare it to 10^m.

But this is still tricky to implement.

An alternative