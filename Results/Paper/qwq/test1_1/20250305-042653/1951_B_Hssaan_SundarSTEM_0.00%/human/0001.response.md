Alright, I have this problem to solve. Let's understand it step by step.

So, there are n cows with unique ratings, each in a specific position from 1 to n. The tournament works by starting with a match between the first two cows, and then the winner continues to match against the next cow in line, and so on, until all cows have been matched. The cow with the higher rating always wins.

I own cow k, and I want to maximize the number of wins this cow gets. I have the option to swap my cow with any other cow once, or choose not to swap at all.

First, I need to simulate the tournament to see how many wins my cow can get in different scenarios.

Let's think about the initial setup without any swaps. My cow is in position k. The tournament proceeds as follows:

1. Match between position 1 and 2.

2. The winner matches against position 3.

3. This continues until all cows have been matched.

In each match, the cow with the higher rating wins.

If I don't swap, I can track how many wins my cow gets in this sequence.

But I have the option to swap my cow with any other cow once. So, I need to consider all possible swaps and find out which swap maximizes the number of wins for my cow.

This seems computationally intensive if n is large, considering t test cases up to 10^4 and n up to 10^5 per test case. So, I need an efficient way to calculate this.

Let me consider the properties of the tournament:

- The tournament is a sequence of matches where the winner continues.

- The highest-rated cow will always win against any lower-rated cow.

- So, the number of wins my cow can get depends on how many cows with lower ratings it can encounter before facing a higher-rated cow.

If I place my cow in a position where it can sequentially defeat lower-rated cows and then lose to a higher-rated one, that would be optimal.

Wait, but I can only swap once. So, I need to choose the best position to place my cow to maximize its wins.

Alternatively, perhaps it's better to bring a higher-rated cow to an earlier position to help my cow get more wins indirectly.

But the problem states that I can only swap my cow with another cow once, or choose not to swap.

So, I need to consider the impact of swapping my cow to a different position and see how many wins it can achieve.

Let me try to formalize this.

Let’s denote:

- My cow has rating a_k.

- Original positions: 1 to n with ratings a_1, a_2, ..., a_n.

Option 1: Do not swap.

Simulate the tournament and count how many wins my cow gets in its original position.

Option 2: Swap my cow with another cow.

After swapping, simulate the tournament and count how many wins my cow gets in the new position.

I need to choose the option that gives the maximum number of wins for my cow.

But simulating the tournament for each possible swap is too slow for the given constraints.

I need a smarter way to calculate the number of wins for my cow in any position.

Let’s think about how the tournament progresses.

The first match is between position 1 and 2.

The winner then faces position 3, and so on.

So, the sequence of matches is determined by the positions.

If I place my cow in position p, then I need to see how many wins it can achieve starting from position p.

But this is not straightforward because the opponent in each match is the winner of the previous match.

This seems complicated.

Maybe I can think in terms of the path my cow takes in the tournament.

Wait, perhaps I can model this as a single-elimination tournament bracket.

But in this problem, it's a bit different because the matches are sequential, each time the winner faces the next cow in line.

This is similar to a tournament where the winner advances to the next round.

In such a setup, the number of wins a cow can achieve is equal to the number of cows with lower ratings that come before it in the sequence, until it faces a cow with a higher rating.

Wait, but the sequence is important here.

Let me consider that my cow needs to face cows with lower ratings to win, and the moment it faces a cow with a higher rating, it loses.

So, in its original position, I can calculate how many wins it gets by counting how many cows with lower ratings are after it, until it faces a cow with a higher rating.

But if I swap it with another cow, I need to consider the new position and repeat the same logic.

Wait, but I need to consider that the sequence of matches affects the opponents my cow faces.

This seems tricky.

Let me consider a different approach.

Suppose I fix the position of my cow, say position p.

Then, the tournament proceeds as follows:

- Match 1: position 1 vs position 2, winner advances.

- Match 2: winner of match 1 vs position 3.

- ...

- Continue until all cows have been matched.

I need to find out how many wins my cow can achieve starting from position p.

To maximize the number of wins, I need to ensure that my cow faces as many cows with lower ratings as possible before facing a cow with a higher rating.

So, if I place my cow in position p, I need to see how many cows with lower ratings are in positions 1 to p-1, and in what order they are arranged.

This is getting complicated.

Let me look at the example provided.

In the first test case:

n=6, k=1

a = [12,10,14,11,8,3]

It says that it's optimal to do nothing, and the cow wins 1 match.

Let's simulate:

Original positions: [12,10,14,11,8,3]

Match 1: 12 vs 10, 12 wins.

Match 2: 12 vs 14, 14 wins.

Match 3: 14 vs 11, 14 wins.

Match 4: 14 vs 8, 14 wins.

Match 5: 14 vs 3, 14 wins.

So, my cow (12) only wins one match.

In the second test case:

n=6, k=5

a = [7,2,727,10,12,13]

It's optimal to swap cow k (12) to position 3.

After swap: [7,2,12,727,10,13]

Match 1: 7 vs 2, 7 wins.

Match 2: 7 vs 12, 12 wins.

Match 3: 12 vs 727, 727 wins.

Match 4: 727 vs 10, 727 wins.

Match 5: 727 vs 13, 727 wins.

So, my cow (12) wins 2 matches.

Another option could be to swap to other positions, but apparently, swapping to position 3 gives the maximum wins.

In the third test case:

n=2, k=2

a = [1000000000,1]

It's optimal to do nothing.

Match 1: 1000000000 vs 1, 1000000000 wins.

So, my cow (1) loses immediately, with 0 wins.

If I swap, position becomes [1,1000000000], then match 1:1 vs 1000000000, 1000000000 wins. Still 0 wins for my cow.

So, in this case, swapping doesn't help.

From these examples, it seems that swapping my cow to a position where it can face and defeat cows with lower ratings before facing higher-rated cows can increase its wins.

But how to generalize this?

Let me think about the tournament flow.

The tournament is a sequence of matches where:

- Match 1: position 1 vs position 2.

- Match 2: winner of match 1 vs position 3.

- ...

- Match n-1: winner of match n-2 vs position n.

So, effectively, it's like a linked list where each match is a step forward, and the winner advances to the next match.

In this setup, the number of wins my cow can achieve depends on its rating and its position in the sequence.

If I place my cow in position p, then it will first play against the winner of the previous matches.

To maximize its wins, I need to place it in a position where the winner of the previous matches has a lower rating than my cow, and this should happen as many times as possible.

Wait, but the winner of previous matches is the highest-rated cow among the previous matches.

So, perhaps I need to place my cow in a position where the previous winner has a lower rating than my cow.

But this seems tricky to calculate directly.

Let me consider that if I place my cow in position p, then it will play against the winner of the first p-1 matches.

So, if the winner among the first p-1 cows has a lower rating than my cow, my cow will win that match.

Then, it will proceed to play against position p+1, and so on, as long as it keeps winning.

So, the number of wins my cow can achieve in position p is equal to the number of cows with lower ratings in positions p+1 to n, until it faces a cow with a higher rating.

Wait, no.

Actually, after winning against the winner of the first p-1 matches, it then plays against position p+1.

But the winner of the first p-1 matches is the highest-rated among the first p-1 cows.

So, if my cow's rating is higher than that, it wins the first match.

Then, it plays against position p+1.

If my cow's rating is higher than position p+1, it wins again, and so on.

So, the number of wins is equal to the number of consecutive cows after position p that have lower ratings than my cow, plus one for defeating the winner of the first p-1 matches, provided that my cow's rating is higher than the winner of the first p-1 matches.

This seems a bit messy.

Let me try to formalize it.

Define:

- Let W(p) be the number of wins my cow achieves if placed in position p.

- Let M(p) be the maximum rating among the first p-1 cows.

Then,

- If a_k > M(p), my cow wins the first match.

- Then, it plays against position p+1, p+2, ..., n, winning each match as long as a_k > a_{p+i}.

- So, the number of wins is 1 (for beating M(p)) plus the number of consecutive cows after p with ratings less than a_k.

- But, if a_k <= M(p), my cow doesn't win any matches.

So, W(p) = 0 if a_k <= M(p)

Else, W(p) = 1 + L(p), where L(p) is the maximum number of consecutive cows starting from p+1 with a_i < a_k.

I need to find the maximum W(p) over all possible p (from 1 to n).

Additionally, I need to consider the original position without swapping, which is equivalent to p=k.

Wait, but in the problem, k is the initial position, and I can choose to swap with any other cow, or choose not to swap.

So, in terms of choosing p, p can be any position from 1 to n, but with the constraint that only my cow can be moved to that position by swapping with the cow in that position.

Wait, no.

Actually, I can choose to swap my cow with any other cow, meaning I can place my cow in any position by swapping it with the cow in that position.

So, effectively, I can choose p to be any position from 1 to n, and place my cow there, replacing the cow that was originally there.

Therefore, I need to consider W(p) for all p from 1 to n, and choose the maximum W(p).

But calculating W(p) for each p separately would be inefficient for large n.

I need a smarter way to compute this.

Let me consider precomputing some values.

First, precompute M(p), the maximum rating among the first p-1 cows for each p from 1 to n.

Similarly, precompute L(p), the number of consecutive cows after position p with ratings less than a_k.

Then, for each p, W(p) = 0 if a_k <= M(p), else W(p) = 1 + L(p).

Finally, the answer is the maximum W(p) over all p from 1 to n.

This seems feasible.

Let me think about how to compute M(p) and L(p) efficiently.

For M(p):

- M(1) = 0 (no previous cows)

- M(p) = max(a_1, a_2, ..., a_{p-1}) for p >= 2

I can compute M(p) for all p in O(n) time by keeping a running maximum.

Similarly, for L(p):

- L(p) = length of the largest suffix starting at p+1 where a_i < a_k

I can precompute this by iterating from p=n downto 1 and keeping a count of consecutive a_i < a_k.

Wait, but this needs to be done for each p, which seems O(n^2). That's too slow.

Wait, no, I can precompute L(p) for all p in O(n) time.

Let me store a list where L[p] = number of consecutive cows starting from p+1 with a_i < a_k.

I can compute this by iterating from p=n downto 1, and if a_{p+1} < a_k, then L[p] = 1 + L[p+1], else L[p] = 0.

This way, L[p] is computed in O(n) time.

Similarly, M(p) can be computed in O(n) time by keeping a running maximum from p=1 to n.

Then, for each p, W(p) = 0 if a_k <= M(p), else W(p) = 1 + L(p).

Finally, the answer is the maximum W(p) over all p from 1 to n.

This seems efficient enough, as it runs in O(n) time per test case, and n <= 10^5, t <= 10^4, but the sum of n over all test cases does not exceed 10^5, so it should be acceptable.

Wait, but in the code provided, it seems to be doing something different.

Let me look at the given code:

def func():

for _ in range(int(input())):

(n, k) = list(map(int, input().split()))

s = list(map(int, input().split()))

(s[0], s[k - 1]) = (s[k - 1], s[0])

ans = 0

h = s[0]

j = -1

for i in s[1:]:

j += 1

if h < i:

break

else:

ans += 1

p = j

(s[0], s[k - 1]) = (s[k - 1], s[0])

ans1 = 0

(s[p], s[k - 1]) = (s[k - 1], s[p])

z = 0

for i in s:

if i == h:

if s[0] != h:

ans1 += 1

z = 1

elif i > h:

break

elif z == 1:

ans1 += 1

print(max(ans, ans1))

This code is trying to simulate two scenarios and take the maximum of the two.

First, it swaps s[0] and s[k-1], then counts how many wins the cow in position 0 gets until it loses.

Then, it swaps back s[0] and s[k-1], and swaps s[p] and s[k-1], where p is the position where the first loss occurred in the first simulation.

Then, it counts how many wins the cow in position 0 gets in this new arrangement.

Finally, it prints the maximum of ans and ans1.

This seems like an attempt to consider two different swap scenarios, but it's not clear if this covers all possible optimal swaps.

I'm not entirely sure if this code correctly implements the logic I described earlier.

Let me try to see if this code matches my logic.

In my logic, I suggested precomputing M(p) and L(p) for all p, then finding the maximum W(p) over all p.

But in the given code, it seems to be considering only two specific swaps:

1. Swapping my cow to position 1 (s[0]).

2. Swapping my cow to the position where it lost in the first simulation.

Then, it takes the maximum of wins in these two scenarios.

But according to my earlier reasoning, I need to consider all possible positions p to swap my cow to, not just position 1 and one other position.

Therefore, this code might not be considering all possible optimal swaps.

Let me check the first test case:

n=6, k=1

a = [12,10,14,11,8,3]

In the code:

Swap s[0] and s[0], which is doing nothing.

Then, h = s[0] = 