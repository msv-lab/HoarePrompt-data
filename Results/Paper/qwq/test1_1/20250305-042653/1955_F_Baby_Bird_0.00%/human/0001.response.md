Alright, I've got this problem to solve. Let's see what it's about. So, there are n integers in a sequence, each of which is at most 4. Alice and Bob are playing a game where they look at the bitwise XOR of all the numbers in the sequence. If the XOR is non-zero, Alice wins; otherwise, Bob wins. After each game, Eve removes one number from the sequence, and they play again with the remaining numbers. This continues until there are no numbers left. Eve wants to maximize the number of times Bob wins.

First, I need to understand the XOR operation. XOR is a bitwise operation where the result is 1 if the bits are different and 0 if they are the same. For a sequence of numbers, the XOR is the bitwise XOR of all of them.

Given that each number in the sequence is at most 4, the possible numbers are 0, 1, 2, 3, 4. But according to the input, it's 0-based, meaning p_i represents the count of numbers i in the sequence. So, p0 is the count of 0s, p1 of 1s, p2 of 2s, p3 of 3s, and p4 of 4s.

Wait, but in the problem statement, it says "the number of ones, twos, threes, and fours in the sequence at the beginning of the game." So, p0 is the count of 1s, p1 is the count of 2s, p2 is the count of 3s, and p3 is the count of 4s. No, that doesn't make sense. Let me read it again.

"each integer of the sequence doesn't exceed 4 . The rules of the game are too complex to describe, so let's just describe the winning condition — Alice wins if the [bitwise XOR](http://tiny.cc/xor_wiki_eng) of all the numbers in the sequence is non-zero; otherwise, Bob wins.

The guys invited Eve to act as a judge. Initially, Alice and Bob play with n numbers. After one game, Eve removes one of the numbers from the sequence, then Alice and Bob play with n-1 numbers. Eve removes one number again, after which Alice and Bob play with n - 2 numbers. This continues until the sequence of numbers is empty.

Eve seems to think that in such a game, Alice almost always wins, so she wants Bob to win as many times as possible. Determine the maximum number of times Bob can win against Alice if Eve removes the numbers optimally.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4 ) — the number of test cases.

The first and only line of each test case contains four integers p_i (0 ≤ p_i ≤ 200 ) — the number of ones, twos, threes, and fours in the sequence at the beginning of the game.

Output

For each test case, print the maximum number of times Bob will win in a separate line, if Eve removes the numbers optimally.

Example

Input

5

1 1 1 0

1 0 1 2

2 2 2 0

3 3 2 0

0 9 9 9

Output

1

1

3

3

12

Note

In the first example, Bob wins when Eve has not removed any numbers yet.

In the second example, Bob wins if Eve removes one one and one three.

"

Wait, actually, the problem says "the number of ones, twos, threes, and fours in the sequence at the beginning of the game." So, p0 is the count of 1s, p1 is the count of 2s, p2 is the count of 3s, and p3 is the count of 4s.

But in the sample input, the first test case is "1 1 1 0", which means one 1, one 2, one 3, and zero 4s. So, the sequence is [1,2,3].

We need to compute the XOR of the sequence: 1 XOR 2 XOR 3 = (1 XOR 2) XOR 3 = (01 XOR 10) XOR 11 = (11) XOR 11 = 00. So, XOR is 0, which means Bob wins this game.

Then, Eve removes one number. Let's say she removes 1, so the sequence becomes [2,3]. XOR is 2 XOR 3 = 1 XOR 11 = 10, which is 2, non-zero, so Alice wins.

If she removes 2, sequence is [1,3]. XOR is 1 XOR 3 = 2, Alice wins.

If she removes 3, sequence is [1,2]. XOR is 1 XOR 2 = 3, Alice wins.

So, no matter which number Eve removes, Alice wins the next game. Then, Eve removes another number, and so on.

So, in this case, Bob wins only once, which is when no number is removed.

Similarly, in the second test case, "1 0 1 2", which is one 1, zero 2s, one 3, and two 4s. So, the sequence is [1,3,4,4].

XOR of [1,3,4,4] is 1 XOR 3 XOR 4 XOR 4 = (1 XOR 3) XOR (4 XOR 4) = 2 XOR 0 = 2, which is non-zero, so Alice wins.

Then, Eve removes one number. To make Bob win, she needs to make the XOR zero.

Possible removals:

- Remove 1: [3,4,4]. XOR: 3 XOR 4 XOR 4 = 3 XOR 0 = 3, Alice wins.

- Remove 3: [1,4,4]. XOR: 1 XOR 4 XOR 4 = 1 XOR 0 = 1, Alice wins.

- Remove 4: [1,3,4]. XOR: 1 XOR 3 XOR 4 = 2 XOR 4 = 6, Alice wins.

- Remove another 4: same as above.

So, in this case, Bob cannot win any game if Eve removes any number.

But according to the sample output, it's 1, meaning Bob wins once. Wait, but in the note, it says "In the second example, Bob wins if Eve removes one one and one three."

Wait, let's see:

Initial sequence: [1,3,4,4]

Eve removes one number, say 1: [3,4,4]. XOR: 3 XOR 4 XOR 4 = 3 XOR 0 = 3, Alice wins.

Eve removes another number, say 3: [4,4]. XOR: 4 XOR 4 = 0, Bob wins.

So, in this case, Bob wins when two numbers are removed, leaving [4,4], XOR is 0.

So, Bob wins once in this scenario.

Similarly, in the first test case, Bob wins only once, when no number is removed.

In the third test case, "2 2 2 0", which is two 1s, two 2s, two 3s, and zero 4s. Sequence: [1,1,2,2,3,3].

XOR: 1 XOR 1 XOR 2 XOR 2 XOR 3 XOR 3 = (1 XOR 1) XOR (2 XOR 2) XOR (3 XOR 3) = 0 XOR 0 XOR 0 = 0, so Bob wins.

Then, Eve removes one number, say 1: [1,2,2,3,3]. XOR: 1 XOR 2 XOR 2 XOR 3 XOR 3 = (1 XOR 2) XOR (2 XOR 3) XOR 3 = (3 XOR 1) XOR 3 = 2 XOR 3 = 1, Alice wins.

Then, remove another number, say 2: [1,2,3,3]. XOR: 1 XOR 2 XOR 3 XOR 3 = (1 XOR 2) XOR (3 XOR 3) = 3 XOR 0 = 3, Alice wins.

Then, remove another number, say 3: [1,2,3]. XOR: 1 XOR 2 XOR 3 = 0, Bob wins.

Then, remove another number, say 1: [2,3]. XOR: 2 XOR 3 = 1, Alice wins.

Then, remove 2: [3]. XOR: 3, Alice wins.

Finally, remove 3: empty sequence, XOR is 0, Bob wins.

So, Bob wins three times: when no number is removed, when three numbers are removed, and when six numbers are removed.

Hence, the output is 3.

Similarly, in the fourth test case, "3 3 2 0", which is three 1s, three 2s, two 3s, and zero 4s. Sequence: [1,1,1,2,2,2,3,3].

XOR: 1 XOR 1 XOR 1 XOR 2 XOR 2 XOR 2 XOR 3 XOR 3 = (1 XOR 1 XOR 1) XOR (2 XOR 2 XOR 2) XOR (3 XOR 3) = (1) XOR (2) XOR (0) = 3, Alice wins.

Then, Eve removes one number, say 1: [1,1,2,2,2,3,3]. XOR: 1 XOR 1 XOR 2 XOR 2 XOR 2 XOR 3 XOR 3 = (1 XOR 1) XOR (2 XOR 2 XOR 2) XOR (3 XOR 3) = (0) XOR (2) XOR (0) = 2, Alice wins.

Remove another 1: [1,2,2,2,3,3]. XOR: 1 XOR 2 XOR 2 XOR 2 XOR 3 XOR 3 = (1 XOR 2) XOR (2 XOR 2) XOR (3 XOR 3) = (3 XOR 0) XOR 0 = 3, Alice wins.

Remove another 2: [1,2,2,3,3]. XOR: 1 XOR 2 XOR 2 XOR 3 XOR 3 = (1 XOR 2) XOR (2 XOR 3) XOR 3 = (3 XOR 1) XOR 3 = 2 XOR 3 = 1, Alice wins.

Remove another 2: [1,2,3,3]. XOR: 1 XOR 2 XOR 3 XOR 3 = (1 XOR 2) XOR (3 XOR 3) = 3 XOR 0 = 3, Alice wins.

Remove another 3: [1,2,3]. XOR: 1 XOR 2 XOR 3 = 0, Bob wins.

Remove another 3: [1,2]. XOR: 1 XOR 2 = 3, Alice wins.

Finally, remove 1: [2]. XOR: 2, Alice wins.

So, Bob wins only once in this case, but the sample output is 3. Wait, maybe I miscalculated.

Wait, three 1s, three 2s, two 3s. Total numbers: 3+3+2=8.

So, sequences from 8 numbers down to 0.

Bob wins when the XOR is zero.

Initial XOR is 1 XOR 1 XOR 1 XOR 2 XOR 2 XOR 2 XOR 3 XOR 3 = 1 XOR 1 XOR 1 XOR 2 XOR 2 XOR 2 XOR 3 XOR 3.

As I calculated before, it's 3, Alice wins.

Then, after removing one number, various possibilities, but in one of the steps, when three numbers are removed, XOR is zero, Bob wins.

Similarly, when six numbers are removed, XOR is zero, Bob wins again.

And when all eight numbers are removed, XOR is zero, Bob wins again.

So, total of three times Bob wins.

Hence, the output is 3.

Similarly, in the fifth test case, "0 9 9 9", which is zero 1s, nine 2s, nine 3s, and nine 4s. Sequence: [2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4].

Total numbers: 9+9+9=27.

We need to find how many times Bob can win, i.e., how many times the XOR of the remaining numbers is zero, with optimal removal by Eve.

The output is 12, meaning Bob wins 12 times.

Now, I need to find a general way to calculate the maximum number of times Bob can win for any given p0, p1, p2, p3, representing the counts of 1,2,3,4 respectively.

First, I need to understand the XOR of the sequence.

Given that each number is 1,2,3,4, and their counts are p0, p1, p2, p3.

First, let's note the binary representations:

1: 01

2: 10

3: 11

4: 100

Wait, but in the problem, it says each integer doesn't exceed 4, but in binary, 4 is 100, which has three bits. So, we need to consider XOR in terms of bitwise operations.

But since the numbers are small, we can consider the XOR of the sequence based on their counts.

Let me think differently. Since XOR is associative and commutative, the order of removal doesn't matter, only which numbers are removed.

Eve removes one number at a time, and after each removal, Alice and Bob play with the remaining numbers.

Eve wants to maximize the number of times Bob wins, which means maximizing the number of times the XOR of the remaining numbers is zero.

So, Eve can choose which number to remove at each step to make the XOR zero for that step.

Wait, but in the sample explanations, it seems that Eve needs to remove numbers in a sequence, and after each removal, check the XOR of the remaining numbers.

But actually, Eve removes one number, then another, and so on, each time playing with the remaining numbers.

But in terms of maximizing Bob's wins, Eve wants to choose which number to remove at each step to make the XOR zero as often as possible.

But it's not clear if Eve can choose which number to remove at each step based on the current sequence or not.

Wait, the problem says: "Eve removes one of the numbers from the sequence, then Alice and Bob play with n-1 numbers. Eve removes one number again, after which Alice and Bob play with n - 2 numbers. This continues until the sequence of numbers is empty."

So, Eve removes one number at a time, and after each removal, Alice and Bob play with the remaining numbers.

Eve wants to maximize the number of times Bob wins, i.e., the number of times the XOR of the remaining numbers is zero.

So, Eve can choose which number to remove at each step to maximize the number of times the XOR of the remaining numbers is zero.

This seems like a problem where we need to consider the XOR of the sequence and how it changes when we remove numbers.

Let's consider that the XOR of the entire sequence is some value X.

If X is zero, then Bob wins initially. Then, Eve removes one number, and we need to see what the new XOR is.

If Eve removes a number Y, the new XOR of the remaining numbers is X XOR Y.

So, the new XOR is X XOR Y.

Eve wants to choose Y such that X XOR Y is zero, which means Y = X.

But Y has to be one of the numbers in the sequence.

So, if X is present in the sequence, Eve can remove X to make the XOR of the remaining numbers zero.

Otherwise, she has to choose another number.

Wait, but in the first test case, [1,2,3], XOR is 0, so Bob wins initially.

Then, Eve removes one number, say 1, remaining [2,3], XOR is 2 XOR 3 = 1, which is non-zero, Alice wins.

If she removes 2, remaining [1,3], XOR is 1 XOR 3 = 2, Alice wins.

If she removes 3, remaining [1,2], XOR is 1 XOR 2 = 3, Alice wins.

So, in this case, Bob wins only once, when no number is removed.

But according to the note, in the second example, Eve can remove one 1 and one 3 to make Bob win.

Wait, in the second test case, [1,3,4,4], XOR is 1 XOR 3 XOR 4 XOR 4 = 1 XOR 3 XOR 0 = 2, which is non-zero, so Alice wins initially.

Then, Eve removes one number.

If she removes 1, remaining [3,4,4], XOR is 3 XOR 4 XOR 4 = 3 XOR 0 = 3, Alice wins.

If she removes 3, remaining [1,4,4], XOR is 1 XOR 4 XOR 4 = 1 XOR 0 = 1, Alice wins.

If she removes 4, remaining [1,3,4], XOR is 1 XOR 3 XOR 4 = 2 XOR 4 = 6, Alice wins.

If she removes another 4, same as above.

So, in this case, Bob cannot win any game except possibly when two numbers are removed.

Wait, in the note, it says "In the second example, Bob wins if Eve removes one one and one three."

Wait, if Eve removes one 1 and one 3, remaining [4,4], XOR is 4 XOR 4 = 0, Bob wins.

But according to the problem, Eve removes one number at a time, so in the first removal, she removes one number, then play with n-1 numbers, then removes another number, and plays with n-2 numbers, and so on.

So, in the second test case, starting with [1,3,4,4], XOR is 2, Alice wins.

Then, Eve removes one number, say 1, remaining [3,4,4], XOR is 3, Alice wins.

Then, Eve removes another number, say 3, remaining [4,4], XOR is 0, Bob wins.

So, in this case, Bob wins once, when two numbers are removed.

But according to the sample output, it's 1, which matches.

Wait, but in the explanation, it says "Bob wins if Eve removes one one and one three", but in practice, Eve removes one number at a time, and in the second removal, she can choose another number.

So, in this case, Bob wins only once, when two numbers are removed.

In the third test case, [1,1,2,2,3,3], XOR is 0, Bob wins.

Then, Eve removes one number, say 1, remaining [1,2,2,3,3], XOR is 3, Alice wins.

Then, remove another number, say 2, remaining [1,2,3,3], XOR is 3, Alice wins.

Then, remove another number, say 3, remaining [1,2,3], XOR is 0, Bob wins.

Then, remove another number, say 1, remaining [2,3], XOR is 1, Alice wins.

Then, remove another number, say 2, remaining [3], XOR is 3, Alice wins.

Then, remove the last number, empty sequence, XOR is 0, Bob wins.

So, Bob wins three times: when no number is removed, when three numbers are removed, and when six numbers are removed.

Hence, the output is 3.

Similarly, in the fourth test case, [1,1,1,2,2,2,3,3], XOR is 3, Alice wins.

Then, remove one number, say 1, remaining [1,1,2,2,2,3,3], XOR is 2, Alice wins.

Then, remove another 1, remaining [1,2,2,2,3,3], XOR is 3, Alice wins.

Then, remove another 2, remaining [1,2,2,3,3], XOR is 1, Alice wins.

Then, remove another 2, remaining [1,2,3,3], XOR is 3, Alice wins.

Then, remove another 3, remaining [1,2,3], XOR is 0, Bob wins.

Then, remove another 3, remaining [1,2], XOR is 3, Alice wins.

Then, remove another 1, remaining [2], XOR is 2, Alice wins.

Finally, remove the last number, empty sequence, XOR is 0, Bob wins.

So, Bob wins three times: initially (when no number is removed, but XOR is 3, Alice wins), after removing four numbers ([1,2,3], XOR is 0), and after removing all eight numbers (empty sequence, XOR is 0).

Wait, but according to the earlier analysis, Bob wins when no number is removed if XOR is zero, but in this case, initial XOR is 3, which is non-zero, so Alice wins.

So, Bob only wins when four numbers are removed and when eight numbers are removed.

Hence, two times, but the sample output is 3.

Wait, perhaps I miscalculated the initial XOR.

Let me recalculate the initial XOR for the fourth test case: three 1s, three 2s, two 3s.

XOR: 1 XOR 1 XOR 1 XOR 2 XOR 2 XOR 2 XOR 3 XOR 3.

Grouping: (1 XOR 1 XOR 1) XOR (2 XOR 2 XOR 2) XOR (3 XOR 3).

1 XOR 1 = 0, 0 XOR 1 = 1.

2 XOR 2 = 0, 0 XOR 2 = 2.

3 XOR 3 = 0.

So, total XOR is 1 XOR 2 XOR 0 = 3.

So, Alice wins initially.

Then, after removing some numbers, Bob can win when four numbers are removed and when eight numbers are removed.

So, two times, but sample output is 3.

Wait, maybe I missed one.

Wait, when no number is removed, XOR is 3, Alice wins.

After removing one number, various possibilities, but XOR is non-zero.

After removing two numbers, possible XOR is non-zero.

After removing three numbers, possible XOR is non-zero.

After removing four numbers, XOR is zero, Bob wins.

After removing five numbers, XOR is non-zero.

After removing six numbers, XOR is zero, Bob wins.

After removing seven numbers, XOR is non-zero.

After removing eight numbers, XOR is zero, Bob wins.

So, Bob wins three times: when four, six, and eight numbers are removed.

Hence, the output is 3.

Got it.

So, the task is to count how many times the XOR of the remaining sequence is zero, for each step from n down to 0, with optimal removal by Eve to maximize Bob's wins.

But in practice, since Eve can choose which number to remove at each step, we need to find a way to maximize the number of times the XOR of the remaining sequence is zero.

This seems tricky because it depends on the sequence of removals.

But perhaps there is a smarter way to calculate this based on the counts of each number and their XOR contributions.

Let's consider that the XOR of the sequence is the XOR of the counts of each number's XOR value.

Wait, no. The XOR of a sequence is the XOR of all individual numbers in the sequence.

Given that each number is 1,2,3,4, and we have their counts p0, p1, p2, p3.

First, let's compute the XOR of the entire sequence.

Since XOR is associative and commutative, we can compute it by XORing all the numbers together.

Given that, we can compute the total XOR as (1 XOR 1 XOR ... p0 times) XOR (2 XOR 2 XOR ... p1 times) XOR (3 XOR 3 XOR ... p2 times) XOR (4 XOR 4 XOR ... p3 times).

But since XOR of a number with itself is zero, and XOR is associative, we can simplify this.

For any number that appears an even number of times, its XOR contribution is zero.

For any number that appears an odd number of times, its XOR contribution is the number itself.

So, the total XOR is the XOR of all numbers that appear an odd number of times.

Hence, we can compute the total XOR by XORing the numbers that have odd counts.

So, if p0 is odd, include 1; if p1 is odd, include 2; if p2 is odd, include 3; if p3 is odd, include 4.

Then, total XOR is the XOR of these included numbers.

Now, when Eve removes a number, she chooses which number to remove to maximize the number of times the remaining XOR is zero.

This seems like a problem that can be solved by considering the parity of the counts and the XOR values.

But it's still not clear how to generalize this for any number of removals.

Perhaps it's better to think in terms of the number of times the XOR can be zero during the process.

Given that, and considering that XOR is zero when the XOR of the remaining numbers is zero, which is equivalent to the XOR of the removed numbers being equal to the total XOR.

Wait, that might not be directly helpful.

Another approach is to consider that the sequence of XOR values as numbers are removed forms a certain pattern based on which numbers are removed.

But this seems too vague.

Let me look at the provided program to see if I can understand the logic behind it.

The program is:

def func():

for _ in range(int(input())):

p = list(map(lambda x: int(x) - int(x) % 2, input().split()))

print((sum(list(map(lambda x: x % 2 > 0, p[:3]))) == 3) + sum(p) // 2)

First, it reads the number of test cases.

Then, for each test case, it reads four integers, which are the counts p0, p1, p2, p3.

Then, it applies a map function to each p_i: int(x) - int(x) % 2.

Wait, int(x) is just x, since x is already an integer.

Wait, no, wait, in Python, if x is a string, int(x) converts it to an integer.

But in this case, x is a string from input(), so int(x) converts it to an integer.

Then, int(x) - int(x) % 2 means subtracting the parity of x from x.

So, if x is even, x % 2 == 0, so p_i = x - 0 = x.

If x is odd, x % 2 == 1, so p_i = x - 1 = x - 1.

So, effectively, p_i becomes the largest even number less than or equal to the original p_i.

So, p_i is set to p_i - p_i % 2, which is equivalent to p_i // 2 * 2.

So, p_i is now the even part of the original p_i.

Then, it prints the sum of whether the first three p_i (p0, p1, p2) have odd original counts (before the subtraction), and the total sum of the evenified p_i divided by 2.

Wait, let's break it down.

First, p = list(map(lambda x: int(x) - int(x) % 2, input().split()))

So, for each p_i, it reads it as an integer and subtracts its parity.

So, if p_i was even, it remains the same; if odd, it becomes even by subtracting 1.

Then, sum(list(map(lambda x: x % 2 > 0, p[:3]))) == 3

This checks if the number of p_i among p0, p1, p2 that are odd (before the subtraction) is equal to 3.

Wait, but after subtraction, p_i is evenified, so x % 2 == 0 for all p_i.

Wait, no, wait.

After subtraction, p_i is even, so p_i % 2 == 0.

Then, x % 2 > 0 would be False for all p_i, since they are even.

So, sum(list(map(lambda x: x % 2 > 0, p[:3]))) would be 0, because all p_i are even after the subtraction.

So, sum(...) == 3 would be False, which is 0.

Then, sum(p) // 2 is the sum of the evenified p_i divided by 2.

So, sum(p) is the sum of p0_even, p1_even, p2_even, p3_even.

Then, sum(p) // 2 is floor division by 2.

So, the print statement is effectively printing 0 + sum(p) // 2.

But according to the sample inputs and outputs, this seems incorrect.

Wait, let's check with the first sample input.

First test case: 1 1 1 0

After evenification: p0 = 0, p1 = 0, p2 = 0, p3 = 0

sum(p) = 0, sum(p) // 2 = 0

sum(p[:3]) % 2 > 0 is 0 % 2 > 0 ? 0 > 0 ? No.

So, (0 == 3) is False, which is 0.

Then, print(0 + 0) = 0, but the sample output is 1.

So, this doesn't match.

Wait, perhaps I misread the code.

Looking again:

print((sum(list(map(lambda x: x % 2 > 0, p[:3]))) == 3) + sum(p) // 2)

So, sum(list(map(lambda x: x % 2 > 0, p[:3]))) is sum of whether p0, p1, p2 are odd.

Wait, but p_i have been evenified, so they are all even, so x % 2 == 0, so x % 2 > 0 is False, which is 0.

So, sum(...) == 3 is checking if all three are odd, but after evenification, they are even, so sum(...) == 0.

So, (0 == 3) is False, which is 0.

Then, sum(p) // 2 is sum of evenified p_i divided by 2.

In the first test case, p_i are all evenified to 0, so sum(p) // 2 = 0.

Hence, print(0 + 0) = 0, but sample output is 1.

So, this doesn't match.

Wait, perhaps I'm misunderstanding the evenification.

Wait, no, p_i is set to p_i - p_i % 2, which makes it even.

So, if p_i was odd, p_i % 2 == 1, so p_i becomes p_i - 1, which is even.

If p_i was even, p_i % 2 == 0, so p_i remains even.

So, after evenification, p_i is always even.

Then, x % 2 > 0 for even p_i is False, so sum(...) == 0.

So, (0 == 3) is False, which is 0.

Then, sum(p) // 2 is sum of even p_i divided by 2.

In the first test case, p_i are all 0, so sum(p) // 2 = 0.

Hence, print(0 + 0) = 0, but sample output is 1.

So, this is incorrect.

Wait, maybe I need to re-express the code.

Let me see the code again:

def func():

for _ in range(int(input())):

p = list(map(lambda x: int(x) - int(x) % 2, input().split()))

print((sum(list(map(lambda x: x % 2 > 0, p[:3]))) == 3) + sum(p) // 2)

So, in the first test case, p = [1,1,1,0]

After evenification: p = [0,0,0,0]

Then, sum(p[:3]) = 0 + 0 + 0 = 0

sum(p[:3]) % 2 > 0 is 0 > 0 ? No.

So, sum(list(map(lambda x: x % 2 > 0, p[:3]))) = 0

Then, (0 == 3) is False, which is 0.

sum(p) = 0 + 0 + 0 + 0 = 0

sum(p) // 2 = 0

So, print(0 + 0) = 0, but sample output is 1.

Hence, the code is incorrect for this test case.

Wait, perhaps the intention is different.

Wait, maybe the evenification is not supposed to be applied to p_i.

Wait, perhaps it's a mistake in the code.

Alternatively, maybe it's trying to calculate something else.

Wait, perhaps it's trying to calculate the number of times Bob can win based on the parity of the counts.

But in this case, it's not working correctly.

Alternatively, perhaps the author intended to count the number of p_i that are odd before evenification.

Wait, in the first test case, p = [1,1,1,0]

Before evenification, p0=1 (odd), p1=1 (odd), p2=1 (odd), p3=0 (even).

So, sum(list(map(lambda x: x % 2 > 0, p[:3]))) is sum([1,1,1]) = 3

Then, (3 == 3) is True, which is 1.

Then, sum(p) = 1 + 1 + 1 + 0 = 3

sum(p) // 2 = 1 (since 3 // 2 = 1)

So, print(1 + 1) = 2, but sample output is 1.

So, still not matching.

Wait, perhaps the evenification is supposed to be applied after reading but before processing.

Alternatively, perhaps the evenification is a mistake.

Wait, perhaps the code is intended to be:

p = list(map(int, input().split()))

Then, sum(list(map(lambda x: x % 2 > 0, p[:3]))) == 3

Which would be sum([1,1,1]) == 3, which is True, so 1.

Then, sum(p) // 2 = (1 + 1 + 1 + 0) // 2 = 3 // 2 = 1.

So, print(1 + 1) = 2, but sample output is 1.

So, still not matching.

Hence, the code is incorrect.

Wait, but in the second test case: 1 0 1 2

sum(p[:3]) % 2 > 0: sum([1,0,1]) = 2, which is not > 0? Wait, sum(list(map(lambda x: x % 2 > 0, p[:3]))) is sum([1 % 2 > 0, 0 % 2 > 0, 1 % 2 > 0]) = sum([True, False, True]) = 2

Then, (2 == 3) is False, which is 0.

sum(p) // 2 = (1 + 0 + 1 + 2) // 2 = 4 // 2 = 2.

So, print(0 + 2) = 2, but sample output is 1.

So, incorrect again.

Similarly, third test case: 2 2 2 0

sum(p[:3]) % 2 > 0: sum([2,2,2]) = 6, which is not > 0.

So, sum(list(map(lambda x: x % 2 > 0, p[:3]))) = sum([False, False, False]) = 0

(0 == 3) is False, which is 0.

sum(p) // 2 = (2 + 2 + 2 + 0) // 2 = 6 // 2 = 3.

So, print(0 + 3) = 3, which matches the sample output.

Fourth test case: 3 3 2 0

sum(p[:3]) % 2 > 0: sum([3,3,2]) = 8, which is not > 0.

sum(list(map(lambda x: x % 2 > 0, p[:3]))) = sum([True, True, False]) = 2

(2 == 3) is False, which is 0.

sum(p) // 2 = (3 + 3 + 2 + 0) // 2 = 8 // 2 = 4.

So, print(0 + 4) = 4, but sample output is 3.

So, incorrect.

Fifth test case: 0 9 9 9

sum(p[:3]) % 2 > 0: sum([0,9,9]) = 18, which is not > 0.

sum(list(map(lambda x: x % 2 > 0, p[:3]))) = sum([False, True, True]) = 2

(2 == 3) is False, which is 0.

sum(p) // 2 = (0 + 9 + 9 + 9) // 2 = 27 // 2 = 13.

So, print(0 + 13) = 13, but sample output is 12.

So, incorrect.

Hence, the provided program does not produce the correct output for most of the sample inputs.

Therefore, the program is incorrect.

Correctness: **False**

