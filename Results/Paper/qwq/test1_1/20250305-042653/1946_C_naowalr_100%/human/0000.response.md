Alright, I've got this problem to solve. It's about trees in graph theory, which I've worked with before, but I need to make sure I understand everything correctly.

So, the problem is: Given a tree with n vertices, I need to find the maximum number x such that I can remove exactly k edges from the tree in such a way that every remaining connected component has at least x vertices.

First, I need to understand what a tree is. A tree is an undirected graph with no cycles, and it has exactly n-1 edges for n vertices. That means any two vertices are connected by exactly one path.

Now, the task is to remove exactly k edges, and after removal, all the resulting connected components should have at least x vertices, and I need to maximize x.

I need to think about how removing edges affects the connected components. Each time I remove an edge, I split the tree into two smaller trees. So, if I remove one edge, I get two connected components. If I remove a second edge, I might split one of those components further, and so on.

The goal is to remove k edges such that none of the resulting components have fewer than x vertices, and I want the largest possible x that allows this.

This sounds like a binary search problem. I can binary search on x, the minimum size of the components.

To perform the binary search, I need a way to check, for a given x, whether it's possible to remove exactly k edges such that all resulting components have at least x vertices.

So, for a given x, I need to check if removing k edges can lead to all components having at least x vertices.

How can I check this efficiently?

I think I can use a depth-first search (DFS) to traverse the tree and count the number of components that would be formed if I cut edges where the subtree size is at least x.

Wait, actually, in this problem, when I remove an edge, I split the tree into two parts. Both parts must have at least x vertices.

So, for each edge, I need to know the sizes of the two parts it would split the tree into.

If I can precompute the size of each subtree, then for each edge, I can determine if both resulting parts would have at least x vertices.

But I need to remove exactly k edges, not at most k edges.

This seems a bit tricky.

Let me think differently.

Suppose I consider all possible ways to remove k edges and check if all resulting components have at least x vertices. But that's exponential in the number of edges, which is too slow.

Given the constraints, n can be up to 10^5 per test case, and t can be up to 10^4, but the total sum of n across all test cases is up to 10^5.

So, I need an efficient way to handle this.

Binary search on x seems promising.

Let's assume I fix x and try to find the maximum number of edges I can remove such that all resulting components have at least x vertices.

If this maximum number is at least k, then x is achievable.

Otherwise, it's not.

Wait, but I need to remove exactly k edges.

Hmm.

Actually, in the problem, it's to remove exactly k edges, not at most k.

So, I need to make sure that after removing k edges, all components have at least x vertices.

I need to maximize x under this condition.

I think the correct way is to perform a binary search on x, and for each x, check if it's possible to remove exactly k edges such that all components have at least x vertices.

To check this, I need to find the maximum number of edges I can remove such that all resulting components have at least x vertices, and see if this number is at least k.

Wait, but I need to remove exactly k edges.

Wait, perhaps I need to find the minimum x such that the maximum number of edges I can remove without creating any component smaller than x is at least k.

But I need to maximize x such that I can remove exactly k edges and all components have at least x vertices.

This is a bit confusing.

Let me look at the standard approach for these kinds of problems.

In problems where you need to maximize x such that some condition holds, and the condition is monotonic, you can use binary search.

Here, if a certain x is achievable, then any smaller x should also be achievable, because removing edges that separate components of size at least x would also separate components of size at least any y < x.

So, the condition is monotonic, and binary search can be applied.

So, I can perform a binary search over x from 1 to n, and for each x, check if it's possible to remove exactly k edges such that all resulting components have at least x vertices.

Now, how to implement this check efficiently.

I think the key is to find the maximum number of edges I can remove such that all resulting components have at least x vertices, and see if this number is at least k.

If it is, then x is achievable; otherwise, it's not.

But I need to remove exactly k edges, so I need to make sure that removing more than k edges doesn't prevent me from achieving the condition.

Wait, no. I need to remove exactly k edges, not more, not less.

But in the binary search approach, I can find the maximum number of edges I can remove such that all components have at least x vertices, and if this number is at least k, then x is achievable.

Then, I can take the highest x for which this holds.

Wait, but in the problem, it's to remove exactly k edges, so I need to make sure that removing k edges satisfies the condition, not more.

Wait, perhaps I need to find the maximum x such that the minimal number of edges that need to be removed to ensure all components have at least x vertices is at most k.

But I need to remove exactly k edges.

This is getting a bit tangled.

Let me think differently.

Suppose I fix x and try to find the minimal number of edges I need to remove to ensure all components have at least x vertices.

If this minimal number is less than or equal to k, then x is achievable.

Otherwise, it's not.

But in the problem, I need to remove exactly k edges, so I need to make sure that removing k edges is sufficient to achieve the condition, but also that I remove exactly k edges.

Wait, but if I can achieve the condition by removing less than k edges, then I can remove additional edges in a way that maintains the condition.

But in this problem, I have to remove exactly k edges.

So, perhaps I need to find the maximal x such that I can remove k edges and all components have at least x vertices.

To handle this, I can perform a binary search on x, and for each x, compute the maximal number of edges I can remove such that all components have at least x vertices.

If this number is at least k, then x is achievable.

Otherwise, it's not.

Then, I take the largest x for which this holds.

Wait, but I need to remove exactly k edges, so I need to ensure that removing k edges satisfies the condition.

But if for a certain x, I can remove more than k edges without violating the condition, then removing exactly k edges should also satisfy the condition.

Because removing more edges gives me smaller components, which might make it harder to satisfy the condition.

Wait, no, removing more edges can only make it harder, because it can create smaller components.

So, if I can remove m edges such that all components have at least x vertices, and m >= k, then removing k edges will also satisfy the condition.

Because removing fewer edges can only make the components larger, which is better for satisfying the condition.

Wait, no, removing fewer edges means larger components, which have more vertices, which is better for satisfying the condition of having at least x vertices.

Wait, but I need to make sure that after removing k edges, all components have at least x vertices.

So, if I can remove m edges (m >= k) such that all components have at least x vertices, then removing k edges (which is less than m) should also satisfy the condition, because removing fewer edges leads to larger components, which have more vertices, which is better for satisfying the condition.

Wait, but this seems counterintuitive.

Actually, removing more edges can split the tree into smaller components, which might violate the condition of having at least x vertices.

So, if I can remove m edges (m >= k) such that all components have at least x vertices, does that imply that removing k edges can also satisfy the condition?

Not necessarily, because when I remove more edges, I might be forced to split components in a way that maintains the minimum component size.

But removing fewer edges might allow larger components, which is better.

Wait, I'm getting confused.

Let me think differently.

Suppose I perform a binary search on x.

For each x, I need to find the minimal number of edges to remove to ensure all components have at least x vertices.

If this minimal number is less than or equal to k, then x is achievable.

Otherwise, it's not.

Then, I take the largest x for which this holds.

Wait, but in the problem, it's to remove exactly k edges.

So, this might not be directly applicable.

Wait, perhaps I need to find the maximal x such that the minimal number of edges to remove to ensure all components have at least x vertices is less than or equal to k.

But I need to remove exactly k edges.

So, perhaps I need to find the maximal x such that I can remove at least k edges without creating any component smaller than x.

Wait, but I need to remove exactly k edges.

I think the key is that if I can remove m edges such that all components have at least x vertices, and m >= k, then I can choose to remove exactly k edges and still satisfy the condition.

Because removing more edges doesn't violate the condition; it just makes it harder.

So, if m >= k, then I can remove exactly k edges and still satisfy the condition.

Hence, in the binary search, for a given x, I compute m, the maximal number of edges I can remove such that all components have at least x vertices.

If m >= k, then x is achievable.

Otherwise, it's not.

So, I can perform a binary search on x, from 1 to n.

For each x, compute m, and check if m >= k.

Take the largest x for which m >= k.

This seems correct.

Now, how to compute m efficiently.

I need to compute the maximal number of edges I can remove such that all resulting components have at least x vertices.

In a tree, removing an edge splits the tree into two subtrees.

So, for each edge, if both resulting subtrees have at least x vertices, then I can remove that edge.

So, m is the number of edges where both resulting subtrees have at least x vertices.

Hence, I can compute the size of each subtree using DFS or BFS, and then for each edge, check if both subtrees have at least x vertices.

If they do, then I can remove that edge.

So, m is the number of edges where both subtrees have at least x vertices.

I can compute the subtree sizes using DFS.

Then, for each edge (u,v), if the subtree size of u (assuming v is the parent) is at least x and the subtree size of v is at least x, then I can remove that edge.

Wait, no.

Actually, for each edge (u,v), if the subtree size of u (assuming v is the parent) is at least x and the remaining tree size minus the subtree size of u is at least x, then I can remove that edge.

Wait, I need to be careful here.

Let's assume I remove edge (u,v), then the tree splits into two components: one containing u and one containing v.

The size of the component containing u is the subtree size of u, and the size of the component containing v is the total number of vertices minus the subtree size of u.

So, for edge (u,v), I can remove it if both the subtree size of u >= x and (n - subtree size of u) >= x.

Hence, for each edge, I can check these conditions.

So, m is the number of edges where both subtree size of u >= x and n - subtree size of u >= x.

Hence, I can compute the subtree sizes for all nodes, and then count the number of edges that satisfy these conditions.

This can be done efficiently in O(n).

Hence, for each x, I can compute m in O(n), and then check if m >= k.

Given that t can be up to 10^4, and n up to 10^5, but the total sum of n across all test cases is up to 10^5, this should be efficient enough.

Now, in the code provided, it seems to implement this idea.

Let me look at the code.

First, it sets up threading with large stack sizes, which might be necessary for deep recursion in large trees.

Then, it defines func_1, which reads t, the number of test cases, and for each test case, calls solve.

In solve:

- It reads n and k.

- Reads the tree edges and stores them in adj, an adjacency list.

- Initializes L = 1 and R = 100001.

- Performs a binary search between L and R.

- For each x in the binary search, it calls dfs(1,1), which computes the subtree sizes and counts the number of edges that can be removed.

- It sets numCuts to 0, which counts the number of edges that can be removed for the current x.

- Then, it performs the dfs starting from node 1 with parent 1.

- After dfs, it checks if numCuts > k or (numCuts == k and leftover >= x).

- If so, it sets L = x; else, R = x.

- Finally, it prints L.

In dfs(a, p):

- It computes the number of vertices in the subtree rooted at a with parent p.

- For each child b of a, if b != p, it recurses into dfs(b, a) and adds the returned vertices.

- It sets vertices = 1 + sum of dfs(b, a) for all b != p.

- If vertices >= x and a != p, it means the subtree size is at least x, and the remaining tree size is n - vertices, which should also be >= x to remove the edge (a,p).

- So, if vertices >= x and a != p, it increments numCuts and returns 0.

- Else, it returns vertices.

Wait, but in the code, it's:

if vertices >= x and a != p:

numCuts += 1

return 0

else:

return vertices

So, when vertices >= x and a != p, it increments numCuts and returns 0.

Else, it returns vertices.

This seems to correspond to the condition that if the subtree size is at least x, and a != p, then we can remove the edge (a,p), provided that the remaining tree size is at least x.

Wait, but n - vertices >= x is not being checked directly here.

Wait, perhaps it's implicitly checked.

Wait, no.

Actually, in this implementation, it's only checking if the subtree size is at least x, and assuming that the remaining tree size is at least x.

But that might not be the case.

Wait, this seems flawed.

Wait, in the condition, it's checking if vertices >= x and a != p, then numCuts +=1 and returns 0.

But it doesn't ensure that n - vertices >=x.

So, this might overcount the number of edges that can be removed.

Hence, this seems incorrect.

Wait, perhaps in the binary search, it's adjusting accordingly.

Wait, maybe not.

Let me think.

Suppose I have a tree where n=5, x=3, and k=1.

Suppose the tree is 1-2-3-4-5, a straight line.

Then, subtree sizes:

- Subtree of 1: 5

- Subtree of 2: 4

- Subtree of 3: 3

- Subtree of 4: 2

- Subtree of 5:1

Now, for x=3, let's see.

If I remove edge 2-3:

- Subtree of 2: 2 <3

- Subtree of 3:3 >=3

- But n - subtree of 3 =5-3=2 <3

So, I cannot remove edge 2-3 for x=3.

But according to the code, it would consider removing edge 2-3 because subtree of 2 is 2 <3, but actually, it shouldn't be considered.

Wait, no, in the code, it checks if vertices >=x and a !=p, then numCuts +=1.

But in this case, for edge 2-3, a=2, p=3, vertices=2 <3, so it doesn't increment numCuts.

Wait, but in this example, dfs(1,1):

- dfs(1,1): vertices=5

- dfs(2,1): vertices=4

- dfs(3,2): vertices=3

- dfs(4,3): vertices=2

- dfs(5,4): vertices=1

- return 1

- return 1+2=3

- return 3+3=6 ?? Wait, no.

Wait, in the code, it's return 0 if vertices >=x and a !=p.

Wait, in the above example, for a=3, p=2, vertices=3 >=3, so numCuts +=1 and return 0.

Then, in dfs(2,1), vertices=1 (since dfs(3,2) returns 0), which is <3, so return 1.

Then, in dfs(1,1), vertices=1 (from dfs(2,1)) + other children if any.

Wait, in this tree, 1 is connected to 2, so dfs(1,1) would have vertices=1 + dfs(2,1)=1, so vertices=2.

But n=5, so n - vertices=3 >=3.

But according to the code, it would not count the edge 1-2 because vertices=2 <3.

So, numCuts=1 (from edge 3-2), but actually, removing edge 3-2 is not valid because the subtree of 3 has size 3 >=3, but the remaining tree has size 2 <3.

Hence, for x=3, m=1, but actually, m should be 0 in this case because removing edge 3-2 violates the condition that both components have at least x=3 vertices.

So, the code seems incorrect because it doesn't check that both subtrees have at least x vertices.

It only checks that the subtree size is at least x, but not the remaining tree size.

Hence, it might overcount the number of edges that can be removed.

Therefore, the code is incorrect.

Hence, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]