Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a binary string, which means it only contains '0's and '1's. I need to find the minimum number of pieces to cut this string into, such that I can rearrange these pieces and get a sorted binary string. A sorted binary string is one where all the '0's come before any '1's. Make sense.

First, I need to understand what a "piece" is. A piece is a contiguous substring of the original string. So, if I have a string like "11010", I can cut it into pieces like "11", "0", "10", and so on. Then, I can rearrange these pieces in any order to form a new string. My goal is to have this new string be sorted, meaning all '0's first, followed by all '1's.

I need to find the minimum number of such pieces. That means I want to make as few cuts as possible, but still be able to rearrange them into a sorted string.

Let me think about how to approach this.

One way to think about it is to identify sections of the string that are already in the correct position relative to the final sorted string. In a sorted string, all '0's come before '1's. So, ideally, I want pieces that either consist entirely of '0's or entirely of '1's, and I can arrange them in the correct order.

But that might not always be possible, especially if the original string has '1's before '0's. In that case, I need to cut the string in such a way that I can rearrange the pieces to fix the order.

Let me consider some examples to get a better understanding.

Take the first test case: "11010"

I need to cut this into pieces and rearrange them to get a sorted string, which would be "00011" or something similar with all '0's before '1's.

Looking at "11010", one possible way is to cut it into "11", "0", and "10". Then, rearrange them as "0", "10", "11", which gives "01011". That's not sorted because there's a '1' after a '0', but it's not fully sorted.

Wait, maybe I need a different cutting. Let's try "110", "10". Rearrange as "10", "110", which is "10110". Still not sorted.

Another way: "1", "10", "10". Rearrange as "1", "10", "10", which is "11010". Still not sorted.

Hmm, seems like I need to cut it into more pieces.

Let's try "1", "1", "0", "1", "0". Now, rearrange as "0", "0", "1", "1", "1", which is "00111". This is sorted, but I used 5 pieces. But the sample output says 3 pieces are enough. So, I need a better way.

Let me look at another example: "00000000"

This is already sorted, so I should need only 1 piece.

Similarly, "1" is already sorted, so 1 piece.

"10" can be rearranged to "01", which is sorted, so 2 pieces.

"0001111" is already sorted, so 1 piece.

"0110" can be cut into "0", "110" and rearranged as "0", "110" which is "0110". Is that sorted? Wait, '0's are before '1's, so yes, it's sorted. So, 2 pieces.

From these examples, it seems like the number of pieces needed is related to how many times the sequence changes from '0' to '1' or '1' to '0', especially when '1's come before '0's.

Wait, in the first example, "11010", there are multiple changes.

Let me think about this differently. Suppose I want to have all '0's first and all '1's later. If there are '1's before '0's, I need to separate them in such a way that I can rearrange the pieces to move the '1's to the end.

One way to think about it is to identify the regions where '1's appear before '0's and cut those regions to move them to the end.

Let me consider the string "11010". If I cut it into "11", "0", "10", and rearrange as "0", "10", "11", which is "01011". That's not fully sorted because there's a '1' in the middle. So, maybe I need to cut it differently.

Wait, maybe I should cut at the points where '1's are followed by '0's.

In "11010", the transitions are:

- Position 2: '1' to '0'

- Position 4: '1' to '0'

So, if I cut after position 2, and after position 4, I get "110", "1", "0". Rearranging: "0", "0", "11", which is "0011". That's sorted, and I used 3 pieces, which matches the sample output.

Another way: Cut after the first '1' and after the '0' that follows, but that seems similar.

So, it seems like the number of pieces needed is related to the number of times the sequence changes from '1' to '0', plus one for the initial piece.

Wait, in "11010", there are two '1' to '0' transitions, so number of pieces is 3.

In "0110", there is one '1' to '0' transition, so number of pieces is 2.

In "10", there is one '1' to '0' transition, so number of pieces is 2.

In "0001111", there are no '1' to '0' transitions, so number of pieces is 1.

In "00000000", no '1' to '0' transitions, so 1 piece.

In "1", no '1' to '0' transitions, so 1 piece.

Seems consistent.

So, my approach is: Count the number of '1' to '0' transitions in the string. Each such transition requires an additional piece. Then, the total number of pieces is the number of '1' to '0' transitions plus one for the initial piece.

Wait, but in the first example, there are two '1' to '0' transitions, and the number of pieces is 3, which fits.

In "0110", one '1' to '0' transition, two pieces.

In "10", one '1' to '0' transition, two pieces.

In "0001111", no '1' to '0' transitions, one piece.

In "00000000", no '1' to '0' transitions, one piece.

In "1", no '1' to '0' transitions, one piece.

Looks good.

But wait, in "11010", there are two '1' to '0' transitions, but in the code, there's a flag for whether there's a '0' followed by '1'. Wait, the code checks if s[j] != s[j+1], and if s[j] == '0' and s[j+1] == '1', set flag = True.

Then, after counting all changes, if flag is True, subtract one from the count.

Wait, that seems opposite to what I thought.

According to my logic, the number of '1' to '0' transitions plus one gives the number of pieces.

But in the code, it's counting all changes (s[j] != s[j+1]) and incrementing count, starting from 1.

Then, if there's a '0' followed by '1', set flag = True, and later subtract one if flag is True.

Wait, maybe I need to understand the code's logic.

Let's see:

Initialize count = 1 (since at least one piece is needed)

Initialize flag = False

Iterate through the string from j = 0 to j = len(s)-2:

if s[j] != s[j+1]:

count += 1

if s[j] == '0' and s[j+1] == '1':

flag = True

if flag:

count -= 1

print(count)

So, it's counting the number of changes in the string, and each change increases the count by one.

But then, if there's any '0' followed by '1', it sets flag = True, and at the end, if flag is True, it subtracts one from the count.

Wait, why is it doing that?

Let me think.

In the first example, "11010":

- j=0: s[0]='1', s[1]='1' -> no change

- j=1: s[1]='1', s[2]='0' -> change, count=2

- j=2: s[2]='0', s[3]='1' -> change, count=3

- j=3: s[3]='1', s[4]='0' -> change, count=4

Then, flag is True because there's '0' followed by '1' (j=2: '0' to '1')

So, count -=1 -> count=3

Which matches the sample output.

In "0110":

- j=0: '0' != '1' -> count=2, flag=True

- j=1: '1' == '1' -> no change

- j=2: '1' != '0' -> count=3

flag is True, count -=1 -> count=2

Which matches the sample output.

In "00000000":

- No changes, count=1, flag=False -> count=1

Matches sample output.

In "1":

- No changes, count=1, flag=False -> count=1

Matches sample output.

In "10":

- j=0: '1' != '0' -> count=2, flag=True (since '0' followed by '1')

Then, count -=1 -> count=1

Wait, but according to the sample output, it should be 2.

Wait, there's a discrepancy here.

Wait, in the fourth test case, the explanation says:

"In the fourth test case, you need to make a single cut between the two characters and rearrange them to make the string "01"."

So, for "10", the output should be 2, but according to the code, it would be:

- count starts at 1

- j=0: '1' != '0' -> count=2, flag=True

- flag is True, so count -=1 -> count=1

But the sample output is 2.

Wait, that means the code is wrong for this test case.

Wait, perhaps I misread the sample output.

Wait, let's check the sample input and output:

Input:

6

11010

00000000

1

10

0001111

0110

Output:

3

1

1

2

1

2

So, for "10", it should be 2, but according to the code, it would be 1, which is incorrect.

Wait, maybe there's a mistake in the code.

Let me see what's happening.

In "10":

- count =1

- j=0: '1' != '0' -> count=2, flag=True (since '0' followed by '1')

- flag is True, so count -=1 -> count=1

But sample output is 2, so the code is wrong here.

Wait, perhaps the logic is not correct.

Let me think again.

Maybe the correct approach is to count the number of times the string changes from '1' to '0', because that's when you need to make an additional piece.

In "11010", there are two '1' to '0' changes.

In "0110", there is one '1' to '0' change.

In "10", there is one '1' to '0' change.

In "0001111", there is no '1' to '0' change.

So, the number of pieces should be the number of '1' to '0' changes plus one.

In "11010", 2 changes +1 =3

In "0110", 1 change +1=2

In "10", 1 change +1=2

In "0001111", 0 changes +1=1

Which matches the sample outputs.

But according to the code:

- It counts all changes (s[j] != s[j+1]), not just '1' to '0'

- Then, if there's any '0' followed by '1', it subtracts one from the count.

This seems incorrect, because in "11010", it counts 3 changes: '1' to '0', '0' to '1', '1' to '0'. Then, since there's a '0' to '1', it subtracts one, resulting in count=3, which matches the sample.

In "0110", it counts 2 changes: '0' to '1', '1' to '0'. Since there's a '0' to '1', it subtracts one, resulting in count=2, which matches the sample.

In "10", it counts 1 change: '1' to '0'. Since there's a '0' to '1' (wait, no, in "10", it's '1' to '0', no '0' to '1', so flag remains False, count -=1 is not executed, so count=2, but sample output is 2. Wait, no, in "10", there is no '0' followed by '1', so flag remains False, so no subtraction, count=2.

Wait, but earlier I thought flag is set to True in "10" because of '1' != '0', and s[j]='1', s[j+1]='0', but the code checks if s[j]=='0' and s[j+1]=='1', which is not the case here. So, flag remains False, and count remains 2.

Which matches the sample output of 2.

Wait, perhaps I misread the code.

Let's look at the code again:

for j in range(len(s)-1):

if s[j] != s[j+1]:

count +=1

if s[j] == '0' and s[j+1] == '1':

flag = True

if flag:

count -=1

So, in "10":

- j=0: '1' != '0' -> count=2, flag remains False (since '1' to '0' doesn't set flag)

- flag is False, so no subtraction, count=2

Which matches the sample output.

Wait, but earlier I thought flag is set to True in "10", but no, because flag is set only if '0' followed by '1', which doesn't happen in "10".

So, in "10", count=2, which is correct.

Wait, perhaps I made a mistake earlier.

Let me check another case.

Consider "0110":

- j=0: '0' != '1' -> count=2, flag=True (since '0' to '1')

- j=1: '1' == '1' -> no change

- j=2: '1' != '0' -> count=3, flag remains True

- flag is True, so count -=1 -> count=2

Which matches the sample output.

Another case: "11010"

- j=0: '1' == '1' -> no change

- j=1: '1' != '0' -> count=2, flag remains False

- j=2: '0' != '1' -> count=3, flag=True (since '0' to '1')

- j=3: '1' != '0' -> count=4, flag remains True

- flag is True, so count -=1 -> count=3

Which matches the sample output.

Wait, perhaps this logic works.

Let me see why.

The logic seems to be:

- Count the number of times the string changes (i.e., s[j] != s[j+1])

- If there is at least one '0' followed by '1', subtract one from the count.

- The initial count is 1, representing the whole string as one piece.

I need to verify if this logic correctly computes the minimum number of pieces.

Let me consider the general case.

Imagine the string is divided into runs of consecutive '0's and '1's.

For example, "11010" has runs: '11', '0', '1', '0'.

The number of runs is 4.

In general, a string with r runs would need at least r pieces, because each run is a sequence of the same character, and to rearrange them, you might need to keep each run separate.

But in this problem, we can merge some runs into fewer pieces because we can have pieces that contain both '0's and '1's, as long as in the final arrangement, all '0's come before '1's.

Wait, but the pieces must be contiguous substrings, and in the final arrangement, they must be placed in some order.

So, perhaps the number of pieces needed is equal to the number of times the desired order is violated.

Wait, perhaps it's better to think in terms of the number of '1's that appear before some '0's.

In other words, the number of '1's that need to be moved to the end.

But I need to think in terms of cutting the string into pieces and rearranging them.

Let me consider that the minimal number of pieces is equal to the number of times we have a '1' that is followed by a '0' in the original string, because each such occurrence requires that the '1' be separated from the '0' in different pieces.

Wait, but in the code, it's counting all changes and then subtracting one if there's any '0' followed by '1'.

In "11010", there are two changes: '1' to '0' and '0' to '1', and '1' to '0'. So, count=3, flag=True, count-=1 -> count=2, but sample output is 3.

Wait, no, in "11010", as per earlier analysis, count=4 (initial count=1, plus 3 changes), flag=True, count-=1 -> count=3, which matches the sample.

Wait, but in my earlier thought, I thought count should be number of '1' to '0' transitions plus one.

But according to the code, it's counting all changes and subtracting one if there's any '0' to '1' transition.

I need to find a general rule.

Let me consider that the minimal number of pieces is equal to the number of '1' to '0' transitions plus one.

In "11010", two '1' to '0' transitions, so 3 pieces.

In "0110", one '1' to '0' transition, 2 pieces.

In "10", one '1' to '0' transition, 2 pieces.

In "0001111", no '1' to '0' transitions, 1 piece.

In "00000000", no '1' to '0' transitions, 1 piece.

In "1", no '1' to '0' transitions, 1 piece.

This seems consistent with the sample outputs.

Now, in the code, it's counting all changes (s[j] != s[j+1]), starting from count=1.

In "11010":

- initial count=1

- j=0: '1' == '1' -> no change

- j=1: '1' != '0' -> count=2

- j=2: '0' != '1' -> count=3

- j=3: '1' != '0' -> count=4

- flag is True because there's '0' to '1' at j=2

- count -=1 -> count=3

Which matches the above logic.

In "0110":

- initial count=1

- j=0: '0' != '1' -> count=2

- j=1: '1' == '1' -> no change

- j=2: '1' != '0' -> count=3

- flag is True because of '0' to '1' at j=0

- count -=1 -> count=2

Which matches.

In "10":

- initial count=1

- j=0: '1' != '0' -> count=2

- flag remains False because no '0' to '1'

- count remains 2

Which matches.

So, the code seems to be correctly implementing the logic of counting the number of '1' to '0' transitions plus one, but in a different way.

Wait, but in "11010", there are two '1' to '0' transitions, and count ends up being 3, which is consistent.

In "0110", one '1' to '0' transition, count=2.

In "10", one '1' to '0' transition, count=2.

In "0001111", no '1' to '0' transitions, count=1.

Seems correct.

So, perhaps the code is correct.

But earlier I thought there was a discrepancy with "10", but actually, it's correct.

Therefore, the code is correct.

**Final Solution**

To solve this problem, we need to determine the minimum number of pieces to cut a given binary string into, such that these pieces can be rearranged to form a sorted binary string (all '0's followed by all '1's).

### Approach

1. **Initial Setup**: 
   - We initialize a counter (`count`) to 1 because, in the worst case, the entire string is one piece.
   
2. **Iterate Through the String**:
   - We iterate through the string, checking for points where the character changes from '0' to '1' or '1' to '0'.
   - Each change indicates a potential point where we need to make a cut to rearrange the pieces correctly.
   
3. **Flag for '0' to '1' Transitions**:
   - We use a flag to check if there is any '0' followed by '1' in the string.
   - If such a transition exists, it indicates that we might need to adjust the count of pieces by subtracting one because the pieces can be rearranged to form the sorted string more efficiently.

4. **Adjust Count Based on Flag**:
   - If the flag is set (i.e., there is at least one '0' followed by '1'), we subtract one from the count.
   - This adjustment accounts for the fact that the pieces can be rearranged to minimize the total number of pieces needed.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        s = input().strip()
        count = 1
        flag = False
        j = 0
        while j < len(s) - 1:
            if s[j] != s[j + 1]:
                count += 1
                if s[j] == '0' and s[j + 1] == '1':
                    flag = True
            j += 1
        if flag:
            count -= 1
        print(count)

if __name__ == "__main__":
    func()
```

### Explanation

- **Initialization**: 
  - We start with `count = 1` assuming the whole string is one piece.
  
- **Iteration and Counting Changes**:
  - For each test case, we iterate through the string and count the number of times consecutive characters differ.
  - Each difference indicates a change from '0' to '1' or '1' to '0', which may require an additional piece.
  
- **Flag Mechanism**:
  - We set a flag if there is any '0' followed by '1'. This helps in identifying if there are any reverse transitions that allow for more efficient rearrangement.
  
- **Adjusting the Count**:
  - If the flag is set, we subtract one from the count because it's possible to rearrange the pieces more optimally due to the existence of '0' followed by '1' transitions.
  
- **Output the Result**:
  - For each test case, we print the adjusted count, which represents the minimum number of pieces needed to rearrange the string into a sorted binary string.

This approach ensures that we efficiently determine the minimum number of pieces required while considering the specific constraints of the problem.