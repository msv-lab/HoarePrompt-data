Alright, I've got this problem to solve. Let's see what it's asking for. So, there are two firework launch installations, each launching fireworks at regular intervals: one every 'a' minutes and the other every 'b' minutes. Each firework remains visible in the sky for 'm + 1' minutes after it's launched. The goal is to find the maximum number of fireworks that can be seen in the sky at the same time.

First, I need to understand how the fireworks are launched and when they are visible. For the first installation, it launches fireworks at times a, 2a, 3a, and so on. Similarly, the second installation launches at times b, 2b, 3b, etc. Each firework is visible from the time it's launched up to m minutes after its launch, inclusive. So, a firework launched at time t is visible at times t, t+1, t+2, ..., t+m.

I need to find a time when the maximum number of these visibility intervals overlap. That is, find a time when the most number of fireworks are visible in the sky at the same time.

Let me think about how to approach this. One way is to consider the launch times and their visibility periods and see how they overlap.

Let's consider the first installation. The fireworks launched at ka minutes (where k is a positive integer) are visible from ka to ka + m. Similarly, for the second installation, fireworks launched at lb minutes (l is a positive integer) are visible from lb to lb + m.

I need to find a time t where the number of intervals [ka, ka + m] and [lb, lb + m] that contain t is maximized.

This seems like a problem of interval overlapping. I need to find the time t where the most number of these intervals overlap.

But since a, b, and m can be up to 10^18, and t can be up to 10^4, I need an efficient way to calculate this without iterating through all possible times.

Let me think about the possible scenarios where the number of visible fireworks is maximized.

Case 1: No overlap between the visibility periods of fireworks from the same installation.

If a > m, then no two fireworks from the first installation will be visible at the same time because the launch interval is larger than the visibility period. Similarly, if b > m, the same applies to the second installation.

Case 2: Overlap between the visibility periods of fireworks from the same installation.

If a <= m, then there can be overlapping visibility periods from the first installation. Similarly for the second installation if b <= m.

Case 3: Overlap between the visibility periods of fireworks from different installations.

Fireworks from different installations can overlap if their visibility periods intersect.

I need to consider all these overlaps to find the maximum number of fireworks visible at any time.

Let me try to find a general formula or approach to calculate this.

One approach is to consider the density of launches and their visibility periods.

For the first installation, the number of fireworks visible at a time t is floor((t - ka)/a) for ka <= t <= ka + m.

Wait, that might not be the right way to think about it.

Alternatively, for a given time t, the number of fireworks visible is the number of ka such that ka <= t <= ka + m for the first installation, plus the number of lb such that lb <= t <= lb + m for the second installation.

This is equivalent to the number of ka in [t - m, t] for the first installation, and similarly for the second installation.

But since ka are multiples of a, i.e., ka = a * k for k = 1, 2, 3, ..., and similarly lb = b * l for l = 1, 2, 3, ...

So, for a given t, the number of ka in [t - m, t] is floor(t / a) - floor((t - m - 1)/a), similarly for lb.

Therefore, the total number of visible fireworks at time t is:

floor(t / a) - floor((t - m - 1)/a) + floor(t / b) - floor((t - m - 1)/b)

I need to maximize this expression over all possible t.

But since t can be up to infinity in theory, I need a smarter way to find the maximum without checking every possible t.

Let me consider the least common multiple (LCM) of a and b. The LCM is the time after which the launch cycles repeat.

But given that a and b can be up to 10^18, calculating LCM directly might not be feasible.

Alternatively, I can look for the time t where the visibility periods of as many fireworks as possible overlap.

I recall that in similar problems, the maximum overlapping often occurs at multiples of the LCM of the intervals, or at times where multiple launches coincide.

But in this case, since m can be up to 10^18, and a and b can be up to 10^18, I need a more efficient way.

Let me consider the maximum possible number of overlaps.

For the first installation, if a <= m, then within any interval of length m + a, there can be up to floor(m / a) + 1 fireworks overlapping.

Wait, actually, if a <= m, then the number of overlapping fireworks from the first installation at any time is floor(m / a) + 1.

Similarly for the second installation.

But I need to consider the overlaps between the two installations as well.

Wait, perhaps not.

Let me think differently.

Suppose I consider the time t = LCM(a, b), that is, the least common multiple of a and b. At this time, both installations have launched fireworks, and their visibility periods may overlap.

But calculating LCM directly is not efficient for large a and b.

Alternatively, I can think about the greatest common divisor (GCD) of a and b.

Wait, maybe there's a better way.

Let me consider the possible times when both installations launch fireworks simultaneously. That would be at multiples of LCM(a, b).

But again, LCM can be very large.

Alternatively, perhaps I can find the time t where the number of launches from each installation up to t is maximized, considering their visibility periods.

Wait, perhaps I can think in terms of the number of launches up to a certain time.

Let me define:

For the first installation, the number of launches up to time t is floor(t / a).

Similarly, for the second installation, it's floor(t / b).

But I need to consider the visibility periods, which extend m minutes after each launch.

So, the number of visible fireworks from the first installation at time t is floor((t - (t mod a))/a) - floor(((t - m - 1) - ((t - m - 1) mod a))/a)

Wait, that seems complicated.

Alternatively, the number of visible fireworks from the first installation at time t is floor(t / a) - floor((t - m - 1)/a).

Similarly for the second installation.

So, total visible fireworks at time t is:

floor(t / a) - floor((t - m - 1)/a) + floor(t / b) - floor((t - m - 1)/b)

I need to maximize this expression over t.

I need to find the maximum value of this expression for t >= 0.

Let me consider that floor(t / a) increases by 1 every a minutes, and floor(t / b) increases by 1 every b minutes.

Similarly, floor((t - m - 1)/a) increases by 1 every a minutes, and floor((t - m - 1)/b) increases by 1 every b minutes.

Therefore, the expression floor(t / a) - floor((t - m - 1)/a) can be seen as the number of launches from the first installation whose visibility includes time t.

Similarly for the second installation.

So, the total visible fireworks at time t is the sum of these two.

To maximize this sum, I need to find a t where both counts are as large as possible.

Let me consider that if t is a multiple of a and b, then both floor(t / a) and floor(t / b) increase, and similarly for floor((t - m - 1)/a) and floor((t - m - 1)/b).

But this seems a bit messy.

Perhaps there's a better mathematical approach.

Let me consider that the maximum number of overlapping visibility periods from the first installation is floor(m / a) + 1, if a divides m.

Similarly for the second installation.

But I need to consider when the visibility periods overlap between the two installations.

Wait, perhaps the maximum number of visible fireworks is the sum of the maximum overlaps from each installation, plus any additional overlaps when their launch times coincide.

But I need to be careful not to double-count.

Let me consider different cases based on the values of a, b, and m.

Case 1: a > m and b > m.

In this case, no two fireworks from the same installation overlap, because the launch interval is larger than the visibility period.

Therefore, the maximum number of visible fireworks is the number of installations launching at times when their visibility periods overlap.

Since a > m and b > m, each installation can have at most one firework visible at a time.

So, the maximum number is the number of installations launching within m minutes of each other.

But since the launches are periodic, I need to find a time t where the launches from both installations have fireworks visible.

The earliest time when both installations have launched is max(a, b).

But I need to find a time t where t >= a and t >= b, and t - a <= m and t - b <= m.

Wait, perhaps it's better to consider t such that there exists k and l where ka <= t <= ka + m and lb <= t <= lb + m.

To maximize the number of visible fireworks, I need to find t where the most number of ka and lb are such that t is within their visibility periods.

This seems complicated.

Perhaps I can consider that for a given t, the number of visible fireworks from the first installation is the number of ka in [t - m, t], and similarly for the second installation.

Given that ka = a * k for k = 1, 2, 3, ..., the number of ka in [t - m, t] is floor(t / a) - floor((t - m - 1)/a).

Similarly for the second installation.

Therefore, the total visible fireworks at time t is:

floor(t / a) - floor((t - m - 1)/a) + floor(t / b) - floor((t - m - 1)/b)

I need to maximize this expression over t.

To find the maximum value of this expression, I can consider that the expression can change only at points where t is a multiple of a or b, or t - m - 1 is a multiple of a or b.

But given the large values of a, b, and m, I need a smarter way.

Let me consider that the maximum number of visible fireworks is achieved when t is such that it maximizes the number of ka and lb in [t - m, t].

One way to maximize this is to set t to be a common multiple of a and b, or perhaps t = LCM(a, b).

But again, LCM can be very large, and I need an efficient way.

Alternatively, perhaps I can set t to be min(a, b) + m.

Let me see.

Suppose t = min(a, b) + m.

Then, floor(t / a) - floor((t - m - 1)/a) + floor(t / b) - floor((t - m - 1)/b)

Let's consider a < b.

Then t = a + m.

floor((a + m)/a) - floor((a + m - m - 1)/a) + floor((a + m)/b) - floor((a + m - m - 1)/b)

= floor((a + m)/a) - floor((a - 1)/a) + floor((a + m)/b) - floor((a - 1)/b)

= (1 + floor(m / a)) - 0 + floor((a + m)/b) - floor((a - 1)/b)

= 1 + floor(m / a) + floor((a + m)/b) - floor((a - 1)/b)

Similarly, if a > b, t = b + m would give:

floor((b + m)/a) - floor((b + m - m - 1)/a) + floor((b + m)/b) - floor((b + m - m - 1)/b)

= floor((b + m)/a) - floor((b - 1)/a) + floor((b + m)/b) - floor((b - 1)/b)

= floor((b + m)/a) - floor((b - 1)/a) + (1 + floor(m / b)) - 0

= floor((b + m)/a) - floor((b - 1)/a) + 1 + floor(m / b)

This seems promising.

But is this always the maximum?

Let me check with the example given.

In the first example:

a = 6, b = 7, m = 4

t = min(6,7) + 4 = 6 + 4 = 10

floor(10/6) - floor((10 - 4 -1)/6) + floor(10/7) - floor((10 - 4 -1)/7)

= floor(10/6) - floor(5/6) + floor(10/7) - floor(5/7)

= 1 - 0 + 1 - 0 = 2

Which matches the first output of 2.

Another example:

a = 3, b = 4, m = 10

t = 3 + 10 = 13

floor(13/3) - floor((13 - 10 -1)/3) + floor(13/4) - floor((13 -10 -1)/4)

= floor(13/3) - floor(2/3) + floor(13/4) - floor(2/4)

= 4 - 0 + 3 - 0 = 7

Which matches the second output of 7.

Another example:

a = 7, b = 8, m = 56

t = 7 + 56 = 63

floor(63/7) - floor((63 -56 -1)/7) + floor(63/8) - floor((63 -56 -1)/8)

= floor(63/7) - floor(6/7) + floor(63/8) - floor(6/8)

= 9 - 0 + 7 - 0 = 16

But according to the third output, it's 17. So, there's a discrepancy here.

Wait, perhaps t = LCM(a, b) or another value would give a higher count.

Let's check t = LCM(7,8) = 56

floor(56/7) - floor((56 -56 -1)/7) + floor(56/8) - floor((56 -56 -1)/8)

= 8 - floor(-1/7) + 7 - floor(-1/8)

= 8 - (-1) + 7 - (-1) = 8 + 1 + 7 + 1 = 17

Ah, so at t = 56, the number is 17, which matches the third output.

So, in this case, t = LCM(a, b) gives a higher count than t = min(a, b) + m.

Therefore, my previous assumption that t = min(a, b) + m gives the maximum is not always true.

So, I need to find a better way to determine t that maximizes the expression.

But calculating LCM is not feasible for large a and b, as LCM(a, b) can be up to a*b if a and b are coprime, which is 10^36, way beyond feasible computation.

I need a smarter approach.

Let me consider that the maximum number of visible fireworks is achieved when t is a multiple of both a and b, i.e., t is a multiple of LCM(a, b).

At such times, both installations have launched fireworks, and their visibility periods overlap.

At t = LCM(a, b), the number of visible fireworks from the first installation is floor(LCM(a, b)/a) - floor((LCM(a, b) - m -1)/a)

Similarly for the second installation.

But calculating LCM directly is not efficient.

Alternatively, I can use the GCD to calculate LCM, since LCM(a, b) = a*b / GCD(a, b).

But even then, for large a and b, a*b can be up to 10^36, which is too big to handle directly.

I need a way to calculate the expression without computing LCM directly.

Let me consider the possible values of t that could maximize the expression.

Possible candidates are:

1. t = min(a, b) + m

2. t = LCM(a, b)

3. t = max(a, b)

4. t = some other value where the visibility periods overlap maximally.

From the third example, t = LCM(a, b) gives a higher count than t = min(a, b) + m.

But in the first example, t = min(a, b) + m gives the correct maximum.

So, perhaps the maximum is the maximum of these two options.

But calculating LCM is not feasible.

Is there a way to compute the expression at t = LCM(a, b) without computing LCM directly?

Let me think about the expression again:

floor(t / a) - floor((t - m -1)/a) + floor(t / b) - floor((t - m -1)/b)

I need to maximize this.

Let me consider that floor(t / a) is the number of multiples of a up to t, and floor((t - m -1)/a) is the number of multiples of a up to t - m -1.

Therefore, floor(t / a) - floor((t - m -1)/a) is the number of multiples of a in the interval [t - m, t].

Similarly for b.

So, the total visible fireworks is the number of multiples of a in [t - m, t] plus the number of multiples of b in [t - m, t].

To maximize this, I need to maximize the number of multiples of a and b in [t - m, t].

This seems similar to finding t that maximizes the number of multiples of a and b in an interval of length m + 1.

I need to find t such that t - m <= ka <= t and t - m <= lb <= t for as many ka and lb as possible.

This seems tricky.

Let me consider that if a divides t and b divides t, then t is a multiple of LCM(a, b).

At such t, both floor(t / a) and floor(t / b) increase, and floor((t - m -1)/a) and floor((t - m -1)/b) depend on m and a, b.

But again, without computing LCM, I'm not sure how to proceed.

Let me consider that if a and b are co-prime, then LCM(a, b) = a*b.

But even for small a and b, a*b can be large.

Wait, maybe I can consider the density of multiples.

But I need an exact count, not an approximation.

Let me consider that for a given t, the number of multiples of a in [t - m, t] is floor(t / a) - floor((t - m -1)/a)

Similarly for b.

I need to maximize the sum of these two.

Let me consider that if t is a multiple of a, then floor(t / a) = t / a, and floor((t - m -1)/a) = floor((t - m -1)/a)

Similarly for b.

But this seems too vague.

Let me consider specific cases.

Case 1: a = b

If a = b, then both installations launch fireworks simultaneously every a minutes.

In this case, the number of visible fireworks at time t is floor(t / a) - floor((t - m -1)/a), since both installations launch at the same times.

But since they are the same, the maximum number would be 2 * (floor(m / a) + 1), because m +1 minutes of visibility for each firework, and they overlap completely.

Wait, no.

Actually, if a = b, then the number of visible fireworks at any time t is the number of launches up to t minus the number of launches before t - m.

Which is floor(t / a) - floor((t - m -1)/a)

But since both installations launch at the same times, the total visible fireworks would be 2 * (floor(t / a) - floor((t - m -1)/a))

Therefore, in this case, the maximum is 2 * (floor(m / a) + 1)

But need to confirm this.

Wait, no.

If a = b, then at each launch time, both installations launch a firework.

So, for each ka, there are two fireworks launched: one from each installation.

Therefore, the number of visible fireworks at time t is 2 * (number of ka in [t - m, t])

Which is 2 * (floor(t / a) - floor((t - m -1)/a))

To maximize this, t should be such that [t - m, t] includes as many ka as possible.

The maximum number is 2 * ceil((m +1)/ a)

Wait, no.

Actually, the number of ka in [t - m, t] is floor(t / a) - floor((t - m -1)/a)

This expression is maximized when t is such that t is just after a multiple of a, say t = ka.

Then, floor(t / a) = k, floor((t - m -1)/a) = floor((ka - m -1)/a) = k - ceil(m / a)

Therefore, floor(t / a) - floor((t - m -1)/a) = k - (k - ceil(m / a)) = ceil(m / a)

So, the maximum number of fireworks from one installation is ceil(m / a)

Similarly for the other installation.

Therefore, if a = b, the total is 2 * ceil(m / a)

But in the example where a = b =1, m =1, the output is 4, which is 2 * ceil(1 /1) + something.

Wait, perhaps I'm missing something.

Wait, in the last example:

a =1, b=1, m=1000000000000000000

Output: 2000000000000000002

Which is 2 * (m +1) = 2 * (10^18 +1) = 2*10^18 +2 = 2000000000000000002

So, in this case, a = b =1, m =10^18

Then, ceil(m / a) = ceil(10^18 /1) =10^18

But the output is 2*(10^18 +1) = 2*10^18 +2

Wait, that doesn't match.

Wait, perhaps I need to consider that when a =1, b=1, m=10^18, at t=1, the number of visible fireworks is floor(1/1) - floor((1 -10^18 -1)/1) + floor(1/1) - floor((1 -10^18 -1)/1)

=1 - floor(-10^18 -1) +1 - floor(-10^18 -1)

=1 - (-10^18 -1) +1 - (-10^18 -1)

=1 +10^18 +1 +1 +10^18 +1

=2*10^18 +4

But the output is 2000000000000000002, which is 2*10^18 +2

So, my calculation is off.

Wait, perhaps floor(-n) = -ceil(n)

Wait, in programming, floor of a negative number is the smallest integer less than or equal to it.

So, floor(-2.5) = -3

Therefore, floor((1 -10^18 -1)/1) = floor(-10^18 -1) = -10^18 -1

So, floor(1/1) - floor((1 -10^18 -1)/1) =1 - (-10^18 -1) =1 +10^18 +1 =10^18 +2

Similarly for the second installation.

So, total is 2*(10^18 +2) = 2*10^18 +4

But the output is 2*10^18 +2

So, my calculation is incorrect.

Perhaps I'm missing something about the floor function for negative numbers.

Wait, let's check floor(-2.5) = -3, floor(-1) = -1

So, for t=1, m=10^18

t - m -1 =1 -10^18 -1 = -10^18

floor(-10^18 /1) = -10^18

So, floor(t /1) - floor((t - m -1)/1) =1 - (-10^18) =1 +10^18

Similarly for the second installation.

Total: 2*(10^18 +1) =2*10^18 +2

Which matches the output.

So, my earlier mistake was in calculating floor(-10^18 -1), which is -10^18 -1, but in the correct calculation, it's floor(t - m -1)/a) = floor(1 -10^18 -1)/1) = floor(-10^18) = -10^18

Wait, no, t - m -1 =1 -10^18 -1 = -10^18

floor(-10^18 /1) = -10^18

Therefore, floor(t /1) - floor((t - m -1)/1) =1 - (-10^18) =1 +10^18

Similarly for the second installation.

Total: 2*(10^18 +1) =2*10^18 +2

Got it.

So, perhaps in general, for a=1 and b=1, m=1, the output is 4, which is 2*(1 +1) =4

Similarly, for a=1, b=1, m=10^18, output is 2*(10^18 +1) =2*10^18 +2

So, in this case, it seems that t=1 gives the maximum.

But what about other cases?

Wait, in the first example, a=6, b=7, m=4, t=10 gives 2, which matches the output.

But in the third example, a=7, b=8, m=56, t=56 gives 17, which is higher than t=7+56=63 giving 16.

So, perhaps t=LCM(a,b) gives a higher count in some cases.

But calculating LCM is not feasible for large a and b.

Is there a way to compute the expression at t=LCM(a,b) without computing LCM directly?

Let me recall that LCM(a,b) = a*b / GCD(a,b)

But even with GCD, a*b can be up to 10^36, which is too big.

I need another approach.

Let me consider that the maximum number of visible fireworks is the sum of the maximum overlaps from each installation, plus any additional overlaps when their launch times coincide.

For each installation, the maximum number of overlapping fireworks is floor(m / a) +1, when a divides m.

Similarly for b.

So, the total would be floor(m / a) +1 + floor(m / b) +1

But in the third example, a=7, b=8, m=56

floor(56 /7) +1 + floor(56 /8) +1 =8 +1 +7 +1=17, which matches the output.

Similarly, in the first example, floor(4 /6)+1 + floor(4 /7)+1=0 +1 +0 +1=2, which matches the output.

In the last example, floor(10^18 /1)+1 + floor(10^18 /1)+1=10^18 +1 +10^18 +1=2*10^18 +2, which matches the output.

So, perhaps the general formula is:

floor(m / a) +1 + floor(m / b) +1 = floor(m / a) + floor(m / b) +2

But in the second example, a=3, b=4, m=10

floor(10 /3)+1 + floor(10 /4)+1=3 +1 +2 +1=7, which matches the output.

So, perhaps the formula is floor(m / a) + floor(m / b) +2

But wait, in the case where a=1, b=1, m=0

floor(0 /1)+1 + floor(0 /1)+1=0 +1 +0 +1=2

Which would be correct, as at t=1, both installations launch fireworks that are visible at t=1, since m=0 means visibility only at t.

So, total visible fireworks at t=1 would be 2.

Similarly, for a=1, b=1, m=1, output is 4, which is floor(1 /1)+1 + floor(1 /1)+1=1 +1 +1 +1=4

Which matches.

So, it seems that the general formula is floor(m / a) +1 + floor(m / b) +1 = floor(m / a) + floor(m / b) +2

But wait, in the first example, a=6, b=7, m=4

floor(4 /6)=0, floor(4 /7)=0, so 0 +0 +2=2, which matches.

In the third example, floor(56 /7)=8, floor(56 /8)=7, so 8 +7 +2=17, which matches.

In the second example, floor(10 /3)=3, floor(10 /4)=2, so 3 +2 +2=7, which matches.

In the last example, floor(10^18 /1)=10^18, floor(10^18 /1)=10^18, so 10^18 +10^18 +2=2*10^18 +2, which matches.

So, it seems that the formula is floor(m / a) + floor(m / b) +2

But why does this work?

Because for each installation, the maximum number of overlapping fireworks is floor(m / a) +1, as the visibility period is m +1 minutes (from t to t + m inclusive).

Therefore, summing for both installations gives floor(m / a) +1 + floor(m / b) +1 = floor(m / a) + floor(m / b) +2

This seems to hold in all the examples.

But is this always correct?

Wait, what if a divides m and b divides m, and a and b are such that their launches coincide at t=LCM(a,b), which could be less than min(a,b)+m.

But in the formula floor(m / a) + floor(m / b) +2, it seems to account for that.

Wait, in the third example, a=7, b=8, m=56

Since 7 divides 56, floor(56 /7)=8, and 8 divides 56, floor(56 /8)=7, so 8 +7 +2=17, which matches the output.

Similarly, in other cases, it seems to hold.

But let's check another case.

Suppose a=2, b=3, m=1

Then, floor(1 /2)=0, floor(1 /3)=0, so 0 +0 +2=2

At t=2, floor(2 /2)-floor((2 -1 -1)/2) + floor(2 /3)-floor((2 -1 -1)/3) =1 - floor(0/2) +0 - floor(-1/3) =1 -0 +0 -(-1)=1 +1=2

At t=3, floor(3 /2)-floor((3 -1 -1)/2) + floor(3 /3)-floor((3 -1 -1)/3) =1 - floor(1/2) +1 - floor(1/3) =1 -0 +1 -0=2

At t=6, floor(6 /2)-floor((6 -1 -1)/2) + floor(6 /3)-floor((6 -1 -1)/3) =3 - floor(4/2) +2 - floor(4/3) =3 -2 +2 -1=1 +1=2

So, the maximum is 2, which matches the formula.

Another case: a=2, b=4, m=5

floor(5 /2)=2, floor(5 /4)=1, so 2 +1 +2=5

At t=4, floor(4 /2)-floor((4 -5 -1)/2) + floor(4 /4)-floor((4 -5 -1)/4) =2 - floor(-2/2) +1 - floor(-2/4) =2 - (-1) +1 - (-1) =2 +1 +1 +1=5

Which matches.

So, it seems that floor(m / a) + floor(m / b) +2 is the correct formula.

But wait, in the first example, a=6, b=7, m=4, it gives 0 +0 +2=2, which matches.

Another check: a=5, b=6, m=78123459896

floor(78123459896 /5)=15624691979, floor(78123459896 /6)=13020576649, so 15624691979 +13020576649 +2=28645268630, which matches the fourth output.

So, it seems that the formula floor(m / a) + floor(m / b) +2 is correct.

Therefore, the program should implement this formula.

But looking at the given program:

def func():

t = int(input())

for i in range(t):

(a, b, m) = map(int, input().split())

mn = min(a, b) + m

if m % a == 0 and m % b == 0 and (a != 1) and (b != 1):

print(mn // a + mn // b + 1)

else:

print(mn // a + mn // b)

This seems different from my formula.

Let's see what it's doing.

It sets mn = min(a, b) + m

Then, if m is divisible by both a and b and a and b are not 1, it prints mn // a + mn // b +1

Else, it prints mn // a + mn // b

