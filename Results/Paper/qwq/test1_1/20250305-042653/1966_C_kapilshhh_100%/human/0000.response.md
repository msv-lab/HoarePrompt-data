Alright, I've got this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual compared to standard stone-removal games. Let's try to understand the problem step by step.

First, the setup: There are n piles of stones, and each pile has a certain number of stones. Alice and Bob take turns, and on each turn, a player chooses a positive integer k, which has to be at most the size of the smallest non-empty pile. Then, the player removes k stones from each non-empty pile. The player who can't make a move because all piles are empty loses.

Alice goes first, and both players play optimally. I need to determine who wins each game for multiple test cases.

Looking at the example, there are 7 test cases, each with different numbers of piles and different sizes of piles. The expected output is either "Alice" or "Bob", indicating who wins the game.

Okay, so I need to find a way to determine the winner based on the initial configuration of the piles.

I recall that in game theory, particularly in impartial games like this, the concept of Nimbers or the mex function can be used to determine the winner. However, the standard Nim game involves removing stones from a single pile per turn, not from all piles simultaneously.

This game is different because the player removes k stones from every non-empty pile at once. So, it's affecting all piles simultaneously, which makes it unlike standard Nim.

Let me think about how the game progresses.

Suppose there are piles with sizes a1, a2, ..., an.

A move consists of selecting a k (1 <= k <= min of the piles), and then subtracting k from each pile that has stones.

After a move, any pile that had less than k stones is removed (since it would become negative, but since we're removing k from each, piles with fewer than k stones are considered empty).

Wait, no. The problem says "remove k stones from each nonempty pile at once." So, if a pile has, say, 3 stones and k=2 is chosen, it becomes 1. Only piles with fewer than k stones are not considered for removal in that turn, but they still have stones left.

Wait, no, the problem says "remove k stones from each nonempty pile at once." It doesn't say that piles with fewer than k stones are ignored; it says that k must be at most the size of the smallest nonempty pile, ensuring that every pile has at least k stones to remove.

So, after removing k stones from each pile, all piles will have at least 0 stones, but piles that had exactly k stones will now be empty.

The game continues until all piles are empty, and the player who cannot make a move loses.

Hmm, so I need to find out who has the winning strategy.

Let me consider some small examples to see if I can find a pattern.

Example 1:

n = 5

piles: 3 3 3 3 3

Alice chooses k=3, removes 3 from each pile, all piles become empty. Game over, Alice wins.

Example 2:

n=2

piles: 1 7

Alice must choose k=1 (since the smallest pile has 1 stone).

She removes 1 from each pile: piles become 0 and 6.

Now, Bob's turn. The smallest nonempty pile is 6, so he can choose k up to 6.

He chooses k=6, removes 6 from the pile of 6, making it empty. The other pile is already empty.

So, all piles are empty, Bob wins.

Example 3:

n=7

piles: 1 3 9 7 4 2 100

Alice can choose k=1 (since the smallest pile is 1).

She removes 1 from each pile:

Piles become: 0, 2, 8, 6, 3, 1, 99.

Now, Bob's turn. The smallest nonempty pile is 1.

Bob chooses k=1.

Removes 1 from each nonempty pile:

Piles: 0, 1, 7, 5, 2, 0, 98.

Alice's turn. Smallest nonempty pile is 1.

Chooses k=1.

Removes 1 from each nonempty pile:

Piles: 0, 0, 6, 4, 1, 0, 97.

Bob's turn. Smallest nonempty pile is 1.

Chooses k=1.

Removes 1 from each nonempty pile:

Piles: 0, 0, 5, 3, 0, 0, 96.

Alice's turn. Smallest nonempty pile is 3.

Chooses k=3.

Removes 3 from each nonempty pile:

Piles: 0, 0, 2, 0, 0, 0, 93.

Bob's turn. Smallest nonempty pile is 2.

Chooses k=2.

Removes 2 from each nonempty pile:

Piles: 0, 0, 0, 0, 0, 0, 91.

All piles are empty, Bob wins.

Wait, but according to the sample output, Alice wins this case. But in my simulation, Bob wins. Maybe I made a mistake in simulation.

Wait, let's check the sample output again.

Sample Output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

So, for the third test case, Alice should win. But in my simulation, Bob won. So, perhaps my simulation is incorrect.

Maybe there's a better way to approach this problem without simulating each move, especially since n can be up to 2*10^5 and t up to 10^4, which would make simulation too slow anyway.

I need a way to determine the winner quickly for each test case.

Let me think about the game in terms of game theory, specifically impartial games.

In standard Nim, the XOR of pile sizes determines the winner. But in this game, moves affect all piles simultaneously, so it's different.

Maybe I can model this game as a single pile game, since moves affect all piles at once.

Let me consider the mex function or some other way to find the Grundy number for the game.

Alternatively, perhaps there's a way to reduce this game to a standard game that I already know.

Let me think differently. Since each move removes k stones from every non-empty pile, this is similar to subtracting k from each pile simultaneously.

This seems similar to the game of Nim where each pile is a heap, and moves involve subtracting the same amount from all heaps.

Wait, that sounds familiar. It's similar to the game of Nim with a twist.

In standard Nim, each player chooses one heap and removes any number of objects from it. Here, the player chooses a number k and removes k from all heaps that have at least k stones.

Wait, no, the player removes k stones from every non-empty pile, as long as k is at most the smallest non-empty pile.

This seems more similar to the game of Nim with a restriction on the moves.

Alternatively, perhaps I can think of this as a subtraction game where the same amount is subtracted from all piles.

But this seems complicated. Maybe there's a mathematical way to determine the winner based on the pile sizes.

Let me consider sorting the piles in decreasing order.

Suppose I have piles sorted as a1 >= a2 >= ... >= an.

On each turn, a player chooses k <= a_n (the smallest non-empty pile), and subtracts k from all a_i where a_i >= k.

This seems like it could be modeled using the concept of the mex or something similar.

Wait, perhaps I can think in terms of the number of stones removed over the course of the game.

Alternatively, maybe I can think about the number of moves possible.

But that seems too vague.

Let me look at the sample input and output again.

Sample Input:

7

5

3 3 3 3 3

2

1 7

7

1 3 9 7 4 2 100

3

1 2 3

6

2 1 3 4 2 4

8

5 7 2 9 6 3 3 2

1

1000000000

Sample Output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

Looking at the first test case:

n=5, piles: 3 3 3 3 3

Alice can choose k=3, removes 3 from each, all piles become 0, Alice wins.

Second test case:

n=2, piles:1 7

Alice must choose k=1, removes 1 from each, piles become 0 and 6.

Bob chooses k=6, removes 6 from the pile of 6, making it 0. All piles empty, Bob wins.

Third test case:

n=7, piles:1 3 9 7 4 2 100

According to sample output, Alice wins.

But in my earlier simulation, I thought Bob wins, so my simulation must be wrong.

Fourth test case:

n=3, piles:1 2 3

Alice chooses k=1, removes 1 from each, piles become 0,1,2.

Bob chooses k=1, removes 1 from each non-empty pile, piles become 0,0,1.

Alice chooses k=1, removes 1 from the last pile, making it 0. All piles empty, Alice wins.

Fifth test case:

n=6, piles:2 1 3 4 2 4

Alice chooses k=1, removes 1 from each, piles become 1,0,2,3,1,3.

Bob chooses k=1, removes 1 from each non-empty pile, piles become 0,0,1,2,0,2.

Alice chooses k=1, removes 1 from each non-empty pile, piles become 0,0,0,1,0,1.

Bob chooses k=1, removes 1 from each non-empty pile, piles become 0,0,0,0,0,0. Bob wins.

Sixth test case:

n=8, piles:5 7 2 9 6 3 3 2

Alice chooses k=2, removes 2 from each, piles become 3,5,0,7,4,1,1,0.

Bob chooses k=1, removes 1 from each non-empty pile, piles become 2,4,0,6,3,0,0,0.

Alice chooses k=2, removes 2 from each non-empty pile, piles become 0,2,0,4,1,0,0,0.

Bob chooses k=1, removes 1 from each non-empty pile, piles become 0,1,0,3,0,0,0,0.

Alice chooses k=1, removes 1 from each non-empty pile, piles become 0,0,0,2,0,0,0,0.

Bob chooses k=2, removes 2 from the pile of 2, making it 0. All piles empty, Bob wins.

Wait, but according to the sample output, Alice wins this case. But in my simulation, Bob wins. So again, discrepancy.

Seventh test case:

n=1, pile:1000000000

Alice chooses k=1000000000, removes all stones, wins.

So, in the sample output, Alice wins in test cases 1,3,4,6,7; Bob wins in test cases 2 and 5.

But in my simulation of test case 3 and 6, I thought Bob wins, but according to the sample output, Alice wins. So, my simulation must be incorrect.

Perhaps there's a better way to approach this.

Let me think about the game in terms of the number of stones in the piles.

I need a way to determine the winner without simulating the entire game, as that would be too slow for the given constraints.

Looking at the provided program, it seems to sort the unique pile sizes in reverse order and then check some condition based on whether the difference between consecutive pile sizes is greater than 1 or not.

Wait, let's look at the code again.

def func():

tc = int(input())

while tc > 0:

n = int(input())

arr = sorted(list(set([int(x) for x in input().split(' ')])), reverse=True) + [0]

dp = True

n = len(arr) - 1

for i in range(1, n):

dp = arr[i] - arr[i + 1] > 1 or not dp

print('Alice' if dp else 'Bob')

tc -= 1

So, it reads the number of test cases, then for each test case, it reads n and then the pile sizes.

It then creates a list of unique pile sizes, sorted in descending order, and appends a 0 at the end.

Then, it initializes dp = True.

It sets n to be the length of this array minus 1.

Then, it loops from 1 to n-1, and for each i, it sets dp to be (arr[i] - arr[i+1] > 1) or not dp.

Finally, it prints "Alice" if dp is True, else "Bob".

I need to understand why this works.

First, it's using a dynamic programming approach, where dp is being updated based on some condition.

The condition is arr[i] - arr[i+1] > 1 or not dp.

I need to understand what this condition represents.

Perhaps arr[i] represents the size of the piles, and by checking the difference between consecutive pile sizes, it's determining something about the possible moves.

Wait, but in the code, it's using unique pile sizes, sorted in reverse order.

So, it's considering distinct pile sizes, from largest to smallest.

Applying the condition arr[i] - arr[i+1] > 1 or not dp to update dp.

This seems like it's checking for some kind of gap in the pile sizes.

I need to think about what this condition signifies in the context of the game.

Alternatively, perhaps it's determining the mex or something similar.

But I'm not sure.

Let me consider the first test case:

piles: 3 3 3 3 3

unique sorted reverse: [3,0]

n=2

Loop from i=1 to 1:

dp = arr[1] - arr[2] > 1 or not dp = 3 - 0 > 1 or True = True or True = True

So, dp remains True, Alice wins, which matches the sample output.

Second test case:

piles:1 7

unique sorted reverse: [7,1,0]

n=3

Loop from i=1 to 2:

i=1: dp = 7 - 1 > 1 or True = True or True = True

i=2: dp =1 - 0 > 1 or True = True or True = True

So, dp remains True, but according to the sample output, Bob wins, so this is incorrect.

Wait, but in the sample output, for the second test case, it's "Bob".

Wait, no, looking back at the sample output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

So, for the second test case, it's "Bob", which would correspond to dp being False.

But according to the code, dp would be True, which would print "Alice", but sample output is "Bob". So, there's a discrepancy here.

Wait, perhaps I miscounted the test cases.

Looking back, in the sample input, there are 7 test cases, but in my earlier simulation, I might have miscounted.

Wait, in the sample output, the second test case is "Bob", which corresponds to dp=False.

But according to the code, for the second test case, dp would be True, printing "Alice", which doesn't match the sample output "Bob".

So, perhaps the code is incorrect.

Wait, but the problem says to assume the given program is correct, and I need to verify its correctness based on the problem description.

Wait, the instruction says: "Assume valid inputs as described in the problem description."

So, I need to assume that the inputs are valid as per the problem, and determine if the given program is correct or not.

Given that, I need to see if the program correctly determines the winner for each test case.

From the sample input and output, and comparing it to what the program would output, there seems to be a discrepancy in the second test case.

According to the sample output, the second test case should be "Bob", but according to the program, it would print "Alice", assuming dp remains True.

Wait, perhaps I miscalculated.

Let me re-execute the program for the second test case.

Second test case:

n=2

piles:1 7

unique sorted reverse: [7,1,0]

n=3

for i in 1 to 2:

i=1: dp = (7-1 >1) or True = True or True = True

i=2: dp = (1-0 >1) or True = True or True = True

So, dp remains True, which would print "Alice", but sample output is "Bob".

This suggests that the program is incorrect.

Wait, but perhaps I'm misunderstanding something.

Looking back at the problem, it says: "Assume valid inputs as described in the problem description."

So, I need to assume that the inputs are correct, and determine if the program is correct or not based on the problem description.

Given that, since the program produces "Alice" for the second test case, but the sample output is "Bob", the program is incorrect.

Therefore, Correctness: False.

Wait, but maybe I'm missing something.

Perhaps the unique sorted reverse list and the way dp is updated has a specific meaning.

Let me think differently.

Suppose I consider the game where the number of possible moves is determined by the unique pile sizes.

Each move consists of choosing a k that is at most the smallest pile, and removing k from all piles.

This is similar to choosing a k that is a positive integer less than or equal to the smallest pile, and then reducing each pile by k.

This operation is equivalent to replacing each pile with (a_i - k), but only if a_i >= k; otherwise, the pile is considered empty.

This game resembles a variant of Nim where the moves affect all piles simultaneously.

In such games, the Grundy number (or Nimber) can be used to determine the game's outcome.

The Grundy number for a game position is the mex (minimum excludant) of the Grundy numbers of the positions reachable in one move.

However, calculating the Grundy number for each possible state is not feasible due to the large size of n and a_i.

Therefore, I need a smarter way to compute the winner.

Looking back at the provided program, it seems to be using some kind of DP to determine the winner based on the unique pile sizes.

But as per the second test case, it seems to be giving an incorrect output.

Therefore, I conclude that the program is incorrect.

Correctness: False