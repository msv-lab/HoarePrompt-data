Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in the given array up to that point. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the list. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is missing.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. That's important because it means p doesn't have any duplicates.

I need to find a way to determine each p_i based on the corresponding a_i and possibly some other information I can derive.

Let me consider the MEX function. For a sequence of numbers, MEX is the smallest missing non-negative integer. So, if I have the first i elements of p, I can compute their MEX.

But in this problem, I don't know p, I only know a, which is derived from p through this MEX operation minus p_i.

I need to find a way to reverse-engineer p from a.

Maybe I should look at the properties of MEX and see how it relates to p_i.

Let's consider the value of MEX for the first i elements of p. Let's denote MEX(p_1 to p_i) as m_i. Then, a_i = m_i - p_i, which implies p_i = m_i - a_i.

So, p_i can be expressed in terms of m_i and a_i. If I can find m_i, I can find p_i.

But m_i depends on the previous elements of p, so it's not straightforward to compute m_i directly.

Wait, m_i is the MEX of p_1 to p_i. So, m_i is the smallest non-negative integer not present in p_1 to p_i.

Given that p is a permutation of 0 to n-1, all numbers from 0 to n-1 will eventually appear in p, and MEX will be n once all numbers are present.

But I need to find p_i for each i, based on a_i.

Let me try to think recursively. Suppose I have p_1 to p_{i-1}, and I know a_i. Can I find p_i?

Given p_1 to p_{i-1}, I can compute m_{i-1}, the MEX of p_1 to p_{i-1}.

Then, m_i, the MEX of p_1 to p_i, will depend on what p_i is.

If p_i is not equal to m_{i-1}, then m_i remains m_{i-1}.

If p_i is equal to m_{i-1}, then m_i becomes the next smallest integer not in p_1 to p_i.

Wait, more precisely:

- If p_i is less than m_{i-1}, then m_i remains m_{i-1}, because p_i is already smaller than m_{i-1} and hence m_{i-1} is still the smallest missing integer.

- If p_i is greater than or equal to m_{i-1}, then m_i is m_{i-1} + 1, because m_{i-1} is now present in p_1 to p_i, so the new MEX is m_{i-1} + 1.

So, there's a relationship between m_{i-1}, p_i, and m_i.

Given that, and knowing that a_i = m_i - p_i, perhaps I can find a way to express p_i in terms of a_i and m_{i-1}.

Let me see.

From a_i = m_i - p_i, we have p_i = m_i - a_i.

Now, m_i depends on p_i and m_{i-1}, as described above.

This seems a bit circular. Maybe I need to find a way to express m_i in terms of m_{i-1} and p_i.

From the earlier observation:

- If p_i < m_{i-1}, then m_i = m_{i-1}

- If p_i >= m_{i-1}, then m_i = m_{i-1} + 1

So, m_i is either m_{i-1} or m_{i-1} + 1, depending on p_i.

Given that, and p_i = m_i - a_i, perhaps I can find a way to iterate through the sequence and determine p_i step by step.

But this seems a bit tricky. Maybe there's a better way.

Let me consider the entire sequence.

Since p is a permutation, each number from 0 to n-1 appears exactly once in p.

Also, MEX of p_1 to p_i is the smallest non-negative integer not in p_1 to p_i.

Given that, and the fact that p is a permutation, MEX starts from 0 and increases as numbers are included in p.

Wait, no. Actually, MEX can be any number from 0 to n, depending on the elements in p_1 to p_i.

Wait, no, MEX is the smallest non-negative integer not present, so it can be from 0 to n, inclusive.

But since p contains numbers from 0 to n-1, MEX can be from 0 to n.

Wait, in the example given:

p = [0,1,4,2,3]

a = [1,1,-2,1,2]

Let's verify:

For i=1: MEX(0) = 1, a1 = 1 - 0 = 1

For i=2: MEX(0,1) = 2, a2 = 2 - 1 = 1

For i=3: MEX(0,1,4) = 2, a3 = 2 - 4 = -2

For i=4: MEX(0,1,4,2) = 3, a4 = 3 - 2 = 1

For i=5: MEX(0,1,4,2,3) = 5, a5 = 5 - 3 = 2

Wait, in the problem statement, a5 is given as 2, which matches 5 - 3 = 2.

Wait, but in the problem statement, it says a = [1,1,-2,1,2], which matches the calculations above.

So, in this case, MEX values are [1,2,2,3,5], and p_i are [0,1,4,2,3], and a_i = MEX - p_i.

Now, in this example, MEX increases sometimes when p_i doesn't include the current smallest missing number.

Wait, for i=3, p_i=4, which is greater than m_{i-1}=2, so m_i = m_{i-1} + 1 = 3, but in the calculation above, MEX(0,1,4) is 2, which seems inconsistent with my earlier assumption.

Wait, perhaps I made a mistake in understanding how MEX works.

Let me double-check the MEX definition.

MEX of a set is the smallest non-negative integer not present in the set.

So, for p_1 to p_i = [0,1,4], MEX is 2, since 0 and 1 are present, 2 is missing.

Wait, but 4 is present, but 2 and 3 are missing; the smallest missing is 2.

Yes, so MEX is 2.

Then, for p_1 to p_3 = [0,1,4], MEX is 2.

Then p4=2, so p1 to p4 = [0,1,4,2], MEX is 3, since 0,1,2,4 are present, 3 is missing.

Then p5=3, so p1 to p5 = [0,1,4,2,3], MEX is 5, since 0,1,2,3,4 are present, 5 is missing.

Okay, that makes sense.

So, in this case, a5 = MEX - p5 = 5 - 3 = 2.

Now, in the problem, it's guaranteed that at least one valid p exists for the given a, so I don't have to worry about invalid a arrays.

My task is, given a, find one possible p that satisfies the condition a_i = MEX(p1 to pi) - p_i.

Now, to find p, I need to find a way to reconstruct p from a.

Let me think about the properties of MEX and how it relates to p and a.

Given that p is a permutation, each p_i is unique and ranges from 0 to n-1.

Given that, and knowing a_i = MEX(p1 to pi) - p_i, I need to find p_i.

Let me consider the last element, p_n.

At i=n, MEX(p1 to pn) is the smallest non-negative integer not in p1 to pn.

Since p is a permutation of 0 to n-1, MEX(p1 to pn) is n, because all numbers from 0 to n-1 are present.

Therefore, a_n = n - p_n.

So, p_n = n - a_n.

That's straightforward.

Similarly, for p_{n-1}, MEX(p1 to p_{n-1}) is the smallest non-negative integer not in p1 to p_{n-1}.

Since p_n is already determined, and p is a permutation, MEX(p1 to p_{n-1}) is either n (if n-1 is in p1 to p_{n-1}) or some smaller number.

Wait, no.

Wait, p is a permutation of 0 to n-1, so MEX(p1 to p_{n-1}) is the smallest number from 0 to n not in p1 to p_{n-1}.

Wait, but n is not in p at all, since p contains 0 to n-1.

Wait, MEX is the smallest non-negative integer not in the array.

So, in p1 to p_{n-1}, since p_n is not included, MEX could be any number from 0 to n, depending on what's missing in p1 to p_{n-1}.

Wait, but p contains all numbers from 0 to n-1, so in p1 to p_{n-1}, one number from 0 to n-1 is missing, and n is also missing.

So, MEX would be the smallest missing number in p1 to p_{n-1}, which could be from 0 to n.

Wait, but in the example, for i=4, p1 to p4 = [0,1,4,2], MEX is 3.

So, a4 = 3 - 2 = 1.

Similarly, for i=5, p1 to p5 = [0,1,4,2,3], MEX is 5, a5 = 5 - 3 = 2.

Wait, but in the problem, n=5, and a5 = 2, which matches.

So, in general, for the last element, p_n = n - a_n.

Similarly, for p_{n-1}, MEX(p1 to p_{n-1}) is some value, say m, and a_{n-1} = m - p_{n-1}.

But m is the MEX of p1 to p_{n-1}, which is the smallest missing number in p1 to p_{n-1}.

Given that, and knowing p_n, perhaps I can find a way to determine p_{n-1}.

Wait, maybe I should iterate from the end to the beginning.

Let me try that.

Start with i=n.

p_n = n - a_n.

Then, for i=n-1, MEX(p1 to p_{n-1}) is m_{n-1}, and a_{n-1} = m_{n-1} - p_{n-1}.

So, p_{n-1} = m_{n-1} - a_{n-1}.

But m_{n-1} is the MEX of p1 to p_{n-1}.

Wait, but I don't know m_{n-1} yet.

However, I know that m_{n} is n, since p1 to pn contains all numbers from 0 to n-1, so MEX is n.

Now, m_{n-1} is the MEX of p1 to p_{n-1}.

If p_n is less than m_{n-1}, then m_n = m_{n-1}.

But p_n is determined as n - a_n.

Wait, perhaps I need to consider how MEX changes when adding p_n to p1 to p_{n-1}.

From the earlier observation:

- If p_n < m_{n-1}, then m_n = m_{n-1}.

- If p_n >= m_{n-1}, then m_n = m_{n-1} + 1.

But in this case, m_n is n, as p1 to pn contains all numbers from 0 to n-1.

So, m_n = n.

Now, if p_n < m_{n-1}, then m_n = m_{n-1}.

But m_n is n, so if p_n < m_{n-1}, then m_{n-1} = n.

Otherwise, if p_n >= m_{n-1}, then m_n = m_{n-1} + 1 = n, so m_{n-1} = n - 1.

Therefore, m_{n-1} is either n or n - 1, depending on p_n.

Similarly, p_n = n - a_n.

So, if p_n < m_{n-1}, then m_{n-1} = n.

Else, m_{n-1} = n - 1.

Wait, but p_n = n - a_n, and a_n = n - p_n, so a_n = m_n - p_n = n - p_n.

Therefore, p_n = n - a_n.

Now, m_{n-1} is n if p_n < n, which is always true since p_n is between 0 and n-1, inclusive.

Wait, p_n = n - a_n, and a_n can be from -n to n, but in reality, a_n = n - p_n, and p_n is from 0 to n-1, so a_n is from 1 to n.

Wait, no.

Wait, a_n = MEX(p1 to pn) - p_n = n - p_n.

So, a_n = n - p_n.

Therefore, p_n = n - a_n.

Given that, and p_n is between 0 and n-1, a_n is between 1 and n.

Wait, if p_n = 0, a_n = n - 0 = n.

If p_n = n-1, a_n = n - (n-1) = 1.

So, a_n ranges from 1 to n.

Wait, but in the example, a5 = 2, which is consistent with p5 = 3, since 5 - 3 = 2.

Wait, but in the problem statement, it says -n <= a_i <= n, but in this specific case, a_n is from 1 to n.

Wait, perhaps in general a_i can be negative, depending on the MEX and p_i.

Looking back at the first test case:

p = [0,1,4,2,3]

a = [1,1,-2,1,2]

Wait, a3 = -2, which is less than 1.

So, a_i can be negative.

Wait, but according to my earlier assumption, a_n = n - p_n, which should be from 1 to n.

But in the first test case, n=5, a5=2, p5=3, which is 5 - 3 = 2, fine.

But a3 = -2, which is less than 1. How is that possible?

Wait, perhaps my assumption is incorrect for earlier elements.

Wait, for i=3, a3 = MEX(p1,p2,p3) - p3 = 2 - 4 = -2.

So, a3 is -2.

So, my earlier assumption that a_i = n - p_i only holds for i=n.

For i < n, a_i can be less than 1, as shown in this example.

So, I need a different approach.

Let me try to generalize the approach.

I need to find p_i for each i from 1 to n, given a_i = MEX(p1 to pi) - p_i.

I need to find a way to compute p_i based on a_i and possibly some other information.

Let me consider iterating from the end to the beginning, as I did earlier.

At i=n:

p_n = n - a_n.

Then, for i=n-1:

m_{n-1} = MEX(p1 to p_{n-1}).

But m_{n-1} is the smallest missing number in p1 to p_{n-1}.

Given that, and a_{n-1} = m_{n-1} - p_{n-1}.

So, p_{n-1} = m_{n-1} - a_{n-1}.

But I don't know m_{n-1} yet.

However, I can consider that m_{n-1} is either m_n (if p_n < m_{n-1}) or m_{n-1} + 1 (if p_n >= m_{n-1}).

Wait, m_n is n, and p_n = n - a_n.

Now, if p_n < m_{n-1}, then m_n = m_{n-1}.

But m_n is n, so m_{n-1} = n.

Otherwise, m_n = m_{n-1} + 1 = n, so m_{n-1} = n - 1.

Therefore, m_{n-1} is either n or n - 1.

Now, p_{n-1} = m_{n-1} - a_{n-1}.

But m_{n-1} is either n or n - 1.

So, p_{n-1} is either n - a_{n-1} or (n - 1) - a_{n-1}.

But I need to determine which one it is.

Wait, perhaps I can consider that p_{n-1} must be less than m_{n-1}, because if p_{n-1} >= m_{n-1}, then m_{n} would be m_{n-1} + 1 = n.

But p_n = n - a_n, which is less than m_{n-1}.

Wait, this is getting complicated.

Maybe I need to keep track of the possible m_i values as I iterate backwards.

Let me try to formalize this.

Initialize mex as n.

Then, for i from n down to 1:

p_i = mex - a_i.

if p_i < mex:

mex = mex

else:

mex = mex + 1

Wait, but p_i is determined as mex - a_i.

And then, based on whether p_i < mex or not, mex stays the same or increases by 1.

Wait, but in this case, p_i is determined first, and then mex is updated based on p_i.

But in reality, mex depends on all p1 to pi.

This seems messy.

Wait, perhaps I need to think differently.

Let me consider that mex is the smallest number not present in p1 to pi.

So, as I iterate from i=n down to 1, I can keep track of which numbers have been used in p.

Wait, but p is a permutation, so all numbers from 0 to n-1 are used exactly once.

Wait, perhaps I can maintain a set of available numbers, and determine p_i based on a_i and the current mex.

Let me try to think of an algorithm.

Initialize a deque or a list to build p.

Initialize mex as n.

Then, for each i from n down to 1:

p_i = mex - a_i.

Add p_i to p at position i.

If p_i < mex:

mex = mex

else:

mex = mex + 1

Wait, but in this approach, I'm assuming that mex is determined after adding p_i.

But in reality, mex is determined based on p1 to pi.

This seems flawed.

Wait, maybe I need to keep track of the numbers that have been used so far.

Let me try to think of another way.

Since p is a permutation, I can keep track of which numbers have been used in p so far.

Start from the end, set p_n = n - a_n.

Then, for p_{n-1}, set p_{n-1} = mex - a_{n-1}, where mex is the smallest number not in p1 to p_{n-1}.

Wait, but to find mex for p1 to p_{n-1}, I need to know p1 to p_{n-1}.

This seems circular.

Perhaps I need to maintain a set of used numbers and compute mex accordingly.

Wait, maybe I can use a priority queue or sort the used numbers to find the mex.

But that might be inefficient for large n.

Wait, but n can be up to 2e5, so I need an efficient way.

Let me consider that mex is the smallest number not in p1 to pi.

So, I can keep track of the used numbers up to pi, and find the smallest number not used.

But in code, that would be O(n^2), which is too slow.

I need a better way.

Wait, perhaps I can use a boolean array to mark which numbers are used up to pi.

Then, finding mex is just finding the smallest index in the boolean array that is False.

But again, for n up to 2e5, this might be too slow if done naively.

Wait, but I can optimize the mex finding step.

I can keep track of the unused numbers in a separate data structure, like a heap or a set.

But sets have logarithmic operations, which for 2e5 operations would be too slow.

Wait, perhaps I can precompute the mex for each step.

Wait, maybe I need to think differently.

Looking back at the initial approach, where I iterate from the end to the beginning, setting p_i = mex - a_i, and updating mex accordingly.

Perhaps that's the way to go.

Let me try to implement that logic step by step.

Initialize mex as n.

For i from n down to 1:

p_i = mex - a_i.

if p_i < mex:

mex = mex

else:

mex = mex + 1

Wait, but in this case, if p_i >= mex, then mex should be mex + 1.

But in reality, p_i is determined as mex - a_i, so p_i should be less than mex, because a_i = mex - p_i, which would make a_i positive or zero, but in the example, a_i can be negative.

Wait, in the first test case, a3 = -2, which would imply p3 = mex - (-2) = mex + 2.

If mex is, say, 2, then p3 = 4, which matches the example.

Then, mex would be updated based on p3.

Wait, in the example, for i=3, p3=4, which is greater than mex=2, so mex should be 2 + 1 = 3.

But in reality, in the example, for i=3, MEX(p1,p2,p3)=2, which seems inconsistent with this.

Wait, perhaps my understanding is incorrect.

Let me try to simulate the process for the first test case.

n=5

a = [1,1,-2,1,2]

Initialize mex = 5

i=5:

p5 = 5 - 2 = 3

if p5 < mex: 3 < 5, so mex remains 5

i=4:

p4 = 5 - 1 = 4

if p4 < mex: 4 < 5, so mex remains 5

i=3:

p3 = 5 - (-2) = 7

But in the example, p3=4.

Wait, that doesn't match.

Wait, in the example, a3=-2, so p3 = mex - a_i = 5 - (-2) = 7, but in the example, p3=4.

That's inconsistent.

Wait, perhaps I made a mistake in the mex update.

Wait, perhaps I need to choose the correct mex for each step.

Wait, maybe I need to ensure that p_i is within 0 to n-1.

In the first test case, p3=4, which is valid since n=5.

Wait, but according to my earlier logic, p3 = mex - a_i = 5 - (-2) = 7, which is invalid, since n=5 and p_i should be between 0 and 4.

Wait, perhaps I need to adjust the mex based on whether p_i is used or not.

This is getting too complicated.

Maybe I need to look for an alternative approach.

Let me consider that p is a permutation, so each number from 0 to n-1 appears exactly once.

I can try to find the position of each number in p based on a.

But that seems vague.

Wait, perhaps I can think in terms of building p from the end.

Since p_n = n - a_n, and p_{n-1} depends on a_{n-1} and the current mex, which in turn depends on p_n.

Wait, maybe I need to keep track of the available numbers and choose p_i accordingly.

Wait, perhaps I can use a queue or a deque to keep track of the possible values for p_i.

Let me try to think differently.

Initialize a list of available numbers from 0 to n-1.

Then, iterate from i=n down to 1:

p_i = mex - a_i

Remove p_i from the available numbers.

Update mex based on whether p_i < current mex or not.

Wait, but I need to ensure that p_i is in the available numbers.

In the first test case, for i=5, p5=3, which is available, then remove 3.

For i=4, p4=4, which is available, remove 4.

For i=3, p3=7, which is not available (since n=5), which is invalid.

Wait, but in the example, p3=4, which is already used, but in this case, p3=7, which is invalid.

This suggests that my approach is flawed.

Wait, perhaps I need to choose p_i as the smallest available number that satisfies p_i = mex - a_i.

But that might not always be possible.

Wait, perhaps I need to maintain a set of unused numbers and choose p_i from there.

But this seems too vague.

Let me look back at the provided code to see how it's implemented.

The code does the following:

from collections import deque

def func():

for _ in range(int(input())):

n = int(input())

ar = list(map(int, input().split()))

res = [None] * n

mex = n

for i in range(len(ar)-1, -1, -1):

res[i] = mex - ar[i]

if mex > mex - ar[i]:

mex = mex - ar[i]

print(' '.join((str(x) for x in res)))



So, it iterates from the end to the beginning, setting res[i] = mex - ar[i], and then updating mex if mex > res[i].

Wait, in the first test case, for i=5, ar[4]=2, so res[4] = 5 - 2 = 3

Then, since mex=5 > 3, mex=3

For i=4, ar[3]=1, res[3]=3 - 1=2

mex=3 > 2, so mex=2

For i=3, ar[2]=-2, res[2]=2 - (-2)=4

mex=2 > 4? No, 2 < 4, so mex remains 2

For i=2, ar[1]=1, res[1]=2 - 1=1

mex=2 > 1, so mex=1

For i=1, ar[0]=1, res[0]=1 - 1=0

mex=1 > 0, so mex=0

So, res = [0,1,4,2,3], which matches the first test case.

Okay, so this seems to work for the first test case.

Let's see for the second test case.

n=5

a=[1,1,1,1,1]

Following the same logic:

Initialize mex=5

i=5, ar[4]=1, res[4]=5-1=4

mex=5 > 4, so mex=4

i=4, ar[3]=1, res[3]=4-1=3

mex=4 > 3, so mex=3

i=3, ar[2]=1, res[2]=3-1=2

mex=3 > 2, so mex=2

i=2, ar[1]=1, res[1]=2-1=1

mex=2 > 1, so mex=1

i=1, ar[0]=1, res[0]=1-1=0

mex=1 > 0, so mex=0

So, res=[0,1,2,3,4], which matches the second test case.

Third test case:

n=3

a=[-2,1,2]

Initialize mex=3

i=3, ar[2]=2, res[2]=3-2=1

mex=3 > 1, so mex=1

i=2, ar[1]=1, res[1]=1-1=0

mex=1 > 0, so mex=0

i=1, ar[0]=-2, res[0]=0 - (-2)=2

mex=0 > 2? No, 0 < 2, so mex remains 0

So, res=[2,0,1], which matches the third test case.

Okay, so the code seems to work for the given examples.

Now, I need to verify if this approach is correct in general.

Let's see.

The code sets