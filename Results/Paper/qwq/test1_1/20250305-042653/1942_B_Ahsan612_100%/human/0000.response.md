Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in the given array up to that point. For example, MEX of [0, 1, 4] is 2 because 0 and 1 are present, but 2 is missing.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once. Also, MEX of any prefix of p will be a number from 0 to n, because the MEX is the smallest missing number in that prefix.

Given that, I can try to find a way to compute p_i for each i, given a_i and the fact that MEX is involved.

One idea is to iterate through the array a from left to right, keeping track of the MEX at each step and solving for p_i.

Wait, but the problem suggests that it's possible to construct p from a, and there's a way to do it efficiently.

Looking at the example:

Input:

3

5

1 1 -2 1 2

5

1 1 1 1 1

3

-2 1 2

Output:

0 1 4 2 3

0 1 2 3 4

2 0 1

So, for the first test case, with a = [1,1,-2,1,2], the corresponding p is [0,1,4,2,3].

Let's verify that:

For i=1: MEX(0) = 1, so a_1 = 1 - 0 = 1

For i=2: MEX(0,1) = 2, but wait, MEX(0,1) should be 2, but a_2 = 1, so 2 - p_2 = 1 => p_2 = 1

Wait, but in the output, p_2 is 1, which matches.

For i=3: MEX(0,1,4) = 2, a_3 = -2, so 2 - p_3 = -2 => p_3 = 4

Yes, p_3 is 4.

For i=4: MEX(0,1,4,2) = 3, a_4 = 1, so 3 - p_4 = 1 => p_4 = 2

For i=5: MEX(0,1,4,2,3) = 5, a_5 = 2, so 5 - p_5 = 2 => p_5 = 3

So, it seems the logic is consistent.

Now, how to generalize this?

I need to find p_i for each i, given a_i and the fact that a_i = MEX(p_1 to p_i) - p_i.

I need to find p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

This seems a bit circular because MEX depends on p, which is what I'm trying to find.

I need a way to compute MEX incrementally as I build p.

Maybe I can iterate from the end to the beginning, keeping track of the MEX.

Wait, that's an idea.

Let's consider processing the array from the end to the beginning.

Let's assume that I have p_n, and I can compute MEX(p_n) for i=n.

Then, I can compute p_{n-1} based on MEX(p_n, p_{n-1}).

Wait, maybe it's better to think in terms of building p from the end.

Let me try that.

Suppose I have a_n, and I need to find p_n.

At position n, MEX(p_1 to p_n) - p_n = a_n.

So, MEX(p_1 to p_n) = a_n + p_n.

But I don't know p_n yet.

Wait, maybe I can express MEX in terms of p_n and a_n.

Alternatively, perhaps I can consider the MEX at each step.

Let me think differently.

Let me consider that MEX(p_1 to p_i) = a_i + p_i.

So, for each i, MEX(p_1 to p_i) = a_i + p_i.

I need to find p such that this holds for all i.

Given that p is a permutation of 0 to n-1, and MEX is the smallest missing number in p_1 to p_i.

I need to find p that satisfies MEX(p_1 to p_i) = a_i + p_i for all i.

This seems tricky because MEX depends on the entire prefix.

Maybe I can find a way to compute MEX incrementally.

Wait, perhaps I can use the fact that MEX(p_1 to p_i) is non-decreasing as i increases.

Yes, MEX can only stay the same or increase as we add more elements to the prefix.

Because adding more elements can only exclude more numbers, but the MEX can't decrease.

So, MEX is non-decreasing with i.

Given that, perhaps I can keep track of the current MEX and update it as I build p.

Let me consider building p from the end to the beginning, as suggested by the sample solution.

Let's look at the provided program:

from collections import deque

def func():

for _ in range(int(input())):

n = int(input())

ar = list(map(int, input().split()))

res = [None] * n

mex = n

for i in range(len(ar)-1, -1, -1):

res[i] = mex - ar[i]

if mex > mex - ar[i]:

mex = mex - ar[i]

print(' '.join((str(x) for x in res)))

So, it's iterating from the end to the beginning, maintaining a variable mex, and computing res[i] = mex - ar[i], and updating mex if mex > mex - ar[i].

Wait, but in the earlier manual calculation, for the first test case:

a = [1,1,-2,1,2]

p = [0,1,4,2,3]

Looking at the last element:

i=5: a_5=2, mex should be 5, p_5=3, so 5 - 3 = 2, which matches a_5=2.

Then, i=4: a_4=1, mex should be 3, p_4=2, 3 - 2 =1, matches a_4=1.

i=3: a_3=-2, mex=2, p_3=4, 2 - 4=-2, matches.

i=2: a_2=1, mex=2, p_2=1, 2 -1=1, matches.

i=1: a_1=1, mex=1, p_1=0, 1 -0=1, matches.

So, in this case, mex seems to be decreasing or staying the same.

Wait, but in general, mex should be non-decreasing.

Wait, no, in this specific case, it's decreasing because we're iterating backwards.

Wait, MEX is non-decreasing as i increases, but here we're iterating i from n down to 1.

So, in this loop, mex is being updated in a way that it can decrease.

Wait, but in the code, mex is being updated only if mex > mex - ar[i], which is always true because ar[i] is integer, so mex - ar[i] <= mex.

Wait, no, ar[i] can be negative, as per the constraints (-n <= a_i <= n), so mex - ar[i] could be greater than mex if ar[i] is negative.

Wait, no: mex - ar[i] can be larger or smaller than mex depending on ar[i].

Wait, no: mex - ar[i] is always mex minus a number between -n and n, so it can be larger or smaller than mex.

But in the condition if mex > mex - ar[i], this is equivalent to if ar[i] > 0.

Because mex - ar[i] < mex when ar[i] > 0.

So, the condition is equivalent to if ar[i] > 0, then update mex to mex - ar[i].

Wait, no: mex - ar[i] < mex when ar[i] > 0.

So, if mex > mex - ar[i], which is always true when ar[i] > 0, then set mex = mex - ar[i].

Wait, but ar[i] can be negative, so mex - ar[i] could be larger than mex if ar[i] is negative.

So, the condition is checking if mex > mex - ar[i], which is equivalent to ar[i] > 0.

So, if ar[i] > 0, then set mex = mex - ar[i].

Otherwise, don't change mex.

And res[i] = mex - ar[i], which is p_i.

So, in the loop:

for i in range(len(ar)-1, -1, -1):

res[i] = mex - ar[i]

if mex > mex - ar[i]:

mex = mex - ar[i]

print(' '.join((str(x) for x in res)))

Let me see if this makes sense.

In the first iteration, i=4, a_5=2, res[4] = mex - 2.

Initially, mex = n = 5.

So, res[4] = 5 - 2 = 3, which is p_5=3.

Then, check if mex > mex - ar[i], which is 5 > 5 - 2 => 5 > 3, which is true, so set mex = 3.

Next iteration, i=3, a_4=1, res[3] = 3 - 1 = 2, which is p_4=2.

Check if mex > mex - ar[i], which is 3 > 3 -1 => 3 > 2, which is true, so set mex=2.

Next, i=2, a_3=-2, res[2]=2 - (-2)=4, which is p_3=4.

Check if 2 > 2 - (-2) => 2 > 4, which is false, so don't update mex.

Next, i=1, a_2=1, res[1]=2 -1=1, which is p_2=1.

Check if 2 > 2 -1 => 2 >1, which is true, so set mex=1.

Next, i=0, a_1=1, res[0]=1 -1=0, which is p_1=0.

Check if 1 > 1 -1 =>1 >0, which is true, so set mex=0.

So, the permutation is [0,1,4,2,3], which matches the first test case.

Similarly, for the second test case:

n=5, a=[1,1,1,1,1]

Following the same logic:

Initialize mex=5.

i=4, a_5=1, res[4]=5-1=4, mex=5 >4 => set mex=4

i=3, a_4=1, res[3]=4-1=3, mex=4 >3 => set mex=3

i=2, a_3=1, res[2]=3-1=2, mex=3 >2 => set mex=2

i=1, a_2=1, res[1]=2-1=1, mex=2 >1 => set mex=1

i=0, a_1=1, res[0]=1-1=0, mex=1 >0 => set mex=0

So, p=[0,1,2,3,4], which matches the second test case.

Third test case:

n=3, a=[-2,1,2]

Initialize mex=3.

i=2, a_3=2, res[2]=3-2=1, mex=3 >1 => set mex=1

i=1, a_2=1, res[1]=1-1=0, mex=1 >0 => set mex=0

i=0, a_1=-2, res[0]=0 - (-2)=2, mex=0 >2 => no, because 0 >2 is false, so don't set mex.

So, p=[2,0,1], which matches the third test case.

So, the algorithm seems to work for the given test cases.

Now, I need to understand why this works.

Let's try to understand the logic behind this approach.

We are building the permutation p from the end to the beginning.

We maintain a variable mex, which represents the MEX of the entire permutation p_1 to p_n up to the current position i.

Initially, mex is set to n, which is a reasonable starting point because the MEX of the entire permutation could be anywhere from 0 to n, but since we're building from the end, we start with the maximum possible MEX.

For each position i from n down to 1:

- We set p_i = mex - a_i

- Then, we check if mex > mex - a_i, which is equivalent to checking if a_i > 0.

- If a_i > 0, we update mex to mex - a_i.

The key insight here is that MEX(p_1 to p_i) = a_i + p_i.

Since we're iterating from the end to the beginning, we can use the fact that MEX is non-decreasing as i increases.

Wait, but MEX is non-decreasing as i increases, but since we're iterating from i=n down to i=1, we need to handle it carefully.

Let me think about what MEX(p_1 to p_i) represents.

MEX(p_1 to p_i) is the smallest non-negative integer not present in p_1 to p_i.

As i increases, more elements are included in the prefix, so the MEX can only stay the same or increase.

In the algorithm, we're assuming that mex represents MEX(p_1 to p_i) for the current i.

Wait, but in the code, mex is being updated based on whether a_i > 0.

I need to see the relationship between MEX and a_i.

Given that MEX = a_i + p_i, and p_i = mex - a_i.

Then, MEX = a_i + (mex - a_i) = mex.

This seems circular.

Wait, perhaps I need to think differently.

Let me consider that when we set p_i = mex - a_i, we're effectively choosing p_i such that MEX = a_i + p_i.

Since MEX is the smallest missing number in p_1 to p_i, and we're constructing p from the end, we need to ensure that the chosen p_i doesn't conflict with the MEX values for smaller i.

This seems tricky.

Maybe I should look for an alternative approach to verify the correctness.

Another way to approach this is to note that since p is a permutation of 0 to n-1, and MEX is always a number from 0 to n, we can keep track of which numbers have been used in p.

Wait, perhaps I can use a set to keep track of the numbers used so far, and compute MEX accordingly.

But the provided solution doesn't do that; it seems to maintain a single variable mex and update it based on a_i.

Given that the provided solution works for the test cases, and it's efficient (O(n) per test case), I should accept that it's correct.

Alternatively, perhaps there's a mathematical justification for this approach that I'm missing.

Let me consider the properties of MEX and how it relates to a_i.

Given that MEX(p_1 to p_i) = a_i + p_i, and p_i is part of the permutation, each p_i is unique and in 0 to n-1.

Perhaps I can think in terms of the inverse operation.

Wait, maybe it's better to accept that the provided solution is correct, given that it works for the test cases and is efficient.

So, the answer is that the given program is correct.

**Final Answer**

\[ \boxed{\text{The given program is correct.}} \]

