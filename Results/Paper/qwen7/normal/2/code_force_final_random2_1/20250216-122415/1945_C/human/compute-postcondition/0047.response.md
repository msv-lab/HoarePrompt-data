Postcondition: **`one` is incremented by 1 if `s[i]` is not '0', otherwise it remains unchanged; `zero` is incremented by 1 if `s[i]` is '0', otherwise it remains unchanged; `zero_perc` is recalculated as math.ceil((`zero` - 1) * 100 / (`previous_i` + 4)) if `s[i]` is '0' and (`zero` - 1) / (`previous_i` + 4) * 100 >= 50 and `one_perc` >= 50, otherwise it remains unchanged; `one_perc` is recalculated as math.ceil((`one` - `zero`) * 100 / (len(lst) - (`previous_i` + 1) - 1)) if `zero_perc` >= 50 and `one_perc` >= 50, otherwise it remains unchanged; `lst` now contains `previous_i` + 2 if `s[i]` is '0', otherwise it contains `previous_i` + 3; `zero_perc` is updated to math.ceil(`zero` * 100 / (`i` + 1)); `one_perc` is updated to math.ceil((`one` - `zero`) * 100 / (len(lst) - (`i` + 1))); `lst` now contains `i + 1` if the condition `zero_perc >= 50 and one_perc >= 50` is true. Otherwise, `lst` contains `previous_i` + 2 if `s[i]` is '0', otherwise it contains `previous_i` + 3.**