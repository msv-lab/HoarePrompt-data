#State of the program right berfore the function call: cast is a callable object that can convert string representations of integers into integers, and the input is a space-separated sequence of integers representing the array elements.
def func_1(cast):
    return map(cast, input().split())
    #The program returns a map object that applies the 'cast' function to each element in the input string split by spaces. Each element in the input string should be a string representation of an integer.
#Overall this is what the function does:Functionality: The function accepts a callable object `cast` and a string input. It splits the input string by spaces, converts each element using the `cast` function, and returns a map object containing the converted integers.

#State of the program right berfore the function call: arr is a list of integers, and predicate is a function that takes an integer as input and returns a boolean.
def func_2(arr, predicate):
    l, r = 0, len(arr)
    while l + 1 < r:
        mid = (l + r) // 2
        
        if predicate(arr[mid]):
            l = mid
        else:
            r = mid
        
    #State: Output State: The list `arr` remains unchanged, variable `l` is the leftmost index where the predicate is true or 0 if no such index exists, and `r` is the rightmost index where the predicate is false or the length of `arr` if no such index exists. 
    #
    #In simpler terms, after the loop completes all its iterations, `l` will be the smallest index in the list `arr` for which the predicate returns True, or 0 if no such index exists. Similarly, `r` will be the largest index for which the predicate returns False, or the length of the list if no such index exists. The list `arr` itself does not change during the process.
    if predicate(arr[l]) :
        return l
        #The program returns the leftmost index `l` where the predicate is true or 0 if no such index exists.
    #State: The list `arr` remains unchanged, variable `l` is the leftmost index where the predicate is true or 0 if no such index exists, and `r` is the rightmost index where the predicate is false or the length of `arr` if no such index exists.
    return None
    #None
#Overall this is what the function does:The function `func_2` accepts a list of integers `arr` and a predicate function `predicate`. It performs a binary search to find the leftmost index where the predicate returns `True`. If such an index exists, it returns that index; otherwise, it returns `0`. If no index satisfies the predicate, it returns `None`. The original list `arr` remains unchanged throughout the process.

#State of the program right berfore the function call: arr is a list of integers where each element is in the range [0, 2^30), and predicate is a function that takes an integer and returns a boolean.
def func_3(arr, predicate):
    return func_2(arr, predicate)
    #The program returns a boolean value determined by the function `func_2` applied to the list `arr` and the predicate function.
#Overall this is what the function does:The function accepts a list of integers and a predicate function. It checks whether every integer in the list satisfies the given predicate. If all integers meet the predicate, it returns True; otherwise, it returns False.

#State of the program right berfore the function call: arr is a list of integers, predicate is a function that takes an integer and returns a boolean.
def func_4(arr, predicate):
    result = func_2(arr, predicate)
    if (result is not None) :
        return result + 1
        #The program returns the value of result (which is not None) plus 1
    #State: arr is a list of integers, predicate is a function that takes an integer and returns a boolean, result is the return value of func_2(arr, predicate), and the result is None
    return None
    #The program returns None
#Overall this is what the function does:The function accepts a list of integers `arr` and a predicate function `predicate`. It calls another function `func_2(arr, predicate)` to get a result. If the result is not None, it returns the result plus one; otherwise, it returns None.

#State of the program right berfore the function call: n and q are positive integers such that 2 <= n <= 2 * 10^5 and 1 <= q <= 2 * 10^5. a is a list of integers where each element is in the range [0, 2^30). l and r are positive integers such that 1 <= l < r <= n for each query.
def func_5():
    n, q = func_1(int)
    a = list(func_1(int))
    x = [0]
    inds = defaultdict(list)
    inds[0].append(0)
    for i in a:
        x.append(x[-1] ^ i)
        
        inds[x[-1]].append(len(x) - 1)
        
    #State: Output State: `inds` is a defaultdict with the item `{0: [0, 1, 2, ...], 1: [1, 2, 4, ...], 2: [2, 4, ...], ...}`, `x` is a list containing all the elements generated by the loop, which starts from `[0]` and appends each new value as the result of `x[-1] ^ i` where `i` is the current digit from the list `a`. The length of `x` will be equal to the sum of the digits in `a` plus one.
    #
    #In this final state, the dictionary `inds` will contain keys that are the unique values in the list `x` (excluding the initial 0), and the corresponding values will be lists of indices where these values appear in `x`. The list `x` will include all intermediate results generated during the loop's execution, starting from 0 and ending with the last computed value, with each new value being the result of a bitwise XOR operation between the previous value in `x` and the current digit from the list `a`.
    for i in range(q):
        l, r = func_1(int)
        
        if x[l - 1] == x[r]:
            print('Yes')
            continue
        
        lower = inds[x[r]][func_4(inds[x[r]], lambda arg: arg < l) or 0]
        
        upper = inds[x[l - 1]][func_3(inds[x[l - 1]], lambda arg: arg <= r)]
        
        if upper > lower:
            print('Yes')
        else:
            print('No')
        
    #State: `i` is 2, `q` is a positive integer, `l` is the return value of `func_1(int)`, `r` is the return value of `func_1(int)`, `lower` is the index in `inds[x[r]]` where the element is less than or equal to `l` or the first element if no such element exists, `upper` is the index in `inds[x[l - 1]]` where the element is less than or equal to `r` or the first element if no such element exists.
#Overall this is what the function does:The function processes a list `a` of integers and handles multiple queries defined by pairs of indices `(l, r)`. For each query, it checks if the prefix XOR sums up to `l-1` and `r` are equal. If they are, it prints 'Yes'. Otherwise, it finds the smallest index in the list of indices where the prefix XOR sum is less than `l` and the largest index where the prefix XOR sum is less than or equal to `r`. If the upper bound index is greater than the lower bound index, it prints 'Yes'; otherwise, it prints 'No'. The function does not return any value but prints the results for each query.

