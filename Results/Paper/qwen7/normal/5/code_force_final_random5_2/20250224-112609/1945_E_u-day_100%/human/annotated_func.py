#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of two integers n and x such that 1 ≤ x ≤ n ≤ 2⋅10^5, and a list of integers p which is a permutation of size n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing integers parsed from user input.
#Overall this is what the function does:The function processes user input by splitting it and converting each element to an integer, returning a map object containing these integers.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4, each test case consists of n and x where 1 ≤ x ≤ n ≤ 2⋅10^5, and p is a list of integers representing a permutation of length n.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which we do not have the definition of, but it operates on the variables t, n, x, and p (a permutation list of length n).
#Overall this is what the function does:The function does not accept any direct parameters. Instead, it operates on the variables `t`, `n`, `x`, and `p` (where `p` is a permutation list of length `n`), and returns a list generated by calling `func_1()`.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation, k is an integer such that 1 ≤ k ≤ n, and arr is a list of n distinct integers from 1 to n representing the permutation.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: pos remains -1, i is 9, n is a positive integer, k is an integer such that 1 ≤ k ≤ n, and arr is the result of the function func_2().
    low, high = 0, n
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: Output State: `low` is either `mid` from the last iteration where `arr[mid] <= k`, `high` is `n` if `low + 1` equals `high` and `arr[low] <= k`, `mid` is `(low + high) // 2` from the last iteration, `pos` remains -1, `i` is 9, `n` is a positive integer, `k` is an integer such that \(1 \leq k \leq n\), `arr` is the result of the function `func_2()`, and the set `st` contains the values `(0 + n) // 2`, `mid` from the second iteration, and `mid` from the third iteration. The set `st` will contain all the mid values calculated during the iterations of the loop.
    #
    #This means that after all iterations, the variable `low` will be the largest index such that `arr[low] <= k`, or it will be equal to `high` if `low + 1` equals `high` and `arr[low] <= k`. The variable `high` will be `n` if the loop exits because `low + 1` equals `high` and `arr[low] <= k`. The variable `mid` will hold the last calculated midpoint value. The set `st` will contain all the midpoints calculated during the iterations of the loop.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: n, 0
    #State: `low` is either the largest index such that `arr[low] <= k`, or it is equal to `high` if `low + 1` equals `high` and `arr[low] <= k`. `high` is `n` if the loop exits because `low + 1` equals `high` and `arr[low] <= k`. `mid` holds the last calculated midpoint value. `pos` remains -1, `i` is 9, `n` is a positive integer, `k` is an integer such that \(1 \leq k \leq n\), `arr` is the result of the function `func_2()`, and the set `st` contains the values `(0 + n) // 2`, `mid` from the second iteration, and `mid` from the third iteration. If `arr[low]` is equal to `k`, the function does nothing. Otherwise, `low` is adjusted based on the comparison between `arr[low]` and `k`.
#Overall this is what the function does:The function accepts a positive integer `n`, an integer `k` such that \(1 \leq k \leq n\), and a list `arr` of `n` distinct integers from 1 to `n`. It performs a binary search on `arr` to find the smallest index `low` such that `arr[low] > k`. If `arr[low]` is equal to `k`, it prints 0. Otherwise, it prints 1 followed by `low + 1` and `pos + 1`, where `pos` is initially -1 and remains unchanged. The function returns no value.

