Reasoning:

1. **Problem Understanding**: The problem requires counting the number of beautiful pairs in an array. A pair \(\langle i, j \rangle\) is considered beautiful if \(a_i + a_j\) is divisible by \(x\) and \(a_i - a_j\) is divisible by \(y\).

2. **Key Observations**:
   - For a pair \(\langle i, j \rangle\) to be beautiful, the following must hold:
     \[
     (a_i + a_j) \% x == 0 \quad \text{and} \quad (a_i - a_j) \% y == 0
     \]
   - This can be transformed into:
     \[
     (a_i \% x + a_j \% x) \% x == 0 \quad \text{and} \quad (a_i \% y - a_j \% y) \% y == 0
     \]
   - Simplifying further, we get:
     \[
     (a_i \% x) \% x == 0 \quad \text{and} \quad (a_i \% y) \% y == (a_j \% y) \% y
     \]

3. **Algorithm Analysis**:
   - The provided solution uses modular arithmetic to efficiently count the number of beautiful pairs.
   - It uses two dictionaries (`mod_x_map` and `mod_y_map`) to keep track of the counts of remainders when elements are divided by \(x\) and \(y\).
   - For each element in the array, it calculates the remainder when divided by \(x\) and \(y\), and updates the counts in the respective maps.
   - It also checks if there are any previous elements that have the same remainder when divided by \(y\) and adds those counts to the result.

4. **Code Verification**:
   - The code correctly reads the input and processes each test case.
   - The logic inside `func_1` is sound and follows the correct approach to count the beautiful pairs using modular arithmetic.
   - The implementation handles the constraints and examples provided in the problem statement accurately.

Based on the above reasoning, the provided program correctly implements the solution to the problem.

Correctness: **True**