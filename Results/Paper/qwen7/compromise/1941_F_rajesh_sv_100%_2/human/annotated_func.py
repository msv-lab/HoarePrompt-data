#State of the program right berfore the function call: func is a callable object representing a function that takes no arguments and returns a dictionary.
def func_1(func):
    d = {}
    return wrapper
    #The program returns a wrapper function that takes no arguments and returns a dictionary.
#Overall this is what the function does:The function `func_1` accepts a callable object `func` that returns a dictionary when called. It generates and returns a wrapper function that, when called, returns the same dictionary produced by `func`.

#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. a is a list of n integers where 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. d is a list of m integers where 1 <= d_i <= 10^9. f is a list of k integers where 1 <= f_i <= 10^9.
def wrapper():
    if (args not in d) :
        d[args] = func(*args)
    #State: `t` is an integer such that 1 <= t <= 10^4; `d[args]` is set to the result of `func(*args)` where `args` are the arguments passed to the function; `n`, `m`, `k`, `a`, `f` remain unchanged.
    return d[args]
    #The program returns the result of `func(*args)` where `args` are the arguments passed to the function `func`, stored in `d[args]`
#Overall this is what the function does:The function acts as a wrapper that checks if the result of calling `func(*args)` has already been computed and stored in the dictionary `d` using the arguments `args`. If the result is found in `d`, it returns that result; otherwise, it computes the result by calling `func(*args)`, stores it in `d`, and then returns it. The function itself does not modify the input lists `a` and `f`, nor does it directly accept any parameters.

#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. a is a list of n integers where 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. d is a list of m integers where 1 <= d_i <= 10^9. f is a list of k integers where 1 <= f_i <= 10^9.
def func_2():
    return sys.stdin.readline().strip()
    #The program reads a line from standard input, strips any trailing whitespace, and returns it.
#Overall this is what the function does:The function reads a line from standard input, removes any trailing whitespace, and returns the resulting string.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n, m, and k are integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2⋅10^5. The list a is a sorted list of n integers such that 1 ≤ a_i ≤ 2⋅10^9 and a_i < a_{i+1}. The list d is a list of m integers such that 1 ≤ d_i ≤ 10^9. The list f is a list of k integers such that 1 ≤ f_i ≤ 10^9.
def func_3():
    return int(func_2())
    #The program returns an integer value generated by the function `func_2()` for each test case.
#Overall this is what the function does:The function processes multiple lists (a, d, f) and an integer t, and for each test case, it returns an integer value generated by the function `func_2()`.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n, m, and k are integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2 \cdot 10^5. a is a list of n integers sorted in strictly increasing order such that 1 ≤ a_i ≤ 2 \cdot 10^9. d is a list of m integers such that 1 ≤ d_i ≤ 10^9. f is a list of k integers such that 1 ≤ f_i ≤ 10^9.
def func_4(delimiter):
    return list(map(int, func_2().split(delimiter)))
    #The program returns a list of integers obtained by splitting a string returned from `func_2()` using the `delimiter` and converting each element to an integer.
#Overall this is what the function does:The function accepts a delimiter parameter and returns a list of integers. It achieves this by first calling another function `func_2()` to get a string, then splits this string using the provided delimiter, and finally converts each split element into an integer.

#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. The list a is a sorted list of n integers such that 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. The list d is a list of m integers such that 1 <= d_i <= 10^9. The list f is a list of k integers such that 1 <= f_i <= 10^9.
def func_5():
    return func_2()
    #The program returns the result of calling the function `func_2()` with all the given parameters and lists intact.
#Overall this is what the function does:The function calls another function `func_2()` with the parameters `t`, `n`, `m`, `k`, and the lists `a`, `d`, and `f` intact and returns the result of this call.

#State of the program right berfore the function call: (n, m, k) are positive integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2 × 10^5; A is a list of n strictly increasing integers representing the complexities of the prepared problems, D is a list of unique integers representing the complexities of the models after sorting, F is a list of k integers representing the complexities of the functions; the values of A, D, and F are within the specified ranges.
def func_6():
    n, m, k = func_4()
    A = func_4()
    D = sorted(set(func_4()))
    F = func_4()
    max_diff, next_max_diff, index = -inf, -inf, None
    for i in range(1, n):
        diff = A[i] - A[i - 1]
        
        if diff > max_diff:
            next_max_diff = max_diff
            max_diff = diff
            index = i
        elif diff > next_max_diff:
            next_max_diff = diff
        
    #State: After the loop executes all iterations, the variables will be in the following state: `max_diff` will hold the maximum difference found between consecutive elements in the array `A`, `next_max_diff` will hold the second maximum difference found, `index` will hold the index of the element where `max_diff` was found (or `None` if no valid `max_diff` was found), `i` will be equal to `n`, and `diff` will not be defined since it is a local variable within the loop.
    left, right = A[index - 1], A[index]
    ans = max_diff
    for f in F:
        l = bisect_right(D, left - f)
        
        h = bisect_left(D, right - f) - 1
        
        while l < h:
            mid = l + (h - l) // 2
            mid_sum, mid_next_sum = D[mid] + f, D[mid + 1] + f
            if mid_sum - left < right - mid_next_sum:
                l = mid + 1
            else:
                h = mid
        
        if l == h:
            ans = min(ans, max(D[l] + f - left, right - D[l] - f))
        
    #State: The loop has executed all its iterations, and `ans` holds the minimum value among all updates made during the iterations. `l` and `h` are equal and represent the index in `D` where the final condition `mid_sum - left < right - mid_next_sum` is no longer satisfied. `mid`, `mid_sum`, and `mid_next_sum` retain their last computed values from the final iteration. `f` retains its last value from the final iteration, and `left` and `right` remain unchanged from their values when the loop started.
    print(max(ans, next_max_diff))
    #This is printed: max(ans, next_max_diff)
#Overall this is what the function does:The function calculates and returns the minimum value among the maximum difference found between consecutive elements in the list `A`, and the smallest value that can be obtained by finding pairs `(left, right)` from lists `A`, `D`, and `F` such that `left + f <= right - f` for each `f` in `F`. If no such pair exists, it returns the maximum difference found.

#State of the program right berfore the function call: testcases is a positive integer representing the number of test cases. For each test case, n, m, and k are positive integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. a is a sorted list of n integers where 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. d is a list of m integers where 1 <= d_i <= 10^9. f is a list of k integers where 1 <= f_i <= 10^9.
def func_7():
    testcases = func_3()
    for _ in range(testcases):
        func_6()
        
    #State: Output State: `testcases` is a positive integer minus the total number of iterations (i.e., `testcases - testcases`), and `func_6()` has been called `testcases` times.
    #
    #In simpler terms, after the loop executes all its iterations, `testcases` will be reduced to zero (since it starts as a positive integer and decreases by one with each iteration), and `func_6()` will have been called exactly `testcases` times.
#Overall this is what the function does:The function accepts no explicit parameters but relies on variables set by external functions (`testcases`, `a`, `d`, and `f`). It iterates `testcases` times, calling `func_6()` each time. After completing the iterations, `testcases` is reduced to zero, and `func_6()` has been called exactly `testcases` times. The function does not return any value; its primary action is to validate the input constraints through the calls to `func_6()`.

