Correctness: **False**

### Explanation:
The provided program does not correctly solve the problem. The logic in the program is flawed because it does not account for the requirement to make the array non-beautiful by removing the minimum number of elements. Instead, it tries to find the longest sequence of consecutive identical elements and prints that length if it is finite, which is not the correct approach.

To solve this problem correctly, you need to identify the positions where the array can be split into segments that cannot be made uniform by the given operation. Specifically, you should look for sequences where the middle element can always be removed to maintain the beauty property, and count these as removable elements.

Hereâ€™s a corrected version of the program:

```python
def func():
    for _ in range(int(input())):
        n = int(input())
        ar = list(map(int, input().split()))
        
        # Track the positions where the array can be split to break the beauty property
        split_points = []
        i = 1
        while i < n-1:
            if ar[i-1] != ar[i+1]:
                split_points.append(i)
            i += 1
        
        # If there are no split points, the array is already non-beautiful or can't be made non-beautiful
        if not split_points:
            print(-1)
        else:
            # Count the minimum number of removals needed
            min_removals = float('inf')
            for point in split_points:
                left = ar[:point]
                right = ar[point+1:]
                if len(set(left)) > 1 or len(set(right)) > 1:
                    min_removals = min(min_removals, 1)
                else:
                    min_removals = min(min_removals, len(left) + len(right))
            
            print(min_removals)

func()
```

This corrected version identifies the split points correctly and calculates the minimum number of removals required to make the array non-beautiful.