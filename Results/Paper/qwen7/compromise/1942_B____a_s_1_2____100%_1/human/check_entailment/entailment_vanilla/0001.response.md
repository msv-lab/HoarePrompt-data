### Reasoning:

Let's analyze the given program to determine if it correctly constructs a permutation \( p \) based on the array \( a \).

1. **Input Parsing:**
   - The program reads the number of test cases \( t \).
   - For each test case, it reads the length \( n \) of the permutation and the array \( a \).

2. **Initialization:**
   - It initializes a list `p` of size \( n \) with all elements set to `-1`.
   - It also initializes `mex` (minimum excluded value) to \( n \).

3. **Constructing the Permutation:**
   - The loop runs from \( n-1 \) to \( 0 \). For each index \( i \):
     - It sets \( p[i] \) to \( \text{mex} - a[i] \).
     - It updates `mex` to be the minimum of its current value and the newly assigned value of \( p[i] \).

4. **Output:**
   - It prints the constructed permutation \( p \).

### Analysis:

- **Correctness of the Approach:**
  - The goal is to ensure that \( a_i = \text{MEX}(p_1, p_2, \ldots, p_i) - p_i \).
  - By setting \( p[i] = \text{mex} - a[i] \), the program ensures that the MEX condition is satisfied.
  - The use of `mex` to keep track of the smallest unused value in the permutation is crucial.

- **Handling of `mex`:**
  - The `mex` value is updated to be the minimum of its current value and the newly assigned value of \( p[i] \). This ensures that the smallest unused value is correctly tracked.

- **Edge Cases:**
  - The program handles all edge cases as specified in the problem statement. It guarantees that at least one valid permutation exists and respects the constraints.

### Conclusion:

The program correctly implements the logic to construct a valid permutation \( p \) based on the given array \( a \). Therefore, the program is correct.

### Final Answer:

Correctness: **True**