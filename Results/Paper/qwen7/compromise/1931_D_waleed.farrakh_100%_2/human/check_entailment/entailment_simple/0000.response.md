### Reasoning:

1. **Function `func_1` Analysis:**
   - This function processes each test case and calculates the number of beautiful pairs.
   - It uses a dictionary `freq` to keep track of the frequency of `(a % x, a % y)` pairs.
   - For each element `a` in the array, it calculates `rx = (-a % x + x) % x` and `ry = a % y`.
   - If the pair `(rx, ry)` is already in `freq`, it adds the frequency of this pair to the count.
   - It then updates the frequency of the current pair `(a % x, a % y)` in `freq`.

2. **Function `func_2` Analysis:**
   - This function reads input from stdin, parses it, and constructs the test cases.
   - It reads the number of test cases `t`, then for each test case, it reads `n`, `x`, `y`, and the array `arr`.
   - It constructs a list of test cases and passes it to `func_1`.
   - Finally, it prints the results returned by `func_1`.

3. **Overall Logic:**
   - The logic in `func_1` correctly identifies and counts the beautiful pairs based on the conditions provided.
   - The input reading and parsing in `func_2` correctly constructs the test cases and passes them to `func_1`.
   - The output in `func_2` correctly prints the results.

4. **Edge Cases:**
   - The program handles the edge case where `t` is 0 (no test cases) correctly by returning an empty list.
   - The program correctly handles large inputs (up to \(2 \times 10^5\) elements per array) using efficient modulus operations and dictionaries.

### Conclusion:
Given the analysis, the program correctly implements the logic to find the number of beautiful pairs in the array for each test case. There are no logical errors or inefficiencies that would cause incorrect results.

### Correctness:
**True**