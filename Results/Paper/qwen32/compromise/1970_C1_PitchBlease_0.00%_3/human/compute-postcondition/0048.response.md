The only object in the loop head is the variable `neighbor`, so we can only adjust that one. According to the code, whether the loop can execute depends on the elements in `tree[current]`. If `tree[current]` has more than one element, the loop will execute again for the next element.

At the end of the last iteration, `neighbor` was one of the elements in `tree[current]`. For the loop to execute one more time, there must be at least one more element in `tree[current]` that `neighbor` can take the value of.

State: **`queue` is not empty and may or may not contain an additional tuple `(neighbor, dist + 1)`. `visited` contains all reachable nodes from `start`, and if `neighbor` was not already in `visited`, it is now included. `current` is the first element of the tuple removed from the queue and is a key in `tree` with `tree[current]` having at least two elements. `dist` is the second element of the tuple removed from the queue. `neighbor` is the next element in `tree[current]` that has not yet been processed.**