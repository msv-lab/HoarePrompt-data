Sure, let's create a comprehensive set of test cases for the given problem statement. We will cover both basic and edge cases to ensure the robustness, reliability, and scalability of the solution.

### Basic Test Cases

# Test 1
**Input**: 
```
1
10
.@@*@.**@@
```
**Output**: 
```
3
```
**Explanation**: The optimal path is 1 -> 3 -> 5 -> 8 -> 10, collecting 3 coins.

# Test 2
**Input**: 
```
1
5
.@@@@
```
**Output**: 
```
4
```
**Explanation**: The optimal path is 1 -> 2 -> 3 -> 4 -> 5, collecting 4 coins.

# Test 3
**Input**: 
```
1
15
.@@..@***..@@@*
```
**Output**: 
```
3
```
**Explanation**: The optimal path is 1 -> 2 -> 4 -> 6 -> 9 -> 12 -> 14, collecting 3 coins.

# Test 4
**Input**: 
```
1
2
.@
```
**Output**: 
```
1
```
**Explanation**: The optimal path is 1 -> 2, collecting 1 coin.

# Test 5
**Input**: 
```
1
3
.@*
```
**Output**: 
```
1
```
**Explanation**: The optimal path is 1 -> 2, collecting 1 coin. The third cell has thorns.

### Edge Test Cases

# Test 6
**Input**: 
```
1
1
.
```
**Output**: 
```
0
```
**Explanation**: There is only one cell, which is empty, so no coins can be collected.

# Test 7
**Input**: 
```
1
2
..
```
**Output**: 
```
0
```
**Explanation**: Both cells are empty, so no coins can be collected.

# Test 8
**Input**: 
```
1
5
*****
```
**Output**: 
```
0
```
**Explanation**: All cells have thorns, so no coins can be collected.

# Test 9
**Input**: 
```
1
5
.@.@.
```
**Output**: 
```
2
```
**Explanation**: The optimal path is 1 -> 2 -> 4 -> 5, collecting 2 coins.

# Test 10
**Input**: 
```
1
5
*.*@.
```
**Output**: 
```
1
```
**Explanation**: The optimal path is 1 -> 3 -> 4, collecting 1 coin. The first and third cells have thorns.

# Test 11
**Input**: 
```
1
50
.@@..@***..@@@*..@@..@***..@@@*..@@..@***..@@@*
```
**Output**: 
```
12
```
**Explanation**: The optimal path collects 12 coins by avoiding thorns and maximizing coin pickups.

# Test 12
**Input**: 
```
1
50
..................................................
```
**Output**: 
```
0
```
**Explanation**: All cells are empty, so no coins can be collected.

# Test 13
**Input**: 
```
1
50
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
```
**Output**: 
```
50
```
**Explanation**: All cells have coins, and there are no thorns, so all coins can be collected.

# Test 14
**Input**: 
```
1000
1
.
1
.@
1
.@*
1
5
.@@@@
1
5
*****
1
5
.@.@.
1
5
*.*@.
1
50
.@@..@***..@@@*..@@..@***..@@@*..@@..@***..@@@*
1
50
..................................................
1
50
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
```
**Output**: 
```
0
1
1
4
0
2
1
12
0
50
```
**Explanation**: This test case covers multiple scenarios to ensure the solution handles a large number of test cases efficiently.

These test cases ensure that the solution is robust, handles edge cases, and performs well under various conditions.