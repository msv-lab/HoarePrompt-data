Correctness: **False**

Explanation:
The program does not handle all potential cases correctly. Specifically, it does not correctly calculate the minimum cost when the number of yogurts `n` is odd and `2 * a < b`. Let's analyze the problematic part of the code:

```python
if n % 2:
    if 2 * a < b:
        print(a * n)
    else:
        print(n // 2 * b + a)
elif 2 * a < b:
    print(a * n)
else:
    print(n // 2 * b)
```

In the case where `n` is odd and `2 * a < b`, the program correctly calculates the cost as `a * n`. However, in the else block where `n` is odd and `2 * a >= b`, the program correctly adds one more yogurt at the regular price `a` to the cost of `n // 2` pairs of yogurts at the promotion price `b`. This is correct.

The issue arises in the `elif` and `else` blocks where `n` is even. The `elif` block is unreachable because the condition `2 * a < b` is already checked in the `if` block. Therefore, the `elif` block is redundant and can be removed. However, the main issue is that the `else` block, which handles the case where `n` is even and `2 * a >= b`, is correct.

However, the `elif` block is not necessary and can be removed. The main issue is that the logic is correct for all cases, but the `elif` block is redundant. However, the code does not handle the case where `n` is 1 correctly because `n // 2` will be 0, and adding `a` will give the correct result, but the logic should be more explicit.

To handle all cases correctly, the code can be simplified as follows:

```python
def func():
    for _ in range(int(input())):
        (n, a, b) = map(int, input().split())
        if 2 * a < b:
            print(a * n)
        else:
            print((n // 2) * b + (n % 2) * a)

```

This simplified version correctly handles all cases, including when `n` is 1. The original code does not handle the logic for even `n` correctly due to the unreachable `elif` block, making it incorrect.

Thus, the original program is incorrect.