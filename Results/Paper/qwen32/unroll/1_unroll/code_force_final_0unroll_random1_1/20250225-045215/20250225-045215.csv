Task ID,unique_id,Dataset,model_created,model_run,description,Code,run_number,original correctness,summary fsl,naive correctness fsl,vanilla,vanilla_no_cot,simple tree,complex tree,summary,simple verify fsl,complex verify fsl,summary verify fsl,simple verify,complex verify,summary verify
1945_D,1945_D_vjudge.10_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The guys lined up in a queue of n people, starting with person number i = 1 ,
to ask Serafim the Owl about the meaning of life. Unfortunately, Kirill was
very busy writing the legend for this problem, so he arrived a little later
and stood at the end of the line after the n -th person. Kirill is completely
dissatisfied with this situation, so he decided to bribe some people ahead of
him.

For the i -th person in the queue, Kirill knows two values: a_i and b_i . If
at the moment Kirill is standing at position i , then he can choose any
position j such that j < i and exchange places with the person at position j .
In this case, Kirill will have to pay him a_j coins. And for each k such that
j < k < i , Kirill will have to pay b_k coins to the person at position k .
Kirill can perform this action any number of times.

Kirill is thrifty, so he wants to spend as few coins as possible, but he
doesn't want to wait too long, so Kirill believes he should be among the first
m people in line.

Help Kirill determine the minimum number of coins he will have to spend in
order to not wait too long.

Input

Each test consists of several sets of input data. The first line contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows
the description of the test case.

The first line of each test case contains two integers n and m (1 \le m \le n
\le 200\,000 ) — the number of people in the queue besides Kirill and the
maximum allowable final position of Kirill, respectively.

The second line contains n integers a_1, a_2, \dots, a_n separated by spaces
(1 \le a_i \le 10^9 ).

The third line contains n integers b_1, b_2, \dots, b_n separated by spaces (1
\le b_i \le 10^9 ).

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of coins
Kirill needs to spend.

Example

Input

    4
    
    4 2
    
    7 3 6 9
    
    4 3 8 5
    
    6 2
    
    6 9 7 1 8 3
    
    5 8 8 1 4 1
    
    7 7
    
    7 2 9 2 6 5 9
    
    9 1 10 7 1 4 9
    
    2 1
    
    2 3
    
    1 1

Output

    14
    22
    9
    3","x = int(input())
custos = []
 
for i in range(x):
    custo = 0
    num_fila = 0
    max_p = 0
    a_values = []
    b_values = []
    nf = input().split()
    num_fila = int(nf[0])
    max_p = int(nf[1])
    a = input().split()
    b = input().split()
    for y in a:
        a_values.append(int(y))
    for y in b:
        b_values.append(int(y))
    for y in range(num_fila - 1, max_p - 1, -1):
        if a_values[y] < b_values[y]:
            custo += a_values[y]
        else:
            custo += b_values[y]
    for y in range(max_p - 1, 0, -1):
        if (a_values[y - 1] + b_values[y]) <= a_values[y]:
            custo += b_values[y]
            if y == 1:
                custo += a_values[0]
                break
        else:
            custo += a_values[y]
            break
    custos.append(custo)
    
for c in custos:
    print(c)",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1942_C2,1942_C2_BooMeR1OP_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)","t = int(input())
 
for _ in range(t):
    n, x, y = list(map(int, input().split()))
    a = list(map(int,input().split()))
 
    a = [num - 1 for num in a]  
 
    ans = x - 2
    st = set(a)
    a.sort()
 
    for i in range(x):
        t1 = (a[i] + 1) % n
        t2 = (a[i] + 2) % n
        if t1 not in st and t2 in st:
            ans += 1
 
    odd = []
    even = []
 
    for i in range(x):
        next_elem = a[0] + n if i == x - 1 else a[i + 1]
        gap = next_elem - a[i] - 1
        if gap > 1 and gap % 2 == 1:
            odd.append(gap)
        elif gap > 0 and gap % 2 == 0:
            even.append(gap)
 
    odd.sort()
    even.sort()
 
    for gap in odd:
        if y < gap // 2:
            ans += 2 * y
            y = 0
            break
        ans += gap
        y -= gap // 2
 
    for gap in even:
        if y < gap // 2:
            ans += 2 * y
            y = 0
            break
        ans += gap
        y -= gap // 2
 
    print(ans)",1,True,False,False,False,False,True,False,True,False,False,False,False,False,False
1926_C,1926_C_vjudge.2_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Please note that the time limit for this problem is only 0.5 seconds per test.

Vladislav wrote the integers from 1 to n , inclusive, on the board. Then he
replaced each integer with the sum of its digits.

What is the sum of the numbers on the board now?

For example, if n=12 then initially the numbers on the board are:

Then after the replacement, the numbers become:

The sum of these numbers is 1+2+3+4+5+6+7+8+9+1+2+3=51 . Thus, for n=12 the
answer is 51 .

Input

The first line contains an integer t (1 \leq t \leq 10^4 ) — the number of
test cases.

The only line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the largest number Vladislav writes.

Output

For each test case, output a single integer — the sum of the numbers at the
end of the process.

Example

Input

    7
    
    12
    
    1
    
    2
    
    3
    
    1434
    
    2024
    
    200000

Output

    51
    1
    3
    6
    18465
    28170
    4600002","N = int(2 * 10e4) + 1
 
t = int(input())
 
pd = [0 for _ in range(N)]
 
for i in range(1, N):
    pd[i] += pd[i - 1]    
    for j in str(i):
        pd[i] += int(j)
 
for _ in range(t):    
    n = int(input())
    print(pd[n])",1,True,True,False,True,False,True,True,True,False,False,True,False,True,False
1941_B,1941_B_Mujtaba1122_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Rudolf has an array a of n integers, the elements are numbered from 1 to n .

In one operation, he can choose an index i (2 \le i \le n - 1 ) and assign:

  * a_{i - 1} = a_{i - 1} - 1 
  * a_i = a_i - 2 
  * a_{i + 1} = a_{i + 1} - 1 

Rudolf can apply this operation any number of times. Any index i can be used
zero or more times.

Can he make all the elements of the array equal to zero using this operation?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases in the test.

The first line of each case contains a single integer n (3 \le n \le 2 \cdot
10^5 ) — the number of elements in the array.

The second line of each case contains n integers a_1, a_2, \dots, a_n (0 \le
a_j \le 10^9 ) — the elements of the array.

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output ""YES"" if it is possible to make all the elements of
the array zero using the described operations. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    7
    
    5
    
    1 3 5 5 2
    
    5
    
    2 4 4 5 1
    
    5
    
    0 1 3 3 1
    
    6
    
    5 6 0 2 3 0
    
    4
    
    1 2 7 2
    
    3
    
    7 1 0
    
    4
    
    1 1 1 1

Output

    YES
    NO
    YES
    NO
    NO
    NO
    NO
    
Note

In the first example, the original array is [1, 3, 5, 5, 2] , to make all its
elements zero, Rudolf can act as follows:

  * apply the operation at i=4 and get the array [1, 3, 4, 3, 1] ; 
  * apply the operation at i=3 and get the array [1, 2, 2, 2, 1] ; 
  * apply the operation at i=2 and get the array [0, 0, 1, 2, 1] ; 
  * apply the operation at i=4 and get the array [0, 0, 0, 0, 0] .","def isempty(list,n): 
    for i in range(n):
        if list[i]!=0:
            return False
    return True
 
def rudolf(list,n):
    for i in range(1,n-1):
        while list[i]>1 and list[i-1]>0 and list[i+1]>0:
            list[i-1]-=1*list[i-1]
            list[i]-=2*list[i-1]
            list[i+1]-=1*list[i-1]
    if  isempty(list,n):
        print(""YES"")
    else :
        print(""NO"")
 
 
 
t = int(input())
for i in range(t):
    n = int(input())
    l = input()
    lst = list(map(int,l.split()))
    rudolf(lst,n)",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1971_E,1971_E_M2024_95.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Timur is in a car traveling on the number line from point 0 to point n . The
car starts moving from point 0 at minute 0 .

There are k+1 signs on the line at points 0, a_1, a_2, \dots, a_k , and Timur
knows that the car will arrive there at minutes 0, b_1, b_2, \dots, b_k ,
respectively. The sequences a and b are strictly increasing with a_k = n .

![](https://espresso.codeforces.com/eaf3bfb8e7a8fa4f5e8673f9a02116761cb86c93.png)

Between any two adjacent signs, the car travels with a constant speed. Timur
has q queries: each query will be an integer d , and Timur wants you to output
how many minutes it takes the car to reach point d , rounded down to the
nearest integer.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains three integers n , k , and q , (k
\leq n \leq 10^9 ; 1 \leq k, q \leq 10^5 ) — the final destination, the number
of points Timur knows the time for, and the number of queries respectively.

The second line of each test case contains k integers a_i (1 \leq a_i \leq n ;
a_i < a_{i+1} for every 1 \leq i \leq k-1 ; a_k = n ).

The third line of each test case contains k integers b_i (1 \leq b_i \leq 10^9
; b_i < b_{i+1} for every 1 \leq i \leq k-1 ).

Each of the following q lines contains a single integer d (0 \leq d \leq n ) —
the distance that Timur asks the minutes passed for.

The sum of k over all test cases doesn't exceed 10^5 , and the sum of q over
all test cases doesn't exceed 10^5 .

Output

For each query, output a single integer — the number of minutes passed until
the car reaches the point d , rounded down.

Example

Input

    4
    
    10 1 3
    
    10
    
    10
    
    0
    
    6
    
    7
    
    10 2 4
    
    4 10
    
    4 7
    
    6
    
    4
    
    2
    
    7
    
    1000000000 1 1
    
    1000000000
    
    1000000000
    
    99999999
    
    6 1 3
    
    6
    
    5
    
    2
    
    6
    
    5

Output

    0 6 7 
    5 4 2 5 
    99999999 
    1 5 4 
    
Note

For the first test case, the car goes from point 0 to point 10 in 10 minutes,
so the speed is 1 unit per minute and:

  * At point 0 , the time will be 0 minutes. 
  * At point 6 , the time will be 6 minutes. 
  * At point 7 , the time will be 7 minutes. 

For the second test case, between points 0 and 4 , the car travels at a speed
of 1 unit per minute and between 4 and 10 with a speed of 2 units per minute
and:

  * At point 6 , the time will be 5 minutes. 
  * At point 4 , the time will be 4 minutes. 
  * At point 2 , the time will be 2 minutes. 
  * At point 7 , the time will be 5.5 minutes, so the answer is 5 . 

For the fourth test case, the car travels with 1.2 units per minute, so the
answers to the queries are:

  * At point 2 , the time will be 1.66\dots minutes, so the answer is 1 . 
  * At point 6 , the time will be 5 minutes. 
  * At point 5 , the time will be 4.16\dots minutes, so the answer is 4 .","from bisect import bisect_left
t = int(input())
 
for _ in range(t):
    n, k, q = map(int, input().split())
    a = [0] + list(map(int, input().split()))
    b = [0] + list(map(int, input().split()))
    ad = [0]
    bd = [0]
    for i in range(1, len(a)):
        ad.append(a[i]-a[i-1])
    for i in range(1, len(b)):
        bd.append(b[i]-b[i-1])
    v = [0]
    for i in range(1,len(a)):
        v.append(ad[i]/bd[i])    
    for l in range(q):
        m = 0
        i = 1
        ql = int(input())
        s = bisect_left(a, ql)
        if a[s] == ql:
            print(b[s], end=' ')
            continue
        ql -= a[s-1]
        m += b[s-1]
        m += bd[s] * ql/ad[s]
        print(int(m), end=' ')
    print()",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True
1928_B,1928_B_danielababu_10.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vasya has two hobbies — adding permutations^{\dagger} to arrays and finding
the most frequently occurring element. Recently, he found an array a and
decided to find out the maximum number of elements equal to the same number in
the array a that he can obtain after adding some permutation to the array a .

More formally, Vasya must choose exactly one permutation p_1, p_2, p_3,
\ldots, p_n of length n , and then change the elements of the array a
according to the rule a_i := a_i + p_i . After that, Vasya counts how many
times each number occurs in the array a and takes the maximum of these values.
You need to determine the maximum value he can obtain.

^{\dagger} A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^4 ) — the number of test cases. Then
follows the description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single number — the maximum number of elements
equal to the same number after the operation of adding a permutation.

Example

Input

    7
    
    2
    
    1 2
    
    4
    
    7 1 4 1
    
    3
    
    103 102 104
    
    5
    
    1 101 1 100 1
    
    5
    
    1 10 100 1000 1
    
    2
    
    3 1
    
    3
    
    1000000000 999999997 999999999

Output

    2
    2
    3
    2
    1
    1
    2
    
Note

In the first test case, it is optimal to choose p = [2, 1] . Then after
applying the operation, the array a will be [3, 3] , in which the number 3
occurs twice, so the answer is 2 .

In the second test case, one of the optimal options is p = [2, 3, 1, 4] .
After applying the operation, the array a will be [9, 4, 5, 5] . Since the
number 5 occurs twice, the answer is 2 .","def ii(): return int(input())
 
def mii(): return map(int, input().split())
 
def lii(): return list(map(int, input().split()))
 
def slii(): return sorted(list(map(int, input().split())))
 
def mis(): return map(str, input().split())
 
def lis(): return list(input())
 
def slis(): return sorted(list(map(str, input().split())))
 
def pre(arr):
    ans = []
    tem = 1
    for i in range(len(arr)):
        tem *= arr[i]
        ans.append(tem)
 
    return ans
 
def suf(arr):
    ans = []
    tem = 1
    for i in range(len(arr)-1,-1,-1):
        tem *= arr[i]
        ans.append(tem)
 
    return ans
        
 
        
for _ in range(ii()):
    n = ii()
    arr = lii()
     
    m =  max(arr)
    new= []
    for i in range(n):
        new.append(m - arr[i]+1)
    
    new.sort()
    ans = set()
    for i in new:
        if i <= n and i >0:
            ans.add(i)
    
    print(len(ans))",1,False,False,False,False,False,False,True,False,False,True,False,True,True,False
1946_E,1946_E_shade34_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]","def alge(a, b):
    if b == 0:
        return 1, 0
    if a < b:
        c, d = alge(b, a)
        return d, c
    if a % b == 0:
        return 1, -(a // b - 1)
    c, d = alge(b, a % b)
    return d, c - a // b * d
 
 
def deli(a, b):
    c, d = alge(b, 1000000007)
    return c * a % 1000000007
 
 
#print(75582 * 15 * 120)
facts = [1]
ch = 1
for i in range(1, 200002):
    ch *= i
    ch %= 1000000007
    facts.append(ch)
for _ in range(int(input())):
    #n = int(input())
    n, m1, m2 = map(int, input().split())
    p = list(map(int, input().split()))
    s = list(map(int, input().split()))
    #s = str(input())
    if p[-1] != s[0] or p[0] != 1 or s[-1] != n:
        print(0)
    else:
        ans = 1
        kol = n
        for x in s:
            cnk = deli(facts[kol - 1], facts[n - x] * facts[kol - 1 + x - n])
            #print(cnk, kol - 1, n - x)
            ans *= cnk
            ans %= 1000000007
            kol = n - x
        kol = s[0] - 1
        p2 = []
        for i in range(m1 - 2, -1, -1):
            p2.append(p[i])
        for x in p2:
            cnk = deli(facts[kol - 1], facts[x - 1] * facts[kol - x])
            #print(cnk, kol - 1, x - 1)
            ans *= cnk
            ans %= 1000000007
            kol = x - 1
        for i in range(m1 - 1):
            ans *= facts[p[i + 1] - p[i] - 1]
            ans %= 1000000007
        for i in range(m2 - 1):
            ans *= facts[s[i + 1] - s[i] - 1]
            ans %= 1000000007
        print(ans)
 
# cnk = 1
# for i in range(1, 20):
#     cnk *= i
# print(cnk)",1,True,True,False,False,False,True,True,True,True,True,False,True,True,False
1970_F2,1970_F2_fcmb57_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This afternoon, you decided to enjoy the first days of Spring by taking a walk
outside. As you come near the Quidditch field, you hear screams. Once again,
there is a conflict about the score: the two teams are convinced that they won
the game! To prevent this problem from happening one more time, you decide to
get involved in the refereeing of the matches.

Now, you will stay in the stadium to watch the game and count the score. At
the end of the game, you will decide the winner.

Today, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw
(B) team. Each team is composed of P players (1 \leq P \leq 10 ).

The field is a rectangle of N lines and M columns (3 \leq N, M \leq 99 , N and
M are odd). All the positions are integers, and several entities are allowed
to be at the same position in the field. At the beginning of the game, the
field contains goals for the two teams (each team can own between one and five
goals), the players, and exactly one Quaffle. In this version of the problem,
one Bludger can be present. An other type of ball will be available in the
harder version of the problem.

A game is composed of T steps (0 \leq T \leq 10000 ). At each step, one entity
on the field (a player or a ball) performs one action. All entities can move.
A player can also catch a ball or throw the Quaffle that it is carrying. To
catch a ball, a player must be located on the same cell as it. The Quaffle
does not perform any action while it is being carried; it only follows the
movements of the player. If a player carrying the Quaffle decides to throw it,
the Quaffle is simply put at the current position of the player. If a player
is on the same cell as a Bludger (either after a movement from the player or
the Bludger), the player is eliminated. If the player is eliminated while it
is carrying the Quaffle, the Quaffle remains on the cell containing both the
player and the Bludger after the move. It is guaranteed that this never occurs
while the player is in a cell containing a goal.

To win a point, a player must leave the Quaffle at a goal of the other team.
When it does, the team of the player wins one point, and the Quaffle instantly
moves to the middle of the field (the cell at the (M+1)/2 -th column of the
(N+1)/2 -th line of the field, starting from 1). There is no goal in the
middle of the field. If a player puts the ball in its own goal, the other team
wins the point.

Input

On the first line, the integers N and M .

The description of the field follows: N lines of M pairs of characters
separated by spaces. Each pair of characters represents a position on the
field. It can be either:

  * .. to represent an empty cell 
  * R0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid. 
  * RG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG). 
  * .Q to represent the Quaffle, which is the ball that the players use to score goals. 
  * .B to represent a Bludger.

The next line contains T , the number of steps that compose the game. T lines
follow, each describing one action. It contains several pieces of information
separated by a space. First, a pair of characters representing the entity that
must perform the action. Second, the description of the action:

  * U, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time. 
  * C indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since several balls can be in the same cell. 
  * T indicates that the player throws the Quaffle that it is carrying. 

All the actions performed by the entities are guaranteed to be valid: the
players stay in the field, don't catch a ball if they are not in the same
cell, don't release the Quaffle if they are not carrying it, ...

Output

You must output the description of the main events of the game, one event per
line. More precisely:

  * Each time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team. 
  * Each time a player is eliminated, you must print t p ELIMINATED, where t is the current time and p is the player who is eliminated. The format to print the player is the same as in the input.

The events must be printed in ascending order of t. If several players are
eliminated at the same time, the events must be written in alphabetical order:
B0, ..., B9, R0, ... R9.

At the end of the game, you must print the final score as: FINAL SCORE: r b,
where r is the score of the red team and b is the score of the blue team.

Examples

Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    12
    
    R0 D
    
    R0 C .Q
    
    R0 R
    
    R0 T
    
    R0 D
    
    B0 R
    
    B0 U
    
    B0 C .Q
    
    B0 L
    
    B0 L
    
    B0 L
    
    B0 T

Output

    11 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    5
    
    R0 D
    
    R0 C .Q
    
    R0 L
    
    R0 L
    
    R0 T

Output

    4 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    5 5
    
    .. .. .. .. ..
    
    .. .. .. .. ..
    
    RG R0 .Q B0 BG
    
    .. .. .. .. ..
    
    .. .. .B .. ..
    
    5
    
    .B L
    
    .B U
    
    .B U
    
    B0 L
    
    B0 L

Output

    2 R0 ELIMINATED
    4 B0 ELIMINATED
    FINAL SCORE: 0 0
    
Note

In the first example, the red player takes the Quaffle, move it and throw it.
The blue player catches the ball, goes to the red goal and scores.

In the second example, the red player takes the ball and scores in the goal of
their own team: the blue team wins a point.

In the third example, the Bludger goes at the position of R0: R0 is
eliminated. Then, B0 moves to the position of the Bludger: B0 is eliminated
too.

You can find one more example in the easy version of the problem","""""""
https://codeforces.com/problemset/problem/1970/F2
F2. Playing Quidditch (Medium)
""""""
 
n, m = [int(x) for x in input().split()]
players = dict()
goals = {""B"": [], ""R"": []}
mouvements = {""L"": (-1, 0), ""R"": (1, 0), ""U"": (0, -1), ""D"": (0, 1)}
middle = ((m + 1) // 2, (n + 1) // 2)
quidditch = [middle, """"]
pointsb, pointsr = 0, 0
 
for y in range(n):
    s = input().split()
    for x in range(m):
        if s[x] == "".."":
            continue
        elif s[x] == "".Q"":
            quidditch[0] = (x, y)
        elif s[x] == ""RG"":
            goals[""R""].append((x, y))
        elif s[x] == ""BG"":
            goals[""B""].append((x, y))
        else:
            players[s[x]] = (x, y)
 
 
def add(a, b):
    x, y = a
    dx, dy = b
    return x + dx, y + dy
 
 
moves = int(input())
for i in range(moves):
    mo = input().split()
    if mo[0] == "".Q"":
        quidditch[0] = add(quidditch[0], mouvements[mo[1]])
    elif mo[1] in ""ULDR"":
        players[mo[0]] = add(players[mo[0]], mouvements[mo[1]])
        if "".B"" in players:
            elimines = []
            for k, v in players.items():
                if k != "".B"" and v == players["".B""]:
                    elimines.append(k)
            elimines.sort()
            for c in elimines:
                print(i, c, ""ELIMINATED"")
                if quidditch[1] == c:
                    quidditch = [players[c], """"]
                del players[c]
    elif mo[1] == ""C"":
        quidditch[1] == mo[0]
    elif mo[1] == ""T"":
        quidditch[1] = """"
        if players[mo[0]] in goals[""R""]:
            pointsb += 1
            print(i, ""BLUE GOAL"")
            if mo[0][0] == ""R"":
                quidditch[0] = middle
            else:
                quidditch[0] = players[mo[0]]
        if players[mo[0]] in goals[""B""]:
            pointsr += 1
            print(i, ""RED GOAL"")
            if mo[0][0] == ""B"":
                quidditch[0] = middle
            else:
                quidditch[0] = players[mo[0]]
print(""FINAL SCORE:"", pointsr, pointsb)",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1928_B,1928_B_danielababu_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vasya has two hobbies — adding permutations^{\dagger} to arrays and finding
the most frequently occurring element. Recently, he found an array a and
decided to find out the maximum number of elements equal to the same number in
the array a that he can obtain after adding some permutation to the array a .

More formally, Vasya must choose exactly one permutation p_1, p_2, p_3,
\ldots, p_n of length n , and then change the elements of the array a
according to the rule a_i := a_i + p_i . After that, Vasya counts how many
times each number occurs in the array a and takes the maximum of these values.
You need to determine the maximum value he can obtain.

^{\dagger} A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^4 ) — the number of test cases. Then
follows the description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single number — the maximum number of elements
equal to the same number after the operation of adding a permutation.

Example

Input

    7
    
    2
    
    1 2
    
    4
    
    7 1 4 1
    
    3
    
    103 102 104
    
    5
    
    1 101 1 100 1
    
    5
    
    1 10 100 1000 1
    
    2
    
    3 1
    
    3
    
    1000000000 999999997 999999999

Output

    2
    2
    3
    2
    1
    1
    2
    
Note

In the first test case, it is optimal to choose p = [2, 1] . Then after
applying the operation, the array a will be [3, 3] , in which the number 3
occurs twice, so the answer is 2 .

In the second test case, one of the optimal options is p = [2, 3, 1, 4] .
After applying the operation, the array a will be [9, 4, 5, 5] . Since the
number 5 occurs twice, the answer is 2 .","def ii(): return int(input())
 
def mii(): return map(int, input().split())
 
def lii(): return list(map(int, input().split()))
 
def slii(): return sorted(list(map(int, input().split())))
 
def mis(): return map(str, input().split())
 
def lis(): return list(input())
 
def slis(): return sorted(list(map(str, input().split())))
 
def pre(arr):
    ans = []
    tem = 1
    for i in range(len(arr)):
        tem *= arr[i]
        ans.append(tem)
 
    return ans
 
def suf(arr):
    ans = []
    tem = 1
    for i in range(len(arr)-1,-1,-1):
        tem *= arr[i]
        ans.append(tem)
 
    return ans
        
 
from bisect import bisect_left        
for _ in range(ii()):
    n = ii()
    arr = sorted(list(set(lii())))
     
    m =  max(arr)
    ans = 0
    for i in range(len(arr)):
        a = bisect_left(arr,arr[i]+n)
        d = a - i
        ans = max(ans,d)
    
 
    
    print(ans)",1,True,True,False,False,False,True,True,True,True,True,False,True,True,False
1970_A1,1970_A1_sujalkumar_sharma_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"A parentheses sequence is a string consisting of characters ""("" and "")"", for
example ""(()(("".

A balanced parentheses sequence is a parentheses sequence which can become a
valid mathematical expression after inserting numbers and operations into it,
for example ""(()(()))"".

The balance of a parentheses sequence is defined as the number of opening
parentheses ""("" minus the number of closing parentheses "")"". For example, the
balance of the sequence ""(()(("" is 3.

A balanced parentheses sequence can also be defined as a parentheses sequence
with balance 0 such that each of its prefixes has a non-negative balance.

We define the balanced shuffle operation that takes a parentheses sequence and
returns a parentheses sequence as follows: first, for every character of the
input sequence, we compute the balance of the prefix of the sequence before
that character and write those down in a table together with the positions of
the characters in the input sequence, for example:

Prefix balance| 0| 1| 2| 1| 2| 3| 2| 1  
---|---|---|---|---|---|---|---|---  
Position| 1| 2| 3| 4| 5| 6| 7| 8  
Character| (| (| )| (| (| )| )| )  
  
Then, we sort the columns of this table in increasing order of prefix balance,
breaking ties in decreasing order of position. In the above example, we get:

Prefix balance| 0| 1| 1| 1| 2| 2| 2| 3  
---|---|---|---|---|---|---|---|---  
Position| 1| 8| 4| 2| 7| 5| 3| 6  
Character| (| )| (| (| )| (| )| )  
  
The last row of this table forms another parentheses sequence, in this case
""()(()())"". This sequence is called the result of applying the balanced
shuffle operation to the input sequence, or in short just the balanced shuffle
of the input sequence.

You are given a balanced parentheses sequence. Print its balanced shuffle.

Input

The only line of input contains a string s consisting only of characters ""(""
and "")"". This string is guaranteed to be a non-empty balanced parentheses
sequence with its length not exceeding 500\,000 .

Output

Print the parentheses sequence t — the balanced shuffle of s .

Example

Input

    (()(()))
    
Output

    ()(()())","def balanced_shuffle(s):
    n = len(s)
    prefix_balance = []
    balance = 0
    
    for i in range(n):
        prefix_balance.append((balance, i, s[i]))
        if s[i] == '(':
            balance += 1
        else:
            balance -= 1
    
    prefix_balance.sort(key=lambda x: (x[0], -x[1]))
    
    result = ''.join([x[2] for x in prefix_balance])
    
    return result
 
s = input().strip()
print(balanced_shuffle(s))",1,True,True,False,True,True,True,True,True,True,True,True,True,True,True
1955_F,1955_F_the_mehedi_8.33%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob gathered in the evening to play an exciting game on a sequence
of n integers, each integer of the sequence doesn't exceed 4 . The rules of
the game are too complex to describe, so let's just describe the winning
condition — Alice wins if the [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
all the numbers in the sequence is non-zero; otherwise, Bob wins.

The guys invited Eve to act as a judge. Initially, Alice and Bob play with n
numbers. After one game, Eve removes one of the numbers from the sequence,
then Alice and Bob play with n-1 numbers. Eve removes one number again, after
which Alice and Bob play with n - 2 numbers. This continues until the sequence
of numbers is empty.

Eve seems to think that in such a game, Alice almost always wins, so she wants
Bob to win as many times as possible. Determine the maximum number of times
Bob can win against Alice if Eve removes the numbers optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first and only line of each test case contains four integers p_i (0 \le
p_i \le 200 ) — the number of ones, twos, threes, and fours in the sequence at
the beginning of the game.

Output

For each test case, print the maximum number of times Bob will win in a
separate line, if Eve removes the numbers optimally.

Example

Input

    5
    
    1 1 1 0
    
    1 0 1 2
    
    2 2 2 0
    
    3 3 2 0
    
    0 9 9 9

Output

    1
    1
    3
    3
    12
    
Note

In the first example, Bob wins when Eve has not removed any numbers yet.

In the second example, Bob wins if Eve removes one one and one three.","import math
for _ in range(int(input())):
    a = list(map(int,input().split()))
    cnt = 0
    if a[0]==a[1]==a[2] and a[0]%2==1:
        cnt+=1
    for x in a:
        cnt+=math.floor(x/2)
    print(cnt)",1,False,True,True,True,True,True,False,False,False,False,False,True,True,True
1937_A,1937_A_Morphy0123_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array a_1, a_2, \ldots, a_n . Initially, a_i=i for each 1 \le
i \le n .

The operation \texttt{swap}(k) for an integer k \ge 2 is defined as follows:

  * Let d be the largest divisor^\dagger of k which is not equal to k itself. Then swap the elements a_d and a_k . 

Suppose you perform \texttt{swap}(i) for each i=2,3,\ldots, n in this exact
order. Find the position of 1 in the resulting array. In other words, find
such j that a_j = 1 after performing these operations.

^\dagger An integer x is a divisor of y if there exists an integer z such that
y = x \cdot z .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^4 ). The description of the test cases follows.

The only line of each test case contains one integer n (1 \le n \le 10^9 ) —
the length of the array a .

Output

For each test case, output the position of 1 in the resulting array.

Example

Input

    4
    
    1
    
    4
    
    5
    
    120240229

Output

    1
    4
    4
    67108864
    
Note

In the first test case, the array is [1] and there are no operations
performed.

In the second test case, a changes as follows:

  * Initially, a is [1,2,3,4] . 
  * After performing \texttt{swap}(2) , a changes to [\underline{2},\underline{1},3,4] (the elements being swapped are underlined). 
  * After performing \texttt{swap}(3) , a changes to [\underline{3},1,\underline{2},4] . 
  * After performing \texttt{swap}(4) , a changes to [3,\underline{4},2,\underline{1}] . 

Finally, the element 1 lies on index 4 (that is, a_4 = 1 ). Thus, the answer
is 4 .","from math import log2
n_cases = int(input())
 
for i in range(n_cases):
    n = int(input())
    if n == 1:
        print(1)
    else:
        power = 1
        n = log2(n)
        while power < n:
            power += 1
        
        if power == n:
            print(2 ** power)
        else:
            power -= 1
            print(2 ** power)",1,True,False,False,True,True,True,True,True,False,False,False,True,True,True
1942_B,1942_B_IntruSieve_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[MOOO! - Doja Cat](https://soundcloud.com/amalaofficial/mooo)

⠀

Farmer John has a permutation p_1, p_2, \ldots, p_n , where every integer from
0 to n-1 occurs exactly once. He gives Bessie an array a of length n and
challenges her to construct p based on a .

The array a is constructed so that a_i = \texttt{MEX}(p_1, p_2, \ldots, p_i) -
p_i , where the \texttt{MEX} of an array is the minimum non-negative integer
that does not appear in that array. For example, \texttt{MEX}(1, 2, 3) = 0 and
\texttt{MEX}(3, 1, 0) = 2 .

Help Bessie construct any valid permutation p that satisfies a . The input is
given in such a way that at least one valid p exists. If there are multiple
possible p , it is enough to print one of them.

Input

The first line contains t (1 \leq t \leq 10^4 ) — the number of test cases.

The first line of each test case contains an integer n (1 \leq n \leq 2 \cdot
10^5 ) — the lengths of p and a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-n \leq a_i \leq n ) — the elements of array a .

It is guaranteed that there is at least one valid p for the given data.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output n integers on a new line, the elements of p .

If there are multiple solutions, print any of them.

Example

Input

    3
    
    5
    
    1 1 -2 1 2
    
    5
    
    1 1 1 1 1
    
    3
    
    -2 1 2

Output

    0 1 4 2 3 
    0 1 2 3 4 
    2 0 1 
    
Note

In the first case, p = [0, 1, 4, 2, 3] is one possible output.

a will then be calculated as a_1 = \texttt{MEX}(0) - 0 = 1 , a_2 =
\texttt{MEX}(0, 1) - 1 = 1 , a_3 = \texttt{MEX}(0, 1, 4) - 4 = -2 , a_4 =
\texttt{MEX}(0, 1, 4, 2) - 2 = 1 , a_5 = \texttt{MEX}(0, 1, 4, 2, 3) - 3 = 2 .

So, as required, a will be [1, 1, -2, 1, 2] .","def what_the_mex():
    n = int(input())
    arr = list(map(int , input().split()))
    mex = []
    minn = 0
    used = {}
    for i in range(n):
        if arr[i] > 0:
            mex.append(minn)
            used[minn] = True
            while minn in used:
                minn += 1
        else:
            mex.append(abs(arr[i] - minn))
            used[abs(arr[i] - minn)] = True   
    for itm in mex:
        print(itm , end = ' ')
    print()
    
for _ in range(int(input())):
    what_the_mex()",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1921_C,1921_C_rujhaan_taneja_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Stepan is a very busy person. Today he needs to send n messages at moments
m_1, m_2, \dots m_n (m_i < m_{i + 1} ). Unfortunately, by the moment 0 , his
phone only has f units of charge left. At the moment 0 , the phone is turned
on.

The phone loses a units of charge for each unit of time it is on. Also, at any
moment, Stepan can turn off the phone and turn it on later. This action
consumes b units of energy each time. Consider turning on and off to be
instantaneous, so you can turn it on at moment x and send a message at the
same moment, and vice versa, send a message at moment x and turn off the phone
at the same moment.

If at any point the charge level drops to 0 (becomes \le 0 ), it is impossible
to send a message at that moment.

Since all messages are very important to Stepan, he wants to know if he can
send all the messages without the possibility of charging the phone.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. This is followed by the descriptions of the test
cases.

The first line of each test case contains four integers n , f , a , and b (1
\le n \le 2 \cdot 10^5 , 1 \le f, a, b \le 10^9 ) — the number of messages,
the initial phone's charge, the charge consumption per unit of time, and the
consumption when turned off and on sequentially.

The second line of each test case contains n integers m_1, m_2, \dots, m_n (1
\le m_i \le 10^9 , m_i < m_{i + 1} ) — the moments at which messages need to
be sent.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output ""YES"" if Stepan can send all the messages, and ""NO""
otherwise.

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    6
    
    1 3 1 5
    
    3
    
    7 21 1 3
    
    4 6 10 13 17 20 26
    
    5 10 1 2
    
    1 2 3 4 5
    
    1 1000000000 1000000000 1000000000
    
    1000000000
    
    3 11 9 6
    
    6 8 10
    
    12 621526648 2585904 3566299
    
    51789 61859 71998 73401 247675 298086 606959 663464 735972 806043 806459 919683

Output

    NO
    YES
    YES
    NO
    NO
    YES
    
Note

In the first test case of the example, at moment 0 , the phone's charge is 3 .
When sending a message at moment 3 without turning it off, (3 - 0) \cdot 1 = 3
units of charge will be spent. In this case, the charge will drop to 0 and
Stepan will not be able to send the message. When turning off and on, the
phone's charge will decrease by 5 , so it will not be possible to send the
message in this way.

In the third test case of the example, at moment 0 , the phone's charge is 10
. The phone loses 1 unit of charge per unit of time, and when turned off and
on, it loses 2 units of charge. To send all messages, the following actions
can be taken:

  * Turn off the phone at moment 0 and turn it on at moment 1 , after which 10 - 2 = 8 units of charge will remain; 
  * send a message at moment 1 ; 
  * send a message at moment 2 , after which 8 - (2 - 1) \cdot 1 = 7 units of charge will remain; 
  * Turn off the phone at moment 2 and turn it on at moment 3 , after which 7 - 2 = 5 units of charge will remain; 
  * send a message at moment 3 ; 
  * Turn off the phone at moment 3 and turn it on at moment 4 , after which 5 - 2 = 3 units of charge will remain; 
  * send a message at moment 4 ; 
  * Turn off the phone at moment 4 and turn it on at moment 5 , after which 3 - 2 = 1 unit of charge will remain; 
  * send a message at moment 5 . 

The last (sixth) test set of the example may fail if there is an integer
overflow in your solution.","test_cases=int(input())
for i in range (test_cases):
    feat=[int(i) for i in input(). split(' ')]
    n=feat[0]
    f=feat[1]
    a=feat[2]
    b=feat[-1]
    arr=[int(i) for i in input().split(' ')]
    array2=[]
    for i in range (0,n):
        if i==0:
            if arr[0]<b/a:
                array2.append(arr[0]*a)
        else:    
            if (arr[i]-arr[i-1])<b/a:
                array2.append((arr[i]-arr[i-1])*a)
    if (sum(array2)+(n-len(array2))*b)<f:
        print('Yes')
    else:
        print('No')",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1929_B,1929_B_muhammadhamid_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a
drawing and attract her attention.

As a drawing, he decided to draw a square grid of size n \times n , in which
some cells are colored. But coloring the cells is difficult, so he wants to
color as few cells as possible. But at the same time, he wants at least k
diagonals to have at least one colored cell. Note that the square grid of size
n \times n has a total of 4n - 2 diagonals.

Help little Sasha to make the girl fall in love with him and tell him the
minimum number of cells he needs to color.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 1000 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (2 \leq n \leq
10^8 , 1 \leq k \leq 4n - 2 ) — the size of the square grid and the minimum
number of diagonals in which there should be at least one colored cell.

Output

For each test case, output a single integer — the minimum number of cells that
need to be colored.

Example

Input

    7
    
    3 4
    
    3 3
    
    3 10
    
    3 9
    
    4 7
    
    7 11
    
    2 3

Output

    2
    2
    6
    5
    4
    6
    2
    
Note

In the pictures below, the colored cells are marked in black, and all
diagonals are marked in purple.

In the first test case, you can color 2 cells so that 4 diagonals contain at
least one colored cell:

![](https://espresso.codeforces.com/c88e80de5be4f91764dbe5bdc534c50fec115db3.png)

In the third test case, you can color 6 cells so that all 10 diagonals contain
at least one colored cell:

![](https://espresso.codeforces.com/624a36083689f6fb20bf243e5d1707fdcd71ef60.png)","import math
 
for _ in range(int(input())):
    #n=int(input())
    n,k=(map(int,input().split()))
    if k ==1:
        print(1)
        continue
 
    if k<=2*(n+(n-2)):
        print(math.ceil(k/2))
    else:
        print(k//2 +1)",1,True,False,False,False,False,True,True,False,True,True,False,False,False,False
1926_E,1926_E_Venkatesh0987_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vladislav has n cards numbered 1, 2, \dots, n . He wants to lay them down in a
row as follows:

  * First, he lays down all the odd-numbered cards from smallest to largest. 
  * Next, he lays down all cards that are twice an odd number from smallest to largest (i.e. 2 multiplied by an odd number). 
  * Next, he lays down all cards that are 3 times an odd number from smallest to largest (i.e. 3 multiplied by an odd number). 
  * Next, he lays down all cards that are 4 times an odd number from smallest to largest (i.e. 4 multiplied by an odd number). 
  * And so on, until all cards are laid down. 

What is the k -th card he lays down in this process? Once Vladislav puts a
card down, he cannot use that card again.

Input

The first line contains an integer t (1 \leq t \leq 5 \cdot 10^4 ) — the
number of test cases.

The only line of each test case contains two integers n and k (1 \leq k \leq n
\leq 10^9 ) — the number of cards Vlad has, and the position of the card you
need to output.

Output

For each test case, output a single integer — the k -th card Vladislav lays
down.

Example

Input

    11
    
    7 1
    
    7 2
    
    7 3
    
    7 4
    
    7 5
    
    7 6
    
    7 7
    
    1 1
    
    34 14
    
    84 19
    
    1000000000 1000000000

Output

    1
    3
    5
    7
    2
    6
    4
    1
    27
    37
    536870912
    
Note

In the first seven test cases, n=7 . Vladislav lays down the cards as follows:

  * First — all the odd-numbered cards in the order 1 , 3 , 5 , 7 . 
  * Next — all cards that are twice an odd number in the order 2 , 6 . 
  * Next, there are no remaining cards that are 3 times an odd number. (Vladislav has only one of each card.) 
  * Next — all cards that are 4 times an odd number, and there is only one such card: 4 . 
  * There are no more cards left, so Vladislav stops. 

Thus the order of cards is 1 , 3 , 5 , 7 , 2 , 6 , 4 .","for _ in range(int(input())):
    n, k = map(int, input().split())
    s = 0
    i = 0
    d = n
    h = n
    p = 1
    g = 0
 
    if k > (n + 1) // 2:
        while s < k and d > 0:
            s += (d + 1) // 2
            d -= (d + 1) // 2
            i += 1
        
        while p <= (i - 1):
            g += (h + 1) // 2
            h -= (h + 1) // 2
            p += 1
        
        f = k - g
        y = (2**(i-1)) *(2*f-1)
        print(y)
    else:
        print(2*k - 1)",1,True,True,False,True,False,True,True,True,False,True,False,True,True,True
1932_B,1932_B_permaximum_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).","def apocalypse(t, test_cases):
    results = []
    for test in test_cases:
        n, a = test
        current_year = 0
        for ai in a:
            # Find the next year when the sign ai occurs
            if current_year % ai == 0:
                next_year = current_year + ai
            else:
                next_year = ((current_year // ai) + 1) * ai
            current_year = next_year
        results.append(current_year)
    return results
 
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    test_cases.append((n, a))
 
# Get results
results = apocalypse(t, test_cases)
 
# Print results
for result in results:
    print(result)",1,True,True,True,True,True,True,True,True,True,True,True,True,True,True
1926_E,1926_E_Joyboy1730_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vladislav has n cards numbered 1, 2, \dots, n . He wants to lay them down in a
row as follows:

  * First, he lays down all the odd-numbered cards from smallest to largest. 
  * Next, he lays down all cards that are twice an odd number from smallest to largest (i.e. 2 multiplied by an odd number). 
  * Next, he lays down all cards that are 3 times an odd number from smallest to largest (i.e. 3 multiplied by an odd number). 
  * Next, he lays down all cards that are 4 times an odd number from smallest to largest (i.e. 4 multiplied by an odd number). 
  * And so on, until all cards are laid down. 

What is the k -th card he lays down in this process? Once Vladislav puts a
card down, he cannot use that card again.

Input

The first line contains an integer t (1 \leq t \leq 5 \cdot 10^4 ) — the
number of test cases.

The only line of each test case contains two integers n and k (1 \leq k \leq n
\leq 10^9 ) — the number of cards Vlad has, and the position of the card you
need to output.

Output

For each test case, output a single integer — the k -th card Vladislav lays
down.

Example

Input

    11
    
    7 1
    
    7 2
    
    7 3
    
    7 4
    
    7 5
    
    7 6
    
    7 7
    
    1 1
    
    34 14
    
    84 19
    
    1000000000 1000000000

Output

    1
    3
    5
    7
    2
    6
    4
    1
    27
    37
    536870912
    
Note

In the first seven test cases, n=7 . Vladislav lays down the cards as follows:

  * First — all the odd-numbered cards in the order 1 , 3 , 5 , 7 . 
  * Next — all cards that are twice an odd number in the order 2 , 6 . 
  * Next, there are no remaining cards that are 3 times an odd number. (Vladislav has only one of each card.) 
  * Next — all cards that are 4 times an odd number, and there is only one such card: 4 . 
  * There are no more cards left, so Vladislav stops. 

Thus the order of cards is 1 , 3 , 5 , 7 , 2 , 6 , 4 .","t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    L=[]
    while n:
        m=(n+1)//2
        n-=m
        L.append(m)
    tot=0;pow=1
    for a in L:
        if tot<k and k<=tot+a:
            print(pow*(2*(k-tot)-1))
        tot+=a
        pow*=2",1,True,True,False,True,False,False,True,True,True,False,True,True,True,True
1971_B,1971_B_omg_0014_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a string s consisting of lowercase English letters.

Rearrange the characters of s to form a new string r that is not equal to s ,
or report that it's impossible.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains a string s of length at most 10
consisting of lowercase English letters.

Output

For each test case, if no such string r exists as described in the statement,
output ""NO"" (without quotes).

Otherwise, output ""YES"" (without quotes). Then, output one line — the string r
, consisting of letters of string s .

You can output ""YES"" and ""NO"" in any case (for example, strings ""yEs"", ""yes"",
and ""Yes"" will be recognized as a positive response).

If multiple answers are possible, you can output any of them.

Example

Input

    8
    
    codeforces
    
    aaaaa
    
    xxxxy
    
    co
    
    d
    
    nutdealer
    
    mwistht
    
    hhhhhhhhhh

Output

    YES
    forcodesec
    NO
    YES
    xxyxx
    YES
    oc
    NO
    YES
    undertale
    YES
    thtsiwm
    NO
    
Note

In the first test case, another possible answer is \texttt{forcescode} .

In the second test case, all rearrangements of \texttt{aaaaa} are equal to
\texttt{aaaaa} .","n = int(input()) 
for i in range(n):
    s = input()
    a = set(s)  
    if len(a) == 2: 
        print(""NO"")
    else:
        print(""YES"")
        b=("""".join(sorted(s)))
        c=("""".join(sorted(s,reverse=True)))
        if b==s:
            print(c)
        else:
            print(b)",1,False,True,False,True,False,True,True,True,False,False,False,True,True,True
1945_D,1945_D_joaod_12.50%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The guys lined up in a queue of n people, starting with person number i = 1 ,
to ask Serafim the Owl about the meaning of life. Unfortunately, Kirill was
very busy writing the legend for this problem, so he arrived a little later
and stood at the end of the line after the n -th person. Kirill is completely
dissatisfied with this situation, so he decided to bribe some people ahead of
him.

For the i -th person in the queue, Kirill knows two values: a_i and b_i . If
at the moment Kirill is standing at position i , then he can choose any
position j such that j < i and exchange places with the person at position j .
In this case, Kirill will have to pay him a_j coins. And for each k such that
j < k < i , Kirill will have to pay b_k coins to the person at position k .
Kirill can perform this action any number of times.

Kirill is thrifty, so he wants to spend as few coins as possible, but he
doesn't want to wait too long, so Kirill believes he should be among the first
m people in line.

Help Kirill determine the minimum number of coins he will have to spend in
order to not wait too long.

Input

Each test consists of several sets of input data. The first line contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows
the description of the test case.

The first line of each test case contains two integers n and m (1 \le m \le n
\le 200\,000 ) — the number of people in the queue besides Kirill and the
maximum allowable final position of Kirill, respectively.

The second line contains n integers a_1, a_2, \dots, a_n separated by spaces
(1 \le a_i \le 10^9 ).

The third line contains n integers b_1, b_2, \dots, b_n separated by spaces (1
\le b_i \le 10^9 ).

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of coins
Kirill needs to spend.

Example

Input

    4
    
    4 2
    
    7 3 6 9
    
    4 3 8 5
    
    6 2
    
    6 9 7 1 8 3
    
    5 8 8 1 4 1
    
    7 7
    
    7 2 9 2 6 5 9
    
    9 1 10 7 1 4 9
    
    2 1
    
    2 3
    
    1 1

Output

    14
    22
    9
    3","cases = int(input())
 
for c in range(cases):
    na_frente, pos_final = map(int, input().split())
    custo_pra_trocar_a = list(map(int, input().split()))
    custo_pra_passar_b = list(map(int, input().split()))
 
    na_frente -= 1
    pos_final -= 1
 
    total = 0
    best = 10**12
    for v in range(na_frente, -1, -1):
        if(v <= pos_final):
            if(best > total + custo_pra_trocar_a[v]):
                best = total + custo_pra_trocar_a[v]
 
            if(custo_pra_trocar_a[v] < custo_pra_passar_b[v]):
                total += custo_pra_trocar_a[v]
            else:
                total += custo_pra_passar_b[v]
        else:
            if(custo_pra_trocar_a[v] < custo_pra_passar_b[v]):
                total += custo_pra_trocar_a[v]
            else:
                total += custo_pra_passar_b[v]
    
    print(best)",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1965_A,1965_A_panda.BANDANA_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob are playing a game on n piles of stones. On each player's turn,
they select a positive integer k that is at most the size of the smallest
nonempty pile and remove k stones from each nonempty pile at once. The first
player who is unable to make a move (because all piles are empty) loses.

Given that Alice goes first, who will win the game if both players play
optimally?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the number of piles in the game.

The next line of each test case contains n integers a_1, a_2, \ldots a_n (1
\le a_i \le 10^9 ), where a_i is the initial number of stones in the i -th
pile.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, print a single line with the name of the winner, assuming
both players play optimally. If Alice wins, print ""Alice"", otherwise print
""Bob"" (without quotes).

Example

Input

    7
    
    5
    
    3 3 3 3 3
    
    2
    
    1 7
    
    7
    
    1 3 9 7 4 2 100
    
    3
    
    1 2 3
    
    6
    
    2 1 3 4 2 4
    
    8
    
    5 7 2 9 6 3 3 2
    
    1
    
    1000000000

Output

    Alice
    Bob
    Alice
    Alice
    Bob
    Alice
    Alice
    
Note

In the first test case, Alice can win by choosing k=3 on her first turn, which
will empty all of the piles at once.

In the second test case, Alice must choose k=1 on her first turn since there
is a pile of size 1 , so Bob can win on the next turn by choosing k=6 .","t=int(input())
for i in range(t):
    n=int(input())
    l=map(int,input().split())
    lis=sorted(set(l))
    if (1 not in lis) or (len(lis)==1) :
        print(""Alice"")
    else:
        
        test=True
        for j in range(1,len(lis)):
            if lis[j]-lis[j-1]>1:
                if j%2==1:
                    print(""Bob"")
                else:
                    print(""Alice"")
                test=False
                break
        if test==True:
            if len(lis)%2==1:
                print(""Alice"")
            else:
                print(""Bob"")",1,True,False,False,False,False,True,True,False,False,False,False,False,False,False
1977_A,1977_A_vjudge.3_40.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The little boy Nikita was given some cubes as a present. He decided to build a
tower out of them.

Initially, the tower doesn't have any cubes. In one move, Nikita either puts
exactly 1 cube on top of the tower or removes exactly 1 cube from the top of
the tower. Is it possible that after n moves, the resulting tower has exactly
m cubes?

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 100 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains two integers n and m (1 \le n, m \le
100 ).

Output

For each test case, output ""Yes"" (without quotes) if Nikita can obtain a tower
with m cubes, and ""No"" (without quotes) otherwise.

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    3
    
    3 3
    
    2 4
    
    5 3

Output

    Yes
    No
    Yes
    
Note

In the first test case, Nikita can put 1 cube on top of the tower 3 times in a
row, so the answer is ""Yes"".

In the second test case, Nikita can only end up with either a tower with no
blocks or a tower with 2 blocks, so the answer is ""No"".","t = int(input())
for i in range(t):
    n, m = [int(i) for i in input().split()]
    if n==m:
        print('Yes')
    elif m>n:
        print('No')
    else:
        if m==n-1:
            print('Yes')
        else:
            if m%2==0 and n%2==0:
                print('Yes')
            elif m%2!=0 and n%2!=0:
                print('Yes')
            else:
                print('No')",1,False,False,False,True,False,True,False,False,True,False,False,False,True,False
1965_B,1965_B_Shivank_0912_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two integers n and k . Find a sequence a of non-negative
integers of size at most 25 such that the following conditions hold.

  * There is no subsequence of a with a sum of k . 
  * For all 1 \le v \le n where v \ne k , there is a subsequence of a with a sum of v . 

A sequence b is a subsequence of a if b can be obtained from a by the deletion
of several (possibly, zero or all) elements, without changing the order of the
remaining elements. For example, [5, 2, 3] is a subsequence of [1, 5, 7, 8, 2,
4, 3] .

It can be shown that under the given constraints, a solution always exists.

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. The description of the test cases follows.

Each test case consists of a single line containing two integers n and k (2
\le n \le 10^6 , 1 \le k \le n ) — the parameters described above.

It is guaranteed that the sum of n over all test cases does not exceed 10^7 .

Output

The first line of output for each test case should contain a single integer m
(1 \le m \le 25 ) — the size of your chosen sequence.

The second line of output for each test case should contain m integers a_i (0
\le a_i \le 10^9 ) — the elements of your chosen sequence.

If there are multiple solutions, print any.

Example

Input

    5
    
    2 2
    
    6 1
    
    8 8
    
    9 3
    
    10 7

Output

    1
    1
    5
    2 3 4 5 6
    7
    1 1 1 1 1 1 1
    4
    7 1 4 1
    4
    1 2 8 3
    
Note

In the first example, we just need a subsequence that adds up to 1 , but not
one that adds up to 2 . So the array a=[1] suffices.

In the second example, all elements are greater than k=1 , so no subsequence
adds up to 1 . Every other integer between 1 and n is present in the array, so
there is a subsequence of size 1 adding up to each of those numbers.","def solve(t, cases):
    results = []
    sequence = [2 ** i for i in range(25)]
    for n, k in cases:
        results.append((25, sequence))
    return results
 
# Read input
import sys
input = sys.stdin.read
data = input().split()
 
t = int(data[0])
cases = []
index = 1
for _ in range(t):
    n = int(data[index])
    k = int(data[index + 1])
    cases.append((n, k))
    index += 2
 
# Solve the cases
results = solve(t, cases)
 
# Print the results
for result in results:
    print(result[0])
    print(' '.join(map(str, result[1])))",1,False,False,False,,False,False,False,False,False,False,False,False,False,False
1923_A,1923_A_RGS45_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a ribbon divided into n cells, numbered from 1 to n from left to
right. Each cell either contains a chip or is free.

You can perform the following operation any number of times (possibly zero):
choose a chip and move it to the closest free cell to the left. You can choose
any chip that you want, provided that there is at least one free cell to the
left of it. When you move the chip, the cell where it was before the operation
becomes free.

Your goal is to move the chips in such a way that they form a single block,
without any free cells between them. What is the minimum number of operations
you have to perform?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of cells; 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_i \le 1 ); a_i = 0 means that the i -th cell is free; a_i = 1 means that the i -th cell contains a chip. 

Additional constraint on the input: in each test case, at least one cell
contains a chip.

Output

For each test case, print one integer — the minimum number of operations you
have to perform so that all chips form a single block without any free cells
between them.

Example

Input

    5
    
    8
    
    0 1 1 1 0 1 1 0
    
    6
    
    0 1 0 0 0 0
    
    6
    
    1 1 1 1 1 1
    
    5
    
    1 0 1 0 1
    
    9
    
    0 1 1 0 0 0 1 1 0

Output

    1
    0
    0
    2
    3
    
Note

In the first example, you can perform the operation on the chip in the 7 -th
cell. The closest free cell to the left is the 5 -th cell, so it moves there.
After that, all chips form a single block.

In the second example, all chips are already in a single block. Same for the
third example.","t=int(input(""""))
for _ in range(t):
    n=int(input(""""))
    arr="""".join(input("""").split())
    x=arr.find(""1"")
    y=(arr[::-1]).find(""1"")
    z=arr[x:n-y]
    print(z.count(""0""))",1,True,True,False,True,False,False,True,True,False,False,False,True,False,False
1978_C,1978_C_Listar_4.35%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Let's call the Manhattan value of a permutation^{\dagger} p the value of the
expression |p_1 - 1| + |p_2 - 2| + \ldots + |p_n - n| .

For example, for the permutation [1, 2, 3] , the Manhattan value is |1 - 1| +
|2 - 2| + |3 - 3| = 0 , and for the permutation [3, 1, 2] , the Manhattan
value is |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 .

You are given integers n and k . Find a permutation p of length n such that
its Manhattan value is equal to k , or determine that no such permutation
exists.

^{\dagger} A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^{4} ) — the number of test cases. The description
of the test cases follows.

The only line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^{5}, 0 \le k \le 10^{12} ) — the length of the permutation and the
required Manhattan value.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^{5} .

Output

For each test case, if there is no suitable permutation, output ""No"".
Otherwise, in the first line, output ""Yes"", and in the second line, output n
distinct integers p_1, p_2, \ldots, p_n (1 \le p_i \le n ) — a suitable
permutation.

If there are multiple solutions, output any of them.

You can output the answer in any case (for example, the strings ""yEs"", ""yes"",
""Yes"", and ""YES"" will be recognized as a positive answer).

Example

Input

    8
    
    3 4
    
    4 5
    
    7 0
    
    1 1000000000000
    
    8 14
    
    112 777
    
    5 12
    
    5 2

Output

    Yes
    3 1 2
    No
    Yes
    1 2 3 4 5 6 7
    No
    Yes
    8 2 3 4 5 6 1 7
    No
    Yes
    5 4 3 1 2
    Yes
    2 1 3 4 5
    
Note

In the first test case, the permutation [3, 1, 2] is suitable, its Manhattan
value is |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 .

In the second test case, it can be proven that there is no permutation of
length 4 with a Manhattan value of 5 .

In the third test case, the permutation [1,2,3,4,5,6,7] is suitable, its
Manhattan value is |1-1|+|2-2|+|3-3|+|4-4|+|5-5|+|6-6|+|7-7|=0 .","def list_p(n,k):
    k=k//2
    l=list(range(1,n+1))
    for i in range(n-1,-1,-1):
        if k==0:
            return l
        if 1+i>k:
            x=l[-1]
            l.pop(-1)
            l.insert(-k,x)
            return l
        k=k-i+1
        x=l[-1]
        l.pop(-1)
        l.insert(0,x)
 
def tf():
    n,k=map(int,input().split())
    if k%2:
        return 0,0
    if n%2:
        max_k=(n**2-1)//2
    else:
        max_k=(n**2)//2
    if max_k<k:
        return 0,0
    return n,k
 
def p(l):
    print('YES')
    for i in l:
        print(i,end=' ')
    print()
    return
 
def solve():
    n,k=tf()
    if n==0:
        print('NO')
        return
    l=list_p(n,k)
    # print(l)
    p(l)
    return
 
T=int(input())
for i in range(T):solve()",1,False,False,False,True,False,True,True,False,False,False,False,False,False,True
1951_B,1951_B_Hssaan_SundarSTEM_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[The HU - Shireg Shireg](https://youtu.be/SNCx4n2m5_o)

ඞ

There are n cows participating in a coding tournament. Cow i has a Cowdeforces
rating of a_i (all distinct), and is initially in position i . The tournament
consists of n-1 matches as follows:

  * The first match is between the cow in position 1 and the cow in position 2 . 
  * Subsequently, each match i is between the cow in position i+1 and the winner of match i-1 . 
  * In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match. 

You are the owner of cow k . For you, winning the tournament is not important;
rather, you want your cow to win in as many matches as possible. As an
acquaintance of the tournament organizers, you can ask them to swap the
position of your cow with another cow only once, or you can choose to do
nothing.

Find the maximum number of wins your cow can achieve.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and k (2 \le n \le
10^5, 1 \le k \le n ) — the number of cows and your cow's index.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the Cowdeforces rating of the cows. It is guaranteed that
a_i 's are pairwise different.

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, print one integer: the maximum number of wins cow k can
achieve if you choose to swap (or do nothing) optimally.

Example

Input

    3
    
    6 1
    
    12 10 14 11 8 3
    
    6 5
    
    7 2 727 10 12 13
    
    2 2
    
    1000000000 1

Output

    1
    2
    0
    
Note

In the first test case, it is optimal to do nothing. Let a' be the Cowdeforces
rating of the cows in the original order (with your cow's rating bolded), then

  * Initially, a' = [\mathbf{12}, 10, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 14 and loses. 

In total, your cow wins 1 match.

In the second test case, it is optimal to swap your cow to position 3 . Then,
let a' be the Cowdeforces rating of the cows in the order after the swap.

  * Initially, a' = [7, 2, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [\mathbf{12}, 10, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 727 and loses. 

In total, your cow wins 2 matches.","import math as m
for _ in range(int(input())):
    n,k = list(map(int,input().split()))
    s = list(map(int,input().split()))
    s[0],s[k-1] = s[k-1],s[0]
    ans = 0
    h = s[0]
    j = -1
    for i in s[1:]:
        j += 1
        if h<i:
            break
        else:
            ans += 1
    p = j+1
    s[0],s[k-1] = s[k-1],s[0]
    ans1 = 0
    # print(s)
    s[p],s[k-1] = s[k-1],s[p]
    # print(s)
    z = 0
    for i in s:
        if i==h:
            if s[0]!=h:
                ans1 += 1
            z = 1
        elif i>h:
            break
        else:
            if z==1:
                ans1 += 1
    print(max(ans,ans1))",1,True,False,False,False,False,False,True,False,False,False,False,False,False,False
1942_B,1942_B_Ahsan612_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[MOOO! - Doja Cat](https://soundcloud.com/amalaofficial/mooo)

⠀

Farmer John has a permutation p_1, p_2, \ldots, p_n , where every integer from
0 to n-1 occurs exactly once. He gives Bessie an array a of length n and
challenges her to construct p based on a .

The array a is constructed so that a_i = \texttt{MEX}(p_1, p_2, \ldots, p_i) -
p_i , where the \texttt{MEX} of an array is the minimum non-negative integer
that does not appear in that array. For example, \texttt{MEX}(1, 2, 3) = 0 and
\texttt{MEX}(3, 1, 0) = 2 .

Help Bessie construct any valid permutation p that satisfies a . The input is
given in such a way that at least one valid p exists. If there are multiple
possible p , it is enough to print one of them.

Input

The first line contains t (1 \leq t \leq 10^4 ) — the number of test cases.

The first line of each test case contains an integer n (1 \leq n \leq 2 \cdot
10^5 ) — the lengths of p and a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-n \leq a_i \leq n ) — the elements of array a .

It is guaranteed that there is at least one valid p for the given data.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output n integers on a new line, the elements of p .

If there are multiple solutions, print any of them.

Example

Input

    3
    
    5
    
    1 1 -2 1 2
    
    5
    
    1 1 1 1 1
    
    3
    
    -2 1 2

Output

    0 1 4 2 3 
    0 1 2 3 4 
    2 0 1 
    
Note

In the first case, p = [0, 1, 4, 2, 3] is one possible output.

a will then be calculated as a_1 = \texttt{MEX}(0) - 0 = 1 , a_2 =
\texttt{MEX}(0, 1) - 1 = 1 , a_3 = \texttt{MEX}(0, 1, 4) - 4 = -2 , a_4 =
\texttt{MEX}(0, 1, 4, 2) - 2 = 1 , a_5 = \texttt{MEX}(0, 1, 4, 2, 3) - 3 = 2 .

So, as required, a will be [1, 1, -2, 1, 2] .","from collections import deque
for _ in range(int(input())):
    n =int(input())
    ar = list(map(int,input().split()))
 
    res = [None] * n
    mex = n
    for i in range(len(ar)-1,-1,-1):
        res[i] = mex - ar[i]
        if mex > mex - ar[i]:
            mex = mex - ar[i]
    print("" "".join(str(x) for x in res))",1,True,False,False,False,False,False,True,True,False,False,False,False,False,False
1928_A,1928_A_danileo.lopez.v_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Bob has a rectangle of size a \times b . He tries to cut this rectangle into
two rectangles with integer sides by making a cut parallel to one of the sides
of the original rectangle. Then Bob tries to form some other rectangle from
the two resulting rectangles, and he can rotate and move these two rectangles
as he wishes.

Note that if two rectangles differ only by a 90^{\circ} rotation, they are
considered the same. For example, the rectangles 6 \times 4 and 4 \times 6 are
considered the same.

Thus, from the 2 \times 6 rectangle, another rectangle can be formed, because
it can be cut into two 2 \times 3 rectangles, and then these two rectangles
can be used to form the 4 \times 3 rectangle, which is different from the 2
\times 6 rectangle.

![](https://espresso.codeforces.com/670958570876245598e151e6877e3b0231a7c60e.png)

However, from the 2 \times 1 rectangle, another rectangle cannot be formed,
because it can only be cut into two rectangles of 1 \times 1 , and from these,
only the 1 \times 2 and 2 \times 1 rectangles can be formed, which are
considered the same.

![](https://espresso.codeforces.com/1463aaa4fa7eb1e7432c1d8b5813e7ae91147066.png)

Help Bob determine if he can obtain some other rectangle, or if he is just
wasting his time.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. This is followed
by the description of the test cases.

The single line of each test case contains two integers a and b (1 \le a, b
\le 10^9 ) — the size of Bob's rectangle.

Output

For each test case, output ""Yes"" if Bob can obtain another rectangle from the
a \times b rectangle. Otherwise, output ""No"".

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive answers.

Example

Input

    7
    
    1 1
    
    2 1
    
    2 6
    
    3 2
    
    2 2
    
    2 4
    
    6 3

Output

    No
    No
    Yes
    Yes
    Yes
    Yes
    No
    
Note

In the first test case, the 1 \times 1 rectangle cannot be cut into two
rectangles, so another rectangle cannot be obtained from it.

In the fourth test case, the 3 \times 2 rectangle can be cut into two 3 \times
1 rectangles, and from these, the 1 \times 6 rectangle can be formed.

In the fifth test case, the 2 \times 2 rectangle can be cut into two 1 \times
2 rectangles, and from these, the 1 \times 4 rectangle can be formed.","t = int(input())  # Número de casos de prueba
 
for _ in range(t):
    a, b = map(int, input().split())  # Leer las dimensiones del rectángulo
    
    # Si cualquiera de las dimensiones es par
    if a % 2 == 0 or b % 2 == 0:
        # Hacer un corte en la dimensión par
        if a % 2 == 0:  # Dividir a en dos partes si es par
            a1, a2 = a // 2, a // 2
            if a1 != b:  # Verificar que no se forme un cuadrado al dividir
                print(""Yes"")
                continue
        
        if b % 2 == 0:  # Dividir b en dos partes si es par
            b1, b2 = b // 2, b // 2
            if b1 != a:  # Verificar que no se forme un cuadrado al dividir
                print(""Yes"")
                continue
 
        # Si no se puede formar un nuevo rectángulo
        print(""No"")
    else:
        # Si ambos lados son impares, no se puede formar otro rectángulo
        print(""No"")",1,True,True,False,True,False,True,True,True,False,False,False,False,True,False
1926_D,1926_D_ayushdreams147_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.","def solve(n,a):
    res =0
    count={}
    for num in a:
        if num not in count:
            count[((1 << 31) - 1) ^ num] = count.get(((1 << 31) - 1) ^ num, 0) + 1
            res+=1
        else:
            count[num] -= 1
            if count[num] == 0:
                del count[num]
    return res
t = int(input())
for _ in range(t):
    n = int(input())
    a= list(map(int,input().split()))
    print(solve(n,a))",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1974_A,1974_A_EA10_50.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Little Rosie has a phone with a desktop (or launcher, as it is also called).
The desktop can consist of several screens. Each screen is represented as a
grid of size 5 \times 3 , i.e., five rows and three columns.

There are x applications with an icon size of 1 \times 1 cells; such an icon
occupies only one cell of the screen. There are also y applications with an
icon size of 2 \times 2 cells; such an icon occupies a square of 4 cells on
the screen. Each cell of each screen can be occupied by no more than one icon.

Rosie wants to place the application icons on the minimum number of screens.
Help her find the minimum number of screens needed.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first and only line of each test case contains two integers x and y (0
\leq x, y \leq 99 ) — the number of applications with a 1 \times 1 icon and
the number of applications with a 2 \times 2 icon, respectively.

Output

For each test case, output the minimal number of required screens on a
separate line.

Example

Input

    11
    
    1 1
    
    7 2
    
    12 4
    
    0 3
    
    1 0
    
    8 1
    
    0 0
    
    2 0
    
    15 0
    
    8 2
    
    0 9

Output

    1
    1
    2
    2
    1
    1
    0
    1
    1
    2
    5
    
Note

The solution for the first test case can look as follows:

![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)
Blue squares represent empty spaces for icons, green squares represent 1
\times 1 icons, red squares represent 2 \times 2 icons

The solution for the third test case can look as follows:

![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)","a=int(input())
for i in range(a):
    x,y=map(int,input().split())
    z=(y+1)//2
    m=15*z-y*4
    if m<a:
        z=z+(x-m+15-1)//15
    print(z)",1,False,False,False,True,False,False,True,False,False,False,False,True,False,True
1951_B,1951_B_Hssaan_SundarSTEM_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[The HU - Shireg Shireg](https://youtu.be/SNCx4n2m5_o)

ඞ

There are n cows participating in a coding tournament. Cow i has a Cowdeforces
rating of a_i (all distinct), and is initially in position i . The tournament
consists of n-1 matches as follows:

  * The first match is between the cow in position 1 and the cow in position 2 . 
  * Subsequently, each match i is between the cow in position i+1 and the winner of match i-1 . 
  * In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match. 

You are the owner of cow k . For you, winning the tournament is not important;
rather, you want your cow to win in as many matches as possible. As an
acquaintance of the tournament organizers, you can ask them to swap the
position of your cow with another cow only once, or you can choose to do
nothing.

Find the maximum number of wins your cow can achieve.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and k (2 \le n \le
10^5, 1 \le k \le n ) — the number of cows and your cow's index.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the Cowdeforces rating of the cows. It is guaranteed that
a_i 's are pairwise different.

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, print one integer: the maximum number of wins cow k can
achieve if you choose to swap (or do nothing) optimally.

Example

Input

    3
    
    6 1
    
    12 10 14 11 8 3
    
    6 5
    
    7 2 727 10 12 13
    
    2 2
    
    1000000000 1

Output

    1
    2
    0
    
Note

In the first test case, it is optimal to do nothing. Let a' be the Cowdeforces
rating of the cows in the original order (with your cow's rating bolded), then

  * Initially, a' = [\mathbf{12}, 10, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 14 and loses. 

In total, your cow wins 1 match.

In the second test case, it is optimal to swap your cow to position 3 . Then,
let a' be the Cowdeforces rating of the cows in the order after the swap.

  * Initially, a' = [7, 2, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [\mathbf{12}, 10, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 727 and loses. 

In total, your cow wins 2 matches.","import math as m
for _ in range(int(input())):
    n,k = list(map(int,input().split()))
    s = list(map(int,input().split()))
    s[0],s[k-1] = s[k-1],s[0]
    ans = 0
    h = s[0]
    j = -1
    for i in s[1:]:
        j += 1
        if h<i:
            break
        else:
            ans += 1
    p = j
    s[0],s[k-1] = s[k-1],s[0]
    ans1 = 0
    s[p],s[k-1] = s[k-1],s[p]
    z = 0
    for i in s:
        if i==h:
            if s[0]!=h:
                ans1 += 1
            z = 1
        elif i>h:
            break
        else:
            if z==1:
                ans1 += 1
    print(max(ans,ans1))",1,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1926_B,1926_B_saydigulamov_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vladislav has a binary square grid of n \times n cells. A triangle or a square
is drawn on the grid with symbols \texttt{1} . As he is too busy being cool,
he asks you to tell him which shape is drawn on the grid.

  * A triangle is a shape consisting of k (k>1 ) consecutive rows, where the i -th row has 2 \cdot i-1 consecutive characters \texttt{1} , and the central 1s are located in one column. An upside down triangle is also considered a valid triangle (but not rotated by 90 degrees).

![](https://espresso.codeforces.com/6528b67bef9e7966366c8ff95b57ba96a1f44217.png)
Two left pictures contain examples of triangles: k=4 , k=3 . The two right
pictures don't contain triangles.

  * A square is a shape consisting of k (k>1 ) consecutive rows, where the i -th row has k consecutive characters \texttt{1} , which are positioned at an equal distance from the left edge of the grid.

![](https://espresso.codeforces.com/4b06bb9ff8f408edc96077ace0d5e299065a3c50.png)
Examples of two squares: k=2 , k=4 .

For the given grid, determine the type of shape that is drawn on it.

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The first line of each test case contains a single integer n (2 \leq n \leq 10
) — the size of the grid.

The next n lines each contain n characters \texttt{0} or \texttt{1} .

The grid contains exactly one triangle or exactly one square that contains all
the \texttt{1} s in the grid. It is guaranteed that the size of the triangle
or square is greater than 1 (i.e., the shape cannot consist of exactly one 1).

Output

For each test case, output ""SQUARE"" if all the \texttt{1} s in the grid form a
square, and ""TRIANGLE"" otherwise (without quotes).

Example

Input

    6
    
    3
    
    000
    
    011
    
    011
    
    4
    
    0000
    
    0000
    
    0100
    
    1110
    
    2
    
    11
    
    11
    
    5
    
    00111
    
    00010
    
    00000
    
    00000
    
    00000
    
    10
    
    0000000000
    
    0000000000
    
    0000000000
    
    0000000000
    
    0000000000
    
    1111111110
    
    0111111100
    
    0011111000
    
    0001110000
    
    0000100000
    
    3
    
    111
    
    111
    
    111

Output

    SQUARE
    TRIANGLE
    SQUARE
    TRIANGLE
    TRIANGLE
    SQUARE","a=int(input())
for i in range(a):
    k=[]
    for _ in range(int(input())):
        b=input()
        if '1' in b:
            k.append(b.count('1'))
    if k[0]==k[1]:
        print(""SQUARE"")
    else:
        print('TRIANGLE')",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1929_B,1929_B_avaniagr_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a
drawing and attract her attention.

As a drawing, he decided to draw a square grid of size n \times n , in which
some cells are colored. But coloring the cells is difficult, so he wants to
color as few cells as possible. But at the same time, he wants at least k
diagonals to have at least one colored cell. Note that the square grid of size
n \times n has a total of 4n - 2 diagonals.

Help little Sasha to make the girl fall in love with him and tell him the
minimum number of cells he needs to color.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 1000 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (2 \leq n \leq
10^8 , 1 \leq k \leq 4n - 2 ) — the size of the square grid and the minimum
number of diagonals in which there should be at least one colored cell.

Output

For each test case, output a single integer — the minimum number of cells that
need to be colored.

Example

Input

    7
    
    3 4
    
    3 3
    
    3 10
    
    3 9
    
    4 7
    
    7 11
    
    2 3

Output

    2
    2
    6
    5
    4
    6
    2
    
Note

In the pictures below, the colored cells are marked in black, and all
diagonals are marked in purple.

In the first test case, you can color 2 cells so that 4 diagonals contain at
least one colored cell:

![](https://espresso.codeforces.com/c88e80de5be4f91764dbe5bdc534c50fec115db3.png)

In the third test case, you can color 6 cells so that all 10 diagonals contain
at least one colored cell:

![](https://espresso.codeforces.com/624a36083689f6fb20bf243e5d1707fdcd71ef60.png)","import math
for s in [*open(0)][1:]:
    n,k=map(int,s.split())
    if k<=(4*n-4):
        print(math.ceil(k/2))
    elif k==(4*n-3):
        print(2*n-1)
    elif k==(4*n-2):
        print(2*n)",1,True,False,False,False,False,True,True,False,False,False,False,False,False,False
1924_A,1924_A_dhruvdd8888_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two integers n and k along with a string s .

Your task is to check whether all possible strings of length n that can be
formed using the first k lowercase English alphabets occur as a subsequence of
s . If the answer is NO, you also need to print a string of length n that can
be formed using the first k lowercase English alphabets which does not occur
as a subsequence of s .

If there are multiple answers, you may print any of them.

Note: A string a is called a subsequence of another string b if a can be
obtained by deleting some (possibly zero) characters from b without changing
the order of the remaining characters.

Input

The first line of input contains a single integer t \, (1 \le t \le 10^5) ,
the number of test cases.

The first line of each test case contains 3 integers n \, (1 \le n \le 26), \:
k \, (1 \le k \le 26), \: m \, (1 \le m \le 1000) , where n and k are the same
as described in the input and m is the length of the string s .

The second line of each test case contains a single string s of length m ,
comprising only of the first k lowercase English alphabets.

It is guaranteed that the sum of m and the sum of n over all test cases does
not exceed 10^6 .

Output

For each test case, print YES if all possible strings of length n that can be
formed using the first k lowercase English alphabets occur as a subsequence of
s , else print NO.

If your answer is NO, print a string of length n that can be formed using the
first k lowercase English alphabets which does not occur as a subsequence of s
in the next line.

You may print each letter of YES or NO in any case (for example, YES, yES, YeS
will all be recognized as a positive answer).

Example

Input

    3
    
    2 2 4
    
    abba
    
    2 2 3
    
    abb
    
    3 3 10
    
    aabbccabab

Output

    YES
    NO
    aa
    NO
    ccc
    
Note

For the first test case, all possible strings (aa, ab, ba, bb) of length 2
that can be formed using the first 2 English alphabets occur as a subsequence
of abba.

For the second test case, the string aa is not a subsequence of abb.","from collections import *
from math import *
from heapq import *
import sys
from bisect import *
from random import randint
rrr = randint(8888,88888)
 
 
def sol():
    n,k,m = tuple(map(int,input().split()))
 
    s = input()
    us = set(chr(i+97) for i  in range(k))
    win = set()
    ans = []
    ps = 0
    for i in s:
        if i in us:
            win.add(i)
            if len(win) == k:
                ans.append(i)
                ps += 1
                win.clear()
    
    # print(ps)
    if ps >= n:return print(""YES"")
 
    print(""NO"")
 
    for i in us:
        if i not in win:
            return print("""".join(ans)+i + (""a"" * (n - len(ans) - 1)))
 
 
 
for _ in range(int(input())):
    sol()",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1925_B,1925_B_WarsNitin_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Jay managed to create a problem of difficulty x and decided to make it the
second problem for Codeforces Round #921.

But Yash fears that this problem will make the contest highly unbalanced, and
the coordinator will reject it. So, he decided to break it up into a
problemset of n sub-problems such that the difficulties of all the sub-
problems are a positive integer and their sum is equal to x .

The coordinator, Aleksey, defines the balance of a problemset as the
[GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the
difficulties of all sub-problems in the problemset.

Find the maximum balance that Yash can achieve if he chooses the difficulties
of the sub-problems optimally.

Input

The first line of input contains a single integer t (1\leq t\leq 10^3 )
denoting the number of test cases.

Each test case contains a single line of input containing two integers x
(1\leq x\leq 10^8 ) and n (1\leq n\leq x ).

Output

For each test case, print a single line containing a single integer denoting
the maximum balance of the problemset Yash can achieve.

Example

Input

    3
    
    10 3
    
    5 5
    
    420 69

Output

    2
    1
    6
    
Note

For the first test case, one possible way is to break up the problem of
difficulty 10 into a problemset having three problems of difficulties 4 , 2
and 4 respectively, giving a balance equal to 2 .

For the second test case, there is only one way to break up the problem of
difficulty 5 into a problemset of 5 problems with each problem having a
difficulty 1 giving a balance equal to 1 .","from math import sqrt
for q in range(int(input())):
    x,n=list(map(int,input().split(' ')))
    ans=1
    for i in range(1,int(sqrt(x))+1):
        if(x%i==0):
            if((x-n*i)>=0 and (x-n*i)%i==0):
                ans=max(ans,i)
            if((x-n*((x//i))>=0 and x//i>0 and ((x-n*((x//i)))%((x//i))==0))):
                ans=max(ans,(x//i))
    print(ans)",1,True,True,True,True,"Let's analyze the given problem and the provided program step by step to determine its correctness.

### Problem Analysis

The problem requires finding the maximum balance (GCD) of a set of `n` sub-problems such that the sum of their difficulties equals `x`. The balance is defined as the GCD of all sub-problem difficulties.

### Correct Approach

To maximize the balance, we need to find the largest integer `d` such that:
1. `d` divides `x` (i.e., `x % d == 0`).
2. We can form `n` sub-problems, each with a difficulty of at least `d`, and the sum of these difficulties equals `x`.

The key insight is that if `d` divides `x`, then `x = k * d` for some integer `k`. To form `n` sub-problems, we need to check if we can distribute the total difficulty `x` into `n` parts, each of which is a multiple of `d`.

### Program Analysis

The provided program iterates over all possible divisors of `x` up to the square root of `x`. For each divisor `i`:
1. It checks if `x - n * i >= 0` and `(x - n * i) % i == 0`. This condition ensures that if we create `n` sub-problems each with difficulty `i`, the remaining difficulty can also be divided into multiples of `i`.
2. It also checks the same conditions for the corresponding quotient `x // i`.

If both conditions are satisfied, it updates the maximum balance `ans` with the current divisor `i` or `x // i`.

### Verification

Let's verify the program with the provided examples:

1. **First Test Case (x = 10, n = 3):**
   - Divisors of 10: 1, 2, 5, 10
   - Checking `i = 1`: `10 - 3 * 1 = 7` (not divisible by 1, but we can form 3 sub-problems with difficulty 1 and one with difficulty 7, but this does not maximize the GCD)
   - Checking `i = 2`: `10 - 3 * 2 = 4` (divisible by 2, so we can form 3 sub-problems with difficulty 2 and one with difficulty 4, but this does not satisfy the sum condition directly)
   - Checking `i = 5`: `10 - 3 * 5 = -5` (not valid)
   - Checking `i = 10`: `10 - 3 * 10 = -20` (not valid)
   - Checking `x // i = 10`: `10 - 3 * 1 = 7` (not divisible by 10)
   - Checking `x // i = 5`: `10 - 3 * 2 = 4` (divisible by 2, but not by 5)
   - Checking `x // i = 2`: `10 - 3 * 5 = -5` (not valid)
   - Checking `x // i = 1`: `10 - 3 * 10 = -20` (not valid)
   - The maximum valid `i` is 2, which can be verified by forming sub-problems with difficulties 4, 2, and 4.

2. **Second Test Case (x = 5, n = 5):**
   - Divisors of 5: 1, 5
   - Checking `i = 1`: `5 - 5 * 1 = 0` (valid, so we can form 5 sub-problems with difficulty 1)
   - Checking `i = 5`: `5 - 5 * 1 = 0` (valid, but we cannot form 5 sub-problems with difficulty 5)
   - The maximum valid `i` is 1, which can be verified by forming sub-problems with difficulties 1, 1, 1, 1, and 1.

3. **Third Test Case (x = 420, n = 69):**
   - Divisors of 420: 1, 2, 3, 4, 5, 6, 7, 10, 12, 14, 15, 20, 21, 28, 30, 35, 42, 60, 70, 84, 105, 140, 210, 420
   - Checking `i = 6`: `420 - 69 * 6 = 6` (divisible by 6, so we can form 69 sub-problems with difficulty 6 and one with difficulty 6)
   - Checking `i = 7`: `420 - 69 * 7 = -27` (not valid)
   - Checking `i = 10`: `420 - 69 * 10 = -470` (not valid)
   - Checking `i = 12`: `420 - 69 * 12 = -708` (not valid)
   - Checking `i = 14`: `420 - 69 * 14 = -826` (not valid)
   - Checking `i = 15`: `420 - 69 * 15 = -885` (not valid)
   - Checking `i = 20`: `420 - 69 * 20 = -1260` (not valid)
   - Checking `i = 21`: `420 - 69 * 21 = -1349` (not valid)
   - Checking `i = 28`: `420 - 69 * 28 = -1692` (not valid)
   - Checking `i = 30`: `420 - 69 * 30 = -1950` (not valid)
   - Checking `i = 35`: `420 - 69 * 35 = -2295` (not valid)
   - Checking `i = 42`: `420 - 69 * 42 = -2688` (not valid)
   - Checking `i = 60`: `420 - 69 * 60 = -3780` (not valid)
   - Checking `i = 70`: `420 - 69 * 70 = -4410` (not valid)
   - Checking `i = 84`: `420 - 69 * 84 = -5244` (not valid)
   - Checking `i = 105`: `420 - 69 * 105 = -6315` (not valid)
   - Checking `i = 140`: `420 - 69 * 140 = -8580` (not valid)
   - Checking `i = 210`: `420 - 69 * 210 = -13080` (not valid)
   - Checking `i = 420`: `420 - 69 * 420 = -27060` (not valid)
   - Checking `x // i = 420`: `420 - 69 * 1 = 351` (not divisible by 420)
   - Checking `x // i = 210`: `420 - 69 * 2 = 282` (not divisible by 210)
   - Checking `x // i = 140`: `420 - 69 * 3 = 213` (not divisible by 140)
   - Checking `x // i = 105`: `420 - 69 * 4 = 144` (not divisible by 105)
   - Checking `x // i = 84`: `420 - 69 * 5 = 75` (not divisible by 84)
   - Checking `x // i = 70`: `420 - 69 * 6 = 6` (divisible by 70, but not by 6)
   - Checking `x // i = 60`: `420 - 69 * 7 = -33` (not valid)
   - Checking `x // i = 42`: `420 - 69 * 10 = -470` (not valid)
   - Checking `x // i = 35`: `420 - 69 * 12 = -708` (not valid)
   - Checking `x // i = 30`: `420 - 69 * 14 = -826` (not valid)
   - Checking `x // i = 28`: `420 - 69 * 15 =",True,True,True,True,True,True,True,True,True
1937_D,1937_D_Dipta_bar_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a one-dimensional grid of length n . The i -th cell of the grid
contains a character s_i , which is either '<' or '>'.

When a pinball is placed on one of the cells, it moves according to the
following rules:

  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. 
  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). 
  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. 

You need to answer n independent queries. In the i -th query, a pinball will
be placed on the i -th cell. Note that we always place a pinball on the
initial grid.

For each query, calculate how many seconds it takes the pinball to leave the
grid. It can be shown that the pinball will always leave the grid within a
finite number of steps.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^5 ). The description of the test cases follows.

The first line of each test case contains an integer n (1 \le n \le 5 \cdot
10^5 ).

The second line of each test case contains a string s_1s_2 \ldots s_{n} of
length n consisting of characters '<' and '>'.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, for each i (1 \le i \le n ) output the answer if a pinball
is initially placed on the i -th cell.

Example

Input

    3
    
    3
    
    ><<
    
    4
    
    <<<<
    
    6
    
    <><<<>

Output

    3 6 5 
    1 2 3 4 
    1 4 7 10 8 1 
    
Note

In the first test case, the movement of the pinball for i=1 is shown in the
following pictures. It takes the pinball 3 seconds to leave the grid.

![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)

The movement of the pinball for i=2 is shown in the following pictures. It
takes the pinball 6 seconds to leave the grid.

![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)","t = int(input())
 
 
 
def solve(s):
    n = len(s)
    A = [] 
    idx_A = []
    for i in range(0, n):
        if s[i] == '>':
            if (len(idx_A) == 0):
                A.append(0)
            else:
                x = A[len(A) - 1] + (i - idx_A[len(idx_A) - 1]) * len(idx_A)
                A.append(x)
            idx_A.append(i)
    B = []
    idx_B = []
    for j in range(0, n):
        i = n - 1 - j
        if s[i] == '<':
            if (len(idx_B) == 0):
                B.append(0)
            else:
                x = B[len(B) - 1] + (idx_B[len(B) - 1] - i) * len(idx_B)
                B.append(x)
            idx_B.append(i)
    l = 0
    r = len(B)
 
 
    for i in range(0, n):
        if (s[i] == '>'):
            if l < r:
                a = A[l]
                x = r - (l + 2)
                b = B[r - 1]
                if x >= 0:
                    b = b - B[x]
                    b = b - (idx_B[x] - idx_B[r - 1]) * (x + 1)
                b = b + (idx_B[r - 1] - i) * (l + 1)
                print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print(n - i, end = "" "")
                else:
                    a = B[r - 1] + (idx_B[r - 1] - i) * r
                    b = A[l - 1]
                    if l - r > 0:
                        b = b - A[l - r - 1]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 1]) * (l - r)
                    b = b + (i - idx_A[l - 1]) * r
                    print(a * 2 + b * 2 + (n - i), end = "" "")
            l += 1
        else:
            r -= 1
            if (l <= r):
                if (l == 0):
                    print(i + 1, end = "" "")
                else:
                    a = A[l - 1]
                    a = a + (i - idx_A[l - 1]) * l
                    b = B[r]
                    if r - l >= 0:
                        b = b - B[r - l]
                        b = b - (idx_B[r - l] - i) * (r - l)
                    b = b + (idx_B[r] - i) * l
                    print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print((n - i) + (i - idx_A[l - 1]) * 2, end = "" "")
                else:
                    a = B[r]
                    b = A[l - 1]
                    if l - r - 1 > 0:
                        b = b - A[l - r - 2]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 2]) * (l - r - 1)
                    b = b + (i - idx_A[l - 1]) * (r + 1)
                    print(a * 2 + b * 2 + (n - i), end = "" "")
 
 
for i in range(0, t):
    n = int(input())
    s = input()
    solve(s)
    print()",1,True,False,False,True,False,True,True,True,False,True,True,True,True,True
1978_C,1978_C_Listar_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Let's call the Manhattan value of a permutation^{\dagger} p the value of the
expression |p_1 - 1| + |p_2 - 2| + \ldots + |p_n - n| .

For example, for the permutation [1, 2, 3] , the Manhattan value is |1 - 1| +
|2 - 2| + |3 - 3| = 0 , and for the permutation [3, 1, 2] , the Manhattan
value is |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 .

You are given integers n and k . Find a permutation p of length n such that
its Manhattan value is equal to k , or determine that no such permutation
exists.

^{\dagger} A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^{4} ) — the number of test cases. The description
of the test cases follows.

The only line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^{5}, 0 \le k \le 10^{12} ) — the length of the permutation and the
required Manhattan value.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^{5} .

Output

For each test case, if there is no suitable permutation, output ""No"".
Otherwise, in the first line, output ""Yes"", and in the second line, output n
distinct integers p_1, p_2, \ldots, p_n (1 \le p_i \le n ) — a suitable
permutation.

If there are multiple solutions, output any of them.

You can output the answer in any case (for example, the strings ""yEs"", ""yes"",
""Yes"", and ""YES"" will be recognized as a positive answer).

Example

Input

    8
    
    3 4
    
    4 5
    
    7 0
    
    1 1000000000000
    
    8 14
    
    112 777
    
    5 12
    
    5 2

Output

    Yes
    3 1 2
    No
    Yes
    1 2 3 4 5 6 7
    No
    Yes
    8 2 3 4 5 6 1 7
    No
    Yes
    5 4 3 1 2
    Yes
    2 1 3 4 5
    
Note

In the first test case, the permutation [3, 1, 2] is suitable, its Manhattan
value is |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 .

In the second test case, it can be proven that there is no permutation of
length 4 with a Manhattan value of 5 .

In the third test case, the permutation [1,2,3,4,5,6,7] is suitable, its
Manhattan value is |1-1|+|2-2|+|3-3|+|4-4|+|5-5|+|6-6|+|7-7|=0 .","def list_p(n,k):
    k=k//2
    l=list(range(1,n+1))
    c=0
    for i in range(n,-1,-2):
        c+=1
        if k==0:
            return l
        if k<i-1:
            return r_ret(c,k,l)
        k=k-i+1
        l=ret(c,l)
 
def r_ret(c,k,l):
    x,y=l[-c],l[-c-k]
    l[-c],l[-c - k]=y,x
    return l
 
def ret(c,l):
    x,y=l[-c],l[c-1]
    l[c-1],l[-c]=x,y
    return l
 
 
def tf():
    n,k=map(int,input().split())
    if k%2:
        return 0,0
    if n%2:
        max_k=(n**2-1)//2
    else:
        max_k=(n**2)//2
    if max_k<k:
        return 0,0
    return n,k
 
def p(l):
    print('YES')
    for i in l:
        print(i,end=' ')
    print()
    return
 
def solve():
    n,k=tf()
    if n==0:
        print('NO')
        return
    l=list_p(n,k)
    p(l)
    return
 
T=int(input())
for i in range(T):solve()",1,True,True,False,False,True,True,False,True,False,False,False,False,True,False
1922_C,1922_C_EmperorDogeAV_32.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n cities located on the number line, the i -th city is in the point
a_i . The coordinates of the cities are given in ascending order, so a_1 < a_2
< \dots < a_n .

The distance between two cities x and y is equal to |a_x - a_y| .

For each city i , let's define the closest city j as the city such that the
distance between i and j is not greater than the distance between i and each
other city k . For example, if the cities are located in points [0, 8, 12, 15,
20] , then:

  * the closest city to the city 1 is the city 2 ; 
  * the closest city to the city 2 is the city 3 ; 
  * the closest city to the city 3 is the city 4 ; 
  * the closest city to the city 4 is the city 3 ; 
  * the closest city to the city 5 is the city 4 . 

The cities are located in such a way that for every city, the closest city is
unique. For example, it is impossible for the cities to be situated in points
[1, 2, 3] , since this would mean that the city 2 has two closest cities (1
and 3 , both having distance 1 ).

You can travel between cities. Suppose you are currently in the city x . Then
you can perform one of the following actions:

  * travel to any other city y , paying |a_x - a_y| coins; 
  * travel to the city which is the closest to x , paying 1 coin. 

You are given m queries. In each query, you will be given two cities, and you
have to calculate the minimum number of coins you have to spend to travel from
one city to the other city.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

Each test case is given in the following format:

  * the first line contains one integer n (2 \le n \le 10^5 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_1 < a_2 < \dots < a_n \le 10^9 ); 
  * the third line contains one integer m (1 \le m \le 10^5 ); 
  * then m lines follow; the i -th of them contains two integers x_i and y_i (1 \le x_i, y_i \le n ; x_i \ne y_i ), denoting that in the i -th query, you have to calculate the minimum number of coins you have to spend to travel from the city x_i to the city y_i . 

Additional constraints on the input:

  * in every test case, for each city, the closest city is determined uniquely; 
  * the sum of n over all test cases does not exceed 10^5 ; 
  * the sum of m over all test cases does not exceed 10^5 . 

Output

For each query, print one integer — the minimum number of coins you have to
spend.

Example

Input

    1
    
    5
    
    0 8 12 15 20
    
    5
    
    1 4
    
    1 5
    
    3 4
    
    3 2
    
    5 1

Output

    3
    8
    1
    4
    14
    
Note

Let's consider the first two queries in the example from the statement:

  * in the first query, you are initially in the city 1 . You can travel to the closest city (which is the city 2 ), paying 1 coin. Then you travel to the closest city (which is the city 3 ) again, paying 1 coin. Then you travel to the closest city (which is the city 4 ) again, paying 1 coin. In total, you spend 3 coins to get from the city 1 to the city 4 ; 
  * in the second query, you can use the same way to get from the city 1 to the city 4 , and then spend 5 coins to travel from the city 4 to the city 5 .","t = int(input())
def go_through(cities, n):
	prog_cities = [0] * (n-1)
	for i in range(n-1):
		back = -99999999
		forward = 99999999
		if i > 0:
			back = cities[i-1]
		if i < n-1:
			forward = cities[i+1]
		
		if abs(forward - cities[i]) < abs(cities[i] - back):
			prog_cities[i] = 1
		else:
			prog_cities[i] = abs(forward - cities[i])
	return prog_cities
 
for _ in range(t):
	n = int(input())
	cities = input().split()
	for i in range(n):
		cities[i] = int(cities[i])
	
	forward_cities = go_through(cities, n)
	cities.reverse()
	backward_cities = go_through(cities, n)
 
	pref_sum_f = [0]
	pref_sum_b = [0]
 
	for i in range(n-1):
		pref_sum_f.append(pref_sum_f[i]+forward_cities[i])
		pref_sum_b.append(pref_sum_b[i]+backward_cities[i])
 
 
	pref_sum_b.reverse()
 
	m = int(input())
 
	for i in range(m):
		a, b = input().split()
		a, b = int(a), int(b)
 
		if a < b:
			print(pref_sum_f[b-1] - pref_sum_f[a-1])
		
		else:
			print(pref_sum_b[b-1] - pref_sum_b[a-1])",1,False,False,False,False,False,False,False,True,True,False,False,False,False,False
1973_A,1973_A_CpError123_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .","def resoudre_padel_pour_trois(t, cas_de_test):
    resultats = []
    for p1, p2, p3 in cas_de_test:
        total_points = p1 + p2 + p3
        if total_points % 2 != 0:
            resultats.append(-1)
            continue
        
        total_matchs = total_points // 2
        if total_matchs > 3 or p3 > total_matchs:
            resultats.append(-1)
            continue
        
        egalites = total_points - (2 * (p3 - p2)) - (2 * (p3 - p1))
        if egalites < 0:
            resultats.append(-1)
        else:
            resultats.append(egalites // 2)
    return resultats
 
# Entrées
t = 7
cas_de_test = [
    (0, 0, 0),
    (0, 1, 1),
    (0, 2, 3),
    (3, 3, 3),
    (3, 4, 5),
    (1, 1, 10),
    (0, 0, 6)
]
 
# Résolution et affichage des résultats
resultats = resoudre_padel_pour_trois(t, cas_de_test)
print(""\n"".join(map(str, resultats)))",1,False,False,False,True,False,True,True,True,False,False,False,True,True,True
1942_C2,1942_C2_asiftreadingonthinice_6.67%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)","tt=int(input())
for ii in range(tt):
    n,x,y=map(int,input().split())
    a=list(map(int,input().split()))
    a.sort()
    ans=x+y-2
    tmp=[]
    for i in range(1,len(a)):
        if a[i]-a[i-1]==2:
            ans+=1
        elif (a[i]-a[i-1])%2==0 and y>(a[i]-a[i-1])//2-1:
            tmp.append((a[i]-a[i-1])//2)
            ans+=(a[i]-a[i-1])//2
            y-=((a[i]-a[i-1])//2-1)
    if a[0]+n-a[len(a)-1]==2:
        ans+=1
    elif (a[0]+n-a[len(a)-1])%2==0 and y>(a[i]-a[i-1])//2-1:
        tmp.append((a[0]+n-a[len(a)-1])//2)
        ans+=(a[i]-a[i-1])//2
        y-=((a[i]-a[i-1])//2-1)
    ans+=y
    print(min(ans,n-2))",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1974_B,1974_B_vher1311._100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Polycarp has a string s , which consists of lowercase Latin letters. He
encodes this string using the following algorithm:

  * first, he constructs a new auxiliary string r , which consists of all distinct letters of the string s , written in alphabetical order; 
  * then the encoding happens as follows: each character in the string s is replaced by its symmetric character from the string r (the first character of the string r will be replaced by the last, the second by the second from the end, and so on). 

For example, encoding the string s =""codeforces"" happens as follows:

  * the string r is obtained as ""cdefors""; 
  * the first character s_1 ='c' is replaced by 's'; 
  * the second character s_2 ='o' is replaced by 'e'; 
  * the third character s_3 ='d' is replaced by 'r'; 
  * ... 
  * the last character s_{10} ='s' is replaced by 'c'. 

![](https://espresso.codeforces.com/b6f889887677396af4d296900b8ca492324e83ef.png)
The string r and replacements for s =""codeforces"".

Thus, the result of encoding the string s =""codeforces"" is the string
""serofedsoc"".

Write a program that performs decoding — that is, restores the original string
s from the encoding result.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the length of the string b .

The second line of each test case contains a string b of length n , consisting
of lowercase Latin letters — the result of encoding the original string s .

It is guaranteed that the sum of the values of n over all test cases in the
test does not exceed 2 \cdot 10^5 .

Output

For each test case, output the string s from which the encoding result b was
obtained.

Example

Input

    5
    
    10
    
    serofedsoc
    
    3
    
    ttf
    
    9
    
    tlrhgmaoi
    
    1
    
    w
    
    15
    
    hnndledmnhlttin

Output

    codeforces
    fft
    algorithm
    w
    meetinthemiddle","def decode_string(encoded):
    # Get unique characters and sort them to form 'r'
    r = ''.join(sorted(set(encoded)))
    # Create the mapping dictionary
    mapping = {r[i]: r[-(i+1)] for i in range(len(r))}
    # Decode the string using the mapping
    return ''.join(mapping[char] for char in encoded)
 
# Reading input
import sys
input = sys.stdin.read
data = input().split()
 
index = 0
t = int(data[index])
index += 1
results = []
 
for _ in range(t):
    n = int(data[index])
    index += 1
    b = data[index]
    index += 1
    results.append(decode_string(b))
 
# Output the results
print('\n'.join(results))",1,True,True,False,True,False,True,True,True,True,True,True,True,True,True
1967_B1,1967_B1_pulidindim_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.","t=int(input())
for i in range(t):
    n,m=map(int,input().split())
    count=2
    ans=n
    while count<=m:
        countmins=int(count -1)
        g=int(n/count)
        if g<countmins: break
        g-=countmins
        ans+=(int(g/count)+1)
        count+=1
    print(int(ans))",1,True,False,False,False,False,False,True,False,False,False,False,False,False,False
1928_A,1928_A_43395_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Bob has a rectangle of size a \times b . He tries to cut this rectangle into
two rectangles with integer sides by making a cut parallel to one of the sides
of the original rectangle. Then Bob tries to form some other rectangle from
the two resulting rectangles, and he can rotate and move these two rectangles
as he wishes.

Note that if two rectangles differ only by a 90^{\circ} rotation, they are
considered the same. For example, the rectangles 6 \times 4 and 4 \times 6 are
considered the same.

Thus, from the 2 \times 6 rectangle, another rectangle can be formed, because
it can be cut into two 2 \times 3 rectangles, and then these two rectangles
can be used to form the 4 \times 3 rectangle, which is different from the 2
\times 6 rectangle.

![](https://espresso.codeforces.com/670958570876245598e151e6877e3b0231a7c60e.png)

However, from the 2 \times 1 rectangle, another rectangle cannot be formed,
because it can only be cut into two rectangles of 1 \times 1 , and from these,
only the 1 \times 2 and 2 \times 1 rectangles can be formed, which are
considered the same.

![](https://espresso.codeforces.com/1463aaa4fa7eb1e7432c1d8b5813e7ae91147066.png)

Help Bob determine if he can obtain some other rectangle, or if he is just
wasting his time.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. This is followed
by the description of the test cases.

The single line of each test case contains two integers a and b (1 \le a, b
\le 10^9 ) — the size of Bob's rectangle.

Output

For each test case, output ""Yes"" if Bob can obtain another rectangle from the
a \times b rectangle. Otherwise, output ""No"".

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive answers.

Example

Input

    7
    
    1 1
    
    2 1
    
    2 6
    
    3 2
    
    2 2
    
    2 4
    
    6 3

Output

    No
    No
    Yes
    Yes
    Yes
    Yes
    No
    
Note

In the first test case, the 1 \times 1 rectangle cannot be cut into two
rectangles, so another rectangle cannot be obtained from it.

In the fourth test case, the 3 \times 2 rectangle can be cut into two 3 \times
1 rectangles, and from these, the 1 \times 6 rectangle can be formed.

In the fifth test case, the 2 \times 2 rectangle can be cut into two 1 \times
2 rectangles, and from these, the 1 \times 4 rectangle can be formed.","for i in range(int(input())):
    a, b, = [int(i) for i in input().split()]
    if(a%2==0 and b%2==0):
      print('yes')
    elif(a-b==-a,a) or (b-a==-b,b):
      print('no') 
    elif((a-b)%2>0 or (a-b)%2<0):
      print('yes')
    else:
      print('no')",1,False,False,False,Correctness:,False,True,False,False,False,False,False,False,False,False
1937_C,1937_C_moonsong98_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * ""? a b c d"" 

After that, you receive:

  * ""<"" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * ""="" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * "">"" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * ""! i j"" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query ""? 0 2 3 1"", the jury return ""<"" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query ""? 1 1 2 3"", the jury return ""="" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query ""? 1 2 0 3"", the jury return "">"" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.","import sys
 
input = sys.stdin.readline
sys.setrecursionlimit(int(1e9))
 
 
def check(a, b, c, d):
    print(f""? {a} {b} {c} {d}"")
    sys.stdout.flush()
    return input().strip()
 
 
def answer(a, b):
    print(f""! {a} {b}"")
    sys.stdout.flush()
 
 
def solve():
    n = int(input())
 
    if n == 2:
        answer(0, 1)
        return
 
    # debug
 
    max_index = 0
 
    for i in range(0, n):
        res = check(0, max_index, 0, i)
        if res == ""<"":
            max_index = i
 
    min_indices = [max_index]
    for i in range(0, n):
        res = check(max_index, min_indices[0], max_index, i)
        if res == ""<"":
            min_indices = [i]
        elif res == ""="":
            min_indices.append(i)
 
    min_index = min_indices[0]
    for i in min_indices:
        if i == max_index:
            continue
        res = check(min_index, min_index, min_index, i)
        if res == ""="":
            min_index = i
 
    answer(max_index, min_index)
 
 
T = int(input())
 
for _ in range(T):
    solve()",1,True,True,False,False,False,False,False,False,False,False,False,False,False,False
1957_C,1957_C_Phyber_Optik_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","import sys
 
sys.setrecursionlimit(400000)
 
dp = [-1 for _ in range(300007)]
 
def go(n):
    # if n <= 1:
    #     return 1
 
    # if dp[n] != -1:
    #     return dp[n]
 
    # dp[n] = (go(n - 1) + 2 * (n - 1) * go(n - 2)) % 1000000007
 
    # return dp[n]
    dp[1] = 1
    dp[2] = 3
    for i in range(3, n + 1):
        dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % 1000000007
 
go(300000)
t = int(input())
 
for _ in range(t):
    n, k = map(int, input().split())
    invalid = set([])
 
    for _ in range(k):
        r, c = map(int, input().split())
        invalid.add(r)
        invalid.add(c)
 
 
    print(max(1, dp[n - len(invalid)]))",1,True,False,False,False,False,True,True,False,False,False,False,False,False,False
1971_D,1971_D_M2024_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a binary string^{\dagger} . Please find the minimum number of
pieces you need to cut it into, so that the resulting pieces can be rearranged
into a sorted binary string.

![](https://espresso.codeforces.com/76039f9769ba94c1817dbbc5e1fb1b5e4f60950f.png)

Note that:

  * each character must lie in exactly one of the pieces; 
  * the pieces must be contiguous substrings of the original string; 
  * you must use all the pieces in the rearrangement. 

^{\dagger} A binary string is a string consisting of characters \texttt{0} and
\texttt{1} . A sorted binary string is a binary string such that all
characters \texttt{0} come before all characters \texttt{1} .

Input

The first line contains a single integer t (1 \leq t \leq 500 ) — the number
of test cases.

The only line of each test case contains a single string s (1 \leq |s| \leq
500 ) consisting of characters \texttt{0} and \texttt{1} , where |s| denotes
the length of the string s .

Output

For each test case, output a single integer — the minimum number of pieces
needed to be able to rearrange the string into a sorted binary string.

Example

Input

    6
    
    11010
    
    00000000
    
    1
    
    10
    
    0001111
    
    0110

Output

    3
    1
    1
    2
    1
    2
    
Note

The first test case is pictured in the statement. It can be proven that you
can't use fewer than 3 pieces.

In the second and third test cases, the binary string is already sorted, so
only 1 piece is needed.

In the fourth test case, you need to make a single cut between the two
characters and rearrange them to make the string \texttt{01} .","t = int(input())
 
for _ in range(t):
    a = input()
    cut0 = 0
    cut1 = 0
    for i in range(len(a)-1):
        if a[i] == '1' and a[i+1] == '0':
            cut1 += 1
        if a[i] == '0' and a[i+1] == '1':
            cut0 += 1
    if cut0 == 0:
        print(cut1+1)
    else:
        print(cut0+cut1)
 
# 011 0 111 0 11
# 1 011",1,True,True,False,True,True,True,True,True,False,False,True,True,True,True
1931_A,1931_A_Outlastqr_20.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Nikita had a word consisting of exactly 3 lowercase Latin letters. The letters
in the Latin alphabet are numbered from 1 to 26 , where the letter ""a"" has the
index 1 , and the letter ""z"" has the index 26 .

He encoded this word as the sum of the positions of all the characters in the
alphabet. For example, the word ""cat"" he would encode as the integer 3 + 1 +
20 = 24 , because the letter ""c"" has the index 3 in the alphabet, the letter
""a"" has the index 1 , and the letter ""t"" has the index 20 .

However, this encoding turned out to be ambiguous! For example, when encoding
the word ""ava"", the integer 1 + 22 + 1 = 24 is also obtained.

Determine the lexicographically smallest word of 3 letters that could have
been encoded.

A string a is lexicographically smaller than a string b if and only if one of
the following holds:

  * a is a prefix of b , but a \ne b ;
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .

Input

The first line of the input contains a single integer t (1 \le t \le 100 ) —
the number of test cases in the test.

This is followed by the descriptions of the test cases.

The first and only line of each test case contains an integer n (3 \le n \le
78 ) — the encoded word.

Output

For each test case, output the lexicographically smallest three-letter word
that could have been encoded on a separate line.

Example

Input

    5
    
    24
    
    70
    
    3
    
    55
    
    48

Output

    aav
    rzz
    aaa
    czz
    auz","import string
 
alphabet = string.ascii_lowercase
 
for i in range(int(input())):
    n = int(input())
    word = """"
    if n > 52:
        word += alphabet[n - 53] + ""zz""
    elif n > 26:
        word += ""a"" + alphabet[n - 28] + ""z""
    else:
        word += ""aa"" + alphabet[n - 3]
    print(word)",1,False,True,False,False,False,False,True,False,False,False,False,False,False,False
1941_C,1941_C_HELLOProgrammer112_6.25%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Rudolf has a string s of length n . Rudolf considers the string s to be ugly
if it contains the substring^\dagger ""pie"" or the substring ""map"", otherwise
the string s will be considered beautiful.

For example, ""ppiee"", ""mmap"", ""dfpiefghmap"" are ugly strings, while ""mathp"",
""ppiiee"" are beautiful strings.

Rudolf wants to shorten the string s by removing some characters to make it
beautiful.

The main character doesn't like to strain, so he asks you to make the string
beautiful by removing the minimum number of characters. He can remove
characters from any positions in the string (not just from the beginning or
end of the string).

^\dagger String a is a substring of b if there exists a consecutive segment of
characters in string b equal to a .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 10^6
) — the length of the string s .

The next line of each test case contains the string s of length n . The string
s consists of lowercase Latin letters.

The sum of n over all test cases does not exceed 10^6 .

Output

For each test case, output a single integer — the minimum number of characters
that need to be deleted to make the string s beautiful. If the string is
initially beautiful, then output 0 .

Example

Input

    6
    
    9
    
    mmapnapie
    
    9
    
    azabazapi
    
    8
    
    mappppie
    
    18
    
    mapmapmapmapmapmap
    
    1
    
    p
    
    11
    
    pppiepieeee

Output

    2
    0
    2
    6
    0
    2
    
Note

In the first test case, for example, you can delete the 4 th and 9 th
characters to make the string beautiful.

In the second test case, the string is already beautiful.","for _ in range(int(input())):
    a=int(input())   
    s=input()         
    x=s.count(""map"")   
    y=s.count(""pie"")  
    print(x+y)",1,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1937_C,1937_C_FransValli_5.88%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * ""? a b c d"" 

After that, you receive:

  * ""<"" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * ""="" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * "">"" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * ""! i j"" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query ""? 0 2 3 1"", the jury return ""<"" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query ""? 1 1 2 3"", the jury return ""="" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query ""? 1 2 0 3"", the jury return "">"" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.","for _ in range(int(input())):
    n = int(input())
 
    #Find first item
    k = 1
    for i in range(2, n):
        print('?', 0, k, 0, i, flush=True)
        res = input()
        if res == '<':
            k = i
 
    #Find second item    
    best = 0
    for i in range(1, n):
        print('?', k, best, k, i, flush=True)
        res = input()
        if res == '<':
            best = i
 
    print('!', k, best, flush = True)",1,False,False,False,False,False,True,False,True,False,False,False,True,False,False
1955_F,1955_F_Baby_Bird_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob gathered in the evening to play an exciting game on a sequence
of n integers, each integer of the sequence doesn't exceed 4 . The rules of
the game are too complex to describe, so let's just describe the winning
condition — Alice wins if the [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
all the numbers in the sequence is non-zero; otherwise, Bob wins.

The guys invited Eve to act as a judge. Initially, Alice and Bob play with n
numbers. After one game, Eve removes one of the numbers from the sequence,
then Alice and Bob play with n-1 numbers. Eve removes one number again, after
which Alice and Bob play with n - 2 numbers. This continues until the sequence
of numbers is empty.

Eve seems to think that in such a game, Alice almost always wins, so she wants
Bob to win as many times as possible. Determine the maximum number of times
Bob can win against Alice if Eve removes the numbers optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first and only line of each test case contains four integers p_i (0 \le
p_i \le 200 ) — the number of ones, twos, threes, and fours in the sequence at
the beginning of the game.

Output

For each test case, print the maximum number of times Bob will win in a
separate line, if Eve removes the numbers optimally.

Example

Input

    5
    
    1 1 1 0
    
    1 0 1 2
    
    2 2 2 0
    
    3 3 2 0
    
    0 9 9 9

Output

    1
    1
    3
    3
    12
    
Note

In the first example, Bob wins when Eve has not removed any numbers yet.

In the second example, Bob wins if Eve removes one one and one three.","for _ in range(int(input())):
    p = list(map(lambda x: int(x) - int(x) % 2, input().split()))
    print((sum(list(map(lambda x: x % 2 > 0, p[:3]))) == 3) + sum(p) // 2)",1,False,False,False,False,False,False,False,True,False,False,False,False,False,False
1954_C,1954_C_Ahsan612_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two integers x and y of the same length, consisting of digits
from 1 to 9 .

You can perform the following operation any number of times (possibly zero):
swap the i -th digit in x and the i -th digit in y .

For example, if x=73 and y=31 , you can swap the 2 -nd digits and get x=71 and
y=33 .

Your task is to maximize the product of x and y using the aforementioned
operation any number of times. If there are multiple answers, print any of
them.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

The first line of each test case contains a single integer x (1 \le x <
10^{100} ).

The second line of each test case contains a single integer y (1 \le y <
10^{100} ).

Additional constraint on input: the integers x and y consist only of digits
from 1 to 9 .

Output

For each test case, print two lines — the first line should contain the number
x after performing the operations; similarly, the second line should contain
the number y after performing the operations. If there are multiple answers,
print any of them.

Example

Input

    3
    
    73
    
    31
    
    2
    
    5
    
    3516
    
    3982

Output

    71
    33
    5
    2
    3912
    3586","for _ in range(int(input())):
    a = list(map(int,list(input())))
    b = list(map(int,list(input())))
    new = [None]*len(a)
    new2 = [None]*len(a)
    i = 0
    while i<len(a) and a[i] == b[i]:
        new[i] = max(a[i],b[i])
        new2[i] = min(a[i],b[i])
        i += 1
    if i!=len(a):
        new[i] = max(a[i],b[i])
        new2[i] = min(a[i],b[i])
        i += 1
        while i<len(a):
            new[i] = min(a[i],b[i])
            new2[i] = max(a[i],b[i])
            i+=1
    print("""".join(str(x) for x in new))
    print("""".join(str(x) for x in new2))",1,True,True,False,True,False,True,True,True,False,False,False,True,True,True
1945_C,1945_C_undercovers23_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"In the village of Letovo, there are n houses. The villagers decided to build a
big road that will divide the village into left and right sides. Each resident
wants to live on either the right or the left side of the street, which is
described as a sequence a_1, a_2, \dots, a_n , where a_j = 0 if the resident
of the j -th house wants to live on the left side of the street; otherwise,
a_j = 1 .

The road will pass between two houses. The houses to the left of it will be
declared the left-side, and the houses to the right will be declared the
right-side. More formally, let the road pass between houses i and i+1 . Then
the houses at positions between 1 and i will be on the left side of the
street, and at positions between i+1 and n will be on the right side. The road
also may pass before the first and after the last house; in this case, the
entire village is declared to be either the right or left side, respectively.

To make the design fair, it was decided to lay the road so that at least half
of the residents on each side of the village are satisfied with the choice.
That is, among x residents on one side, at least \lceil\frac{x}{2}\rceil
should want to live on that side, where \lceil x \rceil denotes rounding up a
real number x .

![](https://espresso.codeforces.com/75baa17903d65a630fb0d3334683e857d5fdc345.png)
To the left of the road, there will be i houses, among the corresponding a_j
there must be at least \lceil\frac{i}{2}\rceil zeros. To the right of the
road, there will be n-i houses, among the corresponding a_j there must be at
least \lceil\frac{n-i}{2}\rceil ones.

Determine after which house i the road should be laid in order to satisfy the
described condition and be as close to the middle of the village as possible.
Formally, among all suitable positions i , minimize \left|\frac{n}{2} -
i\right| .

If there are multiple suitable positions i with the minimum \left|\frac{n}{2}
- i\right| , output the smaller one.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 2\cdot 10^4 ). The description of the test cases
follows.

The first line of each test case contains a single integer n (3 \le n \le
3\cdot 10^5 ). The next line of each test case contains a string a of length n
, consisting only of 0 and 1 .

It is guaranteed that the sum of n over all test cases does not exceed 3\cdot
10^5 .

Output

For each test case, output a single number i — the position of the house after
which the road should be laid (if it should be laid before the first house,
output 0 ). We can show that the answer always exists.

Example

Input

    7
    
    3
    
    101
    
    6
    
    010111
    
    6
    
    011001
    
    3
    
    000
    
    3
    
    110
    
    3
    
    001
    
    4
    
    1100

Output

    2
    3
    2
    3
    0
    1
    0
    
Note

Let's consider the first example of input data.

If we lay the road after the first house, there will be one house a_1 = 1 on
the left side of the street, the resident of which would like to live on the
right side of the street. Then 0 out of 1 residents on the even side will be
satisfied with the choice, which means that the road cannot be laid after
house 1 .

If we lay the road after the second house, 1 out of 2 residents on the left
side (with preferences a_1 = 1 , a_2 = 0 ) and 1 out of 1 resident on the
right side (with preference a_3 = 1 ) will be satisfied with the choice. More
than half of the residents on each side are satisfied with the choice, which
means that the road can be laid after house 2 . We can show that this is the
optimal answer.","t=int(input())
for _ in range(t):
    n=int(input())
    s=input()
    
    if n%2==0:
        pk=n/2
    else:
        pk=(n/2) 
    
    sl=list(s)
    o=sl.count(""1"")
    z=sl.count(""0"")
    
    zero,one=0,0
    lst=[]
    mini=pow(10,8)
    for i in range(n-1):
        if s[i]==""0"":
            zero+=1
        else:
            one+=1
        
        zero_perc=(zero*100)//(i+1)
        one_perc=((o-one)*100)//(n-i-1)
        #print(zero_perc,one_perc,""hulu"",i)
        if zero_perc>=50 and one_perc>=50:
            lst.append(i+1)
        #print(lst)
 
    #print(mini,""le"")
    #print(lst)
    #print(pk)
    for ele in lst:
        mini=min(mini,abs(pk-ele))
    final=[]
    #print(mini,""88"")
    for elem in lst:
        if abs(pk-elem)==mini:
            final.append(elem)
    
    final.sort()
    if len(final)==0:
        c1=(o*100)//n
        if c1>=50:
            final.append(0)
        else:
            final.append(n)
        
    print(final[0])",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1965_B,1965_B_NS3081992_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two integers n and k . Find a sequence a of non-negative
integers of size at most 25 such that the following conditions hold.

  * There is no subsequence of a with a sum of k . 
  * For all 1 \le v \le n where v \ne k , there is a subsequence of a with a sum of v . 

A sequence b is a subsequence of a if b can be obtained from a by the deletion
of several (possibly, zero or all) elements, without changing the order of the
remaining elements. For example, [5, 2, 3] is a subsequence of [1, 5, 7, 8, 2,
4, 3] .

It can be shown that under the given constraints, a solution always exists.

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. The description of the test cases follows.

Each test case consists of a single line containing two integers n and k (2
\le n \le 10^6 , 1 \le k \le n ) — the parameters described above.

It is guaranteed that the sum of n over all test cases does not exceed 10^7 .

Output

The first line of output for each test case should contain a single integer m
(1 \le m \le 25 ) — the size of your chosen sequence.

The second line of output for each test case should contain m integers a_i (0
\le a_i \le 10^9 ) — the elements of your chosen sequence.

If there are multiple solutions, print any.

Example

Input

    5
    
    2 2
    
    6 1
    
    8 8
    
    9 3
    
    10 7

Output

    1
    1
    5
    2 3 4 5 6
    7
    1 1 1 1 1 1 1
    4
    7 1 4 1
    4
    1 2 8 3
    
Note

In the first example, we just need a subsequence that adds up to 1 , but not
one that adds up to 2 . So the array a=[1] suffices.

In the second example, all elements are greater than k=1 , so no subsequence
adds up to 1 . Every other integer between 1 and n is present in the array, so
there is a subsequence of size 1 adding up to each of those numbers.","# import random
# import itertools
# from sys import stdin, stdout
# import operator
# import collections
import bisect
import collections
import heapq
import math
import sys
from sys import maxsize
# from decimal import Decimal
 
#sys.setrecursionlimit(10**6)
 
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()
 
 
# mod = 998244353
# fval = [1]
# for i in range(1,1002):
#     x = (fval[-1]*i)%mod
#     fval.append(x)
# #
# ifac = [1]*(1002)
# ifac[1001] = pow(fval[1001], -1, mod)
# for i in range(1001-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%mod
# print(fval)
# print(ifac)
# _________________ For taking Input from the Text Files __________________
# import os.path
#
# if (os.path.exists('input.txt')):
#     sys.stdin = open(""input.txt"", ""r"")
#     sys.stdout = open(""output.txt"", ""w"")
#     sys.stderr = open(""error.txt"", ""w"")
 
def drank(d, processing, da, rank):
    tmp = 10 ** 9
    if len(d[da]) == 1:
        return 1
    for di in d[da]:
        if processing[di - 1] == 0:
            processing[di - 1] = 1
            tmp = min(tmp, drank(d, processing, di, rank))
            processing[di - 1] = 0
    rank[da - 1] = tmp + 1
    return tmp + 1
 
# def primeFactors(n, d):
#     if (n % 2 == 0):
#         d[2] = 0
#     while n % 2 == 0:
#         d[2] += 1
#         n = n // 2
#     for i in range(3, int(math.sqrt(n)) + 1, 2):
#         if (n % i == 0):
#             d[i] = 0
#         while n % i == 0:
#             d[i] += 1
#             n = n // i
#     if n > 2:
#         d[n] = 1
# def powerofadivisor(n,div):
#     x = 0
#     while n%div == 0:
#         n//=div
#         x+=1
#     return x
 
#import heapq as hq
#import math
 
def gcd(a,b):
    if b==0:
        x = 1
        y = 0
        return x, y, a
    x, y, g = gcd(b, a%b)
    return y, x- (a//b)*y, g
 
# mod = 998244353
#
# is_prime = [True]*(10**7+5)
# primes = []
# def primeseive(n):
#     is_prime[0] = is_prime[1] = False
#     for i in range(4,n+1,2): is_prime[i] = False
#     i = 3
#     while i*i<=n:
#         if is_prime[i] == True:
#             for j in range(i*i,n+1,i):
#                 is_prime[j] = False
#         i+=2
    # for i in range(n):
    #     if is_prime[i]: primes.append(i)
import heapq
 
def solve():
    n, k = li()
    b = bin(n)[2:]
    l = len(b)
    if k == 1:
        if n == 2: return ""1\n2""
        ans = [2, 3]
        for i in range(2,l):
            ans.append(2**i)
    else:
        bk = bin(k)[2:]
        ans = []
        lk = len(bk)
        for i in range(lk-1):
            ans.append(2**i)
        ans.append(k-1-sum(ans))
        ans.append(k+1)
        ans.append(2*k+1)
        for i in range(lk, l):
            ans.append(2**i)
    return str(len(ans))+""\n""+' '.join(map(str, ans))
 
 
 
 
def main():
    # primeseive(10**7+2)
    # print(is_prime)
    for _ in range(ii()):
        sys.stdout.write(str(solve()) + ""\n"")
        #solve()
        # si()
        #print(""? {} {}"".format(low, mid), flush=True)
        # print(solve(), flush=True)
    # print(solve())
 
    #     z += str(ans) + '\n'
    # print(len(ans), ' '.join(map(str, ans)), sep='\n')
    # stdout.write(z)
 
 
# for interactive problems
# print(""? {} {}"".format(l,m), flush=True)
# or print this after each print statement
# sys.stdout.flush()
 
 
if __name__ == ""__main__"":
    main()",1,True,True,False,True,True,True,True,True,False,False,False,True,True,True
1968_C,1968_C_Sinerat_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;","for _ in range(int(input())):
    n = int(input())
    x = list(map(int, input().split()))
    a = [0]*n
    a[0] = 1000
    for i in range(1, n):
        a[i] = a[i-1] + x[i-1]
    print(*a)",1,True,True,False,True,False,False,False,False,False,True,False,True,True,True
1974_B,1974_B_vher1311._0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Polycarp has a string s , which consists of lowercase Latin letters. He
encodes this string using the following algorithm:

  * first, he constructs a new auxiliary string r , which consists of all distinct letters of the string s , written in alphabetical order; 
  * then the encoding happens as follows: each character in the string s is replaced by its symmetric character from the string r (the first character of the string r will be replaced by the last, the second by the second from the end, and so on). 

For example, encoding the string s =""codeforces"" happens as follows:

  * the string r is obtained as ""cdefors""; 
  * the first character s_1 ='c' is replaced by 's'; 
  * the second character s_2 ='o' is replaced by 'e'; 
  * the third character s_3 ='d' is replaced by 'r'; 
  * ... 
  * the last character s_{10} ='s' is replaced by 'c'. 

![](https://espresso.codeforces.com/b6f889887677396af4d296900b8ca492324e83ef.png)
The string r and replacements for s =""codeforces"".

Thus, the result of encoding the string s =""codeforces"" is the string
""serofedsoc"".

Write a program that performs decoding — that is, restores the original string
s from the encoding result.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the length of the string b .

The second line of each test case contains a string b of length n , consisting
of lowercase Latin letters — the result of encoding the original string s .

It is guaranteed that the sum of the values of n over all test cases in the
test does not exceed 2 \cdot 10^5 .

Output

For each test case, output the string s from which the encoding result b was
obtained.

Example

Input

    5
    
    10
    
    serofedsoc
    
    3
    
    ttf
    
    9
    
    tlrhgmaoi
    
    1
    
    w
    
    15
    
    hnndledmnhlttin

Output

    codeforces
    fft
    algorithm
    w
    meetinthemiddle","def symmetric_encode(s):
    # Create a list of unique characters from the input string
    unique_chars = sorted(list({char for char in s}))
    
    i, j = 0, len(unique_chars) - 1
    
    # Encode the input string
    for char in s:
        if char in unique_chars:
            # Replace the current character with its symmetric counterpart
            s = s.replace(char, unique_chars[j])
            j -= 1
        else:
            # Add the new character to the unique_chars list
            unique_chars.insert(i, char)
            
            # Update i and j
            i += 1
            j += 1
    
    return ''.join(unique_chars)
 
# Main function
if __name__ == ""__main__"":
    t = int(input())
    
    for _ in range(t):
        n = int(input())
        b = input()
        
        # Get the encoded string
        encoded_str = symmetric_encode(b)
        
        # Print the encoded string
        print(encoded_str)",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1956_D,1956_D_waijayale_2.38%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Nene gave you an array of integers a_1, a_2, \ldots, a_n of length n .

You can perform the following operation no more than 5\cdot 10^5 times
(possibly zero):

  * Choose two integers l and r such that 1 \le l \le r \le n , compute x as \operatorname{MEX}(\\{a_l, a_{l+1}, \ldots, a_r\\}) , and simultaneously set a_l:=x, a_{l+1}:=x, \ldots, a_r:=x . 

Here, \operatorname{MEX} of a set of integers \\{c_1, c_2, \ldots, c_k\\} is
defined as the smallest non-negative integer m which does not occur in the set
c .

Your goal is to maximize the sum of the elements of the array a . Find the
maximum sum and construct a sequence of operations that achieves this sum.
Note that you don't need to minimize the number of operations in this
sequence, you only should use no more than 5\cdot 10^5 operations in your
solution.

Input

The first line contains an integer n (1 \le n \le 18 ) — the length of the
array a .

The second line contains n integers a_1,a_2,\ldots,a_n (0\leq a_i \leq 10^7 )
— the array a .

Output

In the first line, output two integers s and m (0\le m\le 5\cdot 10^5 ) — the
maximum sum of elements of the array a and the number of operations in your
solution.

In the i -th of the following m lines, output two integers l and r (1 \le l
\le r \le n ), representing the parameters of the i -th operation.

It can be shown that the maximum sum of elements of the array a can always be
obtained in no more than 5 \cdot 10^5 operations.

Examples

Input

    2
    
    0 1

Output

    4 1
    1 2
    
Input

    3
    
    1 3 9

Output

    13 0
    
Input

    4
    
    1 100 2 1

Output

    105 2
    3 3
    3 4
    
Input

    1
    
    0

Output

    1 1
    1 1
    
Note

In the first example, after the operation with l=1 and r=2 the array a becomes
equal to [2,2] . It can be shown that it is impossible to achieve a larger sum
of the elements of a , so the answer is 4 .

In the second example, the initial sum of elements is 13 which can be shown to
be the largest.

In the third example, the array a changes as follows:

  * after the first operation (l=3 , r=3 ), the array a becomes equal to [1,100,0,1] ; 
  * after the second operation (l=3 , r=4 ), the array a becomes equal to [1,100,2,2] . 

It can be shown that it is impossible to achieve a larger sum of the elements
of a , so the answer is 105 .","def apply_operations(a, l, r, ops):
    if l == r:
        if a[l] != 0:
            ops.append((l, l))
            a[l] = 0
        return
 
    apply_operations(a, l + 1, r, ops)
    if a[l] != r - l + 1:
        ops.append((l, r))
        for i in range(l, r + 1):
            a[i] = r - l + 1
 
        apply_operations(a, l + 1, r, ops)
 
def maximize_sum(a):
    n = len(a)
    ops = []
 
    def recursive_maximize_sum(l, r):
        s = sum(a[l:r+1])
        if s <= (r - l + 1) * (r - l + 1):
            apply_operations(a, l, r, ops)
            ops.append((l, r))
            for i in range(l, r + 1):
                a[i] = r - l + 1
        else:
            mx = max(a[l:r+1])
            pos = a[l:r+1].index(mx) + l
            if pos != l:
                recursive_maximize_sum(l, pos - 1)
            if pos != r:
                recursive_maximize_sum(pos + 1, r)
 
    recursive_maximize_sum(0, n - 1)
    return sum(a), len(ops), ops
 
def main():
    n = int(input())
    a = list(map(int, input().split()))
    s, m, ops = maximize_sum(a)
    print(s, m)
    for l, r in ops:
        print(l + 1, r + 1)
 
if __name__ == ""__main__"":
    main()",1,False,False,False,False,False,True,False,False,False,False,False,False,False,False
1932_B,1932_B_permaximum_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).","t = int(input())
 
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    year = 0
    for ai in a:
        year += (year % ai) or ai
    print(year)",1,False,True,False,True,True,True,True,True,False,False,False,True,False,True
1950_C,1950_C_imaginary_faye_50.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Given the time in 24-hour format, output the equivalent time in 12-hour
format.

  * [24-hour format](https://en.wikipedia.org/wiki/24-hour_clock#Description) divides the day into 24 hours from 00 to 23 , each of which has 60 minutes from 00 to 59 . 
  * [12-hour format](https://en.wikipedia.org/wiki/12-hour_clock#Description) divides the day into two halves: the first half is \mathrm{AM} , and the second half is \mathrm{PM} . In each half, the hours are numbered in the order 12, 01, 02, 03, \dots, 11 . Each hour has 60 minutes numbered from 00 to 59 . 

Input

The first line contains a single integer t (1 \leq t \leq 1440 ) — the number
of test cases.

The only line of each test case contains a string s of length 5 with format
hh:mm representing a valid time in the 24-hour format. hh represents the hour
from 00 to 23 , and mm represents the minute from 00 to 59 .

The input will always be a valid time in 24-hour format.

Output

For each test case, output two strings separated by a space (""hh:mm AM"" or
""hh:mm PM""), which are the 12-hour equivalent to the time provided in the test
case (without quotes).

You should output the time exactly as indicated; in particular, you should not
remove leading zeroes.

Example

Input

    11
    
    09:41
    
    18:06
    
    12:14
    
    00:59
    
    00:00
    
    14:34
    
    01:01
    
    19:07
    
    11:59
    
    12:00
    
    21:37

Output

    09:41 AM
    06:06 PM
    12:14 PM
    12:59 AM
    12:00 AM
    02:34 PM
    01:01 AM
    07:07 PM
    11:59 AM
    12:00 PM
    09:37 PM","def gb114():
    for t in range(int(input())):
        s = input()
        h = s[:2]
        if h == '00':
            print('12', end='')
        elif int(h) <= 12:
            print(h, end='')
        else:
            print('0{}'.format(int(h) - 12), end='')
        print(s[2:], ['AM', 'PM'][int(h) >= 12])
gb114()",1,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1937_D,1937_D_Dipta_bar_5.26%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a one-dimensional grid of length n . The i -th cell of the grid
contains a character s_i , which is either '<' or '>'.

When a pinball is placed on one of the cells, it moves according to the
following rules:

  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. 
  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). 
  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. 

You need to answer n independent queries. In the i -th query, a pinball will
be placed on the i -th cell. Note that we always place a pinball on the
initial grid.

For each query, calculate how many seconds it takes the pinball to leave the
grid. It can be shown that the pinball will always leave the grid within a
finite number of steps.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^5 ). The description of the test cases follows.

The first line of each test case contains an integer n (1 \le n \le 5 \cdot
10^5 ).

The second line of each test case contains a string s_1s_2 \ldots s_{n} of
length n consisting of characters '<' and '>'.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, for each i (1 \le i \le n ) output the answer if a pinball
is initially placed on the i -th cell.

Example

Input

    3
    
    3
    
    ><<
    
    4
    
    <<<<
    
    6
    
    <><<<>

Output

    3 6 5 
    1 2 3 4 
    1 4 7 10 8 1 
    
Note

In the first test case, the movement of the pinball for i=1 is shown in the
following pictures. It takes the pinball 3 seconds to leave the grid.

![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)

The movement of the pinball for i=2 is shown in the following pictures. It
takes the pinball 6 seconds to leave the grid.

![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)","t = int(input())
 
 
 
def solve(s):
    n = len(s)
    A = [] 
    idx_A = []
    for i in range(0, n):
        if s[i] == '>':
            if (len(idx_A) == 0):
                A.append(0)
            else:
                x = A[len(A) - 1] + (i - idx_A[len(idx_A) - 1]) * len(idx_A)
                A.append(x)
            idx_A.append(i)
    B = []
    idx_B = []
    for j in range(0, n):
        i = n - 1 - j
        if s[i] == '<':
            if (len(idx_B) == 0):
                B.append(0)
            else:
                x = B[len(B) - 1] + (idx_B[len(B) - 1] - i) * len(idx_B)
                B.append(x)
            idx_B.append(i)
    l = 0
    r = len(B)
 
    for i in range(0, n):
        if (s[i] == '>'):
            if l < r:
                a = A[l]
                x = r - (l + 2)
                b = B[r - 1]
                if x >= 0:
                    b = b - B[x]
                    b = b - (idx_B[x] - idx_B[r - 1]) * (x + 1)
                b = (idx_B[r - 1] - i) * (l + 1)
                print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print(n - i, end = "" "")
                else:
                    a = B[r - 1] + (idx_B[r - 1] - i) * r
                    b = A[l - 1]
                    if l - r > 0:
                        b = b - A[l - r - 1]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 1]) * (l - r)
                    b = b + (i - idx_A[l - 1]) * r
                    print(a * 2 + b * 2 + (n - i), end = "" "")
            l += 1
        else:
            r -= 1
            if (l <= r):
                if (l == 0):
                    print(i + 1, end = "" "")
                else:
                    a = A[l - 1]
                    a = a + (i - idx_A[l - 1]) * l
                    b = B[r]
                    if r - l >= 0:
                        b = b - B[r - l]
                        b = b - (idx_B[r - l] - i) * (r - l)
                    b = b + (idx_B[r] - i) * l
                    print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print((n - i) + (i - idx_A[l - 1]) * 2, end = "" "")
                else:
                    a = B[r]
                    b = A[l - 1]
                    if l - r - 1 > 0:
                        b = b - A[l - r - 2]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 2]) * (l - r - 1)
                    b = b + (i - idx_A[l - 1]) * (r + 1)
                    print(a * 2 + b * 2 + (n - i), end = "" "")
 
 
for i in range(0, t):
    n = int(input())
    s = input()
    solve(s)
    print()",1,False,False,False,False,False,True,False,False,False,False,False,False,False,False
1951_B,1951_B_meet732_7.69%,codeforces2024,human,qwen2p5-coder-32b-instruct,"[The HU - Shireg Shireg](https://youtu.be/SNCx4n2m5_o)

ඞ

There are n cows participating in a coding tournament. Cow i has a Cowdeforces
rating of a_i (all distinct), and is initially in position i . The tournament
consists of n-1 matches as follows:

  * The first match is between the cow in position 1 and the cow in position 2 . 
  * Subsequently, each match i is between the cow in position i+1 and the winner of match i-1 . 
  * In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match. 

You are the owner of cow k . For you, winning the tournament is not important;
rather, you want your cow to win in as many matches as possible. As an
acquaintance of the tournament organizers, you can ask them to swap the
position of your cow with another cow only once, or you can choose to do
nothing.

Find the maximum number of wins your cow can achieve.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and k (2 \le n \le
10^5, 1 \le k \le n ) — the number of cows and your cow's index.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the Cowdeforces rating of the cows. It is guaranteed that
a_i 's are pairwise different.

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, print one integer: the maximum number of wins cow k can
achieve if you choose to swap (or do nothing) optimally.

Example

Input

    3
    
    6 1
    
    12 10 14 11 8 3
    
    6 5
    
    7 2 727 10 12 13
    
    2 2
    
    1000000000 1

Output

    1
    2
    0
    
Note

In the first test case, it is optimal to do nothing. Let a' be the Cowdeforces
rating of the cows in the original order (with your cow's rating bolded), then

  * Initially, a' = [\mathbf{12}, 10, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 14 and loses. 

In total, your cow wins 1 match.

In the second test case, it is optimal to swap your cow to position 3 . Then,
let a' be the Cowdeforces rating of the cows in the order after the swap.

  * Initially, a' = [7, 2, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [\mathbf{12}, 10, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 727 and loses. 

In total, your cow wins 2 matches.","def mwins(a):
    x=a[k]
 
    ind=[]
    c=0
    for i in range(n):
        if a[i]>x:
            ind.append(i)
            c+=1
        if c==2:break
    if k==14:print(ind)
    if ind==[]:return n-1
    if len(ind)==1:
        if ind[0]==0:
            return k-1
        if ind[0]>k:return ind[0]-1
        return max(k-ind[0],ind[0]-1)
    if ind[0]==0: return min(ind[1]-1,k-1)
    if k>ind[1]: return max(ind[0]-1,ind[1]-ind[0])
    return max(ind[0]-1,k-ind[0])
    
 
 
 
for _ in range(int(input())):
    n,k=list(map(int,input().split()))
    l=list(map(int,input().split()))
    k-=1
    print(mwins(l))",1,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1966_B,1966_B_bestestgrammar_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is an n \times m grid of white and black squares. In one operation, you
can select any two squares of the same color, and color all squares in the
subrectangle between them that color.

Formally, if you select positions (x_1, y_1) and (x_2, y_2) , both of which
are currently the same color c , set the color of all (x, y) where \min(x_1,
x_2) \le x \le \max(x_1, x_2) and \min(y_1, y_2) \le y \le \max(y_1, y_2) to c
.

This diagram shows a sequence of two possible operations on a grid:

![](https://espresso.codeforces.com/efe0d6bfa2062b4821f73fb07120103af504fb62.png)

Is it possible for all squares in the grid to be the same color, after
performing any number of operations (possibly zero)?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n and m (1 \le n, m \le
500 ) — the number of rows and columns in the grid, respectively.

Each of the next n lines contains m characters 'W' and 'B' — the initial
colors of the squares of the grid.

It is guaranteed that the sum of n\cdot m over all test cases does not exceed
3\cdot 10^5 .

Output

For each test case, print ""YES"" if it is possible to make all squares in the
grid the same color, and ""NO"" otherwise.

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive
responses.

Example

Input

    8
    
    2 1
    
    W
    
    B
    
    6 6
    
    WWWWBW
    
    WBWWWW
    
    BBBWWW
    
    BWWWBB
    
    WWBWBB
    
    BBBWBW
    
    1 1
    
    W
    
    2 2
    
    BB
    
    BB
    
    3 4
    
    BWBW
    
    WBWB
    
    BWBW
    
    4 2
    
    BB
    
    BB
    
    WW
    
    WW
    
    4 4
    
    WWBW
    
    BBWB
    
    WWBB
    
    BBBB
    
    1 5
    
    WBBWB

Output

    NO
    YES
    YES
    YES
    YES
    NO
    YES
    NO
    
Note

In the first example, it is impossible to ever change the color of any square
with an operation, so we output NO.

The second example is the case pictured above. As shown in that diagram, it is
possible for all squares to be white after two operations, so we output YES.

In the third and fourth examples, all squares are already the same color, so
we output YES.

In the fifth example we can do everything in two operations. First, select
positions (2, 1) and (1, 4) and color all squares with 1 \le x \le 2 and 1 \le
y \le 4 to white. Then, select positions (2, 1) and (3, 4) and color all
squares with 2 \le x \le 3 and 1 \le y \le 4 to white. After these two
operations all squares are white.","t = int(input())
 
for tc in range(t):
    n, m = map(int, input().split())
    gr = []
 
    for i in range(n):
        gr.append(input())
 
    ans = ""YES""
 
    if gr[0][0] != gr[n - 1][m - 1]:
 
        impossible = True
        for j in range(m - 1):
            if gr[0][j] != gr[0][j + 1] or gr[n - 1][j] != gr[n - 1][j + 1]:
                impossible = False
 
        if impossible:
            ans = ""NO""
 
        impossible = True
        for i in range(n - 1):
            if gr[i][0] != gr[i + 1][0] or gr[i][m - 1] != gr[i + 1][m - 1]:
                impossible = False
 
        if impossible:
            ans = ""NO""
 
    print(ans)",1,True,False,False,True,False,False,False,False,True,False,False,False,False,False
1970_F1,1970_F1_osvarp_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This afternoon, you decided to enjoy the first days of Spring by taking a walk
outside. As you come near the Quidditch field, you hear screams. Once again,
there is a conflict about the score: the two teams are convinced that they won
the game! To prevent this problem from happening one more time, you decide to
get involved in the refereeing of the matches.

Now, you will stay in the stadium to watch the game and count the score. At
the end of the game, you will decide the winner.

Today, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw
(B) team. Each team is composed of P players (1 \leq P \leq 10 ).

The field is a rectangle of N lines and M columns (3 \leq N, M \leq 99 , N and
M are odd). All the positions are integers, and several entities are allowed
to be at the same position in the field. At the beginning of the game, the
field contains goals for the two teams (each team can own between one and five
goals), the players, and exactly one Quaffle. Other types of balls will be
available in the harder versions of the problem.

A game is composed of T steps (0 \leq T \leq 10000 ). At each step, one entity
on the field (a player or a ball) performs one action. All entities can move.
A player can also catch a ball or throw the Quaffle that it is carrying. To
catch a ball, a player must be located on the same cell as it. The Quaffle
does not perform any action while it is being carried; it only follows the
movements of the player. If a player carrying the Quaffle decides to throw it,
the Quaffle is simply put at the current position of the player.

To win a point, a player must leave the Quaffle at a goal of the other team.
When it does, the team of the player wins one point, and the Quaffle instantly
moves to the middle of the field (the cell at the (M+1)/2 -th column of the
(N+1)/2 -th line of the field, starting from 1). There is no goal in the
middle of the field. If a player puts the ball in its own goal, the other team
wins the point.

Input

On the first line, the integers N and M .

The description of the field follows: N lines of M pairs of characters
separated by spaces. Each pair of characters represents a position on the
field. It can be either:

  * .. to represent an empty cell 
  * R0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid. 
  * RG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG). 
  * .Q to represent the Quaffle, which is the ball that the players use to score goals. 

The next line contains T , the number of steps that compose the game. T lines
follow, each describing one action. It contains several pieces of information
separated by a space. First, a pair of characters representing the entity that
must perform the action. Second, the description of the action:

  * U, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time. 
  * C indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since in the next versions of the problem, several balls may be in the same cell. 
  * T indicates that the player throws the Quaffle that it is carrying. 

All the actions performed by the entities are guaranteed to be valid: the
players stay in the field, don't catch a ball if they are not in the same
cell, don't release the Quaffle if they are not carrying it, ...

Output

You must output the description of the main events of the game, one event per
line. More precisely:

  * Each time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team. 

The events must be printed in ascending order of t.

At the end of the game, you must print the final score as: FINAL SCORE: r b,
where r is the score of the red team and b is the score of the blue team.

Examples

Input

    5 5
    
    .. R1 .. B1 ..
    
    RG .. .. .. BG
    
    RG R0 .Q B0 BG
    
    RG .. .. .. BG
    
    .. R2 .. B2 ..
    
    13
    
    B2 U
    
    B2 U
    
    B2 L
    
    B2 C .Q
    
    B2 L
    
    B2 L
    
    B2 T
    
    R0 R
    
    R0 C .Q
    
    R0 D
    
    R0 R
    
    R0 R
    
    R0 T

Output

    6 BLUE GOAL
    12 RED GOAL
    FINAL SCORE: 1 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    12
    
    R0 D
    
    R0 C .Q
    
    R0 R
    
    R0 T
    
    R0 D
    
    B0 R
    
    B0 U
    
    B0 C .Q
    
    B0 L
    
    B0 L
    
    B0 L
    
    B0 T

Output

    11 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    5
    
    R0 D
    
    R0 C .Q
    
    R0 L
    
    R0 L
    
    R0 T

Output

    4 BLUE GOAL
    FINAL SCORE: 0 1
    
Note

In the first example, a blue player goes to the middle of the grid, at the
position of the Quaffle. He takes it, goes to the goal of the red team, and
lets the ball there. He scores! The ball gets back to the middle of the field,
a red player takes it and scores too.

In the second example, the red player takes the Quaffle, move it and throw it.
The blue player catches the ball, goes to the red goal and scores.

In the third example, the red player takes the ball and scores in the goal of
their own team: the blue team wins a point.","from sys import stdin
 
mov = {'U':(-1,0),'D':(1,0),'L':(0,-1),'R':(0,1),'T':(0,0)};
GoalName = [""RED"", ""BLUE""]
 
def main():
    n,m = map(int,stdin.readline().strip().split());
    grid = [];
    elements = {"".B"":(-1,-1)};
    allPlayers = {};
    goal = [[],[]]
    points= [0,0];
    
    def goalIn( pos ):
        res = 0 if ( pos in goal[0] ) else ( 1 if ( pos in goal[1] ) else -1 );
        return res;
    def isPlayer( el ):
        res = (el[0] == 'B' or el[0] == 'R')and(el[1]!='G');
        return res;
    
    for i in range(n):
        line = stdin.readline().strip().split();
        grid.append( line );
        for ind in range(len(line)):
            if ( line[ind] != "".."" ):
                elements[line[ind]] = (i,ind);
                if ( isPlayer( line[ind] ) ):
                    allPlayers[line[ind]] = False;
                elif ( line[ind][1]=='G' ):
                    tmp = 0 if line[ind][0] =='B' else 1;
                    goal[tmp].append( (i,ind) );
    
    t = int(stdin.readline().strip());
    for time in range( t ):
        comand = stdin.readline().strip().split();
        if ( len(comand) == 3 ):
            obj, com, el = comand;
            if ( el == "".Q"" ):
                # print(""lo agarra en (%d, %d)"" % ( elements[obj][0], elements[obj][1] ) );
                allPlayers[obj] = True;
            elif ( el == "".S"" ):
                team = 1 if obj[0] =='B' else 0;
                points[team] += 10;
                print( ""%d %s CATCH GOLDEN SNITCH"" % ( time, GoalName[team] ) );
        else:
            obj, com = comand;
            pos = elements[obj];
            nxt = (pos[0]+mov[com][0], pos[1]+mov[com][1] );
            if ( ( obj == "".B"" and isPlayer(grid[nxt[0]][nxt[1]])) or ( isPlayer(obj) and elements["".B""]==nxt ) ):
                player =  obj if isPlayer(obj) else grid[nxt[0]][nxt[1]];
                print( ""%d %s ELIMINATED"" % (time, player ) );
            elif ( com=='T' ):
                allPlayers[obj] = False;
                if ( goalIn(pos)!=-1 ):
                    team=goalIn(pos);
                    print( ""%d %s GOAL"" %( time, GoalName[team] ) );
                    points[team] += 1;
            elif( isPlayer(obj) ):
                elements[obj] = nxt;
            
            if ( obj == "".B"" ):
                elements[obj] = nxt;
            
    print(""FINAL SCORE: %d %d""%( points[0], points[1] ));
                
                
                
 
main();",1,True,True,False,False,False,True,True,True,False,True,False,False,False,False
1955_D,1955_D_M4R0U4N3_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Maxim has an array a of n integers and an array b of m integers (m \le n ).

Maxim considers an array c of length m to be good if the elements of array c
can be rearranged in such a way that at least k of them match the elements of
array b .

For example, if b = [1, 2, 3, 4] and k = 3 , then the arrays [4, 1, 2, 3] and
[2, 3, 4, 5] are good (they can be reordered as follows: [1, 2, 3, 4] and [5,
2, 3, 4] ), while the arrays [3, 4, 5, 6] and [3, 4, 3, 4] are not good.

Maxim wants to choose every subsegment of array a of length m as the elements
of array c . Help Maxim count how many selected arrays will be good.

In other words, find the number of positions 1 \le l \le n - m + 1 such that
the elements a_l, a_{l+1}, \dots, a_{l + m - 1} form a good array.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains three integers n , m , and k (1 \le
k \le m \le n \le 2 \cdot 10^5 ) — the number of elements in arrays a and b ,
the required number of matching elements.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^6 ) — the elements of array a . Elements of the array a are not
necessarily unique.

The third line of each test case contains m integers b_1, b_2, \dots, b_m (1
\le b_i \le 10^6 ) — the elements of array b . Elements of the array b are not
necessarily unique.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 . Similarly, it is guaranteed that the sum of m over all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test case, output the number of good subsegments of array a on a
separate line.

Example

Input

    5
    
    7 4 2
    
    4 1 2 3 4 5 6
    
    1 2 3 4
    
    7 4 3
    
    4 1 2 3 4 5 6
    
    1 2 3 4
    
    7 4 4
    
    4 1 2 3 4 5 6
    
    1 2 3 4
    
    11 5 3
    
    9 9 2 2 10 9 7 6 3 6 3
    
    6 9 7 8 10
    
    4 1 1
    
    4 1 5 6
    
    6

Output

    4
    3
    2
    4
    1
    
Note

In the first example, all subsegments are good.

In the second example, good subsegments start at positions 1 , 2 , and 3 .

In the third example, good subsegments start at positions 1 and 2 .","max_val = 1000000  # Update this with the actual known maximum value if needed
 
cnt_b = [0] * (max_val + 1)
 
for _ in range(int(input())):
    n, m, k = map(int, input().split())
 
    a = list(map(int, input().split()))  # n elements
    b = list(map(int, input().split()))  # m elements
 
    for i in range(m):
        cnt_b[b[i]] += 1
 
    b_values = set(b)
 
    ans = 0
    curr = 0
 
    for i in range(m):
        if a[i] in b_values:
            cnt_b[a[i]] -= 1
            if cnt_b[a[i]] >= 0:
                curr += 1
 
    if curr >= k:
        ans += 1
 
    for i in range(n - m):
        if a[i] in b_values:
            cnt_b[a[i]] += 1
            if cnt_b[a[i]] > 0:
                curr -= 1
 
        if a[i + m] in b_values:
            cnt_b[a[i + m]] -= 1
            if cnt_b[a[i + m]] >= 0:
                curr += 1
 
        if curr >= k:
            ans += 1
 
    print(ans)
 
    for i in b_values:
        cnt_b[i] = 0",1,True,True,False,True,True,True,True,True,False,False,False,True,True,True
1949_D,1949_D_Lucina_24.69%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are designing a new video game. It has n scenarios, which the player may
play in any order, but each scenario must be played exactly once. When a
player switches from a scenario to another scenario, the game shows a
specially crafted transition video to make it all feel part of one big story.
This video is specific to a pair of scenarios, but not to their order, in
other words, the video playing when switching from scenario a to scenario b is
the same as the video playing when switching from scenario b to scenario a .
Therefore, you need to create \frac{n(n-1)}{2} different transition videos,
one for each possible pair of different scenarios.

Each transition video can be either funny or scary. It is boring to see too
many funny videos or too many scary videos in a row. Therefore, your goal is
to create the videos in such a way that no matter in which order does the
player approach the scenarios, they will never see more than \lceil
\frac{3n}{4} \rceil transition videos of the same type in a row.

You have already come up with ideas for at most \lfloor \frac{n}{2} \rfloor of
the transition videos, and therefore already know if those will be funny or
scary. Now you need to choose funny or scary for all other transition videos
in such a way that the above requirement is satisfied.

Input

The first line contains a single integer n (2 \le n \le 24 ) — the number of
scenarios in the game.

The next n lines describe the partial transition video plan. Each of those
lines contains n characters. The j -th character of the i -th line corresponds
to the transition video between the i -th and the j -th scenarios. It will be
F if the corresponding transition video will be funny, S if the corresponding
transition video will be scary, ? if the corresponding transition video is
still undecided, or . if i=j .

It is guaranteed that the i -th character of the j -th line and the j -th
character of the i -th line will be the same for all i and j . It is
guaranteed that at most \lfloor \frac{n}{2} \rfloor (n divided by 2, rounded
down) transition videos will already be decided, in other words, that at most
2\lfloor \frac{n}{2} \rfloor characters in the input will be F or S.

Output

Print n lines describing the full transition video plan in the same format as
the input. Each of those lines must contain n characters. The j -th character
of the i -th line must be F if the corresponding transition video is funny, S
if the corresponding transition video is scary, or . if i=j .

Each ? character from the input must be replaced with either F or S, and all
other characters from the input must remain unchanged. It must still hold that
the i -th character of the j -th line and the j -th character of the i -th
line are the same for all i and j .

For each permutation of the n scenarios, it must hold that the transition
videos corresponding to playing the scenarios in this order do not have more
than \lceil \frac{3n}{4} \rceil (3n divided by 4, rounded up) videos of the
same type consecutively.

If there are multiple solutions, print any of them. It can be proven that for
all inputs satisfying the constraints of this problem a solution always
exists.

Examples

Input

    5
    
    .?F??
    
    ?.???
    
    F?.S?
    
    ??S.?
    
    ????.

Output

    .FFFF
    F.FFF
    FF.SF
    FFS.F
    FFFF.

Input

    12
    
    .???????????
    
    ?.??????????
    
    ??.?????????
    
    ???.????????
    
    ????.???????
    
    ?????.??????
    
    ??????.?????
    
    ???????.????
    
    ????????.???
    
    ?????????.??
    
    ??????????.?
    
    ???????????.

Output

    .SSSFFSSSSFS
    S.SFFSFSFFFS
    SS.SFFFSSSFS
    SFS.FFSSSSFS
    FFFF.FFFFFSF
    FSFFF.SFFSFF
    SFFSFS.SSSFS
    SSSSFFS.SSFS
    SFSSFFSS.SFS
    SFSSFSSSS.FS
    FFFFSFFFFF.F
    SSSSFFSSSSF.
    
Note

In the first sample: We are allowed \lceil \frac{3\cdot 5}{4} \rceil=4
transition videos of the same type in a row, but for any permutation of the 5
scenarios the player will see only 4 transition videos in total, therefore we
can choose funny or scary freely. We must still respect the already chosen
types.

In the second sample: One of the 479001600 possible permutations of scenarios
is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following
sequence of transition videos for this permutation: SSSSSSSSSFS. Even though
this sequence has 10 scary transition videos in total, it has only 9 scary
transition videos in a row, which is the maximum allowed amount (\lceil
\frac{3\cdot 12}{4} \rceil=9 ).","n = int(input())
a = [0]*(n+1)
b = [0]*(n+1)
xx = [""""]
for i in range(1,n+1):
    x = input()
    for j in range(1,n+1):
        if x[j-1] == ""F"":
            a[i] += 1
            a[j] += 1
        elif x[j-1] == ""S"":
            b[i] += 1
            b[j] += 1
    xx.append(x)
 
sa = []
sb = []
for i in range(1,n+1):
    if a[i] > 0 and b[i] == 0:
        sa.append(i)
    if b[i] > 0 and a[i] == 0:
        sb.append(i)
if len(sa) >= len(sb):
    for i in range(1,n+1):
        if a[i] == 0 and b[i] == 0:
            sa.append(i)
    for i in range(1,n+1):
        nx = """"
        for j in range(1,n+1):
            if xx[i][j-1] != ""?"":
                nx += xx[i][j-1]
            elif i in sa[:n//4] or j in sa[:n//4]:
                nx += ""F""
            else:
                nx += ""S""
        print(nx)
else:
    for i in range(1,n+1):
        if a[i] == 0 and b[i] == 0:
            sb.append(i)
    for i in range(1,n+1):
        nx = """"
        for j in range(1,n+1):
            if xx[i][j-1] != ""?"":
                nx += xx[i][j-1]
            elif i in sb[:n//4] or j in sb[:n//4]:
                nx += ""S""
            else:
                nx += ""F""
        print(nx)",1,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1927_C,1927_C_saeed_zirak_3.70%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Given an array a of n integers, an array b of m integers, and an even number k
.

Your task is to determine whether it is possible to choose exactly \frac{k}{2}
elements from both arrays in such a way that among the chosen elements, every
integer from 1 to k is included.

For example:

  * If a=[2, 3, 8, 5, 6, 5] , b=[1, 3, 4, 10, 5] , k=6 , then it is possible to choose elements with values 2, 3, 6 from array a and elements with values 1, 4, 5 from array b . In this case, all numbers from 1 to k=6 will be included among the chosen elements.
  * If a=[2, 3, 4, 5, 6, 5] , b=[1, 3, 8, 10, 3] , k=6 , then it is not possible to choose elements in the required way. 

Note that you are not required to find a way to choose the elements — your
program should only check whether it is possible to choose the elements in the
required way.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains three integers n , m , and k (1 \le
n, m \le 2\cdot10^5 , 2 \le k \le 2 \cdot \min(n, m) , k is even) — the length
of array a , the length of array b , and the number of elements to be chosen,
respectively.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^6 ) — the elements of array a .

The third line of each test case contains m integers b_1, b_2, \dots, b_m (1
\le b_j \le 10^6 ) — the elements of array b .

It is guaranteed that the sum of values n and m over all test cases in a test
does not exceed 4 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output ""YES"" if it is possible to choose \frac{k}{2} numbers from
each array in such a way that among the chosen elements, every integer from 1
to k is included. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    6
    
    6 5 6
    
    2 3 8 5 6 5
    
    1 3 4 10 5
    
    6 5 6
    
    2 3 4 5 6 5
    
    1 3 8 10 3
    
    3 3 4
    
    1 3 5
    
    2 4 6
    
    2 5 4
    
    1 4
    
    7 3 4 4 2
    
    1 4 2
    
    2
    
    6 4 4 2
    
    1 5 2
    
    3
    
    2 2 1 4 3

Output

    YES
    NO
    YES
    YES
    NO
    NO
    
Note

In the first test case of the example, it is possible to choose elements equal
to 2 , 3 , and 6 from array a and elements equal to 1 , 4 , and 5 from array b
. Thus, all numbers from 1 to k=6 are included among the chosen elements.

In the second test case of the example, it can be shown that it is not
possible to choose exactly three elements from each array in the required way.

In the third test case of the example, it is possible to choose elements equal
to 1 and 3 from array a and elements equal to 2 and 4 from array b . Thus, all
numbers from 1 to k=4 are included among the chosen elements.","for t in range(int(input())):
    n,m,k=map(int,input().split())
    a=list(map(int,input().split()))
    b=list(map(int,input().split()))
 
    aOnes=0
    bOnes=0
    newk=k//2
    i=1
    
    while i<=k:
        if i in a and i in b:
            if aOnes<bOnes:
                aOnes+=1
            else:
                bOnes+=1
        elif i in a and aOnes<=newk:
            aOnes+=1
        elif i in b and bOnes<=newk:
            bOnes+=1
        else:
            break
        i+=1
 
 
    if aOnes==newk and bOnes==newk:
        print(""yes"")
    else:
        print(""no"")",1,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1948_C,1948_C_we_114514_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a grid, consisting of 2 rows and n columns. The rows are numbered
from 1 to 2 from top to bottom. The columns are numbered from 1 to n from left
to right. Each cell of the grid contains an arrow pointing either to the left
or to the right. No arrow points outside the grid.

There is a robot that starts in a cell (1, 1) . Every second, the following
two actions happen one after another:

  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); 
  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). 

Your task is to determine whether the robot can reach the cell (2, n) .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer (2 \le n \le 2
\cdot 10^5 ).

The second line contains a string consisting of exactly n characters < and/or
> — the first row of the grid.

The third line contains a string consisting of exactly n characters < and/or >
— the second row of the grid.

Additional constraints on the input:

  * n is even; 
  * there are no arrows pointing outside the grid; 
  * the sum of n over all test cases doesn't exceed 2 \cdot 10^5 . 

Output

For each test case, print YES if the robot can reach the cell (2, n) ;
otherwise, print NO.

You can print each letter in any case. For example, yes, Yes, YeS will all be
recognized as positive answer.

Example

Input

    4
    
    4
    
    >><<
    
    >>><
    
    2
    
    ><
    
    ><
    
    4
    
    >>><
    
    >><<
    
    6
    
    >><<><
    
    ><>>><

Output

    YES
    YES
    NO
    YES
    
Note

In the first example, one of the possible paths looks as follows: (1, 1)
\rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 4) .

In the second example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) .

In the third example, there is no way to reach the cell (2, 4) .

In the fourth example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (1, 2) \rightarrow (1, 3)
\rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (2, 5) \rightarrow (2, 6) .","def can_reach_end(n, row1, row2):
    """"""
    判断机器人是否能够从 (1,1) 到达 (2,n)。
    """"""
    half_n = n // 2  # 列数的一半（n 是偶数）
    for i in range(half_n - 1):
        if row1[2 * i + 1] == '<' and (row2[2 * i] == '<' or row2[2 * i + 2] == '<'):
            return ""No""
    if row1[n - 1] == '<' and row2[n - 2] == '<':
        return ""No""
    return ""Yes""
 
def process_test_cases():
    """"""
    读取输入并处理每个测试用例。
    """"""
    t = int(input())
    results = []
    for _ in range(t):
        n = int(input())
        row1 = input()
        row2 = input()
        results.append(can_reach_end(n, row1, row2))
    print(""\n"".join(results))
 
if __name__ == ""__main__"":
    process_test_cases()",1,True,False,False,True,False,False,True,True,False,False,True,False,False,False
1941_B,1941_B_mathemolympiad_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Rudolf has an array a of n integers, the elements are numbered from 1 to n .

In one operation, he can choose an index i (2 \le i \le n - 1 ) and assign:

  * a_{i - 1} = a_{i - 1} - 1 
  * a_i = a_i - 2 
  * a_{i + 1} = a_{i + 1} - 1 

Rudolf can apply this operation any number of times. Any index i can be used
zero or more times.

Can he make all the elements of the array equal to zero using this operation?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases in the test.

The first line of each case contains a single integer n (3 \le n \le 2 \cdot
10^5 ) — the number of elements in the array.

The second line of each case contains n integers a_1, a_2, \dots, a_n (0 \le
a_j \le 10^9 ) — the elements of the array.

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output ""YES"" if it is possible to make all the elements of
the array zero using the described operations. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    7
    
    5
    
    1 3 5 5 2
    
    5
    
    2 4 4 5 1
    
    5
    
    0 1 3 3 1
    
    6
    
    5 6 0 2 3 0
    
    4
    
    1 2 7 2
    
    3
    
    7 1 0
    
    4
    
    1 1 1 1

Output

    YES
    NO
    YES
    NO
    NO
    NO
    NO
    
Note

In the first example, the original array is [1, 3, 5, 5, 2] , to make all its
elements zero, Rudolf can act as follows:

  * apply the operation at i=4 and get the array [1, 3, 4, 3, 1] ; 
  * apply the operation at i=3 and get the array [1, 2, 2, 2, 1] ; 
  * apply the operation at i=2 and get the array [0, 0, 1, 2, 1] ; 
  * apply the operation at i=4 and get the array [0, 0, 0, 0, 0] .","numTest = int(input())
 
for _ in range (0, numTest):
    n = int(input())
    a = [int(x) for x in input().split()]
    stop = False
    for i in range (0, n-2):
        if a[i] < 0:
            print(""NO"")
            stop = True
            break
        opNum = a[i]
        a[i] -= opNum
        a[i+1] -= 2*opNum
        a[i+2] -= opNum
    if stop == True:
        continue
    if a[len(a)-1]!=0 or a[len(a)-2]!=0:
        print(""NO"")
    else:
        print(""YES"")",1,True,False,False,False,False,True,False,False,False,False,False,False,False,False
1922_C,1922_C_Talharashid_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n cities located on the number line, the i -th city is in the point
a_i . The coordinates of the cities are given in ascending order, so a_1 < a_2
< \dots < a_n .

The distance between two cities x and y is equal to |a_x - a_y| .

For each city i , let's define the closest city j as the city such that the
distance between i and j is not greater than the distance between i and each
other city k . For example, if the cities are located in points [0, 8, 12, 15,
20] , then:

  * the closest city to the city 1 is the city 2 ; 
  * the closest city to the city 2 is the city 3 ; 
  * the closest city to the city 3 is the city 4 ; 
  * the closest city to the city 4 is the city 3 ; 
  * the closest city to the city 5 is the city 4 . 

The cities are located in such a way that for every city, the closest city is
unique. For example, it is impossible for the cities to be situated in points
[1, 2, 3] , since this would mean that the city 2 has two closest cities (1
and 3 , both having distance 1 ).

You can travel between cities. Suppose you are currently in the city x . Then
you can perform one of the following actions:

  * travel to any other city y , paying |a_x - a_y| coins; 
  * travel to the city which is the closest to x , paying 1 coin. 

You are given m queries. In each query, you will be given two cities, and you
have to calculate the minimum number of coins you have to spend to travel from
one city to the other city.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

Each test case is given in the following format:

  * the first line contains one integer n (2 \le n \le 10^5 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_1 < a_2 < \dots < a_n \le 10^9 ); 
  * the third line contains one integer m (1 \le m \le 10^5 ); 
  * then m lines follow; the i -th of them contains two integers x_i and y_i (1 \le x_i, y_i \le n ; x_i \ne y_i ), denoting that in the i -th query, you have to calculate the minimum number of coins you have to spend to travel from the city x_i to the city y_i . 

Additional constraints on the input:

  * in every test case, for each city, the closest city is determined uniquely; 
  * the sum of n over all test cases does not exceed 10^5 ; 
  * the sum of m over all test cases does not exceed 10^5 . 

Output

For each query, print one integer — the minimum number of coins you have to
spend.

Example

Input

    1
    
    5
    
    0 8 12 15 20
    
    5
    
    1 4
    
    1 5
    
    3 4
    
    3 2
    
    5 1

Output

    3
    8
    1
    4
    14
    
Note

Let's consider the first two queries in the example from the statement:

  * in the first query, you are initially in the city 1 . You can travel to the closest city (which is the city 2 ), paying 1 coin. Then you travel to the closest city (which is the city 3 ) again, paying 1 coin. Then you travel to the closest city (which is the city 4 ) again, paying 1 coin. In total, you spend 3 coins to get from the city 1 to the city 4 ; 
  * in the second query, you can use the same way to get from the city 1 to the city 4 , and then spend 5 coins to travel from the city 4 to the city 5 .","from collections import defaultdict
for i in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    d1=defaultdict(int)
    d2=defaultdict(int)
    d1[2]=1
    for i in range(1,n-1):
        if (l[i+1]-l[i])<(l[i]-l[i-1]) :
            d1[i+2]=1+d1[i+1]
        else:
            d1[i+2]=(l[i+1]-l[i])+d1[i+1]
    d2[n-1]=1
    for i in range(n-2,0,-1):
        if (l[i]-l[i-1])<(l[i+1]-l[i]) :
            d2[i]=1+d2[i+1]
        else:
            d2[i]=(l[i]-l[i-1])+d2[i+1]
    #print(d1,d2)
    m=int(input())
    for j in range(m):
        x,y=(map(int,input().split()))
        if y>x:
            print(d1[y]-d1[x])
        else:
            print(d2[y]-d2[x])",1,True,False,False,True,False,False,False,False,False,False,False,False,False,False
1965_A,1965_A_ool_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob are playing a game on n piles of stones. On each player's turn,
they select a positive integer k that is at most the size of the smallest
nonempty pile and remove k stones from each nonempty pile at once. The first
player who is unable to make a move (because all piles are empty) loses.

Given that Alice goes first, who will win the game if both players play
optimally?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the number of piles in the game.

The next line of each test case contains n integers a_1, a_2, \ldots a_n (1
\le a_i \le 10^9 ), where a_i is the initial number of stones in the i -th
pile.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, print a single line with the name of the winner, assuming
both players play optimally. If Alice wins, print ""Alice"", otherwise print
""Bob"" (without quotes).

Example

Input

    7
    
    5
    
    3 3 3 3 3
    
    2
    
    1 7
    
    7
    
    1 3 9 7 4 2 100
    
    3
    
    1 2 3
    
    6
    
    2 1 3 4 2 4
    
    8
    
    5 7 2 9 6 3 3 2
    
    1
    
    1000000000

Output

    Alice
    Bob
    Alice
    Alice
    Bob
    Alice
    Alice
    
Note

In the first test case, Alice can win by choosing k=3 on her first turn, which
will empty all of the piles at once.

In the second test case, Alice must choose k=1 on her first turn since there
is a pile of size 1 , so Bob can win on the next turn by choosing k=6 .","import heapq
import sys
 
input = sys.stdin.readline
 
def solve(arr):
    A = False
    if arr[0] != 1:
        return 'Alice'
    set_ = list(set(arr))
    set_.sort()
    not_c = True
    for i in range(1, len(set_)):
        if set_[i] - set_[i-1] > 1:
            not_c = False
            break
        A = not A
    if not_c:
        A = not A
 
    return 'Alice' if A else 'Bob'
 
 
t = int(input())
c = 1
while t > 0:
    n = list(map(int, input().rstrip().split()))
 
    arr = list(map(int, input().rstrip().split()))
    r = solve(arr)
    print(r)
    t -= 1",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1978_A,1978_A_Divya_Reddy78094_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice has n books. The 1 -st book contains a_1 pages, the 2 -nd book contains
a_2 pages, \ldots , the n -th book contains a_n pages. Alice does the
following:

  * She divides all the books into two non-empty piles. Thus, each book ends up in exactly one of the two piles.
  * Alice reads one book with the highest number in each pile.

Alice loves reading very much. Help her find the maximum total number of pages
she can read by dividing the books into two piles.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 100
) — the number of books Alice has.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the number of pages in each book.

Output

For each test case, output a single integer — the maximum number of pages
Alice can read.

Example

Input

    5
    
    2
    
    1 1
    
    4
    
    2 3 3 1
    
    5
    
    2 2 3 2 2
    
    2
    
    10 3
    
    3
    
    1 2 3

Output

    2
    4
    5
    13
    5
    
Note

In the first test case, Alice can put book number 1 in the first pile, and
book number 2 in the second pile. Then she will read a_1 + a_2 = 1 + 1 = 2
pages.

In the second test case, Alice can put books with numbers 2 and 3 in the first
pile, and books with numbers 1 and 4 in the second pile. Then she will read
the book with the highest number 3 from the first pile, and the book with the
highest number 4 from the second pile. Then she will read a_3 + a_4 = 3 + 1 =
4 pages.","t= int(input())
for _ in range(t):
    n = int(input())
    nums  = list(map(int,input().split()))
    print(max(nums[:-1])+nums[-1])",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1924_A,1924_A_uguess_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two integers n and k along with a string s .

Your task is to check whether all possible strings of length n that can be
formed using the first k lowercase English alphabets occur as a subsequence of
s . If the answer is NO, you also need to print a string of length n that can
be formed using the first k lowercase English alphabets which does not occur
as a subsequence of s .

If there are multiple answers, you may print any of them.

Note: A string a is called a subsequence of another string b if a can be
obtained by deleting some (possibly zero) characters from b without changing
the order of the remaining characters.

Input

The first line of input contains a single integer t \, (1 \le t \le 10^5) ,
the number of test cases.

The first line of each test case contains 3 integers n \, (1 \le n \le 26), \:
k \, (1 \le k \le 26), \: m \, (1 \le m \le 1000) , where n and k are the same
as described in the input and m is the length of the string s .

The second line of each test case contains a single string s of length m ,
comprising only of the first k lowercase English alphabets.

It is guaranteed that the sum of m and the sum of n over all test cases does
not exceed 10^6 .

Output

For each test case, print YES if all possible strings of length n that can be
formed using the first k lowercase English alphabets occur as a subsequence of
s , else print NO.

If your answer is NO, print a string of length n that can be formed using the
first k lowercase English alphabets which does not occur as a subsequence of s
in the next line.

You may print each letter of YES or NO in any case (for example, YES, yES, YeS
will all be recognized as a positive answer).

Example

Input

    3
    
    2 2 4
    
    abba
    
    2 2 3
    
    abb
    
    3 3 10
    
    aabbccabab

Output

    YES
    NO
    aa
    NO
    ccc
    
Note

For the first test case, all possible strings (aa, ab, ba, bb) of length 2
that can be formed using the first 2 English alphabets occur as a subsequence
of abba.

For the second test case, the string aa is not a subsequence of abb.","t = int(input())
 
for i in range(t):
    n, k, m = map(int,input().split())
    s = input()
 
    cnt = 0
    cur = 0
    ans=''
 
    for ss in s:
        cur_ss = ord(ss)-ord('a')
        if cur & (1 << cur_ss) == 0:
            cur += (1 << cur_ss)
        if cur == (1<<k)-1:
            cnt += 1
            cur = 0
            ans+=ss
    if cnt >= n:
        print('YES')
    else:
        print('NO')
        tmp = ''
        for i in range(k):
            if cur & (1 << i) == 0:
                tmp = chr(ord('a')+i)
                break
        ans += tmp
        ans += 'a'*(n-cnt-1)
        print(ans)",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1932_C,1932_C_2200033007_KLU_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array a of length n , a positive integer m , and a string of
commands of length n . Each command is either the character 'L' or the
character 'R'.

Process all n commands in the order they are written in the string s .
Processing a command is done as follows:

  * First, output the remainder of the product of all elements of the array a when divided by m . 
  * Then, if the command is 'L', remove the leftmost element from the array a , if the command is 'R', remove the rightmost element from the array a . 

Note that after each move, the length of the array a decreases by 1 , and
after processing all commands, it will be empty.

Write a program that will process all commands in the order they are written
in the string s (from left to right).

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases in the input. Then descriptions of t test cases follow.

Each test case of the input is given by three lines.

The first line contains two integers n and m (1 \le n \le 2\cdot10^5, 1 \le m
\le 10^4 ) — the initial length of the array a and the value to take the
remainder by.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^4 )
— the elements of the array a .

The third line contains a string s consisting of n characters 'L' and 'R'.

It is guaranteed that the sum of the values of n for all test cases in a test
does not exceed 2\cdot10^5 .

Output

For each test case, output n integers b_1, b_2, \dots, b_n , where b_i is the
remainder when dividing the product of all elements of the current state of
the array a by m at the beginning of the execution of the i -th command.

Example

Input

    4
    
    4 6
    
    3 1 4 2
    
    LRRL
    
    5 1
    
    1 1 1 1 1
    
    LLLLL
    
    6 8
    
    1 2 3 4 5 6
    
    RLLLRR
    
    1 10000
    
    10000
    
    R

Output

    0 2 4 1 
    0 0 0 0 0 
    0 0 0 4 4 4 
    0 
    
Note

In the first test case of the example:

  * 3 \cdot 1 \cdot 4 \cdot 2 \bmod 6 = 24 \bmod 6 = 0 ;
  * s_1 = \text{L} , so we remove the first element and get the array [1, 4, 2] ;
  * 1 \cdot 4 \cdot 2 \bmod 6 = 8 \bmod 6 = 2 ;
  * s_2 = \text{R} , so we remove the last element and get the array [1, 4] ;
  * 1 \cdot 4 \bmod 6 = 4 \bmod 6 = 4 ;
  * s_3 = \text{R} , so we remove the last element and get the array [1] ;
  * 1 \bmod 6 = 1 ;
  * s_4 = \text{L} , so we remove the first element and get an empty array.","def solve(n, m, a, s):
	b = []
	l = 0
	r = n - 1
	for i in range(n):
		if s[i] == 'L':
			b.append(a[l])
			l += 1
		else:
			b.append(a[r])
			r -= 1
	ans = []
	p = 1
	for v in reversed(b):
		p = (p * v)%m
		ans.append(p)
	return reversed(ans)
 
for _ in range(int(input())):
	n, m = map(int, input().split())
	a = list(map(int, input().split()))
	s = input()
	print(*solve(n, m, a, s))",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1945_B,1945_B_Rylin31_14.29%,codeforces2024,human,qwen2p5-coder-32b-instruct,"One of the days of the hike coincided with a holiday, so in the evening at the
camp, it was decided to arrange a festive fireworks display. For this purpose,
the organizers of the hike bought two installations for launching fireworks
and a huge number of shells for launching.

Both installations are turned on simultaneously. The first installation
launches fireworks every a minutes (i.e., after a, 2 \cdot a, 3 \cdot a, \dots
minutes after launch). The second installation launches fireworks every b
minutes (i.e., after b, 2 \cdot b, 3 \cdot b, \dots minutes after launch).

Each firework is visible in the sky for m + 1 minutes after launch, i.e., if a
firework was launched after x minutes after the installations were turned on,
it will be visible every minute from x to x + m , inclusive. If one firework
was launched m minutes after another, both fireworks will be visible for one
minute.

What is the maximum number of fireworks that could be seen in the sky at the
same time?

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follow the
descriptions of the test cases.

The first and only line of each test case contains integers a , b , m (1 \le
a, b, m \le 10^{18} ) — the frequency of launching for the first installation,
the second installation, and the time the firework is visible in the sky.

Output

For each set of input data, output a single number — the maximum number of
fireworks that can be seen simultaneously.

Example

Input

    6
    
    6 7 4
    
    3 4 10
    
    7 8 56
    
    5 6 78123459896
    
    1 1 1
    
    1 1 1000000000000000000

Output

    2
    7
    17
    28645268630
    4
    2000000000000000002
    
Note

In the first set of input data, the fireworks are visible in the sky for 5
minutes. Since the first installation launches fireworks every 6 minutes, and
the second one every 7 minutes, two fireworks launched from the same
installation will not be visible in the sky at the same time. At the same
time, after 7 minutes from the start of the holiday, one firework from the
first and one from the second camp will be visible. Thus, it is possible to
see no more than 2 fireworks simultaneously.

In the third set of input data, 17 fireworks will be visible after 112
minutes:

  * 9 fireworks launched from the first installation at times [56, 63, 70, 77, 84, 91, 98, 105, 112 ]; 
  * 8 fireworks launched from the second installation at times [56, 64, 72, 80, 88, 96, 104, 112 ].","t=int(input())
for i in range(t):
  a,b,m=map(int,input().split())
  mn=min(a,b)+m
  if m%a==0 and m%b==0 and a!=1 and b!=1:
    print((mn)//a+(mn)//b+1)
  else:
    print((mn)//a+(mn)//b)",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1971_D,1971_D_DSKroc_14.29%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a binary string^{\dagger} . Please find the minimum number of
pieces you need to cut it into, so that the resulting pieces can be rearranged
into a sorted binary string.

![](https://espresso.codeforces.com/76039f9769ba94c1817dbbc5e1fb1b5e4f60950f.png)

Note that:

  * each character must lie in exactly one of the pieces; 
  * the pieces must be contiguous substrings of the original string; 
  * you must use all the pieces in the rearrangement. 

^{\dagger} A binary string is a string consisting of characters \texttt{0} and
\texttt{1} . A sorted binary string is a binary string such that all
characters \texttt{0} come before all characters \texttt{1} .

Input

The first line contains a single integer t (1 \leq t \leq 500 ) — the number
of test cases.

The only line of each test case contains a single string s (1 \leq |s| \leq
500 ) consisting of characters \texttt{0} and \texttt{1} , where |s| denotes
the length of the string s .

Output

For each test case, output a single integer — the minimum number of pieces
needed to be able to rearrange the string into a sorted binary string.

Example

Input

    6
    
    11010
    
    00000000
    
    1
    
    10
    
    0001111
    
    0110

Output

    3
    1
    1
    2
    1
    2
    
Note

The first test case is pictured in the statement. It can be proven that you
can't use fewer than 3 pieces.

In the second and third test cases, the binary string is already sorted, so
only 1 piece is needed.

In the fourth test case, you need to make a single cut between the two
characters and rearrange them to make the string \texttt{01} .","import math
t = int(input())
for q in range(t) :
    s =  input()
    count=0
    for i in range(len(s)-1) :
        if int(s[i]) > int(s[i+1]) :
            count+=1
    print(count+1)",1,False,True,True,True,True,True,True,True,False,False,True,True,True,True
1945_A,1945_A_2210080053_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.","for s in[*open(0)][1:]:a,b,c=map(int,s.split());b+=c;print((a--b//3,-1)[c<b%3])",1,True,True,False,True,False,False,True,True,False,False,True,True,True,True
1941_B,1941_B_m.olimovvv_20.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Rudolf has an array a of n integers, the elements are numbered from 1 to n .

In one operation, he can choose an index i (2 \le i \le n - 1 ) and assign:

  * a_{i - 1} = a_{i - 1} - 1 
  * a_i = a_i - 2 
  * a_{i + 1} = a_{i + 1} - 1 

Rudolf can apply this operation any number of times. Any index i can be used
zero or more times.

Can he make all the elements of the array equal to zero using this operation?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases in the test.

The first line of each case contains a single integer n (3 \le n \le 2 \cdot
10^5 ) — the number of elements in the array.

The second line of each case contains n integers a_1, a_2, \dots, a_n (0 \le
a_j \le 10^9 ) — the elements of the array.

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output ""YES"" if it is possible to make all the elements of
the array zero using the described operations. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    7
    
    5
    
    1 3 5 5 2
    
    5
    
    2 4 4 5 1
    
    5
    
    0 1 3 3 1
    
    6
    
    5 6 0 2 3 0
    
    4
    
    1 2 7 2
    
    3
    
    7 1 0
    
    4
    
    1 1 1 1

Output

    YES
    NO
    YES
    NO
    NO
    NO
    NO
    
Note

In the first example, the original array is [1, 3, 5, 5, 2] , to make all its
elements zero, Rudolf can act as follows:

  * apply the operation at i=4 and get the array [1, 3, 4, 3, 1] ; 
  * apply the operation at i=3 and get the array [1, 2, 2, 2, 1] ; 
  * apply the operation at i=2 and get the array [0, 0, 1, 2, 1] ; 
  * apply the operation at i=4 and get the array [0, 0, 0, 0, 0] .","for _ in range(int(input())):
    a = int(input())
    b = list(map(int, input().split()))
    if b[0] % 2 == 1 and b[1] != b[0] + 2 or b[-1] % 2 == 1 and b[-2] != b[-1] + 2:
        print(""NO"")
    else:
        print(""YES"")",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1930_A,1930_A_Artem_Pugash_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are 2n positive integers written on a whiteboard. Being bored, you
decided to play a one-player game with the numbers on the whiteboard.

You start with a score of 0 . You will increase your score by performing the
following move exactly n times:

  * Choose two integers x and y that are written on the whiteboard. 
  * Add \min(x,y) to your score. 
  * Erase x and y from the whiteboard. 

Note that after performing the move n times, there will be no more integers
written on the whiteboard.

Find the maximum final score you can achieve if you optimally perform the n
moves.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \leq n \leq 50
) — the number of integers written on the whiteboard is 2n .

The second line of each test case contains 2n integers a_1,a_2,\ldots,a_{2n}
(1 \leq a_i \leq 10^7 ) — the numbers written on the whiteboard.

Output

For each test case, output the maximum final score that you can achieve.

Example

Input

    3
    
    1
    
    2 3
    
    2
    
    1 1 2 1
    
    3
    
    1 1 1 1 1 1

Output

    2
    2
    3
    
Note

In the first test case, you can only make one move. You select x=2 and y=3 ,
and your score will be \min(x,y)=2 .

In the second test case, the following is a sequence of moves that achieves a
final score of 2 :

  * In the first move, select x=1 and y=1 . Then, add \min(x,y)=1 to the score. After erasing x and y , the integers left on the whiteboard are 1 and 2 . 
  * In the second move, select x=1 and y=2 . Then, add \min(x,y)=1 to the score. After removing x and y , no more integers will be left on the whiteboard. 

It can be proved that it is not possible to get a score greater than 2 .

In the third test case, you will perform the move thrice, adding 1 to the
score each time.","for _ in range(int(input())):
	n = int(input())
	l = sorted(list(map(int, input().split())))
	score = 0
	for i in range(0,2*n,2):
		score+=l[i]
 
	print(score)",1,True,True,True,True,True,True,True,True,True,True,True,True,True,True
1923_C,1923_C_tgfgvfbvd_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"An array a of length m is considered good if there exists an integer array b
of length m such that the following conditions hold:

  1. \sum\limits_{i=1}^{m} a_i = \sum\limits_{i=1}^{m} b_i ; 
  2. a_i \neq b_i for every index i from 1 to m ; 
  3. b_i > 0 for every index i from 1 to m . 

You are given an array c of length n . Each element of this array is greater
than 0 .

You have to answer q queries. During the i -th query, you have to determine
whether the subarray c_{l_{i}}, c_{l_{i}+1}, \dots, c_{r_{i}} is good.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and q (1 \le n, q \le
3 \cdot 10^5 ) — the length of the array c and the number of queries.

The second line of each test case contains n integers c_1, c_2, \dots, c_n (1
\le c_i \le 10^9 ).

Then q lines follow. The i -th of them contains two integers l_i and r_i (1
\le l_i \le r_i \le n ) — the borders of the i -th subarray.

Additional constraints on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 ; the sum of q over all test cases does not exceed 3 \cdot
10^5 .

Output

For each query, print YES if the subarray is good. Otherwise, print NO.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    1
    
    5 4
    
    1 2 1 4 5
    
    1 5
    
    4 4
    
    3 4
    
    1 3

Output

    YES
    NO
    YES
    NO","for _ in range(int(input())):
    n,m=map(int,input().split())
    l=list(map(int,input().split()))
    p=[0]
    c=[0]
    i,j=0,0
 
    for x in l:
        if x==1:
            j+=1
        i+=x
 
        p.append(i)
        c.append(j)
 
    for _ in range(m):
        a,b=map(int,input().split())
        i=c[b]-c[a-1]
        s=p[b]-p[a-1]
 
        if b-a+1>1 and s-(b-a+1)>=i:
            print('YES')
        else:
            print('NO')",1,True,True,False,False,False,True,True,True,False,False,False,False,True,False
1929_A,1929_A_mina330_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Sasha decided to give his girlfriend an array a_1, a_2, \ldots, a_n . He found
out that his girlfriend evaluates the beauty of the array as the sum of the
values (a_i - a_{i - 1}) for all integers i from 2 to n .

Help Sasha and tell him the maximum beauty of the array a that he can obtain,
if he can rearrange its elements in any way.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \leq n \leq
100 ) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\leq a_i \leq 10^9 ) — the elements of the array a .

Output

For each test case, output a single integer — the maximum beauty of the array
a that can be obtained.

Example

Input

    5
    
    3
    
    2 1 3
    
    3
    
    69 69 69
    
    5
    
    100 54 80 43 90
    
    4
    
    3 4 3 3
    
    2
    
    2 1

Output

    2
    0
    57
    1
    1
    
Note

In the first test case, the elements of the array a can be rearranged to make
a = [1, 2, 3] . Then its beauty will be equal to (a_2 - a_1) + (a_3 - a_2) =
(2 - 1) + (3 - 2) = 2 .

In the second test case, there is no need to rearrange the elements of the
array a . Then its beauty will be equal to 0 .","ntest=int(input())
for itest in range(0,ntest,1):
    n=int(input())
    a=list(map(int,input().split()))
    a.sort()
    print(a[len(a)-1]-a[0])",1,True,False,False,True,False,True,True,True,False,False,False,True,True,False
1971_D,1971_D_Macjony_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a binary string^{\dagger} . Please find the minimum number of
pieces you need to cut it into, so that the resulting pieces can be rearranged
into a sorted binary string.

![](https://espresso.codeforces.com/76039f9769ba94c1817dbbc5e1fb1b5e4f60950f.png)

Note that:

  * each character must lie in exactly one of the pieces; 
  * the pieces must be contiguous substrings of the original string; 
  * you must use all the pieces in the rearrangement. 

^{\dagger} A binary string is a string consisting of characters \texttt{0} and
\texttt{1} . A sorted binary string is a binary string such that all
characters \texttt{0} come before all characters \texttt{1} .

Input

The first line contains a single integer t (1 \leq t \leq 500 ) — the number
of test cases.

The only line of each test case contains a single string s (1 \leq |s| \leq
500 ) consisting of characters \texttt{0} and \texttt{1} , where |s| denotes
the length of the string s .

Output

For each test case, output a single integer — the minimum number of pieces
needed to be able to rearrange the string into a sorted binary string.

Example

Input

    6
    
    11010
    
    00000000
    
    1
    
    10
    
    0001111
    
    0110

Output

    3
    1
    1
    2
    1
    2
    
Note

The first test case is pictured in the statement. It can be proven that you
can't use fewer than 3 pieces.

In the second and third test cases, the binary string is already sorted, so
only 1 piece is needed.

In the fourth test case, you need to make a single cut between the two
characters and rearrange them to make the string \texttt{01} .","t=int(input())
for i in range(t):
    s=input()
    count=1
    flag=False
    j=0
    while j<len(s)-1:
        if s[j]!=s[j+1]:
            count+=1
            if s[j]=='0' and s[j+1]=='1':
                flag=True
        j+=1
    if flag:
        count-=1
    print(count)",1,True,True,True,False,False,True,True,True,True,False,True,False,True,False
1955_A,1955_A_abood718_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The price of one yogurt at the ""Vosmiorochka"" store is a burles, but there is
a promotion where you can buy two yogurts for b burles.

Maxim needs to buy exactly n yogurts. When buying two yogurts, he can choose
to buy them at the regular price or at the promotion price.

What is the minimum amount of burles Maxim should spend to buy n yogurts?

Input

The first line contains a single integer t (1 \le t \le {10}^{4} ) — the
number of test cases.

The first and only line of each test case contains three integers n , a , and
b (1 \le n \le 100 , 1 \le a, b \le 30 ) — the number of yogurts Maxim wants
to buy, the price for one yogurt, and the price for two yogurts on promotion.

Output

For each test case, print in a separate line the minimum cost of buying n
yogurts at ""Vosmiorochka"".

Example

Input

    4
    
    2 5 9
    
    3 5 9
    
    3 5 11
    
    4 5 11

Output

    9
    14
    15
    20
    
Note

In the third test case of the example, it is more advantageous to buy three
yogurts for 15 burles than two for 11 and one for 5 .

In the fourth test case of the example, you need to buy four yogurts, each for
5 burles.","for i in range(int(input())):
    A, B, C = map(int,input().split())
    if (B *2) < C:
        print(A*B)
    else:
        if A % 2 == 0:
            print(int((A * C)/2))
        else:
            X = A // 2
            print((X * C) + B)",1,True,False,False,True,False,True,False,True,True,True,True,False,False,False
1929_B,1929_B_KortVick_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a
drawing and attract her attention.

As a drawing, he decided to draw a square grid of size n \times n , in which
some cells are colored. But coloring the cells is difficult, so he wants to
color as few cells as possible. But at the same time, he wants at least k
diagonals to have at least one colored cell. Note that the square grid of size
n \times n has a total of 4n - 2 diagonals.

Help little Sasha to make the girl fall in love with him and tell him the
minimum number of cells he needs to color.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 1000 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (2 \leq n \leq
10^8 , 1 \leq k \leq 4n - 2 ) — the size of the square grid and the minimum
number of diagonals in which there should be at least one colored cell.

Output

For each test case, output a single integer — the minimum number of cells that
need to be colored.

Example

Input

    7
    
    3 4
    
    3 3
    
    3 10
    
    3 9
    
    4 7
    
    7 11
    
    2 3

Output

    2
    2
    6
    5
    4
    6
    2
    
Note

In the pictures below, the colored cells are marked in black, and all
diagonals are marked in purple.

In the first test case, you can color 2 cells so that 4 diagonals contain at
least one colored cell:

![](https://espresso.codeforces.com/c88e80de5be4f91764dbe5bdc534c50fec115db3.png)

In the third test case, you can color 6 cells so that all 10 diagonals contain
at least one colored cell:

![](https://espresso.codeforces.com/624a36083689f6fb20bf243e5d1707fdcd71ef60.png)","from math import ceil
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if 4 * n - 2 == k:
        print(k // 2 + 1)
    else:
        print(ceil(k / 2))",1,True,False,False,False,False,False,True,False,False,False,False,False,False,False
1919_A,1919_A_vjudge.9_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob are bored, so they decide to play a game with their wallets.
Alice has a coins in her wallet, while Bob has b coins in his wallet.

Both players take turns playing, with Alice making the first move. In each
turn, the player will perform the following steps in order:

  1. Choose to exchange wallets with their opponent, or to keep their current wallets. 
  2. Remove 1 coin from the player's current wallet. The current wallet cannot have 0 coins before performing this step. 

The player who cannot make a valid move on their turn loses. If both Alice and
Bob play optimally, determine who will win the game.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers a and b (1 \le
a, b \le 10^9 ) — the number of coins in Alice's and Bob's wallets,
respectively.

Output

For each test case, output ""Alice"" if Alice will win the game, and ""Bob"" if
Bob will win the game.

Example

Input

    10
    
    1 1
    
    1 4
    
    5 3
    
    4 5
    
    11 9
    
    83 91
    
    1032 9307
    
    839204 7281
    
    1000000000 1000000000
    
    53110 2024

Output

    Bob
    Alice
    Bob
    Alice
    Bob
    Bob
    Alice
    Alice
    Bob
    Bob
    
Note

In the first test case, an example of the game is shown below:

  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=1 . 
  * Since Alice's wallet is empty, Bob must choose to not swap their wallets in step 1 of his move. Now, a=0 and b=0 . 
  * Since both Alice's and Bob's wallets are empty, Alice is unable to make a move. Hence, Bob wins. 

In the second test case, an example of the game is shown below:

  * Alice chooses to swap wallets with Bob in step 1 of her move. Now, a=3 and b=1 . 
  * Bob chooses to swap wallets with Alice in step 1 of his move. Now, a=1 and b=2 . 
  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=2 . 
  * Since Alice's wallet is empty, Bob can only choose to not swap wallets with Alice in step 1 of his move. Now, a=0 and b=1 . 
  * Since Alice's wallet is empty, Alice can only choose to swap wallets with Bob in step 1 of her move. Now, a=0 and b=0 . 
  * Since both Alice's wallet and Bob's wallet are empty, Bob is unable to make a move. Hence, Alice wins.","def determine_winner(a, b):
    # If the sum of coins is odd, Alice wins, because she can always force Bob
    # to face an empty wallet scenario first due to having the first move advantage.
    # For an even sum, Bob wins, by following Alice's strategy and ensuring
    # that Alice faces the empty wallet scenario first.
    if (a + b) % 2 == 0:
        return ""Bob""
    else:
        return ""Alice""
 
def main():
    t = int(input(""Enter the number of test cases: ""))  # Read the number of test cases
    
    results = []
    
    for _ in range(t):
        a, b = map(int, input().strip().split())  # Read the number of coins in Alice's and Bob's wallets
        winner = determine_winner(a, b)
        results.append(winner)
    
    for result in results:
        print(result)
 
if __name__ == ""__main__"":
    main()",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True
1980_A,1980_A_j64._25.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Vlad is planning to hold m rounds next month. Each round should contain one
problem of difficulty levels 'A', 'B', 'C', 'D', 'E', 'F', and 'G'.

Vlad already has a bank of n problems, where the i -th problem has a
difficulty level of a_i . There may not be enough of these problems, so he may
have to come up with a few more problems.

Vlad wants to come up with as few problems as possible, so he asks you to find
the minimum number of problems he needs to come up with in order to hold m
rounds.

For example, if m=1 , n = 10 , a= 'BGECDCBDED', then he needs to come up with
two problems: one of difficulty level 'A' and one of difficulty level 'F'.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

The first line of each test case contains two integers n and m (1 \le n \le 50
, 1 \le m \le 5 ) — the number of problems in the bank and the number of
upcoming rounds, respectively.

The second line of each test case contains a string a of n characters from 'A'
to 'G' — the difficulties of the problems in the bank.

Output

For each test case, output a single integer — the minimum number of problems
that need to come up with to hold m rounds.

Example

Input

    3
    
    10 1
    
    BGECDCBDED
    
    10 2
    
    BGECDCBDED
    
    9 1
    
    BBCDEFFGG

Output

    2
    5
    1","def min_problems_to_create(t, test_cases):
    """"""
    Calculate the minimum number of problems Vlad needs to create.
 
    Args:
        t (int): Number of test cases.
        test_cases (list): List of test cases, where each test case is a tuple containing
            - n (int): Number of problems in the bank.
            - m (int): Number of upcoming rounds.
            - a (str): String of problem difficulties.
 
    Returns:
        list: List of results, one for each test case.
    """"""
 
    results = []
 
    for _ in range(t):
        n, m, a = test_cases[_]
 
        # Initialize frequency array
        freq = [0] * 7
 
        # Count frequency of each type of problem
        for prob in a:
            freq[ord(prob) - ord('A')] += 1
 
        # Calculate missing problems
        missing = sum(max(0, m - f) for f in freq)
 
        results.append(missing)
 
    return results
 
 
# Example usage
t = 3
test_cases = [
    (10, 1, ""BGECDCBDED""),
    (10, 2, ""BGECDCBDED""),
    (9, 1, ""BBCDEFFGG"")
]
 
results = min_problems_to_create(t, test_cases)
for result in results:
    print(result)",1,False,True,False,True,False,True,True,False,True,False,False,True,True,True
1927_B,1927_B_Rylin31_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Polycarp lost the string s of length n consisting of lowercase Latin letters,
but he still has its trace.

The trace of the string s is an array a of n integers, where a_i is the number
of such indices j (j < i ) that s_i=s_j . For example, the trace of the string
abracadabra is the array [0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 4 ].

Given a trace of a string, find any string s from which it could have been
obtained. The string s should consist only of lowercase Latin letters a-z.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the length of the lost string.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i < n ) — the trace of the string. It is guaranteed that for the given
trace, there exists a suitable string s .

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a string s that corresponds to the given trace. If
there are multiple such strings s , then output any of them.

The string s should consist of lowercase Latin letters a-z.

It is guaranteed that for each test case, a valid answer exists.

Example

Input

    5
    
    11
    
    0 0 0 1 0 2 0 3 1 1 4
    
    10
    
    0 0 0 0 0 1 0 1 1 0
    
    1
    
    0
    
    8
    
    0 1 2 3 4 5 6 7
    
    8
    
    0 0 0 0 0 0 0 0

Output

    abracadabra
    codeforces
    a
    aaaaaaaa
    dijkstra","for i in range(int(input())):
  l=int(input())
  array=list(map(int,input().split()))
  alp=[""a"",""b"",""c"",""d"",""e"",""f"",""g"",""h"",""i"",""j"",""k"",""l"",""m"",""n"",""o"",""p"",""q"",""r"",""s"",""t"",""u"",""v"",""w"",""x"",""y"",""z""]
  rev_array=array[::-1]
  ans=[]
  for j in range(l):
    ans.append(alp[rev_array[j::].count(rev_array[j])-1])
  print("""".join(map(str,ans)))",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1970_A1,1970_A1_Tapaswikodali_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"A parentheses sequence is a string consisting of characters ""("" and "")"", for
example ""(()(("".

A balanced parentheses sequence is a parentheses sequence which can become a
valid mathematical expression after inserting numbers and operations into it,
for example ""(()(()))"".

The balance of a parentheses sequence is defined as the number of opening
parentheses ""("" minus the number of closing parentheses "")"". For example, the
balance of the sequence ""(()(("" is 3.

A balanced parentheses sequence can also be defined as a parentheses sequence
with balance 0 such that each of its prefixes has a non-negative balance.

We define the balanced shuffle operation that takes a parentheses sequence and
returns a parentheses sequence as follows: first, for every character of the
input sequence, we compute the balance of the prefix of the sequence before
that character and write those down in a table together with the positions of
the characters in the input sequence, for example:

Prefix balance| 0| 1| 2| 1| 2| 3| 2| 1  
---|---|---|---|---|---|---|---|---  
Position| 1| 2| 3| 4| 5| 6| 7| 8  
Character| (| (| )| (| (| )| )| )  
  
Then, we sort the columns of this table in increasing order of prefix balance,
breaking ties in decreasing order of position. In the above example, we get:

Prefix balance| 0| 1| 1| 1| 2| 2| 2| 3  
---|---|---|---|---|---|---|---|---  
Position| 1| 8| 4| 2| 7| 5| 3| 6  
Character| (| )| (| (| )| (| )| )  
  
The last row of this table forms another parentheses sequence, in this case
""()(()())"". This sequence is called the result of applying the balanced
shuffle operation to the input sequence, or in short just the balanced shuffle
of the input sequence.

You are given a balanced parentheses sequence. Print its balanced shuffle.

Input

The only line of input contains a string s consisting only of characters ""(""
and "")"". This string is guaranteed to be a non-empty balanced parentheses
sequence with its length not exceeding 500\,000 .

Output

Print the parentheses sequence t — the balanced shuffle of s .

Example

Input

    (()(()))
    
Output

    ()(()())","class BalanceInfo:
    def __init__(self, balance, position, character):
        self.balance = balance
        self.position = position
        self.character = character
def compare(infoA, infoB):
    if infoA.balance != infoB.balance:
        return infoA.balance - infoB.balance
    return infoB.position - infoA.position
def balanced_shuffle(s):
    n = len(s)
    balance_info = []
    balance = 0
    for i in range(n):
        balance_info.append(BalanceInfo(balance, i, s[i]))
        if s[i] == '(':
            balance += 1
        else:
            balance -= 1
    balance_info.sort(key=lambda x: (x.balance, -x.position))
    result = ''.join(info.character for info in balance_info)
    print(result)
if __name__ == ""__main__"":
    s = input().strip()  
    balanced_shuffle(s)",1,True,True,True,True,True,True,True,True,True,True,True,True,False,True
1948_C,1948_C_saurabh_k1_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a grid, consisting of 2 rows and n columns. The rows are numbered
from 1 to 2 from top to bottom. The columns are numbered from 1 to n from left
to right. Each cell of the grid contains an arrow pointing either to the left
or to the right. No arrow points outside the grid.

There is a robot that starts in a cell (1, 1) . Every second, the following
two actions happen one after another:

  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); 
  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). 

Your task is to determine whether the robot can reach the cell (2, n) .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer (2 \le n \le 2
\cdot 10^5 ).

The second line contains a string consisting of exactly n characters < and/or
> — the first row of the grid.

The third line contains a string consisting of exactly n characters < and/or >
— the second row of the grid.

Additional constraints on the input:

  * n is even; 
  * there are no arrows pointing outside the grid; 
  * the sum of n over all test cases doesn't exceed 2 \cdot 10^5 . 

Output

For each test case, print YES if the robot can reach the cell (2, n) ;
otherwise, print NO.

You can print each letter in any case. For example, yes, Yes, YeS will all be
recognized as positive answer.

Example

Input

    4
    
    4
    
    >><<
    
    >>><
    
    2
    
    ><
    
    ><
    
    4
    
    >>><
    
    >><<
    
    6
    
    >><<><
    
    ><>>><

Output

    YES
    YES
    NO
    YES
    
Note

In the first example, one of the possible paths looks as follows: (1, 1)
\rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 4) .

In the second example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) .

In the third example, there is no way to reach the cell (2, 4) .

In the fourth example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (1, 2) \rightarrow (1, 3)
\rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (2, 5) \rightarrow (2, 6) .","t = int(input())
for _ in range(t):
    n = int(input())
    a = input()
    b = input()
    for  i in range(1 ,n ,2):
        if (i+1<n and a[i]== b[i+1] == ""<"") or (a[i] == b[i-1] == ""<"")  :
            print(""No"")
            break
    else:
        print(""yes"")",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1965_B,1965_B_NS3081992_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two integers n and k . Find a sequence a of non-negative
integers of size at most 25 such that the following conditions hold.

  * There is no subsequence of a with a sum of k . 
  * For all 1 \le v \le n where v \ne k , there is a subsequence of a with a sum of v . 

A sequence b is a subsequence of a if b can be obtained from a by the deletion
of several (possibly, zero or all) elements, without changing the order of the
remaining elements. For example, [5, 2, 3] is a subsequence of [1, 5, 7, 8, 2,
4, 3] .

It can be shown that under the given constraints, a solution always exists.

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. The description of the test cases follows.

Each test case consists of a single line containing two integers n and k (2
\le n \le 10^6 , 1 \le k \le n ) — the parameters described above.

It is guaranteed that the sum of n over all test cases does not exceed 10^7 .

Output

The first line of output for each test case should contain a single integer m
(1 \le m \le 25 ) — the size of your chosen sequence.

The second line of output for each test case should contain m integers a_i (0
\le a_i \le 10^9 ) — the elements of your chosen sequence.

If there are multiple solutions, print any.

Example

Input

    5
    
    2 2
    
    6 1
    
    8 8
    
    9 3
    
    10 7

Output

    1
    1
    5
    2 3 4 5 6
    7
    1 1 1 1 1 1 1
    4
    7 1 4 1
    4
    1 2 8 3
    
Note

In the first example, we just need a subsequence that adds up to 1 , but not
one that adds up to 2 . So the array a=[1] suffices.

In the second example, all elements are greater than k=1 , so no subsequence
adds up to 1 . Every other integer between 1 and n is present in the array, so
there is a subsequence of size 1 adding up to each of those numbers.","# import random
# import itertools
# from sys import stdin, stdout
# import operator
# import collections
import bisect
import collections
import heapq
import math
import sys
from sys import maxsize
# from decimal import Decimal
 
#sys.setrecursionlimit(10**6)
 
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()
 
 
# mod = 998244353
# fval = [1]
# for i in range(1,1002):
#     x = (fval[-1]*i)%mod
#     fval.append(x)
# #
# ifac = [1]*(1002)
# ifac[1001] = pow(fval[1001], -1, mod)
# for i in range(1001-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%mod
# print(fval)
# print(ifac)
# _________________ For taking Input from the Text Files __________________
# import os.path
#
# if (os.path.exists('input.txt')):
#     sys.stdin = open(""input.txt"", ""r"")
#     sys.stdout = open(""output.txt"", ""w"")
#     sys.stderr = open(""error.txt"", ""w"")
 
def drank(d, processing, da, rank):
    tmp = 10 ** 9
    if len(d[da]) == 1:
        return 1
    for di in d[da]:
        if processing[di - 1] == 0:
            processing[di - 1] = 1
            tmp = min(tmp, drank(d, processing, di, rank))
            processing[di - 1] = 0
    rank[da - 1] = tmp + 1
    return tmp + 1
 
# def primeFactors(n, d):
#     if (n % 2 == 0):
#         d[2] = 0
#     while n % 2 == 0:
#         d[2] += 1
#         n = n // 2
#     for i in range(3, int(math.sqrt(n)) + 1, 2):
#         if (n % i == 0):
#             d[i] = 0
#         while n % i == 0:
#             d[i] += 1
#             n = n // i
#     if n > 2:
#         d[n] = 1
# def powerofadivisor(n,div):
#     x = 0
#     while n%div == 0:
#         n//=div
#         x+=1
#     return x
 
#import heapq as hq
#import math
 
def gcd(a,b):
    if b==0:
        x = 1
        y = 0
        return x, y, a
    x, y, g = gcd(b, a%b)
    return y, x- (a//b)*y, g
 
# mod = 998244353
#
# is_prime = [True]*(10**7+5)
# primes = []
# def primeseive(n):
#     is_prime[0] = is_prime[1] = False
#     for i in range(4,n+1,2): is_prime[i] = False
#     i = 3
#     while i*i<=n:
#         if is_prime[i] == True:
#             for j in range(i*i,n+1,i):
#                 is_prime[j] = False
#         i+=2
    # for i in range(n):
    #     if is_prime[i]: primes.append(i)
import heapq
 
def solve():
    n, k = li()
    b = bin(n)[2:]
    l = len(b)
    if k == 1:
        if n == 2: return ""1\n2""
        ans = [2, 3]
        for i in range(2,l):
            ans.append(2**i)
    else:
        bk = bin(k)[2:]
        ans = []
        lk = len(bk)
        for i in range(lk-1):
            ans.append(2**i)
        ans.append(k-1-sum(ans))
        ans.append(k+1)
        ans.append(2*k+1)
        for i in range(lk, l):
            ans.append(2**i)
    return ' '.join(map(str, ans))
 
 
 
 
def main():
    # primeseive(10**7+2)
    # print(is_prime)
    for _ in range(ii()):
        sys.stdout.write(str(solve()) + ""\n"")
        #solve()
        # si()
        #print(""? {} {}"".format(low, mid), flush=True)
        # print(solve(), flush=True)
    # print(solve())
 
    #     z += str(ans) + '\n'
    # print(len(ans), ' '.join(map(str, ans)), sep='\n')
    # stdout.write(z)
 
 
# for interactive problems
# print(""? {} {}"".format(l,m), flush=True)
# or print this after each print statement
# sys.stdout.flush()
 
 
if __name__ == ""__main__"":
    main()",1,False,True,False,True,True,True,True,True,False,False,False,True,True,True
