Correctness: **False**

The provided Python program contains several logical errors and issues that prevent it from correctly solving the problem as described. Here are the main issues:

1. **Incorrect Handling of Quaffle Ownership**:
   - The line `quidditch[1] == mo[0]` is a comparison, not an assignment. It should be `quidditch[1] = mo[0]` to correctly assign the player who catches the Quaffle.

2. **Incorrect Logic for Throwing the Quaffle**:
   - The program does not correctly handle the logic for throwing the Quaffle. Specifically, the lines:
     ```python
     if players[mo[0]] in goals['R']:
         pointsb += 1
         print(i, 'BLUE GOAL')
         if mo[0][0] == 'R':
             quidditch[0] = middle
         else:
             quidditch[0] = players[mo[0]]
     if players[mo[0]] in goals['B']:
         pointsr += 1
         print(i, 'RED GOAL')
         if mo[0][0] == 'B':
             quidditch[0] = middle
         else:
             quidditch[0] = players[mo[0]]
     ```
     - There are two `if` statements, which means both conditions could be true if the Quaffle is in both goals (which is impossible, but the logic is flawed). It should be an `if-elif` structure.
     - The Quaffle should always be moved to the middle after a goal is scored, regardless of which team scored. The current logic incorrectly places the Quaffle at the player's position if the player's team matches the goal's team.

3. **Incorrect Handling of Eliminations**:
   - The program correctly identifies players to be eliminated, but it incorrectly handles the Quaffle's position if the eliminated player was carrying it. The Quaffle should be left at the cell where the player and Bludger were, but the current logic incorrectly assigns the Quaffle's position to the player's last position.

4. **Incorrect Goal Scoring Check**:
   - The program checks if a player's position is in the goals list, but it should check if the Quaffle is at a goal after a player throws it.

5. **Incorrect Final Score Printing**:
   - The final score is printed with the scores in the wrong order. It should be `print('FINAL SCORE:', pointsr, pointsb)` but the program prints `print('FINAL SCORE:', pointsr, pointsb)` which is correct, but the logic leading to this point is flawed.

Here is a corrected version of the program addressing these issues:

```python
(n, m) = [int(x) for x in input().split()]
players = dict()
goals = {'B': [], 'R': []}
mouvements = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}
middle = ((m + 1) // 2, (n + 1) // 2)
quidditch = [middle, '']
(pointsb, pointsr) = (0, 0)
for y in range(n):
    s = input().split()
    for x in range(m):
        if s[x] == '..':
            continue
        elif s[x] == '.Q':
            quidditch[0] = (x, y)
        elif s[x] == 'RG':
            goals['R'].append((x, y))
        elif s[x] == 'BG':
            goals['B'].append((x, y))
        else:
            players[s[x]] = (x, y)
moves = int(input())
for i in range(moves):
    mo = input().split()
    if mo[0] == '.Q':
        quidditch[0] = func_1(quidditch[0], mouvements[mo[1]])
    elif mo[1] in 'ULDR':
        players[mo[0]] = func_1(players[mo[0]], mouvements[mo[1]])
        if '.B' in players:
            elimines = []
            for (k, v) in players.items():
                if k != '.B' and v == players['.B']:
                    elimines.append(k)
            elimines.sort()
            for c in elimines:
                print(i, c, 'ELIMINATED')
                if quidditch[1] == c:
                    quidditch[0] = players[c]
                del players[c]
    elif mo[1] == 'C':
        quidditch[1] = mo[0]
    elif mo[1] == 'T':
        quidditch[1] = ''
        if quidditch[0] in goals['R']:
            if mo[0][0] == 'B':
                pointsb += 1
                print(i, 'BLUE GOAL')
            else:
                pointsr += 1
                print(i, 'RED GOAL')
            quidditch[0] = middle
        elif quidditch[0] in goals['B']:
            if mo[0][0] == 'R':
                pointsr += 1
                print(i, 'RED GOAL')
            else:
                pointsb += 1
                print(i, 'BLUE GOAL')
            quidditch[0] = middle
print('FINAL SCORE:', pointsr, pointsb)

def func_1(a, b):
    (x, y) = a
    (dx, dy) = b
    return (x + dx, y + dy)
```

This corrected version should now correctly handle the game logic as described in the problem statement.