### Reasoning:

1. **Input Handling**: The program uses `func_10()` to read the number of test cases `t`, and for each test case, it reads the integers `n` and `k` using `func_7()`. This part of the program is correctly handling the input as specified.

2. **Main Logic**: The main logic resides in `func_14()`. The function is supposed to generate a sequence `a` of non-negative integers such that:
   - There is no subsequence of `a` with a sum of `k`.
   - For all `1 ≤ v ≤ n` where `v ≠ k`, there is a subsequence of `a` with a sum of `v`.

3. **Special Case for `k = 1`**:
   - If `k = 1`, the function checks if `n = 2`. If so, it returns the sequence `[2]`, which satisfies the conditions.
   - Otherwise, it constructs a sequence starting with `2, 3`, followed by powers of `2` up to `2^(l-1)`, where `l` is the length of the binary representation of `n`. This sequence ensures that all sums up to `n` except `1` can be formed, as the smallest number in the sequence is `2`.

4. **General Case for `k ≠ 1`**:
   - The function constructs a sequence starting with powers of `2` up to `2^(lk-2)`, where `lk` is the length of the binary representation of `k`.
   - It then appends `k - 1 - sum(ans)`, `k + 1`, `2 * k + 1`, and continues with powers of `2` from `2^(lk)` to `2^(l-1)`. This ensures that all sums up to `n` except `k` can be formed.
   - The sequence also ensures that no subsequence sums to `k` by including `k - 1 - sum(ans)` and `k + 1` which are strategically placed to prevent a subsequence from summing to `k`.

5. **Output Handling**: The function `func_15()` iterates over the number of test cases, calls `func_14()` for each, and writes the result to the standard output.

### Conclusion:
The provided code correctly implements the logic to generate the required sequence for each test case based on the given constraints. It handles the special case when `k = 1` and the general case when `k ≠ 1` appropriately. Therefore, the program meets the problem description.

### Correctness:
Correctness: **True**