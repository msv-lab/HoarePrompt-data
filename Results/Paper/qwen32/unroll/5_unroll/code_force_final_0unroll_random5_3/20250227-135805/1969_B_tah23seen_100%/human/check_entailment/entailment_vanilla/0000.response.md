Let's analyze the given problem and the provided solution step-by-step to determine if the program is correct.

### Problem Analysis
The problem is to cyclically shift substrings of a binary string to sort it in non-descending order (i.e., all 0s followed by all 1s) with the minimum total cost. The cost of shifting a substring of length `r - l + 1` is `r - l + 1`.

### Solution Analysis
The provided solution uses a function `func_1` to calculate the minimum cost. Let's break down the logic:

1. **Initialization**:
   - `cost` is initialized to 0. This variable will store the total cost.
   - `one` is initialized to 0. This variable counts the number of '1's encountered so far.

2. **Iterating through the string**:
   - For each character `i` in the string `s`:
     - If `i` is '1', increment the `one` counter.
     - If `i` is '0' and `one` is greater than 0, it means we have encountered a '0' after some '1's. This indicates that we need to move these '1's before the '0' to sort the string. The cost to move these '1's is the length of the substring containing these '1's plus the '0', which is `one + 1`. This cost is added to the total `cost`.

3. **Returning the cost**:
   - The function returns the total `cost` after processing the entire string.

### Correctness of the Solution
The logic in `func_1` is based on the observation that whenever a '0' is encountered after some '1's, the cost to sort the substring containing these '1's and the '0' is `one + 1`. This is because we need to perform a cyclic shift of the substring to move all '1's before the '0'. The solution correctly accumulates this cost for each such occurrence.

However, there is a subtle issue with the provided code. The problem statement specifies that the input string consists of only '0's and '1's, and the solution assumes this correctly. But the logic in `func_1` does not handle cases where the string starts with '0's or is already sorted (all '0's or all '1's), which would result in a cost of 0. The provided solution correctly handles these cases as well because the cost is only added when a '0' is encountered after some '1's.

### Conclusion
The provided solution correctly calculates the minimum cost to sort the binary string using the described operations. Therefore, the program is correct.

Reasoning: The solution correctly calculates the minimum cost by identifying the points where a '0' follows one or more '1's and adding the appropriate cost for each such occurrence.
Correctness: **True**