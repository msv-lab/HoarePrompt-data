### Reasoning:

Let's analyze the given code and compare it against the problem description to ensure correctness.

1. **Input Reading:**
   - `func_1()` reads a single integer from the input, which represents the number of test cases.
   - `func_2()` reads a line of space-separated integers and returns them as a map object of integers.

2. **Processing Each Test Case:**
   - For each test case, the code initializes several variables:
     - `n`: Number of items.
     - `k`: Number of items Bob can take for free.
     - `prices`: List of prices for Alice.
     - `neg_prices`: List of negative prices for Alice (used for the heap).
     - `bonuses`: List of prices for Bob.
     - `combined`: A list of tuples combining `neg_prices` and `bonuses`, sorted by the bonus values.
     - `heap`: A min-heap used to keep track of the items Bob can take for free.
     - `max_profit` and `current_profit`: Variables to keep track of the maximum and current profit, respectively.

3. **Heap Initialization:**
   - The first `k` items (based on sorted `combined` list) are pushed into the heap. This ensures that Bob can take these items for free.

4. **Calculating Initial Profit:**
   - If there are any items left in `combined` after pushing `k` items into the heap, `func_3()` is called to calculate the initial profit. This function sums up the prices of items in `secondary_heap` and adds the sum of prices for items in `primary_items` where the sum of the two prices in the tuple is non-negative.

5. **Iterative Profit Calculation:**
   - The code iterates through the remaining items in `combined`:
     - It updates the `current_profit` based on whether the sum of the item's prices is non-negative.
     - It pushes the current item into the heap and pops the smallest item from the heap, updating the `current_profit` accordingly.
     - It checks if the updated `current_profit` is greater than `max_profit` and updates `max_profit` if necessary.

6. **Output:**
   - After processing all items for a test case, the code prints the `max_profit`.

### Analysis:

- **Heap Usage:** The use of a heap ensures that Bob always takes the least profitable items for free, minimizing Alice's loss.
- **Profit Calculation:** The logic correctly calculates the profit by considering the prices Alice pays and the bonuses Bob provides.
- **Edge Cases:** The code handles edge cases such as when `k` is 0 (Bob takes no items for free) and when `k` equals `n` (Bob takes all items for free).

### Conclusion:

The provided code correctly implements the logic required to solve the problem as described. It efficiently handles the constraints and calculates the optimal profit for Alice.

**Correctness: True**