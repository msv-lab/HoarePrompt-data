### Reasoning:

Let's break down the logic of the provided program and compare it with the requirements of the problem statement.

1. **Reading Input:**
   - The program correctly reads the number of test cases.
   - For each test case, it reads the values of `n` and `m`.
   - It then reads the array `a` of `n` integers.
   - Finally, it reads the string `s` of length `n`.

2. **Constructing List `b`:**
   - The program constructs a list `b` by iterating through the string `s`.
   - If the command is 'L', it appends the leftmost element of `a` to `b` and increments the left pointer `l`.
   - If the command is 'R', it appends the rightmost element of `a` to `b` and decrements the right pointer `r`.
   - This part of the program seems to be working correctly as per the problem statement.

3. **Computing Cumulative Products:**
   - The program initializes an empty list `ans` and a variable `p` to 1.
   - It then iterates through the list `b` in reverse order.
   - For each element `v` in `b`, it updates `p` to `(p * v) % m` and appends `p` to `ans`.
   - This step is also correct because it computes the product of elements in `b` taken modulo `m` and stores these results in `ans`.

4. **Returning Results:**
   - The program returns the list `ans` in reverse order.
   - This is necessary because the problem requires the remainders to be printed in the order they were computed before removing elements from `a`.

### Issues Identified:
- The main issue lies in the way the product is computed and stored. The program is appending the elements of `a` directly to `b` based on the commands, but it should be computing the product of all elements in `a` at each step before removing any elements.
- The current implementation only considers the elements that are selected based on the commands, not the entire array `a` at each step.

### Correct Implementation:
To fix the program, we need to compute the product of all elements in `a` at each step before removing any elements based on the commands. Here is the corrected version of the function:

```python
def func_1(n, m, a, s):
    ans = []
    product = 1
    for num in a:
        product = (product * num) % m
    l = 0
    r = n - 1
    for i in range(n):
        ans.append(product)
        if s[i] == 'L':
            product = (product * pow(a[l], m - 2, m)) % m  # Remove the leftmost element
            l += 1
        else:
            product = (product * pow(a[r], m - 2, m)) % m  # Remove the rightmost element
            r -= 1
    return ans
```

However, the above code uses modular inverse which is computationally expensive and unnecessary for this problem. A simpler approach would be to recompute the product after each removal, which is more straightforward but less efficient for large arrays.

Given the original code does not meet the problem requirements, the correctness is:

### Correctness: **False**