Let's analyze the provided Python program to see if it correctly solves the problem.

The program reads multiple test cases, where each test case consists of three integers: `n` (the number of yogurts Maxim wants to buy), `a` (the price for one yogurt), and `b` (the price for two yogurts on promotion). The goal is to calculate the minimum cost for buying exactly `n` yogurts.

Here's a step-by-step breakdown of the logic in the program:

1. **Reading Input**: The program correctly reads the number of test cases and then iterates over each test case.
2. **Condition Check**: For each test case, the program checks if the price of two yogurts bought individually (`a * 2`) is less than the promotion price (`b`). If true, it calculates the total cost as `n * a` because buying them individually is cheaper.
3. **Even Number of Yogurts**: If `n` is even, the program calculates the total cost as `(n / 2) * b` because buying pairs of yogurts at the promotion price is cheaper.
4. **Odd Number of Yogurts**: If `n` is odd, the program calculates the total cost as `(n // 2) * b + a`. This means buying as many pairs as possible at the promotion price and paying the individual price for the remaining yogurt.

Now, let's verify if this logic covers all scenarios correctly:

- If `a * 2 < b`, buying yogurts individually is always cheaper, so the program correctly returns `n * a`.
- If `n` is even and `a * 2 >= b`, buying pairs of yogurts at the promotion price is cheaper, so the program correctly returns `(n / 2) * b`.
- If `n` is odd and `a * 2 >= b`, buying as many pairs as possible at the promotion price and paying the individual price for the remaining yogurt is the optimal strategy, which the program correctly implements.

The program handles all edge cases, including when `n` is 1, and when the promotion price is not beneficial.

Thus, the program is correct.

Correctness: **True**