### Reasoning:

The provided code attempts to solve the problem by iterating through each possible position to place the road and checking whether the conditions are met for both sides of the road. However, there are several issues with the code that need to be addressed:

1. **Incorrect Calculation of `pk`:**
   - The variable `pk` is calculated as `n / 2`, but it should be `n // 2` because we need integer division to get the midpoint index correctly.

2. **Percentage Calculation:**
   - The code calculates `zero_perc` and `one_perc` using integer division (`//`) and multiplies by 100 to get percentages. This approach is unnecessary and can lead to incorrect results due to rounding issues. Instead, the code should directly compare counts with their respective thresholds.

3. **Threshold Comparison:**
   - The conditions `zero_perc >= 50` and `one_perc >= 50` are used to check if at least half of the residents on each side are satisfied. However, these conditions do not correctly implement the ceiling function required by the problem statement. Instead, the code should use direct count comparisons with the ceiling values of `i / 2` and `(n - i) / 2`.

4. **Handling Edge Cases:**
   - The code checks if `len(final) == 0` and then decides whether to append `0` or `n` based on the overall satisfaction of residents. However, this logic is flawed because it does not account for the possibility of placing the road between the first and last house correctly.

5. **Optimization:**
   - The code could be optimized by avoiding unnecessary calculations and sorting operations. Specifically, it can keep track of the minimum distance and the corresponding index during the first pass through the list.

### Correctness:

Given the above issues, the code is not correct as it stands. Therefore, the correctness of the given program is:

**Correctness: False**

### Suggested Fix:

Here is a corrected version of the code:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        
        zero, one = 0, 0
        total_zeros = s.count('0')
        total_ones = s.count('1')
        
        best_i = None
        min_diff = float('inf')
        
        for i in range(n + 1):  # Include the possibility of placing the road before the first house
            if i == 0:
                left_zeros = 0
                left_ones = 0
                right_zeros = total_zeros
                right_ones = total_ones
            else:
                if s[i - 1] == '0':
                    zero += 1
                else:
                    one += 1
                left_zeros = zero
                left_ones = one
                right_zeros = total_zeros - zero
                right_ones = total_ones - one
            
            if left_zeros >= (i + 1) // 2 and right_ones >= (n - i) // 2:
                diff = abs(i - n // 2)
                if diff < min_diff:
                    min_diff = diff
                    best_i = i
        
        print(best_i)

func()
```

This corrected version ensures that the conditions are checked correctly using integer arithmetic and handles edge cases appropriately.