Correctness: **False**

Explanation:

The provided program does not correctly solve the problem as described. Here are the issues:

1. **Incorrect Logic for Identifying Non-Beautiful Arrays**:
   - The program attempts to find the minimum number of elements to remove by counting the consecutive occurrences of the first element (`arr[0]`). This approach is flawed because it does not consider the overall structure of the array and the conditions for making it non-beautiful.
   - The problem requires that the array should not be able to be made beautiful by any sequence of operations. The program's logic only checks for the first element and does not handle other cases where the array might still be beautiful after removing elements.

2. **Handling of Edge Cases**:
   - The program correctly identifies that an array with all identical elements cannot be made non-beautiful (it prints `-1` in such cases). However, it fails to handle other edge cases and general cases correctly.

3. **Incorrect Use of `Decimal`**:
   - The use of `Decimal('Infinity')` is unnecessary and incorrect for this problem. The program should use a simple integer value like `float('inf')` or a large integer to represent infinity.

4. **Incorrect Calculation of Minimum Removals**:
   - The program's logic for calculating the minimum number of elements to remove is flawed. It only considers the first element and does not account for other elements that might be part of the pattern making the array beautiful.

To correctly solve the problem, a more sophisticated approach is needed. Here is a corrected version of the program:

```python
def min_elements_to_remove_to_stop_beautiful(n, arr):
    if n <= 2:
        return -1  # An array with 1 or 2 elements is always non-beautiful
    
    # Check if all elements are the same
    if len(set(arr)) == 1:
        return -1  # It's impossible to make it non-beautiful
    
    # Check if the array can be made non-beautiful by removing elements
    for i in range(1, n - 1):
        if arr[i] != arr[0] and arr[i] != arr[-1]:
            return 1  # Removing this element will make the array non-beautiful
    
    # If all elements are the same except the first and last, we need to remove more
    if arr[0] == arr[-1]:
        return 2  # Removing the first and last elements will make the array non-beautiful
    
    return -1  # If none of the above conditions are met, it's impossible to make it non-beautiful

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())
        arr = list(map(int, input().split()))
        print(min_elements_to_remove_to_stop_beautiful(n, arr))
```

This corrected version:
- Handles arrays of length 1 or 2 by returning `-1` immediately.
- Checks if all elements are the same and returns `-1` if they are.
- Checks if there is any element in the middle that is different from the first and last elements, and returns `1` if such an element exists.
- If the first and last elements are the same and all middle elements are different, it returns `2`.
- If none of the above conditions are met, it returns `-1`.

This approach ensures that the program correctly identifies the minimum number of elements to remove to make the array non-beautiful.