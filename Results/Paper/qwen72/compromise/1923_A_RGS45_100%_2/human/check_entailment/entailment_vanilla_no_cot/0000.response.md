Correctness: **True**

The provided Python program appears to correctly solve the problem based on the given description. Here's a breakdown of why:

1. **Input Handling**: The program reads the number of test cases `t` and then iterates over each test case. For each test case, it reads the number of cells `n` and the array of cell states `arr`.

2. **Finding the Range of Chips**: 
   - `x = arr.find('1')` finds the index of the first chip (1) from the left.
   - `y = arr[::-1].find('1')` finds the index of the first chip (1) from the right, but since the array is reversed, it effectively gives the number of trailing zeros.

3. **Extracting the Subarray of Chips**:
   - `z = arr[x:n - y]` extracts the subarray that contains all the chips, excluding leading and trailing zeros.

4. **Counting the Gaps**:
   - `print(z.count('0'))` counts the number of zeros (free cells) within the subarray of chips, which represents the minimum number of operations needed to move the chips into a single block.

This approach works because the number of operations required to form a single block of chips is equal to the number of free cells (0s) between the first and last chip in the array. The program correctly identifies this range and counts the free cells within it, which is the minimum number of moves needed.

Thus, the program is correct for the given problem.