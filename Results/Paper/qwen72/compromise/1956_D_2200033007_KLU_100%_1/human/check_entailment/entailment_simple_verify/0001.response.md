### Reasoning:

1. **Problem Understanding:**
   - The problem requires maximizing the sum of an array by performing operations that set a subarray to the MEX of that subarray.
   - The constraints are small (1 ≤ n ≤ 18), which allows for a more exhaustive approach.

2. **Function 1: `func_1(start_index, end_index)`**
   - This function is intended to compute the maximum possible sum of the subarray from `start_index` to `end_index`.
   - It uses dynamic programming to store results in `res_dict` to avoid redundant calculations.
   - The base case is when `start_index` equals `end_index`, where the maximum sum is the maximum of 1 and the element at that index. This is correct because the MEX of a single element is the smallest non-negative integer not in the set, which is either 0 or 1.
   - For larger subarrays, it recursively computes the maximum sum by considering different partitions and the MEX of the subarray. However, the MEX calculation is not explicitly shown in the code, which is a critical oversight.

3. **Function 2: `func_2(start_index, end_index)`**
   - This function constructs the sequence of operations that achieve the maximum sum computed by `func_1`.
   - It first computes the maximum value for the subarray using `func_1`.
   - If the subarray length is 1, it checks if the element is 0 and returns the corresponding operation. This is correct.
   - If the maximum value is equal to the square of the subarray length, it calls `make_stairs` to transform the subarray into a "staircase" and appends the operation to the result. This is intended to handle the case where the subarray can be transformed to maximize the sum, but the implementation of `make_stairs` is incorrect.
   - Otherwise, it recursively finds the partition that achieves the maximum value and constructs the operations for those partitions. This is correct in theory but relies on the correct implementation of MEX and `make_stairs`.

4. **Function 3: `make_stairs(i)`**
   - This function is intended to transform a subarray into a "staircase" where the elements are 0, 1, 2, ..., i.
   - The function checks if the subarray is already in the desired "staircase" form, which is a good idea.
   - However, the function does not correctly transform the subarray into the desired form. It sets all elements to `i` and recursively calls itself, which does not achieve the "staircase" transformation. The correct approach would be to set the elements to their respective MEX values in a way that forms the staircase.

5. **Global Variables:**
   - The use of global variables `arr` and `res` is problematic. It can lead to issues in function calls and state management.
   - It is better to pass these variables as arguments to the functions to ensure they are properly scoped and managed.

6. **MEX Calculation:**
   - The MEX calculation is not explicitly shown in the code. The function `func_1` and `func_2` assume that the MEX is correctly computed, but this is not clear from the provided code.
   - The MEX calculation should be implemented and used in the functions to ensure the correctness of the operations.

### Final Evaluation:

Given the issues with the MEX calculation and the incorrect implementation of the `make_stairs` function, the provided program is not correct. The dynamic programming approach in `func_1` and the recursive construction in `func_2` are on the right track, but they rely on a correct MEX calculation and a properly implemented `make_stairs` function, which are missing in the provided code.

Final: **False**