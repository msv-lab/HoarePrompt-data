Correctness: **False**

### Explanation:
The provided program does not correctly solve the problem. Here are the issues:

1. **Incorrect Logic for Finding Minimum Removals:**
   - The program attempts to find the minimum number of consecutive elements that are the same as the first element (`a[0]`). However, this approach is flawed because it does not consider the possibility of making the array non-beautiful by removing elements that are not necessarily consecutive or equal to the first element.
   - The problem requires finding the minimum number of elements to remove to make the array non-beautiful, which means breaking the condition where elements can be made the same by the given operation. The program does not handle this correctly.

2. **Handling of Single-Element Arrays:**
   - The program correctly handles the case where the array has only one unique element by printing `-1`. However, it does not handle other edge cases or more complex scenarios effectively.

3. **General Approach:**
   - The correct approach should involve checking if the array can be made non-beautiful by removing the minimum number of elements. This typically involves identifying patterns or sequences that can be broken by removing elements.

### Correct Approach:
To solve the problem correctly, you need to:
- Identify the longest subarray where the elements can be made the same using the given operation.
- Determine the minimum number of elements to remove to break this pattern and make the array non-beautiful.

Here is a corrected version of the program:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().strip().split()))
        
        # If all elements are the same, it's impossible to make the array non-beautiful
        if len(set(a)) == 1:
            print(-1)
            continue
        
        # Initialize the minimum number of removals to a large number
        min_removals = n
        
        # Check for the longest subarray where elements can be made the same
        for i in range(1, n - 1):
            if a[i - 1] == a[i + 1]:
                # Calculate the minimum number of removals needed to break this pattern
                left = i - 1
                right = i + 1
                while left >= 0 and right < n and a[left] == a[right]:
                    left -= 1
                    right += 1
                min_removals = min(min_removals, right - left - 1)
        
        # If no such subarray is found, the array is already non-beautiful
        if min_removals == n:
            print(0)
        else:
            print(min_removals)

func()
```

### Explanation of the Corrected Program:
- **Set Check:** If all elements in the array are the same, it is impossible to make the array non-beautiful, so we print `-1`.
- **Subarray Check:** We iterate through the array to find the longest subarray where the elements can be made the same using the given operation. For each valid index `i` (where `a[i-1] == a[i+1]`), we expand outwards to find the length of the subarray that can be made the same.
- **Minimum Removals:** We keep track of the minimum number of elements that need to be removed to break the pattern and make the array non-beautiful.
- **Output:** If no such subarray is found, the array is already non-beautiful, so we print `0`. Otherwise, we print the minimum number of removals.

This approach ensures that the program correctly identifies the minimum number of elements to remove to make the array non-beautiful.