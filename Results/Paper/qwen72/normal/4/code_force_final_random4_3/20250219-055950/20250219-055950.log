DEBUG - Start Task 1926_D_ayushdreams147_6.67%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1937_B_kaushik_yadav_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given a 2 \times n grid filled with zeros and ones. Let the number at
the intersection of the i -th row and the j -th column be a_{ij} .

There is a grasshopper at the top-left cell (1, 1) that can only jump one cell
right or downwards. It wants to reach the bottom-right cell (2, n) . Consider
the binary string of length n+1 consisting of numbers written in cells of the
path without changing their order.

Your goal is to:

  1. Find the lexicographically smallest^\dagger string you can attain by choosing any available path; 
  2. Find the number of paths that yield this lexicographically smallest string. 

^\dagger If two strings s and t have the same length, then s is
lexicographically smaller than t if and only if in the first position where s
and t differ, the string s has a smaller element than the corresponding
element in t .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^4 ). The description of the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 2
\cdot 10^5 ).

The second line of each test case contains a binary string a_{11} a_{12}
\ldots a_{1n} (a_{1i} is either 0 or 1 ).

The third line of each test case contains a binary string a_{21} a_{22} \ldots
a_{2n} (a_{2i} is either 0 or 1 ).

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output two lines:

  1. The lexicographically smallest string you can attain by choosing any available path; 
  2. The number of paths that yield this string. 

Example

Input

    3
    
    2
    
    00
    
    00
    
    4
    
    1101
    
    1100
    
    8
    
    00100111
    
    11101101

Output

    000
    2
    11000
    1
    001001101
    4
    
Note

In the first test case, the lexicographically smallest string is \mathtt{000}
. There are two paths that yield this string:

![](https://espresso.codeforces.com/77986b77a0625593b90ec3560ecfcbf9154500d2.png)

In the second test case, the lexicographically smallest string is
\mathtt{11000} . There is only one path that yields this string:

![](https://espresso.codeforces.com/553da757110049e03424fa5158938ddaa7e49324.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 1969_A_vigneshwaran2110609_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Monocarp wants to throw a party. He has n friends, and he wants to have at
least 2 of them at his party.

The i -th friend's best friend is p_i . All p_i are distinct, and for every i
\in [1, n] , p_i \ne i .

Monocarp can send invitations to friends. The i -th friend comes to the party
if both the i -th friend and the p_i -th friend receive an invitation (note
that the p_i -th friend doesn't have to actually come to the party). Each
invitation is sent to exactly one of the friends.

For example, if p = [3, 1, 2, 5, 4] , and Monocarp sends invitations to the
friends [1, 2, 4, 5] , then the friends [2, 4, 5] will come to the party. The
friend 1 won't come since his best friend didn't receive an invitation; the
friend 3 won't come since he didn't receive an invitation.

Calculate the minimum number of invitations Monocarp has to send so that at
least 2  friends come to the party.

Input

The first line contains one integer t (1 \le t \le 5000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of friends; 
  * the second line contains n integers p_1, p_2, \dots, p_n (1 \le p_i \le n ; p_i \ne i ; all p_i are distinct). 

Output

Print one integer — the minimum number of invitations Monocarp has to send.

Example

Input

    3
    
    5
    
    3 1 2 5 4
    
    4
    
    2 3 4 1
    
    2
    
    2 1

Output

    2
    3
    2
    
Note

In the first testcase, Monocarp can send invitations to friends 4 and 5 . Both
of them will come to the party since they are each other's best friends, and
both of them have invitations.

In the second testcase, Monocarp can send invitations to friends 1, 2 and 3 ,
for example. Then friends 1 and 2 will attend: friend 1 and his best friend 2
have invitations, friend 2 and his best friend 3 have invitations. Friend 3
won't attend since his friend 4 doesn't have an invitation. It's impossible to
send invitations to fewer than 3 friends in such a way that at least 2 come.

In the third testcase, Monocarp can send invitations to both friends 1 and 2 ,
and both of them will attend.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1941_D_funseeker_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Rudolf and Bernard decided to play a game with their friends. n people stand
in a circle and start throwing a ball to each other. They are numbered from 1
to n in the clockwise order.

Let's call a transition a movement of the ball from one player to his
neighbor. The transition can be made clockwise or counterclockwise.

Let's call the clockwise (counterclockwise) distance from player y_1 to player
y_2 the number of transitions clockwise (counterclockwise) that need to be
made to move from player y_1 to player y_2 . For example, if n=7 then the
clockwise distance from 2 to 5 is 3 , and the counterclockwise distance from 2
to 5 is 4 .

Initially, the ball is with the player number x (players are numbered
clockwise). On the i -th move the person with the ball throws it at a distance
of r_i (1 \le r_i \le n - 1 ) clockwise or counterclockwise. For example, if
there are 7 players, and the 2 nd player, after receiving the ball, throws it
a distance of 5 , then the ball will be caught by either the 7 th player
(throwing clockwise) or the 4 th player (throwing counterclockwise). An
illustration of this example is shown below.

![](https://espresso.codeforces.com/29f44c71d01625dfd7795270dbc36b2737f0b368.png)

The game was interrupted after m throws due to unexpected rain. When the rain
stopped, the guys gathered again to continue. However, no one could remember
who had the ball. As it turned out, Bernard remembered the distances for each
of the throws and the direction for some of the throws (clockwise or
counterclockwise).

Rudolf asks you to help him and based on the information from Bernard,
calculate the numbers of the players who could have the ball after m throws.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains three integers n, m, x (2 \le n \le
1000 , 1 \le m \le 1000 , 1 \le x \le n ) — the number of players, the number
of throws made, and the number of the player who threw the ball first,
respectively.

The next m lines contain information about each throw in order. Each of them
contains an integer r_i (1 \le r_i \le n - 1 ) — the distance at which the i
-th throw was made, and a symbol c_i , equal to '0', '1', or '?':

  * if c_i ='0', then the i -th throw was made clockwise, 
  * if c_i ='1', then the i -th throw was made counterclockwise, 
  * if c_i ='?', then Bernard does not remember the direction and the i -th throw could have been made either clockwise or counterclockwise. 

It is guaranteed that the sum n \cdot m (n multiplied by m ) over all test
cases does not exceed 2 \cdot 10^5 .

Output

For each test case, output two lines.

In the first line, output the number of players k (1 \le k \le n ) who could
have the ball at the end of the game.

In the next line, output k numbers b_i (1 \le b_i \le n ) — the numbers of the
players in increasing order. All numbers must be different.

Example

Input

    5
    
    6 3 2
    
    2 ?
    
    2 ?
    
    2 ?
    
    12 1 2
    
    3 1
    
    10 7 4
    
    2 ?
    
    9 1
    
    4 ?
    
    7 0
    
    2 0
    
    8 1
    
    5 ?
    
    5 3 1
    
    4 0
    
    4 ?
    
    1 ?
    
    4 1 1
    
    2 ?

Output

    3
    2 4 6 
    1
    11 
    4
    3 5 7 9 
    3
    2 3 5 
    1
    3 
    
Note

Below is an illustration of three throws for the first test case. The arrows
denote possible throw directions. Players who could have the ball after the
throw are highlighted in gray.

![](https://espresso.codeforces.com/8c70d0cb48359ee6327eabbf182827e664062516.png)
![](https://espresso.codeforces.com/159cf99566782566b4c267b54062452988d11444.png)
![](https://espresso.codeforces.com/007b0cb2cc613eba2f2e45e69d5d973f282a9d5d.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1929_B_muhammadhamid_25.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a
drawing and attract her attention.

As a drawing, he decided to draw a square grid of size n \times n , in which
some cells are colored. But coloring the cells is difficult, so he wants to
color as few cells as possible. But at the same time, he wants at least k
diagonals to have at least one colored cell. Note that the square grid of size
n \times n has a total of 4n - 2 diagonals.

Help little Sasha to make the girl fall in love with him and tell him the
minimum number of cells he needs to color.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 1000 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (2 \leq n \leq
10^8 , 1 \leq k \leq 4n - 2 ) — the size of the square grid and the minimum
number of diagonals in which there should be at least one colored cell.

Output

For each test case, output a single integer — the minimum number of cells that
need to be colored.

Example

Input

    7
    
    3 4
    
    3 3
    
    3 10
    
    3 9
    
    4 7
    
    7 11
    
    2 3

Output

    2
    2
    6
    5
    4
    6
    2
    
Note

In the pictures below, the colored cells are marked in black, and all
diagonals are marked in purple.

In the first test case, you can color 2 cells so that 4 diagonals contain at
least one colored cell:

![](https://espresso.codeforces.com/c88e80de5be4f91764dbe5bdc534c50fec115db3.png)

In the third test case, you can color 6 cells so that all 10 diagonals contain
at least one colored cell:

![](https://espresso.codeforces.com/624a36083689f6fb20bf243e5d1707fdcd71ef60.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1957_B_Sukhbir_bachhal_6.67%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Given integers n and k , construct a sequence of n non-negative (i.e. \geq 0 )
integers a_1, a_2, \ldots, a_n such that

  1. \sum\limits_{i = 1}^n a_i = k 
  2. The number of 1 s in the binary representation of a_1 | a_2 | \ldots | a_n is maximized, where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). 

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The only line of each test case contains two integers n and k (1 \leq n \leq 2
\cdot 10^5 , 1 \leq k \leq 10^9 ) — the number of non-negative integers to be
printed and the sum respectively.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a sequence a_1, a_2, \ldots, a_n on a new line that
satisfies the conditions given above.

If there are multiple solutions, print any of them.

Example

Input

    4
    
    1 5
    
    2 3
    
    2 5
    
    6 51

Output

    5
    1 2
    5 0
    3 1 1 32 2 12

Note

In the first test case, we have to print exactly one integer, hence we can
only output 5 as the answer.

In the second test case, we output 1, 2 which sum up to 3 , and 1 | 2 = (11)_2 has two 1 s in its binary representation, which is the maximum we can achieve in these constraints.

In the fourth test case, we output 3, 1, 1, 32, 2, 12 which sum up to 51 , and 3 | 1 | 1 | 32 | 2 | 12 = (101\,111)_2 has five 1 s in its binary representation, which is the maximum we can achieve in these constraints.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1954_C_hoangha1306_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two integers x and y of the same length, consisting of digits
from 1 to 9 .

You can perform the following operation any number of times (possibly zero):
swap the i -th digit in x and the i -th digit in y .

For example, if x=73 and y=31 , you can swap the 2 -nd digits and get x=71 and
y=33 .

Your task is to maximize the product of x and y using the aforementioned
operation any number of times. If there are multiple answers, print any of
them.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

The first line of each test case contains a single integer x (1 \le x <
10^{100} ).

The second line of each test case contains a single integer y (1 \le y <
10^{100} ).

Additional constraint on input: the integers x and y consist only of digits
from 1 to 9 .

Output

For each test case, print two lines — the first line should contain the number
x after performing the operations; similarly, the second line should contain
the number y after performing the operations. If there are multiple answers,
print any of them.

Example

Input

    3
    
    73
    
    31
    
    2
    
    5
    
    3516
    
    3982

Output

    71
    33
    5
    2
    3912
    3586
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1932_B_fpeng2002_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1924_A_uguess_8.33%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two integers n and k along with a string s .

Your task is to check whether all possible strings of length n that can be
formed using the first k lowercase English alphabets occur as a subsequence of
s . If the answer is NO, you also need to print a string of length n that can
be formed using the first k lowercase English alphabets which does not occur
as a subsequence of s .

If there are multiple answers, you may print any of them.

Note: A string a is called a subsequence of another string b if a can be
obtained by deleting some (possibly zero) characters from b without changing
the order of the remaining characters.

Input

The first line of input contains a single integer t \, (1 \le t \le 10^5) ,
the number of test cases.

The first line of each test case contains 3 integers n \, (1 \le n \le 26), \:
k \, (1 \le k \le 26), \: m \, (1 \le m \le 1000) , where n and k are the same
as described in the input and m is the length of the string s .

The second line of each test case contains a single string s of length m ,
comprising only of the first k lowercase English alphabets.

It is guaranteed that the sum of m and the sum of n over all test cases does
not exceed 10^6 .

Output

For each test case, print YES if all possible strings of length n that can be
formed using the first k lowercase English alphabets occur as a subsequence of
s , else print NO.

If your answer is NO, print a string of length n that can be formed using the
first k lowercase English alphabets which does not occur as a subsequence of s
in the next line.

You may print each letter of YES or NO in any case (for example, YES, yES, YeS
will all be recognized as a positive answer).

Example

Input

    3
    
    2 2 4
    
    abba
    
    2 2 3
    
    abb
    
    3 3 10
    
    aabbccabab

Output

    YES
    NO
    aa
    NO
    ccc
    
Note

For the first test case, all possible strings (aa, ab, ba, bb) of length 2
that can be formed using the first 2 English alphabets occur as a subsequence
of abba.

For the second test case, the string aa is not a subsequence of abb.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1951_B_meet732_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: [The HU - Shireg Shireg](https://youtu.be/SNCx4n2m5_o)

ඞ

There are n cows participating in a coding tournament. Cow i has a Cowdeforces
rating of a_i (all distinct), and is initially in position i . The tournament
consists of n-1 matches as follows:

  * The first match is between the cow in position 1 and the cow in position 2 . 
  * Subsequently, each match i is between the cow in position i+1 and the winner of match i-1 . 
  * In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match. 

You are the owner of cow k . For you, winning the tournament is not important;
rather, you want your cow to win in as many matches as possible. As an
acquaintance of the tournament organizers, you can ask them to swap the
position of your cow with another cow only once, or you can choose to do
nothing.

Find the maximum number of wins your cow can achieve.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and k (2 \le n \le
10^5, 1 \le k \le n ) — the number of cows and your cow's index.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the Cowdeforces rating of the cows. It is guaranteed that
a_i 's are pairwise different.

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, print one integer: the maximum number of wins cow k can
achieve if you choose to swap (or do nothing) optimally.

Example

Input

    3
    
    6 1
    
    12 10 14 11 8 3
    
    6 5
    
    7 2 727 10 12 13
    
    2 2
    
    1000000000 1

Output

    1
    2
    0
    
Note

In the first test case, it is optimal to do nothing. Let a' be the Cowdeforces
rating of the cows in the original order (with your cow's rating bolded), then

  * Initially, a' = [\mathbf{12}, 10, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 14 and loses. 

In total, your cow wins 1 match.

In the second test case, it is optimal to swap your cow to position 3 . Then,
let a' be the Cowdeforces rating of the cows in the order after the swap.

  * Initially, a' = [7, 2, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [\mathbf{12}, 10, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 727 and loses. 

In total, your cow wins 2 matches.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1946_E_freeskyljy_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1970_C1_amen_meb_47.06%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: This is the easy version of the problem. The difference in this version is
that t=1 and we work on an array-like tree.

Ron and Hermione are playing a game on a tree of n nodes that are initially
inactive. This tree is special because it has exactly two leaves. It can thus
be seen as an array. The game consists of t rounds, each of which starts with
a stone on exactly one node, which is considered as activated. A move consists
of picking an inactive neighbor of the node with a stone on it and moving the
stone there (thus activating this neighbor). Ron makes the first move, after
which he alternates with Hermione until no valid move is available. The player
that cannot make a move loses the round. If both players play optimally, who
wins each round of this game?

Note that all the rounds are played with the same tree; only the starting node
changes. Moreover, after each round, all active nodes are considered inactive
again.

Input

The first line contains integers n (2 \leq n \leq 2\times 10^5 ), t (t=1 ),
the number of nodes in the tree and the number of rounds, respectively.

The next n-1 lines contain two integers 1 \leq u, v \leq n each, corresponding
to an edge of the tree. It is guaranteed that the tree has exactly two leaves.

The next line contains t integers 1 \leq u_1 , \dots, u_t \leq n ,
corresponding to the node where the stone is initially put.

Output

The output consists of t=1 line which is either "Ron" or "Hermione".

Examples

Input

    3 1
    
    2 3
    
    3 1
    
    3

Output

    Ron
    
Input

    5 1
    
    1 2
    
    2 3
    
    3 4
    
    4 5
    
    5

Output

    Hermione
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1980_B_prosenjit_mondol_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Dmitry has n cubes, numbered from left to right from 1 to n . The cube with
index f is his favorite.

Dmitry threw all the cubes on the table, and the i -th cube showed the value
a_i (1 \le a_i \le 100 ). After that, he arranged the cubes in non-increasing
order of their values, from largest to smallest. If two cubes show the same
value, they can go in any order.

After sorting, Dmitry removed the first k cubes. Then he became interested in
whether he removed his favorite cube (note that its position could have
changed after sorting).

For example, if n=5 , f=2 , a = [4, \color{green}3, 3, 2, 3] (the favorite
cube is highlighted in green), and k = 2 , the following could have happened:

  * After sorting a=[4, \color{green}3, 3, 3, 2] , since the favorite cube ended up in the second position, it will be removed. 
  * After sorting a=[4, 3, \color{green}3, 3, 2] , since the favorite cube ended up in the third position, it will not be removed. 

Input

The first line contains an integer t (1 \le t \le 1000 ) — the number of test
cases. Then follow the descriptions of the test cases.

The first line of each test case description contains three integers n , f ,
and k (1 \le f, k \le n \le 100 ) — the number of cubes, the index of Dmitry's
favorite cube, and the number of removed cubes, respectively.

The second line of each test case description contains n integers a_i (1 \le
a_i \le 100 ) — the values shown on the cubes.

Output

For each test case, output one line — "YES" if the cube will be removed in all
cases, "NO" if it will not be removed in any case, "MAYBE" if it may be either
removed or left.

You can output the answer in any case. For example, the strings "YES", "nO",
"mAyBe" will be accepted as answers.

Example

Input

    12
    
    5 2 2
    
    4 3 3 2 3
    
    5 5 3
    
    4 2 1 3 5
    
    5 5 2
    
    5 2 4 1 3
    
    5 5 5
    
    1 2 5 4 3
    
    5 5 4
    
    3 1 2 4 5
    
    5 5 5
    
    4 3 2 1 5
    
    6 5 3
    
    1 2 3 1 2 3
    
    10 1 1
    
    1 1 1 1 1 1 1 1 1 1
    
    1 1 1
    
    42
    
    5 2 3
    
    2 2 1 1 2
    
    2 1 1
    
    2 1
    
    5 3 1
    
    3 3 2 3 2

Output

    MAYBE
    YES
    NO
    YES
    YES
    YES
    MAYBE
    MAYBE
    YES
    YES
    YES
    NO
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1966_B_AngryBiceps_6.67%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There is an n \times m grid of white and black squares. In one operation, you
can select any two squares of the same color, and color all squares in the
subrectangle between them that color.

Formally, if you select positions (x_1, y_1) and (x_2, y_2) , both of which
are currently the same color c , set the color of all (x, y) where \min(x_1,
x_2) \le x \le \max(x_1, x_2) and \min(y_1, y_2) \le y \le \max(y_1, y_2) to c
.

This diagram shows a sequence of two possible operations on a grid:

![](https://espresso.codeforces.com/efe0d6bfa2062b4821f73fb07120103af504fb62.png)

Is it possible for all squares in the grid to be the same color, after
performing any number of operations (possibly zero)?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n and m (1 \le n, m \le
500 ) — the number of rows and columns in the grid, respectively.

Each of the next n lines contains m characters 'W' and 'B' — the initial
colors of the squares of the grid.

It is guaranteed that the sum of n\cdot m over all test cases does not exceed
3\cdot 10^5 .

Output

For each test case, print "YES" if it is possible to make all squares in the
grid the same color, and "NO" otherwise.

You can output the answer in any case (upper or lower). For example, the
strings "yEs", "yes", "Yes", and "YES" will be recognized as positive
responses.

Example

Input

    8
    
    2 1
    
    W
    
    B
    
    6 6
    
    WWWWBW
    
    WBWWWW
    
    BBBWWW
    
    BWWWBB
    
    WWBWBB
    
    BBBWBW
    
    1 1
    
    W
    
    2 2
    
    BB
    
    BB
    
    3 4
    
    BWBW
    
    WBWB
    
    BWBW
    
    4 2
    
    BB
    
    BB
    
    WW
    
    WW
    
    4 4
    
    WWBW
    
    BBWB
    
    WWBB
    
    BBBB
    
    1 5
    
    WBBWB

Output

    NO
    YES
    YES
    YES
    YES
    NO
    YES
    NO
    
Note

In the first example, it is impossible to ever change the color of any square
with an operation, so we output NO.

The second example is the case pictured above. As shown in that diagram, it is
possible for all squares to be white after two operations, so we output YES.

In the third and fourth examples, all squares are already the same color, so
we output YES.

In the fifth example we can do everything in two operations. First, select
positions (2, 1) and (1, 4) and color all squares with 1 \le x \le 2 and 1 \le
y \le 4 to white. Then, select positions (2, 1) and (3, 4) and color all
squares with 2 \le x \le 3 and 1 \le y \le 4 to white. After these two
operations all squares are white.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1973_A_rcd_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1956_C_danikzor_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The magical girl Nene has an n\times n matrix a filled with zeroes. The j -th
element of the i -th row of matrix a is denoted as a_{i, j} .

She can perform operations of the following two types with this matrix:

  * Type 1 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{i, j}:=p_j for all 1 \le j \le n simultaneously. 
  * Type 2 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{j, i}:=p_j for all 1 \le j \le n simultaneously. 

Nene wants to maximize the sum of all the numbers in the matrix
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}a_{i,j} . She asks you to find the
way to perform the operations so that this sum is maximized. As she doesn't
want to make too many operations, you should provide a solution with no more
than 2n operations.

A permutation of length n is an array consisting of n distinct integers from 1
to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of test cases follows.

The only line of each test case contains a single integer n (1 \le n \le 500 )
— the size of the matrix a .

It is guaranteed that the sum of n^2 over all test cases does not exceed 5
\cdot 10^5 .

Output

For each test case, in the first line output two integers s and m (0\leq m\leq
2n ) — the maximum sum of the numbers in the matrix and the number of
operations in your solution.

In the k -th of the next m lines output the description of the k -th
operation:

  * an integer c (c \in \\{1, 2\\} ) — the type of the k -th operation; 
  * an integer i (1 \le i \le n ) — the row or the column the k -th operation is applied to; 
  * a permutation p_1, p_2, \ldots, p_n of integers from 1 to n — the permutation used in the k -th operation. 

Note that you don't need to minimize the number of operations used, you only
should use no more than 2n operations. It can be shown that the maximum
possible sum can always be obtained in no more than 2n operations.

Example

Input

    2
    
    1
    
    2

Output

    1 1
    1 1 1
    7 3
    1 1 1 2
    1 2 1 2
    2 1 1 2
    
Note

In the first test case, the maximum sum s=1 can be obtained in 1 operation by
setting a_{1, 1}:=1 .

In the second test case, the maximum sum s=7 can be obtained in 3 operations
as follows:

![](https://espresso.codeforces.com/4074275900ed2b8a474fda5b3a628454fc521f8a.png)

It can be shown that it is impossible to make the sum of the numbers in the
matrix larger than 7 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1927_B_bubika_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Polycarp lost the string s of length n consisting of lowercase Latin letters,
but he still has its trace.

The trace of the string s is an array a of n integers, where a_i is the number
of such indices j (j < i ) that s_i=s_j . For example, the trace of the string
abracadabra is the array [0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 4 ].

Given a trace of a string, find any string s from which it could have been
obtained. The string s should consist only of lowercase Latin letters a-z.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the length of the lost string.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i < n ) — the trace of the string. It is guaranteed that for the given
trace, there exists a suitable string s .

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a string s that corresponds to the given trace. If
there are multiple such strings s , then output any of them.

The string s should consist of lowercase Latin letters a-z.

It is guaranteed that for each test case, a valid answer exists.

Example

Input

    5
    
    11
    
    0 0 0 1 0 2 0 3 1 1 4
    
    10
    
    0 0 0 0 0 1 0 1 1 0
    
    1
    
    0
    
    8
    
    0 1 2 3 4 5 6 7
    
    8
    
    0 0 0 0 0 0 0 0

Output

    abracadabra
    codeforces
    a
    aaaaaaaa
    dijkstra
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1921_A_KartheKeyan_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: A square of positive (strictly greater than 0 ) area is located on the
coordinate plane, with sides parallel to the coordinate axes. You are given
the coordinates of its corners, in random order. Your task is to find the area
of the square.

Input

Each test consists of several testcases. The first line contains one integer t
(1 \le t \le 100 ) — the number of testcases. The following is a description
of the testcases.

Each testcase contains four lines, each line contains two integers x_i, y_i
(-1000\le x_i, y_i\le 1000 ), coordinates of the corners of the square.

It is guaranteed that there is a square with sides parallel to the coordinate
axes, with positive (strictly greater than 0 ) area, with corners in given
points.

Output

For each test case, print a single integer, the area of the square.

Example

Input

    3
    
    1 2
    
    4 5
    
    1 5
    
    4 2
    
    -1 1
    
    1 -1
    
    1 1
    
    -1 -1
    
    45 11
    
    45 39
    
    17 11
    
    17 39

Output

    9
    4
    784
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1921_B_karan_singh_coder_7.69%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: In order to test the hypothesis about the cats, the scientists must arrange
the cats in the boxes in a specific way. Of course, they would like to test
the hypothesis and publish a sensational article as quickly as possible,
because they are too engrossed in the next hypothesis about the phone's
battery charge.

Scientists have n boxes in which cats may or may not sit. Let the current
state of the boxes be denoted by the sequence b_1, \dots, b_n : b_i = 1 if
there is a cat in box number i , and b_i = 0 otherwise.

Fortunately, the unlimited production of cats has already been established, so
in one day, the scientists can perform one of the following operations:

  * Take a new cat and place it in a box (for some i such that b_i = 0 , assign b_i = 1 ). 
  * Remove a cat from a box and send it into retirement (for some i such that b_i = 1 , assign b_i = 0 ). 
  * Move a cat from one box to another (for some i, j such that b_i = 1, b_j = 0 , assign b_i = 0, b_j = 1 ). 

It has also been found that some boxes were immediately filled with cats.
Therefore, the scientists know the initial position of the cats in the boxes
s_1, \dots, s_n and the desired position f_1, \dots, f_n .

Due to the large amount of paperwork, the scientists do not have time to solve
this problem. Help them for the sake of science and indicate the minimum
number of days required to test the hypothesis.

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
descriptions of the test cases.

Each test case consists of three lines.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the number of boxes.

The second line of each test case contains a string s of n characters, where
the i -th character is '1' if there is a cat in the i -th box and '0'
otherwise.

The third line of each test case contains a string f of n characters, where
the i -th character is '1' if there should be a cat in the i -th box and '0'
otherwise.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the minimum
number of operations required to obtain the desired position from the initial
position. It can be shown that a solution always exists.

Example

Input

    6
    
    5
    
    10010
    
    00001
    
    1
    
    1
    
    1
    
    3
    
    000
    
    111
    
    4
    
    0101
    
    1010
    
    3
    
    100
    
    101
    
    8
    
    10011001
    
    11111110

Output

    2
    0
    3
    2
    1
    4
    
Note

In the first test case, you can first move the cat from the first box to the
fifth, and then remove the cat from the fourth box.

In the second test case, there is nothing to do — the only cat is already
sitting in the correct box.

In the third test case of input data, it takes three days to place a cat in
each box.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': True, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1969_A_vedhasree0709_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Monocarp wants to throw a party. He has n friends, and he wants to have at
least 2 of them at his party.

The i -th friend's best friend is p_i . All p_i are distinct, and for every i
\in [1, n] , p_i \ne i .

Monocarp can send invitations to friends. The i -th friend comes to the party
if both the i -th friend and the p_i -th friend receive an invitation (note
that the p_i -th friend doesn't have to actually come to the party). Each
invitation is sent to exactly one of the friends.

For example, if p = [3, 1, 2, 5, 4] , and Monocarp sends invitations to the
friends [1, 2, 4, 5] , then the friends [2, 4, 5] will come to the party. The
friend 1 won't come since his best friend didn't receive an invitation; the
friend 3 won't come since he didn't receive an invitation.

Calculate the minimum number of invitations Monocarp has to send so that at
least 2  friends come to the party.

Input

The first line contains one integer t (1 \le t \le 5000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of friends; 
  * the second line contains n integers p_1, p_2, \dots, p_n (1 \le p_i \le n ; p_i \ne i ; all p_i are distinct). 

Output

Print one integer — the minimum number of invitations Monocarp has to send.

Example

Input

    3
    
    5
    
    3 1 2 5 4
    
    4
    
    2 3 4 1
    
    2
    
    2 1

Output

    2
    3
    2
    
Note

In the first testcase, Monocarp can send invitations to friends 4 and 5 . Both
of them will come to the party since they are each other's best friends, and
both of them have invitations.

In the second testcase, Monocarp can send invitations to friends 1, 2 and 3 ,
for example. Then friends 1 and 2 will attend: friend 1 and his best friend 2
have invitations, friend 2 and his best friend 3 have invitations. Friend 3
won't attend since his friend 4 doesn't have an invitation. It's impossible to
send invitations to fewer than 3 friends in such a way that at least 2 come.

In the third testcase, Monocarp can send invitations to both friends 1 and 2 ,
and both of them will attend.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1945_B_Bataineh_14.29%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: One of the days of the hike coincided with a holiday, so in the evening at the
camp, it was decided to arrange a festive fireworks display. For this purpose,
the organizers of the hike bought two installations for launching fireworks
and a huge number of shells for launching.

Both installations are turned on simultaneously. The first installation
launches fireworks every a minutes (i.e., after a, 2 \cdot a, 3 \cdot a, \dots
minutes after launch). The second installation launches fireworks every b
minutes (i.e., after b, 2 \cdot b, 3 \cdot b, \dots minutes after launch).

Each firework is visible in the sky for m + 1 minutes after launch, i.e., if a
firework was launched after x minutes after the installations were turned on,
it will be visible every minute from x to x + m , inclusive. If one firework
was launched m minutes after another, both fireworks will be visible for one
minute.

What is the maximum number of fireworks that could be seen in the sky at the
same time?

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follow the
descriptions of the test cases.

The first and only line of each test case contains integers a , b , m (1 \le
a, b, m \le 10^{18} ) — the frequency of launching for the first installation,
the second installation, and the time the firework is visible in the sky.

Output

For each set of input data, output a single number — the maximum number of
fireworks that can be seen simultaneously.

Example

Input

    6
    
    6 7 4
    
    3 4 10
    
    7 8 56
    
    5 6 78123459896
    
    1 1 1
    
    1 1 1000000000000000000

Output

    2
    7
    17
    28645268630
    4
    2000000000000000002
    
Note

In the first set of input data, the fireworks are visible in the sky for 5
minutes. Since the first installation launches fireworks every 6 minutes, and
the second one every 7 minutes, two fireworks launched from the same
installation will not be visible in the sky at the same time. At the same
time, after 7 minutes from the start of the holiday, one firework from the
first and one from the second camp will be visible. Thus, it is possible to
see no more than 2 fireworks simultaneously.

In the third set of input data, 17 fireworks will be visible after 112
minutes:

  * 9 fireworks launched from the first installation at times [56, 63, 70, 77, 84, 91, 98, 105, 112 ]; 
  * 8 fireworks launched from the second installation at times [56, 64, 72, 80, 88, 96, 104, 112 ].
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1955_C_Luv985_3.33%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1955_F_Slata_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob gathered in the evening to play an exciting game on a sequence
of n integers, each integer of the sequence doesn't exceed 4 . The rules of
the game are too complex to describe, so let's just describe the winning
condition — Alice wins if the [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
all the numbers in the sequence is non-zero; otherwise, Bob wins.

The guys invited Eve to act as a judge. Initially, Alice and Bob play with n
numbers. After one game, Eve removes one of the numbers from the sequence,
then Alice and Bob play with n-1 numbers. Eve removes one number again, after
which Alice and Bob play with n - 2 numbers. This continues until the sequence
of numbers is empty.

Eve seems to think that in such a game, Alice almost always wins, so she wants
Bob to win as many times as possible. Determine the maximum number of times
Bob can win against Alice if Eve removes the numbers optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first and only line of each test case contains four integers p_i (0 \le
p_i \le 200 ) — the number of ones, twos, threes, and fours in the sequence at
the beginning of the game.

Output

For each test case, print the maximum number of times Bob will win in a
separate line, if Eve removes the numbers optimally.

Example

Input

    5
    
    1 1 1 0
    
    1 0 1 2
    
    2 2 2 0
    
    3 3 2 0
    
    0 9 9 9

Output

    1
    1
    3
    3
    12
    
Note

In the first example, Bob wins when Eve has not removed any numbers yet.

In the second example, Bob wins if Eve removes one one and one three.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1977_A_Sardorbek_08_20.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The little boy Nikita was given some cubes as a present. He decided to build a
tower out of them.

Initially, the tower doesn't have any cubes. In one move, Nikita either puts
exactly 1 cube on top of the tower or removes exactly 1 cube from the top of
the tower. Is it possible that after n moves, the resulting tower has exactly
m cubes?

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 100 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains two integers n and m (1 \le n, m \le
100 ).

Output

For each test case, output "Yes" (without quotes) if Nikita can obtain a tower
with m cubes, and "No" (without quotes) otherwise.

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    3
    
    3 3
    
    2 4
    
    5 3

Output

    Yes
    No
    Yes
    
Note

In the first test case, Nikita can put 1 cube on top of the tower 3 times in a
row, so the answer is "Yes".

In the second test case, Nikita can only end up with either a tower with no
blocks or a tower with 2 blocks, so the answer is "No".
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1956_C_danikzor_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The magical girl Nene has an n\times n matrix a filled with zeroes. The j -th
element of the i -th row of matrix a is denoted as a_{i, j} .

She can perform operations of the following two types with this matrix:

  * Type 1 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{i, j}:=p_j for all 1 \le j \le n simultaneously. 
  * Type 2 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{j, i}:=p_j for all 1 \le j \le n simultaneously. 

Nene wants to maximize the sum of all the numbers in the matrix
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}a_{i,j} . She asks you to find the
way to perform the operations so that this sum is maximized. As she doesn't
want to make too many operations, you should provide a solution with no more
than 2n operations.

A permutation of length n is an array consisting of n distinct integers from 1
to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of test cases follows.

The only line of each test case contains a single integer n (1 \le n \le 500 )
— the size of the matrix a .

It is guaranteed that the sum of n^2 over all test cases does not exceed 5
\cdot 10^5 .

Output

For each test case, in the first line output two integers s and m (0\leq m\leq
2n ) — the maximum sum of the numbers in the matrix and the number of
operations in your solution.

In the k -th of the next m lines output the description of the k -th
operation:

  * an integer c (c \in \\{1, 2\\} ) — the type of the k -th operation; 
  * an integer i (1 \le i \le n ) — the row or the column the k -th operation is applied to; 
  * a permutation p_1, p_2, \ldots, p_n of integers from 1 to n — the permutation used in the k -th operation. 

Note that you don't need to minimize the number of operations used, you only
should use no more than 2n operations. It can be shown that the maximum
possible sum can always be obtained in no more than 2n operations.

Example

Input

    2
    
    1
    
    2

Output

    1 1
    1 1 1
    7 3
    1 1 1 2
    1 2 1 2
    2 1 1 2
    
Note

In the first test case, the maximum sum s=1 can be obtained in 1 operation by
setting a_{1, 1}:=1 .

In the second test case, the maximum sum s=7 can be obtained in 3 operations
as follows:

![](https://espresso.codeforces.com/4074275900ed2b8a474fda5b3a628454fc521f8a.png)

It can be shown that it is impossible to make the sum of the numbers in the
matrix larger than 7 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1945_D_vjudge.1_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The guys lined up in a queue of n people, starting with person number i = 1 ,
to ask Serafim the Owl about the meaning of life. Unfortunately, Kirill was
very busy writing the legend for this problem, so he arrived a little later
and stood at the end of the line after the n -th person. Kirill is completely
dissatisfied with this situation, so he decided to bribe some people ahead of
him.

For the i -th person in the queue, Kirill knows two values: a_i and b_i . If
at the moment Kirill is standing at position i , then he can choose any
position j such that j < i and exchange places with the person at position j .
In this case, Kirill will have to pay him a_j coins. And for each k such that
j < k < i , Kirill will have to pay b_k coins to the person at position k .
Kirill can perform this action any number of times.

Kirill is thrifty, so he wants to spend as few coins as possible, but he
doesn't want to wait too long, so Kirill believes he should be among the first
m people in line.

Help Kirill determine the minimum number of coins he will have to spend in
order to not wait too long.

Input

Each test consists of several sets of input data. The first line contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows
the description of the test case.

The first line of each test case contains two integers n and m (1 \le m \le n
\le 200\,000 ) — the number of people in the queue besides Kirill and the
maximum allowable final position of Kirill, respectively.

The second line contains n integers a_1, a_2, \dots, a_n separated by spaces
(1 \le a_i \le 10^9 ).

The third line contains n integers b_1, b_2, \dots, b_n separated by spaces (1
\le b_i \le 10^9 ).

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of coins
Kirill needs to spend.

Example

Input

    4
    
    4 2
    
    7 3 6 9
    
    4 3 8 5
    
    6 2
    
    6 9 7 1 8 3
    
    5 8 8 1 4 1
    
    7 7
    
    7 2 9 2 6 5 9
    
    9 1 10 7 1 4 9
    
    2 1
    
    2 3
    
    1 1

Output

    14
    22
    9
    3
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1937_D_r-tron18_5.26%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There is a one-dimensional grid of length n . The i -th cell of the grid
contains a character s_i , which is either '<' or '>'.

When a pinball is placed on one of the cells, it moves according to the
following rules:

  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. 
  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). 
  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. 

You need to answer n independent queries. In the i -th query, a pinball will
be placed on the i -th cell. Note that we always place a pinball on the
initial grid.

For each query, calculate how many seconds it takes the pinball to leave the
grid. It can be shown that the pinball will always leave the grid within a
finite number of steps.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^5 ). The description of the test cases follows.

The first line of each test case contains an integer n (1 \le n \le 5 \cdot
10^5 ).

The second line of each test case contains a string s_1s_2 \ldots s_{n} of
length n consisting of characters '<' and '>'.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, for each i (1 \le i \le n ) output the answer if a pinball
is initially placed on the i -th cell.

Example

Input

    3
    
    3
    
    ><<
    
    4
    
    <<<<
    
    6
    
    <><<<>

Output

    3 6 5 
    1 2 3 4 
    1 4 7 10 8 1 
    
Note

In the first test case, the movement of the pinball for i=1 is shown in the
following pictures. It takes the pinball 3 seconds to leave the grid.

![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)

The movement of the pinball for i=2 is shown in the following pictures. It
takes the pinball 6 seconds to leave the grid.

![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1927_A_Yash-_-_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You have a horizontal strip of n cells. Each cell is either white or black.

You can choose a continuous segment of cells once and paint them all white.
After this action, all the black cells in this segment will become white, and
the white ones will remain white.

What is the minimum length of the segment that needs to be painted white in
order for all n cells to become white?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 10 )
— the length of the strip.

The second line of each test case contains a string s , consisting of n
characters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white
cell, and 'B' — a black one. It is guaranteed that at least one cell of the
given strip is black.

Output

For each test case, output a single number — the minimum length of a
continuous segment of cells that needs to be painted white in order for the
entire strip to become white.

Example

Input

    8
    
    6
    
    WBBWBW
    
    1
    
    B
    
    2
    
    WB
    
    3
    
    BBW
    
    4
    
    BWWB
    
    6
    
    BWBWWB
    
    6
    
    WWBBWB
    
    9
    
    WBWBWWWBW

Output

    4
    1
    1
    2
    4
    6
    4
    7
    
Note

In the first test case of the example for the strip "WBBWBW", the minimum
length of the segment to be repainted white is 4 . It is necessary to repaint
to white the segment from the 2 -nd to the 5 -th cell (the cells are numbered
from 1 from left to right).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1974_A_Ridham__50.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Little Rosie has a phone with a desktop (or launcher, as it is also called).
The desktop can consist of several screens. Each screen is represented as a
grid of size 5 \times 3 , i.e., five rows and three columns.

There are x applications with an icon size of 1 \times 1 cells; such an icon
occupies only one cell of the screen. There are also y applications with an
icon size of 2 \times 2 cells; such an icon occupies a square of 4 cells on
the screen. Each cell of each screen can be occupied by no more than one icon.

Rosie wants to place the application icons on the minimum number of screens.
Help her find the minimum number of screens needed.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first and only line of each test case contains two integers x and y (0
\leq x, y \leq 99 ) — the number of applications with a 1 \times 1 icon and
the number of applications with a 2 \times 2 icon, respectively.

Output

For each test case, output the minimal number of required screens on a
separate line.

Example

Input

    11
    
    1 1
    
    7 2
    
    12 4
    
    0 3
    
    1 0
    
    8 1
    
    0 0
    
    2 0
    
    15 0
    
    8 2
    
    0 9

Output

    1
    1
    2
    2
    1
    1
    0
    1
    1
    2
    5
    
Note

The solution for the first test case can look as follows:

![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)
Blue squares represent empty spaces for icons, green squares represent 1
\times 1 icons, red squares represent 2 \times 2 icons

The solution for the third test case can look as follows:

![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1972_D1_Imran32_50.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1966_A_Sadasak_8.33%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You have a hand of n cards, where each card has a number written on it, and a
fixed integer k . You can perform the following operation any number of times:

  * Choose any k cards from your hand that all have the same number. 
  * Exchange these cards for k-1 cards, each of which can have any number you choose (including the number written on the cards you just exchanged). 

Here is one possible sequence of operations for the first example case, which
has k=3 :

![](https://espresso.codeforces.com/ac8986e55ddc41e4d0ee63ac67222f97e7fcc1bf.png)

What is the minimum number of cards you can have in your hand at the end of
this process?

Input

The first line of the input contains a single integer t (1 \le t \le 500 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n and k (1 \le n \le
100 , 2 \le k \le 100 ) — the number of cards you have, and the number of
cards you exchange during each operation, respectively.

The next line of each test case contains n integers c_1, c_2, \ldots c_n (1
\le c_i \le 100 ) — the numbers written on your cards.

Output

For each test case, output a single integer — the minimum number of cards you
can have left in your hand after any number of operations.

Example

Input

    7
    
    5 3
    
    4 1 1 4 4
    
    1 10
    
    7
    
    7 2
    
    4 2 1 100 5 2 3
    
    10 4
    
    1 1 1 1 1 1 1 1 1 1
    
    5 2
    
    3 8 1 48 7
    
    6 2
    
    10 20 30 10 20 40
    
    6 3
    
    10 20 30 10 20 40

Output

    2
    1
    1
    3
    5
    1
    6
    
Note

The first example case corresponds to the picture above. The sequence of
operations displayed there is optimal, so the answer is 2 .

In the second example case, no operations can be performed, so the answer is 1
.

In the fourth example case, you can repeatedly select 4 cards numbered with 1
and replace them with 3 cards numbered with 1 , until there are 3 cards left.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1973_D_pennymagic156_8.33%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: This is an interactive problem.

Fox gave Cat two positive integers n and k . She has a hidden array a_1,
\ldots , a_n of length n , such that 1 \leq a_i \leq n for every i . Now they
are going to play the following game:

For any two integers l, r such that 1 \leq l \leq r \leq n , define f(l, r) =
(r - l + 1) \cdot \max\limits_{x=l}^r a_x . In other words, f(l, r) is equal
to the maximum of the subarray a_l, \ldots, a_r multiplied by its size.

Cat can ask Fox at most 2 n questions about the array. He will tell her two
integers l and x (1 \leq l \leq n, 1 \leq x \leq 10^9 ), and she will tell him
one integer p as the answer — the smallest positive integer r such that f(l,
r) = x , or n+1 if no such r exists.

Now, Cat needs to find the largest value m such that there exists a sequence
c_1, \ldots, c_{k-1} such that 1 \leq c_1 < \ldots < c_{k-1} < n and f(1, c_1)
= f(c_1 + 1, c_2) = \ldots = f(c_{k-1}+1, n) = m . If no such m exists, he
should indicate this and take -1 as the answer. Note that for k = 1 , m is
always equal to f(1, n) .

In other words, the goal is to find the largest m such that you can split the
array into exactly k subarrays (k is the constant given to you in the
beginning of the interaction) so that all the subarrays have the product of
their length and their maximum equal to m , or determine that no such m
exists. Every element should belong in exactly one of the subarrays.

Cat doesn't know what he should do, so he asked you to play the game for him.

Interaction

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains two positive integers n and k (1
\leq k \leq n \leq 10^4 ) — the length of the hidden array and the number of
subarrays in the desired split.

Now you are allowed to make queries in the following way — print one line of
the form "\mathtt{?} \ l \ x " (it must hold that 1 \leq l \leq n , 1 \leq x
\leq 10^9 ) and you will receive the smallest integer r such that l \leq r
\leq n and f(l, r) = x , or n + 1 if no such r exists.

If you want to print the answer, output "\mathtt{!} \ m " and you will recieve
1 if your answer is correct and -1 otherwise. In the first case, the
interaction continues with the next test case. Note that printing the answer
doesn't count towards the number of queries made. Please note that you don't
receive the values for the next test case immediately, you will first have to
read whether your answer to the last test case was correct.

If you receive the integer -1 at any moment, it means your program has made an
invalid query, exceeded the query limit, or gave an incorrect answer. Your
program must terminate immediately to receive a Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query, do not forget to output end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see documentation for other languages. 

It is guaranteed that the total sum of n over the test cases won't exceed 10^4
.

Hacks

The format of the hacks should be the following: the first line should contain
one integer t (1 \leq t \leq 10^3 ) — the number of test cases. The
description of the test cases should follow.

The first line of each test case should contain two integers n and k (1 \leq k
\leq n \leq 10^4 ) — the length of the array a and the number of subarrays you
want to split it into.

The second line should contain n integers a_1, a_2, \ldots, a_n (1 \leq a_i
\leq n ).

The sum of n over all test cases should not exceed 10^4 .

Example

Input

Copy

    3
    1 1
    
    1
    2 2
    
    1
    
    3
    
    1
    6 3
    
    7
    
    2
    
    3
    
    6
    
    1

Output

Copy

    ! 1
    
    ? 1 1
    
    ? 2 1
    
    ! -1
    
    ? 1 9
    
    ? 1 6
    
    ? 3 6
    
    ? 4 6
    
    ! 6

Note

The hidden arrays in the three testcases are [1] , [1, 2] and [1, 3, 6, 1, 2,
1] . In the second testcase, no split satisfies the constraints, so the answer
is -1 .

The answer for the first query of the third testcase is 7 since no valid r
exists. For the second query of the third testcase, since 2 \cdot \max(1, 3) =
6 , we will get 2 as the answer, since r = 1 doesn't satisfy the constraint.

The sample interaction guessed all three answers (1, -1 and 6 ) correctly, so
it received 1 after each answer.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1951_E_harshkankhar1_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: [Christopher Tin ft. Soweto Gospel Choir - Baba
Yetu](https://youtu.be/d4iOF4yoNQw)

ඞ

You are given a string s consisting of lowercase Latin characters. You need to
partition^\dagger this string into some substrings, such that each substring
is not a palindrome^\ddagger .

^\dagger A partition of a string s is an ordered sequence of some k strings
t_1, t_2, \ldots, t_k , such that t_1 + t_2 + \ldots + t_k = s , where + here
represents the concatenation operation.

^\ddagger A string s is considered a palindrome if it reads the same backwards
as forwards. For example, \mathtt{racecar} , \mathtt{abccba} , and \mathtt{a}
are palindromes, but \mathtt{ab} , \mathtt{dokibird} , and \mathtt{kurosanji}
are not.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases.

Each test case contains a string s consisting of lowercase Latin characters (1
\le |s| \le 10^6 ).

It is guaranteed that the sum of |s| over all test cases does not exceed 10^6
.

Output

For each test case, print on one line "YES" if there exists a partition of s
whose parts are not palindromes, or "NO" if there is no such partition.

If the answer is "YES", on the second line, print an integer k — the number of
parts that s needs to be partitioned to such that each part is not a
palindrome. On the third line, print k strings t_1, t_2, \ldots, t_k
representing such a partition. If there are multiple such partitions, print
any of them.

Example

Input

    3
    
    sinktheyacht
    
    lllllllll
    
    uwuowouwu

Output

    YES
    1
    sinktheyacht
    NO
    YES
    3
    uw uow ouwu
    
Note

In the first test case, since \mathtt{sinktheyacht} is already non-palindrome,
the partition [\mathtt{sinktheyacht}] is valid.

In the second test case, as any substring of the string s is palindrome, there
are no valid partitions.

In the third test case, another valid partition is [\mathtt{uw},\mathtt{uo},
\mathtt{wou}, \mathtt{wu}] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1945_E_hjacobs3_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Anton got bored during the hike and wanted to solve something. He asked Kirill
if he had any new problems, and of course, Kirill had one.

You are given a permutation p of size n , and a number x that needs to be
found. A permutation of length n is an array consisting of n distinct integers
from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

You decided that you are a cool programmer, so you will use an advanced
algorithm for the search — binary search. However, you forgot that for binary
search, the array must be sorted.

You did not give up and decided to apply this algorithm anyway, and in order
to get the correct answer, you can perform the following operation no more
than 2 times before running the algorithm: choose the indices i , j (1\le i, j
\le n ) and swap the elements at positions i and j .

After that, the binary search is performed. At the beginning of the algorithm,
two variables l = 1 and r = n + 1 are declared. Then the following loop is
executed:

  1. If r - l = 1 , end the loop 
  2. m = \lfloor \frac{r + l}{2} \rfloor 
  3. If p_m \le x , assign l = m , otherwise r = m . 

The goal is to rearrange the numbers in the permutation before the algorithm
so that after the algorithm is executed, p_l is equal to x . It can be shown
that 2 operations are always sufficient.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 2\cdot 10^4 ) — the number of test cases. Then follow
the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le x \le n
\le 2\cdot 10^5 ) — the length of the permutation and the number to be found.

The second line contains the permutation p separated by spaces (1 \le p_i \le
n ).

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2\cdot 10^5 .

Output

For each test case, output an integer k (0 \le k \le 2 ) on the first line —
the number of operations performed by you. In the next k lines, output 2
integers i , j (1 \le i, j \le n ) separated by a space, indicating that you
are swapping the elements at positions i and j .

Note that you do not need to minimize the number of operations.

Example

Input

    5
    
    6 3
    
    1 2 3 4 5 6
    
    6 5
    
    3 1 6 5 2 4
    
    5 1
    
    3 5 4 2 1
    
    6 3
    
    4 3 1 5 2 6
    
    3 2
    
    3 2 1

Output

    0
    1
    3 4
    2
    2 4
    1 5
    2
    4 5
    2 4
    1
    1 3
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1980_A_UltraMate_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Vlad is planning to hold m rounds next month. Each round should contain one
problem of difficulty levels 'A', 'B', 'C', 'D', 'E', 'F', and 'G'.

Vlad already has a bank of n problems, where the i -th problem has a
difficulty level of a_i . There may not be enough of these problems, so he may
have to come up with a few more problems.

Vlad wants to come up with as few problems as possible, so he asks you to find
the minimum number of problems he needs to come up with in order to hold m
rounds.

For example, if m=1 , n = 10 , a= 'BGECDCBDED', then he needs to come up with
two problems: one of difficulty level 'A' and one of difficulty level 'F'.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

The first line of each test case contains two integers n and m (1 \le n \le 50
, 1 \le m \le 5 ) — the number of problems in the bank and the number of
upcoming rounds, respectively.

The second line of each test case contains a string a of n characters from 'A'
to 'G' — the difficulties of the problems in the bank.

Output

For each test case, output a single integer — the minimum number of problems
that need to come up with to hold m rounds.

Example

Input

    3
    
    10 1
    
    BGECDCBDED
    
    10 2
    
    BGECDCBDED
    
    9 1
    
    BBCDEFFGG

Output

    2
    5
    1
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1925_D_jinyiqi_27.78%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There are n children in a class, m pairs among them are friends. The i -th
pair who are friends have a friendship value of f_i .

The teacher has to go for k excursions, and for each of the excursions she
chooses a pair of children randomly, equiprobably and independently. If a pair
of children who are friends is chosen, their friendship value increases by 1
for all subsequent excursions (the teacher can choose a pair of children more
than once). The friendship value of a pair who are not friends is considered 0
, and it does not change for subsequent excursions.

Find the expected value of the sum of friendship values of all k pairs chosen
for the excursions (at the time of being chosen). It can be shown that this
answer can always be expressed as a fraction \dfrac{p}{q} where p and q are
coprime integers. Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 5 \cdot 10^4 ). Description of the test cases
follows.

The first line of each test case contains 3 integers n , m and k (2 \le n \le
10^5 , 0 \le m \le \min \Big(10^5 , \frac{n(n-1)}{2} \Big) , 1 \le k \le 2
\cdot 10^5 ) — the number of children, pairs of friends and excursions
respectively.

The next m lines contain three integers each — a_i , b_i , f_i — the indices
of the pair of children who are friends and their friendship value. (a_i \neq
b_i , 1 \le a_i,b_i \le n , 1 \le f_i \le 10^9 ). It is guaranteed that all
pairs of friends are distinct.

It is guaranteed that the sum of n and sum m over all test cases does not
exceed 10^5 and the sum of k over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, print one integer — the answer to the problem.

Example

Input

    4
    
    100 0 24
    
    2 1 10
    
    1 2 1
    
    3 1 2
    
    2 1 1
    
    5 2 4
    
    1 2 25
    
    3 2 24

Output

    0
    55
    777777784
    40000020
    
Note

For the first test case, there are no pairs of friends, so the friendship
value of all pairs is 0 and stays 0 for subsequent rounds, hence the
friendship value for all excursions is 0 .

For the second test case, there is only one pair possible (1, 2) and its
friendship value is initially 1 , so each turn they are picked and their
friendship value increases by 1 . Therefore, the total sum is 1+2+3+\ldots+10
= 55 .

For the third test case, the final answer is \frac{7}{9} = 777\,777\,784\bmod
(10^9+7) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1920_B_Dehong2019_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1920_B_omar1212nasser_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1920_B_omar1212nasser_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1957_C_hx199411_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1954_A_michi330_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob have bought a ribbon consisting of n parts. Now they want to
paint it.

First, Alice will paint every part of the ribbon into one of m colors. For
each part, she can choose its color arbitrarily.

Then, Bob will choose at most k  parts of the ribbon and repaint them into the
same color (he chooses the affected parts and the color arbitrarily).

Bob would like all parts to have the same color. However, Alice thinks that
this is too dull, so she wants to paint the ribbon in such a way that Bob
cannot make all parts have the same color.

Is it possible to paint the ribbon in such a way?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of one line containing three integers n , m and k (1
\le m, k \le n \le 50 ) — the number of parts, the number of colors and the
number of parts Bob can repaint, respectively.

Output

For each test case, print YES if Alice can paint the ribbon so that Bob cannot
make all parts have the same color. Otherwise, print NO.

You can print every letter in any register. For example, Yes, yes, yEs will
all be recognized as positive answer.

Example

Input

    5
    
    1 1 1
    
    5 1 1
    
    5 2 1
    
    5 2 2
    
    5 5 3

Output

    NO
    NO
    YES
    NO
    YES
    
Note

In the first test case, a ribbon consists of 1 part. So all its parts will
always have the same color.

In the second test case, there is only 1 color.

In the third test case, Alice can paint the ribbon as follows: [1, 2, 1, 2, 1]
. It's impossible to change the color of at most 1 part so that all parts have
the same color.

In the fourth test case, no matter how Alice paints the ribbon, Bob will
always be able to repaint 2 parts so that all parts have the same color.

In the fifth test case, Alice can paint the ribbon as follows: [1, 2, 3, 4, 5]
. It's impossible to change the color of at most 3 parts so that all parts
have the same color.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1948_A_Tirthraj_Raval_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given an integer n .

Your task is to build a string of uppercase Latin letters. There must be
exactly n special characters in this string. Let's call a character special if
it is equal to exactly one of its neighbors.

For example, there are 6 special characters in the AAABAACC string (at
positions: 1 , 3 , 5 , 6 , 7 and 8 ).

Print any suitable string or report that there is no such string.

Input

The first line contains a single integer t (1 \le t \le 50 ) — the number of
test cases.

The only line of each test case contains a single integer n (1 \le n \le 50 ).

Output

For each test case, print the answer as follows:

  * if there is no suitable string, print one line containing the string NO; 
  * otherwise, print two lines. The first line should contain the string YES; on the second line print a string of length at most 200  — the answer itself (it can be shown that if some answers exist, then there is an answer of length at most 200 ). If there are several solutions, print any of them. 

Example

Input

    3
    
    6
    
    1
    
    2

Output

    YES
    AAABAACC
    NO
    YES
    MM
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1921_B_AmirSol_7.69%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: In order to test the hypothesis about the cats, the scientists must arrange
the cats in the boxes in a specific way. Of course, they would like to test
the hypothesis and publish a sensational article as quickly as possible,
because they are too engrossed in the next hypothesis about the phone's
battery charge.

Scientists have n boxes in which cats may or may not sit. Let the current
state of the boxes be denoted by the sequence b_1, \dots, b_n : b_i = 1 if
there is a cat in box number i , and b_i = 0 otherwise.

Fortunately, the unlimited production of cats has already been established, so
in one day, the scientists can perform one of the following operations:

  * Take a new cat and place it in a box (for some i such that b_i = 0 , assign b_i = 1 ). 
  * Remove a cat from a box and send it into retirement (for some i such that b_i = 1 , assign b_i = 0 ). 
  * Move a cat from one box to another (for some i, j such that b_i = 1, b_j = 0 , assign b_i = 0, b_j = 1 ). 

It has also been found that some boxes were immediately filled with cats.
Therefore, the scientists know the initial position of the cats in the boxes
s_1, \dots, s_n and the desired position f_1, \dots, f_n .

Due to the large amount of paperwork, the scientists do not have time to solve
this problem. Help them for the sake of science and indicate the minimum
number of days required to test the hypothesis.

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
descriptions of the test cases.

Each test case consists of three lines.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the number of boxes.

The second line of each test case contains a string s of n characters, where
the i -th character is '1' if there is a cat in the i -th box and '0'
otherwise.

The third line of each test case contains a string f of n characters, where
the i -th character is '1' if there should be a cat in the i -th box and '0'
otherwise.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the minimum
number of operations required to obtain the desired position from the initial
position. It can be shown that a solution always exists.

Example

Input

    6
    
    5
    
    10010
    
    00001
    
    1
    
    1
    
    1
    
    3
    
    000
    
    111
    
    4
    
    0101
    
    1010
    
    3
    
    100
    
    101
    
    8
    
    10011001
    
    11111110

Output

    2
    0
    3
    2
    1
    4
    
Note

In the first test case, you can first move the cat from the first box to the
fifth, and then remove the cat from the fourth box.

In the second test case, there is nothing to do — the only cat is already
sitting in the correct box.

In the third test case of input data, it takes three days to place a cat in
each box.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 1945_A_josie.elliston_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1956_C_AKXYN_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The magical girl Nene has an n\times n matrix a filled with zeroes. The j -th
element of the i -th row of matrix a is denoted as a_{i, j} .

She can perform operations of the following two types with this matrix:

  * Type 1 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{i, j}:=p_j for all 1 \le j \le n simultaneously. 
  * Type 2 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{j, i}:=p_j for all 1 \le j \le n simultaneously. 

Nene wants to maximize the sum of all the numbers in the matrix
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}a_{i,j} . She asks you to find the
way to perform the operations so that this sum is maximized. As she doesn't
want to make too many operations, you should provide a solution with no more
than 2n operations.

A permutation of length n is an array consisting of n distinct integers from 1
to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of test cases follows.

The only line of each test case contains a single integer n (1 \le n \le 500 )
— the size of the matrix a .

It is guaranteed that the sum of n^2 over all test cases does not exceed 5
\cdot 10^5 .

Output

For each test case, in the first line output two integers s and m (0\leq m\leq
2n ) — the maximum sum of the numbers in the matrix and the number of
operations in your solution.

In the k -th of the next m lines output the description of the k -th
operation:

  * an integer c (c \in \\{1, 2\\} ) — the type of the k -th operation; 
  * an integer i (1 \le i \le n ) — the row or the column the k -th operation is applied to; 
  * a permutation p_1, p_2, \ldots, p_n of integers from 1 to n — the permutation used in the k -th operation. 

Note that you don't need to minimize the number of operations used, you only
should use no more than 2n operations. It can be shown that the maximum
possible sum can always be obtained in no more than 2n operations.

Example

Input

    2
    
    1
    
    2

Output

    1 1
    1 1 1
    7 3
    1 1 1 2
    1 2 1 2
    2 1 1 2
    
Note

In the first test case, the maximum sum s=1 can be obtained in 1 operation by
setting a_{1, 1}:=1 .

In the second test case, the maximum sum s=7 can be obtained in 3 operations
as follows:

![](https://espresso.codeforces.com/4074275900ed2b8a474fda5b3a628454fc521f8a.png)

It can be shown that it is impossible to make the sum of the numbers in the
matrix larger than 7 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1951_C_DevK01_4.76%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: [Maître Gims - Est-ce que tu m'aimes ?](https://youtu.be/6TpyRE_juyA)

ඞ

As the CEO of a startup company, you want to reward each of your k employees
with a ticket to the upcoming concert. The tickets will be on sale for n days,
and by some time travelling, you have predicted that the price per ticket at
day i will be a_i . However, to prevent ticket hoarding, the concert
organizers have implemented the following measures:

  * A person may purchase no more than m tickets per day. 
  * If a person purchases x tickets on day i , all subsequent days (i.e. from day i+1 onwards) will have their prices per ticket increased by x . 

For example, if a = [1, 3, 8, 4, 5] and you purchase 2 tickets on day 1 , they
will cost 2 in total, and the prices from day 2 onwards will become [5, 10, 6,
7] . If you then purchase 3 more tickets on day 2 , they will cost in total an
additional 15 , and the prices from day 3 onwards will become [13, 9, 10] .

Find the minimum spending to purchase k tickets.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains three integers n , m , and k (1 \le
n \le 3 \cdot 10^5, 1 \le m \le 10^9, 1 \le k \le \min(nm, 10^9) ) — the
number of sale days, the maximum amount of ticket purchasable each day, and
the number of tickets to be bought at the end.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the price per ticket for each of the upcoming n days.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the minimum amount of money needed to
purchase exactly k tickets.

Example

Input

    4
    
    4 2 3
    
    8 6 4 2
    
    4 2 8
    
    8 6 4 2
    
    5 100 1
    
    10000 1 100 10 1000
    
    6 3 9
    
    5 5 5 5 5 5

Output

    10
    64
    1
    72
    
Note

In the first test case, one optimal way to buy 3 tickets is as follows:

  * Buy 0 tickets on the first day. The prices per ticket for the remaining days are [6, 4, 2] . 
  * Buy 0 tickets on the second day. The prices per ticket for the remaining days are [4, 2] . 
  * Buy 1 ticket on the third day with cost 4 . The price per ticket for the remaining day is [3] . 
  * Buy 2 tickets on the fourth day with cost 6 . 

In the second test case, there is only one way to buy 8 tickets:

  * Buy 2 tickets on the first day with cost 16 . The prices per ticket for the remaining days are [8, 6, 4] . 
  * Buy 2 tickets on the second day with cost 16 . The prices per ticket for the remaining days are [8, 6] . 
  * Buy 2 tickets on the third day with cost 16 . The price per ticket for the remaining day is [8] . 
  * Buy 2 tickets on the fourth day with cost 16 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_F_NoInternetName_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Let us call an array x_1,\dots,x_m interesting if it is possible to divide the
array into k>1 parts so that [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
values from each part are equal.

More formally, you must split array x into k consecutive segments, each
element of x must belong to exactly 1 segment. Let y_1,\dots,y_k be the XOR of
elements from each part respectively. Then y_1=y_2=\dots=y_k must be
fulfilled.

For example, if x = [1, 1, 2, 3, 0] , you can split it as follows:
[\color{blue}1], [\color{green}1], [\color{red}2, \color{red}3, \color{red}0]
. Indeed \color{blue}1=\color{green}1=\color{red}2 \oplus \color{red}3\oplus
\color{red}0 .

You are given an array a_1,\dots,a_n . Your task is to answer q queries:

  * For fixed l , r , determine whether the subarray a_l,a_{l+1},\dots,a_r is interesting. 

Input

The first line contains a single integer t (1\le t\le 10^4 ) — the number of
test cases.

The first line of each test case contains two integers n and q (2 \le n \le 2
\cdot 10^5 , 1 \le q \le 2 \cdot 10^5 ) — the number of elements in the array
and the number of queries respectively.

The next line contains n integers a_1,\dots,a_n (0 \le a_i < 2^{30} ) —
elements of the array.

Each of the next q lines contains two integers l and r (1 \le l < r \le n )
describing the query.

It is guaranteed that the sum of n over all testcases does not exceed 2 \cdot
10^5 .

It is guaranteed that the sum of q over all testcases does not exceed 2 \cdot
10^5 .

Output

For each query, output "YES" if the subarray is interesting and "NO"
otherwise.

You can output "Yes" and "No" in any case (for example, the strings "yES",
"yes", and "Yes" will be recognized as correct answers).

Example

Input

    4
    
    5 5
    
    1 1 2 3 0
    
    1 5
    
    2 4
    
    3 5
    
    1 3
    
    3 4
    
    5 5
    
    1 2 3 4 5
    
    1 5
    
    2 4
    
    3 5
    
    1 3
    
    2 3
    
    7 4
    
    12 9 10 9 10 11 9
    
    1 5
    
    1 7
    
    2 6
    
    2 7
    
    11 4
    
    0 0 1 0 0 1 0 1 1 0 1
    
    1 2
    
    2 5
    
    6 9
    
    7 11

Output

    YES
    YES
    NO
    NO
    NO
    
    YES
    NO
    NO
    YES
    NO
    
    NO
    NO
    NO
    NO
    
    YES
    NO
    YES
    YES
    
Note

Explanation for the first test case:

The first query is described in the statement.

In the second query, we should divide [1,2,3] . A possible division is
[1,2],[3] , since 1\oplus 2=3 .

It can be shown that for queries 3,4,5 , the subarrays are not interesting.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1921_E_amanchandra_9_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob are playing a game on a checkered board. The board has h rows,
numbered from top to bottom, and w columns, numbered from left to right. Both
players have a chip each. Initially, Alice's chip is located at the cell with
coordinates (x_a, y_a) (row x_a , column y_a ), and Bob's chip is located at
(x_b, y_b) . It is guaranteed that the initial positions of the chips do not
coincide. Players take turns making moves, with Alice starting.

On her turn, Alice can move her chip one cell down or one cell down-right or
down-left (diagonally). Bob, on the other hand, moves his chip one cell up,
up-right, or up-left. It is not allowed to make moves that go beyond the board
boundaries.

More formally, if at the beginning of Alice's turn she is in the cell with
coordinates (x_a, y_a) , then she can move her chip to one of the cells (x_a +
1, y_a) , (x_a + 1, y_a - 1) , or (x_a + 1, y_a + 1) . Bob, on his turn, from
the cell (x_b, y_b) can move to (x_b - 1, y_b) , (x_b - 1, y_b - 1) , or (x_b
- 1, y_b + 1) . The new chip coordinates (x', y') must satisfy the conditions
1 \le x' \le h and 1 \le y' \le w .

![](https://espresso.codeforces.com/d2faa6ca73d70e765c2cc6ef0834e24c2e4a5528.png)
Example game state. Alice plays with the white chip, Bob with the black one.
Arrows indicate possible moves.

A player immediately wins if they place their chip in a cell occupied by the
other player's chip. If either player cannot make a move (Alice—if she is in
the last row, i.e. x_a = h , Bob—if he is in the first row, i.e. x_b = 1 ),
the game immediately ends in a draw.

What will be the outcome of the game if both opponents play optimally?

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the description of the test cases.

Each test case consists of a single line containing six integers h , w , x_a ,
y_a , x_b , y_b (1 \le x_a, x_b \le h \le 10^6 , 1 \le y_a, y_b \le w \le 10^9
) — the dimensions of the board and the initial positions of Alice's and Bob's
chips. It is guaranteed that either x_a \ne x_b or y_a \ne y_b .

It is guaranteed that the sum of h over all test cases does not exceed 10^6 .

Output

For each test case, output "Alice" if Alice wins, "Bob" if Bob wins, and
"Draw" if neither player can secure a victory. You can output each letter in
any case (lowercase or uppercase). For example, the strings "bOb", "bob",
"Bob", and "BOB" will be accepted as Bob's victory.

Example

Input

    12
    
    6 5 2 2 5 3
    
    4 1 2 1 4 1
    
    1 4 1 3 1 1
    
    5 5 1 4 5 2
    
    4 4 1 1 4 4
    
    10 10 1 6 10 8
    
    10 10 2 6 10 7
    
    10 10 9 1 8 1
    
    10 10 8 1 10 2
    
    10 10 1 1 2 1
    
    10 10 1 3 4 1
    
    10 10 3 1 1 1

Output

    Alice
    Bob
    Draw
    Draw
    Draw
    Alice
    Draw
    Draw
    Bob
    Alice
    Alice
    Draw
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1966_A_CodeBlazer19_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You have a hand of n cards, where each card has a number written on it, and a
fixed integer k . You can perform the following operation any number of times:

  * Choose any k cards from your hand that all have the same number. 
  * Exchange these cards for k-1 cards, each of which can have any number you choose (including the number written on the cards you just exchanged). 

Here is one possible sequence of operations for the first example case, which
has k=3 :

![](https://espresso.codeforces.com/ac8986e55ddc41e4d0ee63ac67222f97e7fcc1bf.png)

What is the minimum number of cards you can have in your hand at the end of
this process?

Input

The first line of the input contains a single integer t (1 \le t \le 500 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n and k (1 \le n \le
100 , 2 \le k \le 100 ) — the number of cards you have, and the number of
cards you exchange during each operation, respectively.

The next line of each test case contains n integers c_1, c_2, \ldots c_n (1
\le c_i \le 100 ) — the numbers written on your cards.

Output

For each test case, output a single integer — the minimum number of cards you
can have left in your hand after any number of operations.

Example

Input

    7
    
    5 3
    
    4 1 1 4 4
    
    1 10
    
    7
    
    7 2
    
    4 2 1 100 5 2 3
    
    10 4
    
    1 1 1 1 1 1 1 1 1 1
    
    5 2
    
    3 8 1 48 7
    
    6 2
    
    10 20 30 10 20 40
    
    6 3
    
    10 20 30 10 20 40

Output

    2
    1
    1
    3
    5
    1
    6
    
Note

The first example case corresponds to the picture above. The sequence of
operations displayed there is optimal, so the answer is 2 .

In the second example case, no operations can be performed, so the answer is 1
.

In the fourth example case, you can repeatedly select 4 cards numbered with 1
and replace them with 3 cards numbered with 1 , until there are 3 cards left.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1954_B_Ahsan612_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Let's call an array a beautiful if you can make all its elements the same by
using the following operation an arbitrary number of times (possibly, zero):

  * choose an index i (2 \le i \le |a| - 1 ) such that a_{i - 1} = a_{i + 1} , and replace a_i with a_{i - 1} . 

You are given a beautiful array a_1, a_2, \dots, a_n . What is the minimum
number of elements you have to remove from it in order for it to stop being
beautiful? Swapping elements is prohibited. If it is impossible to do so, then
output -1.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 3
\cdot 10^5 ).

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le n ).

Additional constraints on the input:

  * in every test case, the given array a is beautiful; 
  * the sum of n over all test cases does not exceed 3 \cdot 10^5 . 

Output

For each test case, output a single integer — the minimum number of elements
you have to remove from the array a in order for it to stop being beautiful.
If it is impossible, then output -1.

Example

Input

    4
    
    3
    
    2 2 2
    
    5
    
    1 2 1 2 1
    
    1
    
    1
    
    7
    
    3 3 3 5 3 3 3

Output

    -1
    1
    -1
    3
    
Note

In the first testcase, it is impossible to modify the array in such a way that
it stops being beautiful. An array consisting of identical numbers will remain
beautiful no matter how many numbers we remove from it.

In the second testcase, you can remove the number at the index 5 , for
example.

The resulting array will be [1, 2, 1, 2] . Let's check if it is beautiful. Two
operations are available:

  * Choose i = 2 : the array becomes [1, 1, 1, 2] . No more operations can be applied to it, and the numbers are not all the same. 
  * Choose i = 3 instead: the array becomes [1, 2, 2, 2] . No more operations can be applied to it either, and the numbers are still not all the same. 

Thus, the array [1, 2, 1, 2] is not beautiful.

In the fourth testcase, you can remove the first three elements, for example.
The resulting array [5, 3, 3, 3] is not beautiful.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1920_A_mateusvrs_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alex is solving a problem. He has n constraints on what the integer k can be.
There are three types of constraints:

  1. k must be greater than or equal to some integer x ; 
  2. k must be less than or equal to some integer x ; 
  3. k must be not equal to some integer x . 

Help Alex find the number of integers k that satisfy all n constraints. It is
guaranteed that the answer is finite (there exists at least one constraint of
type 1 and at least one constraint of type 2 ). Also, it is guaranteed that no
two constraints are the exact same.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \leq n \leq
100 ) — the number of constraints.

The following n lines describe the constraints. Each line contains two
integers a and x (a \in \\{1,2,3\\}, \, 1 \leq x \leq 10^9 ). a denotes the
type of constraint. If a=1 , k must be greater than or equal to x . If a=2 , k
must be less than or equal to x . If a=3 , k must be not equal to x .

It is guaranteed that there is a finite amount of integers satisfying all n
constraints (there exists at least one constraint of type 1 and at least one
constraint of type 2 ). It is also guaranteed that no two constraints are the
exact same (in other words, all pairs (a, x) are distinct).

Output

For each test case, output a single integer — the number of integers k that
satisfy all n constraints.

Example

Input

    6
    
    4
    
    1 3
    
    2 10
    
    3 1
    
    3 5
    
    2
    
    1 5
    
    2 4
    
    10
    
    3 6
    
    3 7
    
    1 2
    
    1 7
    
    3 100
    
    3 44
    
    2 100
    
    2 98
    
    1 3
    
    3 99
    
    6
    
    1 5
    
    2 10
    
    1 9
    
    2 2
    
    3 2
    
    3 9
    
    5
    
    1 1
    
    2 2
    
    3 1
    
    3 2
    
    3 3
    
    6
    
    1 10000
    
    2 900000000
    
    3 500000000
    
    1 100000000
    
    3 10000
    
    3 900000001

Output

    7
    0
    90
    0
    0
    800000000
    
Note

In the first test case, k \geq 3 and k \leq 10 . Furthermore, k \neq 1 and k
\neq 5 . The possible integers k that satisfy the constraints are
3,4,6,7,8,9,10 . So the answer is 7 .

In the second test case, k \ge 5 and k \le 4 , which is impossible. So the
answer is 0 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1955_C_Ben_Fredj_Mehdi_96.67%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1943_C_vas0x59_100%
ERROR - Error: unsupported statement type: <ast.Nonlocal object at 0x79a60df9b460> nonlocal n

DEBUG - Start Task 1921_D_Jubayer934_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Petya has an array a_i of n integers. His brother Vasya became envious and
decided to make his own array of n integers.

To do this, he found m integers b_i (m\ge n ), and now he wants to choose some
n integers of them and arrange them in a certain order to obtain an array c_i
of length n .

To avoid being similar to his brother, Vasya wants to make his array as
different as possible from Petya's array. Specifically, he wants the total
difference D = \sum_{i=1}^{n} |a_i - c_i| to be as large as possible.

Help Vasya find the maximum difference D he can obtain.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 100 ) — the number of test cases. This is followed by a
description of the test cases.

The first line of each test case contains two integers n and m (1\le n\le m\le
2 \cdot 10^5 ).

The second line of each test case contains n integers a_i (1\le a_i\le 10^9 ).
The third line of each test case contains m integers b_i (1\le b_i\le 10^9 ).

It is guaranteed that in a test, the sum of m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the maximum total difference D
that can be obtained.

Example

Input

    9
    
    4 6
    
    6 1 2 4
    
    3 5 1 7 2 3
    
    3 4
    
    1 1 1
    
    1 1 1 1
    
    5 5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    2 6
    
    5 8
    
    8 7 5 8 2 10
    
    2 2
    
    4 1
    
    9 6
    
    4 6
    
    8 10 6 4
    
    3 10 6 1 8 9
    
    3 5
    
    6 5 2
    
    1 7 9 7 2
    
    5 5
    
    9 10 6 3 7
    
    5 9 2 3 9
    
    1 6
    
    3
    
    2 7 10 1 1 5

Output

    16
    0
    12
    11
    10
    23
    15
    25
    7
    
Note

In the first example, Vasya can, for example, create the array (1, 5, 7, 2) .
Then the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .

In the second example, all the integers available to Vasya are equal to 1, so
he can only create the array (1, 1, 1) , for which the difference D = 0 .

In the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)
. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =
4+2+0+2+4 = 12 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1922_C_EmperorDogeAV_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There are n cities located on the number line, the i -th city is in the point
a_i . The coordinates of the cities are given in ascending order, so a_1 < a_2
< \dots < a_n .

The distance between two cities x and y is equal to |a_x - a_y| .

For each city i , let's define the closest city j as the city such that the
distance between i and j is not greater than the distance between i and each
other city k . For example, if the cities are located in points [0, 8, 12, 15,
20] , then:

  * the closest city to the city 1 is the city 2 ; 
  * the closest city to the city 2 is the city 3 ; 
  * the closest city to the city 3 is the city 4 ; 
  * the closest city to the city 4 is the city 3 ; 
  * the closest city to the city 5 is the city 4 . 

The cities are located in such a way that for every city, the closest city is
unique. For example, it is impossible for the cities to be situated in points
[1, 2, 3] , since this would mean that the city 2 has two closest cities (1
and 3 , both having distance 1 ).

You can travel between cities. Suppose you are currently in the city x . Then
you can perform one of the following actions:

  * travel to any other city y , paying |a_x - a_y| coins; 
  * travel to the city which is the closest to x , paying 1 coin. 

You are given m queries. In each query, you will be given two cities, and you
have to calculate the minimum number of coins you have to spend to travel from
one city to the other city.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

Each test case is given in the following format:

  * the first line contains one integer n (2 \le n \le 10^5 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_1 < a_2 < \dots < a_n \le 10^9 ); 
  * the third line contains one integer m (1 \le m \le 10^5 ); 
  * then m lines follow; the i -th of them contains two integers x_i and y_i (1 \le x_i, y_i \le n ; x_i \ne y_i ), denoting that in the i -th query, you have to calculate the minimum number of coins you have to spend to travel from the city x_i to the city y_i . 

Additional constraints on the input:

  * in every test case, for each city, the closest city is determined uniquely; 
  * the sum of n over all test cases does not exceed 10^5 ; 
  * the sum of m over all test cases does not exceed 10^5 . 

Output

For each query, print one integer — the minimum number of coins you have to
spend.

Example

Input

    1
    
    5
    
    0 8 12 15 20
    
    5
    
    1 4
    
    1 5
    
    3 4
    
    3 2
    
    5 1

Output

    3
    8
    1
    4
    14
    
Note

Let's consider the first two queries in the example from the statement:

  * in the first query, you are initially in the city 1 . You can travel to the closest city (which is the city 2 ), paying 1 coin. Then you travel to the closest city (which is the city 3 ) again, paying 1 coin. Then you travel to the closest city (which is the city 4 ) again, paying 1 coin. In total, you spend 3 coins to get from the city 1 to the city 4 ; 
  * in the second query, you can use the same way to get from the city 1 to the city 4 , and then spend 5 coins to travel from the city 4 to the city 5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1971_D_DSKroc_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given a binary string^{\dagger} . Please find the minimum number of
pieces you need to cut it into, so that the resulting pieces can be rearranged
into a sorted binary string.

![](https://espresso.codeforces.com/76039f9769ba94c1817dbbc5e1fb1b5e4f60950f.png)

Note that:

  * each character must lie in exactly one of the pieces; 
  * the pieces must be contiguous substrings of the original string; 
  * you must use all the pieces in the rearrangement. 

^{\dagger} A binary string is a string consisting of characters \texttt{0} and
\texttt{1} . A sorted binary string is a binary string such that all
characters \texttt{0} come before all characters \texttt{1} .

Input

The first line contains a single integer t (1 \leq t \leq 500 ) — the number
of test cases.

The only line of each test case contains a single string s (1 \leq |s| \leq
500 ) consisting of characters \texttt{0} and \texttt{1} , where |s| denotes
the length of the string s .

Output

For each test case, output a single integer — the minimum number of pieces
needed to be able to rearrange the string into a sorted binary string.

Example

Input

    6
    
    11010
    
    00000000
    
    1
    
    10
    
    0001111
    
    0110

Output

    3
    1
    1
    2
    1
    2
    
Note

The first test case is pictured in the statement. It can be proven that you
can't use fewer than 3 pieces.

In the second and third test cases, the binary string is already sorted, so
only 1 piece is needed.

In the fourth test case, you need to make a single cut between the two
characters and rearrange them to make the string \texttt{01} .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1936_A_mihir111p_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * "? a b c d" 

After that, you receive:

  * "<" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * "=" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * ">" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * "! i j" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query "? 0 2 3 1", the jury return "<" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query "? 1 1 2 3", the jury return "=" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query "? 1 2 0 3", the jury return ">" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1948_E_123gjweq2_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two integers, n and k . There is a graph on n vertices, numbered
from 1 to n , which initially has no edges.

You have to assign each vertex an integer; let a_i be the integer on the
vertex i . All a_i should be distinct integers from 1 to n .

After assigning integers, for every pair of vertices (i, j) , you add an edge
between them if |i - j| + |a_i - a_j| \le k .

Your goal is to create a graph which can be partitioned into the minimum
possible (for the given values of n and k ) number of cliques. Each vertex of
the graph should belong to exactly one clique. Recall that a clique is a set
of vertices such that every pair of vertices in it are connected with an edge.

Since BledDest hasn't really brushed his programming skills up, he can't solve
the problem "given a graph, partition it into the minimum number of cliques".
So we also ask you to print the partition itself.

Input

The first line contains one integer t (1 \le t \le 1600 ) — the number of test
cases.

Each test case consists of one line containing two integers n and k (2 \le n
\le 40 ; 1 \le k \le 2n ).

Output

For each test case, print three lines:

  * the first line should contain n distinct integers a_1, a_2, \dots, a_n (1 \le a_i \le n ) — the values you assign to the vertices; 
  * the second line should contain one integer q (1 \le q \le n ) — the number of cliques you partition the graph into; 
  * the third line should contain n integers c_1, c_2, \dots, c_n (1 \le c_i \le q ) — the partition of the graph into cliques. Where two vertices u and v are in the same clique if c_u = c_v . 

If there are multiple answers, print any of them.

Example

Input

    3
    
    2 3
    
    5 4
    
    8 16

Output

    2 1
    1
    1 1
    3 1 5 2 4
    2
    1 1 2 1 2
    1 2 3 4 5 6 7 8
    1
    1 1 1 1 1 1 1 1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1929_A_mooIi_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Sasha decided to give his girlfriend an array a_1, a_2, \ldots, a_n . He found
out that his girlfriend evaluates the beauty of the array as the sum of the
values (a_i - a_{i - 1}) for all integers i from 2 to n .

Help Sasha and tell him the maximum beauty of the array a that he can obtain,
if he can rearrange its elements in any way.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \leq n \leq
100 ) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\leq a_i \leq 10^9 ) — the elements of the array a .

Output

For each test case, output a single integer — the maximum beauty of the array
a that can be obtained.

Example

Input

    5
    
    3
    
    2 1 3
    
    3
    
    69 69 69
    
    5
    
    100 54 80 43 90
    
    4
    
    3 4 3 3
    
    2
    
    2 1

Output

    2
    0
    57
    1
    1
    
Note

In the first test case, the elements of the array a can be rearranged to make
a = [1, 2, 3] . Then its beauty will be equal to (a_2 - a_1) + (a_3 - a_2) =
(2 - 1) + (3 - 2) = 2 .

In the second test case, there is no need to rearrange the elements of the
array a . Then its beauty will be equal to 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_B_MALIK_ANTUPARTHI_8.33%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_F_parth7042_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Let us call an array x_1,\dots,x_m interesting if it is possible to divide the
array into k>1 parts so that [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
values from each part are equal.

More formally, you must split array x into k consecutive segments, each
element of x must belong to exactly 1 segment. Let y_1,\dots,y_k be the XOR of
elements from each part respectively. Then y_1=y_2=\dots=y_k must be
fulfilled.

For example, if x = [1, 1, 2, 3, 0] , you can split it as follows:
[\color{blue}1], [\color{green}1], [\color{red}2, \color{red}3, \color{red}0]
. Indeed \color{blue}1=\color{green}1=\color{red}2 \oplus \color{red}3\oplus
\color{red}0 .

You are given an array a_1,\dots,a_n . Your task is to answer q queries:

  * For fixed l , r , determine whether the subarray a_l,a_{l+1},\dots,a_r is interesting. 

Input

The first line contains a single integer t (1\le t\le 10^4 ) — the number of
test cases.

The first line of each test case contains two integers n and q (2 \le n \le 2
\cdot 10^5 , 1 \le q \le 2 \cdot 10^5 ) — the number of elements in the array
and the number of queries respectively.

The next line contains n integers a_1,\dots,a_n (0 \le a_i < 2^{30} ) —
elements of the array.

Each of the next q lines contains two integers l and r (1 \le l < r \le n )
describing the query.

It is guaranteed that the sum of n over all testcases does not exceed 2 \cdot
10^5 .

It is guaranteed that the sum of q over all testcases does not exceed 2 \cdot
10^5 .

Output

For each query, output "YES" if the subarray is interesting and "NO"
otherwise.

You can output "Yes" and "No" in any case (for example, the strings "yES",
"yes", and "Yes" will be recognized as correct answers).

Example

Input

    4
    
    5 5
    
    1 1 2 3 0
    
    1 5
    
    2 4
    
    3 5
    
    1 3
    
    3 4
    
    5 5
    
    1 2 3 4 5
    
    1 5
    
    2 4
    
    3 5
    
    1 3
    
    2 3
    
    7 4
    
    12 9 10 9 10 11 9
    
    1 5
    
    1 7
    
    2 6
    
    2 7
    
    11 4
    
    0 0 1 0 0 1 0 1 1 0 1
    
    1 2
    
    2 5
    
    6 9
    
    7 11

Output

    YES
    YES
    NO
    NO
    NO
    
    YES
    NO
    NO
    YES
    NO
    
    NO
    NO
    NO
    NO
    
    YES
    NO
    YES
    YES
    
Note

Explanation for the first test case:

The first query is described in the statement.

In the second query, we should divide [1,2,3] . A possible division is
[1,2],[3] , since 1\oplus 2=3 .

It can be shown that for queries 3,4,5 , the subarrays are not interesting.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1936_A_vikenscars_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * "? a b c d" 

After that, you receive:

  * "<" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * "=" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * ">" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * "! i j" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query "? 0 2 3 1", the jury return "<" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query "? 1 1 2 3", the jury return "=" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query "? 1 2 0 3", the jury return ">" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_B_ashikarjen_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1925_A_aryui_2902_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two positive integers n and k .

Your task is to find a string s such that all possible strings of length n
that can be formed using the first k lowercase English alphabets occur as a
subsequence of s .

If there are multiple answers, print the one with the smallest length. If
there are still multiple answers, you may print any of them.

Note: A string a is called a subsequence of another string b if a can be
obtained by deleting some (possibly zero) characters from b without changing
the order of the remaining characters.

Input

The first line of input contains a single integer t (1\leq t\leq 676 )
denoting the number of test cases.

Each test case consists of a single line of input containing two integers n
(1\leq n\leq 26 ) and k (1\leq k\leq 26 ).

Output

For each test case, print a single line containing a single string s which
satisfies the above property. If there are multiple answers, print the one
with the smallest length. If there are still multiple answers, you may print
any of them.

Example

Input

    4
    
    1 2
    
    2 1
    
    2 2
    
    2 3

Output

    ab
    aa
    baab
    abcbac
    
Note

For the first test case, there are two strings of length 1 which can be formed
using the first 2 lowercase English alphabets, and they are present in s as a
subsequence as follows:

  * \texttt{a}: {\color{red}{\texttt{a}}}\texttt{b} 
  * \texttt{b}: \texttt{a}{\color{red}{\texttt{b}}} 

For the second test case, there is only one string of length 2 which can be
formed using the first lowercase English alphabet, and it is present in s as a
subsequence as follows:

  * \texttt{aa}: {\color{red}{\texttt{aa}}} 

For the third test case, there are 4 strings of length 2 which can be formed
using the first 2 lowercase English alphabets, and they are present in s as a
subsequence as follows:

  * \texttt{aa}: \texttt{b}{\color{red}{\texttt{aa}}}\texttt{b} 
  * \texttt{ab}: \texttt{ba}{\color{red}{\texttt{ab}}} 
  * \texttt{ba}: {\color{red}{\texttt{ba}}}\texttt{ab} 
  * \texttt{bb}: {\color{red}{\texttt{b}}}\texttt{aa}{\color{red}{\texttt{b}}} 

For the fourth test case, there are 9 strings of length 2 which can be formed
using the first 3 lowercase English alphabets, and they are present in s as a
subsequence as follows:

  * \texttt{aa}: {\color{red}{\texttt{a}}}\texttt{bcb}{\color{red}{\texttt{a}}}\texttt{c} 
  * \texttt{ab}: {\color{red}{\texttt{ab}}}\texttt{cbac} 
  * \texttt{ac}: \texttt{abcb}{\color{red}{\texttt{ac}}} 
  * \texttt{ba}: \texttt{abc}{\color{red}{\texttt{ba}}}\texttt{c} 
  * \texttt{bb}: \texttt{a}{\color{red}{\texttt{b}}}\texttt{c}{\color{red}{\texttt{b}}}\texttt{ac} 
  * \texttt{bc}: \texttt{a}{\color{red}{\texttt{bc}}}\texttt{bac} 
  * \texttt{ca}: \texttt{ab}{\color{red}{\texttt{c}}}\texttt{b}{\color{red}{\texttt{a}}}\texttt{c} 
  * \texttt{cb}: \texttt{ab}{\color{red}{\texttt{cb}}}\texttt{ac} 
  * \texttt{cc}: \texttt{ab}{\color{red}{\texttt{c}}}\texttt{ba}{\color{red}{\texttt{c}}}
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1971_A_yixiangwahaha_50.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two integers x and y .

Output two integers: the minimum of x and y , followed by the maximum of x and
y .

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The only line of each test case contains two space-separated integers x and y
(0 \leq x, y \leq 9 ).

Output

For each test case, output two integers: the minimum of x and y , followed by
the maximum of x and y .

Example

Input

    10
    
    1 9
    
    8 4
    
    1 4
    
    3 4
    
    2 0
    
    2 4
    
    6 9
    
    3 3
    
    0 0
    
    9 9

Output

    1 9
    4 8
    1 4
    3 4
    0 2
    2 4
    6 9
    3 3
    0 0
    9 9
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1970_C1_PitchBlease_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: This is the easy version of the problem. The difference in this version is
that t=1 and we work on an array-like tree.

Ron and Hermione are playing a game on a tree of n nodes that are initially
inactive. This tree is special because it has exactly two leaves. It can thus
be seen as an array. The game consists of t rounds, each of which starts with
a stone on exactly one node, which is considered as activated. A move consists
of picking an inactive neighbor of the node with a stone on it and moving the
stone there (thus activating this neighbor). Ron makes the first move, after
which he alternates with Hermione until no valid move is available. The player
that cannot make a move loses the round. If both players play optimally, who
wins each round of this game?

Note that all the rounds are played with the same tree; only the starting node
changes. Moreover, after each round, all active nodes are considered inactive
again.

Input

The first line contains integers n (2 \leq n \leq 2\times 10^5 ), t (t=1 ),
the number of nodes in the tree and the number of rounds, respectively.

The next n-1 lines contain two integers 1 \leq u, v \leq n each, corresponding
to an edge of the tree. It is guaranteed that the tree has exactly two leaves.

The next line contains t integers 1 \leq u_1 , \dots, u_t \leq n ,
corresponding to the node where the stone is initially put.

Output

The output consists of t=1 line which is either "Ron" or "Hermione".

Examples

Input

    3 1
    
    2 3
    
    3 1
    
    3

Output

    Ron
    
Input

    5 1
    
    1 2
    
    2 3
    
    3 4
    
    4 5
    
    5

Output

    Hermione
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1926_B_saydigulamov_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Vladislav has a binary square grid of n \times n cells. A triangle or a square
is drawn on the grid with symbols \texttt{1} . As he is too busy being cool,
he asks you to tell him which shape is drawn on the grid.

  * A triangle is a shape consisting of k (k>1 ) consecutive rows, where the i -th row has 2 \cdot i-1 consecutive characters \texttt{1} , and the central 1s are located in one column. An upside down triangle is also considered a valid triangle (but not rotated by 90 degrees).

![](https://espresso.codeforces.com/6528b67bef9e7966366c8ff95b57ba96a1f44217.png)
Two left pictures contain examples of triangles: k=4 , k=3 . The two right
pictures don't contain triangles.

  * A square is a shape consisting of k (k>1 ) consecutive rows, where the i -th row has k consecutive characters \texttt{1} , which are positioned at an equal distance from the left edge of the grid.

![](https://espresso.codeforces.com/4b06bb9ff8f408edc96077ace0d5e299065a3c50.png)
Examples of two squares: k=2 , k=4 .

For the given grid, determine the type of shape that is drawn on it.

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The first line of each test case contains a single integer n (2 \leq n \leq 10
) — the size of the grid.

The next n lines each contain n characters \texttt{0} or \texttt{1} .

The grid contains exactly one triangle or exactly one square that contains all
the \texttt{1} s in the grid. It is guaranteed that the size of the triangle
or square is greater than 1 (i.e., the shape cannot consist of exactly one 1).

Output

For each test case, output "SQUARE" if all the \texttt{1} s in the grid form a
square, and "TRIANGLE" otherwise (without quotes).

Example

Input

    6
    
    3
    
    000
    
    011
    
    011
    
    4
    
    0000
    
    0000
    
    0100
    
    1110
    
    2
    
    11
    
    11
    
    5
    
    00111
    
    00010
    
    00000
    
    00000
    
    00000
    
    10
    
    0000000000
    
    0000000000
    
    0000000000
    
    0000000000
    
    0000000000
    
    1111111110
    
    0111111100
    
    0011111000
    
    0001110000
    
    0000100000
    
    3
    
    111
    
    111
    
    111

Output

    SQUARE
    TRIANGLE
    SQUARE
    TRIANGLE
    TRIANGLE
    SQUARE
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1921_D_ms_22_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Petya has an array a_i of n integers. His brother Vasya became envious and
decided to make his own array of n integers.

To do this, he found m integers b_i (m\ge n ), and now he wants to choose some
n integers of them and arrange them in a certain order to obtain an array c_i
of length n .

To avoid being similar to his brother, Vasya wants to make his array as
different as possible from Petya's array. Specifically, he wants the total
difference D = \sum_{i=1}^{n} |a_i - c_i| to be as large as possible.

Help Vasya find the maximum difference D he can obtain.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 100 ) — the number of test cases. This is followed by a
description of the test cases.

The first line of each test case contains two integers n and m (1\le n\le m\le
2 \cdot 10^5 ).

The second line of each test case contains n integers a_i (1\le a_i\le 10^9 ).
The third line of each test case contains m integers b_i (1\le b_i\le 10^9 ).

It is guaranteed that in a test, the sum of m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the maximum total difference D
that can be obtained.

Example

Input

    9
    
    4 6
    
    6 1 2 4
    
    3 5 1 7 2 3
    
    3 4
    
    1 1 1
    
    1 1 1 1
    
    5 5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    2 6
    
    5 8
    
    8 7 5 8 2 10
    
    2 2
    
    4 1
    
    9 6
    
    4 6
    
    8 10 6 4
    
    3 10 6 1 8 9
    
    3 5
    
    6 5 2
    
    1 7 9 7 2
    
    5 5
    
    9 10 6 3 7
    
    5 9 2 3 9
    
    1 6
    
    3
    
    2 7 10 1 1 5

Output

    16
    0
    12
    11
    10
    23
    15
    25
    7
    
Note

In the first example, Vasya can, for example, create the array (1, 5, 7, 2) .
Then the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .

In the second example, all the integers available to Vasya are equal to 1, so
he can only create the array (1, 1, 1) , for which the difference D = 0 .

In the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)
. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =
4+2+0+2+4 = 12 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1967_A_yogurtraj_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You have some cards. An integer between 1 and n is written on each card:
specifically, for each i from 1 to n , you have a_i cards which have the
number i written on them.

There is also a shop which contains unlimited cards of each type. You have k
coins, so you can buy k new cards in total, and the cards you buy can contain
any integer between 1 and n .

After buying the new cards, you rearrange all your cards in a line. The score
of a rearrangement is the number of (contiguous) subarrays of length n which
are a permutation of [1, 2, \ldots, n] . What's the maximum score you can get?

Input

Each test contains multiple test cases. The first line contains the number of
test cases t\ (1\le t\le 100) . The description of the test cases follows.

The first line of each test case contains two integers n , k (1\le n \le 2
\cdot 10^5 , 0\le k \le 10^{12} ) — the number of distinct types of cards and
the number of coins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^{12} ) — the number of cards of type i you have at the
beginning.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, output a single line containing an integer: the maximum
score you can get.

Example

Input

    8
    
    1 10
    
    1
    
    2 4
    
    8 4
    
    3 4
    
    6 1 8
    
    3 9
    
    7 6 2
    
    5 3
    
    6 6 7 4 6
    
    9 7
    
    7 6 1 7 6 2 4 3 3
    
    10 10
    
    1 3 1 2 1 9 3 5 7 5
    
    9 8
    
    5 8 7 5 1 3 2 9 8

Output

    11
    15
    15
    22
    28
    32
    28
    36
    
Note

In the first test case, the final (and only) array we can get is [1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1] (including 11 single 1 s), which contains 11 subarrays
consisting of a permutation of [1] .

In the second test case, we can buy 0 cards of type 1 and 4 cards of type 2 ,
and then we rearrange the cards as following: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
1, 2, 1, 2, 1, 2] . There are 8 subarrays equal to [1, 2] and 7 subarrays
equal to [2, 1] , which make a total of 15 subarrays which are a permutation
of [1, 2] . It can also be proved that this is the maximum score we can get.

In the third test case, one of the possible optimal rearrangements is [3, 3,
1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1955_C_dreamyc_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1972_D1_NS3081992_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1926_D_231414_100%
ERROR - Error: unsupported statement type: <ast.Delete object at 0x79a60e28d210> del dic[i]

DEBUG - Start Task 1923_A_Athena___0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There is a ribbon divided into n cells, numbered from 1 to n from left to
right. Each cell either contains a chip or is free.

You can perform the following operation any number of times (possibly zero):
choose a chip and move it to the closest free cell to the left. You can choose
any chip that you want, provided that there is at least one free cell to the
left of it. When you move the chip, the cell where it was before the operation
becomes free.

Your goal is to move the chips in such a way that they form a single block,
without any free cells between them. What is the minimum number of operations
you have to perform?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of cells; 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_i \le 1 ); a_i = 0 means that the i -th cell is free; a_i = 1 means that the i -th cell contains a chip. 

Additional constraint on the input: in each test case, at least one cell
contains a chip.

Output

For each test case, print one integer — the minimum number of operations you
have to perform so that all chips form a single block without any free cells
between them.

Example

Input

    5
    
    8
    
    0 1 1 1 0 1 1 0
    
    6
    
    0 1 0 0 0 0
    
    6
    
    1 1 1 1 1 1
    
    5
    
    1 0 1 0 1
    
    9
    
    0 1 1 0 0 0 1 1 0

Output

    1
    0
    0
    2
    3
    
Note

In the first example, you can perform the operation on the chip in the 7 -th
cell. The closest free cell to the left is the 5 -th cell, so it moves there.
After that, all chips form a single block.

In the second example, all chips are already in a single block. Same for the
third example.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1931_B_DevrajCode_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There are n containers of water lined up, numbered from left to right from 1
to n . Each container can hold any amount of water; initially, the i -th
container contains a_i units of water. The sum of a_i is divisible by n .

You can apply the following operation any (possibly zero) number of times:
pour any amount of water from the i -th container to the j -th container,
where i must be less than j (i.e. i<j ). Any index can be chosen as i or j any
number of times.

Determine whether it is possible to make the amount of water in all containers
the same using this operation.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of containers with water.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i \le 10^9 ) — the amounts of water in the containers. It is guaranteed
that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the
sum of a_i is divisible by n .

It is guaranteed that the sum of n over all test cases in the input does not
exceed 2 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output "YES" if it is possible to make the amount of water in all
containers the same using the described operation. Otherwise, output "NO".

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    6
    
    1
    
    43
    
    2
    
    1 3
    
    5
    
    4 5 2 1 3
    
    3
    
    1 2 3
    
    7
    
    4 5 5 0 6 4 4
    
    7
    
    6 5 5 1 3 4 4

Output

    YES
    NO
    YES
    NO
    NO
    YES
    
Note

In the third test case of the example (a=[4, 5, 2, 1, 3] ), you can proceed as
follows:

  * pour 1 unit of water from the first vessel to the fourth, then a=[3, 5, 2, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the third, then a=[3, 4, 3, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the fourth, then a=[3, 3, 3, 3, 3] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1932_A_5styui_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: During your journey through computer universes, you stumbled upon a very
interesting world. It is a path with n consecutive cells, each of which can
either be empty, contain thorns, or a coin. In one move, you can move one or
two cells along the path, provided that the destination cell does not contain
thorns (and belongs to the path). If you move to the cell with a coin, you
pick it up.

![](https://espresso.codeforces.com/34bd88a4aba4a1ae98e5681455c4a47900b7b9a8.png)
Here, green arrows correspond to legal moves, and the red arrow corresponds to
an illegal move.

You want to collect as many coins as possible. Find the maximum number of
coins you can collect in the discovered world if you start in the leftmost
cell of the path.

Input

The first line of input contains a single integer t (1 \le t \le 1000 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the length of the path.

The second line of each test case contains a string of n characters, the
description of the path. The character '.' denotes an empty cell, '@' denotes
a cell with a coin, and '*' denotes a cell with thorns. It is guaranteed that
the first cell is empty.

Output

For each test case, output a single integer, the maximum number of coins you
can collect.

Example

Input

    3
    
    10
    
    .@@*@.**@@
    
    5
    
    .@@@@
    
    15
    
    .@@..@***..@@@*

Output

    3
    4
    3
    
Note

The picture for the first example is in the problem statement.

Here is the picture for the second example:

![](https://espresso.codeforces.com/68fd7116585f37e79535fbc164a552cc8e148b75.png)

And here is the picture for the third example:

![](https://espresso.codeforces.com/1695fc45669a1bf1d6e1b3d4901cdd3cda38273c.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1973_A_rcd_25.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_B_MALIK_ANTUPARTHI_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1942_C1_gentleman_007_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: [Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the easy version of the problem. The only difference between the two
versions is the constraint on y . In this version y = 0 . You can make hacks
only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , y = 0 ) — the number
of sides of the polygon, number of vertices Bessie has chosen, and the maximum
number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 0
    
    1 6 2 5
    
    8 8 0
    
    1 3 2 5 4 6 7 8
    
    4 2 0
    
    1 3

Output

    2
    6
    2
    
Note

In test cases 1 , 2 and 3 , you can get 2 , 6 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that can be used, the blue lines represent
diagonals that are drawn, and the red numbers represent triangles that are
counted.

![](https://espresso.codeforces.com/80282d636b83d4002ec89755d465b4adb37b9cfb.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1922_A_Abdelrahman_A_14.29%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given an integer n and three strings a, b, c , each consisting of n
lowercase Latin letters.

Let a template be a string t consisting of n lowercase and/or uppercase Latin
letters. The string s matches the template t if the following conditions hold
for all i from 1 to n :

  * if the i -th letter of the template is lowercase, then s_i must be the same as t_i ; 
  * if the i -th letter of the template is uppercase, then s_i must be different from the lowercase version of t_i . For example, if there is a letter 'A' in the template, you cannot use the letter 'a' in the corresponding position of the string. 

Accordingly, the string doesn't match the template if the condition doesn't
hold for at least one i .

Determine whether there exists a template t such that the strings a and b
match it, while the string c does not.

Input

The first line contains an integer t (1 \le t \le 1000 ) — the number of test
cases.

The first line of each test case contains an integer n (1 \le n \le 20 ) — the
length of the given strings.

The next three lines contain the strings a, b and c . Each string consists of
exactly n lowercase Latin letters.

Output

For each testcase, print "YES" if there exists a template t such that the
strings a and b match it, while the string c does not. Otherwise, print "NO".

Example

Input

    4
    
    1
    
    a
    
    b
    
    c
    
    2
    
    aa
    
    bb
    
    aa
    
    10
    
    mathforces
    
    luckforces
    
    adhoccoder
    
    3
    
    acc
    
    abd
    
    abc

Output

    YES
    NO
    YES
    NO
    
Note

In the first test case, you can use the template "C". The first letter of
strings a and b differ from 'c', so they match the template. The first letter
of string c equals 'c', so it doesn't match.

In the third test case, you can use the template "CODEforces".
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1920_B_Dehong2019_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1946_C__Safar_100%
ERROR - Error: unsupported statement type: <ast.Delete object at 0x79a60e17b7c0> del d[x]

DEBUG - Start Task 1973_A_CpError123_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1922_E_lucky__389_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Let's recall that an increasing subsequence of the array a is a sequence that
can be obtained from it by removing some elements without changing the order
of the remaining elements, and the remaining elements are strictly increasing
(i. e a_{b_1} < a_{b_2} < \dots < a_{b_k} and b_1 < b_2 < \dots < b_k ). Note
that an empty subsequence is also increasing.

You are given a positive integer X . Your task is to find an array of integers
of length at most 200 , such that it has exactly X increasing subsequences, or
report that there is no such array. If there are several answers, you can
print any of them.

If two subsequences consist of the same elements, but correspond to different
positions in the array, they are considered different (for example, the array
[2, 2] has two different subsequences equal to [2] ).

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

The only line of each test case contains a single integer X (2 \le X \le
10^{18} ).

Output

For each query, print the answer to it. If it is impossible to find the
required array, print -1 on the first line. Otherwise, print a positive
integer n on the first line — the length of the array. On the second line,
print n integers — the required array itself. If there are several answers,
you can print any of them. All elements of the array should be in the range
[-10^9; 10^9] .

Example

Input

    4
    
    2
    
    5
    
    13
    
    37

Output

    1
    0
    3
    0 1 0
    5
    2 2 3 4 2
    7
    -1 -1 0 0 2 3 -1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1944_A_michi330_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There are n islands, numbered 1, 2, \ldots, n . Initially, every pair of
islands is connected by a bridge. Hence, there are a total of \frac{n (n -
1)}{2} bridges.

Everule lives on island 1 and enjoys visiting the other islands using bridges.
Dominater has the power to destroy at most k bridges to minimize the number of
islands that Everule can reach using (possibly multiple) bridges.

Find the minimum number of islands (including island 1 ) that Everule can
visit if Dominater destroys bridges optimally.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers n and k (1 \le
n \le 100 , 0 \le k \le \frac{n \cdot (n - 1)}{2} ).

Output

For each test case, output the minimum number of islands that Everule can
visit if Dominater destroys bridges optimally.

Example

Input

    6
    
    2 0
    
    2 1
    
    4 1
    
    5 10
    
    5 3
    
    4 4

Output

    2
    1
    4
    1
    5
    1
    
Note

In the first test case, since no bridges can be destroyed, all the islands
will be reachable.

In the second test case, you can destroy the bridge between islands 1 and 2 .
Everule will not be able to visit island 2 but can still visit island 1 .
Therefore, the total number of islands that Everule can visit is 1 .

In the third test case, Everule always has a way of reaching all islands
despite what Dominater does. For example, if Dominater destroyed the bridge
between islands 1 and 2 , Everule can still visit island 2 by traveling by 1
\to 3 \to 2 as the bridges between 1 and 3 , and between 3 and 2 are not
destroyed.

In the fourth test case, you can destroy all bridges since k = \frac{n \cdot
(n - 1)}{2} . Everule will be only able to visit 1 island (island 1 ).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1931_C_Rohidul_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You have an array a of n integers.

You can no more than once apply the following operation: select three integers
i , j , x (1 \le i \le j \le n ) and assign all elements of the array with
indexes from i to j the value x . The price of this operation depends on the
selected indices and is equal to (j - i + 1) burles.

For example, the array is equal to [1, 2, 3, 4, 5, 1] . If we choose i = 2, j
= 4, x = 8 , then after applying this operation, the array will be equal to
[1, 8, 8, 8, 5, 1] .

What is the least amount of burles you need to spend to make all the elements
of the array equal?

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
input test cases. The descriptions of the test cases follow.

The first line of the description of each test case contains a single integer
n (1 \le n \le 2 \cdot 10 ^ 5 ) — the size of the array.

The second line of the description of each test case contains n integers a_1,
a_2, \dots, a_n (1 \le a_i \le n ) — array elements.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output one integer — the minimum number of burles that
will have to be spent to make all the elements of the array equal. It can be
shown that this can always be done.

Example

Input

    8
    
    6
    
    1 2 3 4 5 1
    
    7
    
    1 1 1 1 1 1 1
    
    8
    
    8 8 8 1 2 8 8 8
    
    1
    
    1
    
    2
    
    1 2
    
    3
    
    1 2 3
    
    7
    
    4 3 2 7 1 1 3
    
    9
    
    9 9 2 9 2 5 5 5 3

Output

    4
    0
    2
    0
    1
    2
    6
    7
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1966_C_ParthN27_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob are playing a game on n piles of stones. On each player's turn,
they select a positive integer k that is at most the size of the smallest
nonempty pile and remove k stones from each nonempty pile at once. The first
player who is unable to make a move (because all piles are empty) loses.

Given that Alice goes first, who will win the game if both players play
optimally?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the number of piles in the game.

The next line of each test case contains n integers a_1, a_2, \ldots a_n (1
\le a_i \le 10^9 ), where a_i is the initial number of stones in the i -th
pile.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, print a single line with the name of the winner, assuming
both players play optimally. If Alice wins, print "Alice", otherwise print
"Bob" (without quotes).

Example

Input

    7
    
    5
    
    3 3 3 3 3
    
    2
    
    1 7
    
    7
    
    1 3 9 7 4 2 100
    
    3
    
    1 2 3
    
    6
    
    2 1 3 4 2 4
    
    8
    
    5 7 2 9 6 3 3 2
    
    1
    
    1000000000

Output

    Alice
    Bob
    Alice
    Alice
    Bob
    Alice
    Alice
    
Note

In the first test case, Alice can win by choosing k=3 on her first turn, which
will empty all of the piles at once.

In the second test case, Alice must choose k=1 on her first turn since there
is a pile of size 1 , so Bob can win on the next turn by choosing k=6 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1937_C_Surin_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * "? a b c d" 

After that, you receive:

  * "<" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * "=" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * ">" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * "! i j" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query "? 0 2 3 1", the jury return "<" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query "? 1 1 2 3", the jury return "=" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query "? 1 2 0 3", the jury return ">" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1945_E_u-day_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Anton got bored during the hike and wanted to solve something. He asked Kirill
if he had any new problems, and of course, Kirill had one.

You are given a permutation p of size n , and a number x that needs to be
found. A permutation of length n is an array consisting of n distinct integers
from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

You decided that you are a cool programmer, so you will use an advanced
algorithm for the search — binary search. However, you forgot that for binary
search, the array must be sorted.

You did not give up and decided to apply this algorithm anyway, and in order
to get the correct answer, you can perform the following operation no more
than 2 times before running the algorithm: choose the indices i , j (1\le i, j
\le n ) and swap the elements at positions i and j .

After that, the binary search is performed. At the beginning of the algorithm,
two variables l = 1 and r = n + 1 are declared. Then the following loop is
executed:

  1. If r - l = 1 , end the loop 
  2. m = \lfloor \frac{r + l}{2} \rfloor 
  3. If p_m \le x , assign l = m , otherwise r = m . 

The goal is to rearrange the numbers in the permutation before the algorithm
so that after the algorithm is executed, p_l is equal to x . It can be shown
that 2 operations are always sufficient.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 2\cdot 10^4 ) — the number of test cases. Then follow
the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le x \le n
\le 2\cdot 10^5 ) — the length of the permutation and the number to be found.

The second line contains the permutation p separated by spaces (1 \le p_i \le
n ).

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2\cdot 10^5 .

Output

For each test case, output an integer k (0 \le k \le 2 ) on the first line —
the number of operations performed by you. In the next k lines, output 2
integers i , j (1 \le i, j \le n ) separated by a space, indicating that you
are swapping the elements at positions i and j .

Note that you do not need to minimize the number of operations.

Example

Input

    5
    
    6 3
    
    1 2 3 4 5 6
    
    6 5
    
    3 1 6 5 2 4
    
    5 1
    
    3 5 4 2 1
    
    6 3
    
    4 3 1 5 2 6
    
    3 2
    
    3 2 1

Output

    0
    1
    3 4
    2
    2 4
    1 5
    2
    4 5
    2 4
    1
    1 3
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1978_B_bagel121_75.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1980_B_Flikman_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Dmitry has n cubes, numbered from left to right from 1 to n . The cube with
index f is his favorite.

Dmitry threw all the cubes on the table, and the i -th cube showed the value
a_i (1 \le a_i \le 100 ). After that, he arranged the cubes in non-increasing
order of their values, from largest to smallest. If two cubes show the same
value, they can go in any order.

After sorting, Dmitry removed the first k cubes. Then he became interested in
whether he removed his favorite cube (note that its position could have
changed after sorting).

For example, if n=5 , f=2 , a = [4, \color{green}3, 3, 2, 3] (the favorite
cube is highlighted in green), and k = 2 , the following could have happened:

  * After sorting a=[4, \color{green}3, 3, 3, 2] , since the favorite cube ended up in the second position, it will be removed. 
  * After sorting a=[4, 3, \color{green}3, 3, 2] , since the favorite cube ended up in the third position, it will not be removed. 

Input

The first line contains an integer t (1 \le t \le 1000 ) — the number of test
cases. Then follow the descriptions of the test cases.

The first line of each test case description contains three integers n , f ,
and k (1 \le f, k \le n \le 100 ) — the number of cubes, the index of Dmitry's
favorite cube, and the number of removed cubes, respectively.

The second line of each test case description contains n integers a_i (1 \le
a_i \le 100 ) — the values shown on the cubes.

Output

For each test case, output one line — "YES" if the cube will be removed in all
cases, "NO" if it will not be removed in any case, "MAYBE" if it may be either
removed or left.

You can output the answer in any case. For example, the strings "YES", "nO",
"mAyBe" will be accepted as answers.

Example

Input

    12
    
    5 2 2
    
    4 3 3 2 3
    
    5 5 3
    
    4 2 1 3 5
    
    5 5 2
    
    5 2 4 1 3
    
    5 5 5
    
    1 2 5 4 3
    
    5 5 4
    
    3 1 2 4 5
    
    5 5 5
    
    4 3 2 1 5
    
    6 5 3
    
    1 2 3 1 2 3
    
    10 1 1
    
    1 1 1 1 1 1 1 1 1 1
    
    1 1 1
    
    42
    
    5 2 3
    
    2 2 1 1 2
    
    2 1 1
    
    2 1
    
    5 3 1
    
    3 3 2 3 2

Output

    MAYBE
    YES
    NO
    YES
    YES
    YES
    MAYBE
    MAYBE
    YES
    YES
    YES
    NO
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1977_A_Sardorbek_08_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The little boy Nikita was given some cubes as a present. He decided to build a
tower out of them.

Initially, the tower doesn't have any cubes. In one move, Nikita either puts
exactly 1 cube on top of the tower or removes exactly 1 cube from the top of
the tower. Is it possible that after n moves, the resulting tower has exactly
m cubes?

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 100 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains two integers n and m (1 \le n, m \le
100 ).

Output

For each test case, output "Yes" (without quotes) if Nikita can obtain a tower
with m cubes, and "No" (without quotes) otherwise.

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    3
    
    3 3
    
    2 4
    
    5 3

Output

    Yes
    No
    Yes
    
Note

In the first test case, Nikita can put 1 cube on top of the tower 3 times in a
row, so the answer is "Yes".

In the second test case, Nikita can only end up with either a tower with no
blocks or a tower with 2 blocks, so the answer is "No".
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1973_A_Chuba_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1949_I_Kengreville_61.90%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given n disks in the plane. The center of each disk has integer
coordinates, and the radius of each disk is a positive integer. No two disks
overlap in a region of positive area, but it is possible for disks to be
tangent to each other.

Your task is to determine whether it is possible to change the radii of the
disks in such a way that:

  * Disks that were tangent to each other remain tangent to each other. 
  * No two disks overlap in a region of positive area. 
  * The sum of all radii strictly decreases. 

The new radii are allowed to be arbitrary positive real numbers. The centers
of the disks cannot be changed.

Input

The first line contains an integer n (1\le n \le 1000 ) — the number of disks.

The next n lines contain three integers each. The i -th of such lines contains
x_i , y_i (-10^9 \leq x_i, y_i \leq 10^9 ), and r_i (1 \leq r_i \leq 10^9 ) —
the coordinates of the center, and the radius, of the i -th disk.

Output

Print \texttt{YES} if it is possible to change the radii in the desired
manner. Otherwise, print \texttt{NO} .

Examples

Input

    5
    
    0 2 1
    
    0 0 1
    
    4 -3 4
    
    11 0 3
    
    11 5 2

Output

    YES
    
Input

    4
    
    2 2 2
    
    7 2 3
    
    7 7 2
    
    2 7 3

Output

    NO
    
Note

In the first sample, one can decrease the radii of the first and third disk by
0.5 , and increase the radius of the second disk by 0.5 . This way, the sum of
all radii decreases by 0.5 . The situation before and after changing the radii
is depicted below.

![](https://espresso.codeforces.com/4b45c054d9d982f08b53794399aa5b89a9ee57cf.png)
First sample (left) and a valid way to change the radii of the disks (right).

In the second sample, depicted below, there is no way to change the radii of
the disks in the desired manner.

![](https://espresso.codeforces.com/b7f2e5711b726197f87b2e05ff5d4d5d6e77ee50.png)
Second sample.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1978_B__professor-_50.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1942_C2_BooMeR1OP_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: [Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1955_A_I_am_Naruto_33.33%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The price of one yogurt at the "Vosmiorochka" store is a burles, but there is
a promotion where you can buy two yogurts for b burles.

Maxim needs to buy exactly n yogurts. When buying two yogurts, he can choose
to buy them at the regular price or at the promotion price.

What is the minimum amount of burles Maxim should spend to buy n yogurts?

Input

The first line contains a single integer t (1 \le t \le {10}^{4} ) — the
number of test cases.

The first and only line of each test case contains three integers n , a , and
b (1 \le n \le 100 , 1 \le a, b \le 30 ) — the number of yogurts Maxim wants
to buy, the price for one yogurt, and the price for two yogurts on promotion.

Output

For each test case, print in a separate line the minimum cost of buying n
yogurts at "Vosmiorochka".

Example

Input

    4
    
    2 5 9
    
    3 5 9
    
    3 5 11
    
    4 5 11

Output

    9
    14
    15
    20
    
Note

In the third test case of the example, it is more advantageous to buy three
yogurts for 15 burles than two for 11 and one for 5 .

In the fourth test case of the example, you need to buy four yogurts, each for
5 burles.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1930_A_ns2020_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: There are 2n positive integers written on a whiteboard. Being bored, you
decided to play a one-player game with the numbers on the whiteboard.

You start with a score of 0 . You will increase your score by performing the
following move exactly n times:

  * Choose two integers x and y that are written on the whiteboard. 
  * Add \min(x,y) to your score. 
  * Erase x and y from the whiteboard. 

Note that after performing the move n times, there will be no more integers
written on the whiteboard.

Find the maximum final score you can achieve if you optimally perform the n
moves.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \leq n \leq 50
) — the number of integers written on the whiteboard is 2n .

The second line of each test case contains 2n integers a_1,a_2,\ldots,a_{2n}
(1 \leq a_i \leq 10^7 ) — the numbers written on the whiteboard.

Output

For each test case, output the maximum final score that you can achieve.

Example

Input

    3
    
    1
    
    2 3
    
    2
    
    1 1 2 1
    
    3
    
    1 1 1 1 1 1

Output

    2
    2
    3
    
Note

In the first test case, you can only make one move. You select x=2 and y=3 ,
and your score will be \min(x,y)=2 .

In the second test case, the following is a sequence of moves that achieves a
final score of 2 :

  * In the first move, select x=1 and y=1 . Then, add \min(x,y)=1 to the score. After erasing x and y , the integers left on the whiteboard are 1 and 2 . 
  * In the second move, select x=1 and y=2 . Then, add \min(x,y)=1 to the score. After removing x and y , no more integers will be left on the whiteboard. 

It can be proved that it is not possible to get a score greater than 2 .

In the third test case, you will perform the move thrice, adding 1 to the
score each time.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1968_B_medrifai_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1928_A_41558_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Bob has a rectangle of size a \times b . He tries to cut this rectangle into
two rectangles with integer sides by making a cut parallel to one of the sides
of the original rectangle. Then Bob tries to form some other rectangle from
the two resulting rectangles, and he can rotate and move these two rectangles
as he wishes.

Note that if two rectangles differ only by a 90^{\circ} rotation, they are
considered the same. For example, the rectangles 6 \times 4 and 4 \times 6 are
considered the same.

Thus, from the 2 \times 6 rectangle, another rectangle can be formed, because
it can be cut into two 2 \times 3 rectangles, and then these two rectangles
can be used to form the 4 \times 3 rectangle, which is different from the 2
\times 6 rectangle.

![](https://espresso.codeforces.com/670958570876245598e151e6877e3b0231a7c60e.png)

However, from the 2 \times 1 rectangle, another rectangle cannot be formed,
because it can only be cut into two rectangles of 1 \times 1 , and from these,
only the 1 \times 2 and 2 \times 1 rectangles can be formed, which are
considered the same.

![](https://espresso.codeforces.com/1463aaa4fa7eb1e7432c1d8b5813e7ae91147066.png)

Help Bob determine if he can obtain some other rectangle, or if he is just
wasting his time.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. This is followed
by the description of the test cases.

The single line of each test case contains two integers a and b (1 \le a, b
\le 10^9 ) — the size of Bob's rectangle.

Output

For each test case, output "Yes" if Bob can obtain another rectangle from the
a \times b rectangle. Otherwise, output "No".

You can output the answer in any case (upper or lower). For example, the
strings "yEs", "yes", "Yes", and "YES" will be recognized as positive answers.

Example

Input

    7
    
    1 1
    
    2 1
    
    2 6
    
    3 2
    
    2 2
    
    2 4
    
    6 3

Output

    No
    No
    Yes
    Yes
    Yes
    Yes
    No
    
Note

In the first test case, the 1 \times 1 rectangle cannot be cut into two
rectangles, so another rectangle cannot be obtained from it.

In the fourth test case, the 3 \times 2 rectangle can be cut into two 3 \times
1 rectangles, and from these, the 1 \times 6 rectangle can be formed.

In the fifth test case, the 2 \times 2 rectangle can be cut into two 1 \times
2 rectangles, and from these, the 1 \times 4 rectangle can be formed.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_B_ashikarjen_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1930_B_harshkankhar1_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1955_D_M4R0U4N3_6.67%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Maxim has an array a of n integers and an array b of m integers (m \le n ).

Maxim considers an array c of length m to be good if the elements of array c
can be rearranged in such a way that at least k of them match the elements of
array b .

For example, if b = [1, 2, 3, 4] and k = 3 , then the arrays [4, 1, 2, 3] and
[2, 3, 4, 5] are good (they can be reordered as follows: [1, 2, 3, 4] and [5,
2, 3, 4] ), while the arrays [3, 4, 5, 6] and [3, 4, 3, 4] are not good.

Maxim wants to choose every subsegment of array a of length m as the elements
of array c . Help Maxim count how many selected arrays will be good.

In other words, find the number of positions 1 \le l \le n - m + 1 such that
the elements a_l, a_{l+1}, \dots, a_{l + m - 1} form a good array.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains three integers n , m , and k (1 \le
k \le m \le n \le 2 \cdot 10^5 ) — the number of elements in arrays a and b ,
the required number of matching elements.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^6 ) — the elements of array a . Elements of the array a are not
necessarily unique.

The third line of each test case contains m integers b_1, b_2, \dots, b_m (1
\le b_i \le 10^6 ) — the elements of array b . Elements of the array b are not
necessarily unique.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 . Similarly, it is guaranteed that the sum of m over all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test case, output the number of good subsegments of array a on a
separate line.

Example

Input

    5
    
    7 4 2
    
    4 1 2 3 4 5 6
    
    1 2 3 4
    
    7 4 3
    
    4 1 2 3 4 5 6
    
    1 2 3 4
    
    7 4 4
    
    4 1 2 3 4 5 6
    
    1 2 3 4
    
    11 5 3
    
    9 9 2 2 10 9 7 6 3 6 3
    
    6 9 7 8 10
    
    4 1 1
    
    4 1 5 6
    
    6

Output

    4
    3
    2
    4
    1
    
Note

In the first example, all subsegments are good.

In the second example, good subsegments start at positions 1 , 2 , and 3 .

In the third example, good subsegments start at positions 1 and 2 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1956_C_Phyber_Optik_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: The magical girl Nene has an n\times n matrix a filled with zeroes. The j -th
element of the i -th row of matrix a is denoted as a_{i, j} .

She can perform operations of the following two types with this matrix:

  * Type 1 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{i, j}:=p_j for all 1 \le j \le n simultaneously. 
  * Type 2 operation: choose an integer i between 1 and n and a permutation p_1, p_2, \ldots, p_n of integers from 1 to n . Assign a_{j, i}:=p_j for all 1 \le j \le n simultaneously. 

Nene wants to maximize the sum of all the numbers in the matrix
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}a_{i,j} . She asks you to find the
way to perform the operations so that this sum is maximized. As she doesn't
want to make too many operations, you should provide a solution with no more
than 2n operations.

A permutation of length n is an array consisting of n distinct integers from 1
to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of test cases follows.

The only line of each test case contains a single integer n (1 \le n \le 500 )
— the size of the matrix a .

It is guaranteed that the sum of n^2 over all test cases does not exceed 5
\cdot 10^5 .

Output

For each test case, in the first line output two integers s and m (0\leq m\leq
2n ) — the maximum sum of the numbers in the matrix and the number of
operations in your solution.

In the k -th of the next m lines output the description of the k -th
operation:

  * an integer c (c \in \\{1, 2\\} ) — the type of the k -th operation; 
  * an integer i (1 \le i \le n ) — the row or the column the k -th operation is applied to; 
  * a permutation p_1, p_2, \ldots, p_n of integers from 1 to n — the permutation used in the k -th operation. 

Note that you don't need to minimize the number of operations used, you only
should use no more than 2n operations. It can be shown that the maximum
possible sum can always be obtained in no more than 2n operations.

Example

Input

    2
    
    1
    
    2

Output

    1 1
    1 1 1
    7 3
    1 1 1 2
    1 2 1 2
    2 1 1 2
    
Note

In the first test case, the maximum sum s=1 can be obtained in 1 operation by
setting a_{1, 1}:=1 .

In the second test case, the maximum sum s=7 can be obtained in 3 operations
as follows:

![](https://espresso.codeforces.com/4074275900ed2b8a474fda5b3a628454fc521f8a.png)

It can be shown that it is impossible to make the sum of the numbers in the
matrix larger than 7 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1943_A_nancy-alaa_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob play yet another game on an array a of size n . Alice starts
with an empty array c . Both players take turns playing, with Alice starting
first.

On Alice's turn, she picks one element from a , appends that element to c ,
and then deletes it from a .

On Bob's turn, he picks one element from a , and then deletes it from a .

The game ends when the array a is empty. Game's score is defined to be the
MEX^\dagger of c . Alice wants to maximize the score while Bob wants to
minimize it. Find game's final score if both players play optimally.

^\dagger The \operatorname{MEX} (minimum excludant) of an array of integers is
defined as the smallest non-negative integer which does not occur in the
array. For example:

  * The MEX of [2,2,1] is 0 , because 0 does not belong to the array. 
  * The MEX of [3,1,0,1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * The MEX of [0,3,1,2] is 4 , because 0 , 1 , 2 and 3 belong to the array, but 4 does not. 

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^4 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ).

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ).

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, find game's score if both players play optimally.

Example

Input

    3
    
    4
    
    0 0 1 1
    
    4
    
    0 1 2 3
    
    2
    
    1 1

Output

    2
    1
    0
    
Note

In the first test case, a possible game with a score of 2 is as follows:

  1. Alice chooses the element 1 . After this move, a=[0,0,1] and c=[1] . 
  2. Bob chooses the element 0 . After this move, a=[0,1] and c=[1] . 
  3. Alice chooses the element 0 . After this move, a=[1] and c=[1,0] . 
  4. Bob chooses the element 1 . After this move, a=[\,] and c=[1,0] . 

At the end, c=[1,0] , which has a MEX of 2 . Note that this is an example game
and does not necessarily represent the optimal strategy for both players.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': True, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1968_D_shashank_yadav7_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Bodya and Sasha found a permutation p_1,\dots,p_n and an array a_1,\dots,a_n .
They decided to play a well-known "Permutation game".

A permutation of length n is an array consisting of n distinct integers from 1
to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

Both of them chose a starting position in the permutation.

The game lasts k turns. The players make moves simultaneously. On each turn,
two things happen to each player:

  * If the current position of the player is x , his score increases by a_x . 
  * Then the player either stays at his current position x or moves from x to p_x . 

The winner of the game is the player with the higher score after exactly k
turns.

Knowing Bodya's starting position P_B and Sasha's starting position P_S ,
determine who wins the game if both players are trying to win.

Input

The first line contains a single integer t (1\le t\le 10^4 ) — the number of
testcases.

The first line of each testcase contains integers n , k , P_B , P_S (1\le
P_B,P_S\le n\le 2\cdot 10^5 , 1\le k\le 10^9 ) — length of the permutation,
duration of the game, starting positions respectively.

The next line contains n integers p_1,\dots,p_n (1 \le p_i \le n ) — elements
of the permutation p .

The next line contains n integers a_1,\dots,a_n (1\le a_i\le 10^9 ) — elements
of array a .

It is guaranteed that the sum of values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each testcase output:

  * "Bodya" if Bodya wins the game. 
  * "Sasha" if Sasha wins the game. 
  * "Draw" if the players have the same score. 

Example

Input

    10
    
    4 2 3 2
    
    4 1 2 3
    
    7 2 5 6
    
    10 8 2 10
    
    3 1 4 5 2 7 8 10 6 9
    
    5 10 5 1 3 7 10 15 4 3
    
    2 1000000000 1 2
    
    1 2
    
    4 4
    
    8 10 4 1
    
    5 1 4 3 2 8 6 7
    
    1 1 2 1 2 100 101 102
    
    5 1 2 5
    
    1 2 4 5 3
    
    4 6 9 4 2
    
    4 2 3 1
    
    4 1 3 2
    
    6 8 5 3
    
    6 9 5 4
    
    6 1 3 5 2 4
    
    6 9 8 9 5 10
    
    4 8 4 2
    
    2 3 4 1
    
    5 2 8 7
    
    4 2 3 1
    
    4 1 3 2
    
    6 8 5 3
    
    2 1000000000 1 2
    
    1 2
    
    1000000000 2

Output

    Bodya
    Sasha
    Draw
    Draw
    Bodya
    Sasha
    Sasha
    Sasha
    Sasha
    Bodya
    
Note

Below you can find the explanation for the first testcase, where the game
consists of k=2 turns.

Turn| Bodya's position| Bodya's score| Bodya's move| Sasha's position| Sasha's
score| Sasha's move  
---|---|---|---|---|---|---  
first| 3 | 0 + a_3 = 0 + 5 = 5 | stays on the same position| 2 | 0 + a_2 = 0 + 2 = 2 | moves to p_2=1   
second| 3 | 5 + a_3 = 5 + 5 = 10 | stays on the same position| 1 | 2 + a_1 = 2 + 7 = 9 | stays on the same position  
final results| 3 | 10 | | 1 | 9 |   
  
As we may see, Bodya's score is greater, so he wins the game. It can be shown
that Bodya always can win this game.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1951_D_jgsr031200_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: [Nightwish feat. Jonsu - Erämaan Viimeinen](https://youtu.be/QYlFn5q_UQk)

ඞ

Alice has n coins and wants to shop at Bob's jewelry store. Today, although
Bob has not set up the store yet, Bob wants to make sure Alice will buy
exactly k jewels. To set up the store, Bob can erect at most 60 stalls (each
containing an unlimited amount of jewels) and set the price per jewel for each
stall to be an integer number of coins between 1 and 10^{18} .

Fortunately, Bob knows that Alice buys greedily: and she will go to stall 1 ,
buy as many jewels as possible, then go to stall 2 , buy as many jewels as
possible, and so on until the last stall. Knowing this, Bob can choose the
number of stalls to set up, as well as set the price for each stall so that
Alice buys exactly k jewels. Help Bob fulfill the task, or determine if it is
impossible to do so.

Note that Alice does not need to spend all her coins.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 1000 ) — the number of test cases. The description of the test
cases follows.

Each test case contains two positive integers n and k (1 \le n, k \le 10^{18}
) — the number of coins Alice has and the number of jewels Bob wants Alice to
have bought at the end.

Output

For each test case, print on one line "YES" if Bob can erect at most 60 stalls
and set the prices for the stalls such that Alice buys exactly k jewels, or
"NO" if it is impossible to do so.

If the answer is "YES", on the second line, print an integer s (1 \le s \le 60
) — the number of stalls to be set up by Bob. On the third line, print s
positive integers p_1, p_2, \ldots, p_s (1 \le p_i \le 10^{18}) that represent
such a satisfactory pricing p , where p_i is the price per jewel for stall i .
If there are multiple such p 's, print any of them.

Example

Input

    3
    
    7 3
    
    6 4
    
    255 8

Output

    YES
    10
    2 3 4 5 6 7 8 9 10 11
    NO
    YES
    8
    128 64 32 16 8 4 2 1
    
Note

In the first test case, at the first stall, Alice buys 3 jewels and is left
with 1 coin. This is not enough to buy any jewels for any of the remaining
stalls, so Alice buys exactly 3 jewels at the end.

In the third test case,

  * At the first stall, Alice buys 1 jewel and is left with 127 coins. 
  * At the second stall, Alice buys 1 jewel and is left with 63 coins. 
  * At the third stall, Alice buys 1 jewel and is left with 31 coins. 
  * At the fourth stall, Alice buys 1 jewel and is left with 15 coins. 
  * At the fifth stall, Alice buys 1 jewel and is left with 7 coins. 
  * At the sixth stall, Alice buys 1 jewel and is left with 3 coins. 
  * At the seventh stall, Alice buys 1 jewel and is left with 1 coin. 
  * At the eighth stall, Alice buys 1 jewel and is left with 0 coins. 

Therefore, Alice buys exactly 8 jewels in total.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 1950_A_Pratking1809_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given three digits a , b , and c . Determine whether they form a
stair, a peak, or neither.

  * A stair satisfies the condition a<b<c . 
  * A peak satisfies the condition a<b>c . 

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains three digits a , b , c (0 \leq a , b
, c \leq 9 ).

Output

For each test case, output "STAIR" if the digits form a stair, "PEAK" if the
digits form a peak, and "NONE" otherwise (output the strings without quotes).

Example

Input

    7
    
    1 2 3
    
    3 2 1
    
    1 5 3
    
    3 4 1
    
    0 0 0
    
    4 1 7
    
    4 5 7

Output

    STAIR
    NONE
    PEAK
    PEAK
    NONE
    NONE
    STAIR
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1966_A_CodeBlazer19_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You have a hand of n cards, where each card has a number written on it, and a
fixed integer k . You can perform the following operation any number of times:

  * Choose any k cards from your hand that all have the same number. 
  * Exchange these cards for k-1 cards, each of which can have any number you choose (including the number written on the cards you just exchanged). 

Here is one possible sequence of operations for the first example case, which
has k=3 :

![](https://espresso.codeforces.com/ac8986e55ddc41e4d0ee63ac67222f97e7fcc1bf.png)

What is the minimum number of cards you can have in your hand at the end of
this process?

Input

The first line of the input contains a single integer t (1 \le t \le 500 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n and k (1 \le n \le
100 , 2 \le k \le 100 ) — the number of cards you have, and the number of
cards you exchange during each operation, respectively.

The next line of each test case contains n integers c_1, c_2, \ldots c_n (1
\le c_i \le 100 ) — the numbers written on your cards.

Output

For each test case, output a single integer — the minimum number of cards you
can have left in your hand after any number of operations.

Example

Input

    7
    
    5 3
    
    4 1 1 4 4
    
    1 10
    
    7
    
    7 2
    
    4 2 1 100 5 2 3
    
    10 4
    
    1 1 1 1 1 1 1 1 1 1
    
    5 2
    
    3 8 1 48 7
    
    6 2
    
    10 20 30 10 20 40
    
    6 3
    
    10 20 30 10 20 40

Output

    2
    1
    1
    3
    5
    1
    6
    
Note

The first example case corresponds to the picture above. The sequence of
operations displayed there is optimal, so the answer is 2 .

In the second example case, no operations can be performed, so the answer is 1
.

In the fourth example case, you can repeatedly select 4 cards numbered with 1
and replace them with 3 cards numbered with 1 , until there are 3 cards left.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1975_A_sama1315._100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Mocha likes arrays, so before her departure, Bazoka gave her an array a
consisting of n positive integers as a gift.

Now Mocha wants to know whether array a could become sorted in non-decreasing
order after performing the following operation some (possibly, zero) times:

  * Split the array into two parts — a prefix and a suffix, then swap these two parts. In other words, let a=x+y . Then, we can set a:= y+x . Here + denotes the array concatenation operation. 

For example, if a=[3,1,4,1,5] , we can choose x=[3,1] and y=[4,1,5] ,
satisfying a=x+y . Then, we can set a:= y + x = [4,1,5,3,1] . We can also
choose x=[3,1,4,1,5] and y=[\,] , satisfying a=x+y . Then, we can set a := y+x
= [3,1,4,1,5] . Note that we are not allowed to choose x=[3,1,1] and y=[4,5] ,
neither are we allowed to choose x=[1,3] and y=[5,1,4] , as both these choices
do not satisfy a=x+y .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\leq t\leq 1000 ). The description of the test cases follows.

The first line of each test case contains a single integer n (2\leq n\leq 50 )
— the length of the array a .

The second line of each test case contains n integers a_1,a_2,\ldots,a_n
(1\leq a_i \leq 10^6 ) — the elements of array a .

Output

For each test case, output "Yes" if a could become non-decreasing after
performing the operation any number of times, and output "No" if not.

You can output "Yes" and "No" in any case (for example, strings "yEs", "yes",
"Yes" and "YES" will be recognized as a positive response).

Example

Input

    3
    
    6
    
    1 1 4 5 1 4
    
    5
    
    7 9 2 2 3
    
    3
    
    1 2 3

Output

    No
    Yes
    Yes
    
Note

In the first test case, it can be proven that a cannot become non-decreasing
after performing the operation any number of times.

In the second test case, we can perform the following operations to make a
sorted in non-decreasing order:

  * Split the array into two parts: x=[7] and y=[9,2,2,3] , then swap these two parts. The array will become y+x = [9,2,2,3,7] . 
  * Split the array into two parts: x=[9] and y=[2,2,3,7] , then swap these two parts. The array will become y+x=[2,2,3,7,9] , which is non-decreasing.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'vanilla_no_cot': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 1926_E_Joyboy1730_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Vladislav has n cards numbered 1, 2, \dots, n . He wants to lay them down in a
row as follows:

  * First, he lays down all the odd-numbered cards from smallest to largest. 
  * Next, he lays down all cards that are twice an odd number from smallest to largest (i.e. 2 multiplied by an odd number). 
  * Next, he lays down all cards that are 3 times an odd number from smallest to largest (i.e. 3 multiplied by an odd number). 
  * Next, he lays down all cards that are 4 times an odd number from smallest to largest (i.e. 4 multiplied by an odd number). 
  * And so on, until all cards are laid down. 

What is the k -th card he lays down in this process? Once Vladislav puts a
card down, he cannot use that card again.

Input

The first line contains an integer t (1 \leq t \leq 5 \cdot 10^4 ) — the
number of test cases.

The only line of each test case contains two integers n and k (1 \leq k \leq n
\leq 10^9 ) — the number of cards Vlad has, and the position of the card you
need to output.

Output

For each test case, output a single integer — the k -th card Vladislav lays
down.

Example

Input

    11
    
    7 1
    
    7 2
    
    7 3
    
    7 4
    
    7 5
    
    7 6
    
    7 7
    
    1 1
    
    34 14
    
    84 19
    
    1000000000 1000000000

Output

    1
    3
    5
    7
    2
    6
    4
    1
    27
    37
    536870912
    
Note

In the first seven test cases, n=7 . Vladislav lays down the cards as follows:

  * First — all the odd-numbered cards in the order 1 , 3 , 5 , 7 . 
  * Next — all cards that are twice an odd number in the order 2 , 6 . 
  * Next, there are no remaining cards that are 3 times an odd number. (Vladislav has only one of each card.) 
  * Next — all cards that are 4 times an odd number, and there is only one such card: 4 . 
  * There are no more cards left, so Vladislav stops. 

Thus the order of cards is 1 , 3 , 5 , 7 , 2 , 6 , 4 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1955_F_the_mehedi_100%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: Alice and Bob gathered in the evening to play an exciting game on a sequence
of n integers, each integer of the sequence doesn't exceed 4 . The rules of
the game are too complex to describe, so let's just describe the winning
condition — Alice wins if the [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
all the numbers in the sequence is non-zero; otherwise, Bob wins.

The guys invited Eve to act as a judge. Initially, Alice and Bob play with n
numbers. After one game, Eve removes one of the numbers from the sequence,
then Alice and Bob play with n-1 numbers. Eve removes one number again, after
which Alice and Bob play with n - 2 numbers. This continues until the sequence
of numbers is empty.

Eve seems to think that in such a game, Alice almost always wins, so she wants
Bob to win as many times as possible. Determine the maximum number of times
Bob can win against Alice if Eve removes the numbers optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first and only line of each test case contains four integers p_i (0 \le
p_i \le 200 ) — the number of ones, twos, threes, and fours in the sequence at
the beginning of the game.

Output

For each test case, print the maximum number of times Bob will win in a
separate line, if Eve removes the numbers optimally.

Example

Input

    5
    
    1 1 1 0
    
    1 0 1 2
    
    2 2 2 0
    
    3 3 2 0
    
    0 9 9 9

Output

    1
    1
    3
    3
    12
    
Note

In the first example, Bob wins when Eve has not removed any numbers yet.

In the second example, Bob wins if Eve removes one one and one three.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'vanilla_no_cot': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1971_A_alsadeg190_0.00%
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2p5-72b-instruct
DEBUG - description: You are given two integers x and y .

Output two integers: the minimum of x and y , followed by the maximum of x and
y .

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The only line of each test case contains two space-separated integers x and y
(0 \leq x, y \leq 9 ).

Output

For each test case, output two integers: the minimum of x and y , followed by
the maximum of x and y .

Example

Input

    10
    
    1 9
    
    8 4
    
    1 4
    
    3 4
    
    2 0
    
    2 4
    
    6 9
    
    3 3
    
    0 0
    
    9 9

Output

    1 9
    4 8
    1 4
    3 4
    0 2
    2 4
    6 9
    3 3
    0 0
    9 9
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'vanilla_no_cot': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
