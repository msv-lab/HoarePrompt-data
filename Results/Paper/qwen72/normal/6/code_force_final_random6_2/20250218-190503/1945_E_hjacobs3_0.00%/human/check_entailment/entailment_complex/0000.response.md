Reasoning:

1. **Binary Search Logic**: The binary search logic in the function `func_1` is designed to find the smallest index `l` such that `array[l]` is greater than or equal to `find`. This is a standard binary search approach, but it is not suitable for an unsorted permutation. However, the problem allows us to perform up to 2 swaps to make the binary search work correctly.

2. **Swapping Logic**: The function checks if the index `l` (where `array[l]` is the smallest element greater than or equal to `find`) is the same as the actual index of `find` in the array. If they are not the same, it prints `1` and returns a list of two indices to swap: `l + 1` and the index of `find` in the array plus 1. This ensures that after the swap, the binary search will correctly find `find` at index `l`.

3. **Output Format**: The function correctly prints the number of swaps and returns the indices in the required format as strings.

4. **Edge Cases**: The function handles edge cases where `find` is already in the correct position by printing `0` and not returning any indices to swap.

5. **Overall Functionality**: The function `func_1` is designed to work with the given constraints and problem description. It ensures that the binary search will find the correct element after at most 2 swaps.

However, there is a subtle issue in the binary search logic:
- The binary search should end when `r - l == 1`, but the current implementation uses `l <= r`. This can lead to an infinite loop in some cases, especially when `l` and `r` are equal and the condition `array[mid] >= find` is always true or false.

To fix this, the loop condition should be `r - l > 1`.

Given the current implementation, the program might not terminate correctly in some edge cases, which would make it incorrect.

Correctness: **False**

Here is the corrected version of the function:

```python
def func_1(array, find):
    n = len(array)
    l, r = 0, n
    while r - l > 1:
        mid = (l + r) // 2
        
        if array[mid] >= find:
            r = mid
        else:
            l = mid
    
    # Ensure the correct index is found
    if array[l] == find:
        print(0)
        return []
    elif array[r] == find:
        print(1)
        return [str(r + 1), str(array.index(find) + 1)]
    else:
        print(1)
        return [str(l + 1), str(array.index(find) + 1)]
```

This corrected version ensures that the binary search loop terminates correctly and handles the case where `find` is not found in the array but should be inserted at the correct position.