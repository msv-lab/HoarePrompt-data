
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .

- Program: 

#Function 1:
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        dp = new_dp
    final_sum = p[-1] + offset
    return dp[final_sum]

#Function 2:
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        p = list(map(int, data[index:index + n]))
        index += n
        result = func_1(n, p)
        results.append(result)
    for res in results:
        print(res)



- Annotated Code: 
MOD = 998244353
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 5000, and p is a list of n integers where |p_i| ≤ n, representing the sorted prefix sums of the hidden array a.
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        
        dp = new_dp
        
    #State: After the loop has completed all its iterations, `n` remains a positive integer with \(1 \leq n \leq 5000\). The list `dp` is a list of length `2 * n + 1`, where each element has been updated according to the rules defined in the loop. Specifically, starting from the initial state where `dp[n]` is 1 and all other elements are 0, the loop updates `dp` such that for each index `j` in the range [0, 2 * n], if `dp[j]` was greater than 0 at any point, the adjacent elements `dp[j + 1]` and `dp[j - 1]` (if within bounds) have been incremented by the value of `dp[j]` modulo `MOD`. After `n` iterations, the final state of `dp` reflects the cumulative effect of these updates. The variable `i` is `n + 1`, and `new_dp` is no longer relevant as it is overwritten in each iteration.
    final_sum = p[-1] + offset
    return dp[final_sum]
    #The program returns the value stored at the index `final_sum` in the list `dp`. Here, `final_sum` is calculated as `p[-1] + offset`, where `p[-1]` refers to the last element of the list `p` (which is not explicitly defined in the initial state but assumed to be part of the context leading to `final_sum`), and `offset` is a value that is also not explicitly defined but is part of the calculation for `final_sum`. The list `dp` has a length of `2 * n + 1`, and its elements have been updated according to certain loop rules, which are not detailed here. The exact value returned depends on the specific values of `p[-1]`, `offset`, and the updates made to `dp` during the loop.
#Overall this is what the function does:The function `func_1` takes two parameters: `n`, a positive integer such that 1 ≤ n ≤ 5000, and `p`, a list of `n` integers where each element `p_i` satisfies |p_i| ≤ n, representing the sorted prefix sums of a hidden array `a`. It initializes a list `dp` of length `2 * n + 1` with all elements set to 0, except for the element at index `n` (the `offset`), which is set to 1. The function then iterates `n` times, updating the `dp` list based on the values of the current `dp` list and the modulo operation with a constant `MOD`. After the loop completes, the function calculates `final_sum` as the sum of the last element of `p` and the `offset`. The function returns the value at the index `final_sum` in the `dp` list. The final state of the program includes the updated `dp` list and the returned value, which represents the result of the dynamic programming process applied to the input parameters.

#Function 2:
#State of the program right berfore the function call: t is a positive integer such that 1 ≤ t ≤ 1000, representing the number of test cases. n is a positive integer such that 1 ≤ n ≤ 5000, representing the size of the hidden array a. p is a list of n integers where |p_i| ≤ n and p_1 ≤ p_2 ≤ ... ≤ p_n, representing the sorted prefix sums of the hidden array a.
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        p = list(map(int, data[index:index + n]))
        
        index += n
        
        result = func_1(n, p)
        
        results.append(result)
        
    #State: After all iterations of the loop, `t` is 0 (since it dictates the number of iterations and has been fully consumed), `n` is the last processed integer value from `data`, `p` is the last processed list of `n` integers, `data` remains the same as it was initially, `index` is the final position after processing all elements, `results` is a list containing `t` elements where each element is the value returned by `func_1(n, p)` for each iteration, and `result` is the value returned by `func_1(n, p)` from the last iteration.
    for res in results:
        print(res)
        
    #State: After all iterations of the loop, `t` is 0, `n` is the last processed integer value from `data`, `p` is the last processed list of `n` integers, `data` remains the same as it was initially, `index` is the final position after processing all elements, `results` is a list containing `t` elements where each element is the value returned by `func_1(n, p)` for each iteration, and `result` is the value returned by `func_1(n, p)` from the last iteration.
#Overall this is what the function does:The function reads input from standard input, processes multiple test cases, and prints the results. Each test case involves reading an integer `n` and a list `p` of `n` integers, then calling another function `func_1` with `n` and `p`. The results of these calls are collected and printed one by one. After the function completes, the input data remains unchanged, and the results of the test cases are printed to the standard output.




Beggining of Original Assessment: 
### Reasoning:

1. **Understanding the Problem:**
   - We are given a sorted prefix sum array `p` derived from an unknown array `a` consisting of only 1s and -1s.
   - We need to count the number of possible arrays `a` that can produce the given sorted prefix sum array `p`.
   - The result should be modulo \( 998,244,353 \).

2. **Dynamic Programming Approach:**
   - The function `func_1` uses dynamic programming to solve the problem.
   - It initializes a DP array `dp` of size `2 * n + 1` with an offset to handle negative indices.
   - The DP array `dp[j]` represents the number of ways to reach a prefix sum `j - n` using the first `i` elements of `a`.

3. **DP Transition:**
   - For each element in the array `a`, we update the DP array based on the previous state.
   - If the current prefix sum is `j`, we can either add 1 or -1 to it.
   - This is reflected in the transitions: `new_dp[j + 1]` and `new_dp[j - 1]`.

4. **Final Calculation:**
   - After processing all elements, the final prefix sum is `p[-1]`.
   - We adjust this sum using the offset and return the value from the DP array.

5. **Input Handling:**
   - The function `func_2` reads the input and processes multiple test cases.
   - It correctly parses the input and calls `func_1` for each test case.
   - The results are stored and printed at the end.

6. **Edge Cases:**
   - The code handles edge cases such as small and large values of `n`.
   - It ensures that the prefix sums are within the valid range and the DP array is updated correctly.

### Conclusion:
The provided program correctly implements the solution to the problem using dynamic programming and handles the input and output as specified. Therefore, the program is correct.

### Final Answer:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

