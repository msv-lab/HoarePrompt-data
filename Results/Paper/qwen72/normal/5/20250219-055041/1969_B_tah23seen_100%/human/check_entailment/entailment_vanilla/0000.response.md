### Reasoning:

1. **Problem Understanding**:
   - We need to sort a binary string in non-descending order using cyclic shifts.
   - The cost of a cyclic shift is the length of the substring being shifted.
   - We need to find the minimum total cost to achieve this.

2. **Algorithm Analysis**:
   - The function `func_1(s)` is designed to calculate the minimum cost to sort the binary string `s`.
   - The function iterates through the string `s` and keeps track of the number of '1's encountered (`one`).
   - If a '0' is encountered and there are some '1's before it (`one > 0`), it adds `one + 1` to the cost. This is because to move the '0' to the correct position, we need to shift the substring from the last '1' to the current '0' (including the '0').

3. **Correctness of the Algorithm**:
   - The algorithm correctly identifies the cost of moving each '0' to the left of all '1's.
   - The cost `one + 1` is the length of the substring that needs to be cyclically shifted to move the '0' to the correct position.
   - The algorithm ensures that all '0's are moved to the left of all '1's, which is the required sorted order for a binary string.

4. **Edge Cases**:
   - If the string is already sorted (e.g., "0000" or "1111"), the cost will be 0, which is correct.
   - If the string has no '0's (e.g., "1111"), the cost will be 0, which is correct.
   - If the string has no '1's (e.g., "0000"), the cost will be 0, which is correct.
   - For mixed strings like "101011", the algorithm correctly calculates the cost to move each '0' to the left of all '1's.

5. **Complexity**:
   - The algorithm runs in O(n) time, where n is the length of the string `s`.
   - This is efficient given the constraints (sum of lengths of strings over all test cases doesn't exceed 2 * 10^5).

### Conclusion:
The provided program correctly calculates the minimum total cost to sort a binary string using the described cyclic shift operations. Therefore, the program is correct.

**Correctness: True**