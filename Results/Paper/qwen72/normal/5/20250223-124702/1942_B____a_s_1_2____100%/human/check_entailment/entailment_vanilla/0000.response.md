### Reasoning:

1. **Understanding the Problem:**
   - We are given an array `a` such that `a[i] = MEX(p[1], p[2], ..., p[i]) - p[i]`.
   - The task is to reconstruct the permutation `p` from `a`.

2. **Key Observations:**
   - The MEX of a sequence is the smallest non-negative integer that is not present in the sequence.
   - For each `i`, `a[i]` is the difference between the MEX of the first `i` elements of `p` and `p[i]`.
   - Therefore, `p[i] = MEX(p[1], p[2], ..., p[i]) - a[i]`.

3. **Algorithm Explanation:**
   - The program initializes the permutation `p` with `-1` values.
   - It starts from the last element of `p` and works its way backward.
   - For each index `i`, it sets `p[i]` to `mex - a[i]`, where `mex` is the current minimum excluded value.
   - It then updates `mex` to be the minimum of the current `mex` and the newly set `p[i]`.

4. **Correctness of the Algorithm:**
   - **Initialization:** `mex` is initialized to `n`, which is the largest possible value for the MEX of a permutation of length `n`.
   - **Backward Construction:** By starting from the last element and moving backward, the program ensures that the MEX is correctly calculated for each prefix of `p` up to the current index.
   - **MEX Update:** The update `mex = min(mex, p[i])` ensures that the MEX is the smallest non-negative integer not yet used in the permutation.
   - **Permutation Validity:** Since the input is guaranteed to have at least one valid permutation, the program will always find a valid `p` by the end of the loop.

5. **Edge Cases:**
   - The program handles the edge case where `n = 1` correctly.
   - It also handles the case where `a` contains negative values, as the MEX calculation and the update of `p` are designed to work with these values.

### Conclusion:
The program correctly reconstructs a valid permutation `p` from the given array `a` based on the problem description. Therefore, the program is correct.

### Correctness:
**True**