Correctness: **True**

The provided Python program correctly solves the problem by constructing a valid permutation `p` from the given array `a`. Here's a detailed explanation of why the program works:

1. **Input Handling**: The program reads the number of test cases `t` and then processes each test case individually. For each test case, it reads the length `n` of the permutation and the array `a`.

2. **Initialization**: It initializes the permutation `p` as a list of `-1` of length `n` and sets `mex` to `n`. The variable `mex` is used to keep track of the minimum excluded value (MEX) for the current prefix of the permutation.

3. **Constructing the Permutation**:
   - The program iterates over the array `a` in reverse order (from `n-1` to `0`).
   - For each index `i`, it calculates `p[i]` as `mex - a[i]`. This is based on the relationship given in the problem: \( a_i = \texttt{MEX}(p_1, p_2, \ldots, p_i) - p_i \).
   - It then updates `mex` to be the minimum of the current `mex` and the newly calculated `p[i]`. This ensures that `mex` is always the smallest non-negative integer not yet included in the permutation up to index `i`.

4. **Output**: After constructing the permutation `p`, it prints the elements of `p` separated by spaces.

### Verification with Example

Let's verify the program with the provided example:

- **Test Case 1**:
  - Input: `n = 5`, `a = [1, 1, -2, 1, 2]`
  - Expected Output: `0 1 4 2 3`

  **Step-by-Step Calculation**:
  - Initialize `p = [-1, -1, -1, -1, -1]` and `mex = 5`.
  - For `i = 4`: \( p[4] = 5 - 2 = 3 \), `mex = min(5, 3) = 3`.
  - For `i = 3`: \( p[3] = 3 - 1 = 2 \), `mex = min(3, 2) = 2`.
  - For `i = 2`: \( p[2] = 2 - (-2) = 4 \), `mex = min(2, 4) = 2`.
  - For `i = 1`: \( p[1] = 2 - 1 = 1 \), `mex = min(2, 1) = 1`.
  - For `i = 0`: \( p[0] = 1 - 1 = 0 \), `mex = min(1, 0) = 0`.

  The final permutation `p` is `[0, 1, 4, 2, 3]`, which matches the expected output.

- **Test Case 2**:
  - Input: `n = 5`, `a = [1, 1, 1, 1, 1]`
  - Expected Output: `0 1 2 3 4`

  **Step-by-Step Calculation**:
  - Initialize `p = [-1, -1, -1, -1, -1]` and `mex = 5`.
  - For `i = 4`: \( p[4] = 5 - 1 = 4 \), `mex = min(5, 4) = 4`.
  - For `i = 3`: \( p[3] = 4 - 1 = 3 \), `mex = min(4, 3) = 3`.
  - For `i = 2`: \( p[2] = 3 - 1 = 2 \), `mex = min(3, 2) = 2`.
  - For `i = 1`: \( p[1] = 2 - 1 = 1 \), `mex = min(2, 1) = 1`.
  - For `i = 0`: \( p[0] = 1 - 1 = 0 \), `mex = min(1, 0) = 0`.

  The final permutation `p` is `[0, 1, 2, 3, 4]`, which matches the expected output.

- **Test Case 3**:
  - Input: `n = 3`, `a = [-2, 1, 2]`
  - Expected Output: `2 0 1`

  **Step-by-Step Calculation**:
  - Initialize `p = [-1, -1, -1]` and `mex = 3`.
  - For `i = 2`: \( p[2] = 3 - 2 = 1 \), `mex = min(3, 1) = 1`.
  - For `i = 1`: \( p[1] = 1 - 1 = 0 \), `mex = min(1, 0) = 0`.
  - For `i = 0`: \( p[0] = 0 - (-2) = 2 \), `mex = min(0, 2) = 0`.

  The final permutation `p` is `[2, 0, 1]`, which matches the expected output.

The program correctly handles the given constraints and produces valid permutations for the provided test cases. Therefore, the correctness of the program is **True**.