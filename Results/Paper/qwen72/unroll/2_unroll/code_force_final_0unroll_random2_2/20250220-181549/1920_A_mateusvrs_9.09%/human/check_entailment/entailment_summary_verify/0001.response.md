### Reasoning:

1. **Input Handling**:
   - The function correctly reads the number of test cases `t` and the number of constraints `n` for each test case.
   - It reads each constraint and processes it accordingly.

2. **Constraint Types**:
   - For `a == 1`, the function updates `bx` to the maximum of `x` and the current `bx`. This ensures that `k` must be at least `bx`.
   - For `a == 2`, the function updates `ax` to the minimum of `x` and the current `ax`. This ensures that `k` must be at most `ax`.
   - For `a == 3`, the function adds `x` to the set `cx`. This ensures that `k` must not be equal to any of these values.

3. **Range Validation**:
   - After processing all constraints, the function checks if `bx >= ax`. If this condition is true, it means there is no valid range for `k`, and the function correctly appends `0` to the result list `r`.

4. **Counting Valid Integers**:
   - If `bx < ax`, the function calculates the total number of integers in the range `[bx, ax]` as `ax - bx + 1`.
   - It then iterates over the set `cx` to count how many of these integers are in the range `[bx, ax]` and subtracts this count from the total to get the final count of valid integers.
   - The use of a set `cx` ensures that each `x` value is unique, which is consistent with the problem's guarantee that no two constraints are the exact same.

5. **Output**:
   - The function prints each result in the list `r` on a new line, which is the correct format for the output.

### Detailed Analysis:

- **Initialization**:
  - `ax` is initialized to a very large number (`1000000000.0 + 7`), which ensures that any valid upper bound constraint will be less than this initial value.
  - `bx` is initialized to `-1`, which ensures that any valid lower bound constraint will be greater than this initial value.
  - The use of `1000000000.0 + 7` is a bit unconventional, but it effectively serves the purpose of setting an initial upper bound that is larger than any possible constraint value.

- **Processing Constraints**:
  - The function correctly updates `bx` and `ax` based on the constraints.
  - The set `cx` is used to store the values that `k` must not be equal to, ensuring that duplicates are not added.

- **Range Check**:
  - The condition `if bx >= ax` correctly identifies when the range is invalid and appends `0` to the result list `r`.

- **Counting Valid Integers**:
  - The calculation `ax - bx + 1` correctly determines the total number of integers in the range `[bx, ax]`.
  - The loop `for i in cx` correctly counts and subtracts the invalid integers from the total count.

### Conclusion:
The program correctly handles the constraints and calculates the number of valid integers `k` for each test case. It follows the problem description and produces the expected output.

### Correctness:
**True**

The original assessment is accurate, and the program is correct.