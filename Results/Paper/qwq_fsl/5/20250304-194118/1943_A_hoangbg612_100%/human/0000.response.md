Alright, I have this problem to solve. I need to determine if a given Python program correctly implements the logic described in the problem statement. The program is supposed to handle a game between Alice and Bob, where they take turns modifying an array, and the final score is the MEX of the array Alice builds. I need to verify if the provided program correctly computes the final score as per the rules, considering both players play optimally.

First, I need to understand the problem thoroughly. Alice and Bob are playing a game on an array `a` of size `n`. Alice starts with an empty array `c`. They take turns, with Alice going first. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`. The game ends when `a` is empty, and the score is the MEX of `c`. Alice wants to maximize the MEX, while Bob wants to minimize it.

So, the MEX of an array is the smallest non-negative integer not present in it. For example, MEX of `[0, 1, 3]` is 2, since 0 and 1 are present, but 2 is missing.

I need to ensure that the program correctly simulates the optimal play by both Alice and Bob and computes the final MEX of `c`.

Looking at the provided program:

```python
def func():
    T = int(input())
    for _ in range(T):
        S = int(input())
        N = list(map(int, input().split()))
        N.sort()
        cur = -1
        M = {}
        for num in N:
            if num > cur:
                if num > cur + 1:
                    cur += 1
                    break
                cur = num
                M[cur] = 1
            else:
                M[cur] += 1
        if sum([M[k] for k in M.keys()]) == S:
            cur += 1
        cnt = []
        for k in M.keys():
            if M[k] == 1:
                cnt.append(k)
        if len(cnt) >= 2:
            cur = cnt[1]
        print(cur)
```

This function reads multiple test cases, each consisting of an integer `S` (which I believe is `n`, the size of the array), followed by the array `N`. It sorts the array, initializes `cur` to -1, and uses a dictionary `M` to track something.

I need to understand what `cur` represents and how the dictionary `M` is being used.

From the problem, I know that Alice wants to maximize the MEX, and Bob wants to minimize it. So, in the game, Alice will try to include numbers in `c` that help achieve a higher MEX, while Bob will try to prevent that by removing elements that could help Alice.

But in this program, it seems like the logic is to iterate through the sorted array and build some kind of count or presence map in `M`.

Let me try to think about what the optimal strategies for both players would be.

Alice wants the MEX to be as high as possible, which means she wants to have as many low numbers in `c` as possible. Bob wants to minimize the MEX, so he would try to prevent Alice from getting low numbers into `c`.

Given that Alice can choose to add elements to `c` and remove them from `a`, and Bob just removes elements from `a`, the game is about Alice trying to collect the necessary numbers in `c` while Bob tries to disrupt this by removing elements that could be useful to Alice.

I think the key is to consider the frequency of each number in the array and how many times Alice can pick them.

Since Alice and Bob alternate turns, and Alice goes first, in an array of size `n`, Alice will get to pick ceil(n/2) elements for `c`, and Bob will delete floor(n/2) elements.

But it's not just about the count; it's about which specific elements they pick or delete.

I need to think differently. Maybe consider that Alice can choose which elements go into `c`, and Bob can influence which elements Alice gets by deleting elements that could be useful to her.

But in the program provided, it sorts the array and then iterates through it, updating `cur` based on some conditions.

Let me see if I can find a pattern or a formula that can directly compute the MEX based on the counts of each number.

Suppose we count the frequency of each number from 0 to, say, `n`.

If a number `k` appears at least ceil(count(k)/2) times in `c`, then Alice can ensure that `k` is in `c`.

Wait, perhaps I need to think in terms of the number of times a number is available versus how many times Bob can prevent Alice from picking it.

Let me consider that for each number `k`, if it appears `f_k` times in `a`, then Alice can get ceil(f_k / 2) instances of `k` into `c`, because for every two turns (one Alice, one Bob), Alice can pick one element.

But since Bob can choose to delete elements that Alice wants, or elements that could help Alice.

Wait, perhaps it's better to think in terms of the total number of times Alice can pick elements.

Given that Alice gets to pick ceil(n/2) elements in total, not necessarily specific elements.

But the MEX depends on which numbers are present in `c`, not just how many.

So maybe I need to consider the minimal set of numbers that Alice can collect to maximize the MEX.

I think a better approach is to consider that Alice wants to have as many of the low numbers (0, 1, 2, ...) in `c` as possible, while Bob tries to prevent that.

So, for each number `k`, we need to determine if Alice can ensure that `k` is in `c`.

If Alice can ensure that all numbers from 0 to `k-1` are in `c`, and that `k` is not in `c`, then the MEX would be `k`.

But this seems too vague. Let's try to formalize it.

Let me consider that for each number `k`, the total number of times `k` appears in `a` is `f_k`.

Alice can get ceil(f_k / 2) instances of `k` into `c`, because for each pair of turns, Alice gets one pick.

Wait, but Bob can strategically delete elements to prevent Alice from getting certain numbers.

Actually, Bob can delete elements that Alice wants, or he can delete elements that Alice doesn't need, to minimize the MEX.

Wait, no. Bob's goal is to minimize the MEX, so he would want to prevent Alice from having low numbers in `c`.

So, Bob would delete elements that Alice needs to achieve higher MEX.

But in reality, Bob can delete any element he chooses, not necessarily the ones Alice wants.

So, perhaps it's more accurate to think in terms of the total number of picks Alice has and how she can use them to collect the necessary numbers.

Given that Alice gets ceil(n/2) picks, and Bob gets floor(n/2) picks.

Alice's picks go into `c`, Bob's picks are just deletions from `a`.

So, in the end, `c` contains ceil(n/2) elements, but not necessarily the ones Alice wants.

Wait, actually, Alice chooses which elements to put into `c` with her picks.

So, Alice can select the elements she wants in `c`, and Bob can try to deny her certain elements by deleting them.

But Bob can only delete elements on his turn, not choose which elements Alice picks.

Wait, no. Bob deletes an element on his turn, which is removed from `a`, so it's no longer available for Alice to pick.

So, Bob can choose to delete elements that Alice wants, making them unavailable.

This complicates things.

Let me try to think differently.

Suppose we have the frequency count of each number in `a`.

For each number `k`, if it appears `f_k` times, and Alice needs to have at least one `k` in `c` to include `k` in `c`.

But Bob can delete some of these `k`s to reduce the number available for Alice.

So, for each `k`, the number of times Alice can get `k` into `c` is ceil((f_k - deleted_by_bob)/1), but Bob deletes floor(f_k / 2) or something.

Wait, perhaps for each `k`, the number of times Alice can get `k` into `c` is max(f_k - floor(f_k / 2), 0), which is ceil(f_k / 2).

Because for each pair of turns, Alice gets one pick, and Bob gets one deletion.

So, Alice can get ceil(f_k / 2) instances of `k` into `c`.

Is that correct?

Let me test this with an example.

Suppose `k` appears once. Then Alice can get it into `c` if she picks it before Bob deletes it.

So, if `f_k` = 1, Alice can get it into `c` if she picks it on her first turn.

But if Bob deletes it on his turn, then Alice cannot get it.

Wait, so if `f_k` = 1, Alice can get it into `c` only if she picks it before Bob deletes it.

So, it depends on the order of picks.

Wait, perhaps it's more accurate to say that for each `k`, Alice can get max(f_k - floor(f_k / 2), 0) instances into `c`.

Which is equal to ceil(f_k / 2).

Yes, that makes sense.

So, for each `k`, the number of times Alice can get `k` into `c` is ceil(f_k / 2).

Therefore, for each `k`, if ceil(f_k / 2) >= 1, then Alice can have at least one `k` in `c`.

Otherwise, not.

So, to compute the MEX, we need to find the smallest `k` such that Alice cannot get `k` into `c`, meaning ceil(f_k / 2) == 0, which means f_k == 0.

But wait, if f_k == 0, then obviously Alice cannot get `k` into `c`.

But what if f_k == 1? Then ceil(1 / 2) = 1, so Alice can get it into `c`.

If f_k == 2, ceil(2 / 2) = 1, so again, Alice can get one `k` into `c`.

If f_k == 3, ceil(3 / 2) = 2, so Alice can get two `k`s into `c`.

Wait, but in terms of MEX, we only care if Alice can get at least one `k` into `c`.

So, for each `k`, if f_k >= 1, then Alice can get at least one `k` into `c`, because ceil(f_k / 2) >= 1.

Only if f_k == 0, Alice cannot get `k` into `c`.

Therefore, the MEX would be the smallest `k` for which f_k == 0.

But this seems too straightforward. Is this correct?

Let me check with the example given.

First test case:

n = 4

a = [0, 0, 1, 1]

 frequencies:

0: 2

1: 2

So, for k=0, ceil(2/2)=1, so Alice can get 0 into c.

For k=1, ceil(2/2)=1, so Alice can get 1 into c.

Then, MEX would be 2, since 0 and 1 are present in c.

And in the example, the output is 2, which matches.

Second test case:

n=4

a=[0,1,2,3]

 frequencies:

0:1

1:1

2:1

3:1

For k=0, ceil(1/2)=1, so Alice can get 0 into c.

For k=1, ceil(1/2)=1, so Alice can get 1 into c.

For k=2, ceil(1/2)=1, so Alice can get 2 into c.

For k=3, ceil(1/2)=1, so Alice can get 3 into c.

So, c contains [0,1,2,3], MEX is 4.

But the example output is 1, which contradicts this.

Wait, perhaps my earlier assumption is incorrect.

Looking back, maybe Bob can interfere with Alice's choices.

Wait, perhaps Bob can delete elements that Alice needs.

In the second test case, n=4, a=[0,1,2,3].

Alice wants to maximize MEX, which would mean making c contain as many low numbers as possible.

But the example output is 1, meaning that Bob can prevent Alice from getting 0 into c.

But according to my earlier logic, since f_0=1, Alice should be able to get 0 into c.

Unless Bob deletes 0 before Alice can pick it.

Wait, let's simulate the game.

Turn 1: Alice picks 0 and adds it to c. a now is [1,2,3].

Turn 2: Bob picks, say, 1 and deletes it. a now is [2,3].

Turn 3: Alice picks 2 and adds it to c. c now is [0,2]. a is [3].

Turn 4: Bob picks 3 and deletes it. a is empty.

So, c=[0,2], MEX is 1, which matches the example output.

But according to my earlier logic, Alice should have been able to get both 0 and 1 into c.

But in this scenario, Bob deleted 1, so Alice couldn't pick it.

So, perhaps my initial assumption is incorrect.

Alice can only get ceil(f_k / 2) instances of k into c, but in terms of MEX, she needs at least one of each k starting from 0.

So, for k=0, f_0=1, ceil(1/2)=1, so she can get it.

For k=1, f_1=1, ceil(1/2)=1, but Bob can delete it, so she cannot get it.

Wait, but according to the formula, ceil(f_k / 2) >=1, so she can get it.

But in reality, Bob can delete it before Alice picks it.

So, perhaps the formula needs adjustment.

Let me think differently.

Suppose for each k, the number of times Alice can pick k is ceil((f_k - deleted_by_bob)/1).

But Bob can delete floor(f_k / 2) instances that Alice could have picked.

Wait, perhaps for each k, the number of times Alice can get k into c is max(f_k - floor(f_k / 2), 0).

Which is floor((f_k + 1) / 2).

Yes, that makes sense.

So, Alice can get floor((f_k + 1) / 2) instances of k into c.

This is equivalent to ceil(f_k / 2).

So, in the second test case, for k=0, floor((1 + 1)/2) = 1, so Alice can get 0.

For k=1, floor((1 + 1)/2) = 1, so Alice can get 1.

But in the simulation, Bob deletes 1, so c=[0,2], MEX=1.

This suggests that the formula is not accurate.

Wait, perhaps I need to consider that Bob can delete elements that Alice wants, reducing her effective picks.

So, perhaps for each k, Alice can get max(f_k - floor(f_k / 2), 0) into c.

But in the second test case, f_1=1, floor(1 / 2)=0, so Alice can get 1 into c.

But in the simulation, Bob deletes 1, so Alice cannot get it.

So, perhaps the formula needs to consider that Bob can delete elements that Alice wants.

Therefore, for each k, the number of times Alice can get k into c is f_k - floor(f_k / 2).

Wait, but floor(f_k / 2) is the number of times Bob can delete k.

So, Alice can get f_k - floor(f_k / 2) into c.

Wait, no.

Wait, total picks for Alice are ceil(n / 2), and for Bob floor(n / 2).

But it's not just about total picks, but about which elements they pick.

This is getting complicated.

Maybe I need to think in terms of the game being equivalent to Alice getting to choose ceil(f_k / 2) instances of each k.

Wait, perhaps it's better to look at the provided code and see what it's doing.

In the provided code:

- It sorts the array N.

- Initializes cur = -1.

- Uses a dictionary M to track something.

- Iterates through the sorted array and updates cur based on some conditions.

- Finally, prints cur.

I need to understand what cur represents.

From the first test case, the output is 2, which matches the example.

In the second test case, output is 1, which also matches.

In the third test case, output is 0.

Looking back at the code, it seems to be trying to find the smallest k such that the number of times Alice can get k into c is zero.

But according to the simulation, it seems to be working correctly.

But I need to verify if this logic holds for all cases.

Let me think of another test case.

Test case:

n=3

a=[0,0,0]

 frequencies:

0:3

Alice can get floor((3 + 1)/2) = 2 instances of 0 into c.

So, c will have two 0's, MEX is 1.

But according to the earlier logic, MEX should be 1, but actually, since c has multiple 0's, but MEX is still 1, because 1 is not present.

Wait, no. MEX is the smallest non-negative integer not present in c.

If c=[0,0], then MEX is 1, since 0 is present, but 1 is not.

So, output should be 1.

But according to the formula, ceil(f_0 / 2) = ceil(3 / 2) = 2, so Alice can have two 0's in c.

But she needs to have 1 in c to have MEX greater than 1.

But f_1=0, so she can't have 1 in c.

Hence, MEX is 1.

So, perhaps the program handles this correctly.

Another test case:

n=5

a=[0,1,2,3,4]

 frequencies:

0:1

1:1

2:1

3:1

4:1

Alice can get floor((1 + 1)/2)=1 for each k.

So, she can have one of each in c.

So, c=[0,1,2,3,4], MEX is 5.

But according to the program, let's see.

Sorted array: [0,1,2,3,4]

cur = -1

M = {}

Iterate through N:

num=0 > cur=-1, since 0 > -1 +1=0, cur +=1=0, M[0]=1

num=1 > cur=0, since 1 > 0 +1=1, cur +=1=1, M[1]=1

num=2 > cur=1, since 2 > 1 +1=2, cur +=1=2, M[2]=1

num=3 > cur=2, since 3 > 2 +1=3, cur +=1=3, M[3]=1

num=4 > cur=3, since 4 > 3 +1=4, cur +=1=4, M[4]=1

sum(M[k])=5 == S=5, so cur +=1=5

cnt=[] (since all M[k]=1, but cur=5, which is not in M)

print(cur=5)

Which matches the expected MEX of 5.

Another test case:

n=6

a=[0,0,1,1,2,2]

 frequencies:

0:2

1:2

2:2

Alice can get ceil(2 / 2)=1 for each k.

So, she can have one of each in c.

c=[0,1,2], MEX is 3.

According to the program:

Sorted array: [0,0,1,1,2,2]

cur=-1

M={}

num=0 > cur=-1, since 0 > -1 +1=0, cur=0, M[0]=1

num=0 == cur=0, M[0]=2

num=1 > cur=0, since 1 > 0 +1=1, cur=1, M[1]=1

num=1 == cur=1, M[1]=2

num=2 > cur=1, since 2 > 1 +1=2, cur=2, M[2]=1

num=2 == cur=2, M[2]=2

sum(M[k])=6 == S=6, cur +=1=3

cnt=[] (since M[k]=2 for all k)

print(cur=3)

Which matches the expected MEX of 3.

Seems correct.

Another test case:

n=2

a=[0,1]

 frequencies:

0:1

1:1

Alice can get ceil(1 / 2)=1 for each k.

So, she can have 0 and 1 in c.

c=[0,1], MEX is 2.

According to the program:

Sorted array: [0,1]

cur=-1

M={}

num=0 > cur=-1, since 0 > -1 +1=0, cur=0, M[0]=1

num=1 > cur=0, since 1 > 0 +1=1, cur=1, M[1]=1

sum(M[k])=2 == S=2, cur +=1=2

cnt=[] (since M[k]=1 for all k)

print(cur=2)

Which matches the expected MEX of 2.

Another test case:

n=1

a=[0]

 frequencies:

0:1

Alice can get ceil(1 / 2)=1, so c=[0], MEX is 1.

According to the program:

Sorted array: [0]

cur=-1

M={}

num=0 > cur=-1, since 0 > -1 +1=0, cur=0, M[0]=1

sum(M[k])=1 == S=1, cur +=1=1

cnt=[] (since M[k]=1)

print(cur=1)

Which matches the expected MEX of 1.

Another test case:

n=2

a=[0,0]

 frequencies:

0:2

Alice can get ceil(2 / 2)=1, so c=[0], MEX is 1.

According to the program:

Sorted array: [0,0]

cur=-1

M={}

num=0 > cur=-1, since 0 > -1 +1=0, cur=0, M[0]=1

num=0 == cur=0, M[0]=2

sum(M[k])=2 == S=2, cur +=1=1

cnt=[] (since M[k]=2)

print(cur=1)

Which matches the expected MEX of 1.

Another test case:

n=3

a=[0,1,1]

 frequencies:

0:1

1:2

Alice can get ceil(1 / 2)=1 for 0, and ceil(2 / 2)=1 for 1.

So, c=[0,1], MEX is 2.

According to the program:

Sorted array: [0,1,1]

cur=-1

M={}

num=0 > cur=-1, since 0 > -1 +1=0, cur=0, M[0]=1

num=1 > cur=0, since 1 > 0 +1=1, cur=1, M[1]=1

num=1 == cur=1, M[1]=2

sum(M[k])=3 == S=3, cur +=1=2

cnt=[] (since M[k]=1 for k=0,1 and M[1]=2)

print(cur=2)

Which matches the expected MEX of 2.

Seems consistent.

Wait, but earlier I thought that Bob can delete elements to prevent Alice from getting certain numbers, but in these test cases, it seems that the formula holds.

Perhaps the formula is correct: for each k, Alice can get ceil(f_k / 2) instances