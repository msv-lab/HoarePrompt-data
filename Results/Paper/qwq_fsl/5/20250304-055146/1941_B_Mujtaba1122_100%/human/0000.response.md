Alright, I have this task to verify the correctness of a given Python program based on a problem description. If the program meets the requirements for every potential case, I should print "True"; otherwise, "False". I need to be thorough and consider all possible edge cases to ensure the program's correctness.

Let's start by understanding the problem description. Rudolf has an array of integers, and he can perform a specific operation any number of times. The operation involves choosing an index i (where 2 ≤ i ≤ n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to determine whether it's possible to make all elements of the array zero using these operations.

The program provided is supposed to handle multiple test cases, each consisting of an array of integers, and for each test case, output "YES" if it's possible to make all elements zero, otherwise "NO".

First, I need to understand the logic behind the program. The function `func_2` seems to be the main function that processes each test case. It iterates through the array from the second element to the second-to-last element. For each index i in this range, it enters a while loop that continues as long as certain conditions are met: list[i] > 1, list[i-1] > 0, and list[i+1] > 0. In each iteration of the while loop, it subtracts multiples of list[i-1] from list[i+1], list[i], and list[i-1] itself.

After this loop, it checks if list[i-1] has become zero. If not, it prints 'no' and returns. Finally, it calls `func_1` to check if the entire list is zero. If yes, it prints 'YES'; otherwise, 'NO'.

I need to evaluate whether this logic correctly determines whether it's possible to make all elements zero.

Let me think about the problem more deeply. The operations allowed suggest that each operation reduces the sum of the array by 4 (since 1 + 2 + 1 = 4). Therefore, for it to be possible to make all elements zero, the total sum of the array must be divisible by 4. However, this alone is not sufficient, as the operations are constrained by the positions where they can be applied.

Moreover, the operations can only be performed on elements where 2 ≤ i ≤ n-1, meaning the first and last elements cannot be directly modified except through operations on their adjacent elements.

I need to check if the program's logic aligns with these observations.

Looking back at the program, I see that in the while loop inside `func_2`, it subtracts multiples of list[i-1] from list[i+1], list[i], and list[i-1]. This seems unclear. Specifically, `list[i + 1] -= 1 * list[i - 1]` and similar operations suggest that it's subtracting list[i-1] from list[i+1], 2*list[i-1] from list[i], and list[i-1] from list[i-1]. This doesn't seem to match the operation described in the problem, which is to subtract fixed values (1, 2, 1) from the respective elements.

Wait, the problem allows subtracting 1 from list[i-1], 2 from list[i], and 1 from list[i+1], but the program seems to be subtracting multiples of list[i-1], which is different.

This is a red flag. The program is not implementing the operation as described in the problem. Instead of subtracting fixed values (1, 2, 1), it's subtracting values proportional to list[i-1].

Let me look at the code again:

```python

while list[i] > 1 and list[i - 1] > 0 and (list[i + 1] > 0):

list[i + 1] -= 1 * list[i - 1]

list[i] -= 2 * list[i - 1]

list[i - 1] -= 1 * list[i - 1]

```

This seems to be attempting to perform the operation multiple times, specifically list[i-1] times. But this is not how the operation is defined. The operation should be performed by choosing an index i and subtracting 1 from list[i-1], 2 from list[i], and 1 from list[i+1], but only once per operation, not multiplied by list[i-1].

This suggests a fundamental misunderstanding in the implementation of the operation.

Given this discrepancy, I suspect that the program is incorrect.

But to be thorough, let's consider the examples provided in the problem.

Take the first example:

Input:

7

5

1 3 5 5 2

5

2 4 4 5 1

5

0 1 3 3 1

6

5 6 0 2 3 0

4

1 2 7 2

3

7 1 0

4

1 1 1 1

Output:

YES

NO

YES

NO

NO

NO

NO

Let's see if the program would produce the correct output for the first test case.

First test case:

n = 5

a = [1, 3, 5, 5, 2]

According to the problem, it's possible to make all elements zero with a series of operations, as shown in the example.

But according to the program's logic, it would iterate through i from 1 to 3.

For i=1:

Check if a[1]>1, a[0]>0, a[2]>0:

a[1]=3>1, a[0]=1>0, a[2]=5>0.

Enter while loop:

a[2] -= 1*a[0] => a[2] = 5 - 1*1 = 4

a[1] -= 2*a[0] => a[1] = 3 - 2*1 = 1

a[0] -= 1*a[0] => a[0] = 1 - 1*1 = 0

Now, a = [0,1,4,5,2]

Check if a[i-1] == 0, which is a[0] == 0, so continue.

For i=2:

a[2]=4>1, a[1]=1>0, a[3]=5>0.

Enter while loop:

a[3] -= 1*a[1] => a[3] = 5 - 1*1 = 4

a[2] -= 2*a[1] => a[2] = 4 - 2*1 = 2

a[1] -= 1*a[1] => a[1] = 1 - 1*1 = 0

Now, a = [0,0,2,4,2]

Check if a[i-1] == 0, which is a[1] == 0, so continue.

For i=3:

a[3]=4>1, a[2]=2>0, a[4]=2>0.

Enter while loop:

a[4] -= 1*a[2] => a[4] = 2 - 1*2 = 0

a[3] -= 2*a[2] => a[3] = 4 - 2*2 = 0

a[2] -= 1*a[2] => a[2] = 2 - 1*2 = 0

Now, a = [0,0,0,0,0]

func_1 would return True, so it prints 'YES'.

This matches the expected output.

But let's consider another test case where n=4 and a=[1,2,7,2].

According to the program:

For i=1:

a[1]=2>1, a[0]=1>0, a[2]=7>0.

Enter while loop:

a[2] -= 1*a[0] => a[2]=7-1*1=6

a[1] -= 2*a[0] => a[1]=2-2*1=0

a[0] -= 1*a[0] => a[0]=1-1*1=0

Now, a=[0,0,6,2]

Check if a[i-1]==0, which is a[0]==0, so continue.

For i=2:

a[2]=6>1, a[1]=0>0 is False, so skip.

For i=2, since a[1]=0, condition fails, so no further operations.

Now, check func_1: a=[0,0,6,2], which are not all zero, so prints 'NO'.

This also matches the expected output.

But I need to think about whether the program's logic is correct in general, not just for these specific cases.

Given that the program is misinterpreting the operation by subtracting multiples of list[i-1] instead of fixed values, I suspect that it's coincidentally working for some cases but may fail for others.

Let's consider a case where the program might fail.

Suppose n=5 and a=[0,2,2,2,0].

According to the problem, we can perform operations on i=2,3,4.

Let's see:

Operation on i=3:

a[2] -=1, a[3]-=2, a[4]-=1 => a=[0,2,1,0,0]

Now, a=[0,2,1,0,0]

Operation on i=2:

a[1]-=1, a[2]-=2, a[3]-=1 => a=[0,1,-1,0,0]

But negative values are allowed since the problem doesn't specify anything about them, but the goal is to make all zeros.

Continuing:

Operation on i=2 again:

a[1]-=1, a[2]-=2, a[3]-=1 => a=[0,0,-3,0,0]

Now, a=[0,0,-3,0,0]

This doesn't lead to all zeros, but perhaps there's a different sequence.

Alternatively, starting with i=2:

a[1]-=1, a[2]-=2, a[3]-=1 => a=[-1,0,1,0,0]

Then, operation on i=3:

a[2]-=1, a[3]-=2, a[4]-=1 => a=[-1,0,0,-2,0]

This still doesn't reach all zeros.

It seems that for this input, it's not possible to make all elements zero.

Now, let's see what the program would do with this input.

For i=1:

a[1]=2>1, a[0]=0>0 is False, so skip.

For i=2:

a[2]=2>1, a[1]=2>0, a[3]=2>0.

Enter while loop:

a[3] -=1*a[1] => a[3]=2-1*2=0

a[2] -=2*a[1] => a[2]=2-2*2=-2

a[1] -=1*a[1] => a[1]=2-1*2=0

Now, a=[0,0,-2,0,0]

Check if a[i-1]==0, which is a[1]==0, so continue.

For i=3:

a[3]=0>1 is False, so skip.

Now, check func_1: a=[0,0,-2,0,0], which are not all zero, so prints 'NO'.

This matches the expected behavior.

But let's consider another case: n=4, a=[1,2,1,1]

According to the problem, can we make all zeros?

Operation on i=2:

a[1]-=1, a[2]-=2, a[3]-=1 => a=[0,0,0,1]

Now, only a[3]=1 remains, which cannot be changed since operations can only be performed on i=2.

So, it's not possible to make all zeros.

According to the program:

For i=1:

a[1]=2>1, a[0]=1>0, a[2]=1>0.

Enter while loop:

a[2] -=1*a[0] => a[2]=1-1*1=0

a[1] -=2*a[0] => a[1]=2-2*1=0

a[0] -=1*a[0] => a[0]=1-1*1=0

Now, a=[0,0,0,1]

For i=2:

a[2]=0>1 is False, so skip.

Check func_1: a=[0,0,0,1], not all zero, so prints 'NO'.

Again, correct.

But let's think about a case where the program might fail.

Consider n=5, a=[2,2,2,2,2]

According to the problem, can we make all zeros?

Operation on i=2:

a[1]-=1, a[2]-=2, a[3]-=1 => a=[1,0,1,2,2]

Operation on i=3:

a[2]-=1, a[3]-=2, a[4]-=1 => a=[1,0,0,0,1]

Now, a=[1,0,0,0,1]

We can't perform any more operations to make a[0] and a[4] zero.

So, it's not possible.

According to the program:

For i=1:

a[1]=2>1, a[0]=2>0, a[2]=2>0.

Enter while loop:

a[2] -=1*a[0] => a[2]=2-1*2=0

a[1] -=2*a[0] => a[1]=2-2*2=-2

a[0] -=1*a[0] => a[0]=2-1*2=0

Now, a=[0,-2,0,2,2]

Check if a[i-1]==0, which is a[0]==0, so continue.

For i=2:

a[2]=0>1 is False, skip.

For i=3:

a[3]=2>1, a[2]=0>0 is False, skip.

Check func_1: a=[0,-2,0,2,2], not all zero, so prints 'NO'.

Correct.

Another case: n=3, a=[1,2,1]

According to the problem, can we make all zeros?

Operation on i=2:

a[1]-=1, a[2]-=2, a[3]-=1 => a=[0,0,0]

Yes, it's possible.

According to the program:

For i=1:

a[1]=2>1, a[0]=1>0, a[2]=1>0.

Enter while loop:

a[2] -=1*a[0] => a[2]=1-1*1=0

a[1] -=2*a[0] => a[1]=2-2*1=0

a[0] -=1*a[0] => a[0]=1-1*1=0

Now, a=[0,0,0]

Check if a[i-1]==0, which is a[0]==0, so continue.

For i=2:

a[2]=0>1 is False, skip.

Check func_1: a=[0,0,0], all zero, so prints 'YES'.

Correct.

Wait a minute, earlier I thought that the program is incorrect because it's subtracting multiples of list[i-1], but in these examples, it seems to be working correctly.

Maybe I need to reconsider my initial assumption.

Perhaps the program is implementing a different but equivalent logic to solve the problem.

Let me think differently.

The problem allows performing operations that subtract (1,2,1) from three consecutive elements any number of times.

The goal is to make the entire array zero.

This is similar to solving a system of equations where each operation affects three consecutive elements.

This seems related to linear algebra, where we can model the array as a vector and operations as vectors subtracted from it.

But perhaps there's a simpler way.

I recall that for such problems, there are methods to check if a target state can be reached by performing a series of operations.

In this case, the operations are subtracting (1,2,1) from three consecutive elements.

I need to determine if, by performing these operations, I can transform the initial array into an array of all zeros.

Given that, perhaps there's a pattern or a formula to check the possibility without simulating the operations.

Let me consider the sum of the array.

Each operation subtracts a total of 4 from the array sum.

Therefore, for it to be possible to reach zero, the initial sum must be divisible by 4.

But is this condition sufficient?

Wait, no. Consider an array [2,2,2]. Sum is 6, which is not divisible by 4, so it's impossible. Which matches the earlier example.

Another array [1,3,5,5,2]. Sum is 16, which is divisible by 4, and it's possible.

But consider [1,2,7,2]. Sum is 12, which is divisible by 4, but earlier I thought it's not possible. Wait, but according to the program, it's printing 'NO', which matches the expected output.

Wait, but according to the problem's example output, it's 'NO'.

So, sum being divisible by 4 is a necessary condition, but not sufficient.

There must be another condition to check.

Perhaps the differences between elements must satisfy certain properties.

Alternatively, maybe the array must satisfy certain constraints based on the operations allowed.

Let me think about the operations again.

Each operation subtracts 1 from the left neighbor, 2 from the current element, and 1 from the right neighbor.

This operation can be performed on any index i where 2 ≤ i ≤ n-1.

I need to find a way to make all elements zero.

This seems similar to solving a system of equations where each operation corresponds to subtracting a specific vector from the array.

But this might be too time-consuming to think about.

Looking back at the program, perhaps the author intended to simulate the operations in a greedy way.

In `func_2`, it iterates from the second element to the second-last element, and for each i, it performs operations as long as a[i-1], a[i], and a[i+1] are greater than 0 (with a[i] >1).

After these operations, it checks if a[i-1] is zero.

If not, it prints 'no'.

Finally, it checks if the entire array is zero.

But I'm still unsure about the correctness of this approach.

Let me consider another test case.

Suppose n=5, a=[4,4,4,4,4]

Sum is 20, which is divisible by 4.

Can we make all elements zero?

Operation on i=2:

a=[4,4,4,4,4] -> [3,2,3,4,4]

Operation on i=2:

[3,2,3,4,4] -> [2,0,2,4,4]

Now, a[1]=2, a[2]=0, a[3]=2, a[4]=4, a[5]=4

Operation on i=3:

[2,0,2,4,4] -> [2,0,0,2,4]

Operation on i=4:

[2,0,0,2,4] -> [2,0,0,0,2]

Now, a=[2,0,0,0,2]

I can't perform any more operations because there are no i where 2 ≤ i ≤ n-1 with a[i] >1 and a[i-1] >0 and a[i+1] >0.

So, it's not possible to make all elements zero.

According to the program:

For i=1:

a[1]=4>1, a[0]=4>0, a[2]=4>0.

Enter while loop:

a[2] -=1*a[0] => a[2]=4-1*4=0

a[1] -=2*a[0] => a[1]=4-2*4=-4

a[0] -=1*a[0] => a[0]=4-1*4=0

Now, a=[0,-4,0,4,4]

Check if a[i-1]==0, which is a[0]==0, so continue.

For i=2:

a[2]=0>1 is False, skip.

For i=3:

a[3]=4>1, a[2]=0>0 is False, skip.

Check func_1: a=[0,-4,0,4,4], not all zero, so prints 'NO'.

Correct.

Another test case: n=5, a=[0,0,0,0,0]

Already all zeros, should print 'YES'.

According to the program:

For i=1:

a[1]=0>1 is False, skip.

Check func_1: a=[0,0,0,0,0], all zero, prints 'YES'.

Correct.

Another test case: n=5, a=[1,3,5,5,2]

As in the first example, the program correctly prints 'YES'.

Seems consistent.

Wait, but I still think the program's logic is flawed because it's not implementing the operations as described.

But according to all the test cases I've considered, it's giving the correct output.

Perhaps there's a different way to look at the problem that makes this approach valid.

Let me consider the problem differently.

Suppose I model the array as a system where each operation affects three consecutive elements.

I need to find a combination of operations that results in the entire array being zero.

This can be represented as solving a system of linear equations.

But that might be too time-consuming for this task.

Alternatively, perhaps there's a pattern or invariant that can be used to determine the possibility without simulating all operations.

Looking back at the program, it seems to be using a greedy approach to perform operations wherever possible and then checks if the array is zero.

Given that it's working for the test cases I've thought of, maybe it's correct.

But to be thorough, I need to think of a case where this approach fails.

Suppose n=6, a=[1,2,3,4,5,6]

Sum is 21, which is not divisible by 4, so it's impossible.

According to the program:

For i=1:

a[1]=2>1, a[0]=1>0, a[2]=3>0.

Enter while loop:

a[2] -=1*a[0] => a[2]=3-1*1=2

a[1] -=2*a[0] => a[1]=2-2*1=0

a[0] -=1*a[0] => a[0]=1-1*1=0

Now, a=[0,0,2,4,5,6]

For i=2:

a[2]=2>1, a[1]=0>0 is False, skip.

For i=3:

a[3]=4>1, a[2]=2>0, a[4]=5>0.

Enter while loop:

a[4] -=1*a[2] => a[4]=5-1*2=3

a[3] -=2*a[2] => a[3]=4-2*2=0

a[2] -=1*a[2] => a[2]=2-1*2=0

Now, a=[0,0,0,0,3,6]

For i=4:

a[4]=3>1, a[3]=0>0 is False, skip.

Check func_1: a=[0,0,0,0,3,6], not all zero, so prints 'NO'.

Correct, since sum is not divisible by 4.

But wait, sum is 21, which is not divisible by 4, and indeed it's not possible.

Another case: n=5, a=[4,0,2,0,4]

Sum is 10, which is not divisible by 4, so it's impossible.

According to the program:

For i=1:

a[1]=0>1 is False, skip.

For i=2:

a[2]=2>1, a[1]=0>0 is False, skip.

For i=3:

a[3]=0>1 is False, skip.

Check func_1: a=[4,0,2,0,4], not all zero, so prints 'NO'.

Correct.

Seems consistent.

Wait, but in this case, sum is 10, not divisible by 4, and it's correctly identifying it as 'NO'.

But is the program always checking for sum divisibility by 4?

Wait, no, because in the earlier case of n=5, a=[2,2,2,2,2], sum=10, not divisible by 4, and it's correctly identifying it as 'NO'.

But in the case of n=5, a=[1,3,5,5,2], sum=16, which is divisible by 4, and it's 'YES'.

So, perhaps the program is indirectly checking for sum divisibility by 4, plus some other conditions.

But I need to think of a case where sum is divisible by 4, but it's not possible to make all zeros, and see if the program correctly identifies it as 'NO'.

Consider n=5, a=[0,4,0,4,0]

Sum is 8, which is divisible by 4.

Can we make all zeros?

Operation on i=2:

a=[0,4,0,4,0] -> [0,2,-1,3,0]

Operation on i=3:

[0,2,-1,3,0] -> [0,2,-1,1,-1]

Now, a=[0,2,-1,1,-1]

This doesn't seem to be leading to all zeros.

Another approach:

Operation on i=4:

a=[0,4,0,4,0] -> [-1,2,-1,2,0]

Then operation on i=2:

[-1,2,-1,2,0] -> [-1,0,-3,2,0]

Still not all zeros.

Seems impossible.

According to the program:

For i=1:

a[1]=4>1, a[0]=0>0 is False, skip.

For i=2:

a[2]=0>1 is False, skip.

For i=3:

a[3]=4>1, a[2]=0>0 is False, skip.

Check func_1: a=[0,4,0,4,0], not all zero, so prints 'NO'.

Correct.

Another case: n=5, a=[3,2,3,2,3]

Sum is 13, not divisible by 4, so it's impossible.

According to the program:

For i=1:

a[1]=2>1, a[0]=3>0, a[2]=3>0.

Enter while loop:

a[2] -=1*a[0] => a[2]=3-1*3=0

a[1] -=2*a[0] => a[1]=2-2*3=-4

a[0] -=1*a[0] => a[0]=3-1*3=0

Now, a=[0,-4,0,2,3]

For i=2:

a[2]=0>1 is False, skip.

For i=3:

a[3]=2>1, a[2]=0>0 is False, skip.

Check func_1: a=[0,-4,0,2,3], not all zero, so prints 'NO'.

Correct.

I'm starting to think that the program is correct, despite my initial confusion about its logic.

Perhaps the while loop is effectively reducing the array in a way that, if it's possible to reach all zeros, it will do so.

But I still have a lingering doubt about whether this approach covers all possible scenarios.

Let me consider a case where the sum is divisible by 4, and it is possible to make all zeros, and see if the program handles it correctly.

Consider n=5, a=[2,2,2,2,2], but wait, sum is 10, not divisible by 4, so it's impossible.

Wait, earlier I thought sum must be divisible by 4, but is that always the case?

Wait, each operation subtracts 4 from the total sum, so the initial sum must be divisible by 4 for it to be possible to reach zero.

But in the first test case, sum is 16, which is divisible by 4, and it's possible.

In the second test case, sum is 14, which is not divisible by 4, and it's impossible.

Wait, but in the second test case, sum is 2+4+4+5+1=16, which is divisible by 4, but according to the example output, it's 'NO'.

Wait, that contradicts my earlier assumption.

Wait, in the first test case, sum is 1+3+5+5+2=16, which is divisible by 4, and it's 'YES'.

Second test case, sum is 2+4+4+5+1=16, which is divisible by 4, but it's 'NO'.

Wait, but according to the example output, it's 'NO'.

So, sum being divisible by 4 is not sufficient.

There must be another condition.

Hence, my earlier assumption is incorrect.

There must be another constraint beyond the sum being divisible by 4.

Looking back at the problem, perhaps the differences between certain elements must satisfy some conditions.

Alternatively, maybe the array must be such that certain prefixes or suffixes satisfy specific properties.

Given that, perhaps the program is implementing a correct, though non-obvious, method to check for these conditions.

But I'm still not entirely sure.

Let me consider another approach.

Suppose I try to model the operations as a system of equations.

Let’s denote the number of times operation is performed at position i as x_i.

Then, for each position j, the total subtraction from a[j] is:

- For j=1: x_2

- For j=2: 2x_2 + x_3

- For j=3: 2x_3 + x_4

- ...

- For j=n-1: 2x_{n-1} + x_n

- For j=n: x_n

Wait, no, let's think again.

Each operation at i subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, for each i from 2 to n-1, operation x_i times.

Then, the total subtraction from a[j] is:

- a[1]: subtracted x_2 times (since only operations at i=2 affect a[1])

- a[2]: subtracted 2x_2 + x_3

- a[3]: subtracted x_2 + 2x_3 + x_4

- ...

- a[n-1]: subtracted x_{n-2} + 2x_{n-1} + x_n

- a[n]: subtracted x_{n-1}

Wait, no, a[n] is only affected by operations at i=n-1, subtracting 1 each time.

Similarly, a[1] is only affected by operations at i=2, subtracting 1 each time.

Generalizing, for j from 1 to n:

- a[1]: subtracted x_2

- a[j]: subtracted x_{j} + x_{j+1} for 2 ≤ j ≤ n-1

- a[n]: subtracted x_{n-1}

Wait, perhaps I need to set up the equations properly.

Let me define x_i as the number of times operation is performed at position i (2 ≤ i ≤ n-1).

Then, for each a[j], the total subtraction is:

- a[1]: subtracted x_2

- a[2]: subtracted 2x_2 + x_3

- a[3]: subtracted x_2 + 2x_3 + x_4

- ...

- a[k]: subtracted x_{k-1} + 2x_k + x_{k+1} for 2 ≤ k ≤ n-1

- a[n-1]: subtracted x_{n-2} + 2x_{n-1} + x_n

- a[n]: subtracted x_{n-1}

Wait, no, more accurately:

- a[1]: subtracted x_2

- a[2]: subtracted 2x_2 + x_3

- a[3]: subtracted x_2 + 2x_3 + x_4

- ...

- a[j]: subtracted x_{j-1} + 2x_j + x_{j+1} for 2 ≤ j ≤ n-1

- a[n-1]: subtracted x_{n-2} + 2x_{n-1} + x_n

- a[n]: subtracted x_{n-1}

Wait, but in the operation, for i, it's a[i-1]-1, a[i]-2, a[i+1]-1.

Hence, for a[j], the subtraction is:

- From operations at i=j-1: subtracts 1 if j-1 >=2, else 0

- From operations at i=j: subtracts 2

- From operations at i=j+1: subtracts 1 if j+1 <=n-1, else 0

Wait, perhaps I need to set up equations for each a[j]:

For j=1:

a[1] - x_2 = 0 => x_2 = a[1]

For j=2:

a[2] - 2x_2 - x_3 = 0

For j=3:

a[3] - x_2 - 2x_3 - x_4 = 0

...

For j=k:

a[k] - x_{k-1} - 2x_k - x_{k+1} = 0

...

For j=n-1:

a[n-1] - x_{n-2} - 2x_{n-1} - x_n = 0

For j=n:

a[n] - x_{n-1} = 0 => x_{n-1} = a[n]

This gives a system of equations that needs to be solved for x_2 to x_{n-1}.

This seems like a system of linear equations that can be solved.

But solving this system for large n (up to 2e5) is not feasible in this context.

Given that, perhaps there's a smarter way to check if the system has a solution.

Looking back at the program, perhaps it's implementing a method to solve this system in a greedy manner.

Given that, and considering that it's working for all the test cases I've thought of, maybe it's correct.

But to be thorough, I need to think of a case where the program might fail.

Let me consider n=4, a=[1,2,1,1]

Sum is 5, which is not divisible by 4, so it's impossible.

According to the program, it's printing 'NO', which is correct.

Another case: n=4, a=[0,0,0,0], sum=0, which is divisible by 4, and it's 'YES'.

According to the program, it's 'YES', correct.

Another case: n=5, a=[1,3,5,5,2], sum=16, divisible by 4, and it's 'YES'.

Program prints 'YES', correct.

Another case: n=5, a=[2,4,4,5,1], sum=16, divisible by 4, but it's 'NO'.

Program prints 'NO', correct.

I'm running out of potential counterexamples.

Perhaps the program is correct, and my initial confusion was due to misinterpreting the operations.

Given that, I should conclude that the program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]