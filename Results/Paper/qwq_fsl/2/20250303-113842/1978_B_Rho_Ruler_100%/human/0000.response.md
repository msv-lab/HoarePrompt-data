Alright, I've been given this task to verify the correctness of a Python program based on a provided problem description. The program is supposed to help Bob determine the maximum profit he can obtain from selling his buns with a special promotion. There are multiple test cases, and for each, the program reads three integers: n (the number of buns), a (the usual price of a bun), and b (the price of the first bun sold at a modified price).

The problem allows Bob to choose an integer k (0 ≤ k ≤ min(n, b)) such that the first k buns are sold at a modified price, where the i-th bun is sold for (b - i + 1) coins, and the remaining (n - k) buns are sold at the usual price a.

The goal is to maximize the total profit from selling all n buns.

Looking at the provided program, it seems to use a binary search approach to find the optimal k that maximizes the profit. There are two functions: func_1 and func_2.

- func_1 calculates the profit for a given k.

- func_2 performs a binary search to find the maximum profit by iterating over possible k values from 0 to min(n, b).

First, I need to understand if this program correctly implements the logic to find the maximum profit as described.

Let's break it down step by step.

## Approach

1. **Understanding the Profit Calculation:**
   - For a given k, the profit is calculated as the sum of the modified prices for the first k buns plus the usual price for the remaining (n - k) buns.
   - The modified price for the i-th bun (1 ≤ i ≤ k) is (b - i + 1).
   - Therefore, the total profit for a given k is: sum_{i=1 to k} (b - i + 1) + a * (n - k).

2. **Simplifying the Profit Formula:**
   - The sum of the modified prices for the first k buns is: k*b - sum_{i=1 to k} i + sum_{i=1 to k} 1 = k*b - k*(k+1)/2 + k = k*b - k*(k+1)/2 + k.
   - Simplifying further: k*b - k*(k+1)/2 + k = k*(b - (k+1)/2 + 1) = k*(b - (k-1)/2).
   - But in the code, it's implemented as: k * b - k * (k - 1) // 2 + (n - k) * a.

3. **Binary Search for Optimal k:**
   - The program uses binary search over k from 0 to min(n, b) to find the k that maximizes the profit.
   - It maintains a variable max_profit to keep track of the best profit found.
   - In each iteration, it calculates the profit for mid and mid + 1, and updates the search range based on which profit is higher.

## Solution Code

```python
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        (n, a, b) = map(int, input().split())
        print(func_2(n, a, b))

def func_1(k, n, a, b):
    return k * b - k * (k - 1) // 2 + (n - k) * a

def func_2(n, a, b):
    (low, high) = (0, min(n, b))
    max_profit = 0
    while low <= high:
        mid = (low + high) // 2
        profit_mid = func_1(mid, n, a, b)
        profit_next = func_1(mid + 1, n, a, b)
        max_profit = max(max_profit, profit_mid)
        if profit_next > profit_mid:
            low = mid + 1
        else:
            high = mid - 1
    return max_profit
```

## Explanation

1. **Profit Calculation (func_1):**
   - This function calculates the profit for a given k using the formula: k * b - k * (k - 1) // 2 + (n - k) * a.
   - This formula correctly computes the sum of the modified prices for the first k buns and the usual price for the remaining buns.

2. **Binary Search (func_2):**
   - The binary search is used to efficiently find the optimal k that maximizes the profit.
   - It initializes the search range from low = 0 to high = min(n, b).
   - In each iteration, it calculates the profit for the middle value mid and the next value mid + 1.
   - If the profit of mid + 1 is greater than mid, it means higher k values could yield higher profits, so it sets low = mid + 1.
   - Otherwise, it sets high = mid - 1 to search lower k values.
   - The maximum profit found during the search is returned.

This approach ensures that the program efficiently finds the optimal k for each test case, even for large values of n, a, and b, by leveraging the binary search algorithm's logarithmic time complexity.

## Final Solution
To solve this problem, we need to maximize Bob's profit from selling buns with a promotional pricing strategy. We achieve this by carefully selecting the number of buns sold at a modified price to maximize total revenue.

### Approach
1. **Understanding the Profit Calculation:**
   - For a given `k`, the profit is the sum of modified prices for the first `k` buns plus the usual price for the remaining `n - k` buns.
   - The modified price for the `i`-th bun is `(b - i + 1)`.

2. **Simplifying the Profit Formula:**
   - The sum of modified prices for `k` buns is calculated as `k * b - k * (k - 1) // 2`.
   - The sum for the remaining buns is `(n - k) * a`.

3. **Binary Search for Optimal `k`:**
   - We use binary search over `k` from 0 to `min(n, b)` to efficiently find the `k` that maximizes profit.
   - In each iteration, we calculate the profit for the middle value `mid` and the next value `mid + 1`.
   - Adjust the search range based on which profit is higher.

### Solution Code
```python
def func_1(k, n, a, b):
    return k * b - k * (k - 1) // 2 + (n - k) * a

def func_2(n, a, b):
    low, high = 0, min(n, b)
    max_profit = 0
    while low <= high:
        mid = (low + high) // 2
        profit_mid = func_1(mid, n, a, b)
        if mid + 1 <= high:
            profit_next = func_1(mid + 1, n, a, b)
            if profit_next > profit_mid:
                low = mid + 1
            else:
                high = mid - 1
            max_profit = max(max_profit, profit_mid, profit_next)
        else:
            high = mid - 1
            max_profit = max(max_profit, profit_mid)
    return max_profit

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n, a, b = map(int, input().split())
        print(func_2(n, a, b))
```

### Explanation
1. **Profit Calculation (func_1):**
   - Computes the total profit for a given `k` using the formula: `k * b - k * (k - 1) // 2 + (n - k) * a`.

2. **Binary Search (func_2):**
   - Initializes the search range from `low = 0` to `high = min(n, b)`.
   - Uses a while loop to perform binary search:
     - Calculates the profit for `mid` and `mid + 1`.
     - Adjusts the search range based on which profit is higher.
     - Keeps track of the maximum profit found.
   - Returns the maximum profit after the search completes.

This method ensures efficient computation even for large input values, leveraging binary search to achieve optimal performance.