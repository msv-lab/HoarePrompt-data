Alright, I have this task to verify the correctness of a given Python program based on its problem description. I need to determine whether the program meets the requirements as specified in the description. If it does, I should print "True"; otherwise, "False". It's important to note that partial correctness isn't acceptable; the program must handle all potential cases correctly to be considered correct.

I've been provided with some examples to understand how this works. In Example 1, the problem is to identify non-prime numbers, and the provided program seems to do that correctly, so the correctness is True. In Example 2, the task is to count substrings starting and ending with the same character, but the program provided might not be handling all cases correctly, hence Correctness is False. Similarly, in Example 3, the binary search function is incorrect, so Correctness is False.

Now, for my actual task, I have a more complex problem description involving friendship values among children in a class and how these values change over multiple excursions. The teacher randomly selects pairs of children for excursions, and if they are friends, their friendship value increases by 1 for each subsequent excursion. The goal is to calculate the expected value of the sum of friendship values over all excursions, and this value should be expressed as a fraction p/q, where p and q are coprime, and then compute p * q^{-1} mod (10^9 + 7).

The program provided defines a module-level constant MOD set to 10^9 + 7 and contains two functions: func_1 and func_2. func_2 reads input for multiple test cases and calls func_1 for each test case to compute the result, which is then printed.

Looking at func_1, it takes parameters n (number of children), m (number of friend pairs), k (number of excursions), and friendships (a list of friend pairs with their initial friendship values). The function iterates through each friendship, and for each, it seems to calculate f * (k * (k + 1) // 2) % MOD, where f is the friendship value, and accumulates this to the result.

Wait a minute, this seems off. The problem describes that for each excursion, a pair is chosen randomly, and if they are friends, their friendship value increases by 1 for all subsequent excursions. This implies that the friendship values can increase over time based on how many times they are chosen together.

However, in the provided program, func_1 seems to be calculating something differently. It's summing up, for each friendship, the friendship value multiplied by the sum of the first k natural numbers, modulo MOD. This suggests that it's considering each friendship's value increasing by 1 each time it's chosen, but it doesn't account for the probability of selecting different pairs across excursions.

Let me think about this more carefully. The problem is about expected values, and the sum of friendship values over all excursions, considering that friendship values can increase over time based on how many times the friends have been chosen together.

First, I need to understand what the expected value of the sum of friendship values for all k excursions is.

Let's denote:

- Total possible pairs: Since there are n children, the total number of possible pairs is C(n, 2) = n*(n-1)/2.

- m pairs are friends, each with an initial friendship value f_i.

- For each excursion, a pair is chosen randomly and uniformly from all possible pairs.

- If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

- Friendship values of non-friend pairs are always 0 and never change.

We need to find the expected value of the sum of friendship values at the time each pair is chosen over all k excursions.

This sounds like a problem involving linearity of expectation, where we can calculate the expected contribution of each friend pair over all excursions and sum them up.

Let's consider one friend pair with initial friendship value f. We need to find the expected sum of its friendship value over all k excursions.

Let’s denote the friendship value of this pair at the time of the j-th excursion as f_j.

Initially, f_0 = f.

Each time this pair is chosen, its friendship value increases by 1 for all subsequent excursions.

So, if the pair is chosen t times across the k excursions, then the friendship value at the time of each choice would be f + number of times it has been chosen before that excursion.

This seems complicated. Maybe I should think in terms of indicators.

Let me define X_j as the friendship value of the pair at the time of the j-th excursion.

We need to compute E[sum_{j=1 to k} X_j].

Using linearity of expectation, this is sum_{j=1 to k} E[X_j].

Now, E[X_j] is the expected friendship value of the pair at the time of the j-th excursion.

To find E[X_j], we need to consider how many times the pair has been chosen in the previous excursions.

This seems tricky because the choices are independent, but the friendship value depends on how many times the pair has been chosen before.

Wait, the problem says that the teacher chooses pairs independently and randomly for each excursion. So, the choices are independent across excursions.

Given that, the friendship value at the time of the j-th excursion depends on whether the pair was chosen in any of the previous excursions.

But since the choices are independent, the probability that the pair was chosen in any previous excursion is the same for each excursion.

Wait, perhaps I should model this differently.

Let’s think about the probability that a particular friend pair is chosen in a given excursion. Since the teacher chooses randomly and uniformly among all possible pairs, the probability of choosing any specific pair is 2 / (n*(n-1)), because there are n*(n-1)/2 pairs, so the probability is 2 / (n*(n-1)).

Wait, more precisely, the total number of possible pairs is C(n, 2) = n*(n-1)/2, so the probability of choosing any specific pair in one excursion is 1 / C(n, 2) = 2 / (n*(n-1)).

But actually, no. The probability of choosing a specific pair is 1 / C(n, 2) = 2 / (n*(n-1)).

Wait, but C(n, 2) = n*(n-1)/2, so 1 / C(n, 2) = 2 / (n*(n-1)).

Wait, but that's correct.

Now, for a specific friend pair, the probability that it is chosen in any given excursion is p = 2 / (n*(n-1)).

Given that, over k independent excursions, the number of times this pair is chosen follows a binomial distribution with parameters k and p.

Now, the friendship value at the time of each excursion depends on how many times it has been chosen before that excursion.

Wait, perhaps I can think of it this way:

For the j-th excursion, the expected friendship value X_j is equal to the initial friendship value f plus the expected number of times the pair has been chosen in the previous excursions.

Wait, more formally:

Let S_j be the number of times the pair has been chosen in the first j-1 excursions.

Then, X_j = f + S_j.

Therefore, E[X_j] = f + E[S_j].

Now, S_j is the sum of j-1 independent Bernoulli trials, each with success probability p.

Therefore, E[S_j] = (j-1)*p.

Therefore, E[X_j] = f + (j-1)*p.

Therefore, the expected sum over all k excursions is sum_{j=1 to k} E[X_j] = sum_{j=1 to k} (f + (j-1)*p) = k*f + p * sum_{j=1 to k} (j-1) = k*f + p * (k*(k-1)/2).

So, the total expected sum is k*f + p*k*(k-1)/2.

Now, p = 2 / (n*(n-1)), so plugging in, we get:

Expected sum = k*f + (2 / (n*(n-1))) * k*(k-1)/2 = k*f + (k*(k-1)) / (n*(n-1)).

Wait, but this seems off because the friendship value should increase by 1 for each time the pair is chosen, not just linearly.

Wait, perhaps I made a mistake in modeling X_j.

Let me think differently.

Let me consider that each time the pair is chosen, its friendship value increases by 1 for all subsequent excursions.

So, if the pair is chosen in excursion t, then for all excursions j > t, the friendship value increases by 1.

Additionally, the friendship starts with an initial value f.

Wait, actually, the problem says: "if a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions".

So, the friendship value at the time of choice in excursion t is f plus the number of times the pair has been chosen before t.

Wait, more precisely, each time the pair is chosen, their friendship value increases by 1 for all subsequent choices.

So, if the pair is chosen in excursion t1, then for all excursions t > t1, the friendship value is increased by 1.

If it's chosen again in t2, then for all t > t2, it's increased by another 1, and so on.

Therefore, the friendship value at the time of choosing in excursion j is f plus the number of times the pair has been chosen before j.

So, X_j = f + S_{j-1}, where S_{j-1} is the number of times the pair has been chosen in the first j-1 excursions.

Therefore, E[X_j] = f + E[S_{j-1}].

Since each excursion is independent, S_{j-1} follows a binomial distribution with parameters j-1 and p, where p is the probability of choosing the pair in one excursion.

Therefore, E[S_{j-1}] = (j-1)*p.

Therefore, E[X_j] = f + (j-1)*p.

Therefore, the total expected sum is sum_{j=1 to k} E[X_j] = sum_{j=1 to k} (f + (j-1)*p) = k*f + p*sum_{j=1 to k} (j-1) = k*f + p*(k*(k-1)/2).

This is the same as what I got earlier.

Now, p = 1 / C(n,2) = 2 / (n*(n-1)).

Therefore, total expected sum = k*f + (2 / (n*(n-1))) * (k*(k-1)/2) = k*f + (k*(k-1)) / (n*(n-1)).

Wait, but this seems too simplistic. Let me check with the sample input.

Take the second sample input:

n=2, m=1, k=10

friendship: 1 2 1

According to the formula, total expected sum = 10*1 + (10*9)/(2*1) = 10 + 90/2 = 10 + 45 = 55, which matches the sample output.

Another sample input:

n=2, m=1, k=2

friendship: 2 1 1

Output: 777777784

Wait, according to my formula, total expected sum = 2*1 + (2*1)/2 = 2 + 1 = 3.

But the output is 777777784, which is 3 mod (10^9 + 7), since 3 * 1 = 3, and 1 is the inverse of 1, but perhaps I'm missing something.

Wait, in the third sample input:

n=3, m=1, k=2

friendship: 2 1 1

Output:777777784

According to my formula, total expected sum = 2*1 + (2*1)/(3*2) = 2 + 2/6 = 2 + 1/3 = 7/3.

Expressed as p/q with p and q coprime, it's 7/3, and p * q^{-1} mod (10^9 + 7) is 7 * 3^{-1} mod (10^9 + 7).

Since 3 * 333333336 = 1 mod (10^9 + 7), because 3 * 333333336 = 999999999 + 3 = 1000000002 ≡ 2 mod (10^9 + 7), wait, that's not right.

Wait, actually, 3 * 333333336 = 999999999 + 3 = 1000000002, which modulo (10^9 + 7) is 1000000002 - (10^9 + 7) = 1000000002 - 1000000007 = -5, which is not 1.

Wait, perhaps I need to compute the modular inverse correctly.

The modular inverse of 3 modulo (10^9 + 7) is 333333336, because 3 * 333333336 = 999999999 + 3 = 1000000002, and 1000000002 - 1000000007 = -5, but in modular arithmetic, negative numbers can be adjusted by adding the modulus.

So, -5 + 1000000007 = 1000000002, which is 1000000002 ≡ 2 mod (10^9 + 7), which is not 1. So, perhaps I miscalculated the inverse.

Wait, perhaps I need to use the formula for modular inverse.

The modular inverse of a modulo m is a^{m-2} if m is prime, using Fermat's Little Theorem.

Given that 10^9 + 7 is prime, the inverse of 3 is 3^{(10^9 + 7 - 2)} mod (10^9 + 7).

But that's computationally intensive. Instead, I can use the extended Euclidean algorithm.

But for simplicity, let's assume that the inverse of 3 modulo (10^9 + 7) is 333333336, and verify:

3 * 333333336 = 999999999 + 3 = 1000000002.

1000000002 - 1000000007 = -5.

-5 mod (10^9 + 7) is -5 + 1000000007 = 1000000002, which is not 1.

Wait, that can't be right. There must be a mistake here.

Wait, perhaps 3 * 333333336 = 999999999 + 3 = 1000000002, and 1000000002 - 1000000007 = -5, but in modular arithmetic, -5 mod (10^9 + 7) is indeed -5 + 1000000007 = 1000000002, which is not 1.

This suggests that 333333336 is not the correct inverse of 3 modulo (10^9 + 7).

Wait, perhaps I need to calculate it correctly.

The correct inverse of 3 modulo (10^9 + 7) is indeed 333333336, but apparently, my calculation is wrong.

Wait, perhaps I need to use the formula:

Since (10^9 + 7) is prime, 3^{(10^9 + 7 - 2)} mod (10^9 + 7) = 3^{(10^9 + 5)} mod (10^9 + 7).

This is computationally intensive, so I'll trust that 333333336 is the correct inverse.

Now, for the sample input:

n=2, m=1, k=2

friendship: 2 1 1

According to my formula, total expected sum = k*f + (k*(k-1))/(n*(n-1)) = 2*1 + (2*1)/(2*1) = 2 + 1 = 3

Then, p/q = 3/1, since it's already an integer.

So, p = 3, q = 1, and p * q^{-1} mod (10^9 + 7) = 3 * 1 = 3.

But the sample output is 777777784, which is different.

This suggests that my formula is incorrect.

Wait, perhaps I need to consider that there are multiple friend pairs, and their choices are dependent.

Wait, no, in this sample, there's only one friend pair.

So, according to my formula, it should be 3, but the sample output is 777777784, which is likely 7/3 modulo (10^9 + 7).

Wait, in the note, it says for the third test case, the final answer is 7/9 = 777,777,784 modulo (10^9 + 7).

Wait, but in this sample input, n=3, m=1, k=2, friendship:2 1 1, output:777,777,784.

Wait, perhaps I misread the sample input.

Wait, the third sample input is:

n=3, m=1, k=2

friendship:2 1 1

Output:777777784

According to my formula, total expected sum = k*f + (k*(k-1))/(n*(n-1)) = 2*1 + (2*1)/(3*2) = 2 + 1/3 = 7/3.

So, p/q = 7/3, and p * q^{-1} mod (10^9 + 7) = 7 * 3^{-1} mod (10^9 + 7).

If 3^{-1} is 333333336, then 7 * 333333336 = 2333333352.

But 2333333352 mod (10^9 + 7) is 2333333352 - 2*(10^9 + 7) = 2333333352 - 2000000014 = 333333338.

This is not matching the sample output of 777777784.

Wait, perhaps I'm miscalculating the inverse.

Let me calculate 3^{-1} modulo (10^9 + 7).

We need to find x such that 3x ≡ 1 mod (10^9 + 7).

So, 3x = 1 + m*(10^9 + 7), for some integer m.

Let's solve for x: x = (1 + m*(10^9 + 7)) / 3.

We need x to be an integer, so 1 + m*(10^9 + 7) must be divisible by 3.

10^9 + 7 = 1000000007.

1000000007 divided by 3 is 333333335.666..., so not divisible by 3.

Wait, 1000000007 mod 3:

1+0+0+0+0+0+0+0+0+7 = 8, 8 mod 3 = 2.

So, 1000000007 ≡ 2 mod 3.

So, m*(10^9 + 7) ≡ 2m mod 3.

So, 1 + 2m ≡ 0 mod 3 ⇒ 2m ≡ -1 mod 3 ⇒ 2m ≡ 2 mod 3 ⇒ m ≡ 1 mod 3.

So, m = 1, then x = (1 + 1*(10^9 + 7)) / 3 = (1 + 1000000007) / 3 = 1000000008 / 3 = 333333336.

So, 3^{-1} ≡ 333333336 mod (10^9 + 7).

Now, 7 * 333333336 = 2333333352.

2333333352 mod (10^9 + 7) = 2333333352 - 2*(10^9 + 7) = 2333333352 - 2000000014 = 333333338.

But the sample output is 777777784, which doesn't match.

Wait, perhaps I'm missing something.

Wait, perhaps the expected sum is different.

Let me consider the process step by step.

In the third sample input:

n=3, m=1, k=2

friendship:2 1 1

So, there are 3 children, one friend pair (2,1) with f=1.

Total possible pairs: C(3,2)=3.

So, probability of choosing the friend pair in any excursion is p=1/3.

Now, for k=2 excursions.

Let's enumerate all possible scenarios:

1. Choose the friend pair in both excursions.

Probability: (1/3)*(1/3) = 1/9.

Friendship values:

- Excursion 1: f = 1 (initial)

- Excursion 2: f + 1 = 2 (since they were chosen in excursion 1)

Total sum: 1 + 2 = 3.

2. Choose the friend pair in the first excursion, and a non-friend pair in the second.

Probability: (1/3)*(2/3) = 2/9.

Friendship values:

- Excursion 1: f = 1

- Excursion 2: f + 1 = 2 (since they were chosen in excursion 1)

Total sum: 1 + 2 = 3.

3. Choose a non-friend pair in the first excursion, and the friend pair in the second.

Probability: (2/3)*(1/3) = 2/9.

Friendship values:

- Excursion 1: f = 1 (since not chosen, no increase)

- Excursion 2: f + 0 = 1

Total sum: 1 + 1 = 2.

4. Choose non-friend pairs in both excursions.

Probability: (2/3)*(2/3) = 4/9.

Friendship values:

- Excursion 1: f = 1

- Excursion 2: f = 1

Total sum: 1 + 1 = 2.

Now, expected sum:

(1/9)*3 + (2/9)*3 + (2/9)*2 + (4/9)*2 = (3/9) + (6/9) + (4/9) + (8/9) = (3 + 6 + 4 + 8)/9 = 21/9 = 7/3.

So, the expected sum is 7/3, which matches my earlier calculation.

Now, 7/3 modulo (10^9 + 7) is 7 * 3^{-1} mod (10^9 + 7).

As calculated earlier, 3^{-1} ≡ 333333336 mod (10^9 + 7).

Therefore, 7 * 333333336 = 2333333352 mod (10^9 + 7).

2333333352 - 2*(10^9 + 7) = 2333333352 - 2000000014 = 333333338.

But the sample output is 777777784, which doesn't match my calculation.

Wait, perhaps I'm miscalculating the modular inverse.

Let me check 3 * 333333336 = 999999999 + 3 = 1000000002.

1000000002 mod (10^9 + 7) = 1000000002 - 1000000007 = -5.

But -5 mod (10^9 + 7) is -5 + 1000000007 = 1000000002, which is not 1.

Wait