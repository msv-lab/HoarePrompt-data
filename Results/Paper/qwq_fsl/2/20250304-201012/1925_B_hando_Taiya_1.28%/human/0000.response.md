Alright, I have this task to verify the correctness of a given Python program based on its problem description. I need to determine whether the program meets the requirements as specified, and if it does for every potential case, then it's correct; otherwise, it's incorrect. I have to print "True" if it's correct and "False" if it's not, and follow a specific format.

First, I need to understand the problem description thoroughly. Let's read it again:

"Jay managed to create a problem of difficulty x and decided to make it the second problem for Codeforces Round #921. But Yash fears that this problem will make the contest highly unbalanced, and the coordinator will reject it. So, he decided to break it up into a problemset of n sub-problems such that the difficulties of all the sub-problems are a positive integer and their sum is equal to x.

The coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all sub-problems in the problemset.

Find the maximum balance that Yash can achieve if he chooses the difficulties of the sub-problems optimally.

Input:

The first line of input contains a single integer t (1 ≤ t ≤ 10^3) denoting the number of test cases.

Each test case contains a single line of input containing two integers x (1 ≤ x ≤ 10^8) and n (1 ≤ n ≤ x).

Output:

For each test case, print a single line containing a single integer denoting the maximum balance that Yash can achieve.

Example:

Input:

3

10 3

5 5

420 69

Output:

2

1

6

Note:

For the first test case, one possible way is to break up the problem of difficulty 10 into a problemset having three problems of difficulties 4, 2, and 4 respectively, giving a balance equal to 2.

For the second test case, there is only one way to break up the problem of difficulty 5 into a problemset of 5 problems with each problem having a difficulty 1, giving a balance equal to 1."

So, the task is to divide a problem of difficulty x into n sub-problems, each with a positive integer difficulty, such that their sum is x, and to maximize the GCD of these difficulties.

I need to verify if the provided program achieves this correctly for all possible cases within the given constraints.

Let's look at the provided program:

```

from math import *

tc = int(input())

for _ in range(tc):

func_1()

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

elif n <= i:

ans = max(ans, x // i)

print(ans)

```

First, I need to understand what this code is doing.

It seems to be iterating through possible divisors of x and trying to find the maximum divisor that satisfies some conditions related to n.

Let me try to understand the logic.

The function `func_1` is called for each test case. It reads x and n, then initializes `ans` to 0.

It then loops from 1 to the square root of x (inclusive), checking if i is a divisor of x.

If i is a divisor, it checks two conditions:

1. If n <= x // i, then it sets ans to the maximum of ans and i.

2. Else if n <= i, it sets ans to the maximum of ans and x // i.

Finally, it prints ans.

I need to verify if this correctly computes the maximum possible GCD for any division of x into n positive integers summing to x.

Let me think about the problem differently to see if this approach is correct.

Given x and n, we need to divide x into n parts, each part being a positive integer, such that the sum is x, and the GCD of these parts is maximized.

Let’s recall that the GCD of a set of numbers is the largest number that divides all of them without leaving a remainder.

To maximize the GCD, we need to find the largest possible d such that x can be expressed as the sum of n integers, each being a multiple of d.

In other words, if d is the GCD, then each part can be written as d * k, where k is a positive integer.

So, x = d * (k1 + k2 + ... + kn), where GCD(k1, k2, ..., kn) = 1.

But actually, since d is the GCD, the sum x must be divisible by d, and the sum of the coefficients ki must be such that their GCD is 1.

Wait, maybe I need to think in terms of d being a divisor of x, and then checking if x/d can be expressed as the sum of n integers, each being at least 1.

Wait, perhaps it's better to think that if d is the GCD, then x must be divisible by d, and the sum x = d * (a1 + a2 + ... + an), where ai are positive integers with GCD(ai) = 1.

Therefore, x must be divisible by d, and (x/d) must be at least n, since each ai is at least 1.

Wait, yes, because a1 + a2 + ... + an >= n*1 = n.

So, x/d >= n.

Therefore, d <= x/n.

So, the maximum possible d is the largest divisor of x that is less than or equal to x/n.

Wait, is that correct?

Let me see.

If d is a divisor of x and d <= x/n, then x/d >= n, which satisfies the condition that the sum of n parts, each being at least d, is at least n*d = n*(x/n) = x.

But we need the sum to be exactly x.

Wait, perhaps I need to think differently.

Let’s consider that if d is the GCD, then x must be divisible by d, and the sum of n parts, each being a multiple of d, must equal x.

So, x = d * (a1 + a2 + ... + an), where ai are positive integers with GCD(ai) = 1.

Therefore, (a1 + a2 + ... + an) = x/d.

We need to have n positive integers summing up to x/d, with GCD 1.

The minimal sum for n positive integers with GCD 1 is n, achieved when all ai=1.

But in that case, x/d = n, so d = x/n.

But d must be an integer divisor of x.

Therefore, the maximum possible d is the largest divisor of x that is less than or equal to x/n.

Wait, but x/n may not be an integer.

So, actually, d must be less than or equal to floor(x/n).

Wait, floor(x/n) is the largest integer d such that d <= x/n.

But d must also be a divisor of x.

Therefore, the maximum d is the largest divisor of x that is less than or equal to floor(x/n).

Is that correct?

Let me check with the examples.

First example: x=10, n=3.

floor(10/3)=3.

Divisors of 10 are 1,2,5,10.

The largest divisor <=3 is 2.

And indeed, in the note, they have difficulties 4,2,4, which are all multiples of 2, and sum to 10.

GCD is 2.

So, it matches.

Second example: x=5, n=5.

floor(5/5)=1.

Divisors of 5 are 1,5.

The largest divisor <=1 is 1.

And indeed, all sub-problems have difficulty 1, GCD is 1.

Third example: x=420, n=69.

floor(420/69)= floor(420/69)= floor(6.087)=6.

Divisors of 420 are 1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420.

The largest divisor <=6 is 6.

So, ans=6.

Seems correct.

So, the logic seems to be finding the largest divisor of x that is <= floor(x/n).

Now, looking back at the code:

It loops from i=1 to sqrt(x), checks if i is a divisor of x.

If yes, it checks:

- if n <= x // i, then ans = max(ans, i)

- elif n <= i, then ans = max(ans, x // i)

Wait, this seems a bit confusing.

Let me see.

In the first condition, if n <= x // i, it takes i.

In the second condition, if n <= i, it takes x // i.

Wait, in the first example, x=10, n=3.

sqrt(10)=3.16, so i from 1 to 4.

i=1:

1 is divisor of 10.

x // i = 10.

n=3 <=10, so ans=max(0,1)=1.

i=2:

2 is divisor of 10.

x // 2 =5.

n=3 <=5, so ans=max(1,2)=2.

i=3:

3 is not divisor of 10.

i=4:

4 is not divisor of 10.

So, ans=2, which matches.

Second example: x=5, n=5.

i from 1 to 3.

i=1:

1 is divisor of 5.

5//1=5.

n=5 <=5, so ans=max(0,1)=1.

i=2:

2 is not divisor of 5.

i=3:

3 is not divisor of 5.

So, ans=1, matches.

Third example: x=420, n=69.

i from 1 to 21 (since sqrt(420)=20.49, so i up to 21.

i=1:

1 is divisor, 420//1=420.

n=69<=420, ans=max(0,1)=1.

i=2:

2 is divisor, 420//2=210.

n=69<=210, ans=max(1,2)=2.

...

Continuing up to i=20.

i=6:

6 is divisor, 420//6=70.

n=69<=70, ans=max(6, previous ans).

Wait, previous ans is likely higher by then.

i=7:

7 is divisor, 420//7=60.

n=69>60, so skip.

i=10:

10 is divisor, 420//10=42.

n=69>42, skip.

i=14:

14 is divisor, 420//14=30.

n=69>30, skip.

i=15:

15 is divisor, 420//15=28.

n=69>28, skip.

i=20:

20 is divisor, 420//20=21.

n=69>21, skip.

i=21:

21 is divisor, 420//21=20.

n=69>20, skip.

So, the maximum ans would be from i=6, which is 6, matches the example.

Seems correct.

But is this logic general?

Let me think about another case.

Suppose x=8, n=2.

floor(8/2)=4.

Divisors of 8:1,2,4,8.

Largest divisor <=4 is 4.

So, ans=4.

Possible division:4 and 4, GCD=4.

Another division:2 and 6, GCD=2.

Another:1 and7, GCD=1.

So, maximum GCD is 4.

Code:

i from1 to sqrt(8)=2.8, so i=1,2,3.

i=1:

1 is divisor, 8//1=8.

n=2<=8, ans=max(0,1)=1.

i=2:

2 is divisor, 8//2=4.

n=2<=4, ans=max(1,2)=2.

i=3:

3 is not divisor.

So, ans=2, but should be4.

Wait, seems incorrect.

Wait, but in the code, it goes up to i=isqrt(x)+1, which is 3.

i=4 is not checked.

Wait, but in this case, x=8, n=2.

The code would return 2, but the correct answer should be4.

So, this seems like a mistake.

Wait, but in the earlier examples, it worked.

Wait, perhaps I need to adjust the logic.

Wait, in x=8, n=2.

The code checks i=1,2,3.

i=1: n=2<=8, ans=1.

i=2: n=2<=4, ans=2.

i=3: not divisor.

So, ans=2.

But the optimal GCD is4, as shown by division 4 and4.

So, the code is incorrect in this case.

Wait, but according to the problem statement, if there is at least one input where the program doesn't work, then it's incorrect.

So, in this case, for x=8, n=2, the program outputs2, but the correct answer is4.

Hence, the program is incorrect.

So, Correctness: **False**.

But let's see if there is a way to fix it.

Perhaps the logic is incomplete.

Let me think about the correct approach.

We need to find the largest d that divides x and d <= floor(x/n).

So, to find the largest d, we can iterate through all divisors of x and pick the largest one that is <= floor(x/n).

In the x=8, n=2 case, divisors of8 are1,2,4,8.

floor(8/2)=4.

So, largest d <=4 is4.

Hence, ans=4.

But in the code, it seems to miss this.

Wait, perhaps the code is not checking all possible divisors.

In the code, for x=8, it checks i=1,2,3.

i=1: d=1.

i=2: d=2.

i=3: not divisor.

So, it misses d=4, which is x//i where i=2.

Wait, x//2=4.

But in the code, it only considers i up to isqrt(x)+1=3.

So, i=2 gives d=2, and i=4 is not checked because i goes up to 3.

Hence, it misses d=4.

So, the code is incomplete because it doesn't check all possible divisors.

To fix this, we need to ensure that for each i that is a divisor, we also consider x//i.

So, in the loop, for each i from1 to sqrt(x), if i is a divisor, then both i and x//i are divisors.

We need to check both.

So, in the code, it only checks i up to sqrt(x), and considers i and x//i.

But in the logic, it seems to only update ans based on certain conditions.

Let me see.

In the code:

for i in range(1, isqrt(x) +1):

if x % i ==0:

if n <= x // i:

ans = max(ans, i)

elif n <= i:

ans = max(ans, x // i)

In the x=8, n=2 case:

i=1:

x%1==0.

n=2 <= x//1=8, so ans=max(0,1)=1.

i=2:

x%2==0.

n=2 <= x//2=4, so ans=max(1,2)=2.

i=3:

not divisor.

So, ans=2.

But, x//2=4 is also a divisor, which is d=4.

But the code doesn't check if n <= d.

Wait, perhaps we need to check both i and x//i.

So, perhaps the correct logic is:

for i in range(1, isqrt(x)+1):

if x % i ==0:

d1 = i

d2 = x // i

if d1 <= floor(x/n):

ans = max(ans, d1)

if d2 <= floor(x/n):

ans = max(ans, d2)

But in the code, it's conditional based on n.

Wait, perhaps the condition is incorrect.

Let me think differently.

Let me define floor(x/n)=k.

Then, d <=k.

So, we need to find the largest d that divides x and d <=k.

So, in the code, it should iterate through all divisors of x and take the largest one that is <=k.

But the code only iterates i up to sqrt(x), and for each i that divides x, it considers i and x//i, but updates ans based on conditions involving n.

Perhaps a better way is to collect all divisors of x, then filter those <= floor(x/n), and take the maximum.

Let me see.

In the x=8, n=2 case:

divisors:1,2,4,8.

floor(8/2)=4.

So, divisors <=4:1,2,4.

Hence, ans=4.

In the code, it only gets up to2 because i=2 gives d=2, and i=4 is not checked.

Hence, the code is incorrect.

So, Correctness: **False**.

I have found a case where the program does not work as expected.

## Final Solution
To solve this problem, we need to maximize the GCD (Balance) of a set of sub-problems derived from a given problem of difficulty `x`, divided into `n` sub-problems.

### Approach

1. **Understanding the Problem**:
   - We need to split `x` into `n` positive integers whose sum is `x`.
   - The GCD of these integers should be maximized.

2. **Key Insight**:
   - If the GCD of the sub-problems is `d`, then `d` must be a divisor of `x`.
   - The sum of the sub-problems `n` must be such that `x >= n * d`.

3. **Optimal Strategy**:
   - Find all divisors of `x`.
   - Select the largest divisor `d` such that `d <= floor(x / n)`.

4. **Implementation**:
   - Iterate through all possible divisors up to the square root of `x`.
   - For each divisor `i`, consider both `i` and `x // i`.
   - Track the maximum divisor that is less than or equal to `floor(x / n)`.

### Solution Code

```python
import math

def max_balance(x, n):
    k = x // n
    ans = 0
    for i in range(1, int(math.isqrt(x)) + 1):
        if x % i == 0:
            if i <= k:
                ans = max(ans, i)
            d2 = x // i
            if d2 <= k:
                ans = max(ans, d2)
    return ans

tc = int(input())
for _ in range(tc):
    x, n = map(int, input().split())
    print(max_balance(x, n))
```

### Explanation

1. **Function Definition**:
   - `max_balance(x, n)`: Computes the maximum GCD (`d`) for given `x` and `n`.
   
2. **Divisor Calculation**:
   - We iterate from `1` to the square root of `x` to find all divisors.
   - For each divisor `i`, we also consider `x // i`.

3. **Condition Check**:
   - We maintain a variable `k` which is `floor(x / n)`.
   - We track the maximum divisor that is less than or equal to `k`.

4. **Input Handling**:
   - Read the number of test cases `tc`.
   - For each test case, read `x` and `n`, then compute and print the maximum balance.

This approach ensures that we efficiently find the optimal GCD by considering all possible divisors and selecting the largest one that meets the criteria.