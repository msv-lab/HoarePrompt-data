DEBUG - Start Task 0119
DEBUG - Dataset: apps
DEBUG - model_created: llama3-70b-8192
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: You are given a sequence a_1, a_2, ..., a_{n} of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment a_{i} lies within segment a_{j}.

Segment [l_1, r_1] lies within segment [l_2, r_2] iff l_1 ≥ l_2 and r_1 ≤ r_2.

Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 3·10^5) — the number of segments.

Each of the next n lines contains two integers l_{i} and r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ 10^9) — the i-th segment.


-----Output-----

Print two distinct indices i and j such that segment a_{i} lies within segment a_{j}. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Examples-----
Input
5
1 10
2 9
3 9
2 3
2 9

Output
2 1

Input
3
1 5
2 6
6 20

Output
-1 -1



-----Note-----

In the first example the following pairs are considered correct:  (2, 1), (3, 1), (4, 1), (5, 1) — not even touching borders;  (3, 2), (4, 2), (3, 5), (4, 5) — touch one border;  (5, 2), (2, 5) — match exactly.
DEBUG - Postcondition: `n` remains the same positive integer (1 ≤ `n` ≤ 3·10^5); `segments` remains an empty list; `_` remains the same value as `n`; `i` remains the same value as `n`; `j` is not initialized since the loops do not execute. The loops do not execute because the condition `i < 0` is never satisfied. print(-1, -1) outputs -1 -1
DEBUG - Correctness: False
DEBUG - Start Task 0119
DEBUG - Dataset: apps
DEBUG - model_created: gpt-4o-2024-05-13
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: You are given a sequence a_1, a_2, ..., a_{n} of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment a_{i} lies within segment a_{j}.

Segment [l_1, r_1] lies within segment [l_2, r_2] iff l_1 ≥ l_2 and r_1 ≤ r_2.

Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 3·10^5) — the number of segments.

Each of the next n lines contains two integers l_{i} and r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ 10^9) — the i-th segment.


-----Output-----

Print two distinct indices i and j such that segment a_{i} lies within segment a_{j}. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Examples-----
Input
5
1 10
2 9
3 9
2 3
2 9

Output
2 1

Input
3
1 5
2 6
6 20

Output
-1 -1



-----Note-----

In the first example the following pairs are considered correct:  (2, 1), (3, 1), (4, 1), (5, 1) — not even touching borders;  (3, 2), (4, 2), (3, 5), (4, 5) — touch one border;  (5, 2), (2, 5) — match exactly.
DEBUG - Postcondition: Output State:
DEBUG - Correctness: True
DEBUG - Start Task 0006
DEBUG - Dataset: apps
DEBUG - model_created: llama3-70b-8192
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: You are fighting with Zmei Gorynich — a ferocious monster from Slavic myths, a huge dragon-like reptile with multiple heads! 

 $m$ 

Initially Zmei Gorynich has $x$ heads. You can deal $n$ types of blows. If you deal a blow of the $i$-th type, you decrease the number of Gorynich's heads by $min(d_i, curX)$, there $curX$ is the current number of heads. But if after this blow Zmei Gorynich has at least one head, he grows $h_i$ new heads. If $curX = 0$ then Gorynich is defeated. 

You can deal each blow any number of times, in any order.

For example, if $curX = 10$, $d = 7$, $h = 10$ then the number of heads changes to $13$ (you cut $7$ heads off, but then Zmei grows $10$ new ones), but if $curX = 10$, $d = 11$, $h = 100$ then number of heads changes to $0$ and Zmei Gorynich is considered defeated.

Calculate the minimum number of blows to defeat Zmei Gorynich!

You have to answer $t$ independent queries.


-----Input-----

The first line contains one integer $t$ ($1 \le t \le 100$) – the number of queries.

The first line of each query contains two integers $n$ and $x$ ($1 \le n \le 100$, $1 \le x \le 10^9$) — the number of possible types of blows and the number of heads Zmei initially has, respectively.

The following $n$ lines of each query contain the descriptions of types of blows you can deal. The $i$-th line contains two integers $d_i$ and $h_i$ ($1 \le d_i, h_i \le 10^9$) — the description of the $i$-th blow.


-----Output-----

For each query print the minimum number of blows you have to deal to defeat Zmei Gorynich. 

If Zmei Gorynuch cannot be defeated print $-1$.


-----Example-----
Input
3
3 10
6 3
8 2
1 4
4 10
4 1
3 2
2 6
1 100
2 15
10 11
14 100

Output
2
3
-1



-----Note-----

In the first query you can deal the first blow (after that the number of heads changes to $10 - 6 + 3 = 7$), and then deal the second blow.

In the second query you just deal the first blow three times, and Zmei is defeated. 

In third query you can not defeat Zmei Gorynich. Maybe it's better to convince it to stop fighting?
DEBUG - Postcondition: `_` is assigned the value of `t`, where `t` is an input integer such that 1 <= t <= 100. No changes occur to any other variables as the loop does not execute.
DEBUG - Correctness: False
DEBUG - Start Task 0006
DEBUG - Dataset: apps
DEBUG - model_created: gpt-4o-2024-05-13
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: You are fighting with Zmei Gorynich — a ferocious monster from Slavic myths, a huge dragon-like reptile with multiple heads! 

 $m$ 

Initially Zmei Gorynich has $x$ heads. You can deal $n$ types of blows. If you deal a blow of the $i$-th type, you decrease the number of Gorynich's heads by $min(d_i, curX)$, there $curX$ is the current number of heads. But if after this blow Zmei Gorynich has at least one head, he grows $h_i$ new heads. If $curX = 0$ then Gorynich is defeated. 

You can deal each blow any number of times, in any order.

For example, if $curX = 10$, $d = 7$, $h = 10$ then the number of heads changes to $13$ (you cut $7$ heads off, but then Zmei grows $10$ new ones), but if $curX = 10$, $d = 11$, $h = 100$ then number of heads changes to $0$ and Zmei Gorynich is considered defeated.

Calculate the minimum number of blows to defeat Zmei Gorynich!

You have to answer $t$ independent queries.


-----Input-----

The first line contains one integer $t$ ($1 \le t \le 100$) – the number of queries.

The first line of each query contains two integers $n$ and $x$ ($1 \le n \le 100$, $1 \le x \le 10^9$) — the number of possible types of blows and the number of heads Zmei initially has, respectively.

The following $n$ lines of each query contain the descriptions of types of blows you can deal. The $i$-th line contains two integers $d_i$ and $h_i$ ($1 \le d_i, h_i \le 10^9$) — the description of the $i$-th blow.


-----Output-----

For each query print the minimum number of blows you have to deal to defeat Zmei Gorynich. 

If Zmei Gorynuch cannot be defeated print $-1$.


-----Example-----
Input
3
3 10
6 3
8 2
1 4
4 10
4 1
3 2
2 6
1 100
2 15
10 11
14 100

Output
2
3
-1



-----Note-----

In the first query you can deal the first blow (after that the number of heads changes to $10 - 6 + 3 = 7$), and then deal the second blow.

In the second query you just deal the first blow three times, and Zmei is defeated. 

In third query you can not defeat Zmei Gorynich. Maybe it's better to convince it to stop fighting?
DEBUG - Postcondition: `t` is an integer converted from `data[0]`, `queries` is a list of tuples containing `(n, x)` and the list of `blows`, `results` is assigned the return value of `func(t, queries)`, `index` is incremented appropriately based on the loop, `_` is either 0 or greater, or incremented to 0 based on the initial state, `iterator` is an iterator over `results`. If the iterator has more items, `result` is the next value from `iterator`, and `result` is printed. If the iterator is exhausted, a `StopIteration` exception is raised, causing the loop to break, and no further results are printed. If `results` is empty from the start, the loop will not print anything and will break immediately.
DEBUG - Correctness: False
DEBUG - Start Task 0088
DEBUG - Task 0088 skip due to mult functions.



DEBUG - Start Task 0088
DEBUG - Task 0088 skip due to mult functions.



DEBUG - Start Task 0265
DEBUG - Dataset: apps
DEBUG - model_created: llama3-70b-8192
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: A company of $n$ friends wants to order exactly two pizzas. It is known that in total there are $9$ pizza ingredients in nature, which are denoted by integers from $1$ to $9$.

Each of the $n$ friends has one or more favorite ingredients: the $i$-th of friends has the number of favorite ingredients equal to $f_i$ ($1 \le f_i \le 9$) and your favorite ingredients form the sequence $b_{i1}, b_{i2}, \dots, b_{if_i}$ ($1 \le b_{it} \le 9$).

The website of CodePizza restaurant has exactly $m$ ($m \ge 2$) pizzas. Each pizza is characterized by a set of $r_j$ ingredients $a_{j1}, a_{j2}, \dots, a_{jr_j}$ ($1 \le r_j \le 9$, $1 \le a_{jt} \le 9$) , which are included in it, and its price is $c_j$.

Help your friends choose exactly two pizzas in such a way as to please the maximum number of people in the company. It is known that a person is pleased with the choice if each of his/her favorite ingredients is in at least one ordered pizza. If there are several ways to choose two pizzas so as to please the maximum number of friends, then choose the one that minimizes the total price of two pizzas.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n \le 10^5, 2 \le m \le 10^5$) — the number of friends in the company and the number of pizzas, respectively.

Next, the $n$ lines contain descriptions of favorite ingredients of the friends: the $i$-th of them contains the number of favorite ingredients $f_i$ ($1 \le f_i \le 9$) and a sequence of distinct integers $b_{i1}, b_{i2}, \dots, b_{if_i}$ ($1 \le b_{it} \le 9$).

Next, the $m$ lines contain pizza descriptions: the $j$-th of them contains the integer price of the pizza $c_j$ ($1 \le c_j \le 10^9$), the number of ingredients $r_j$ ($1 \le r_j \le 9$) and the ingredients themselves as a sequence of distinct integers $a_{j1}, a_{j2}, \dots, a_{jr_j}$ ($1 \le a_{jt} \le 9$).


-----Output-----

Output two integers $j_1$ and $j_2$ ($1 \le j_1,j_2 \le m$, $j_1 \ne j_2$) denoting the indices of two pizzas in the required set. If there are several solutions, output any of them. Pizza indices can be printed in any order.


-----Examples-----
Input
3 4
2 6 7
4 2 3 9 5
3 2 3 9
100 1 7
400 3 3 2 5
100 2 9 2
500 3 2 9 5

Output
2 3

Input
4 3
1 1
1 2
1 3
1 4
10 4 1 2 3 4
20 4 1 2 3 4
30 4 1 2 3 4

Output
1 2

Input
1 5
9 9 8 7 6 5 4 3 2 1
3 4 1 2 3 4
1 4 5 6 7 8
4 4 1 3 5 7
1 4 2 4 6 8
5 4 1 9 2 8

Output
2 4
DEBUG - Postcondition: If `_` is initially less than 0, `n` is an input integer where 1 ≤ `n` ≤ 10^5, `m` is an input integer where 2 ≤ `m` ≤ 10^5, `friends` contains sets created from the slices `f_i[1:]` of the input lines, `f_i` is a list of integers obtained from the final input, `pizzas` contains tuples `(c_j, a_jt)` for each iteration of the loop, and `_` is incremented to 0. If `_` is initially 0 or greater, the initial state remains unchanged, `ans` is (-1, -1), `max_pleased` is 0, `min_price` is `float('inf')`, `i` is equal to `m`. After the loop finishes, `print(*ans)` outputs the values of `ans`.
DEBUG - Correctness: False
DEBUG - Start Task 0265
DEBUG - Task 0265 skip due to mult functions.



DEBUG - Start Task 0293
DEBUG - Dataset: apps
DEBUG - model_created: llama3-70b-8192
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: Spongebob is already tired trying to reason his weird actions and calculations, so he simply asked you to find all pairs of n and m, such that there are exactly x distinct squares in the table consisting of n rows and m columns. For example, in a 3 × 5 table there are 15 squares with side one, 8 squares with side two and 3 squares with side three. The total number of distinct squares in a 3 × 5 table is 15 + 8 + 3 = 26.


-----Input-----

The first line of the input contains a single integer x (1 ≤ x ≤ 10^18) — the number of squares inside the tables Spongebob is interested in.


-----Output-----

First print a single integer k — the number of tables with exactly x distinct squares inside.

Then print k pairs of integers describing the tables. Print the pairs in the order of increasing n, and in case of equality — in the order of increasing m.


-----Examples-----
Input
26

Output
6
1 26
2 9
3 5
5 3
9 2
26 1

Input
2

Output
2
1 2
2 1

Input
8

Output
4
1 8
2 3
3 2
8 1



-----Note-----

In a 1 × 2 table there are 2 1 × 1 squares. So, 2 distinct squares in total. [Image] 

In a 2 × 3 table there are 6 1 × 1 squares and 2 2 × 2 squares. That is equal to 8 squares in total. [Image]
DEBUG - Postcondition: If `x` is positive, after the loop execution, `n` will be equal to `int(x)`; `tables` is sorted, and the length of `tables` is printed; `iterator` has reached the end of `tables` and raised a `StopIteration` exception, which breaks the loop. If `tables` is empty or contains only one element, the loop will either not start or will execute only once, respectively. The final state will have `iterator` exhausted, and no further elements will be printed.
DEBUG - Correctness: False
DEBUG - Start Task 0293
DEBUG - Dataset: apps
DEBUG - model_created: gpt-4o-2024-05-13
DEBUG - model_run: gpt-4o-2024-05-13
DEBUG - description: Spongebob is already tired trying to reason his weird actions and calculations, so he simply asked you to find all pairs of n and m, such that there are exactly x distinct squares in the table consisting of n rows and m columns. For example, in a 3 × 5 table there are 15 squares with side one, 8 squares with side two and 3 squares with side three. The total number of distinct squares in a 3 × 5 table is 15 + 8 + 3 = 26.


-----Input-----

The first line of the input contains a single integer x (1 ≤ x ≤ 10^18) — the number of squares inside the tables Spongebob is interested in.


-----Output-----

First print a single integer k — the number of tables with exactly x distinct squares inside.

Then print k pairs of integers describing the tables. Print the pairs in the order of increasing n, and in case of equality — in the order of increasing m.


-----Examples-----
Input
26

Output
6
1 26
2 9
3 5
5 3
9 2
26 1

Input
2

Output
2
1 2
2 1

Input
8

Output
4
1 8
2 3
3 2
8 1



-----Note-----

In a 1 × 2 table there are 2 1 × 1 squares. So, 2 distinct squares in total. [Image] 

In a 2 × 3 table there are 6 1 × 1 squares and 2 2 × 2 squares. That is equal to 8 squares in total. [Image]
DEBUG - Postcondition: `x` is an input integer between 1 and \(10^{18}\)
DEBUG - Correctness: False
