### Reasoning:

1. **Input Parsing and Data Structure Initialization:**
   - The program correctly reads the number of test cases and the details of each test case.
   - It initializes the adjacency list `g` for the graph, which is used to represent the tree structure.

2. **Binary Search for Maximum Component Size:**
   - The program uses binary search to find the maximum value `x` such that the tree can be split into components of size at least `x` after removing `k` edges.
   - The binary search range is set from `1` to `n // k + 1`, which is a reasonable upper bound for the component size.

3. **Depth-First Search (DFS) for Component Size Calculation:**
   - The `dfs` function is used to explore the tree and calculate the size of connected components.
   - It correctly updates the `visited` set to avoid revisiting nodes and calculates the size of the current component (`c`) and the number of components that meet the size threshold (`r`).

4. **Check Function for Validity:**
   - The `check` function uses the `dfs` function to verify if it is possible to split the tree into components of size at least `x` after removing `k` edges.
   - It clears the `visited` set before each call to `dfs` to ensure a fresh traversal.
   - It returns `True` if the conditions are met (i.e., the component size is at least `x` and the number of components is at least `k`), otherwise it returns `False`.

5. **Output:**
   - The program prints the result of the binary search, which is the maximum value `x` that satisfies the conditions.

### Conclusion:
The program appears to correctly implement the logic required to solve the problem. It uses binary search to efficiently find the maximum component size and DFS to validate the conditions. The input parsing, data structures, and algorithmic steps are all consistent with the problem requirements.

Correctness: **True**