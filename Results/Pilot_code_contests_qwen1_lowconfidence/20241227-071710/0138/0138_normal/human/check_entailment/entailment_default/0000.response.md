Correctness: **False**

Explanation: The provided code does not fully implement the logic required to find a lexicographically strictly larger and minimum permutation of string `s` that satisfies the given conditions. Here are the issues:

1. **Initial Check**: The code initially checks if every character in `s` appears at least as many times as in `t`. If this condition is met and `s` and `t` have the same length, it returns `-1`. This part is correct in terms of the problem statement, but it does not ensure that the resulting string is the lexicographically minimum one that is strictly greater than `t`.

2. **Character Frequency Adjustment**: After the initial check, the code attempts to construct a new string by adjusting character frequencies. However, it does not guarantee that the resulting string is the lexicographically minimum one that is strictly greater than `t`.

3. **Character Selection Logic**: The logic for selecting characters to form the resulting string is flawed. For example, it attempts to find a character in the range `(ord(t[i]) - ord('a') + 1, 26)` and append it to the result, but it does not ensure that the resulting string is the lexicographically minimum one.

To illustrate, consider the following example:

- Input:
  ```
  s = "abc"
  t = "abc"
  ```

  The code would return `-1` because every character in `s` appears at least as many times as in `t`, and `s` and `t` have the same length. However, the correct output should be `"abca"` or any other permutation that is lexicographically strictly greater than `t` and lexicographically minimum.

- Another example:
  ```
  s = "aad"
  t = "aac"
  ```

  The code correctly returns `"aad"`, but it fails in more complex cases where a lexicographically minimum string that is strictly greater than `t` needs to be constructed.

Given these issues, the code does not meet the requirements of the problem description for every potential case, hence the correctness is **False**.