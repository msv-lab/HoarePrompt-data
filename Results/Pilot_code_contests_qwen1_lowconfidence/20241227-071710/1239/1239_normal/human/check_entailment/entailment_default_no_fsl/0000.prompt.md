
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: In order to celebrate Twice's 5th anniversary, Tzuyu and Sana decided to play a game.

Tzuyu gave Sana two integers a and b and a really important quest.

In order to complete the quest, Sana has to output the smallest possible value of (a ⊕ x) + (b ⊕ x) for any given x, where ⊕ denotes the [bitwise XOR operation](http://en.wikipedia.org/wiki/Bitwise_operation#XOR). 

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^{4}). Description of the test cases follows.

The only line of each test case contains two integers a and b (1 ≤ a, b ≤ 10^{9}).

Output

For each testcase, output the smallest possible value of the given expression.

Example

Input


6
6 12
4 9
59 832
28 14
4925 2912
1 1


Output


10
13
891
18
6237
0

Note

For the first test case Sana can choose x=4 and the value will be (6 ⊕ 4) + (12 ⊕ 4) = 2 + 8 = 10. It can be shown that this is the smallest possible value.
Functions with output description for each function:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_18(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_19()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function `func_1` prompts the user to input an integer value within the range 1 ≤ t ≤ 10^4. After receiving the input, the function converts the input into an integer and returns it. There are no additional actions or postconditions beyond returning the integer input. This means that the function ensures the input is within the specified range, and it handles the input correctly by converting it to an integer and returning it. However, if the user inputs a value outside the range or a non-integer value, the function will raise a `ValueError`. No other postconditions or actions are performed by this function.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` accepts no parameters and prompts the user to enter a value. It then returns the value entered by the user. This function is essentially a simple input mechanism. Potential edge cases include the user entering an empty string, in which case the function would still return an empty string. However, there is no functionality to handle non-string inputs or any error checking, such as ensuring the input is within a certain range or type.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function3:  The function `func_3()` reads a single line of input from the standard input, strips any leading or trailing whitespace, splits the input into a list of substrings based on spaces, and then converts each substring into an integer, returning a list of these integers. This function accepts no explicit parameters and relies on the standard input for its operation. The function handles the case where the input might contain multiple space-separated integers. If the input is empty or consists only of whitespace, the function will return an empty list. If the input contains non-integer values, the function will raise a `ValueError`.
Function number 4 :
 Code:
 '''
def func_4():
    return map(str, input().strip().split(' '))
''' 

 Output hints for function4:  The function `func_4()` accepts no explicit parameters. It reads input from the standard input stream, expecting a series of test cases, where each test case consists of two space-separated integers \(a\) and \(b\). The function processes this input and returns a map object containing strings of these integers. The map object will have \(t\) entries, where \(t\) is the number of test cases, and each entry will consist of two string representations of integers \(a\) and \(b\) such that \(1 \leq a, b \leq 10^9\). The function assumes that the input is correctly formatted according to the specified constraints. However, it does not handle potential input errors or edge cases such as invalid input formats or values outside the specified range.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_3())
''' 

 Output hints for function5:  The function `func_5()` does not accept any parameters and returns a list. This list is generated by calling the function `func_3()` for each test case, where each test case consists of two integers `a` and `b`. Since `func_3()` is not defined in the provided code snippet, the contents of the list returned by `func_5()` are unspecified. The function assumes that `func_3()` processes the integers `a` and `b` from each test case and returns a value (which could be a single value or a list) for each test case. If `func_3()` fails to process a test case or encounters an error, the behavior is undefined because no error handling is mentioned.
Function number 6 :
 Code:
 '''
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function6:  The function `func_6` sets up a high recursion limit and stack size to handle potentially large numbers of test cases. It then starts a new thread to execute the `main` function, which processes `t` test cases. Each test case consists of two integers `a` and `b`, and the function returns a result based on these values for each test case. However, the function does not specify what exactly the `main` function does with `a` and `b`. Therefore, the exact nature of the result returned is unknown. Additionally, the function does not handle potential exceptions that might occur during the execution of the thread.
Function number 7 :
 Code:
 '''
def func_7(item):
    return item[1]
''' 

 Output hints for function7:  The function `func_7` accepts a parameter `item`, which is expected to be a tuple or list containing exactly two integers. It returns the second integer from `item`. The function performs no additional operations beyond returning the specified element. There are no edge cases mentioned in the annotations, and the code accurately reflects the intended behavior described. The final state of the program after the function concludes is that the second integer from the input `item` is returned.
Function number 8 :
 Code:
 '''
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
''' 

 Output hints for function8:  The function `func_8` accepts a single parameter `l`, which is expected to be a list containing exactly two integers `[a, b]`. It returns a new list where these integers are sorted in descending order based on the key determined by the `getKey` function. If `getKey` is not defined or does not return valid keys, the default behavior of the `sorted` function (which sorts based on the natural ordering of the elements) will be used. Potential edge cases include `l` being an empty list or `l` not containing exactly two elements, in which case the function will raise a `ValueError`.
Function number 9 :
 Code:
 '''
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function9:  The function `func_9` accepts three parameters: `n`, `m`, and `num`, where `n` and `m` are positive integers representing the dimensions of the resulting 2D list, and `num` is an integer that will be used to fill the entire 2D list. The function returns a 2D list with `n` rows and `m` columns, where every element in the list is set to the integer `num`. There are no edge cases or missing functionalities in the provided code; the function correctly creates and returns the specified 2D list.
Function number 10 :
 Code:
 '''
def func_10(x):
    return x and (not x & x - 1)
''' 

 Output hints for function10:  The function `func_10` accepts a non-negative integer `x` and returns `True` if `x` is 0, otherwise it returns `False`. The function uses the expression `return x and not x & x - 1` to determine the return value. This expression checks if `x` is 0 by leveraging the bitwise AND operation between `x` and `x - 1`. If `x` is 0, then `x & x - 1` results in 0, and the expression evaluates to `True`. If `x` is any positive integer, `x & x - 1` will result in a non-zero value, making the expression evaluate to `False`. There are no edge cases or missing functionality as the provided code correctly implements the intended logic.
Function number 11 :
 Code:
 '''
def func_11(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function11:  The function `func_11` accepts an integer `n` where \(1 \leq n \leq 10^9\) and returns a binary string representation of `n` without the '0b' prefix. The function achieves this by first converting the integer `n` to its binary form using the `bin()` function, which includes the '0b' prefix. It then removes the '0b' prefix using the `replace()` method. The function correctly handles all integers within the specified range, including edge cases such as the smallest (`1`) and largest (`10^9`) possible values. No missing functionality or edge cases were found in the provided code.
Function number 12 :
 Code:
 '''
def func_12(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function12:  The function `func_12` accepts an integer `n` within the range 1 ≤ n ≤ 10^9 and returns a list of its individual digits as integers. The function converts the integer `n` into a string, iterates over each character (digit) in the string, converts each character back into an integer, and collects these integers into a list. This process ensures that all digits of `n` are included in the returned list. The function handles the edge case where `n` is a single-digit number by correctly returning a list containing only that digit. No other edge cases are explicitly addressed in the provided code, but the logic inherently manages the conversion and list creation for any valid input within the specified range.
Function number 13 :
 Code:
 '''
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
''' 

 Output hints for function13:  The function `func_13` accepts two non-negative integers `n` and `r` such that \(0 \leq r \leq n\). It calculates and returns the binomial coefficient, which is the number of ways to choose `r` elements from a set of `n` elements without regard to the order of selection. This is mathematically represented as \(\binom{n}{r} = \frac{n!}{r!(n-r)!}\). If `n - r` is 0, then `max(n - r, 1)` returns 1, ensuring the denominator is not zero. If `r` is 0 or `n`, the function correctly returns 1, as \(\binom{n}{0} = \binom{n}{n} = 1\). If `r > n`, the function would raise an error because of the initial condition check, but since the function's preconditions ensure \(0 \leq r \leq n\), this case is handled.
Function number 14 :
 Code:
 '''
def func_14(x, y):
    if x % y == 0:
        return x // y
    else:
        return x // y + 1
''' 

 Output hints for function14:  The function `func_14` accepts two parameters, `x` and `y`, which are positive integers such that 1 <= y <= x. It returns the integer division of `x` by `y` if `x` is divisible by `y`. If `x` is not divisible by `y`, it returns `x // y + 1`. This ensures that the returned value is always greater than or equal to the integer division of `x` by `y`.

Potential edge cases and missing functionality:
- The function correctly handles the case where `x` is exactly divisible by `y` (i.e., `x % y == 0`), returning `x // y`.
- The function correctly handles the case where `x` is not divisible by `y` (i.e., `x % y != 0`), returning `x // y + 1`.
- The function ensures that the inputs are positive integers and that `1 <= y <= x`, as these conditions are checked by the nature of the input constraints.
Function number 15 :
 Code:
 '''
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
''' 

 Output hints for function15:  The function `func_15` accepts three parameters `x`, `y`, and `p`, where `x` and `p` are integers, and `y` is a non-negative integer representing the exponent. The function calculates \( x^{2^k} \mod p \) using the square-and-multiply algorithm and stores the result in `res`. The variable `res` is initialized to 1 and updated in each iteration of the loop. After the loop completes, the function returns the value of `res`, which is always 1. This is because the initial value of `res` is set to 1, and no operations modify its value during the loop.
Function number 16 :
 Code:
 '''
def func_16(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function16:  The function `func_16` accepts two positive integers `x` and `y` such that \(1 \leq x, y \leq 10^9\). It uses the Euclidean algorithm to compute the greatest common divisor (GCD) of `x` and `y`. After executing the algorithm, the function returns 0. This is because the last value of `y` (which is the GCD of `x` and `y`) is assigned to `x`, and then `x` is returned, which is 0. Therefore, the final state of the program after the function concludes is that the return value is 0, regardless of the initial values of `x` and `y` (as long as they are within the specified range).
Function number 17 :
 Code:
 '''
def func_17(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function17:  The function `func_17` accepts an integer `n` greater than 1 and determines whether `n` is a prime number. It returns `True` if `n` is a prime number and `False` otherwise. The function checks several conditions to determine primality:

- If `n` is less than or equal to 1, it returns `False`.
- If `n` is less than or equal to 3, it returns `True`.
- If `n` is divisible by 2 or 3, it returns `False`.
- For numbers greater than 3, it checks divisibility by numbers of the form \(5 + 6k\) and \(7 + 6k\) up to the square root of `n`.

The function returns `True` if `n` passes all these checks, indicating that `n` is a prime number. Otherwise, it returns `False`.
Function number 18 :
 Code:
 '''
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
''' 

 Output hints for function18:  The function changes the standard input and output streams to read from 'input.txt' and write to 'output.txt'. There are no parameters accepted by the function, and it does not return anything. This means that any subsequent input operations will read from 'input.txt' and any subsequent output operations will write to 'output.txt'. The function also does not process or manipulate any data; it only redirects the input and output streams.
Function number 19 :
 Code:
 '''
def func_19():
    for _ in range(func_1()):
        (x, y) = func_3()
        ans = 0
        for i in range(32):
            if x & 1 << i and y & 1 << i or (not x & 1 << i and (not y & 1 << i)):
                continue
            else:
                ans += 1 << i
        func_20(ans)
''' 

 Output hints for function19:  The function `func_19()` accepts no parameters directly but obtains two integers `x` and `y` from the function `func_3()`. It then iterates through 32 bits (from 0 to 31) and checks if both `x` and `y` have a 1 bit set at the same position or if both have a 0 bit set at the same position. If either condition is met, it skips to the next iteration. Otherwise, it sets the corresponding bit in `ans`. After completing the loop, it calls `func_20()` with `ans` as its argument. The final state of the program after `func_19()` concludes is that `x` and `y` are the last values returned by `func_3()`, and `ans` is the bitwise OR of all positions where both `x` and `y` have a 1 bit set across all iterations. Potential edge cases include when both `x` and `y` have no bits set to 1 in common, in which case `ans` would be 0. Additionally, if `func_3()` returns `x` or `y` with all bits set to 1, `ans` would also be all bits set to 1.
Function number 20 :
 Code:
 '''
def func_20(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function20:  The function `func_20()` does not actually return any value; instead, it writes elements of `args` to the specified `file` (defaulting to `sys.stdout`) separated by a separator (`sep`). After writing, it appends an `end` character and flushes the buffer if specified. The function iterates over the elements of `args` and writes them to the file, updating the `at_start` flag to ensure separators are only added between elements. If `kwargs.pop('flush', False)` is `True`, it flushes the write buffers. There are no conditions involving `a` and `b`, and the function does not return `t` as stated in the annotations. Instead, it simply outputs the elements of `args` with the specified formatting.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.