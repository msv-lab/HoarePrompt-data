
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i ∈ \{1, 2\}) — the values written on the tiles.

Output

Output a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

Examples

Input


5
1 2 1 2 1


Output


1 1 1 2 2


Input


9
1 1 2 1 1 1 2 1 1


Output


1 1 1 2 1 1 1 2 1

Note

The first solution produces the prefix sums 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase

"""
Author    : raj1307 - Raj Singh
Institute : Jalpaiguri Government Engineering College
Date      : 29.04.19
"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from builtins import str as __str__
    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            (b, ptr) = (os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell())
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
            self.newlines += b.count(b'\n') + (not b)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            (self._buffer.truncate(0), self._buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
if __name__ == '__main__':
    func_14()

#Function 1:
#State of the program right berfore the function call: There is no direct relationship or precondition involving variables related to the number tiles or their arrangement within the function `func_1`. This function does not contribute to solving the main problem described. It appears to be a separate utility function for writing arguments to a file with specified separators and other formatting options.
def func_1():
    sep, file = kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is `False`, `file` contains the concatenation of all elements in `args` with `sep` between each pair of elements, starting from the second element, `args` is a list containing all original elements, `sep` is `b' '`, `file` is `sys.stdout`, and `kwargs` remains unchanged.
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: `at_start` is `False`, `file` is `sys.stdout` with the concatenated string of `args` and `b'\n'` appended, `args` is a list containing all original elements, `sep` is `b' '`, `kwargs` does not contain the key `'end'` and `'flush'` and retains any other unchanged keys.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function signature are provided, but the function reads an integer input representing the number of number tiles in the bag.
def func_2():
    return int(input())
    #The program returns an integer input representing the number of number tiles in the bag

#Function 3:
#State of the program right berfore the function call: None of the variables in the function `func_3()` are defined in its signature, so there are no explicit preconditions provided. However, based on the problem description, `func_3` should be part of a larger solution where `n` and the list of tiles `a_1, a_2, ..., a_n` are provided as input to the main function, not within `func_3`.
def func_3():
    return str(input())
    #The program returns a string input from the user

#Function 4:
#State of the program right berfore the function call: None of the variables in the function signature are provided in the code snippet. However, the function `func_4()` reads input from the standard input, which consists of two lines: the first line contains a single integer `n` (the number of number tiles in the bag), and the second line contains `n` space-separated integers representing the values written on the tiles (either 1 or 2).
def func_4():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers parsed from the second line of input, where the input consists of the number of number tiles followed by their values (either 1 or 2)

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the following line of input contains n space-separated integers each being either 1 or 2.
def func_5():
    return list(func_4())
    #The program returns a list generated by func_4(), which takes as input an integer n (1 ≤ n ≤ 200,000) and a list of n space-separated integers each being either 1 or 2

#Function 6:
#State of the program right berfore the function call: item is a tuple or list containing at least one element, where the first element is of a type that can be compared and sorted (e.g., integer, float, string).
def func_6(item):
    return item[0]
    #The program returns the first element of the tuple or list 'item', which is of a type that can be compared and sorted

#Function 7:
#State of the program right berfore the function call: l is a list of integers where each integer is either 1 or 2.
def func_7(l):
    return sorted(l, key=getKey)
    #The program returns a sorted list of integers from 'l', where each integer is either 1 or 2, using the 'getKey' function as the sorting key

#Function 8:
#State of the program right berfore the function call: n and m are non-negative integers representing the dimensions of a 2D list, and num is an integer either 1 or 2.
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns, where each element in the list is equal to 'num', which is either 1 or 2

#Function 9:
#State of the program right berfore the function call: x is a non-negative integer.
def func_9(x):
    return x and not x & x - 1
    #The program returns True if x is 0 or False if x is a non-zero non-negative integer

#Function 10:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2^{200,000}.
def func_10(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of integer 'n', without the '0b' prefix

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the binary representation of n consists only of the digits 1 and 2.
def func_11(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is either 1 or 2 based on the binary representation of the initial integer n

#Function 12:
#State of the program right berfore the function call: x is an integer, y is a positive integer, and p is a prime number.
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p1
        
    #State of the program after the loop has been executed: Output State: `y` is 0, `res` is the result of `x^k % p` where `k` is the number of times `y` was odd, `x` is the final value after all squaring operations, `p` and `p1` remain unchanged.
    return res
    #`The program returns res which is the result of x^k % p where k is the number of times y was odd, and x is the final value after all squaring operations`

#Function 13:
#State of the program right berfore the function call: x and y are non-negative integers, and x and y represent two numbers whose greatest common divisor (GCD) is to be computed.
def func_13(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the GCD of the original values of `x_0` and `y_0`; `y` is 0.
    return x
    #The program returns the GCD of the original values of `x_0` and `y_0`

#Function 14:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and l is a list of integers where each integer is either 1 or 2.
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    """if two==one:
        for i in range(n):
            if i%2==0:
                s.append(2)
            else:
                s.append(1)
        print(*s)
        exit()
        
    
    for i in range(n):
        if a[i]==1:
            if one !=0:
                s.append(1)
                one-=1
            else:
                s.append(2)
                two-=1
        else:
            if two!=0:
                s.append(2)
                two-=1
            else:
                s.append(1)
                one-=1
    print(*s)   """
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
        
    #State of the program after the  for loop has been executed: `n` is the value returned by `func_2()`, `l` is the list returned by `func_5()`, `s` is a sequence of `1`s and `2`s starting with `2` and having a length of `n`, `one` is `0`, `two` is `0`, `p` is a list of integers starting with `2` and having a length of `n`, with the last element being even if `one` was used in the last iteration and odd if `two` was used in the last iteration.
    func_1(*s)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
