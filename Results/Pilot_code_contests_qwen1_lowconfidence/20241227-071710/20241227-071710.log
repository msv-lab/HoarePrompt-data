DEBUG - Start Task 0003
ERROR - Error: unsupported statement type: <ast.ClassDef object at 0x7d039b3b5ba0> class graph:

    def __init__(self, gdict=None):
        if gdict is None:
            gdict = defaultdict(list)
        self.gdict, self.edges, self.l = gdict, defaultdict(int), defaultdict(
            int)

    def addEdge(self, node1, node2, w=None):
        self.gdict[node1].append(node2)
        self.gdict[node2].append(node1)
        self.l[node1] += 1
        self.l[node2] += 1

DEBUG - Start Task 0004
DEBUG - Dataset: code_contests
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: An array of integers p_{1},p_{2}, …,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].

There is a hidden permutation of length n.

For each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.

Your task is to restore the permutation.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the size of the permutation.

The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/(2)).

It is guaranteed that the array s corresponds to a valid permutation of length n.

Output

Print n integers p_{1}, p_{2}, …, p_{n} — the elements of the restored permutation. We can show that the answer is always unique.

Examples

Input


3
0 0 0


Output


3 2 1


Input


2
0 1


Output


1 2


Input


5
0 1 1 1 10


Output


1 4 3 2 5

Note

In the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.

In the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.

In the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 0005
DEBUG - Dataset: code_contests
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n points on a coordinate axis OX. The i-th point is located at the integer point x_i and has a speed v_i. It is guaranteed that no two points occupy the same coordinate. All n points move with the constant speed, the coordinate of the i-th point at the moment t (t can be non-integer) is calculated as x_i + t ⋅ v_i.

Consider two points i and j. Let d(i, j) be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points i and j coincide at some moment, the value d(i, j) will be 0.

Your task is to calculate the value ∑_{1 ≤ i < j ≤ n} d(i, j) (the sum of minimum distances over all pairs of points).

Input

The first line of the input contains one integer n (2 ≤ n ≤ 2 ⋅ 10^5) — the number of points.

The second line of the input contains n integers x_1, x_2, ..., x_n (1 ≤ x_i ≤ 10^8), where x_i is the initial coordinate of the i-th point. It is guaranteed that all x_i are distinct.

The third line of the input contains n integers v_1, v_2, ..., v_n (-10^8 ≤ v_i ≤ 10^8), where v_i is the speed of the i-th point.

Output

Print one integer — the value ∑_{1 ≤ i < j ≤ n} d(i, j) (the sum of minimum distances over all pairs of points).

Examples

Input


3
1 3 2
-100 2 3


Output


3


Input


5
2 1 4 3 5
2 2 2 3 4


Output


19


Input


2
2 1
-3 0


Output


0
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 0033
DEBUG - Dataset: code_contests
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Takahashi is participating in a programming contest called AXC002, and he has just submitted his code to Problem A.

The problem has N test cases.

For each test case i (1\leq i \leq N), you are given a string S_i representing the verdict for that test case. Find the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively.

See the Output section for the output format.

Constraints

* 1 \leq N \leq 10^5
* S_i is `AC`, `WA`, `TLE`, or `RE`.

Input

Input is given from Standard Input in the following format:


N
S_1
\vdots
S_N


Output

Let C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively. Print the following:


AC x C_0
WA x C_1
TLE x C_2
RE x C_3

Output

Let C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively. Print the following:


AC x C_0
WA x C_1
TLE x C_2
RE x C_3

Examples

Input

6
AC
TLE
AC
AC
WA
TLE


Output

AC x 3
WA x 1
TLE x 2
RE x 0


Input

10
AC
AC
AC
AC
AC
AC
AC
AC
AC
AC


Output

AC x 10
WA x 0
TLE x 0
RE x 0
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': False, 'default': True, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 0036
DEBUG - Dataset: code_contests
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a staircase with N steps. Takahashi is now standing at the foot of the stairs, that is, on the 0-th step. He can climb up one or two steps at a time.

However, the treads of the a_1-th, a_2-th, a_3-th, \ldots, a_M-th steps are broken, so it is dangerous to set foot on those steps.

How many are there to climb up to the top step, that is, the N-th step, without setting foot on the broken steps? Find the count modulo 1\ 000\ 000\ 007.

Constraints

* 1 \leq N \leq 10^5
* 0 \leq M \leq N-1
* 1 \leq a_1 < a_2 < ... < a_M \leq N-1

Input

Input is given from Standard Input in the following format:


N M
a_1
a_2
.
.
.
a_M


Output

Print the number of ways to climb up the stairs under the condition, modulo 1\ 000\ 000\ 007.

Examples

Input

6 1
3


Output

4


Input

10 2
4
5


Output

0


Input

100 5
1
23
45
67
89


Output

608200469
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 0037
ERROR - Error: expected an indented block after class definition on line 6 (<unknown>, line 13)
DEBUG - Start Task 0053
