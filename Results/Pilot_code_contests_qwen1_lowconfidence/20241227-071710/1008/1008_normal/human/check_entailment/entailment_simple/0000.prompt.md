
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Valera has got a rectangle table consisting of n rows and m columns. Valera numbered the table rows starting from one, from top to bottom and the columns – starting from one, from left to right. We will represent cell that is on the intersection of row x and column y by a pair of integers (x, y).

Valera wants to place exactly k tubes on his rectangle table. A tube is such sequence of table cells (x1, y1), (x2, y2), ..., (xr, yr), that: 

  * r ≥ 2; 
  * for any integer i (1 ≤ i ≤ r - 1) the following equation |xi - xi + 1| + |yi - yi + 1| = 1 holds; 
  * each table cell, which belongs to the tube, must occur exactly once in the sequence. 



Valera thinks that the tubes are arranged in a fancy manner if the following conditions are fulfilled: 

  * no pair of tubes has common cells; 
  * each cell of the table belongs to some tube. 



Help Valera to arrange k tubes on his rectangle table in a fancy manner.

Input

The first line contains three space-separated integers n, m, k (2 ≤ n, m ≤ 300; 2 ≤ 2k ≤ n·m) — the number of rows, the number of columns and the number of tubes, correspondingly. 

Output

Print k lines. In the i-th line print the description of the i-th tube: first print integer ri (the number of tube cells), then print 2ri integers xi1, yi1, xi2, yi2, ..., xiri, yiri (the sequence of table cells).

If there are multiple solutions, you can print any of them. It is guaranteed that at least one solution exists. 

Examples

Input

3 3 3


Output

3 1 1 1 2 1 3
3 2 1 2 2 2 3
3 3 1 3 2 3 3


Input

2 3 1


Output

6 1 1 1 2 1 3 2 3 2 2 2 1

Note

Picture for the first sample: 

<image>

Picture for the second sample: 

<image>
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import sys
from copy import deepcopy
import os, sys
from io import IOBase, BytesIO

"""Template for Python Competitive Programmers prepared by Mayank Chaudhary """
'value of mod'
MOD = 998244353
mod = 10 ** 9 + 7
'use resource'
'for factorial'
'uncomment next 4 lines while doing recursion based question'
'uncomment modules according to your need'
'\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n'
'*******************************************************'
' -------- Python 2 and 3 footer by Pajenegod and c1729 ---------'
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
' main function'
if __name__ == '__main__':
    func_6()

#Function 1:
#State of the program right berfore the function call: None of the variables in the function `func_1()` are described in the problem statement or the function itself. The function reads input from stdin and returns an iterator of integers representing the dimensions of the table (n, m, k), where n and m are the number of rows and columns respectively, and k is the number of tubes.
def func_1():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns an iterator of integers representing the dimensions of the table (n, m, k), where n and m are the number of rows and columns respectively, and k is the number of tubes, read from stdin

#Function 2:
#State of the program right berfore the function call: The function does not take any parameters. It reads input from stdin, which consists of three space-separated integers representing the number of rows (n), the number of columns (m), and the number of tubes (k), respectively.
def func_2():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of three integers read from stdin, representing the number of rows (n), the number of columns (m), and the number of tubes (k) respectively

#Function 3:
#State of the program right berfore the function call: None of the variables in the function signature are provided in the given code snippet. The function does not take any parameters.
def func_3():
    return sys.stdin.readline().strip()
    #The program reads a line from standard input, strips any trailing whitespace, and returns it

#Function 4:
#State of the program right berfore the function call: x and y are non-negative integers, and at least one of them is positive.
def func_4(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: 'x' is the greatest common divisor (GCD) of the original values of 'x' and 'y', 'y' is 0
    return x
    #The program returns x which is the greatest common divisor (GCD) of the original values of x and y, given y is 0

#Function 5:
#State of the program right berfore the function call: x and y are positive integers such that 2 ≤ n, m ≤ 300 and 2 ≤ 2k ≤ n*m.
def func_5(x, y):
    return x * y // func_4(x, y)
    #The program returns the integer division of x * y by the result of func_4(x, y)

#Function 6:
#State of the program right berfore the function call: rows and cols are positive integers such that 2 ≤ rows, cols ≤ 300 and 2 ≤ 2 * k ≤ rows * cols. k is a positive integer representing the number of tubes.
def func_6():
    rows, cols, k = func_1()
    curr_x = curr_y = 0
    turn = 0
    store = []
    for i in range(rows):
        if not turn:
            for j in range(cols):
                store.append([i + 1, j + 1])
        else:
            for j in range(cols - 1, -1, -1):
                store.append([i + 1, j + 1])
        
        turn ^= 1
        
    #State of the program after the  for loop has been executed: `rows` is a positive integer such that \(2 \leq \text{rows} \leq 300\), `cols` is a positive integer such that \(2 \leq \text{cols} \leq 300\), `2 * k` is a positive integer such that \(2 \leq 2 * k \leq \text{rows} * \text{cols}\), `curr_x` is 0, `curr_y` is 0, `turn` is the opposite of its original value, and `store` contains all coordinates \([i + 1, j + 1]\) for every \(i\) in the range from 0 to `rows - 1` and every \(j\) in the range from 0 to `cols - 1`.
    i = 0
    count = 0
    while count < k - 1:
        print(2, end=' ')
        
        print(*store[i], end=' ')
        
        print(*store[i + 1])
        
        i += 2
        
        count += 1
        
    #State of the program after the loop has been executed: `rows` is a positive integer such that \(2 \leq \text{rows} \leq 300\), `cols` is a positive integer such that \(2 \leq \text{cols} \leq 300\), `2 * k` is a positive integer such that \(2 \leq 2 * k \leq \text{rows} * \text{cols}\), `curr_x` is 0, `curr_y` is 0, `turn` is the opposite of its original value, `store` contains all coordinates \([i + 1, j + 1]\) for every \(i\) in the range from 0 to `rows - 1` and every \(j\) in the range from 0 to `cols - 1`, `i` is `rows * cols - 2`, `count` is `k - 1`, `k` must be at least 2, the loop prints `2` followed by pairs of coordinates from `store` until `count` reaches `k - 1
    print(rows * cols - 2 * (k - 1), end=' ')
    while i < rows * cols:
        if i == rows * cols - 1:
            print(*store[i])
        else:
            print(*store[i], end=' ')
        
        i += 1
        
    #State of the program after the loop has been executed: `i` is `rows * cols`, `count` is `k - 1`, `k` must be at least 2, `curr_x` is 0, `curr_y` is 0, `turn` is the opposite of its original value, and the printed value is `rows * cols - 2 * (k - 1)`


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
