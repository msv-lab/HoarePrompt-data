
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: An array of integers p_{1},p_{2}, …,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].

There is a hidden permutation of length n.

For each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.

Your task is to restore the permutation.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the size of the permutation.

The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/(2)).

It is guaranteed that the array s corresponds to a valid permutation of length n.

Output

Print n integers p_{1}, p_{2}, …, p_{n} — the elements of the restored permutation. We can show that the answer is always unique.

Examples

Input


3
0 0 0


Output


3 2 1


Input


2
0 1


Output


1 2


Input


5
0 1 1 1 10


Output


1 4 3 2 5

Note

In the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.

In the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.

In the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.
Annotated Functions:
from sys import stdin, stdout
from collections import Counter, defaultdict
from itertools import permutations, combinations

raw_input = stdin.readline
pr = stdout.write
mod = 10 ** 9 + 7
range = xrange
n = func_1()
BITTree = [0] * (n + 1)
l = func_2()
for i in range(n):
    func_7(i, i)
ans = [0] * n
for i in range(n - 1, -1, -1):
    ans[i] = func_8(l[i])
    func_7(ans[i], -ans[i])
func_4(ans)

#Function 1:
#State of the program right berfore the function call: None of the variables in the function signature are present since the function does not take any parameters. However, the function reads input from the user using `raw_input()`, which is not part of the function's signature but is crucial for the program's operation. The input consists of the integer n followed by n integers representing the array s.
def func_1():
    return int(raw_input())
    #The program returns an integer input by the user followed by n integers representing the array s
#Overall this is what the function does:The function `func_1` reads an integer input `n` from the user, followed by `n` additional integers representing an array `s`. It then returns these values as a single integer (the first input `n`) concatenated with the `n` integers from the array `s` as a string. There are no parameters passed to the function, and it relies on user input through `raw_input()` to proceed. The function does not perform any operations on the input values; it simply collects them and returns them in a specific format.

#Function 2:
#State of the program right berfore the function call: The function does not take any parameters. It reads input from standard input, which consists of two lines. The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}). The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/2), representing the sums described in the problem statement.
def func_2():
    return map(int, raw_input().split())
    #The program returns a map object containing integers read from the standard input, where the first line contains the number of integers to follow and the second line contains those integers
#Overall this is what the function does:The function `func_2()` reads input from standard input consisting of an integer `n` followed by `n` integers. It returns a map object containing these integers. This function assumes that the input is provided in the correct format: the first line contains a single integer `n`, and the second line contains `n` space-separated integers. If the input format is incorrect, the function will raise an error because `raw_input().split()` will not correctly parse the input. There are no explicit checks for the constraints on `n` (1 ≤ n ≤ 2 ⋅ 10^{5}) or the values of the integers (0 ≤ s_{i} ≤ (n(n-1))/2). After the function concludes, the program state will be such that the map object contains the integers read from the standard input.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^{5}.
def func_3(n):
    stdout.write(str(n) + '\n')
#Overall this is what the function does:The function `func_3` accepts an integer `n` such that \(1 \leq n \leq 2 \cdot 10^5\). It writes the integer `n` to standard output followed by a newline character. The function does not return any value. After the function concludes, the integer `n` has been printed to the console.

#Function 4:
#State of the program right berfore the function call: arr is a list of n non-negative integers such that 0 <= n <= 2 * 10^5 and each s_i (where s_i is the i-th element of arr) satisfies 0 <= s_i <= (n*(n-1))/2, corresponding to a valid permutation of length n.
def func_4(arr):
    pr(' '.join(map(str, arr)) + '\n')
#Overall this is what the function does:The function `func_4` accepts a list `arr` of `n` non-negative integers, where `n` is within the range `0 <= n <= 2 * 10^5` and each element `s_i` in `arr` satisfies `0 <= s_i <= (n*(n-1))/2`, corresponding to a valid permutation of length `n`. After executing, the function prints the elements of `arr` separated by spaces followed by a newline character. There is no return value from the function.

#Function 5:
#State of the program right berfore the function call: None of the variables in the function `func_5()` are defined in its signature, thus it does not have any explicit input parameters. The function reads input from `stdin`, processes it, and returns an iterator of integers.
def func_5():
    return map(int, stdin.read().split())
    #The program returns an iterator of integers read from standard input (stdin) and split based on spaces, with each element converted to an integer
#Overall this is what the function does:The function `func_5()` reads input from standard input (stdin), processes it by splitting the input based on spaces, converting each element to an integer, and returning an iterator of these integers. There are no explicit input parameters. Potential edge cases include the input being empty or containing non-integer values, which would result in a ValueError when attempting to convert the elements to integers. The function does not handle these cases, so an error might occur if the input does not consist solely of integers separated by spaces.

#Function 6:
#State of the program right berfore the function call: i is an integer such that 1 <= i <= n, and BITTree is a Binary Indexed Tree (Fenwick Tree) initialized with a length of n+1 containing non-negative integer values.
def func_6(i):
    s = 0
    i = i + 1
    while i > 0:
        s += BITTree[i]
        
        i -= i & -i
        
    #State of the program after the loop has been executed: `i` is 0, `s` is the prefix sum up to the original value of `i` in the Binary Indexed Tree (Fenwick Tree) `BITTree`, `BITTree` is a Binary Indexed Tree (Fenwick Tree) initialized with a length of `n+1` containing non-negative integer values.
    return s
    #The program returns s, which is the prefix sum up to the original value of i in the Binary Indexed Tree (Fenwick Tree) BITTree
#Overall this is what the function does:The function `func_6` accepts an integer `i` as a parameter and returns the prefix sum up to the original value of `i` in the Binary Indexed Tree (Fenwick Tree) `BITTree`. The function starts by incrementing `i` by 1. It then iterates using a while loop where it accumulates the sum of elements in `BITTree` from index `i` to the beginning of the tree, updating `i` by subtracting its largest leftmost set bit until `i` becomes 0. After the loop, the function returns the accumulated sum `s`. This process ensures that the returned value is the prefix sum up to the original value of `i` in the `BITTree`.

#Function 7:
#State of the program right berfore the function call: i is an integer such that 0 <= i <= n, and v is an integer representing the value to be added to the Binary Indexed Tree (BITTree) at index i after adjusting i by adding 1.
def func_7(i, v):
    i += 1
    while i <= n:
        BITTree[i] += v
        
        i += i & -i
        
    #State of the program after the loop has been executed: `i` is greater than `n`, `BITTree[i-1]` is the cumulative effect of adding `v` at every position up to the largest power of 2 less than or equal to `n`, where `i` was updated to the next power of 2 each time the loop executed.
#Overall this is what the function does:The function `func_7` accepts two parameters, `i` and `v`, where `i` is an integer in the range \(0 \leq i \leq n-1\) and `v` is an integer. The function updates the Binary Indexed Tree (BITTree) by adding `v` to the elements at indices from `i + 1` to the next highest index that is a multiple of the largest power of 2 less than or equal to `n`. Specifically, it updates the BITTree such that the value `v` is added to the element at index `i + 1`, then to the next index that is a multiple of 2, then to the next index that is a multiple of 4, and so on, until the index exceeds `n`. The function ensures that the BITTree reflects the cumulative effect of adding `v` to the specified range of indices. If `i` is already a power of 2, it updates the BITTree starting from `i + 1` and continues until the next power of 2.

#Function 8:
#State of the program right berfore the function call: x is an integer such that 0 <= x <= (n*(n-1))//2, n is a positive integer representing the size of the permutation, and BITTree is a Binary Indexed Tree (also known as a Fenwick Tree) that stores the cumulative sums of some permutation-related values up to a certain index.
def func_8(x):
    ret = 0
    sm = 0
    for i in range(21, -1, -1):
        pw = 1 << i
        
        if ret + pw <= n and sm + BITTree[ret + pw] <= x:
            ret += pw
            sm += BITTree[ret]
        
    #State of the program after the  for loop has been executed: `x` is an integer such that \(0 \leq x \leq \frac{n(n-1)}{2}\), `n` is a positive integer, `BITTree` is a Binary Indexed Tree storing cumulative sums, `sm` is the sum of the values added to `sm` during the loop, `ret` is the maximum value such that `ret \leq n` and `sm + BITTree[ret] \leq x`.
    return ret
    #`The program returns ret, which is the maximum value such that ret ≤ n and sm + BITTree[ret] ≤ x`
#Overall this is what the function does:The function `func_8` accepts an integer `x` such that \(0 \leq x \leq \frac{n(n-1)}{2}\), where `n` is a positive integer representing the size of the permutation, and `BITTree` is a Binary Indexed Tree (Fenwick Tree) storing cumulative sums of some permutation-related values up to a certain index. The function iterates backward through a range of bits from 21 to 0. During each iteration, it checks if adding \(2^i\) (where `i` is the current bit index) to `ret` and `BITTree[ret + 2^i]` to `sm` still satisfies the condition `sm + BITTree[ret + 2^i] <= x`. If the condition holds, it updates `ret` and `sm` accordingly. After the loop, the function returns `ret`, which is the maximum value such that `ret` ≤ `n` and `sm + BITTree[ret]` ≤ `x`. This ensures that `ret` is the largest possible value meeting the specified conditions.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.