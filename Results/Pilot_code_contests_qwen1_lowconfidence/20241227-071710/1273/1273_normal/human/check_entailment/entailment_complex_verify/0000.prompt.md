
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You have given tree consist of n vertices. Select a vertex as root vertex that satisfies the condition below.

  * For all vertices v_{1} and v_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then degree(v_{1}) = degree(v_{2}), where degree means the number of vertices connected to that vertex, and distance means the number of edges between two vertices. 



Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^{5}) — the number of vertices.

Each of the next n-1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i} < u_{i} ≤ n) — it means there is an edge exist between v_{i} and u_{i}. It is guaranteed that the graph forms tree.

Output

If there is such root vertex exists, print any of them. Otherwise, print -1.

Examples

Input


7
1 2
2 3
3 4
4 5
3 6
6 7


Output


3


Input


6
1 3
2 3
3 4
4 5
4 6


Output


-1

Note

This is the picture for the first example. 1, 5, 7 also can be a valid answer.

<image>

This is the picture for the second example. You can see that it's impossible to find such root vertex.

<image>
Program:
```
from collections import*

def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        (u, v) = map(int, raw_input().split())
        e[u].append(v)
        e[v].append(u)
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(cur)
        exit()
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(end)
        exit()
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(center)
        exit()
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(top)
        exit()
    print(-1)


```
Original Assessment: Correctness: **False**.

Explanation: The provided program attempts to find a root vertex in a tree that satisfies the given condition. However, the logic in the program is flawed and does not guarantee finding the correct root vertex for all possible inputs. Specifically, the program's approach to checking the degree and distance conditions is not fully robust.

For instance, consider the following input:
```
6
1 2
2 3
3 4
4 5
5 6
```

In this case, the program should output `3` because it is a valid root vertex that satisfies the condition. However, the current implementation might not correctly identify `3` as the root vertex due to its complex and potentially incorrect handling of distances and degrees.

Moreover, the program's structure and logic are overly complicated and do not clearly ensure that all potential cases are handled correctly. A more straightforward and accurate approach would involve directly verifying the condition for each vertex without the extensive nested checks and updates.

To verify the correctness, one could test with various tree structures and ensure that the program identifies the correct root vertex for all valid cases and outputs `-1` for invalid cases. Given the complexity and potential flaws, the program fails to meet the requirements for every potential case, hence the answer is `False`.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from collections import*

#State of the program right berfore the function call: The input is a list of tuples representing the edges of a tree, where each tuple contains two integers v_i and u_i indicating an edge between v_i and u_i. The number of vertices n is given as the first integer in the input, and it satisfies 1 ≤ n ≤ 10^5.
def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u, v = map(int, raw_input().split())
        
        e[u].append(v)
        
        e[v].append(u)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is `n - 1`, `e` is a list with `n + 1` elements, each being an empty list except for the lists `e[u]` and `e[v]` which contain the set of all vertices connected to `u` and `v` respectively, where each vertex appears exactly twice (once for each edge connecting it to another vertex).
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `q` is an empty deque, `cur` is the initial value of `1`, `dep` is a list of length \( n + 1 \) where for all vertices \( v \) reachable from \( 1 \), `dep[v]` is the shortest distance from \( 1 \) to \( v \). `dep[v]` is -1 if \( v \) is not reachable from \( 1 \).
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
        
    #State of the program after the loop has been executed: `q` is an empty deque, `cur` is 0, `end` is the last visited node, `dep` is a list of length \( n + 1 \) where each `dep[i]` represents the shortest distance from node 1 to node `i`, and `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n + 1`, `n` is a non-negative integer, `bad` is `True` if at any point `deg[dep[i]]` was found to be different from `len(e[i])`, otherwise `bad` is `False`, `q` is an empty deque, `cur` is `0`, `end` is the last visited node, `dep` is a list of length \( n + 1 \) where each `dep[i]` represents the shortest distance from node 1 to node `i`, `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree, `deg` is a list of length \( n + 1 \) where every element is either `-1` (indicating the shortest path has not been determined yet) or the length of the edge leading to node `i` from its predecessor, and `bad` is a boolean indicating whether there was a contradiction in the shortest path distances.
    if (not bad) :
        print(cur)
        exit()
    #State of the program after the if block has been executed: *`i` is `n + 1`, `n` is a non-negative integer, `bad` is `False`, `q` is an empty deque, `cur` is `0`, `end` is the last visited node, `dep` is a list of length \( n + 1 \) where each `dep[i]` represents the shortest distance from node 1 to node `i`, `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree, `deg` is a list of length \( n + 1 \) where every element is either `-1` (indicating the shortest path has not been determined yet) or the length of the edge leading to node `i` from its predecessor. The condition `not bad` holds true, ensuring no contradiction in the shortest path distances was found.
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
        
    #State of the program after the  for loop has been executed: `center` is the node that is the farthest from node 1 along the shortest path to `end`, `i` is the number of times the loop has executed, `dep[end]` must be 1 or 0, `n` is a non-negative integer, `bad` is `False`, `q` is an empty deque, `cur` is `0`, `end` is the last visited node, `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree, `deg` is a list of length \( n + 1 \) where every element is either `-1` (indicating the shortest path has not been determined yet) or the length of the edge leading to node `i` from its predecessor.
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `cur` is `None` (or the loop terminates because there are no more nodes to process), `dep` is the depth of each node from node 1 in the shortest path tree, `q` is an empty deque, `end` is the last visited node, `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree, `deg` is a list of length \( n + 1 \) where every element is either `-1` (indicating the shortest path has not been determined yet) or the length of the edge leading to node `i` from its predecessor, and `bad` is `False` if the entire graph is reachable from node 1, otherwise `True`.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n + 1`, `n` is a positive integer, `bad` is `True` if there exists any `i` such that `deg[dep[i]] != len(e[i])`, otherwise `bad` is `False`. The values of `deg[dep[i]]` are either `-1` (if not yet updated) or `len(e[i])` (if the condition was not violated).
    if (not bad) :
        print(end)
        exit()
    #State of the program after the if block has been executed: *`i` is `n + 1`, `n` is a positive integer, `bad` is `False`, the values of `deg[dep[i]]` are either `-1` (if not yet updated) or `len(e[i])` (if the condition was not violated), `print()` outputs `None`
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
        
    #State of the program after the loop has been executed: `q` is an empty deque, `cur` is `center`, `to` is undefined, `dep` is updated such that for each node `to` in `e[cur]` that was visited, `dep[to]` is set to `dep[cur] + 1` if `len(e[to]) == 2` or `1` if `len(e[to]) == 1`, `top` is the deepest node visited during the loop, `i` is `n + 1`, `n` is a positive integer, `bad` is `False
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n + 1`, `n` is a positive integer, `bad` is `True` if there exists any `i` from 1 to `n` where `deg[dep[i]]` is not equal to `len(e[i])`, otherwise `bad` is `False`.
    if (not bad) :
        print(center)
        exit()
    #State of the program after the if block has been executed: *`i` is `n + 1`, `n` is a positive integer, `bad` remains unchanged (either `False` if there exists any `i` from 1 to `n` where `deg[dep[i]]` is not equal to `len(e[i])`, otherwise `bad` remains `False`), and `center` is unchanged.
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `i` is `n + 1`, `n` is a positive integer, `bad` remains unchanged, `center` is unchanged, `dep` is a list of length `n + 1` where each `dep[to]` (where `to` is a node in the graph) is set to the shortest distance from `top` to `to`, `q` is an empty deque, and the loop has executed until all nodes reachable from `top` have been processed.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n + 1`, `n` is a positive integer, `bad` is `True` if `deg[dep[i]] != len(e[i])` for any `i` from 1 to `n`, otherwise `bad` is `False`, `center` is unchanged, `dep` remains unchanged, `q` remains unchanged, `deg` is updated for all valid `i` from 1 to `n` if necessary.
    if (not bad) :
        print(top)
        exit()
    #State of the program after the if block has been executed: *`i` is `n + 1`, `n` is a positive integer, `bad` is `False`, `center` remains unchanged, `dep` remains unchanged, `q` remains unchanged, `deg` remains unchanged, `top` is undefined (NameError).
    print(-1)
#Overall this is what the function does:The function `func` accepts a list of tuples representing the edges of a tree and determines if the input forms a valid tree structure. Specifically, it checks if the tree is well-formed and if there is a unique central node (or two in case of a tree with even diameter). If the tree is valid, it prints the central node; otherwise, it prints `-1`.

1. The function reads the number of vertices \(n\) and the edges of the tree.
2. It constructs an adjacency list representation of the tree.
3. It computes the shortest distance from a root node (node 1) to all other nodes using a breadth-first search (BFS).
4. It checks if all nodes are reachable from the root node.
5. If not all nodes are reachable, it prints `-1`.
6. It identifies the farthest node from the root node and performs another BFS from this node to find the central node.
7. It ensures the central node has a degree of 2 (for single central node) or 1 (for two central nodes in case of even diameter).
8. If the tree passes all checks, it prints the central node; otherwise, it prints `-1`.

Potential edge cases and missing functionality:
- The function assumes the input always forms a valid tree structure (i.e., no cycles and exactly \(n-1\) edges).
- There is no explicit check for the tree being acyclic, though the BFS traversal implicitly verifies this.
- The function does not handle the case where the tree has multiple central nodes due to an even diameter explicitly, although the code attempts to identify the farthest node and then checks its neighbors.
- The function does not validate the input types or ranges explicitly, assuming the input is correctly formatted.

In summary, the function aims to validate a tree structure and find its central node but may not cover all edge cases fully, particularly those involving trees with even diameters.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
