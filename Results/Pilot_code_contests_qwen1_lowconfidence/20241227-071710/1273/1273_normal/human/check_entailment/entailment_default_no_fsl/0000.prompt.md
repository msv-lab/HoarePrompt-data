
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure that the output hints make sense.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You have given tree consist of n vertices. Select a vertex as root vertex that satisfies the condition below.

  * For all vertices v_{1} and v_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then degree(v_{1}) = degree(v_{2}), where degree means the number of vertices connected to that vertex, and distance means the number of edges between two vertices. 



Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^{5}) — the number of vertices.

Each of the next n-1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i} < u_{i} ≤ n) — it means there is an edge exist between v_{i} and u_{i}. It is guaranteed that the graph forms tree.

Output

If there is such root vertex exists, print any of them. Otherwise, print -1.

Examples

Input


7
1 2
2 3
3 4
4 5
3 6
6 7


Output


3


Input


6
1 3
2 3
3 4
4 5
4 6


Output


-1

Note

This is the picture for the first example. 1, 5, 7 also can be a valid answer.

<image>

This is the picture for the second example. You can see that it's impossible to find such root vertex.

<image>
Program:
```
from collections import*

def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        (u, v) = map(int, raw_input().split())
        e[u].append(v)
        e[v].append(u)
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(cur)
        exit()
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(end)
        exit()
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(center)
        exit()
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(top)
        exit()
    print(-1)


```
Output hints: The function `func` accepts a list of tuples representing the edges of a tree and determines if the input forms a valid tree structure. Specifically, it checks if the tree is well-formed and if there is a unique central node (or two in case of a tree with even diameter). If the tree is valid, it prints the central node; otherwise, it prints `-1`.

1. The function reads the number of vertices \(n\) and the edges of the tree.
2. It constructs an adjacency list representation of the tree.
3. It computes the shortest distance from a root node (node 1) to all other nodes using a breadth-first search (BFS).
4. It checks if all nodes are reachable from the root node.
5. If not all nodes are reachable, it prints `-1`.
6. It identifies the farthest node from the root node and performs another BFS from this node to find the central node.
7. It ensures the central node has a degree of 2 (for single central node) or 1 (for two central nodes in case of even diameter).
8. If the tree passes all checks, it prints the central node; otherwise, it prints `-1`.

Potential edge cases and missing functionality:
- The function assumes the input always forms a valid tree structure (i.e., no cycles and exactly \(n-1\) edges).
- There is no explicit check for the tree being acyclic, though the BFS traversal implicitly verifies this.
- The function does not handle the case where the tree has multiple central nodes due to an even diameter explicitly, although the code attempts to identify the farthest node and then checks its neighbors.
- The function does not validate the input types or ranges explicitly, assuming the input is correctly formatted.

In summary, the function aims to validate a tree structure and find its central node but may not cover all edge cases fully, particularly those involving trees with even diameters.

Does the code do what the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.
