Output State: **`q` is a deque containing all nodes with the shortest unexplored distances from node 1 (excluding the node previously in `end`), `end` is the node that was removed from `q` during the last iteration, `cur` is 0, `dep` is a list of length \( n + 1 \) where each `dep[i]` represents the shortest distance from node 1 to node `i`, `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree.**

Explanation:
- The loop continues to process nodes in `q` until `q` becomes empty. Each time a node `end` is processed, all its unexplored neighbors `to` are checked.
- If `dep[to]` was `-1`, it means that `to` was not yet explored, and it is updated with `dep[end] + 1` and its predecessor is set to `end`. The neighbor `to` is then appended to `q`.
- After processing all nodes, `q` will contain all nodes with the shortest unexplored distances from node 1 (excluding the node previously in `end`).
- The loop stops when `q` becomes empty, meaning all nodes reachable from node 1 have been explored and their shortest distances and predecessors have been determined.

If the loop does not execute, the values of the variables remain as follows:
- `q` remains a deque with its leftmost element being the node with the shortest unexplored distance from node 1 (excluding the node previously in `end`).
- `end` is the node that was removed from `q` during the last iteration, if any.
- `cur` is 0.
- `dep` is a list of length \( n + 1 \) where each `dep[i]` represents the shortest distance from node 1 to node `i`.
- `pred` is a list of length \( n + 1 \) where each `pred[i]` is the predecessor of node `i` in the shortest path tree.