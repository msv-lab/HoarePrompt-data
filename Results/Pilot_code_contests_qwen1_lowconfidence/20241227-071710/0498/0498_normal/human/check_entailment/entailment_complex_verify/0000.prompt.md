
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Wilbur is playing with a set of n points on the coordinate plane. All points have non-negative integer coordinates. Moreover, if some point (x, y) belongs to the set, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y also belong to this set.

Now Wilbur wants to number the points in the set he has, that is assign them distinct integer numbers from 1 to n. In order to make the numbering aesthetically pleasing, Wilbur imposes the condition that if some point (x, y) gets number i, then all (x',y') from the set, such that x' ≥ x and y' ≥ y must be assigned a number not less than i. For example, for a set of four points (0, 0), (0, 1), (1, 0) and (1, 1), there are two aesthetically pleasing numberings. One is 1, 2, 3, 4 and another one is 1, 3, 2, 4.

Wilbur's friend comes along and challenges Wilbur. For any point he defines it's special value as s(x, y) = y - x. Now he gives Wilbur some w1, w2,..., wn, and asks him to find an aesthetically pleasing numbering of the points in the set, such that the point that gets number i has it's special value equal to wi, that is s(xi, yi) = yi - xi = wi.

Now Wilbur asks you to help him with this challenge.

Input

The first line of the input consists of a single integer n (1 ≤ n ≤ 100 000) — the number of points in the set Wilbur is playing with.

Next follow n lines with points descriptions. Each line contains two integers x and y (0 ≤ x, y ≤ 100 000), that give one point in Wilbur's set. It's guaranteed that all points are distinct. Also, it is guaranteed that if some point (x, y) is present in the input, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y, are also present in the input.

The last line of the input contains n integers. The i-th of them is wi ( - 100 000 ≤ wi ≤ 100 000) — the required special value of the point that gets number i in any aesthetically pleasing numbering.

Output

If there exists an aesthetically pleasant numbering of points in the set, such that s(xi, yi) = yi - xi = wi, then print "YES" on the first line of the output. Otherwise, print "NO".

If a solution exists, proceed output with n lines. On the i-th of these lines print the point of the set that gets number i. If there are multiple solutions, print any of them.

Examples

Input

5
2 0
0 0
1 0
1 1
0 1
0 -1 -2 1 0


Output

YES
0 0
1 0
2 0
0 1
1 1


Input

3
1 0
0 0
2 0
0 1 2


Output

NO

Note

In the first sample, point (2, 0) gets number 3, point (0, 0) gets number one, point (1, 0) gets number 2, point (1, 1) gets number 5 and point (0, 1) gets number 4. One can easily check that this numbering is aesthetically pleasing and yi - xi = wi.

In the second sample, the special values of the points in the set are 0,  - 1, and  - 2 while the sequence that the friend gives to Wilbur is 0, 1, 2. Therefore, the answer does not exist.
Program:
```
from sys import stdin
from collections import *

rints = lambda : [int(x) for x in stdin.readline().split()]
(n, labels) = (int(input()), [[0 for _ in range(1000)] for _ in range(1000)])
(a, w) = ([rints() for _ in range(n)], rints())
func_1()

def func_1():
    (mem, mem2, out) = (Counter(w), defaultdict(list), [])
    for (x, y) in a:
        mem2[y - x].append([x, y])
    for (i, j) in mem.items():
        if len(mem2[i]) != j:
            print('NO')
            exit()
        mem2[i].sort(reverse=True)
    for i in range(n):
        (x, y) = mem2[w[i]][-1]
        labels[x][y] = i + 1
        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:
            print('NO')
            exit()
        out.append(' '.join(map(str, mem2[w[i]].pop())))
    print('YES')
    print('\n'.join(out))


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not handle the case where the special values (wi) do not form a valid aesthetically pleasing numbering sequence. Specifically, the program assumes that for each wi, there exists a point (x, y) such that \(y - x = wi\). However, the program does not verify if such a point exists or if the points can be numbered in a way that satisfies the conditions.

For instance, consider the following input:

```
5
1 0
0 0
2 0
0 1
1 1
1 0 -1 1 0
```

The program will attempt to assign the points based on the wi values, but it does not check if the wi values are consistent with the points in the set. The point (0, 0) has \(w_1 = 1\), (1, 0) has \(w_2 = 0\), (2, 0) has \(w_3 = -1\), (0, 1) has \(w_4 = 1\), and (1, 1) has \(w_5 = 0\).

The program will try to assign the points as follows:
- Point (1, 0) with \(w_2 = 0\) should be assigned the number 2.
- Point (0, 0) with \(w_1 = 1\) should be assigned the number 1.
- Point (2, 0) with \(w_3 = -1\) should be assigned the number 3.
- Point (0, 1) with \(w_4 = 1\) should be assigned the number 4.
- Point (1, 1) with \(w_5 = 0\) should be assigned the number 5.

However, the program does not check if these assignments are possible without violating the aesthetically pleasing condition. For example, if we assign (0, 0) to 1 and (1, 0) to 2, then (1, 1) cannot be assigned 5 because it violates the condition that all points (x', y') such that \(x' \geq 1\) and \(y' \geq 1\) must be assigned a number not less than 5.

Thus, the program fails to handle such edge cases and does not guarantee a correct output for all valid inputs.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin
from collections import *

rints = lambda : [int(x) for x in stdin.readline().split()]
(n, labels) = (int(input()), [[0 for _ in range(1000)] for _ in range(1000)])
(a, w) = ([rints() for _ in range(n)], rints())
func_1()

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100 000. The following n lines each contain two integers x and y such that 0 ≤ x, y ≤ 100 000, representing the coordinates of a point in the set. It is guaranteed that all points are distinct and if some point (x, y) is present, then all points (x', y'), where 0 ≤ x' ≤ x and 0 ≤ y' ≤ y, are also present. The next line contains n integers wi such that -100 000 ≤ wi ≤ 100 000, representing the required special values for the points.
def func_1():
    mem, mem2, out = Counter(w), defaultdict(list), []
    for (x, y) in a:
        mem2[y - x].append([x, y])
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 100,000\), `mem` is a Counter object of the list `w`, `mem2` is a defaultdict of lists where each key \(y - x\) contains a list of pairs \([x, y]\) corresponding to tuples \((x, y)\) from `a`, `out` is an empty list, `a` must be an iterable containing tuples \((x, y)\) for the loop to execute at least once.
    for (i, j) in mem.items():
        if len(mem2[i]) != j:
            print('NO')
            exit()
        
        mem2[i].sort(reverse=True)
        
    #State of the program after the  for loop has been executed: `out` is an empty list, `mem` is a Counter object of the list `w`, `mem2` is a defaultdict of lists where each key \(y - x\) contains a list of pairs \([x, y]\) corresponding to tuples \((x, y)\) from `a`, and for every key \(i\) in `mem2`, the length of `mem2[i]` is equal to the value of `mem[i]` and `mem2[i]` is sorted in reverse order.
    for i in range(n):
        x, y = mem2[w[i]][-1]
        
        labels[x][y] = i + 1
        
        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:
            print('NO')
            exit()
        
        out.append(' '.join(map(str, mem2[w[i]].pop())))
        
    #State of the program after the  for loop has been executed: `out` is a list containing `n` strings, each representing a pair \([x, y]\) that was popped from `mem2[w[i]]`, `mem2[w[i]]` is empty for all `i`, `labels` is updated such that for each pair \([x, y]\) that was popped, `labels[x][y]` is the index of the pair in the sequence, and `n` is the length of the list `w`.
    print('YES')
    print('\n'.join(out))
#Overall this is what the function does:The function processes a set of points defined by their coordinates \((x, y)\) and a list of integers \(w\). It verifies certain conditions on these points and assigns unique labels to them based on specific criteria. If all conditions are met, it prints 'YES' followed by the labels in a formatted output. If any condition fails, it prints 'NO' and exits immediately. Specifically, it checks that the number of points associated with each value in \(w\) matches the count in \(mem\), sorts the points for each slope \(y - x\) in reverse order, and ensures that the labeling process does not violate certain constraints.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
