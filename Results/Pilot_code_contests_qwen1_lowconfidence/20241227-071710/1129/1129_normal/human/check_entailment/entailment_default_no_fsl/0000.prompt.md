
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Mike is trying rock climbing but he is awful at it. 

There are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai < ai + 1 for all i from 1 to n - 1; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty <image>. In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1, 2, 3, 4, 5) and remove the third element from it, we obtain the sequence (1, 2, 4, 5)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

Input

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.

The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).

Output

Print a single number — the minimum difficulty of the track after removing a single hold.

Examples

Input

3
1 4 6


Output

5


Input

5
1 2 3 4 5


Output

2


Input

5
1 2 3 7 8


Output

4

Note

In the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.

In the second test after removing every hold the difficulty equals 2.

In the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.
Functions with output description for each function:
import fileinput

if __name__ == '__main__':
    from sys import argv
    if argv.pop() == 'test':
        func_4()
    else:
        func_3(list(fileinput.input()), verbose=True)

Function number 1 :
 Code:
 '''
def func_1(s):
    return [int(x) for x in s.split()]
''' 

 Output hints for function1:  The function `func_1` accepts a single parameter `s`, which is a string containing `n` space-separated integers `ai`, where `3 ≤ n ≤ 100` and `1 ≤ ai ≤ 1000`, and the sequence `ai` is guaranteed to be strictly increasing. The function splits the string `s` into individual integer strings, converts them to integers, and returns a list of these integers. The function ensures that the input string `s` meets the specified conditions and performs no additional operations beyond converting the string to a list of integers. Potential edge cases include an empty string or a string that does not meet the specified format, although the code itself handles these cases by attempting to split and convert the string, which may raise a `ValueError` if the format is incorrect.
Function number 2 :
 Code:
 '''
def func_2(args):
    a_s = tuple(func_1(args[1]))
    return a_s
''' 

 Output hints for function2:  The function `func_2` accepts a single parameter `args`, which is expected to be a list where `args[1]` is a list of integers representing the heights of the holds, sorted in increasing order. The function calls another function `func_1` with `args[1]` as its argument, converts the result into a tuple, and returns this tuple. The returned tuple contains the same elements as `args[1]`, ensuring they are also sorted in increasing order. This means the function guarantees to return a sorted tuple of integers representing the heights of the holds. Potential edge cases include scenarios where `args` does not contain exactly two elements, or `args[1]` is an empty list. In such cases, the function would still attempt to access `args[1]`, leading to potential errors. However, assuming `args` is correctly formatted, the function will always return a sorted tuple of integers.
Function number 3 :
 Code:
 '''
def func_3(args, verbose=False):
    a_s = func_2(args)
    max_1 = -float('inf')
    min_2 = float('inf')
    for k in xrange(len(a_s) - 1):
        max_1 = max(max_1, a_s[k + 1] - a_s[k])
    for k in xrange(len(a_s) - 2):
        min_2 = min(min_2, a_s[k + 2] - a_s[k])
    return max(max_1, min_2)
''' 

 Output hints for function3:  The function `func_3` accepts a list `args` of n integers (where n is such that 3 ≤ n ≤ 100) and a boolean `verbose`. It first calls another function `func_2` to process the input list and store the result in `a_s`. Then, it iterates over the list to find the maximum difference between any two consecutive elements (`max_1`). After that, it iterates over the list again to find the minimum difference between every third element starting from the third element to the last element (`min_2`). Finally, it returns the higher value between `max_1` and `min_2`.

Potential edge cases and missing functionality:
1. If the input list `args` has fewer than 3 elements, the function will still attempt to process it. However, since `a_s` is derived from `args`, the length checks in the loops ensure that the indices used for `a_s` are valid. Therefore, no additional handling is needed for lists shorter than 3 elements.
2. The function assumes that `a_s` is a valid list of integers and that the input `args` can be processed by `func_2`. If `func_2` fails or returns an invalid list, the function's behavior is undefined. No error checking is performed on the output of `func_2`.

The function's purpose is to find the highest of either the maximum difference between any two consecutive elements or the minimum difference between every third element in the list. After executing the function, the program's state will have determined these two values and returned the higher one.
Function number 4 :
 Code:
 '''
def func_4():
    assert func_1('1 2 3') == [1, 2, 3]
    assert func_3(['3', '1 4 6']) == 5
    assert func_3(['5', '1 2 3 4 5']) == 2
    assert func_3(['5', '1 2 3 7 8']) == 4
''' 

 Output hints for function4:  The function `func_4` accepts a string representing space-separated integers indicating the heights of the holds on the wall. It first converts this string into a list of integers using `func_1`. Then, it iterates through each integer in the list, temporarily removes one hold at a time, and calculates the difficulty of the track without that hold using `func_3`. Finally, it returns the minimum difficulty found among all possible removals of one hold. Potential edge cases include handling an empty string or a string with invalid input (e.g., non-integer values). If the input string is empty or contains invalid data, the function should handle these cases appropriately.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.