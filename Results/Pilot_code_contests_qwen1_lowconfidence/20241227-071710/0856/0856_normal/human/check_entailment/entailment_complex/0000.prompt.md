
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: The development of a text editor is a hard problem. You need to implement an extra module for brackets coloring in text.

Your editor consists of a line with infinite length and cursor, which points to the current character. Please note that it points to only one of the characters (and not between a pair of characters). Thus, it points to an index character. The user can move the cursor left or right one position. If the cursor is already at the first (leftmost) position, then it does not move left.

Initially, the cursor is in the first (leftmost) character.

Also, the user can write a letter or brackets (either (, or )) to the position that the cursor is currently pointing at. A new character always overwrites the old value at that position.

Your editor must check, whether the current line is the correct text. Text is correct if the brackets in them form the correct bracket sequence.

Formally, correct text (CT) must satisfy the following rules: 

  * any line without brackets is CT (the line can contain whitespaces); 
  * If the first character of the string — is (, the last — is ), and all the rest form a CT, then the whole line is a CT; 
  * two consecutively written CT is also CT. 



Examples of correct texts: hello(codeforces), round, ((i)(write))edi(tor)s, ( me). Examples of incorrect texts: hello)oops(, round), ((me).

The user uses special commands to work with your editor. Each command has its symbol, which must be written to execute this command.

The correspondence of commands and characters is as follows: 

  * L — move the cursor one character to the left (remains in place if it already points to the first character); 
  * R — move the cursor one character to the right; 
  * any lowercase Latin letter or bracket (( or )) — write the entered character to the position where the cursor is now. 



For a complete understanding, take a look at the first example and its illustrations in the note below.

You are given a string containing the characters that the user entered. For the brackets coloring module's work, after each command you need to:

  * check if the current text in the editor is a correct text; 
  * if it is, print the least number of colors that required, to color all brackets. 



If two pairs of brackets are nested (the first in the second or vice versa), then these pairs of brackets should be painted in different colors. If two pairs of brackets are not nested, then they can be painted in different or the same colors. For example, for the bracket sequence ()(())()() the least number of colors is 2, and for the bracket sequence (()(()())())(()) — is 3.

Write a program that prints the minimal number of colors after processing each command.

Input

The first line contains an integer n (1 ≤ n ≤ 10^6) — the number of commands. 

The second line contains s — a sequence of commands. The string s consists of n characters. It is guaranteed that all characters in a string are valid commands.

Output

In a single line print n integers, where the i-th number is:

  * -1 if the line received after processing the first i commands is not valid text, 
  * the minimal number of colors in the case of the correct text. 

Examples

Input


11
(RaRbR)L)L(


Output


-1 -1 -1 -1 -1 -1 1 1 -1 -1 2 

Input


11
(R)R(R)Ra)c


Output


-1 -1 1 1 -1 -1 1 1 1 -1 1 

Note

In the first example, the text in the editor will take the following form:

  1.     (  
    ^

  2.     (  
     ^

  3.     (a  
     ^

  4.     (a  
      ^

  5.     (ab  
      ^

  6.     (ab  
       ^

  7.     (ab)  
       ^

  8.     (ab)  
      ^

  9.     (a))  
      ^

  10.     (a))  
     ^

  11.     (())  
     ^
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import sys

#State of the program right berfore the function call: The input consists of two lines. The first line contains an integer n (1 ≤ n ≤ 10^6) representing the number of commands. The second line contains a string s of length n, where each character in s is a valid command (L, R, lowercase Latin letter, (, or )).
def func():
    n = int(input())
    operations = raw_input()
    ans_list = []
    operator_map = {'(': 1, ')': -1}
    left_sum = [(0) for i in xrange(n + 2)]
    right_sum = [(0) for i in xrange(n + 2)]
    left_min = [(0) for i in xrange(n + 2)]
    right_min = [(0) for i in xrange(n + 2)]
    left_max = [(0) for i in xrange(n + 2)]
    right_max = [(0) for i in xrange(n + 2)]
    cursor_pos = 1
    context = [(0) for i in xrange(n + 2)]
    for op in operations:
        if op == 'L':
            cursor_pos = max(1, cursor_pos - 1)
        elif op == 'R':
            cursor_pos += 1
        else:
            op_val = operator_map.get(op, 0)
            context[cursor_pos] = op_val
        
        left_sum[cursor_pos] = left_sum[cursor_pos - 1] + context[cursor_pos]
        
        right_sum[cursor_pos] = right_sum[cursor_pos + 1] + right_sum[cursor_pos]
        
        left_min[cursor_pos] = min(left_min[cursor_pos - 1], context[cursor_pos])
        
        right_min[cursor_pos] = min(right_min[cursor_pos + 1], context[cursor_pos])
        
        left_max[cursor_pos] = max(left_max[cursor_pos - 1], context[cursor_pos])
        
        right_max[cursor_pos] = max(right_max[cursor_pos + 1], context[cursor_pos])
        
        ans = -1
        
        if left_sum[cursor_pos] + right_sum[cursor_pos + 1] == 0 and left_min[
            cursor_pos] >= 0 and right_min[cursor_pos] >= 0:
            ans = max(left_max[cursor_pos], right_max[cursor_pos])
        
        ans_list.append(ans)
        
    #State of the program after the  for loop has been executed: `ans` is the maximum value found based on the conditions specified in the loop, `ans_list` is a list containing all the values of `ans` for each iteration, `n` is an integer input by the user within the range 1 to \(10^6\), `operations` is a non-empty string containing only the characters '(', ')', `s` has not been read yet, `operator_map` is a dictionary with keys '(', ')' and their corresponding values, `left_sum` is a list of length `n + 2` where each element is the cumulative sum of the elements up to that position in the `context` list, `right_sum` is a list of length `n + 2` where each element is the cumulative sum of the elements starting from that position in the `context` list, `left_min` is a list of length `n + 2` where each element is the minimum value encountered from the start up to that position in the `context` list, `right_min` is a list of length `n + 2` where each element is the minimum value encountered from that position to the end in the `context` list, `right_max` is a list of length `n + 2` where each element is the maximum value encountered from that position to the end in the `context` list, `cursor_pos` is the current position in the `context` list, `context` is a list of length `n + 2` where each element represents the value of the corresponding operation in the `operations` string.
    print(' '.join(map(str, ans_list)))
#Overall this is what the function does:The function processes a series of commands represented as a string `s`. Each command can be one of the following: 'L' (move the cursor left), 'R' (move the cursor right), or a lowercase Latin letter which is stored in the `context` list. During processing, it maintains several lists (`left_sum`, `right_sum`, `left_min`, `right_min`, `left_max`, `right_max`) to track the cumulative sums, minimum, and maximum values of the `context` list up to and from the current cursor position. It iterates through the commands and updates these lists accordingly. After processing all commands, it determines the maximum value among certain conditions and appends it to `ans_list`. Finally, it prints the elements of `ans_list` separated by spaces. The function handles edge cases such as invalid commands and ensures the cursor position stays within valid bounds (1 to `n`). If no valid condition is met, it appends -1 to `ans_list`.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
