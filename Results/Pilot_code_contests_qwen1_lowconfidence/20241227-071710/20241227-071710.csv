Task ID,Dataset,model_created,model_run,description,Code,Test Result,Correctness,Post,original correctness,naive correctness,annotated correctness,annotated correctness simple,naive no fsl correctness,Correctness no fsl,simple verify,complex verify,default verify,simple verify no fsl,complex verify no fsl,default verify no fsl,data file
0004,code_contests,human,qwen2.5-7b-instruct,"An array of integers p_{1},p_{2}, …,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].

There is a hidden permutation of length n.

For each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.

Your task is to restore the permutation.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the size of the permutation.

The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/(2)).

It is guaranteed that the array s corresponds to a valid permutation of length n.

Output

Print n integers p_{1}, p_{2}, …, p_{n} — the elements of the restored permutation. We can show that the answer is always unique.

Examples

Input


3
0 0 0


Output


3 2 1


Input


2
0 1


Output


1 2


Input


5
0 1 1 1 10


Output


1 4 3 2 5

Note

In the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.

In the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.

In the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.","from sys import stdin, stdout
from collections import Counter, defaultdict
from itertools import permutations, combinations
raw_input = stdin.readline
pr = stdout.write
mod=10**9+7

def ni():
    return int(raw_input())


def li():
    return map(int,raw_input().split())


def pn(n):
    stdout.write(str(n)+'\n')


def pa(arr):
    pr(' '.join(map(str,arr))+'\n')

# fast read function for total integer input

def inp():
    # this function returns whole input of
    # space/line seperated integers
    # Use Ctrl+D to flush stdin.
    return map(int,stdin.read().split())

range = xrange # not for python 3.0+

#main code

n=ni()
BITTree=[0]*(n+1)
def gs(i): 
    s = 0
    i = i+1
    while i > 0:  
        s += BITTree[i] 
        i -= i & (-i) 
    return s 
def ub(i ,v): 
    i += 1
    while i <= n: 
        BITTree[i] += v 
        i += i & (-i) 
def fun(x):
    ret=0
    sm=0
    for i in range(21,-1,-1):
        pw=1<<i
        if ret+pw<=n and sm+BITTree[ret+pw]<=x:
            ret+=pw
            sm+=BITTree[ret]
    return ret
l=li()
for i in range(n):
    ub(i,i)
ans=[0]*n
for i in range(n-1,-1,-1):
    ans[i]=fun(l[i])
    ub(ans[i],-ans[i])
pa(ans)

    
",,False,post,True,False,False,False,False,False,False,False,False,True,False,False,code_contests_first1000_under09.json
0005,code_contests,human,qwen2.5-7b-instruct,"There are n points on a coordinate axis OX. The i-th point is located at the integer point x_i and has a speed v_i. It is guaranteed that no two points occupy the same coordinate. All n points move with the constant speed, the coordinate of the i-th point at the moment t (t can be non-integer) is calculated as x_i + t ⋅ v_i.

Consider two points i and j. Let d(i, j) be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points i and j coincide at some moment, the value d(i, j) will be 0.

Your task is to calculate the value ∑_{1 ≤ i < j ≤ n} d(i, j) (the sum of minimum distances over all pairs of points).

Input

The first line of the input contains one integer n (2 ≤ n ≤ 2 ⋅ 10^5) — the number of points.

The second line of the input contains n integers x_1, x_2, ..., x_n (1 ≤ x_i ≤ 10^8), where x_i is the initial coordinate of the i-th point. It is guaranteed that all x_i are distinct.

The third line of the input contains n integers v_1, v_2, ..., v_n (-10^8 ≤ v_i ≤ 10^8), where v_i is the speed of the i-th point.

Output

Print one integer — the value ∑_{1 ≤ i < j ≤ n} d(i, j) (the sum of minimum distances over all pairs of points).

Examples

Input


3
1 3 2
-100 2 3


Output


3


Input


5
2 1 4 3 5
2 2 2 3 4


Output


19


Input


2
2 1
-3 0


Output


0","from sys import stdin
from collections import *


def fast2():
    import os, sys, atexit
    from cStringIO import StringIO as BytesIO
    # range = xrange
    sys.stdout = BytesIO()
    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
    return BytesIO(os.read(0, os.fstat(0).st_size)).readline


class order_tree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [[0, 0] for _ in range(self.n * 2)]
        self.order = defaultdict(int, {arr[i]: i for i in range(self.n)})

    # get interval[l,r)
    def query(self, l):
        res, coun = 0, 0
        l = self.order[l] + self.n
        r = self.n * 2

        while l < r:
            if l & 1:
                res += self.tree[l][0]
                coun += self.tree[l][1]
                l += 1

            if r & 1:
                r -= 1
                res += self.tree[r][0]
                coun += self.tree[r][1]

            l >>= 1
            r >>= 1

        return res, coun

    def update(self, ix, val):
        ix = self.n + self.order[ix]

        # set new value
        self.tree[ix][0] += val
        self.tree[ix][1] += 1

        # move up
        while ix > 1:
            self.tree[ix >> 1][0] = self.tree[ix][0] + self.tree[ix ^ 1][0]
            self.tree[ix >> 1][1] = self.tree[ix][1] + self.tree[ix ^ 1][1]
            ix >>= 1


input = fast2()
rints = lambda: [int(x) for x in input().split()]
n, a = int(input()), sorted(map(lambda x, y: [x, y], rints(), rints()))
dis = sorted(set([x[1] for x in a]))
tree, ans = order_tree(dis), 0

for i in range(n - 1, -1, -1):
    su, coun = tree.query(a[i][1])
    ans += su - coun * a[i][0]
    tree.update(a[i][1], a[i][0])

print(ans)
",,False,post,True,False,False,False,False,False,False,False,False,False,False,False,code_contests_first1000_under09.json
0033,code_contests,human,qwen2.5-7b-instruct,"Takahashi is participating in a programming contest called AXC002, and he has just submitted his code to Problem A.

The problem has N test cases.

For each test case i (1\leq i \leq N), you are given a string S_i representing the verdict for that test case. Find the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively.

See the Output section for the output format.

Constraints

* 1 \leq N \leq 10^5
* S_i is `AC`, `WA`, `TLE`, or `RE`.

Input

Input is given from Standard Input in the following format:


N
S_1
\vdots
S_N


Output

Let C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively. Print the following:


AC x C_0
WA x C_1
TLE x C_2
RE x C_3

Output

Let C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively. Print the following:


AC x C_0
WA x C_1
TLE x C_2
RE x C_3

Examples

Input

6
AC
TLE
AC
AC
WA
TLE


Output

AC x 3
WA x 1
TLE x 2
RE x 0


Input

10
AC
AC
AC
AC
AC
AC
AC
AC
AC
AC


Output

AC x 10
WA x 0
TLE x 0
RE x 0","#!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


def main():
    n = int(input())
    s = [input() for _ in range(n)]

    ac = 0
    wa = 0
    tle = 0
    re = 0

    for i in s:
        if i == ""AC"":
            ac += 1
        elif i == ""WA"":
            wa += 1
        elif i == ""TLE"":
            tle += 1
        elif i == ""RE"":
            re += 1

    print(""AC x"", ac)
    print(""WA x"", wa)
    print(""TLE x"", tle)
    print(""RE x"", re)


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()
",,True,post,True,True,False,True,True,False,True,True,True,True,True,True,code_contests_first1000_under09.json
0036,code_contests,human,qwen2.5-7b-instruct,"There is a staircase with N steps. Takahashi is now standing at the foot of the stairs, that is, on the 0-th step. He can climb up one or two steps at a time.

However, the treads of the a_1-th, a_2-th, a_3-th, \ldots, a_M-th steps are broken, so it is dangerous to set foot on those steps.

How many are there to climb up to the top step, that is, the N-th step, without setting foot on the broken steps? Find the count modulo 1\ 000\ 000\ 007.

Constraints

* 1 \leq N \leq 10^5
* 0 \leq M \leq N-1
* 1 \leq a_1 < a_2 < ... < a_M \leq N-1

Input

Input is given from Standard Input in the following format:


N M
a_1
a_2
.
.
.
a_M


Output

Print the number of ways to climb up the stairs under the condition, modulo 1\ 000\ 000\ 007.

Examples

Input

6 1
3


Output

4


Input

10 2
4
5


Output

0


Input

100 5
1
23
45
67
89


Output

608200469","n, m = map(int, raw_input().split("" ""))

dp = [0 for i in range(0, n + 1)]
dp[0] = 1

for i in range(0, m):
    a = int(raw_input())
    dp[a] = -1

for step in range(1, n + 1):
    if dp[step] < 0:
        continue

    ans = 0
    for prev in [1, 2]:
        if step - prev >= 0 and dp[step - prev] >= 0:
            ans += dp[step - prev]
    dp[step] = ans

# for i in range(0, len(dp)):
#     print(dp[i])

print(dp[n] % 1000000007)
",,True,post,True,False,True,True,False,False,False,False,True,False,False,False,code_contests_first1000_under09.json
