
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure that the output hints make sense.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There is a river of width n. The left bank of the river is cell 0 and the right bank is cell n + 1 (more formally, the river can be represented as a sequence of n + 2 cells numbered from 0 to n + 1). There are also m wooden platforms on a river, the i-th platform has length c_i (so the i-th platform takes c_i consecutive cells of the river). It is guaranteed that the sum of lengths of platforms does not exceed n.

You are standing at 0 and want to reach n+1 somehow. If you are standing at the position x, you can jump to any position in the range [x + 1; x + d]. However you don't really like the water so you can jump only to such cells that belong to some wooden platform. For example, if d=1, you can jump only to the next position (if it belongs to the wooden platform). You can assume that cells 0 and n+1 belong to wooden platforms.

You want to know if it is possible to reach n+1 from 0 if you can move any platform to the left or to the right arbitrary number of times (possibly, zero) as long as they do not intersect each other (but two platforms can touch each other). It also means that you cannot change the relative order of platforms.

Note that you should move platforms until you start jumping (in other words, you first move the platforms and then start jumping).

For example, if n=7, m=3, d=2 and c = [1, 2, 1], then one of the ways to reach 8 from 0 is follow:

<image> The first example: n=7.

Input

The first line of the input contains three integers n, m and d (1 ≤ n, m, d ≤ 1000, m ≤ n) — the width of the river, the number of platforms and the maximum distance of your jump, correspondingly.

The second line of the input contains m integers c_1, c_2, ..., c_m (1 ≤ c_i ≤ n, ∑_{i=1}^{m} c_i ≤ n), where c_i is the length of the i-th platform.

Output

If it is impossible to reach n+1 from 0, print NO in the first line. Otherwise, print YES in the first line and the array a of length n in the second line — the sequence of river cells (excluding cell 0 and cell n + 1).

If the cell i does not belong to any platform, a_i should be 0. Otherwise, it should be equal to the index of the platform (1-indexed, platforms are numbered from 1 to m in order of input) to which the cell i belongs.

Note that all a_i equal to 1 should form a contiguous subsegment of the array a of length c_1, all a_i equal to 2 should form a contiguous subsegment of the array a of length c_2, ..., all a_i equal to m should form a contiguous subsegment of the array a of length c_m. The leftmost position of 2 in a should be greater than the rightmost position of 1, the leftmost position of 3 in a should be greater than the rightmost position of 2, ..., the leftmost position of m in a should be greater than the rightmost position of m-1.

See example outputs for better understanding.

Examples

Input


7 3 2
1 2 1


Output


YES
0 1 0 2 2 0 3 


Input


10 1 11
1


Output


YES
0 0 0 0 0 0 0 0 0 1 


Input


10 1 5
2


Output


YES
0 0 0 0 1 1 0 0 0 0 

Note

Consider the first example: the answer is [0, 1, 0, 2, 2, 0, 3]. The sequence of jumps you perform is 0 → 2 → 4 → 5 → 7 → 8.

Consider the second example: it does not matter how to place the platform because you always can jump from 0 to 11.

Consider the third example: the answer is [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]. The sequence of jumps you perform is 0 → 5 → 6 → 11.
Program:
```
from sys import stdin

def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    (n, m, d) = rints()
    (c, ans) = (rints(), [0] * n)
    (pos, su) = ([], 0)
    for i in range(m - 1, -1, -1):
        pos.append(n + 1 - su - c[i])
        su += c[i]
    pos.append(0)
    pos.reverse()
    for i in range(m):
        if pos[i + 1] - pos[i] <= d:
            for j in range(pos[i + 1], pos[i + 1] + c[i]):
                ans[j - 1] = i + 1
            continue
        pos[i + 1] = min(pos[i] + d, n)
        for j in range(pos[i + 1], pos[i + 1] + c[i]):
            ans[j - 1] = i + 1
        pos[i + 1] += c[i] - 1
    if n + 1 - (pos[-1] + c[-1] - 1) > d:
        print('NO')
    else:
        print('YES')
        print(' '.join(map(str, ans)))


```
Output hints: - The function correctly handles the case where the sum of all elements in `c` is less than or equal to `n` and ensures that the distance between consecutive platforms does not exceed `d`.
- However, the function does not explicitly handle cases where the sum of elements in `c` is exactly `n` and the last platform placement results in the exact boundary condition (`n + 1 - (pos[-1] + c[-1] - 1) == d`). In such a scenario, the function should still print 'YES'.
- The function also does not handle cases where `c` contains zeros. If `c` contains a zero, it means there is no platform, and the function should handle this edge case appropriately by printing 'NO'.

Does the code do what the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.
