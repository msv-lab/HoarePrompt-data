
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

I am giving you some examples to understand the task better. Then I am giving you your task.
# Example 1

Problem description: Write a python function to identify non-prime numbers.


Functions with output hints for each function:
Function nummber 1 :
 Code:
 '''
def is_divisible(number1, number2):
    if number1 % number2 == 0:
        return True
''' 

Output hints for function1:  The function accepts 2 numbers as input, if number 1 is divisible than number2 then the function returns True.
Function nummber 2 :
 Code:
 '''
def is_not_prime(n):
    if n < 2:
        return True
    for i in range(2, n):
        if is_divisible(n,i):
            return True
    return False
''' 

Output hints for function 2:  The function returns True if n is less than 2 or if n is divisible by any integer in the range [2, n). Otherwise, it returns False.

Example Answer 1:
Explanation: The program initially seems to do what the description says. Lets see if the hints also agree with the code and if they give us any reason to think the program is incorrect. The output hints seem to agree with the program code and from their contents they reenforce our reasoning that the code is correct.
The function returns True if `n` is less than 2 or if `n` is divisible by any integer in the range [2, n). Otherwise, it returns False. Since the smallest prime number is 2 and prime numbers can only be divided by 1 and themselves, this approach correctly identifies non-prime numbers as per the given specification. 

Correctness: **True**.

# Example 2

Problem description: Write a python function to count all the substrings starting and ending with same characters.
Function nummber 1 :
 Code:
```
def count_Substring_With_Equal_Ends(s):
    count = 0
    for i in range(len(s)-1):
        for j in range(i,len(s)-1):
            if s[i] == s[j+1]:
                count += 1
    return count
```

Output hints for function number 1 : The function returns the value of the variable 'count', which is equal to the number of times a character at position 'i' in the string 's' is equal to a character at position 'j + 1' for some 'j' in the range '[i, len(s) - 2]'. This implies that 'count' represents the number of consecutive occurrences of identical characters in the string 's' that may form a substring with equal ending and beginning characters, excluding the last character of the string from this comparison.

Example Answer 2:
Explanation: The function initially seems to be correct. Lets see if the output hints agree with the code and if they give us any reason to think the code is incorrec. Indeed they agree with the code and they show that the code might not always follow the program description. The function returns the value of the variable `count`, which is equal to the number of times a character at position `i` in the string `s` is equal to a character at position `j + 1` for some `j` in the range `[i, len(s) - 2]`. This does not account for substrings of length 1, so it is incorrect.

Correctness: **False**.


# Example 3

Problem description: Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.

Functions with output hints for each function:
Function nummber 1 :
 Code:
 '''
def get_list_size(list):
    return len(list)
''' 

Output hint for function1:  The function accepts a string and returns the size of that string
Function nummber 2 :
 Code:
 '''
def find_Rotations(str1):
    n = get_list_size(str1)
    for i in range(1,n+1):
        if str1[i:] + str1[:i] == str1:
            return i
''' 

Output hint for function 2: If the string is a palindrome, the function does not return a value and the variable n remains unchanged, holding the length of the string str1. If the string is not a palindrome, then the function returns an integer i such that 0 < i < n, where n is the length of the string str1, and i represents the length of the shortest non-empty rotation of str1 to return to its original state.. If no such rotation exists, then the function does not return a value.

Example Answer 3:
Explanation: The code initially does not seem to be correct. Lets see if the output hints agree with the code and reenforce our belief that the code is incorrect. The hints do seem to agree with the code and they also show that the code does not always follow the program description. If the string is a palindrome, the function does not return a value, and the variable `n` remains unchanged, holding the length of the string `str1`. This behavior is correct as the specification states that the rotation count must be greater than 0. If the string is not a palindrome, then the function returns an integer `i` such that `0 < i < n`, where `n` is the length of the string `str1`. The value `i` represents the length of the shortest non-empty rotation of str1 to return to its original state.. However, the code iterates from `1` to `n-1`, meaning it does not include `n`. This omission is problematic because it fails to check the complete rotation case, where `i` could be equal to `n`. Consequently, the function does not meet the specification as it should return the rotation count up to `n` times. Therefore, it does not meet the specification.

Correctness: **False**.

# Your task:
Problem description: While playing with geometric figures Alex has accidentally invented a concept of a n-th order rhombus in a cell grid.

A 1-st order rhombus is just a square 1 × 1 (i.e just a cell).

A n-th order rhombus for all n ≥ 2 one obtains from a n-1-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).

<image>

Alex asks you to compute the number of cells in a n-th order rhombus.

Input

The first and only input line contains integer n (1 ≤ n ≤ 100) — order of a rhombus whose numbers of cells should be computed.

Output

Print exactly one integer — the number of cells in a n-th order rhombus.

Examples

Input


1


Output


1

Input


2


Output


5

Input


3


Output


13

Note

Images of rhombus corresponding to the examples are given in the statement.
Functions with output description for each function:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

"""                         
Beautiful is better than ugly.
    Explicit is better than implicit.
Simple is better than complex.
    Complex is better than complicated.
Flat is better than nested.
    Sparse is better than dense.
                    
    * Readability counts *

 // Author : raj1307 - Raj Singh
 // Date   : 21.06.19

"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    _str = str
    str = lambda x=b'': x if type(x) is bytes else _str(x).encode()
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
(mod, MOD) = (1000000007, 998244353)
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        if self.buffer.tell():
            return self.buffer.read()
        return os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
if __name__ == '__main__':
    func_15()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function `func_1` prompts the user to input an integer within the range of 1 to 100. If the user inputs a value outside this range, the behavior is undefined as the code does not handle such cases. The function returns the integer input by the user.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` reads an integer input from the user and returns it as the order of the rhombus (n). It does not accept any parameters. The function assumes that the user will provide a valid integer input. If the user inputs a non-integer value, the function will raise a `ValueError`. No error handling is included to manage such cases.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function3:  The function `func_3()` takes no explicit parameters but expects an integer `n` (where \(1 \leq n \leq 100\)) to be provided as input through standard input. It reads a line of input, strips any leading or trailing whitespace, splits the line into individual string elements based on spaces, converts each string element to an integer, and returns a map object that contains these integers as key-value pairs. If the input does not conform to the specified range or format, the function will still attempt to convert the input to integers and create a map, potentially resulting in a map with fewer entries than the number of space-separated values provided, depending on the input validity.
Function number 4 :
 Code:
 '''
def func_4():
    return list(func_3())
''' 

 Output hints for function4:  The function `func_4` accepts no parameters and returns a list. This list is generated by calling another function `func_3()`, which is presumed to calculate the number of cells in an n-th order rhombus. Since the actual implementation of `func_3()` is not provided, the exact nature of the list returned by `func_4()` cannot be determined precisely. However, it is clear that the final state of the program after the function concludes is that it returns this list. Potential edge cases include scenarios where `func_3()` might return an empty list or a list with specific properties (e.g., length, contents). If `func_3()` does not handle certain inputs correctly, those cases would also be relevant edge cases.
Function number 5 :
 Code:
 '''
def func_5():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function5:  The function `func_5` accepts no parameters and starts the execution of the `main` function with specific settings for the recursion limit and stack size. Specifically, it sets the recursion limit to 100,000,000 and the stack size to 40,960,000 bytes. After these settings are applied, a new thread is created and the `main` function is executed within this thread. There are no potential edge cases mentioned in the annotations or code itself, and the code does exactly what the annotations suggest.
Function number 6 :
 Code:
 '''
def func_6(item):
    return item[0]
''' 

 Output hints for function6:  The function `func_6` accepts a single parameter `item`, which is expected to be a tuple or list containing at least one element. The first element of `item` is an integer representing the order of the rhombus, and it must be within the range of 1 to 100. The function returns this integer. If `item` does not meet these conditions, the function will still execute but may result in incorrect behavior or errors due to the lack of validation checks in the provided code. The postcondition of the function is that it returns the first element of `item`, ensuring it is an integer between 1 and 100. However, the function does not validate the type and value constraints of `item`, which could lead to undefined behavior if the input does not conform to the specified requirements.
Function number 7 :
 Code:
 '''
def func_7(l):
    return sorted(l, key=getKey)
''' 

 Output hints for function7:  The function `func_7` accepts a parameter `l`, which is a list of integers. It returns a new list of integers from `l` sorted based on the values returned by the `getKey` function for each element. There are no edge cases mentioned in the annotations or the code that need special handling, and the code accurately reflects the annotations.
Function number 8 :
 Code:
 '''
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function8:  The function `func_8` accepts three parameters: `n`, `m`, and `num`. It returns a list containing `n` sublists, each of which contains `m` elements, all set to `num`. There are no constraints on `n` and `m` other than them being positive integers, and `num` can be any integer. The function creates a nested list where each sublist has exactly `m` elements, and all elements within each sublist are equal to `num`. This functionality covers all potential cases where `n`, `m`, and `num` are valid integers.
Function number 9 :
 Code:
 '''
def func_9(x):
    return x and (not x & x - 1)
''' 

 Output hints for function9:  The function `func_9` accepts a positive integer `x` such that \(1 \leq x \leq 100\) and returns `True` if `x` is a power of 2, otherwise it returns `False`. The function uses a bitwise operation to determine if `x` is a power of 2. Specifically, it checks if `x` and `x - 1` have no bits in common (i.e., their bitwise AND is zero), which is true only if `x` is a power of 2. This method covers all valid inputs within the specified range and correctly identifies powers of 2, including the edge case where `x` is 1 (which is a power of 2). There are no missing functionalities or edge cases in the provided code.
Function number 10 :
 Code:
 '''
def func_10(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function10:  The function `func_10` accepts an integer `n` where \(1 \leq n \leq 100\) and returns a binary string representation of `n` without the '0b' prefix. The function correctly converts the integer to its binary form using Python's built-in `bin()` function and then removes the '0b' prefix. There are no potential edge cases or missing functionalities since the provided code accurately implements the described behavior.
Function number 11 :
 Code:
 '''
def func_11(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function11:  The function `func_11` accepts an integer `n` within the range 1 to 100 and returns a list of its digits. Given that `n` is an integer between 1 and 100, the function converts `n` into a string, iterates over each character in the string representation of `n`, converts each character back to an integer, and collects these integers into a list. This list is then returned. Since `n` is guaranteed to be within the specified range, no special handling for edge cases such as leading zeros or negative numbers is necessary. The final state of the program after the function concludes is that the program has a list of integers representing the digits of `n`.
Function number 12 :
 Code:
 '''
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res
''' 

 Output hints for function12:  The function `func_12` accepts three parameters: `x`, `y`, and `p`, where `x` and `y` are integers and `p` is a positive integer. It calculates the modular exponentiation of `x^y` under modulo `p`, meaning it computes `(x^y) mod p`. 

The function uses a loop to perform the modular exponentiation efficiently using the method of exponentiation by squaring. Within each iteration of the loop:
- If the current value of `y` is odd, it multiplies `res` by `x` modulo `p`.
- It then squares `x` and reduces it modulo `p`.
- It shifts `y` right by one bit (equivalent to integer division by 2).

After the loop, the function returns `res`, which is the result of the modular exponentiation calculation.

Potential edge cases and missing functionality:
- The annotation mentions `p1` in the line `x = x * x % p1`, but `p1` is not defined in the function. This should be `p` instead.
- The function does not handle the case where `y` is negative. While the provided annotations suggest `y > 0`, in practice, `y` could be negative, and the function should handle such cases appropriately, possibly returning an error or handling it based on the requirements.
Function number 13 :
 Code:
 '''
def func_13(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function13:  The function `func_13` accepts two non-negative integer parameters `x` and `y`, where not both are zero. It computes the greatest common divisor (GCD) of `x` and `y` using the Euclidean algorithm. The function then returns the GCD as the first value (`x`) and `y`, which is set to 0 after the computation, as the second value. This function handles the case where `x` and `y` are both zero by ensuring the loop condition `while y:` is not met initially due to the given precondition that `x` and `y` are not both zero. If either `x` or `y` is zero initially, the function still correctly computes the GCD for the non-zero value.
Function number 14 :
 Code:
 '''
def func_14(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function14:  The function `func_14` accepts an integer `n` such that 1 ≤ n ≤ 100. It returns `False` for values of `n` that do not meet specific criteria and `True` for the value `n = 7`. Specifically:
- If `n` is less than or equal to 1, the function returns `False`.
- If `n` is 2, 3, 4, 5, or 8, the function returns `False`.
- If `n` is 7, the function returns `True`.
- For other values of `n` between 1 and 100 (excluding 7), the function returns `False`.

The function checks if `n` is divisible by 2 or 3, and then uses a loop to check divisibility by numbers of the form `6k ± 1` up to the square root of `n`. If `n` passes all these checks, it returns `True`, which only happens when `n` is 7.
Function number 15 :
 Code:
 '''
def func_15():
    n = func_1()
    if n == 1:
        func_16(1)
    else:
        r = 1
        ans = 1
        for i in range(2, n + 1):
            m = r * r % ans
            r += 2
            ans += 4 + m
        func_16(ans)
''' 

 Output hints for function15:  The function `func_15` accepts no parameters and does not return any value directly. Instead, it indirectly returns the result of calling `func_16` with either the integer 1 or a computed value of `ans`. The computed value of `ans` is derived through a series of operations involving `r` and `m` within a loop for `n` values greater than 1. Specifically, the function first calls `func_1()` to get an integer `n`, then if `n` is 1, it calls `func_16(1)`. Otherwise, it initializes `r` and `ans` to 1, and iterates through a loop from 2 to `n`, updating `r` and `ans` based on the current values of `r` and `m` (where `m` is `r
Function number 16 :
 Code:
 '''
def func_16(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function16:  The function `func_16()` does not accept any parameters and its primary action is to print a sequence of items (represented by `args`) to a specified output stream (`file`). It writes each item in `args` to the stream, separated by a specified separator (`sep`), and appends a specified end character (`end`). If the `flush` parameter is set to `True`, it also flushes the output stream. However, since the function does not utilize any input arguments provided in the problem description, it essentially behaves as a placeholder and does not perform any meaningful computation related to the number of cells in an n-th order rhombus. Any input arguments provided are ignored.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.