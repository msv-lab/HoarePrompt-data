
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either "AB" or "BB". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.

For example, Zookeeper can use two such operations: AABABBA → AABBA → AAA.

Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 20000) — the number of test cases. The description of the test cases follows.

Each of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.

It is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print a single integer: the length of the shortest string that Zookeeper can make.

Example

Input


3
AAA
BABA
AABBBABBBB


Output


3
2
0

Note

For the first test case, you can't make any moves, so the answer is 3.

For the second test case, one optimal sequence of moves is BABA → BA. So, the answer is 2.

For the third test case, one optimal sequence of moves is AABBBABBBB → AABBBABB → AABBBB → ABBB → AB → (empty string). So, the answer is 0.
Program:
```
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return input()

#Function 3:
def func_3():
    return map(int, input().strip().split(' '))

#Function 4:
def func_4():
    return map(str, input().strip().split(' '))

#Function 5:
def func_5():
    return list(func_3())

#Function 6:
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
def func_7(item):
    return item[1]

#Function 8:
def func_8(l):
    return sorted(l, key=getKey, reverse=True)

#Function 9:
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 10:
def func_10(x):
    return x and (not x & x - 1)

#Function 11:
def func_11(n):
    return bin(n).replace('0b', '')

#Function 12:
def func_12(n):
    return [int(i) for i in str(n)]

#Function 13:
def func_13(x, y):
    if x % y == 0:
        return x // y
    else:
        return x // y + 1

#Function 14:
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res

#Function 15:
def func_15(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 16:
def func_16(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True

#Function 17:
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
def func_18():
    for _ in range(int(input())):
        s = raw_input()

        func_19(solve(s))

#Function 19:
def solve(s):
    if s.find('AB') == -1 and s.find('BB') == -1:
        return len(s)
    while s.find('AB') != -1:
        s = s.replace('AB', '')
    while s.find('BB') != -1:
        s = s.replace('BB', '')
    return len(s)

#Function 20:
def func_19(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly handle the given problem description. Specifically, the function `solve(s)` does not correctly handle cases where the string `s` contains both "AB" and "BB" substrings. The function only removes "AB" and "BB" substrings sequentially without considering the optimal order of removals.

For example, consider the input string "ABBAB":
- The program would remove "AB" first, resulting in "BBAB".
- Then it would remove another "BB", resulting in "AB".
- Finally, it would remove "AB", resulting in an empty string.

However, the optimal solution would be:
- Remove "BB" first, resulting in "ABAB".
- Then remove "AB", resulting in "AB".
- Finally, remove "AB", resulting in an empty string.

Thus, the program does not always produce the shortest possible string length. For instance, for the input "ABBAB", the program outputs 2, but the correct output should be 0.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

#Function 1:
#State of the program right berfore the function call: None of the variables in the function `func_1()` are described in the provided code snippet. The function simply reads an integer input and returns it, but there are no input parameters defined in the function signature.
def func_1():
    return int(input())
    #The program returns an integer input provided by the user

#Function 2:
#State of the program right berfore the function call: The function does not take any parameters and it is expected to be part of a larger solution where the input is taken from standard input. The input consists of multiple test cases, each described by the problem statement. Each test case starts with an integer t (1 ≤ t ≤ 20000) indicating the number of test cases, followed by t strings s, each of which is a non-empty string consisting of 'A' and 'B' characters.
def func_2():
    return input()
    #The program returns the input string `s` from the test case, where each string `s` consists of 'A' and 'B' characters

#Function 3:
#State of the program right berfore the function call: None of the variables in the function signature are present in the provided code snippet. The function `func_3` does not take any parameters and it reads input from the standard input, which is not described in the problem statement or the function signature.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object that converts each input string from standard input into an integer

#Function 4:
#State of the program right berfore the function call: None of the variables in the function `func_4()` are defined or used within the provided code snippet. The function reads input from the standard input, splits it by spaces, and maps each element to a string, returning an iterator over the resulting strings. However, the problem description and the intended use of the function do not align with the function's implementation. The function does not take any parameters and does not relate directly to the bomb game described in the problem.
def func_4():
    return map(str, input().strip().split(' '))
    #An iterator over strings obtained by splitting the input string (read from standard input) by spaces and converting each element to a string

#Function 5:
#State of the program right berfore the function call: The function `func_3()` returns an iterable object, and it is not directly used in `func_5()`, implying that `func_5()` processes the output of `func_3()` by converting it into a list. However, there are no direct parameters or dependencies on variables within the function signature provided for `func_5()`.
def func_5():
    return list(func_3())
    #The program returns a list generated from the iterable object returned by func_3()

#Function 6:
#State of the program right berfore the function call: The function `func_6` does not take any parameters. It sets the recursion limit to 1,000,000 and the stack size to 1,024,000 bytes before starting a new thread named `thread` that targets the execution of the `main` function.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple or list with exactly two elements, where the second element is a string consisting of letters 'A' and 'B'.
def func_7(item):
    return item[1]
    #The program returns a string consisting of letters 'A' and 'B'

#Function 8:
#State of the program right berfore the function call: l is a list of strings, where each string consists of characters 'A' and 'B' only.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a list of strings from 'l', sorted in descending order based on a custom key 'getKey', where 'getKey' is not defined in the provided code snippet

#Function 9:
#State of the program right berfore the function call: n and m are non-negative integers representing the dimensions of a 2D list, and num is an integer value that will be used to initialize all elements in the 2D list.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #A 2D list of size n x m where all elements are initialized to the integer value num

#Function 10:
#State of the program right berfore the function call: x is an integer representing a binary number where the length of the binary representation corresponds to the length of the input string s in the main problem.
def func_10(x):
    return x and not x & x - 1
    #The program returns True if x is a power of 2, otherwise returns False

#Function 11:
#State of the program right berfore the function call: n is an integer greater than or equal to 0.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of integer `n`, with the '0b' prefix removed

#Function 12:
#State of the program right berfore the function call: n is a non-negative integer represented as a string.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the string representation of 'n'

#Function 13:
#State of the program right berfore the function call: x is an integer and y is a positive integer (y > 0).
def func_13(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns x divided by y, where x is an integer and is currently divisible by y, and y is a positive integer
    else :
        return x // y + 1
        #The program returns the integer division of x by y plus 1, where x is an integer not divisible by y and y is a positive integer

#Function 14:
#State of the program right berfore the function call: x is an integer representing the base, y is a non-negative integer representing the exponent, and p is a positive integer representing the modulus.
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is the result of \( x^{original \ y} \mod p \), `x` is \( x^{original \ y // 2} \mod p \), `p` is the same positive integer
    return res
    #The program returns res, which is the result of \( x^{original \ y} \mod p \)

#Function 15:
#State of the program right berfore the function call: x and y are non-negative integers where at least one of them is non-zero.
def func_15(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`; `y` is 0.
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, given that y is 0

#Function 16:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_16(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: n is an integer greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: `n` is an integer greater than 1, and `n` is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than 1 and greater than 3, and `n` is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: Output State: \( n \) is an integer greater than 3, not divisible by 2, and not divisible by 3, and \( i \) is the smallest integer such that \( i \times i > n \) and \( i \) is of the form \( 6k + 5 \)
    return True
    #The program returns True

#Function 17:
#State of the program right berfore the function call: There is no function signature provided, and the function `func_17` does not take any parameters. This function is likely responsible for setting up the input and output redirection for a series of test cases but does not contribute to solving the core problem of determining the length of the shortest string after applying the bombing operations.
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
#State of the program right berfore the function call: s is a non-empty string consisting of characters 'A' and 'B', and it represents the initial state of the string that Zookeeper needs to bomb.
def func_18():
    for _ in range(int(input())):
        s = raw_input()
        
        func_19(solve(s))
        
    #State of the program after the  for loop has been executed: `s` is an integer greater than 0, `new_k` is undefined.

#Function 19:
#State of the program right berfore the function call: s is a non-empty string consisting of the characters 'A' and 'B' only.
def solve(s):
    if (s.find('AB') == -1 and s.find('BB') == -1) :
        return len(s)
        #The program returns the length of string `s`
    #State of the program after the if block has been executed: `s` is a non-empty string consisting of the characters 'A' and 'B' only, and `s` contains either the substring 'AB' or 'BB'
    while s.find('AB') != -1:
        s = s.replace('AB', '')
        
    #State of the program after the loop has been executed: 's' is either an empty string or does not contain 'AB'
    while s.find('BB') != -1:
        s = s.replace('BB', '')
        
    #State of the program after the loop has been executed: `s` is a string without the substring 'BB'
    return len(s)
    #The program returns the length of string 's'

#Function 20:
#State of the program right berfore the function call: The function `func_19` does not have any input parameters related to the problem. It seems to be a utility function for printing values, which is not directly contributing to solving the given problem. The problem-solving logic is not implemented in this function.
def func_19():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is a space `' '`, `file` is `sys.stdout`, `at_start` is `False`, and the concatenated string representations of all elements in `args` separated by `sep` have been written to `sys.stdout`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is a space `' '`, `file` is `sys.stdout`, `at_start` is `False`, and the string `\n` has been written to `sys.stdout`. If the keyword argument `flush` is `True`, the function flushes the output stream. If `flush` is not provided or is `False`, no additional action is taken.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
