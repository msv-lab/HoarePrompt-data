
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either "AB" or "BB". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.

For example, Zookeeper can use two such operations: AABABBA → AABBA → AAA.

Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 20000) — the number of test cases. The description of the test cases follows.

Each of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.

It is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print a single integer: the length of the shortest string that Zookeeper can make.

Example

Input


3
AAA
BABA
AABBBABBBB


Output


3
2
0

Note

For the first test case, you can't make any moves, so the answer is 3.

For the second test case, one optimal sequence of moves is BABA → BA. So, the answer is 2.

For the third test case, one optimal sequence of moves is AABBBABBBB → AABBBABB → AABBBB → ABBB → AB → (empty string). So, the answer is 0.
Annotated Functions:
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

#Function 1:
#State of the program right berfore the function call: None of the variables in the function `func_1()` are described in the provided code snippet. The function simply reads an integer input and returns it, but there are no input parameters defined in the function signature.
def func_1():
    return int(input())
    #The program returns an integer input provided by the user
#Overall this is what the function does:The function `func_1()` reads an integer input from the user and returns that integer. There are no input parameters defined in the function signature, which means the function does not accept any arguments. The function does not handle any edge cases such as non-integer inputs or errors during input reading. If the user provides a non-integer input, the program will raise a `ValueError` and terminate. After the function concludes, the program will return the integer input provided by the user.

#Function 2:
#State of the program right berfore the function call: The function does not take any parameters and it is expected to be part of a larger solution where the input is taken from standard input. The input consists of multiple test cases, each described by the problem statement. Each test case starts with an integer t (1 ≤ t ≤ 20000) indicating the number of test cases, followed by t strings s, each of which is a non-empty string consisting of 'A' and 'B' characters.
def func_2():
    return input()
    #The program returns the input string `s` from the test case, where each string `s` consists of 'A' and 'B' characters
#Overall this is what the function does:The function `func_2()` reads a single string `s` from standard input, where `s` consists of 'A' and 'B' characters, and returns this string `s`. It handles multiple test cases, each starting with an integer `t` indicating the number of subsequent strings `s` to read. However, the function only processes one string `s` per call and ignores the integer `t`. There is no handling for reading multiple strings or processing more than one test case within a single function call.

#Function 3:
#State of the program right berfore the function call: None of the variables in the function signature are present in the provided code snippet. The function `func_3` does not take any parameters and it reads input from the standard input, which is not described in the problem statement or the function signature.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object that converts each input string from standard input into an integer
#Overall this is what the function does:The function `func_3` reads a line of space-separated integers from the standard input, converts each integer from a string to an integer type, and returns a map object containing these integers. There are no parameters passed to the function. The function handles the case where the input is a single line of space-separated strings, which are then converted to integers. However, it does not handle potential edge cases such as non-integer inputs or empty input lines. If the input contains non-integer values or is empty, the behavior is undefined, and the returned map object might raise an error when accessed.

#Function 4:
#State of the program right berfore the function call: None of the variables in the function `func_4()` are defined or used within the provided code snippet. The function reads input from the standard input, splits it by spaces, and maps each element to a string, returning an iterator over the resulting strings. However, the problem description and the intended use of the function do not align with the function's implementation. The function does not take any parameters and does not relate directly to the bomb game described in the problem.
def func_4():
    return map(str, input().strip().split(' '))
    #An iterator over strings obtained by splitting the input string (read from standard input) by spaces and converting each element to a string
#Overall this is what the function does:The function `func_4()` reads a single line of input from the standard input, splits it into substrings based on spaces, converts each substring to a string (though this conversion is unnecessary since the split result is already strings), and returns an iterator over these strings. There are no parameters accepted by the function. Potential edge cases include empty input or input containing only spaces, which would still produce an empty iterator. The function does not handle cases where input might contain tabs or multiple consecutive spaces, though splitting by ' ' should account for these as well.

#Function 5:
#State of the program right berfore the function call: The function `func_3()` returns an iterable object, and it is not directly used in `func_5()`, implying that `func_5()` processes the output of `func_3()` by converting it into a list. However, there are no direct parameters or dependencies on variables within the function signature provided for `func_5()`.
def func_5():
    return list(func_3())
    #The program returns a list generated from the iterable object returned by func_3()
#Overall this is what the function does:The function `func_5()` takes no parameters and returns a list generated from the iterable object produced by `func_3()`. After executing, the program state includes the return of a list containing elements from the iterable object returned by `func_3()`. This means that `func_3()` must produce an iterable (e.g., a generator, list, tuple, etc.), which is then converted to a list before being returned. Any potential edge cases would involve scenarios where `func_3()` returns an empty iterable, resulting in an empty list being returned by `func_5()`. There is no missing functionality as described in the annotations; however, it is important to note that the exact content and structure of the iterable produced by `func_3()` will dictate the final state of the returned list.

#Function 6:
#State of the program right berfore the function call: The function `func_6` does not take any parameters. It sets the recursion limit to 1,000,000 and the stack size to 1,024,000 bytes before starting a new thread named `thread` that targets the execution of the `main` function.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` sets the recursion limit to 1,000,000 and the stack size to 1,024,000 bytes, then starts a new thread named `thread` which targets the execution of the `main` function. After the thread starts, the function concludes and does not return any value. This means that the `main` function will run in a separate thread with the specified resource limits. There are no parameters accepted by the function, and it does not modify any external state beyond setting these thread properties.

#Function 7:
#State of the program right berfore the function call: item is a tuple or list with exactly two elements, where the second element is a string consisting of letters 'A' and 'B'.
def func_7(item):
    return item[1]
    #The program returns a string consisting of letters 'A' and 'B'
#Overall this is what the function does:The function `func_7` accepts a parameter `item`, which must be a tuple or list containing exactly two elements, where the second element is a string consisting of the letters 'A' and 'B'. The function returns the second element of `item`. There are no edge cases or missing functionalities in the provided code. After the function concludes, the program will return a string consisting of the letters 'A' and 'B'.

#Function 8:
#State of the program right berfore the function call: l is a list of strings, where each string consists of characters 'A' and 'B' only.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a list of strings from 'l', sorted in descending order based on a custom key 'getKey', where 'getKey' is not defined in the provided code snippet
#Overall this is what the function does:The function `func_8` accepts a list `l` of strings, where each string consists of characters 'A' and 'B' only. It returns a new list of strings from `l`, sorted in descending order based on a custom key 'getKey'. The custom key 'getKey' is not defined in the provided code snippet, which means the sorting behavior is undefined. There are no edge cases mentioned in the annotations or code that handle special conditions such as empty lists or non-compliant inputs (i.e., strings containing characters other than 'A' and 'B'). Therefore, the final state of the program after executing `func_8` is a list of strings from `l` sorted in descending order according to the undefined 'getKey' function.

#Function 9:
#State of the program right berfore the function call: n and m are non-negative integers representing the dimensions of a 2D list, and num is an integer value that will be used to initialize all elements in the 2D list.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #A 2D list of size n x m where all elements are initialized to the integer value num
#Overall this is what the function does:The function `func_9` accepts three parameters: `n` and `m`, which represent the dimensions of a 2D list, and `num`, which is an integer value used to initialize all elements in the 2D list. After execution, the function returns a 2D list of size `n x m` where all elements are initialized to the integer value `num`. The function correctly handles the creation of the 2D list and initializes all elements to `num` without any missing functionality. Potential edge cases include when `n` or `m` is zero (in which case the returned list will be empty), or when `num` is any valid integer value (positive, negative, or zero).

#Function 10:
#State of the program right berfore the function call: x is an integer representing a binary number where the length of the binary representation corresponds to the length of the input string s in the main problem.
def func_10(x):
    return x and not x & x - 1
    #The program returns True if x is a power of 2, otherwise returns False
#Overall this is what the function does:The function `func_10` accepts an integer `x` and returns `True` if `x` is a power of 2, otherwise it returns `False`. The function checks this by using the bitwise operation `x and not x & x - 1`. This operation effectively checks if `x` has exactly one bit set to 1 in its binary representation, which is a characteristic of powers of 2. The function correctly handles all edge cases, including `x = 0`, which is not a power of 2, and positive integers that are powers of 2.

#Function 11:
#State of the program right berfore the function call: n is an integer greater than or equal to 0.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of integer `n`, with the '0b' prefix removed
#Overall this is what the function does:The function `func_11` accepts an integer `n` (where `n` is greater than or equal to 0) and returns its binary string representation without the '0b' prefix. The function correctly converts the integer to a binary string using the built-in `bin()` function and then removes the '0b' prefix by replacing it with an empty string. This function handles the case where `n` is 0, which would still produce a valid binary representation ('0'). There are no apparent edge cases or missing functionality in the provided code.

#Function 12:
#State of the program right berfore the function call: n is a non-negative integer represented as a string.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the string representation of 'n'
#Overall this is what the function does:The function `func_12` takes a non-negative integer `n` represented as a string and returns a list of integers, where each integer is a digit from the string representation of `n`. The function splits the string into individual characters, converts each character to an integer, and collects them into a list. This process works for any valid non-negative integer represented as a string, including edge cases like an empty string (which would result in an empty list), and a single-digit number (which would result in a list containing a single integer). There are no missing functionalities in the provided code.

#Function 13:
#State of the program right berfore the function call: x is an integer and y is a positive integer (y > 0).
def func_13(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns x divided by y, where x is an integer and is currently divisible by y, and y is a positive integer
    else :
        return x // y + 1
        #The program returns the integer division of x by y plus 1, where x is an integer not divisible by y and y is a positive integer
#Overall this is what the function does:The function `func_13` accepts two parameters: `x` (an integer) and `y` (a positive integer). It returns the integer division of `x` by `y` if `x` is divisible by `y`. If `x` is not divisible by `y`, it returns the integer division of `x` by `y` plus 1. 

This covers all potential cases:
- If `x` is divisible by `y`, the function returns the exact result of the integer division `x // y`.
- If `x` is not divisible by `y`, the function returns `x // y + 1`.

The final state of the program after executing the function is that it has returned either `x // y` or `x // y + 1` based on the divisibility condition. No other variables are modified outside the function scope.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the base, y is a non-negative integer representing the exponent, and p is a positive integer representing the modulus.
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is the result of \( x^{original \ y} \mod p \), `x` is \( x^{original \ y // 2} \mod p \), `p` is the same positive integer
    return res
    #The program returns res, which is the result of \( x^{original \ y} \mod p \)
#Overall this is what the function does:The function `func_14` accepts three parameters: `x`, `y`, and `p`. - `x` is an integer representing the base. - `y` is a non-negative integer representing the exponent. - `p` is a positive integer representing the modulus. The function implements the modular exponentiation algorithm, which calculates \( x^y \mod p \) efficiently using the square-and-multiply algorithm. The function first reduces `x` modulo `p` and then iteratively squares `x` and multiplies it with `res` when the least significant bit of `y` is 1. After the loop, the function returns `res`, which is the result of \( x^{original \ y} \mod p \). 

Potential edge cases and missing functionality:
- The function correctly handles the case where `y` is 0, as it initializes `res` to 1, which is the identity element for multiplication.
- The function correctly handles the case where `x` or `p` is 0 or 1, though these cases might not be explicitly stated in the problem context.
- The function correctly reduces `x` modulo `p` at the start to ensure that all intermediate calculations are performed under the same modulus.
- The function correctly updates `x` to \( x^2 \mod p \) in each iteration, ensuring that the final value of `x` is \( x^{y//2} \mod p \).
- The function correctly updates `res` only when the least significant bit of `y` is 1, ensuring that the correct power of `x` is included in the result.

#Function 15:
#State of the program right berfore the function call: x and y are non-negative integers where at least one of them is non-zero.
def func_15(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`; `y` is 0.
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, given that y is 0
#Overall this is what the function does:The function `func_15` accepts two non-negative integer parameters `x` and `y`, where at least one of them is non-zero. It computes the greatest common divisor (GCD) of `x` and `y` using the Euclidean algorithm. The function enters a loop where it repeatedly updates `x` to `y` and `y` to `x % y` until `y` becomes zero. At this point, `x` holds the GCD of the original values of `x` and `y`. The function then returns `x`.

Potential edge cases include:
- If `x` and `y` are both zero, the function will enter an infinite loop since `y` will never become zero. However, the function implicitly handles this case by requiring at least one of the parameters to be non-zero.
- If `x` is zero and `y` is non-zero, the function correctly returns `y` as the GCD.
- If both `x` and `y` are positive integers, the function correctly computes their GCD.

#Function 16:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_16(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: n is an integer greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: `n` is an integer greater than 1, and `n` is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than 1 and greater than 3, and `n` is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: Output State: \( n \) is an integer greater than 3, not divisible by 2, and not divisible by 3, and \( i \) is the smallest integer such that \( i \times i > n \) and \( i \) is of the form \( 6k + 5 \)
    return True
    #The program returns True
#Overall this is what the function does:The function `func_16` accepts an integer `n` greater than 1. It returns `False` if `n` is less than or equal to 3 and even, or if `n` is less than or equal to 3 and divisible by 3, or if `n` is greater than 3 and divisible by any number of the form \(6k \pm 1\) up to \(\sqrt{n}\). It returns `True` if `n` is greater than 3 and not divisible by 2, 3, or any number of the form \(6k \pm 1\) up to \(\sqrt{n}\).

#Function 17:
#State of the program right berfore the function call: There is no function signature provided, and the function `func_17` does not take any parameters. This function is likely responsible for setting up the input and output redirection for a series of test cases but does not contribute to solving the core problem of determining the length of the shortest string after applying the bombing operations.
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:This function sets up the standard input to read from a file named 'input.txt' and standard output to write to a file named 'output.txt'. It does not accept any parameters and does not return any value. The function does not perform any operations related to solving the problem of determining the length of the shortest string after applying bombing operations. This setup is likely used for running test cases in an environment where input and output need to be redirected to specific files. There are no apparent edge cases or missing functionalities in the provided code snippet.

#Function 18:
#State of the program right berfore the function call: s is a non-empty string consisting of characters 'A' and 'B', and it represents the initial state of the string that Zookeeper needs to bomb.
def func_18():
    for _ in range(int(input())):
        s = raw_input()
        
        func_19(solve(s))
        
    #State of the program after the  for loop has been executed: `s` is an integer greater than 0, `new_k` is undefined.
#Overall this is what the function does:The function processes a non-empty string `s` consisting of characters 'A' and 'B' by calling `func_19` with the result of `solve(s)`. The function reads multiple strings from the standard input, processes each one, and then prints the result returned by `func_19`. After the loop completes, the final state of the program is that `s` is an integer representing the processed value of the last string read, and `new_k` is undefined. However, the function itself does not return any value; instead, it relies on `func_19` to handle the output. If `solve(s)` returns an integer, it will be passed to `func_19`, and the final state will be that `s` holds this integer value.

#Function 19:
#State of the program right berfore the function call: s is a non-empty string consisting of the characters 'A' and 'B' only.
def solve(s):
    if (s.find('AB') == -1 and s.find('BB') == -1) :
        return len(s)
        #The program returns the length of string `s`
    #State of the program after the if block has been executed: `s` is a non-empty string consisting of the characters 'A' and 'B' only, and `s` contains either the substring 'AB' or 'BB'
    while s.find('AB') != -1:
        s = s.replace('AB', '')
        
    #State of the program after the loop has been executed: 's' is either an empty string or does not contain 'AB'
    while s.find('BB') != -1:
        s = s.replace('BB', '')
        
    #State of the program after the loop has been executed: `s` is a string without the substring 'BB'
    return len(s)
    #The program returns the length of string 's'
#Overall this is what the function does:The function `solve(s)` accepts a non-empty string `s` consisting of the characters 'A' and 'B' only. It first checks if the string contains neither 'AB' nor 'BB'. If both substrings are absent, it returns the length of the string. Otherwise, it removes all occurrences of 'AB' and 'BB' from the string and returns the length of the resulting string. The function ensures that the final string does not contain 'AB' or 'BB', and the returned length reflects the size of this modified string.

#Function 20:
#State of the program right berfore the function call: The function `func_19` does not have any input parameters related to the problem. It seems to be a utility function for printing values, which is not directly contributing to solving the given problem. The problem-solving logic is not implemented in this function.
def func_19():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is a space `' '`, `file` is `sys.stdout`, `at_start` is `False`, and the concatenated string representations of all elements in `args` separated by `sep` have been written to `sys.stdout`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is a space `' '`, `file` is `sys.stdout`, `at_start` is `False`, and the string `\n` has been written to `sys.stdout`. If the keyword argument `flush` is `True`, the function flushes the output stream. If `flush` is not provided or is `False`, no additional action is taken.
#Overall this is what the function does:The function `func_19` takes a variable number of positional arguments (`args`) and keyword arguments (`kwargs`). It prints these arguments to `sys.stdout` (or another specified file) separated by a space character (`' '`), and then appends a newline character (`'\n'`). If the `flush` keyword argument is set to `True`, it flushes the output stream; otherwise, it does nothing regarding flushing. However, the function itself does not accept any parameters and does not return any value. This means that the function only serves to print the provided arguments to the standard output without any return value.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.