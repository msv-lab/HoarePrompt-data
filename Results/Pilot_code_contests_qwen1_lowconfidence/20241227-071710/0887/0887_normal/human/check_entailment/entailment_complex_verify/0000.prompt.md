
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.

The players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.

After a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.

You are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?

Input

The first line contains a single integer n (1 ≤ n ≤ 105) — the number of black points.

The (i + 1)-th line contains two integers xi, yi ( - 105 ≤ xi, yi, ≤ 105) — the coordinates of the point where the i-th black token is initially located.

It is guaranteed that initial positions of black tokens are distinct.

Output

Print the number of points where the white token can be located initially, such that if both players play optimally, the black player wins.

Examples

Input

4
-2 -1
0 1
0 -3
2 -1


Output

4


Input

4
-2 0
-1 1
0 -2
1 -1


Output

2


Input

16
2 1
1 2
-1 1
0 1
0 0
1 1
2 -1
2 0
1 0
-1 -1
1 -1
2 2
0 -1
-1 0
0 2
-1 2


Output

4

Note

In the first and second examples initial positions of black tokens are shown with black points, possible positions of the white token (such that the black player wins) are shown with white points.

The first example: <image>

The second example: <image>

In the third example the white tokens should be located in the inner square 2 × 2, to make the black player win. <image>
Program:
```
from sys import*
from itertools import*
#Function 1:
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        if lmn[x] > y:
            lmn[x] = y
        if lmx[x] < y:
            lmx[x] = y
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
    return ans

#Function 2:
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        (x, y) = dat[i * 2:i * 2 + 2]
        s[x + y & 1].append((-x + y, x + y))
    print(func_1(s[0]) + func_1(s[1]))


```
Original Assessment: Correctness: **False**.

Explanation: The provided program does not correctly implement the logic required to solve the problem as described. Specifically, the program seems to focus on a different problem, possibly related to finding the number of points where the white token can be located such that the black player wins, but the implementation details do not align with the problem's requirements.

To illustrate, let's consider the problem statement again:

- We need to count the number of initial positions for the white token such that if both players play optimally, the black player wins.
- The key point is that after each move of the white player, the white token cannot be in a position occupied by any black token.

However, the provided functions `func_1` and `func_2` seem to be implementing a different algorithm that calculates something about the positions of points but does not directly address the game's rules or the objective of the problem.

For instance, `func_1` and `func_2` involve complex operations on arrays and do not clearly reflect the game's constraints and the requirement to count valid initial positions for the white token.

Given that the program does not correctly handle the problem's constraints and logic, it fails to meet the requirements, leading to the conclusion that the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import*
from itertools import*

func_2()

#Function 1:
#State of the program right berfore the function call: a is a list of tuples, where each tuple contains two integers representing the coordinates (x, y) of a black token's initial position. All coordinates are distinct and within the range [-100000, 100000].
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        
        if lmn[x] > y:
            lmn[x] = y
        
        if lmx[x] < y:
            lmx[x] = y
        
    #State of the program after the  for loop has been executed: `a` must contain at least one tuple, `x` is equal to \((x - 1) / 2 + 100005\), `lmn[x]` is the maximum value of `y` among all tuples in `a` such that \(lmx[x] < y\), and `lmx[x]` is the minimum value of `y` among all tuples in `a` such that \(lmn[x] > y\).
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
        
    #State of the program after the  for loop has been executed: `a` must contain at least one tuple, `lmn` and `lmx` must be initialized with valid values based on the tuples in `a`, `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`. After all iterations of the loop, `lmn[200009]` is the minimum value of `y` among all tuples in `a`, `lmx` remains unchanged, and `i` is 200009.
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
        
    #State of the program after the  for loop has been executed: `a` must contain at least one tuple, `lmn` and `lmx` remain unchanged, `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`, `i` is 200009. If `lmx[i + 1]` is equal to `lmx[i]` for all `i` from 0 to 200008, then `lmn[200009]` is the minimum value of `y` among all tuples in `a`, `lmx` remains unchanged, and `i` is 200009.
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
        
    #State of the program after the  for loop has been executed: `a` must contain at least one tuple, `lmn` and `lmx` remain unchanged, `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`, `i` is 1. `rmn` is adjusted such that for all `i` from 0 to 200008, `rmn[i]` is the maximum of `rmn[i]` and `rmn[i + 1]`. If the condition `rmn[i - 1] > rmn[i]` holds for any `i` from 200008 to 1, then `rmn` maintains the relationship; otherwise, no changes are made to `rmn` and `rmx`, and `i` is 1.
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
        
    #State of the program after the  for loop has been executed: `a` must contain at least one tuple, `lmn` and `lmx` remain unchanged, `rmn` is a shallow copy of `lmn`, `rmx[0]` is the maximum value in `rmx`, and all other elements in `rmx` (from `1` to `200008`) are also `rmx[0]`, `i` is 1.
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
        
    #State of the program after the  for loop has been executed: `a` must contain at least one tuple, `lmn` and `lmx` remain unchanged, `rmn` is a shallow copy of `lmn`, `rmx[0]` is the maximum value in `rmx`, and all other elements in `rmx` (from `1` to `200008`) are also `rmx[0]`, `i` is `200010` and must be within the range `[0, 200009]`, and for every index `j` in the range `[0, 200008]`, `lmn[j]` is equal to `rmn[j]`.
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
        
    #State of the program after the  for loop has been executed: `a` contains at least one tuple, `lmn` and `lmx` remain unchanged, `rmn` is a shallow copy of `lmn`, `rmx[0]` is the maximum value in `rmx`, and all other elements in `rmx` (from 1 to 200008) are also `rmx[0]`, and `i` is 200010. For every index `j` in the range [0, 200008], if `lmx[j] > rmx[j]` at any point during the loop execution, then `lmx[j]` is set to `rmx[j]`. Otherwise, `lmx[j]` remains unchanged and equals `rmx[0]`.
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
        
    #State of the program after the  for loop has been executed: `lmn` is an array where all elements from 0 to 200007 are equal to `lmn[200008]`, `i` is 0, and `ans` is 0.
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
        
    #State of the program after the  for loop has been executed: `lmn` is an array where all elements from 0 to 200007 are equal to `lmn[200008]`, `i` is 200009, and `ans` is 0. `lmx` is a non-increasing sequence starting from `lmn[200008]` and ending at `lmx[0]`.
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
        
    #State of the program after the  for loop has been executed: `i` is 200008, `ans` is the sum of `(lmx[j] - lmn[j]) / 2` for all j from 0 to 200007 where `lmn[j] < lmx[j]`, and `lmn[j]` is less than `lmx[j]` for all j from 0 to 200007.
    return ans
    #The program returns ans which is the sum of (lmx[j] - lmn[j]) / 2 for all j from 0 to 200007 where lmn[j] < lmx[j]
#Overall this is what the function does:The function `func_1` accepts a parameter `a`, which is a list of tuples, where each tuple contains two integers representing the coordinates (x, y) of a black token's initial position. The coordinates are distinct and within the range [-100000, 100000]. The function processes these coordinates to determine the maximum and minimum y-values for each x-coordinate, stored in arrays `lmn` and `lmx` respectively. It then iterates through these arrays to adjust their values based on specific conditions, ensuring that `lmn` is non-decreasing and `lmx` is non-increasing. Finally, it calculates and returns `ans`, which is the sum of \((\text{lmx}[j] - \text{lmn}[j]) / 2\) for all valid indices \(j\) from 0 to 200007 where \(\text{lmn}[j] < \text{lmx}[j]\).

#Function 2:
#State of the program right berfore the function call: `n` is an integer representing the number of black tokens, and `stdin` is an object providing input data access. For each black token, `dat` contains pairs of integers `(x, y)` representing the x and y coordinates of the token's initial position, with the constraint that `1 <= n <= 10^5` and `-10^5 <= x, y <= 10^5`. The initial positions of black tokens are distinct.
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        x, y = dat[i * 2:i * 2 + 2]
        
        s[x + y & 1].append((-x + y, x + y))
        
    #State of the program after the  for loop has been executed: `n` is a positive integer; `dat` is a map object containing exactly `2 * n` elements; `s` is a list where each sublist `s[0]` and `s[1]` contains exactly `n` elements. Each element in `s[x + y & 1]` is of the form `(-x + y, x + y)` where `x` is the value at key `i * 2` in `dat` and `y` is the value at key `i * 2 + 1` in `dat`, and `i` ranges from `0` to `n - 1`.
    print(func_1(s[0]) + func_1(s[1]))
#Overall this is what the function does:The function `func_2` accepts two parameters: `n`, an integer representing the number of black tokens, and `stdin`, an input data access object providing coordinate data for the tokens. The function reads the coordinates of `n` black tokens from `stdin`, processes these coordinates by categorizing them into two lists based on the parity of the sum of their coordinates, and then calls another function `func_1` on each list, summing the results and printing the total. If `n` is less than 1 or greater than \(10^5\), or if the coordinate values exceed \([-10^5, 10^5]\), the function will still read the data and proceed. However, it does not handle invalid inputs explicitly.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
