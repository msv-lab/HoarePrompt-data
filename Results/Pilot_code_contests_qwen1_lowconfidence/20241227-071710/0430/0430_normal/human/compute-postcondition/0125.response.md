Output State: **`num_data` is a positive integer, `j` is `num_data - 1`, `i` is `num_data - 1`, `x2` is the first element of `data[num_data - 1]`, `y2` is the second element of `data[num_data - 1]`, `distance` is the Euclidean distance between the points `(x1, y1)` and `(x2, y2)`, and `cross_points` is a list containing all valid calculated points from each iteration where the conditions `0.0 <= cp1[0] <= 10.0` and `0.0 <= cp1[1] <= 10.0` and `0.0 <= cp2[0] <= 10.0` and `0.0 <= cp2[1] <= 10.0` hold. Each point `cp1` and `cp2` is either `(x1, y1)` or `(x1 + math.cos(th + al), y1 + math.sin(th + al))` or `(x1 + math.cos(th - al), y1 + math.sin(th - al))` depending on the conditions, and if `distance <= RADIUS_2`.**

Explanation:
- The loop iterates over all possible pairs of points in the `data` list except when `i == j`.
- For each pair, it calculates the distance between the points.
- If the distance is less than or equal to `RADIUS_2`, it calculates the potential cross points `cp1` and `cp2` based on the given conditions.
- It checks if these points lie within the bounds `0.0 <= cp1[0] <= 10.0` and `0.0 <= cp1[1] <= 10.0` and `0.0 <= cp2[0] <= 10.0` and `0.0 <= cp2[1] <= 10.0`.
- If they do, it appends them to the `cross_points` list.
- After the loop completes, `cross_points` will contain all such valid points from each iteration where the conditions hold.