
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: There are n piranhas with sizes a_1, a_2, …, a_n in the aquarium. Piranhas are numbered from left to right in order they live in the aquarium.

Scientists of the Berland State University want to find if there is dominant piranha in the aquarium. The piranha is called dominant if it can eat all the other piranhas in the aquarium (except itself, of course). Other piranhas will do nothing while the dominant piranha will eat them.

Because the aquarium is pretty narrow and long, the piranha can eat only one of the adjacent piranhas during one move. Piranha can do as many moves as it needs (or as it can). More precisely: 

  * The piranha i can eat the piranha i-1 if the piranha i-1 exists and a_{i - 1} < a_i. 
  * The piranha i can eat the piranha i+1 if the piranha i+1 exists and a_{i + 1} < a_i. 



When the piranha i eats some piranha, its size increases by one (a_i becomes a_i + 1).

Your task is to find any dominant piranha in the aquarium or determine if there are no such piranhas.

Note that you have to find any (exactly one) dominant piranha, you don't have to find all of them.

For example, if a = [5, 3, 4, 4, 5], then the third piranha can be dominant. Consider the sequence of its moves: 

  * The piranha eats the second piranha and a becomes [5, \underline{5}, 4, 5] (the underlined piranha is our candidate). 
  * The piranha eats the third piranha and a becomes [5, \underline{6}, 5]. 
  * The piranha eats the first piranha and a becomes [\underline{7}, 5]. 
  * The piranha eats the second piranha and a becomes [\underline{8}]. 



You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 2 ⋅ 10^4) — the number of test cases. Then t test cases follow.

The first line of the test case contains one integer n (2 ≤ n ≤ 3 ⋅ 10^5) — the number of piranhas in the aquarium. The second line of the test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9), where a_i is the size of the i-th piranha.

It is guaranteed that the sum of n does not exceed 3 ⋅ 10^5 (∑ n ≤ 3 ⋅ 10^5).

Output

For each test case, print the answer: -1 if there are no dominant piranhas in the aquarium or index of any dominant piranha otherwise. If there are several answers, you can print any.

Example

Input


6
5
5 3 4 4 5
3
1 1 1
5
4 4 3 4 4
5
5 5 4 3 2
3
1 1 2
5
5 4 3 5 5


Output


3
-1
4
3
3
1

Note

The first test case of the example is described in the problem statement.

In the second test case of the example, there are no dominant piranhas in the aquarium.

In the third test case of the example, the fourth piranha can firstly eat the piranha to the left and the aquarium becomes [4, 4, 5, 4], then it can eat any other piranha in the aquarium.
Program:
```
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math
#Function 1:
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        m = max(a)
        f = 0
        for i in range(n):
            if a[i] == m:
                if i - 1 >= 0 and a[i] > a[i - 1] or (i + 1 < n and a[i] > a[i + 1]):
                    func_2(i + 1)
                    f = 1
                    break
        if f == 0:
            func_2(-1)

#Function 2:
def func_2(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly identify a dominant piranha in the aquarium according to the problem description. Specifically, the program does not simulate the process of a piranha eating another piranha and updating the sizes of the piranhas accordingly. Instead, it simply checks if a piranha is the maximum in the list and if it has an adjacent piranha smaller than itself. However, this approach is insufficient because:

1. The program does not simulate the process of a piranha eating another piranha and increasing its size.
2. It does not handle the scenario where multiple piranhas could potentially become dominant after a series of moves.

For example, consider the input:
```
5
5 3 4 4 5
```
The third piranha can become dominant as explained in the problem statement. However, the current implementation would incorrectly output `-1` because it does not simulate the eating process.

Here is a corrected version of the program that simulates the process correctly:
```python
def find_dominant_piranha(a):
    n = len(a)
    for i in range(n):
        # Check if the current piranha can eat the left neighbor
        if i > 0 and a[i] > a[i - 1]:
            new_a = a[:]
            new_a[i] = a[i - 1] + 1
            new_a.pop(i - 1)
            result = find_dominant_piranha(new_a)
            if result == -1:
                return i + 1
            else:
                continue
        # Check if the current piranha can eat the right neighbor
        if i < n - 1 and a[i] > a[i + 1]:
            new_a = a[:]
            new_a[i] = a[i + 1] + 1
            new_a.pop(i + 1)
            result = find_dominant_piranha(new_a)
            if result == -1:
                return i + 1
            else:
                continue
    return -1

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    print(find_dominant_piranha(a))
```

This corrected version properly simulates the process of a piranha eating another piranha and updating the sizes until a dominant piranha is found or determined to not exist.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. For each test case, n is a positive integer representing the number of piranhas, and a is a list of n positive integers where each integer represents the size of a piranha.
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        
        a = list(map(int, input().split()))
        
        m = max(a)
        
        f = 0
        
        for i in range(n):
            if a[i] == m:
                if i - 1 >= 0 and a[i] > a[i - 1] or i + 1 < n and a[i] > a[i + 1]:
                    func_2(i + 1)
                    f = 1
                    break
        
        if f == 0:
            func_2(-1)
        
    #State of the program after the  for loop has been executed: `t` is the number of test cases entered by the user, `a` is a list of integers, `f` is 0, `i` is `n`, and `n` is the number of elements in each list `a`. If no element in any of the lists `a` satisfies the condition of being a local maximum equal to `m`, then `f` remains 0 and `func_2(-1)` is called at the end of the loop for each test case. Otherwise, for each list `a`, if there exists an element that is a local maximum (`a[i] == m` and either `i-1 < 0` or `i+1 >= n` or both conditions hold), then `f` is set to 1, `func_2(i + 1)` is called, and the loop breaks.
#Overall this is what the function does:The function accepts a parameter `t`, a positive integer representing the number of test cases. For each test case, it accepts `n`, a positive integer representing the number of piranhas, and `a`, a list of `n` positive integers representing the sizes of the piranhas. The function then iterates through each list `a` and checks if there exists a local maximum element (an element that is larger than its immediate neighbors). If such an element is found, it calls `func_2` with the position of this element plus one and sets a flag `f` to 1. If no such element is found in any of the lists, it calls `func_2` with -1 for each test case. The final state of the program after the function concludes is that `t` remains unchanged, `a` is unchanged, `f` is 0 if no local maximum was found or 1 if at least one local maximum was found, `i` is `n` (the length of the current list `a`), and `n` is the number of elements in each list `a`.

#Function 2:
#State of the program right berfore the function call: t is an integer representing the number of test cases, and for each test case, n is an integer representing the number of piranhas in the aquarium, followed by a list of n integers a_1, a_2, ..., a_n where each a_i is the size of the i-th piranha.
def func_2():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is an integer, `n` is an integer, `args` is an empty collection, `sep` is set to `kwargs.pop('sep', ' ')`, `file` is set to `kwargs.pop('file', sys.stdout); `at_start` is `False`. The file contains the concatenation of string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is an integer, `n` is an integer, `args` is an empty collection, `sep` is set to `kwargs.pop('sep', ' ')`, `file` is an instance of `io.TextIOWrapper` with its content being the original content plus `\n`, `at_start` is `False`. If `flush` is `True`, the function flushes the contents of `file`. Otherwise, the state of the variables remains unchanged.
#Overall this is what the function does:The function does not accept any parameters `t` or `n`, nor does it process a list of piranha sizes. Instead, it accepts a variable number of positional arguments (`args`) and keyword arguments (`kwargs`). It prints these arguments to a specified output stream (`file`), separated by a specified separator (`sep`), and appends a specified end character (`end`). If the `flush` argument is set to `True`, it flushes the output stream. After executing, the function leaves `t`, `n`, and `a_i` (if they were present in the input) unchanged, and the output stream contains the concatenated string representations of the input arguments, possibly including separators and end characters. There is no processing of test cases or piranha sizes as implied in the annotations.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
