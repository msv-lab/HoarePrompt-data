
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ashish has two strings a and b, each of length n, and an integer k. The strings only contain lowercase English letters.

He wants to convert string a into string b by performing some (possibly zero) operations on a.

In one move, he can either 

  * choose an index i (1 ≤ i≤ n-1) and swap a_i and a_{i+1}, or 
  * choose an index i (1 ≤ i ≤ n-k+1) and if a_i, a_{i+1}, …, a_{i+k-1} are all equal to some character c (c ≠ 'z'), replace each one with the next character (c+1), that is, 'a' is replaced by 'b', 'b' is replaced by 'c' and so on. 



Note that he can perform any number of operations, and the operations can only be performed on string a. 

Help Ashish determine if it is possible to convert string a into b after performing some (possibly zero) operations on it.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^5) — the number of test cases. The description of each test case is as follows.

The first line of each test case contains two integers n (2 ≤ n ≤ 10^6) and k (1 ≤ k ≤ n).

The second line of each test case contains the string a of length n consisting of lowercase English letters.

The third line of each test case contains the string b of length n consisting of lowercase English letters.

It is guaranteed that the sum of values n among all test cases does not exceed 10^6.

Output

For each test case, print "Yes" if Ashish can convert a into b after some moves, else print "No".

You may print the letters of the answer in any case (upper or lower).

Example

Input


4
3 3
abc
bcd
4 2
abba
azza
2 1
zz
aa
6 2
aaabba
ddddcc


Output


No
Yes
No
Yes

Note

In the first test case it can be shown that it is impossible to convert a into b.

In the second test case,

"abba" \xrightarrow{inc} "acca" \xrightarrow{inc} … \xrightarrow{inc} "azza".

Here "swap" denotes an operation of the first type, and "inc" denotes an operation of the second type.

In the fourth test case,

"aaabba" \xrightarrow{swap} "aaabab" \xrightarrow{swap} "aaaabb" \xrightarrow{inc} … \xrightarrow{inc} "ddaabb" \xrightarrow{inc} … \xrightarrow{inc} "ddddbb" \xrightarrow{inc} … \xrightarrow{inc} "ddddcc".
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement
from __builtin__ import xrange as range
from math import ceil, factorial, log, sqrt
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from bisect import bisect, insort, bisect_left, bisect_right
from fractions import Fraction
import heapq
from functools import reduce
import string
import sys
import os
import re

inf = float('inf')
mod = int(1000000000.0) + 7
mod_ = 998244353
BUFSIZE = 8192
class FastI(IOBase):

    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = StringIO()
        self.newlines = 0

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count('\n') + (not b)
            ptr = self._buffer.tell()
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
        self.newlines -= 1
        return self._buffer.readline()
class FastO(IOBase):

    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = __pypy__.builders.StringBuilder()
        self.write = lambda s: self._buffer.append(s)

    def flush(self):
        os.write(self._fd, self._buffer.build())
        self._buffer = __pypy__.builders.StringBuilder()
(sys.stdin, sys.stdout) = (FastI(sys.stdin), FastO(sys.stdout))
if __name__ == '__main__':

    def bootstrap(cont):
        (call, arg) = cont.switch()
        while True:
            (call, arg) = cont.switch(to=continulet(lambda _, f, args: f(*args), call, arg))
    cont = continulet(bootstrap)
    cont.switch()
    func_2()

#Function 1:
#State of the program right berfore the function call: n and k are integers such that 2 ≤ n ≤ 10^6 and 1 ≤ k ≤ n. s and t are strings of length n consisting of lowercase English letters. freq is a dictionary representing the frequency count of characters in string s.
def func_1():
    n, k = map(int, func_5().split())
    s = func_5()
    t = func_5()
    freq = Counter(s)
    groups = [m.group(0) for m in re.finditer('([a-z])\\1*', t)]
    for group in groups:
        div = len(group) // k
        
        rem = len(group) % k
        
        if freq[group[0]] < rem:
            func_3('No')
            return
        
        freq[group[0]] -= rem
        
        if div == 0:
            continue
        
        for i in range(string.ascii_lowercase.index(group[0]) - 1, -1, -1):
            if freq[string.ascii_lowercase[i]] >= div:
                freq[string.ascii_lowercase[i]] -= div
                break
        else:
            func_3('No')
            return
        
    #State of the program after the  for loop has been executed: `groups` is a non-empty list of substrings consisting of consecutive identical characters from string `t`, `div` is the integer division of the length of each substring in `groups` by `k`, `rem` is the remainder of the length of each substring in `groups` divided by `k`, `freq` is the updated frequency count of characters in string `s` after the loop, and `string.ascii_lowercase.index(group[0])` is the index of the first character in each group. If the loop executes, the frequency of characters in `freq` will be reduced accordingly based on the conditions in the loop. If the loop does not execute, the function will call `func_3('No')` and return without modifying `freq`.
    func_3('Yes')

#Function 2:
#State of the program right berfore the function call: t is an integer representing the number of test cases, n and k are integers where 2 ≤ n ≤ 10^6 and 1 ≤ k ≤ n, a is a string of length n consisting of lowercase English letters, and b is a string of length n consisting of lowercase English letters.
def func_2():
    for _ in range(int(func_5())):
        func_1()
        
    #State of the program after the  for loop has been executed: `t` is an integer representing the number of test cases, `n` and `k` are integers where \(2 \leq n \leq 10^6\) and \(1 \leq k \leq n\), `a` is a string of length `n` consisting of lowercase English letters, `b` is a string of length `n` consisting of lowercase English letters, and `func_1()` has been executed at least `int(func_5())` times.

#Function 3:
#State of the program right berfore the function call: t is an integer greater than or equal to 1 and less than or equal to 10^5. For each test case, n is an integer greater than or equal to 2 and less than or equal to 10^6, k is an integer greater than or equal to 1 and less than or equal to n, sep, file, end, and flush are optional keyword arguments passed to the print function, where sep specifies the separator between values, file specifies the output stream, end specifies the string appended after the last value, and flush specifies whether to forcibly flush the stream.
def func_3():
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is an integer between 1 and \(10^5\) inclusive, `n` is an integer between 2 and \(10^6\) inclusive, `k` is an integer between 1 and `n` inclusive, `sep` is the value of `kwargs.pop('sep', ' ')`, `file` is the content written to the file (concatenation of `sep` and all elements of `args`), `at_start` is `False`, `end` and `flush` remain as optional keyword arguments passed to the print function, `args` is an empty collection.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is an integer between 1 and \(10^5\) inclusive, `n` is an integer between 2 and \(10^6\) inclusive, `k` is an integer between 1 and `n` inclusive, `sep` is the value of `kwargs.pop('sep', ' ')`, `file` is the content written to the file (concatenation of `sep` and `end`), `at_start` is `False`, `end` is `\n`, `flush` remains unchanged, and `args` is an empty collection. If `kwargs.pop('flush', False)` is `True`, then the function will flush the output.

#Function 4:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_4(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, and y is 0

#Function 5:
#State of the program right berfore the function call: t is an integer representing the number of test cases, n and k are integers such that 2 ≤ n ≤ 10^6 and 1 ≤ k ≤ n, and a and b are strings of length n consisting of lowercase English letters.
def func_5():
    return sys.stdin.readline().rstrip('\r\n')
    #`sys.stdin.readline().rstrip('\r\n')` which reads an integer representing the number of test cases from standard input and removes any trailing newline character


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
