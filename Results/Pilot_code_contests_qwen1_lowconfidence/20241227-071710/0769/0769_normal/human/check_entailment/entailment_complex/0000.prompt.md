
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Write a program which reads $n$ dices constructed in the same way as Dice I, and determines whether they are all different. For the determination, use the same way as Dice III.

Constraints

* $2 \leq n \leq 100$
* $0 \leq $ the integer assigned to a face $ \leq 100$

Input

In the first line, the number of dices $n$ is given. In the following $n$ lines, six integers assigned to the dice faces are given respectively in the same way as Dice III.

Output

Print "Yes" if given dices are all different, otherwise "No" in a line.

Examples

Input

3
1 2 3 4 5 6
6 2 4 3 5 1
6 5 4 3 2 1


Output

No


Input

3
1 2 3 4 5 6
6 5 4 3 2 1
5 4 3 2 1 6


Output

Yes
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
class Dice(object):
    """Dice Class

    """

    def __init__(self, numbers):
        """

        Args:
            numbers:
        """
        self.numbers_inverse = {numbers[0]: 1, numbers[1]: 2, numbers[2]: 3, numbers[3]: 4, numbers[4]: 5, numbers[5]: 6}
        self.numbers = {1: numbers[0], 2: numbers[1], 3: numbers[2], 4: numbers[3], 5: numbers[4], 6: numbers[5]}
        self.vertical = [self.numbers[1], self.numbers[2], self.numbers[6], self.numbers[5]]
        self.horizontal = [self.numbers[4], self.numbers[1], self.numbers[3], self.numbers[6]]

    def roll_dice(self, str):
        """

        Args:
            str: move direction

        Returns:

        """
        for s in str:
            if s == 'N':
                self.move_north()
            elif s == 'S':
                self.move_south()
            elif s == 'W':
                self.move_west()
            elif s == 'E':
                self.move_east()

    def set_top(self, value):
        """
        Args:
            value: target_value
        """
        counter = 0
        while counter < 4:
            if self.vertical[0] == value:
                self.map_values()
                return
            else:
                self.roll_dice('S')
            counter += 1
        counter = 0
        while counter < 4:
            if self.vertical[0] == value:
                self.map_values()
                return
            else:
                self.roll_dice('W')
            counter += 1

    def set_front(self, value):
        """
        Args:
            value: target value
        """
        counter = 0
        while counter < 4:
            if self.vertical[1] == value:
                self.map_values()
                return
            else:
                self.roll_dice('SWN')
            counter += 1

    def move_south(self):
        """move this dice towered north
        """
        self.vertical = (self.vertical * 2)[3:7]
        self.horizontal[1] = self.vertical[0]
        self.horizontal[3] = self.vertical[2]
        self.map_values()

    def move_north(self):
        """move this dice towered south
        """
        self.vertical = (self.vertical * 2)[1:5]
        self.horizontal[1] = self.vertical[0]
        self.horizontal[3] = self.vertical[2]
        self.map_values()

    def move_east(self):
        """move this dice towered east
        """
        self.horizontal = (self.horizontal * 2)[3:7]
        self.vertical[0] = self.horizontal[1]
        self.vertical[2] = self.horizontal[3]
        self.map_values()

    def move_west(self):
        """move this dice towered west
        """
        self.horizontal = (self.horizontal * 2)[1:5]
        self.vertical[0] = self.horizontal[1]
        self.vertical[2] = self.horizontal[3]
        self.map_values()

    def map_values(self):
        self.numbers[1] = self.vertical[0]
        self.numbers[2] = self.vertical[1]
        self.numbers[3] = self.horizontal[2]
        self.numbers[4] = self.horizontal[0]
        self.numbers[5] = self.vertical[3]
        self.numbers[6] = self.vertical[2]

    def get_top(self):
        return self.vertical[0]
dice_number = int(raw_input())
dices = []
counter = 0
while counter < dice_number:
    dices.append(Dice([int(x) for x in raw_input().split()]))
    counter += 1
ans = 0
for i in range(dice_number - 1):
    if ans > 0:
        break
    for j in range(i + 1, dice_number):
        ans += int(func_1(dices[i], dices[j]))
        if ans > 0:
            print('No')
            break
if ans == 0:
    print('Yes')

#State of the program right berfore the function call: dice1 and dice2 are lists of six integers each, representing the faces of two dice. The integers assigned to the faces are in the same format as described in Dice III, and it is guaranteed that 0 ≤ the integer assigned to a face ≤ 100.
def func_1(dice1, dice2):
    """compare two dices

    Args:
        dice1: dice1
        dice2: dice2

    Returns:
        Bool (whether dice1 is equals to be dice2 or not)
    """
    flag = False
    if (dice1.numbers == dice2.numbers) :
        flag = True
    else :
        for i in range(6):
            dice1.set_top(i + 1)
            
            for j in xrange(4):
                dice1.roll_dice('SWN')
                if dice1.numbers == dice2.numbers:
                    flag = True
            
            dice1.roll_dice('S')
            
        #State of the program after the  for loop has been executed: `flag` is `True` if `dice1.numbers` equals `dice2.numbers` after all 24 rolls (4 rolls per iteration for 6 iterations), `i` is 5, `dice1`'s top face is an unspecified value, `dice2.numbers` is the original value before any rolls.
    #State of the program after the if-else block has been executed: `dice1` and `dice2` are lists of six integers. If `dice1.numbers` equals `dice2.numbers` at any point during the comparison, `flag` is set to `True`. Otherwise, `flag` remains `False` after all 24 rolls (4 rolls per iteration for 6 iterations), `i` is 5, and `dice1`'s top face is an unspecified value while `dice2.numbers` retains its original value before any rolls.
    return flag
    #The program returns flag which is False since dice1.numbers does not equal dice2.numbers at any point during the 24 rolls
#Overall this is what the function does:The function `func_1` accepts two parameters `dice1` and `dice2`, both of which are lists of six integers representing the faces of two dice. The function attempts to determine if `dice1` can be made identical to `dice2` through a series of 24 roll operations, where each operation consists of rolling the die in the South-West-North direction four times, followed by a single roll to the South. After these operations, if `dice1` matches `dice2` at any point, the function sets `flag` to `True`; otherwise, `flag` remains `False`. The function returns `flag`.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
