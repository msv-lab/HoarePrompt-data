
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Very soon Berland will hold a School Team Programming Olympiad. From each of the m Berland regions a team of two people is invited to participate in the olympiad. The qualifying contest to form teams was held and it was attended by n Berland students. There were at least two schoolboys participating from each of the m regions of Berland. The result of each of the participants of the qualifying competition is an integer score from 0 to 800 inclusive.

The team of each region is formed from two such members of the qualifying competition of the region, that none of them can be replaced by a schoolboy of the same region, not included in the team and who received a greater number of points. There may be a situation where a team of some region can not be formed uniquely, that is, there is more than one school team that meets the properties described above. In this case, the region needs to undertake an additional contest. The two teams in the region are considered to be different if there is at least one schoolboy who is included in one team and is not included in the other team. It is guaranteed that for each region at least two its representatives participated in the qualifying contest.

Your task is, given the results of the qualifying competition, to identify the team from each region, or to announce that in this region its formation requires additional contests.

Input

The first line of the input contains two integers n and m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 10 000, n ≥ 2m) — the number of participants of the qualifying contest and the number of regions in Berland.

Next n lines contain the description of the participants of the qualifying contest in the following format: Surname (a string of length from 1 to 10 characters and consisting of large and small English letters), region number (integer from 1 to m) and the number of points scored by the participant (integer from 0 to 800, inclusive).

It is guaranteed that all surnames of all the participants are distinct and at least two people participated from each of the m regions. The surnames that only differ in letter cases, should be considered distinct.

Output

Print m lines. On the i-th line print the team of the i-th region — the surnames of the two team members in an arbitrary order, or a single character "?" (without the quotes) if you need to spend further qualifying contests in the region.

Examples

Input

5 2
Ivanov 1 763
Andreev 2 800
Petrov 1 595
Sidorov 1 790
Semenov 2 503


Output

Sidorov Ivanov
Andreev Semenov


Input

5 2
Ivanov 1 800
Andreev 2 763
Petrov 1 800
Sidorov 1 800
Semenov 2 503


Output

?
Andreev Semenov

Note

In the first sample region teams are uniquely determined.

In the second sample the team from region 2 is uniquely determined and the team from region 1 can have three teams: "Petrov"-"Sidorov", "Ivanov"-"Sidorov", "Ivanov" -"Petrov", so it is impossible to determine a team uniquely.
Program:
```
from sys import stdin

def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    rstrs = lambda : [str(x) for x in stdin.readline().split()]
    (n, m) = rints()
    (mem, ans) = ([[] for _ in range(m + 1)], [])
    for _ in range(n):
        a = rstrs()
        mem[int(a[1])].append((int(a[-1]), a[0]))
    for i in range(1, m + 1):
        mem[i].sort()
        tem = mem[i]
        if len(tem) > 2 and tem[-3][0] in (tem[-1][0], tem[-2][0]):
            ans.append('?')
        else:
            ans.append('%s %s' % (tem[-1][1], tem[-2][1]))
    print('\n'.join(ans))


```
Original Assessment: Correctness: **False**

Explanation: The program does not handle the case where multiple teams can be formed uniquely but choosing the wrong pair. According to the problem description, if there are multiple valid teams for a region, the output should be `?`. However, the current implementation only checks if the third-highest score is the same as the highest or second-highest score, which is not sufficient to ensure that no other valid pairs exist.

For example, consider the following input:

```
5 2
Ivanov 1 800
Andreev 2 763
Petrov 1 800
Sidorov 1 800
Semenov 2 503
```

In this case, region 1 has three students with the highest score of 800. The program will output:

```
Ivanov Petrov
Andreev Semenov
```

This is incorrect because there are multiple valid teams, and the output should be `?` for region 1. The program needs to check if there are multiple valid teams by ensuring that the highest score is not the only unique score among the top three scores.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin

#State of the program right berfore the function call: n and m are integers such that 2 ≤ n ≤ 100 000, 1 ≤ m ≤ 10 000, and n ≥ 2m. The input consists of n lines, each describing a participant with a surname (a string of length from 1 to 10 characters and consisting of large and small English letters), a region number (an integer from 1 to m), and the number of points scored by the participant (an integer from 0 to 800, inclusive). Each region has at least two participants.
def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    rstrs = lambda : [str(x) for x in stdin.readline().split()]
    n, m = rints()
    mem, ans = [[] for _ in range(m + 1)], []
    for _ in range(n):
        a = rstrs()
        
        mem[int(a[1])].append((int(a[-1]), a[0]))
        
    #State of the program after the  for loop has been executed: `n` is between 2 and 100,000 inclusive, `m` is between 1 and 10,000 inclusive, `mem` is a list of `m + 1` empty lists where each sublist contains one or more tuples of the form `(int(a[-1]), a[0])`, `ans` is an empty list, `i` is `n`, `a` is the value returned by `rstrs()`
    for i in range(1, m + 1):
        mem[i].sort()
        
        tem = mem[i]
        
        if len(tem) > 2 and tem[-3][0] in (tem[-1][0], tem[-2][0]):
            ans.append('?')
        else:
            ans.append('%s %s' % (tem[-1][1], tem[-2][1]))
        
    #State of the program after the  for loop has been executed: `n` is between 2 and 100,000 inclusive, `m` is a positive integer, `mem` is a list of `m + 1` empty lists where each sublist contains one or more tuples of the form `(int(a[-1]), a[0])`, `ans` is a list containing strings either `'?'` or of the form `' %s %s' % (last_value, second_last_value)`, `i` is `m + 1`, `a` is the value returned by `rstrs()`, `tem` is `mem[m]` and is sorted. For every iteration, if `len(tem) > 2` and the third last tuple's first element is the same as either the last or second last tuple's first element, `ans` contains `'?'` appended. Otherwise, `ans` contains the string `' %s %s' % (last_value, second_last_value)` where `last_value` is the second element of the last tuple and `second_last_value` is the second element of the second-to-last tuple in `tem`.
    print('\n'.join(ans))
#Overall this is what the function does:The function reads input data describing participants, processes this data by sorting the participants within each region, and then determines and prints the top two scorers for each region. If the third highest scorer in a region has the same score as the highest or second-highest scorer, it appends '?' to the output; otherwise, it appends the names of the top two scorers. The function returns nothing but prints the results. Potential edge cases include regions with fewer than three participants, where the function will still process the available data.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
