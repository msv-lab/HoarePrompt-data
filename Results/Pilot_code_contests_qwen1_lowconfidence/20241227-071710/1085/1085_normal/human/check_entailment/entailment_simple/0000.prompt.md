
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (xi, yi).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |xi - xj| + |yi - yj|. Daniel, as an ordinary person, calculates the distance using the formula <image>.

The success of the operation relies on the number of pairs (i, j) (1 ≤ i < j ≤ n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.

Input

The first line of the input contains the single integer n (1 ≤ n ≤ 200 000) — the number of watchmen.

Each of the following n lines contains two integers xi and yi (|xi|, |yi| ≤ 109).

Some positions may coincide.

Output

Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.

Examples

Input

3
1 1
7 5
1 5


Output

2


Input

6
0 0
0 1
0 2
-1 1
0 1
1 1


Output

11

Note

In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <image> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: The input consists of the number of watchmen n (1 ≤ n ≤ 200 000) followed by n lines, each containing two integers xi and yi (|xi|, |yi| ≤ 109) representing the coordinates of the i-th watchman. Some positions may coincide.
def func():
    n = int(raw_input())
    rows = {}
    cols = {}
    posi = {}
    for i in range(n):
        x, y = [int(t) for t in raw_input().split(' ')]
        
        if x in rows:
            rows[x] += 1
        else:
            rows[x] = 1
        
        if y in cols:
            cols[y] += 1
        else:
            cols[y] = 1
        
        if (x, y) in posi:
            posi[x, y] += 1
        else:
            posi[x, y] = 1
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `rows` is a dictionary where each key `x` maps to the number of times `x` appeared as the first coordinate, `cols` is a dictionary where each key `y` maps to the number of times `y` appeared as the second coordinate, `posi` is a dictionary where each key `(x, y)` maps to the number of times `(x, y)` appeared.
    ans = 0
    for t in rows.keys():
        ans = ans + (rows[t] - 1) * rows[t] / 2
        
    #State of the program after the  for loop has been executed: `ans` is the sum of \((\text{rows}[t] - 1) \times \text{rows}[t] / 2\) for all unique keys \(t\) in `rows`, `rows` is unchanged, `cols` is unchanged, and `posi` is unchanged.
    for t in cols.keys():
        ans = ans + (cols[t] - 1) * cols[t] / 2
        
    #State of the program after the  for loop has been executed: `ans` is the sum of \((\text{cols}[t] - 1) \times \text{cols}[t] / 2\) for all unique keys \(t\) in `cols`, `rows` remains unchanged, `cols` remains unchanged, `posi` remains unchanged.
    for t in posi.keys():
        if posi[t] > 1:
            ans -= (posi[t] - 1) * posi[t] / 2
        
    #State of the program after the  for loop has been executed: `ans` is the final value of `ans` after applying the adjustment for each key `t` in `posi.keys()` where `posi[t] > 1`, and `posi` is a dictionary where the value of each key `t` is decremented by 1 for every iteration where `posi[t] > 1`. If no iterations occur (i.e., all values in `posi` are initially <= 1), then `ans` remains unchanged and `posi` remains as the initial state.
    print(ans)

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
