
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Captain Fint is involved in another treasure hunt, but have found only one strange problem. The problem may be connected to the treasure's location or may not. That's why captain Flint decided to leave the solving the problem to his crew and offered an absurdly high reward: one day off. The problem itself sounds like this...

There are two arrays a and b of length n. Initially, an ans is equal to 0 and the following operation is defined: 

  1. Choose position i (1 ≤ i ≤ n); 
  2. Add a_i to ans; 
  3. If b_i ≠ -1 then add a_i to a_{b_i}. 



What is the maximum ans you can get by performing the operation on each i (1 ≤ i ≤ n) exactly once?

Uncle Bogdan is eager to get the reward, so he is asking your help to find the optimal order of positions to perform the operation on them.

Input

The first line contains the integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of arrays a and b.

The second line contains n integers a_1, a_2, …, a_n (−10^6 ≤ a_i ≤ 10^6).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ n or b_i = -1).

Additional constraint: it's guaranteed that for any i (1 ≤ i ≤ n) the sequence b_i, b_{b_i}, b_{b_{b_i}}, … is not cyclic, in other words it will always end with -1.

Output

In the first line, print the maximum ans you can get.

In the second line, print the order of operations: n different integers p_1, p_2, …, p_n (1 ≤ p_i ≤ n). The p_i is the position which should be chosen at the i-th step. If there are multiple orders, print any of them.

Examples

Input


3
1 2 3
2 3 -1


Output


10
1 2 3 


Input


2
-1 100
2 -1


Output


99
2 1 


Input


10
-10 -1 2 2 5 -2 -3 -4 2 -6
-1 -1 2 2 -1 5 5 7 7 9


Output


-9
3 5 6 1 9 4 10 7 8 2
Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return float(input())

#Function 3:
def func_3():
    return input()

#Function 4:
def func_4():
    return map(str, input().split())

#Function 5:
def func_5():
    return map(int, input().split())

#Function 6:
def func_6():
    return list(func_5())

#Function 7:
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
def func_8(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 9:
def func_9(x, y):
    return x * y // func_8(x, y)

#Function 10:
def func_10(b, m):
    g = func_8(b, m)
    if g != 1:
        return -1
    else:
        return pow(b, m - 2, m)

#Function 11:
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if inv == -1:
        return -999999999
    else:
        return inv * a % m

#Function 12:
def func_12():
    n = func_1()
    a = func_6()
    b = func_6()
    l = [0] * n
    for i in range(n):
        if b[i] > 0:
            l[b[i] - 1] += a[i]
    l1 = []
    for i in range(n):
        l1.append([l[i], i])
    l1.sort()
    ans = 0
    l2 = []
    for i in range(n):
        l2.append(l1[i][1] + 1)
        if b[l1[i][1]] > 0:
            ans += a[l1[i][1]]
        a[l1[i][1]] += l1[i][0]
    func_13(ans)
    func_13(*l2)

#Function 13:
def func_13(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **True**

Explanation: After reviewing the provided code, it appears to correctly implement the logic described in the problem statement. The code calculates the maximum possible value of `ans` by strategically choosing the order of positions to perform the operations on. Here’s a breakdown of how the code works:

1. **Initialization**: It initializes an array `l` to keep track of the additional values added to each index due to the recursive nature of the `b` array.
2. **Processing**: For each position `i`, if `b[i]` is not `-1`, it adds `a[i]` to the corresponding position `b[i] - 1` in the `l` array.
3. **Sorting**: It sorts the indices based on the values in the `l` array.
4. **Final Calculation**: It calculates the final answer and the order of operations by iterating through the sorted indices and applying the operations accordingly.

The code handles the constraints and guarantees mentioned in the problem statement, such as the non-cyclic nature of the `b` array. Since the code follows the logic precisely and no edge cases or inputs are overlooked, it should work correctly for all valid inputs as per the problem description.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *

"""
// Author : snape_here - Susanta Mukherjee
     
 """
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
mod = 1000000007
getcontext().prec = 25
abc = 'abcdefghijklmnopqrstuvwxyz'
pi = 3.141592653589793
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_7(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_12()

#Function 1:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer a_i satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i either equals -1 or is a valid index such that 1 ≤ b_i ≤ n.
def func_1():
    return int(input())
    #The program returns an integer input provided by the user
#Overall this is what the function does:The function prompts the user to provide an integer input and returns that integer. There are no preconditions specified for the type of input other than it being an integer. The function does not perform any additional operations or validations on the input. If the user inputs a non-integer value, the program will raise an error since the `input()` function in Python returns a string, which cannot be directly converted to an integer without appropriate handling.

#Function 2:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i is either a positive integer such that 1 ≤ b_i ≤ n or -1.
def func_2():
    return float(input())
    #The program waits for user input and returns the input as a float
#Overall this is what the function does:The function accepts no parameters and waits for user input. It then returns the input as a floating-point number. This function does not modify any external variables and relies on user interaction to provide the input. Potential edge cases include invalid input types (e.g., non-numeric strings) which would result in a `ValueError`. The function does not handle these cases and will raise an exception if the user inputs something other than a valid floating-point number.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer a_i satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i satisfies 1 ≤ b_i ≤ n or b_i = -1.
def func_3():
    return input()
    #The program returns input from the user
#Overall this is what the function does:The function `func_3` accepts no parameters and prompts the user for input. It then returns this input. There are no preconditions or postconditions specified within the code itself, but based on the given information, the function simply reads input from the user and returns it. This means that the function essentially acts as a placeholder for user input, which could be of any type (string, number, etc.). No further processing of the input is performed by the function.

#Function 4:
#State of the program right berfore the function call: None of the variables' values are described within the function signature. However, the function does not take any parameters and its purpose seems to read input from stdin. The input format is expected to follow the problem description's constraints and format.
def func_4():
    return map(str, input().split())
    #The program returns a map object containing strings converted from the input split by spaces
#Overall this is what the function does:The function `func_4` reads a line of space-separated input from standard input (stdin) and returns a map object containing the individual input strings as separate elements. There are no parameters passed to the function. This means the function is designed to take any number of space-separated words as input and return them as a map object where each word is a key and mapped to itself. Potential edge cases include empty input or multiple consecutive spaces between words, which will result in single or multiple empty strings in the output map object.

#Function 5:
#State of the program right berfore the function call: The function does not take any parameters, but it reads input from stdin. The first line of input is an integer n (1 ≤ n ≤ 2 ⋅ 10^5), followed by two lines of space-separated integers representing arrays a and b as described in the problem statement.
def func_5():
    return map(int, input().split())
    #The program returns a map object containing integers from the second line of input split by spaces
#Overall this is what the function does:The function reads an integer `n` from the first line of stdin, followed by two lines of space-separated integers representing arrays `a` and `b`. It then returns a map object containing the integers from the second line of input split by spaces. There are no parameters passed to the function. Note that the function does not process the first array `a`, only the second array `b`. Additionally, the returned map object contains the integers directly without any further transformation or validation.

#Function 6:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies −10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer is either a positive integer satisfying 1 ≤ b_i ≤ n or -1. It is also guaranteed that for any i (1 ≤ i ≤ n), the sequence b_i, b_{b_i}, b_{b_{b_i}}, … ends with -1.
def func_6():
    return list(func_5())
    #The program returns a list generated by func_5(), but the specific content of this list cannot be determined without knowing the implementation of func_5()
#Overall this is what the function does:The function `func_6` takes no explicit parameters and returns a list generated by calling `func_5()`. Given the preconditions and guarantees about the inputs and internal state before `func_5()` is called, the function does not alter any external variables directly. Instead, it leverages the output of `func_5()` to produce its own return value. The returned list is derived from `func_5()`'s behavior, which is not detailed in the given information. Therefore, the final state of the program after `func_6` concludes is that it has returned a list whose contents depend entirely on the implementation of `func_5()`. Since no direct operations on input lists `a` and `b` are performed within `func_6`, these lists remain unchanged.

#Function 7:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5. a is a list of integers of length n where each integer satisfies -10^6 ≤ a_i ≤ 10^6. b is a list of integers of length n where each b_i is either a positive integer such that 1 ≤ b_i ≤ n or -1. It is guaranteed that for any i (1 ≤ i ≤ n), the sequence b_i, b_{b_i}, b_{b_{b_i}}, … ends with -1.
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function reads input from a file named 'input.txt' and writes output to a file named 'output.txt'. It processes three parameters: `n` (an integer), `a` (a list of integers), and `b` (a list of integers). For each index `i` from 0 to `n-1`, it follows the chain defined by `b[i]` until it reaches `-1`, and then collects the indices involved in this chain. It returns a list containing the collected indices for each chain.

#Function 8:
#State of the program right berfore the function call: x and y are integers, and y is not zero (y != 0).
def func_8(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0.
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, given that y is 0
#Overall this is what the function does:The function `func_8` accepts two integer parameters `x` and `y`, where `y` is not zero. It calculates the greatest common divisor (GCD) of `x` and `y` using the Euclidean algorithm. After executing the loop, the function returns the GCD of the original values of `x` and `y`. The state of the program after the function concludes is such that `x` contains the GCD of the original `x` and `y`, and `y` is 0. This process handles the case where `y` is zero by terminating the loop early, ensuring that the function correctly computes the GCD even when one of the inputs is zero initially.

#Function 9:
#State of the program right berfore the function call: x and y are integers.
def func_9(x, y):
    return x * y // func_8(x, y)
    #The program returns the integer result of x multiplied by y, then performing integer division by the result of the function func_8(x, y)
#Overall this is what the function does:The function `func_9` accepts two integer parameters `x` and `y`. It calculates the integer result of `x` multiplied by `y`, then performs integer division by the result of calling another function `func_8` with the same arguments `x` and `y`. The function returns the final computed value. Potential edge cases include when `func_8(x, y)` returns zero, which would result in a division by zero error. Additionally, if either `x` or `y` is zero, the multiplication `x * y` could result in zero, leading to a division by `func_8(x, y)`'s result, which might also be zero.

#Function 10:
#State of the program right berfore the function call: b is an integer such that 1 < b < 2 * 10^5 and is coprime with m, and m is an integer such that m > 1.
def func_10(b, m):
    g = func_8(b, m)
    if (g != 1) :
        return -1
        #The program returns -1
    else :
        return pow(b, m - 2, m)
        #The program returns the value of \( b^{m-2} \mod m \), where \( b \) is an integer such that \( 1 < b < 2 \times 10^5 \) and is coprime with \( m \), and \( m \) is an integer such that \( m > 1 \)
#Overall this is what the function does:The function `func_10` accepts two parameters `b` and `m`. `b` is an integer such that \(1 < b < 2 \times 10^5\) and is coprime with \(m\), and `m` is an integer such that \(m > 1\). The function first calls another function `func_8` with the same parameters `b` and `m`. If the result `g` from `func_8` is not equal to 1, the function returns -1. Otherwise, the function returns the value of \(b^{m-2} \mod m\).

#Function 11:
#State of the program right berfore the function call: a is an integer representing an element from array a, b is an integer representing an element from array b, and m is a positive integer representing the modulus.
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if (inv == -1) :
        return -999999999
        #The program returns -999999999
    else :
        return inv * a % m
        #`The program returns (inv * a) % m` where `inv` is the return value of `func_10(b, m)` and `a` is `a % m`
#Overall this is what the function does:The function `func_11` accepts three parameters: `a`, `b`, and `m`. It first computes `a % m` and stores the result back into `a`. Then, it calls another function `func_10(b, m)` to compute the modular inverse of `b` modulo `m`. If the modular inverse does not exist (i.e., `func_10(b, m)` returns `-1`), the function returns `-999999999`. Otherwise, it returns the product of the modular inverse (`inv`) and the updated `a` (which is `a % m`), all taken modulo `m`.

#Function 12:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of integers such that -10^6 ≤ a_i ≤ 10^6, b is a list of integers such that 1 ≤ b_i ≤ n or b_i = -1, and the sequence b_i, b_{b_i}, b_{b_{b_i}}, … always ends with -1.
def func_12():
    n = func_1()
    a = func_6()
    b = func_6()
    l = [0] * n
    for i in range(n):
        if b[i] > 0:
            l[b[i] - 1] += a[i]
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\); `a` is a list of integers; `b` is a list of integers such that \(1 \leq b_i \leq n\) or \(b_i = -1\), and the sequence \(b_i, b_{b_i}, b_{b_{b_i}}, \ldots\) always ends with \(-1\); `b` is the output of `func_6()`, `l` is a list of `n` zeros where for each positive integer in `b`, the corresponding index in `l` (adjusted by subtracting 1) is incremented by the value from `a`.
    l1 = []
    for i in range(n):
        l1.append([l[i], i])
        
    #State of the program after the  for loop has been executed: `i` is `n`, `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\), `b` is a list of integers such that each element is either a positive integer between 1 and `n` or `-1`, and the sequence defined by `b_i, b_{b_i}, b_{b_{b_i}}, ...` always ends with `-1`, `a` is a list of integers, `l` is a list of `n` zeros, `l1` is a list containing `[0, i]` for each `i` from `0` to `n-1`.
    l1.sort()
    ans = 0
    l2 = []
    for i in range(n):
        l2.append(l1[i][1] + 1)
        
        if b[l1[i][1]] > 0:
            ans += a[l1[i][1]]
        
        a[l1[i][1]] += l1[i][0]
        
    #State of the program after the  for loop has been executed: 
    func_13(ans)
    func_13(*l2)
#Overall this is what the function does:The function `func_12` takes three inputs: `n`, `a`, and `b`. Here, `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\), `a` is a list of integers with values ranging from \(-10^6 \leq a_i \leq 10^6\), and `b` is a list of integers where each element is either a positive integer between 1 and `n` or \(-1\), with the sequence defined by `b_i, b_{b_i}, b_{b_{b_i}}, \ldots` always ending with \(-1\).

The function performs the following actions:
1. It initializes a list `l` of length `n` filled with zeros.
2. For each valid index `i` in `b` (i.e., where `b[i] > 0`), it updates `l[b[i] - 1]` by adding the corresponding value from `a`.
3. It then constructs a list `l1` which contains pairs of elements from `l` and their indices.
4. `l1` is sorted based on the first element of each pair.
5. It initializes `ans` to 0 and creates a new list `l2` to store the final indices.
6. For each element in the sorted `l1`, it updates `l2` by adding 1 to the index and adds to `ans` the product of the value from `a` at the current index and the value from `l` at the current index.
7. Finally, it increments the value in `a` at the current index by the value from `l` at the current index.
8. The function calls `func_13` twice: once with `ans` as an argument and once with the elements of `l2`.

After the function concludes, `func_13` is called with two arguments: the sum of certain products involving elements from `a` and `l`, and a list of adjusted indices based on the sorted values of `l` and `b`.

#Function 13:
#State of the program right berfore the function call: args is a variable-length argument list containing integers representing the values to be printed. kwargs is a dictionary containing keyword arguments where sep is the string inserted between values, file is the file object (default is sys.stdout), end is the string appended after the last value (default is a newline), flush is a boolean indicating whether to forcibly flush the stream (default is False).
def func_13():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a variable-length argument list containing integers, `at_start` is `False`, `file` contains the concatenated string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: `args` is a variable-length argument list containing integers, `at_start` is `False`, `file` contains the concatenated string representations of all elements in `args` separated by `sep` followed by `\n`. If `kwargs.pop('flush', False)` is `True`, then `file.flush()` has been called. Otherwise, no changes are made to the file.
#Overall this is what the function does:The function `func_13` accepts a variable-length argument list `args` containing integers and a dictionary `kwargs` with optional parameters `sep`, `file`, `end`, and `flush`. It prints the integers in `args` to the specified output stream (`file`, defaulting to `sys.stdout`) using the specified separator (`sep`, defaulting to a space), ending the output with the specified string (`end`, defaulting to a newline). If `flush` is set to `True`, it forces the output buffer to be flushed. After execution, `file` will contain the concatenated string representations of all elements in `args` separated by `sep` and ended with `end`. If `flush` is `True`, the buffer is flushed. Potential edge cases include empty `args` or `kwargs` dictionaries, and non-integer values in `args`.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
