
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Captain Fint is involved in another treasure hunt, but have found only one strange problem. The problem may be connected to the treasure's location or may not. That's why captain Flint decided to leave the solving the problem to his crew and offered an absurdly high reward: one day off. The problem itself sounds like this...

There are two arrays a and b of length n. Initially, an ans is equal to 0 and the following operation is defined: 

  1. Choose position i (1 ≤ i ≤ n); 
  2. Add a_i to ans; 
  3. If b_i ≠ -1 then add a_i to a_{b_i}. 



What is the maximum ans you can get by performing the operation on each i (1 ≤ i ≤ n) exactly once?

Uncle Bogdan is eager to get the reward, so he is asking your help to find the optimal order of positions to perform the operation on them.

Input

The first line contains the integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of arrays a and b.

The second line contains n integers a_1, a_2, …, a_n (−10^6 ≤ a_i ≤ 10^6).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ n or b_i = -1).

Additional constraint: it's guaranteed that for any i (1 ≤ i ≤ n) the sequence b_i, b_{b_i}, b_{b_{b_i}}, … is not cyclic, in other words it will always end with -1.

Output

In the first line, print the maximum ans you can get.

In the second line, print the order of operations: n different integers p_1, p_2, …, p_n (1 ≤ p_i ≤ n). The p_i is the position which should be chosen at the i-th step. If there are multiple orders, print any of them.

Examples

Input


3
1 2 3
2 3 -1


Output


10
1 2 3 


Input


2
-1 100
2 -1


Output


99
2 1 


Input


10
-10 -1 2 2 5 -2 -3 -4 2 -6
-1 -1 2 2 -1 5 5 7 7 9


Output


-9
3 5 6 1 9 4 10 7 8 2
Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return float(input())

#Function 3:
def func_3():
    return input()

#Function 4:
def func_4():
    return map(str, input().split())

#Function 5:
def func_5():
    return map(int, input().split())

#Function 6:
def func_6():
    return list(func_5())

#Function 7:
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
def func_8(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 9:
def func_9(x, y):
    return x * y // func_8(x, y)

#Function 10:
def func_10(b, m):
    g = func_8(b, m)
    if g != 1:
        return -1
    else:
        return pow(b, m - 2, m)

#Function 11:
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if inv == -1:
        return -999999999
    else:
        return inv * a % m

#Function 12:
def func_12():
    n = func_1()
    a = func_6()
    b = func_6()
    l = [0] * n
    for i in range(n):
        if b[i] > 0:
            l[b[i] - 1] += a[i]
    l1 = []
    for i in range(n):
        l1.append([l[i], i])
    l1.sort()
    ans = 0
    l2 = []
    for i in range(n):
        l2.append(l1[i][1] + 1)
        if b[l1[i][1]] > 0:
            ans += a[l1[i][1]]
        a[l1[i][1]] += l1[i][0]
    func_13(ans)
    func_13(*l2)

#Function 13:
def func_13(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **True**

### Explanation:

The provided Python program correctly implements the logic to find the maximum value of `ans` by choosing the optimal order of positions `i` to perform the operation. Here’s a breakdown of why the program is correct:

1. **Initialization**: The program initializes the necessary variables and lists correctly.
2. **Graph Representation**: It uses an array `l` to store the cumulative sums based on the indices specified in array `b`.
3. **Sorting and Accumulation**: It sorts the list `l1` to ensure that elements are processed in the order that maximizes the addition of `a[i]` to `ans`.
4. **Result Calculation**: The program calculates `ans` by adding `a[i]` to `ans` if `b[i]` is not `-1`, and updates `a[i]` accordingly.
5. **Output**: The program prints the maximum `ans` and the order of operations correctly.

The additional functions (1-13) provided in the code seem to be utility functions or placeholders and do not affect the main logic of the solution. The main function `func_12` handles the core logic correctly based on the problem description.

Since the provided program correctly follows the problem description and handles all given constraints without any issues, the correctness is **True**.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *

"""
// Author : snape_here - Susanta Mukherjee
     
 """
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
mod = 1000000007
getcontext().prec = 25
abc = 'abcdefghijklmnopqrstuvwxyz'
pi = 3.141592653589793
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_7(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_12()

#Function 1:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer a_i satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i either equals -1 or is a valid index such that 1 ≤ b_i ≤ n.
def func_1():
    return int(input())
    #The program returns an integer input provided by the user

#Function 2:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i is either a positive integer such that 1 ≤ b_i ≤ n or -1.
def func_2():
    return float(input())
    #The program waits for user input and returns the input as a float

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer a_i satisfies -10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer b_i satisfies 1 ≤ b_i ≤ n or b_i = -1.
def func_3():
    return input()
    #The program returns input from the user

#Function 4:
#State of the program right berfore the function call: None of the variables' values are described within the function signature. However, the function does not take any parameters and its purpose seems to read input from stdin. The input format is expected to follow the problem description's constraints and format.
def func_4():
    return map(str, input().split())
    #The program returns a map object containing strings converted from the input split by spaces

#Function 5:
#State of the program right berfore the function call: The function does not take any parameters, but it reads input from stdin. The first line of input is an integer n (1 ≤ n ≤ 2 ⋅ 10^5), followed by two lines of space-separated integers representing arrays a and b as described in the problem statement.
def func_5():
    return map(int, input().split())
    #The program returns a map object containing integers from the second line of input split by spaces

#Function 6:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of n integers where each integer satisfies −10^6 ≤ a_i ≤ 10^6, and b is a list of n integers where each integer is either a positive integer satisfying 1 ≤ b_i ≤ n or -1. It is also guaranteed that for any i (1 ≤ i ≤ n), the sequence b_i, b_{b_i}, b_{b_{b_i}}, … ends with -1.
def func_6():
    return list(func_5())
    #The program returns a list generated by func_5(), but the specific content of this list cannot be determined without knowing the implementation of func_5()

#Function 7:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5. a is a list of integers of length n where each integer satisfies -10^6 ≤ a_i ≤ 10^6. b is a list of integers of length n where each b_i is either a positive integer such that 1 ≤ b_i ≤ n or -1. It is guaranteed that for any i (1 ≤ i ≤ n), the sequence b_i, b_{b_i}, b_{b_{b_i}}, … ends with -1.
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
#State of the program right berfore the function call: x and y are integers, and y is not zero (y != 0).
def func_8(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0.
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, given that y is 0

#Function 9:
#State of the program right berfore the function call: x and y are integers.
def func_9(x, y):
    return x * y // func_8(x, y)
    #The program returns the integer result of x multiplied by y, then performing integer division by the result of the function func_8(x, y)

#Function 10:
#State of the program right berfore the function call: b is an integer such that 1 < b < 2 * 10^5 and is coprime with m, and m is an integer such that m > 1.
def func_10(b, m):
    g = func_8(b, m)
    if (g != 1) :
        return -1
        #The program returns -1
    else :
        return pow(b, m - 2, m)
        #The program returns the value of \( b^{m-2} \mod m \), where \( b \) is an integer such that \( 1 < b < 2 \times 10^5 \) and is coprime with \( m \), and \( m \) is an integer such that \( m > 1 \)

#Function 11:
#State of the program right berfore the function call: a is an integer representing an element from array a, b is an integer representing an element from array b, and m is a positive integer representing the modulus.
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if (inv == -1) :
        return -999999999
        #The program returns -999999999
    else :
        return inv * a % m
        #`The program returns (inv * a) % m` where `inv` is the return value of `func_10(b, m)` and `a` is `a % m`

#Function 12:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, a is a list of integers such that -10^6 ≤ a_i ≤ 10^6, b is a list of integers such that 1 ≤ b_i ≤ n or b_i = -1, and the sequence b_i, b_{b_i}, b_{b_{b_i}}, … always ends with -1.
def func_12():
    n = func_1()
    a = func_6()
    b = func_6()
    l = [0] * n
    for i in range(n):
        if b[i] > 0:
            l[b[i] - 1] += a[i]
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\); `a` is a list of integers; `b` is a list of integers such that \(1 \leq b_i \leq n\) or \(b_i = -1\), and the sequence \(b_i, b_{b_i}, b_{b_{b_i}}, \ldots\) always ends with \(-1\); `b` is the output of `func_6()`, `l` is a list of `n` zeros where for each positive integer in `b`, the corresponding index in `l` (adjusted by subtracting 1) is incremented by the value from `a`.
    l1 = []
    for i in range(n):
        l1.append([l[i], i])
        
    #State of the program after the  for loop has been executed: `i` is `n`, `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\), `b` is a list of integers such that each element is either a positive integer between 1 and `n` or `-1`, and the sequence defined by `b_i, b_{b_i}, b_{b_{b_i}}, ...` always ends with `-1`, `a` is a list of integers, `l` is a list of `n` zeros, `l1` is a list containing `[0, i]` for each `i` from `0` to `n-1`.
    l1.sort()
    ans = 0
    l2 = []
    for i in range(n):
        l2.append(l1[i][1] + 1)
        
        if b[l1[i][1]] > 0:
            ans += a[l1[i][1]]
        
        a[l1[i][1]] += l1[i][0]
        
    #State of the program after the  for loop has been executed: 
    func_13(ans)
    func_13(*l2)

#Function 13:
#State of the program right berfore the function call: args is a variable-length argument list containing integers representing the values to be printed. kwargs is a dictionary containing keyword arguments where sep is the string inserted between values, file is the file object (default is sys.stdout), end is the string appended after the last value (default is a newline), flush is a boolean indicating whether to forcibly flush the stream (default is False).
def func_13():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a variable-length argument list containing integers, `at_start` is `False`, `file` contains the concatenated string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: `args` is a variable-length argument list containing integers, `at_start` is `False`, `file` contains the concatenated string representations of all elements in `args` separated by `sep` followed by `\n`. If `kwargs.pop('flush', False)` is `True`, then `file.flush()` has been called. Otherwise, no changes are made to the file.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
