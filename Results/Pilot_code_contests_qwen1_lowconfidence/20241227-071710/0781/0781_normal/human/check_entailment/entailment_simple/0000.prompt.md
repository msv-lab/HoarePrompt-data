
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Pinkie Pie has bought a bag of patty-cakes with different fillings! But it appeared that not all patty-cakes differ from one another with filling. In other words, the bag contains some patty-cakes with the same filling.

Pinkie Pie eats the patty-cakes one-by-one. She likes having fun so she decided not to simply eat the patty-cakes but to try not to eat the patty-cakes with the same filling way too often. To achieve this she wants the minimum distance between the eaten with the same filling to be the largest possible. Herein Pinkie Pie called the distance between two patty-cakes the number of eaten patty-cakes strictly between them.

Pinkie Pie can eat the patty-cakes in any order. She is impatient about eating all the patty-cakes up so she asks you to help her to count the greatest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating!

Pinkie Pie is going to buy more bags of patty-cakes so she asks you to solve this problem for several bags!

Input

The first line contains a single integer T (1 ≤ T ≤ 100): the number of bags for which you need to solve the problem.

The first line of each bag description contains a single integer n (2 ≤ n ≤ 10^5): the number of patty-cakes in it. The second line of the bag description contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ n): the information of patty-cakes' fillings: same fillings are defined as same integers, different fillings are defined as different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling. 

It is guaranteed that the sum of n over all bags does not exceed 10^5.

Output

For each bag print in separate line one single integer: the largest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating for that bag.

Example

Input


4
7
1 7 1 6 4 4 6
8
1 1 4 6 4 6 4 7
3
3 3 3
6
2 5 2 3 1 4


Output


3
2
0
4

Note

For the first bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 6, 4, 7, 1, 6, 4 (in this way, the minimum distance is equal to 3).

For the second bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 4, 6, 7, 4, 1, 6, 4 (in this way, the minimum distance is equal to 2).
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *

"""
// Author : snape_here - Susanta Mukherjee
     
 """
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
mod = 1000000007
getcontext().prec = 25
abc = 'abcdefghijklmnopqrstuvwxyz'
pi = 3.141592653589793
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_7(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_12()

#Function 1:
#State of the program right berfore the function call: T is an integer representing the number of bags, and the subsequent lines contain descriptions of each bag, where the first line of each bag description contains an integer n representing the number of patty-cakes in the bag, followed by a line containing n integers representing the fillings of the patty-cakes. Each integer a_i represents the filling type, and the same fillings are defined as same integers, different fillings as different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling, and the sum of n over all bags does not exceed 10^5.
def func_1():
    return int(input())
    #The program returns an integer representing the number of bags, which is the value input by the user

#Function 2:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 100, n is an integer such that 2 ≤ n ≤ 10^5, and a is a list of n integers where each integer a_i satisfies 1 ≤ a_i ≤ n.
def func_2():
    return float(input())
    #The program returns a float input from the user

#Function 3:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 100, and for each bag described by the subsequent inputs: n is an integer such that 2 ≤ n ≤ 10^5, and a is a list of n integers such that 1 ≤ a_i ≤ n and there exists at least two indices i and j such that i ≠ j and a_i = a_j.
def func_3():
    return input()
    #The program returns the input provided by the user

#Function 4:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 100, and for each bag, n is an integer such that 2 ≤ n ≤ 10^5, and the following line contains n integers a_1, a_2, …, a_n such that 1 ≤ a_i ≤ n and there exists at least two indices i and j such that a_i = a_j.
def func_4():
    return map(str, input().split())
    #The program returns a map object containing strings of the input split by spaces, where the input consists of n integers a_1, a_2, …, a_n such that 1 ≤ a_i ≤ n and there exists at least two indices i and j such that a_i = a_j

#Function 5:
#State of the program right berfore the function call: T is an integer representing the number of bags, and for each bag: n is an integer representing the number of patty-cakes in the bag, followed by a line of n space-separated integers representing the fillings of the patty-cakes. Each bag description is separated by a newline.
def func_5():
    return map(int, input().split())
    #The program returns a map object containing integers converted from user input split by spaces

#Function 6:
#State of the program right berfore the function call: There is no information about the variables used in this function, and the function does not take any arguments or return any values related to the problem description. Therefore, we cannot provide a meaningful precondition based on the given function signature alone.
def func_6():
    return list(func_5())
    #The program returns a list generated by the function `func_5()`

#Function 7:
#State of the program right berfore the function call: T is a positive integer such that 1 <= T <= 100, representing the number of bags. Each bag is described with two lines: the first line contains a positive integer n such that 2 <= n <= 10^5, representing the number of patty-cakes in the bag; the second line contains n positive integers a_1, a_2, ..., a_n such that 1 <= a_i <= n, representing the fillings of the patty-cakes, where the same fillings are represented by the same integers and different fillings by different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling. The sum of n over all bags does not exceed 10^5.
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
#State of the program right berfore the function call: x and y are non-negative integers where y is not zero.
def func_8(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x which is the greatest common divisor (GCD) of the original values of x and y, and y is 0

#Function 9:
#State of the program right berfore the function call: x and y are positive integers.
def func_9(x, y):
    return x * y // func_8(x, y)
    #The program returns the integer division of x * y by func_8(x, y)

#Function 10:
#State of the program right berfore the function call: b is a positive integer, and m is a positive integer such that m > b.
def func_10(b, m):
    g = func_8(b, m)
    if (g != 1) :
        return -1
        #The program returns -1
    else :
        return pow(b, m - 2, m)
        #The program returns b raised to the power of (m-2) modulo m

#Function 11:
#State of the program right berfore the function call: a is an integer, b is an integer, and m is a positive integer (m > 0).
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if (inv == -1) :
        return -999999999
        #The program returns -999999999
    else :
        return inv * a % m
        #`inv * a % m`, where `inv` is the value returned by `func_10(b, m)` and `a` is the remainder when `a` is divided by `m`

#Function 12:
#State of the program right berfore the function call: T is an integer representing the number of bags, n is an integer representing the number of patty-cakes in a bag, and a is a list of integers where each integer represents the filling of a patty-cake. Additionally, each bag contains at least two patty-cakes with the same filling, and the sum of n over all bags does not exceed 10^5.
def func_12():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_6()
        
        a.sort(reverse=True)
        
        f = [0] * 100005
        
        for i in range(n):
            f[a[i]] += 1
        
        s = 0
        
        s = max(f)
        
        if s == n:
            func_13(0)
            continue
        
        if f.count(1) == n - s:
            if s == 2:
                ans = n - s
            else:
                ans = (n - 1) // (s + 1)
                ans += 1
            func_13(ans)
            continue
        
        ans = (n - 1) // (s + 1)
        
        ans += 1
        
        func_13(ans)
        
    #State of the program after the  for loop has been executed: T is an integer representing the number of bags, `n` is the number of patty-cakes processed in the last iteration, `a` is a list of integers representing the fillings of patty-cakes, `f` is an array of 100005 elements where each element at index `a[i]` for `0 <= i < n` is the count of occurrences of `a[i]`, `s` is the maximum value in `f`, `ans` is the final result computed based on the conditions inside the loop, and `func_1()`, `func_6()`, and `func_13()` are functions whose exact behavior is not specified.

#Function 13:
#State of the program right berfore the function call: args is a variable-length argument list containing the values to be printed, sep is a string representing the separator between values (default is a space), file is an object with a write method to which the values will be written (default is sys.stdout), end is a string to be written after the last value (default is a newline), and flush is a boolean indicating whether the output stream should be flushed after writing (default is False).
def func_13():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is the list of arguments, `sep` is `' '`, `file` is `sys.stdout`, `at_start` is `False`, `end` retains its previous value, `flush` retains its previous value, all elements of `args` have been written to `sys.stdout` separated by spaces.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: `args` is a list of arguments, `sep` is ' ', `file` is sys.stdout, `at_start` is False, `end` is '\n'. If the key 'flush' exists in `kwargs` and its value is True, then `flush` is True. Otherwise, `flush` retains its previous value.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
