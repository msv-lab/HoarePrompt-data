
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A colored stripe is represented by a horizontal row of n square cells, each cell is pained one of k colors. Your task is to repaint the minimum number of cells so that no two neighbouring cells are of the same color. You can use any color from 1 to k to repaint the cells.

Input

The first input line contains two integers n and k (1 ≤ n ≤ 5·105; 2 ≤ k ≤ 26). The second line contains n uppercase English letters. Letter "A" stands for the first color, letter "B" stands for the second color and so on. The first k English letters may be used. Each letter represents the color of the corresponding cell of the stripe.

Output

Print a single integer — the required minimum number of repaintings. In the second line print any possible variant of the repainted stripe.

Examples

Input

6 3
ABBACC


Output

2
ABCACA


Input

3 2
BBB


Output

1
BAB
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import string

#State of the program right berfore the function call: n and k are integers such that 1 ≤ n ≤ 5·10^5 and 2 ≤ k ≤ 26. The second input line is a string of length n consisting of k distinct uppercase English letters, where each letter represents the color of the corresponding cell in the stripe.
def func():
    n, k = map(int, raw_input().split())
    s = raw_input()
    alpha = string.uppercase[:k]
    ans1 = list(s)
    ans2 = list(s)
    rec1, rec2 = 0, 0
    for i in range(0, len(s), 2):
        neigh = ()
        
        if i > 0:
            neigh += s[i - 1],
        
        if i < n - 1:
            neigh += s[i + 1],
        
        if i > 0 and s[i] == s[i - 1] or i < n - 1 and s[i] == s[i + 1]:
            for c in alpha:
                if c not in neigh:
                    chosen = c
                    break
            else:
                break
            ans1[i] = chosen
            rec1 += 1
        
    #State of the program after the  for loop has been executed: `n` is an integer, `k` is an integer, `s` is a string of length `n`, `alpha` is the first `k` uppercase English letters, `ans1` is a list of `n` elements where each element is a character from `s`, `ans2` is a list of `n` elements where each element is a character from `s`, `rec1` is the total number of times the inner loop executed (incremented by 1 if `i > 0 and s[i] == s[i - 1] or (i < n - 1 and s[i] == s[i + 1])` for any `i` from 0 to `len(s) - 1`), `rec2` is 0, and `neigh` is a tuple containing the characters `s[i - 1]` and `s[i + 1]` if `i > 0` and `i < n - 1`, only `s[i - 1]` if `i == 0`, and only `s[i + 1]` if `i == n - 1`. If the condition `i > 0 and s[i] == s[i - 1] or (i < n - 1 and s[i] == s[i + 1])` is true for any `i`, then `ans1[i]` is set to `chosen`. Otherwise, `ans1[i]` retains its original value.
    for i in range(1, len(s), 2):
        neigh = ()
        
        if i > 0:
            neigh += s[i - 1],
        
        if i < n - 1:
            neigh += s[i + 1],
        
        if i > 0 and s[i] == s[i - 1] or i < n - 1 and s[i] == s[i + 1]:
            for c in alpha:
                if c not in neigh:
                    chosen = c
                    break
            else:
                break
            ans2[i] = chosen
            rec2 += 1
        
    #State of the program after the  for loop has been executed: `n` is an integer, `k` is an integer, `s` is a string of length `n`, `alpha` is the first `k` uppercase English letters, `ans1` is a list of `n` elements where each element is a character from `s`, `ans2` is a list of `n` elements where each element is a character from `s`, `rec1` is the total number of times the inner loop executed, `rec2` is either 0 or the number of times the condition `i > 0 and s[i] == s[i - 1] or (i < n - 1 and s[i] == s[i + 1])` was met, `neigh` is a tuple containing characters from which no character in `alpha` is excluded, and `i` is the last executed index in the loop. If the condition `i > 0 and s[i] == s[i - 1] or (i < n - 1 and s[i] == s[i + 1])` is true for any `i`, then `ans2[i]` is a character from `s` that is not in `neigh`, and `rec2` is incremented accordingly. Otherwise, `ans2` remains unchanged for those indices.
    valid1 = True
    for i in range(1, len(ans1)):
        if ans1[i] == ans1[i - 1]:
            valid1 = False
            break
        
    #State of the program after the  for loop has been executed: `i` is `len(ans1) - 1`, `len(ans1)` is at least 2, and `valid1` is `False` if at any point `ans1[i]` equals `ans1[i - 1]`, otherwise `valid1` retains its original value (`True` if no such `i` exists).
    valid2 = True
    for i in range(1, len(ans2)):
        if ans2[i] == ans2[i - 1]:
            valid2 = False
            break
        
    #State of the program after the  for loop has been executed: `ans2` is a list of elements, `i` is an index such that `1 <= i < len(ans2)`, and `valid2` is `False` if a duplicate element is found in `ans2`, otherwise `valid2` is `True`.
    if (rec1 < rec2 and valid1 or not valid2) :
        print(rec1)
        print(''.join(ans1))
    else :
        print(rec2)
        print(''.join(ans2))
    #State of the program after the if-else block has been executed: *`ans2` is a list of elements, `i` is an index such that `1 <= i < len(ans2)`, and `valid2` is `False` if a duplicate element is found in `ans2`, otherwise `valid2` is `True`. If `rec1 < rec2` and `valid1` is `True` or `not valid2` is `True`, then `rec1` is printed, and there is a NameError due to the undefined variable `ans1`. Otherwise, `rec2` is printed, and the string `''.join(ans2)` is printed.

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
