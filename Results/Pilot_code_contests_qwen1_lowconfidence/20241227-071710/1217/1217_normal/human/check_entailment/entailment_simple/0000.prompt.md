
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex i is equal to ai.

Ilya believes that the beauty of the vertex x is the greatest common divisor of all numbers written on the vertices on the path from the root to x, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.

For each vertex the answer must be considered independently.

The beauty of the root equals to number written on it.

Input

First line contains one integer number n — the number of vertices in tree (1 ≤ n ≤ 2·105).

Next line contains n integer numbers ai (1 ≤ i ≤ n, 1 ≤ ai ≤ 2·105).

Each of next n - 1 lines contains two integer numbers x and y (1 ≤ x, y ≤ n, x ≠ y), which means that there is an edge (x, y) in the tree.

Output

Output n numbers separated by spaces, where i-th number equals to maximum possible beauty of vertex i.

Examples

Input

2
6 2
1 2


Output

6 6 


Input

3
6 2 3
1 2
1 3


Output

6 6 6 


Input

1
10


Output

10 
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
n = int(raw_input())
a = map(int, raw_input().split())
graph = [[] for _ in range(n)]
for i in xrange(n - 1):
    (x, y) = map(int, raw_input().split())
    x -= 1
    y -= 1
    graph[x].append(y)
    graph[y].append(x)
class Info:

    def __init__(self):
        self.gcd = 0
        self.tor1 = 0
        self.ifr1 = 0
        self.tor2 = 0
        self.ifr2 = 0

    def get(self):
        r = self.gcd
        if self.ifr1 > r:
            r = self.ifr1
        if self.ifr2 > r:
            r = self.ifr2
        return r
visited = [False] * n
gcdinfo = [Info() for _ in xrange(n)]
gcdinfo[0].gcd = a[0]
gcdinfo[0].tor1 = a[0]
gcdinfo[0].ifr1 = 0
func_2(0, -1)
s = ''
for i in xrange(n):
    s += str(gcdinfo[i].get()) + ' '
print(s)

#Function 1:
#State of the program right berfore the function call: a and b are positive integers.
def func_1(a, b):
    return a if b == 0 else func_1(b, a % b)
    #The program returns `a` if `b` is 0, otherwise it returns the result of `func_1(b, a % b)` where `a % b` is the remainder when `a` is divided by `b`

#Function 2:
#State of the program right berfore the function call: `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, and `visited` is a boolean list used for tracking visited nodes. Each element of `gcdinfo` is an object with attributes `gcd`, `tor1`, `ifr1`, `tor2`, and `ifr2`, where `gcd` is the greatest common divisor, and `tor1` and `ifr1`/`tor2` and `ifr2` are used to track potential changes to maximize the gcd.
def func_2(n, parent):
    if visited[n] :
        return
        #The program does not return any value since no return statement is provided in the code snippet.
    #State of the program after the if block has been executed: `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, and `visited` is a boolean list used for tracking visited nodes. Each element of `gcdinfo` is an object with attributes `gcd`, `tor1`, `ifr1`, `tor2`, and `ifr2`. The node `n` is not visited.
    visited[n] = True
    if (parent != -1) :
        newgcd = func_1(gcdinfo[parent].gcd, a[n])
        gcdinfo[n].gcd = newgcd
        if (newgcd < gcdinfo[parent].gcd) :
            gcdinfo[n].tor1 = a[n]
            gcdinfo[n].ifr1 = gcdinfo[parent].gcd
            if (gcdinfo[parent].ifr1 == 0) :
                gcdinfo[n].tor2 = gcdinfo[parent].gcd
                gcdinfo[n].ifr2 = a[n]
            #State of the program after the if block has been executed: *`newgcd` is the result of `func_1(gcdinfo[parent].gcd, a[n])` and is less than `gcdinfo[parent].gcd`; `n` is an integer representing the number of vertices in the tree; `parent` is an integer representing the parent of the current node in the recursive call; `a` is a list of integers where `a[i]` is the integer number written on vertex `i`; `graph` is a list of lists representing the adjacency list of the tree; `visited` is a boolean list used for tracking visited nodes; `visited[n]` is `True`; `gcdinfo[n].gcd` is equal to `newgcd`; `gcdinfo[n].tor1` is equal to `a[n]`; `gcdinfo[n].ifr1` is equal to `0` or `gcdinfo[parent].gcd` depending on the condition; `gcdinfo[n].tor2` is `0`; `gcdinfo[n].ifr2` is equal to `a[n]`.
        else :
            if gcdinfo[parent].ifr1 :
                newgcd1 = func_1(gcdinfo[parent].ifr1, a[n])
            else :
                newgcd1 = 1
            #State of the program after the if-else block has been executed: `newgcd` is the result of `func_1(gcdinfo[parent].ifr1, a[n])` if `gcdinfo[parent].ifr1` is `True`. Otherwise, `newgcd` is 1. Additionally, `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list used for tracking visited nodes, `visited[n]` is `True`, and `gcdinfo[n].gcd` is equal to `newgcd`.
            if gcdinfo[parent].ifr2 :
                newgcd2 = func_1(gcdinfo[parent].ifr2, a[n])
            else :
                newgcd2 = 1
            #State of the program after the if-else block has been executed: *`newgcd` is the greatest common divisor (GCD) of `a[n]` and either `gcdinfo[parent].ifr1` or `gcdinfo[parent].ifr2` depending on their respective conditions. Specifically, if `gcdinfo[parent].ifr1` is `True`, `newgcd` is the result of `func_1(gcdinfo[parent].ifr1, a[n])`. If `gcdinfo[parent].ifr2` is `True`, `newgcd` is the result of `func_1(gcdinfo[parent].ifr2, a[n])`. Otherwise, `newgcd` is 1. `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list used for tracking visited nodes, with `visited[n]` being `True`, and `gcdinfo[n].gcd` is equal to `newgcd`.
            if (newgcd1 > newgcd2) :
                gcdinfo[n].tor1 = gcdinfo[parent].tor1
                gcdinfo[n].ifr1 = gcdinfo[parent].ifr1
            else :
                if (newgcd2 > newgcd1) :
                    gcdinfo[n].tor1 = gcdinfo[parent].tor2
                    gcdinfo[n].ifr1 = gcdinfo[parent].ifr2
                #State of the program after the if block has been executed: *`newgcd` is the GCD of `a[n]` and either `gcdinfo[parent].ifr1` or `gcdinfo[parent].ifr2` depending on their respective conditions. If `newgcd2 > newgcd1`, then `gcdinfo[n].ifr1` is equal to `gcdinfo[parent].ifr2`. In both cases, `gcdinfo[n].gcd` is equal to `newgcd`, `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list used for tracking visited nodes, with `visited[n]` being `True`, and `gcdinfo[n].tor1` is equal to `gcdinfo[parent].tor2`.
            #State of the program after the if-else block has been executed: *`newgcd` is the GCD of `a[n]` and either `gcdinfo[parent].ifr1` or `gcdinfo[parent].ifr2` depending on their respective conditions. If `newgcd1 > newgcd2`, then `gcdinfo[n].ifr1` is equal to `gcdinfo[parent].ifr1`, `gcdinfo[n].tor1` is equal to `gcdinfo[parent].tor1`, and `gcdinfo[n].ifr2` is kept as `gcdinfo[parent].ifr2`. Otherwise, `gcdinfo[n].ifr1` is equal to `gcdinfo[parent].ifr2`, `gcdinfo[n].tor1` is equal to `gcdinfo[parent].tor2`, and `gcdinfo[n].ifr2` is kept as `gcdinfo[parent].ifr1`. In both cases, `gcdinfo[n].gcd` is equal to `newgcd`, `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list used for tracking visited nodes, with `visited[n]` being `True`.
        #State of the program after the if-else block has been executed: *`newgcd` is the result of `func_1(gcdinfo[parent].gcd, a[n])`. If `newgcd < gcdinfo[parent].gcd`, then `gcdinfo[n].gcd` is set to `newgcd`, `gcdinfo[n].tor1` is set to `a[n]`, `gcdinfo[n].ifr1` is set to `0` or `gcdinfo[parent].gcd`, and `gcdinfo[n].ifr2` is set to `0`. Otherwise, `gcdinfo[n].gcd` is set to `newgcd`, which is the GCD of `a[n]` and either `gcdinfo[parent].ifr1` or `gcdinfo[parent].ifr2` depending on their respective conditions, `gcdinfo[n].tor1` is set to `gcdinfo[parent].tor1` or `gcdinfo[parent].tor2` accordingly, and `gcdinfo[n].ifr1` and `gcdinfo[n].ifr2` are updated as specified. `n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list used for tracking visited nodes, and `visited[n]` is `True`.
    #State of the program after the if block has been executed: *`n` is an integer representing the number of vertices in the tree, `parent` is an integer representing the parent of the current node in the recursive call, `a` is a list of integers where `a[i]` is the integer number written on vertex `i`, `graph` is a list of lists representing the adjacency list of the tree, `visited` is a boolean list used for tracking visited nodes, and `visited[n]` is `True`. If `parent != -1`, then `gcdinfo[n].gcd` is updated based on the new GCD calculation involving `gcdinfo[parent].gcd` and `a[n]`, and `gcdinfo[n].tor1`, `gcdinfo[n].ifr1`, and `gcdinfo[n].ifr2` are set according to specific conditions. If `parent == -1`, no changes are made to `gcdinfo[n]`.
    for neigh in graph[n]:
        func_2(neigh, n)
        
    #State of the program after the  for loop has been executed: `graph[n]` must be an empty list, and for every `neigh` in `graph[n]`, `func_2(neigh, n)` has been called at least once.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
