
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Leha decided to move to a quiet town Vičkopolis, because he was tired by living in Bankopolis. Upon arrival he immediately began to expand his network of hacked computers. During the week Leha managed to get access to n computers throughout the town. Incidentally all the computers, which were hacked by Leha, lie on the same straight line, due to the reason that there is the only one straight street in Vičkopolis.

Let's denote the coordinate system on this street. Besides let's number all the hacked computers with integers from 1 to n. So the i-th hacked computer is located at the point xi. Moreover the coordinates of all computers are distinct. 

Leha is determined to have a little rest after a hard week. Therefore he is going to invite his friend Noora to a restaurant. However the girl agrees to go on a date with the only one condition: Leha have to solve a simple task.

Leha should calculate a sum of F(a) for all a, where a is a non-empty subset of the set, that consists of all hacked computers. Formally, let's denote A the set of all integers from 1 to n. Noora asks the hacker to find value of the expression <image>. Here F(a) is calculated as the maximum among the distances between all pairs of computers from the set a. Formally, <image>. Since the required sum can be quite large Noora asks to find it modulo 109 + 7.

Though, Leha is too tired. Consequently he is not able to solve this task. Help the hacker to attend a date.

Input

The first line contains one integer n (1 ≤ n ≤ 3·105) denoting the number of hacked computers.

The second line contains n integers x1, x2, ..., xn (1 ≤ xi ≤ 109) denoting the coordinates of hacked computers. It is guaranteed that all xi are distinct.

Output

Print a single integer — the required sum modulo 109 + 7.

Examples

Input

2
4 7


Output

3


Input

3
4 3 1


Output

9

Note

There are three non-empty subsets in the first sample test:<image>, <image> and <image>. The first and the second subset increase the sum by 0 and the third subset increases the sum by 7 - 4 = 3. In total the answer is 0 + 0 + 3 = 3.

There are seven non-empty subsets in the second sample test. Among them only the following subsets increase the answer: <image>, <image>, <image>, <image>. In total the sum is (4 - 3) + (4 - 1) + (3 - 1) + (4 - 1) = 9.
Program:
```
def func():
    n = int(raw_input())
    s = sorted(map(int, raw_input().split()))
    r = 0
    for i in xrange(n):
        r += s[i] * (2 ** (n - 1 - i) - 1 - (2 ** i - 1)) % (1000000000 + 7)
    print - r


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly implement the solution for the problem. Specifically, the calculation of `F(a)` and the summation over all non-empty subsets is incorrect. The formula used in the program does not accurately represent the maximum distance between pairs of computers for each subset.

To illustrate the issue, consider the second example provided:

- Input: `3 4 3 1`
- Expected output: `9`

However, the program incorrectly calculates the result. Let's manually compute the correct result:

- Non-empty subsets of `{4, 3, 1}` are:
  - `{4}`
  - `{3}`
  - `{1}`
  - `{4, 3}`
  - `{4, 1}`
  - `{3, 1}`
  - `{4, 3, 1}`

For each subset, the maximum distance (`F(a)`) is:
- `{4}`: 0
- `{3}`: 0
- `{1}`: 0
- `{4, 3}`: 1
- `{4, 1}`: 3
- `{3, 1}`: 2
- `{4, 3, 1}`: 3

Summing these values gives `0 + 0 + 0 + 1 + 3 + 2 + 3 = 9`.

The program, however, does not correctly compute these values and hence fails to produce the correct output.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 3·10^5, and the second line contains n integers x1, x2, ..., xn such that 1 ≤ xi ≤ 10^9 and all xi are distinct.
def func():
    n = int(raw_input())
    s = sorted(map(int, raw_input().split()))
    r = 0
    for i in xrange(n):
        r += s[i] * (2 ** (n - 1 - i) - 1 - (2 ** i - 1)) % (1000000000 + 7)
        
    #State of the program after the  for loop has been executed: Let's analyze the given loop step by step to determine the final output state after all iterations of the loop have finished.
    #
    #### Initial State
    #- \( n \) is an integer such that \( 1 \leq n \leq 3 \times 10^5 \).
    #- \( s \) is a sorted list of integers.
    #- \( r \) is 0.
    #
    #### Loop Code
    #```python
    #for i in range(n):
    #    r += s[i] * (2 ** (n - 1 - i) - 1 - (2 ** i - 1)) % (1000000000 + 7)
    #```
    #
    #### Analysis of the Loop
    #- The loop runs from \( i = 0 \) to \( i = n - 1 \).
    #- For each iteration, the value of \( r \) is updated based on the formula:
    #  \[
    #  r \leftarrow r + s[i] \times (2^{n-1-i} - 1 - (2^i - 1)) \mod (1000000000 + 7)
    #  \]
    #
    #### Simplification of the Formula
    #Let's simplify the expression inside the loop:
    #\[
    #2^{n-1-i} - 1 - (2^i - 1) = 2^{n-1-i} - 2^i
    #\]
    #This can be further simplified as:
    #\[
    #2^{n-1-i} - 2^i = 2^i (2^{n-2i-1} - 1)
    #\]
    #So, the update to \( r \) becomes:
    #\[
    #r \leftarrow r + s[i] \times 2^i (2^{n-2i-1} - 1) \mod (1000000000 + 7)
    #\]
    #
    #### Final Value of \( r \)
    #After all \( n \) iterations, \( r \) will be the sum of the terms:
    #\[
    #r = \sum_{i=0}^{n-1} s[i] \times 2^i (2^{n-2i-1} - 1) \mod (1000000000 + 7)
    #\]
    #
    #### Final Output State
    #- \( n \) remains the same as the initial value.
    #- \( s \) remains the same as the initial value.
    #- \( r \) is the sum of the terms described above.
    #
    #### Conclusion
    #The final output state after all iterations of the loop have finished is:
    #\[
    #\text{Output State: } n \text{ is an integer such that } 1 \leq n \leq 3 \times 10^5, \text{ } s \text{ is a sorted list of integers, } r \text{ is } \sum_{i=0}^{n-1} s[i] \times 2^i (2^{n-2i-1} - 1) \mod (1000000000 + 7).
    #\]
    print - r


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
