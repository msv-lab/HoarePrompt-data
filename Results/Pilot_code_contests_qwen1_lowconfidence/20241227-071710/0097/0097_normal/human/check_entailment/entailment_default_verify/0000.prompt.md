
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Program:
```
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys
#Function 1:
def func_1():
    import sys, re, math
    from collections import deque, defaultdict, Counter, OrderedDict
    from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, floor
    from heapq import heappush, heappop, heapify, nlargest, nsmallest








    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        zz = []
        for _ in range(n):
            zz.append(LIST())
        prevplay = 0
        prevClr = 0
        flag = 0
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        if flag == 1:
            print('NO')
        else:
            print('YES')
        t -= 1

#Function 2:
def STR():
    return list(input())

#Function 3:
def INT():
    return int(input())

#Function 4:
def MAP():
    return map(int, input().split())

#Function 5:
def LIST():
    return list(map(int, input().split()))

#Function 6:
def list2d(a, b, c):
    return [[c] * b for i in range(a)]

#Function 7:
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])

#Function 8:
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
    return toret

#Function 9:
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))

#Function 10:
def func_2(zero=0):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            i += 1
    except:
        pass
    if s and s[-1] >= b'0'[0]:
        A.append(sign * numb)
    return A


```
Original Assessment: Correctness: **False**

Explanation: The program does not correctly handle cases where the number of clears increases without an equal or greater increase in the number of plays. Specifically, the program checks if `zz[i][0] < prevplay` or `zz[i][1] < prevClr` or `zz[i][0] < zz[i][1]`, which are incorrect conditions. Instead, it should ensure that the number of plays never decreases and that the number of clears does not exceed the number of plays without a corresponding increase in plays.

For example, consider the following input:
```
3
10 10
10 11
10 12
```

In this case, the number of clears increases from 10 to 11 and then to 12, which is valid. However, the program incorrectly flags this as invalid because it checks if `zz[i][0] < prevplay` and finds that the number of plays does not change, thus triggering the flag.

To fix this, the condition should be checked as follows:
- Ensure `prevplay <= zz[i][0]`
- Ensure `prevClr <= zz[i][0]`
- Ensure `prevClr <= zz[i][1]`

The current implementation fails to correctly validate these conditions.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 10 : Functionality: The function `func_2` takes a parameter `zero` (although it is not used in the function), reads a byte string from standard input, processes it to convert characters to integers, and appends the resulting integers to a list `A`. After processing, the function appends an additional element `0` to the list `A` and returns it. 

- The function reads a byte string `s` from standard input.
- It initializes `numb` to `zero` and `sign` to `1`.
- It iterates over each character in `s`, converting digits to integers and appending them to `A` with the appropriate sign.
- If a `-` character is encountered, it sets `sign` to `-1`.
- If a newline character (`\r`) is not encountered, it appends the current number (`numb`) to `A` with the current sign and resets `numb` and `sign`.
- After the loop, if the last character of `s` is a digit, it appends the final number to `A`.
- Finally, the function returns the list `A` with an additional element `0` appended to it.

Potential edge cases and missing functionality:
- The function does not handle non-digit characters other than `-` and `\r` explicitly. Characters other than digits, `-`, and `\r` are ignored.
- The function assumes that the input is a valid byte string. If the input is not a byte string, the function may raise a `TypeError`.
- The function uses `sys.stdin.buffer.read()` to read the entire input at once, which could potentially cause issues with very large inputs.
- The function does not provide feedback or error handling for invalid input, such as non-byte string input or improperly formatted data.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
