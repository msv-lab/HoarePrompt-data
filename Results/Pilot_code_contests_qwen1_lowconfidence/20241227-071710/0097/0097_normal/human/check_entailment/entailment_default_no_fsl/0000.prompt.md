
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Functions with output description for each function:
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
class ostream:

    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
if __name__ == '__main__':
    func_1()

Function number 1 :
 Code:
 '''
def func_1():
    import sys, re, math
    from collections import deque, defaultdict, Counter, OrderedDict
    from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, floor
    from heapq import heappush, heappop, heapify, nlargest, nsmallest








    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        zz = []
        for _ in range(n):
            zz.append(LIST())
        prevplay = 0
        prevClr = 0
        flag = 0
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        if flag == 1:
            print('NO')
        else:
            print('YES')
        t -= 1
''' 

 Output hints for function1:  The function processes a series of test cases, each consisting of multiple moments when Polycarp checked his gaming statistics. For each test case, it verifies whether the statistics follow certain rules:
1. The number of plays (p_i) should always be greater than or equal to the previous number of plays (p_{i-1}).
2. The number of clears (c_i) should always be greater than or equal to the previous number of clears (c_{i-1}).
3. The number of clears (c_i) should never exceed the number of plays (p_i).
4. If the number of clears increases between two consecutive moments, the increase in clears should not exceed the increase in plays.

If any of these conditions are violated during the processing of a test case, the function prints 'NO' for that test case. Otherwise, it prints 'YES'. The function iterates through all test cases until `t` becomes zero. After executing the function, the state of the program will have `t` set to 0, and no further actions will be performed on the remaining variables.
Function number 2 :
 Code:
 '''
def STR():
    return list(input())
''' 

 Output hints for function2:  The function `STR()` reads input from the standard input for a given number of test cases. For each test case, it reads the number of moments Polycarp peeked at the stats (`n`), followed by `n` pairs of integers representing the number of plays (`p_i`) and clears (`c_i`) at each moment. The function then returns a list of strings, where each string represents the input for each test case in the format "n p_1 c_1 p_2 c_2 ... p_n c_n". This list contains one string per test case. The function does not modify any external state and only processes input and formats it as specified. Potential edge cases include handling invalid input (e.g., negative numbers or non-integer values) and ensuring that the input is read correctly for each test case. However, the provided code does not include any error handling for such cases.
Function number 3 :
 Code:
 '''
def INT():
    return int(input())
''' 

 Output hints for function3:  The function `INT()` reads an integer input from the user, ensuring it is within the range 1 ≤ T ≤ 500. If the input is outside this range, the function will continue to prompt the user until a valid input is received. After validation, the function returns the integer input.
Function number 4 :
 Code:
 '''
def MAP():
    return map(int, input().split())
''' 

 Output hints for function4:  The function accepts input from the user, specifically a positive integer `T` such that \(1 \leq T \leq 500\) representing the number of test cases, a positive integer `n` such that \(1 \leq n \leq 100\) representing the number of pairs, and `n` pairs of non-negative integers \((p_i, c_i)\) where \(0 \leq p_i, c_i \leq 1000\). The function then returns a tuple containing these inputs: \((T, n, p_i, c_i)\). The function ensures that the input values meet the specified constraints, and it processes the input in a single line using the `map` function. Potential edge cases include invalid inputs such as negative numbers or values outside the specified ranges, which would result in incorrect processing. The function does not handle any missing functionality beyond the basic requirement of accepting and returning the input as a tuple.
Function number 5 :
 Code:
 '''
def LIST():
    return list(map(int, input().split()))
''' 

 Output hints for function5:  The function accepts a single string input from the user, which should be formatted as a sequence of space-separated integers. It then splits the string by spaces, converts each segment to an integer, and returns a list of these integers. This process ensures that any valid input string following the specified format will be correctly transformed into a list of integers. Potential edge cases include empty strings or strings with no integers, which would result in an empty list. Additionally, the function assumes the input strictly follows the format, meaning it will raise an error if the input contains non-integer values or additional characters outside the expected format.
Function number 6 :
 Code:
 '''
def list2d(a, b, c):
    return [[c] * b for i in range(a)]
''' 

 Output hints for function6:  The function `list2d` accepts three parameters: `a` (the number of rows), `b` (the number of columns), and `c` (the value to fill in the 2D list). It returns a 2D list (an `a x b` matrix) where each element is set to the value `c`. This is achieved using a list comprehension that creates a list of length `a`, with each element being a sublist of length `b`, where every element in these sublists is the value `c`. There are no edge cases to consider since `a` and `b` are guaranteed to be non-negative integers.
Function number 7 :
 Code:
 '''
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])
''' 

 Output hints for function7:  The function `sortListWithIndex` accepts a list of tuples `listOfTuples`, where each tuple contains exactly two non-negative integers representing the number of plays and clears at a certain moment, and an integer `idx` specifying the index of the element in the tuple to be used for sorting (0 for plays or 1 for clears). The function returns a new list of tuples that is sorted based on the `idx`-th element of each tuple. The original `listOfTuples` remains unchanged. Potential edge cases include empty lists or `listOfTuples` containing tuples with less than two elements, which would raise a `TypeError`. However, the function does not explicitly handle these cases, so the behavior in such scenarios is undefined.
Function number 8 :
 Code:
 '''
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
    return toret
''' 

 Output hints for function8:  The function `sortDictWithVal` takes a dictionary `passedDic` as input, sorts its items based on the criteria specified by the lambda function (first by the tuple values, then by the keys if the values are equal), and returns a new dictionary `toret`. This new dictionary contains the same key-value pairs as the sorted items from `temp`, where each key is the first element of the tuple and each value is the second element of the corresponding tuple in `temp`. The function handles the case where multiple entries might have the same values, ensuring the correct sorting order based on the keys. The returned dictionary maintains the sorted order of the original entries as determined by the lambda function.
Function number 9 :
 Code:
 '''
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))
''' 

 Output hints for function9:  The function `sortDictWithKey` accepts a dictionary `passedDic` where the keys are integers representing the moments of time Polycarp peeked at the stats, and the values are tuples containing two integers `(p, c)` where `p` is the number of plays and `c` is the number of clears at that moment. The function ensures that the returned dictionary maintains the same structure but guarantees that its keys are sorted in ascending order. This is achieved by converting the dictionary to an `OrderedDict`, sorting its items, and then converting it back to a dictionary. The function does not modify the original dictionary but returns a new one with the sorted keys.
Function number 10 :
 Code:
 '''
def func_2(zero=0):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            i += 1
    except:
        pass
    if s and s[-1] >= b'0'[0]:
        A.append(sign * numb)
    return A
''' 

 Output hints for function10:  Functionality: The function `func_2` takes a parameter `zero` (although it is not used in the function), reads a byte string from standard input, processes it to convert characters to integers, and appends the resulting integers to a list `A`. After processing, the function appends an additional element `0` to the list `A` and returns it. 

- The function reads a byte string `s` from standard input.
- It initializes `numb` to `zero` and `sign` to `1`.
- It iterates over each character in `s`, converting digits to integers and appending them to `A` with the appropriate sign.
- If a `-` character is encountered, it sets `sign` to `-1`.
- If a newline character (`\r`) is not encountered, it appends the current number (`numb`) to `A` with the current sign and resets `numb` and `sign`.
- After the loop, if the last character of `s` is a digit, it appends the final number to `A`.
- Finally, the function returns the list `A` with an additional element `0` appended to it.

Potential edge cases and missing functionality:
- The function does not handle non-digit characters other than `-` and `\r` explicitly. Characters other than digits, `-`, and `\r` are ignored.
- The function assumes that the input is a valid byte string. If the input is not a byte string, the function may raise a `TypeError`.
- The function uses `sys.stdin.buffer.read()` to read the entire input at once, which could potentially cause issues with very large inputs.
- The function does not provide feedback or error handling for invalid input, such as non-byte string input or improperly formatted data.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.