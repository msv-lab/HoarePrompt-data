
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Dima, Inna and Seryozha have gathered in a room. That's right, someone's got to go. To cheer Seryozha up and inspire him to have a walk, Inna decided to cook something. 

Dima and Seryozha have n fruits in the fridge. Each fruit has two parameters: the taste and the number of calories. Inna decided to make a fruit salad, so she wants to take some fruits from the fridge for it. Inna follows a certain principle as she chooses the fruits: the total taste to the total calories ratio of the chosen fruits must equal k. In other words, <image> , where aj is the taste of the j-th chosen fruit and bj is its calories.

Inna hasn't chosen the fruits yet, she is thinking: what is the maximum taste of the chosen fruits if she strictly follows her principle? Help Inna solve this culinary problem — now the happiness of a young couple is in your hands!

Inna loves Dima very much so she wants to make the salad from at least one fruit.

Input

The first line of the input contains two integers n, k (1 ≤ n ≤ 100, 1 ≤ k ≤ 10). The second line of the input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the fruits' tastes. The third line of the input contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100) — the fruits' calories. Fruit number i has taste ai and calories bi.

Output

If there is no way Inna can choose the fruits for the salad, print in the single line number -1. Otherwise, print a single integer — the maximum possible sum of the taste values of the chosen fruits.

Examples

Input

3 2
10 8 1
2 7 1


Output

18


Input

5 3
4 4 4 4 4
2 2 2 2 2


Output

-1

Note

In the first test sample we can get the total taste of the fruits equal to 18 if we choose fruit number 1 and fruit number 2, then the total calories will equal 9. The condition <image> fulfills, that's exactly what Inna wants.

In the second test sample we cannot choose the fruits so as to follow Inna's principle.
Program:
```
from collections import defaultdict

def func():
    (n, k) = map(int, raw_input().split())
    A = map(int, raw_input().split())
    B = map(int, raw_input().split())
    dp1 = defaultdict(lambda : 0, {0: 0})
    pos = 0
    for (a, b) in zip(A, B):
        cur = a - b * k
        dp2 = dp1.copy()
        for (x, y) in dp1.iteritems():
            dp2[x + cur] = max(dp2[x + cur], y + a)
        dp1 = dp2
    if dp1[0] > 0:
        print(dp1[0])
    else:
        print(-1)


```
Original Assessment: Correctness: **True**

Explanation: The provided Python program seems to correctly implement the dynamic programming solution to find the maximum possible sum of the taste values of the chosen fruits while maintaining the required taste-to-calories ratio `k`. Here’s a breakdown of why the program works:

1. **Initialization**: The program initializes the dynamic programming (DP) table `dp1` with a base case where the key is 0 and the value is 0.

2. **Iterate through Fruits**: For each fruit, the program calculates the difference between the fruit’s taste and `k` times its calories (`cur = a - b * k`).

3. **Update DP Table**: For each fruit, it updates the DP table `dp2` by considering the current fruit's contribution to the existing states. It checks if adding the current fruit to any existing state in `dp1` results in a better (higher taste) solution and updates `dp2` accordingly.

4. **Check Final State**: After processing all fruits, the program checks if there is any valid state in `dp1` where the total taste is greater than 0. If such a state exists, it prints the maximum taste; otherwise, it prints `-1`.

Given the constraints and the nature of the problem, this approach ensures that the maximum possible sum of the taste values of the chosen fruits is found while adhering to the required ratio. The program handles all the described cases correctly and does not miss any potential scenarios. Therefore, the program is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from collections import defaultdict

#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 100, and k is a positive integer such that 1 <= k <= 10. The list a contains n positive integers each between 1 and 100, inclusive, representing the tastes of the fruits. The list b contains n positive integers each between 1 and 100, inclusive, representing the calories of the fruits.
def func():
    n, k = map(int, raw_input().split())
    A = map(int, raw_input().split())
    B = map(int, raw_input().split())
    dp1 = defaultdict(lambda : 0, {(0): 0})
    pos = 0
    for (a, b) in zip(A, B):
        cur = a - b * k
        
        dp2 = dp1.copy()
        
        for x, y in dp1.iteritems():
            dp2[x + cur] = max(dp2[x + cur], y + a)
        
        dp1 = dp2
        
    #State of the program after the  for loop has been executed: `n` is an integer, `k` is an integer, `a` is a list of `n` positive integers, `B` is a list of `n` integers, `dp1` is a dictionary with keys as integers and values as integers, `pos` is 0, `dp1` is updated to reflect the maximum values obtained by iterating through `a` and `B` using the defined process.
    if (dp1[0] > 0) :
        print(dp1[0])
    else :
        print(-1)
    #State of the program after the if-else block has been executed: `n` is an integer, `k` is an integer, `a` is a list of `n` positive integers, `B` is a list of `n` integers, `dp1` is a dictionary with keys as integers and values as integers, `pos` is 0. If `dp1[0]` is greater than 0, the function reflects the maximum values obtained by iterating through `a` and `B` using the defined process, and does not print anything. Otherwise, `dp1` is updated to reflect the maximum values obtained by iterating through `a` and `B` using the defined process, and `-1` is printed.
#Overall this is what the function does:The function processes two lists, `A` and `B`, containing `n` positive integers each, and an integer `k`. It calculates the maximum sum of elements from list `A` such that the corresponding elements in list `B` do not exceed `k` when multiplied. This is achieved using dynamic programming stored in the dictionary `dp1`. After processing, the function prints the maximum sum if it is greater than 0; otherwise, it prints `-1`. The function does not return any value. Edge cases include when `dp1[0]` is not updated properly or when the input lists `A` and `B` contain invalid values (though the code assumes valid inputs based on the given constraints).

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
