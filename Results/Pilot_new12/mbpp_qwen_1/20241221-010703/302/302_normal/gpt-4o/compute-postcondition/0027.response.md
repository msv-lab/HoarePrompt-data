The code sets `high` to `mid - 1`. Given that `mid` is initially `(low + high) // 2`, this means `high` is now `mid - 1`. Since `mid` is `(low + high) // 2`, substituting `mid` in the new equation for `high` gives us `high = (low + high) // 2 - 1`. The initial condition that `low` is less than or equal to `high` remains valid.

Output State: **`low` is less than or equal to `high`; `mid` is `(low + high) // 2`; `high` is `(low + high) // 2 - 1`**