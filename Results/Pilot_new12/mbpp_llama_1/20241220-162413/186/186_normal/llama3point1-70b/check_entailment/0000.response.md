Correctness: **False**.

The given program attempts to extract the element-wise binary AND operation between two tuples. However, the program description asks for "elementwise and tuples," which can be interpreted in multiple ways. One possible interpretation is that it wants the element-wise bitwise AND operation between corresponding elements of the two tuples, which the given program seems to attempt.

However, the issue lies in the fact that the program uses the bitwise AND operator (&) directly on the elements of the tuples. This will work correctly only if the elements of the tuples are integers. If the tuples contain other types of elements, such as strings or floats, the program will either produce incorrect results or throw an error.

For example, if tup1 = (1, 2, 3) and tup2 = (4, 5, 6), the program will return (0, 0, 2), which is the element-wise bitwise AND of the corresponding elements.

But if tup1 = (1, 'a', 3) and tup2 = (4, 'b', 6), the program will throw an error because it tries to perform a bitwise AND operation between an integer and a string, which is not allowed in Python.

So, the program does not work correctly for tuples containing non-integer elements. 

Here's a corrected version of the function that adds input validation to handle this case:

```python
def func_1(tup1, tup2):
    if len(tup1)!= len(tup2):
        raise ValueError("Tuples must be the same length")
    
    for x, y in zip(tup1, tup2):
        if not isinstance(x, int) or not isinstance(y, int):
            raise ValueError("All elements of the tuples must be integers")
    
    return tuple(x & y for x, y in zip(tup1, tup2))
```

This function first checks if the two tuples have the same length and if all their elements are integers. If these conditions are met, it performs the element-wise bitwise AND operation; otherwise, it raises a ValueError with an informative error message.