
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given a directed graph consisting of n vertices and m edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.

Can you make this graph acyclic by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).


-----Input-----

The first line contains two integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ min(n(n - 1), 100000)) — the number of vertices and the number of edges, respectively.

Then m lines follow. Each line contains two integers u and v denoting a directed edge going from vertex u to vertex v (1 ≤ u, v ≤ n, u ≠ v). Each ordered pair (u, v) is listed at most once (there is at most one directed edge from u to v).


-----Output-----

If it is possible to make this graph acyclic by removing at most one edge, print YES. Otherwise, print NO.


-----Examples-----
Input
3 4
1 2
2 3
3 2
3 1

Output
YES

Input
5 6
1 2
2 3
3 2
3 1
2 1
4 5

Output
NO



-----Note-----

In the first example you can remove edge $2 \rightarrow 3$, and the graph becomes acyclic.

In the second example you have to remove at least two edges (for example, $2 \rightarrow 1$ and $2 \rightarrow 3$) in order to make the graph acyclic.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
(n, m) = map(int, input().split())
graph = [[] for _ in range(n + 1)]
for _ in range(m):
    (u, v) = map(int, input().split())
    graph[u].append(v)
visited = [False] * (n + 1)
rec_stack = [False] * (n + 1)
has_cycle = False
for node in range(1, n + 1):
    if not visited[node]:
        if func_1(node, graph, visited, rec_stack):
            has_cycle = True
            break
if has_cycle:
    print('NO')
else:
    print('YES')

#State of the program right berfore the function call: node is an integer representing the current vertex, graph is a list of lists where each sublist represents the directed edges from the corresponding vertex (1 ≤ node ≤ n), visited is a list of boolean values indicating whether each vertex has been visited, and rec_stack is a list of boolean values indicating the recursion stack state for each vertex.
def func_1(node, graph, visited, rec_stack):
    visited[node] = True
    rec_stack[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            if func_1(neighbor, graph, visited, rec_stack):
                return True
        elif rec_stack[neighbor]:
            return True
        
    #State of the program after the  for loop has been executed: `visited[node]` is True, `rec_stack[node]` is True, all neighbors of `node` have been evaluated. If a neighbor has not been visited, `func_1(neighbor, graph, visited, rec_stack)` has been called for that neighbor. If a neighbor has been visited, for each visited neighbor, `rec_stack[neighbor]` whether True or False reflects their inclusion in the recursion stack at some point during the exploration. Additionally, if any neighbor has led to a cycle, the function would have returned True.
    rec_stack[node] = False
    return False
    #The program returns False, indicating that there are no cycles detected in the graph for the current node since all neighbors have been evaluated and did not lead to a cycle.
#Overall this is what the function does:The function `func_1` is designed to detect cycles in a directed graph represented as a list of adjacency lists. It accepts four parameters: `node`, an integer representing the current vertex to explore; `graph`, a list of lists where each sublist contains directed edges from the corresponding vertex; `visited`, a list of boolean values indicating which vertices have been traversed; and `rec_stack`, a list of boolean values representing the vertices currently in the recursion stack. Upon execution, the function marks the current node as visited and adds it to the recursion stack. It then recursively examines each unvisited neighbor of the current node. If a visited neighbor is found which is also in the recursion stack, a cycle is detected, and the function returns `True`. If all neighbors are explored without finding a cycle, the function marks the current node as not in the recursion stack and returns `False`. The overall functionality thus checks for cycles in the directed graph, providing a boolean output indicating the presence or absence of cycles. Additionally, the function does not handle edge cases where the input `node` may be out of bounds, which could lead to index errors. Therefore, handling for such edge cases is a missing element in the current implementation.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
