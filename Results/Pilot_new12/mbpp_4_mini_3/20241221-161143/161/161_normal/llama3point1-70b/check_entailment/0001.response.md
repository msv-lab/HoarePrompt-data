To verify the correctness of the provided program in finding the n-th Lucas number, we must first understand the Lucas number sequence.

The Lucas numbers are defined as follows:
- L(0) = 2
- L(1) = 1
- For n >= 2, L(n) = L(n-1) + L(n-2)

Given this definition, let's analyze the provided code:

```python
def func_1(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        (a, b) = (2, 1)
        for _ in range(2, n + 1):
            (a, b) = (b, a + b)
        return b
```

1. The code correctly handles the base cases:
   - When `n == 0`, it returns 2.
   - When `n == 1`, it returns 1.

2. For `n >= 2`, it initializes `a` to L(0) = 2 and `b` to L(1) = 1. It then computes the subsequent Lucas numbers in a loop until it reaches L(n).

3. The logic in the for loop correctly updates `a` and `b` to hold the last two computed values of the sequence. Specifically:
   - `a` represents L(n-2)
   - `b` represents L(n-1)
   - The line `(a, b) = (b, a + b)` updates `b` to the next Lucas number, L(n), at each iteration.

After reviewing the code and the logic implemented, we can conclude that it correctly calculates the n-th Lucas number according to the established series.

We also need to consider edge cases:
- What happens if n < 0? The problem description does not specify the expected behavior for negative indices. The code does not handle negative inputs and will lead to incorrect results as it assumes n is always non-negative.

Since the program does not account for all potential cases (specifically when n is negative), we can conclude the following:

Correctness: **False**