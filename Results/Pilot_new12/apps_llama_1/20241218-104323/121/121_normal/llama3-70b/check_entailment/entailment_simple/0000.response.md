Correctness: **True**

The program correctly implements the problem description. Here's why:

1.  The program first reads the length of the genome `n` and the string `s` representing the genome.
2.  It initializes a dictionary `count` to keep track of the counts of each nucleotide ('A', 'C', 'G', 'T') in the genome, ignoring any '?' characters.
3.  It calculates the average count of each nucleotide by dividing the length of the genome by 4 (`avg = n // 4`).
4.  It then adjusts the counts in the `count` dictionary to represent the remaining counts needed for each nucleotide to reach the average count (`count[c] = avg - count[c]`).
5.  The program then iterates over the genome string `s`. For each character, if it's a '?', it replaces it with the first available nucleotide ('A', 'C', 'G', 'T') that has a count greater than 0 in the `count` dictionary and decrements its count. If the character is not a '?', it simply appends it to the result string `res`.
6.  Finally, the program checks if there are any remaining counts greater than 0 in the `count` dictionary. If so, it prints '===' indicating that it's not possible to decode the genome. Otherwise, it prints the resulting decoded genome string `res`.

This implementation follows the problem description and correctly handles all potential cases. It ensures that the number of nucleotides of each type in the decoded genome is equal, and if it's not possible to achieve this, it prints '===' as required.