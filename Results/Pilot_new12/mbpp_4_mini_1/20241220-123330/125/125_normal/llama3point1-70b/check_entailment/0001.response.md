To determine if the provided Python program meets the requirements stated in the problem description, we need to analyze the code and consider various inputs.

### Problem Description
The function is supposed to take a list and an integer `n`, and split the list for every `n`th element, returning a list of the resulting lists.

### Provided Program
```python
def func_1(lst, n):
    return [lst[i::n] for i in range(n)]
```

### Analysis
The implementation uses list comprehension to iterate over a range of `n`, then creates slices of `lst` starting from the index `i` and taking every `n`-th element. 

Let's break down how this operates with different cases:

1. **For `n = 1`**: 
   - The entire list should be returned as a single list.
   - Result should be: `[[elem1, elem2, ..., elemN]]`

2. **For `n = 2`**:
   - The function will return two slices: the first at indices 0, 2, 4, ... and the second at indices 1, 3, 5, ...
   - Result should be: `[[elem1, elem3, elem5, ...], [elem2, elem4, elem6, ...]]`

3. **For `n > len(lst)`**:
   - If `n` is larger than the length of the list, the function will return an empty list for indices greater than the length of `lst` that it tries to slice, leading to a list of empty sub-lists. 
   - This behavior matches the expectation since every "slice" beyond the available elements would naturally result in an empty list: `num_slices = n`, but `len(lst)` is less than `n`.

4. **Edge Cases**:
   - An empty list or `n <= 0` would also be valid edge cases. The behavior in these situations must also be verified. Given `n <= 0`, the range creates an empty iterable, resulting in an empty list, which again matches expectations.

### Conclusion
After examining the code with various inputs, I see that the program does adhere to the problem description. Outputs for different values of `n` properly create the expected sub-lists from the original list according to the provided specifications.

Correctness: **True**