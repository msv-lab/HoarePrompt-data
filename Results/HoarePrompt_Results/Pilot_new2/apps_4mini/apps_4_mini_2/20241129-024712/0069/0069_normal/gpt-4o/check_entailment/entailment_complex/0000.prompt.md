
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given string $s$ of length $n$ consisting of 0-s and 1-s. You build an infinite string $t$ as a concatenation of an infinite number of strings $s$, or $t = ssss \dots$ For example, if $s =$ 10010, then $t =$ 100101001010010...

Calculate the number of prefixes of $t$ with balance equal to $x$. The balance of some string $q$ is equal to $cnt_{0, q} - cnt_{1, q}$, where $cnt_{0, q}$ is the number of occurrences of 0 in $q$, and $cnt_{1, q}$ is the number of occurrences of 1 in $q$. The number of such prefixes can be infinite; if it is so, you must say that.

A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string "abcd" has 5 prefixes: empty string, "a", "ab", "abc" and "abcd".


-----Input-----

The first line contains the single integer $T$ ($1 \le T \le 100$) — the number of test cases.

Next $2T$ lines contain descriptions of test cases — two lines per test case. The first line contains two integers $n$ and $x$ ($1 \le n \le 10^5$, $-10^9 \le x \le 10^9$) — the length of string $s$ and the desired balance, respectively.

The second line contains the binary string $s$ ($|s| = n$, $s_i \in \{\text{0}, \text{1}\}$).

It's guaranteed that the total sum of $n$ doesn't exceed $10^5$.


-----Output-----

Print $T$ integers — one per test case. For each test case print the number of prefixes or $-1$ if there is an infinite number of such prefixes.


-----Example-----
Input
4
6 10
010010
5 3
10101
1 0
0
2 0
01

Output
3
0
1
-1



-----Note-----

In the first test case, there are 3 good prefixes of $t$: with length $28$, $30$ and $32$.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: T is an integer between 1 and 100, n is an integer between 1 and 100,000, and x is an integer in the range [-10^9, 10^9]. The string s consists of characters '0' and '1' and has a length of n. The sum of all n across test cases does not exceed 100,000.
def func_1():
    input = sys.stdin.read
    data = input().split()
    T = int(data[0])
    index = 1
    results = []
    for _ in range(T):
        n = int(data[index])
        
        x = int(data[index + 1])
        
        s = data[index + 2]
        
        index += 3
        
        balance = s.count('0') - s.count('1')
        
        prefix_balances = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_balances[i] = prefix_balances[i - 1] + (1 if s[i - 1] == '0' else -1
                )
        
        if balance == 0:
            if x in prefix_balances:
                results.append(-1)
            else:
                results.append(0)
        else:
            count = 0
            for b in prefix_balances:
                if (x - b) % balance == 0 and (x - b) // balance >= 0:
                    count += 1
            results.append(count)
        
    #State of the program after the  for loop has been executed: `T` is between 1 and 100, `results` is a list containing the output of the computation for each iteration of the loop based on the values of `n`, `x`, and the string `s`, `index` is equal to `3 * T + 1`, `balance` is calculated as the difference between the counts of '0's and '1's in `s` during the last iteration, `prefix_balances` is a list of length `n + 1` containing cumulative balances for the last processed string `s`. If `balance` is 0 and `x` is present in `prefix_balances`, `results` includes `-1` for that iteration; otherwise, it includes `0`. If `balance` is not equal to 0, `count` is the total number of valid values in `prefix_balances` that satisfy the conditions based on `x` and `balance`.
    for result in results:
        print(result)
        
    #State of the program after the  for loop has been executed: `T` is between 1 and 100, `results` contains `T` elements, `index` is `3 * T + T`, `balance` is calculated based on the counts of '0's and '1's in `s` from the last iteration, `prefix_balances` is a list of length `n + 1`, and all elements in `results` have been printed.
#Overall this is what the function does:The function reads input values for multiple test cases, each consisting of an integer `n`, an integer `x`, and a binary string `s`. It calculates the balance of zeros and ones in `s`, and based on this balance and the value of `x`, it determines how many valid balances can be achieved. If the balance is zero and `x` exists in the calculated prefix balances, it appends -1 to the results; otherwise, it appends 0. If the balance is non-zero, it counts how many prefix balances satisfy the condition that `(x - balance) % balance == 0` and are non-negative. Finally, it prints the results for all test cases. The function does not accept parameters directly but processes input from the standard input.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
