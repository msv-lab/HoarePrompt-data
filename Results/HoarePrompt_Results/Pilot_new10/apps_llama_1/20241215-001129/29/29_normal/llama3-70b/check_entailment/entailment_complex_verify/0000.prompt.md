
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to go through the problem descritpion, the program and the original assessment. Then use the annotated version to determine if the original assessment was accurate. Then finally provide a final assessment of the program's correctness. Use the format Final: **True** if you believe the program is correct based on the problem description and the annotations and the original assessment. Otherwise, use Final: **False**.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: The All-Berland National Olympiad in Informatics has just ended! Now Vladimir wants to upload the contest from the Olympiad as a gym to a popular Codehorses website.

Unfortunately, the archive with Olympiad's data is a mess. For example, the files with tests are named arbitrary without any logic.

Vladimir wants to rename the files with tests so that their names are distinct integers starting from 1 without any gaps, namely, "1", "2", ..., "n', where n is the total number of tests.

Some of the files contain tests from statements (examples), while others contain regular tests. It is possible that there are no examples, and it is possible that all tests are examples. Vladimir wants to rename the files so that the examples are the first several tests, all all the next files contain regular tests only.

The only operation Vladimir can perform is the "move" command. Vladimir wants to write a script file, each of the lines in which is "move file_1 file_2", that means that the file "file_1" is to be renamed to "file_2". If there is a file "file_2" at the moment of this line being run, then this file is to be rewritten. After the line "move file_1 file_2" the file "file_1" doesn't exist, but there is a file "file_2" with content equal to the content of "file_1" before the "move" command.

Help Vladimir to write the script file with the minimum possible number of lines so that after this script is run:  all examples are the first several tests having filenames "1", "2", ..., "e", where e is the total number of examples;  all other files contain regular tests with filenames "e + 1", "e + 2", ..., "n", where n is the total number of all tests. 


-----Input-----

The first line contains single integer n (1 ≤ n ≤ 10^5) — the number of files with tests.

n lines follow, each describing a file with test. Each line has a form of "name_i type_i", where "name_i" is the filename, and "type_i" equals "1", if the i-th file contains an example test, and "0" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.


-----Output-----

In the first line print the minimum number of lines in Vladimir's script file.

After that print the script file, each line should be "move file_1 file_2", where "file_1" is an existing at the moment of this line being run filename, and "file_2" — is a string of digits and small English letters with length from 1 to 6.


-----Examples-----
Input
5
01 0
2 1
2extra 0
3 1
99 0

Output
4
move 3 1
move 01 5
move 2extra 4
move 99 3

Input
2
1 0
2 1

Output
3
move 1 3
move 2 1
move 3 2
Input
5
1 0
11 1
111 0
1111 1
11111 0

Output
5
move 1 5
move 11 1
move 1111 2
move 111 4
move 11111 3
Program:
```
def func():
    n = int(input())
    files = []
    for _ in range(n):
        (name, type_) = input().split()
        files.append((name, int(type_)))
    files.sort(key=lambda x: x[1], reverse=True)
    examples = [file[0] for file in files if file[1] == 1]
    regular = [file[0] for file in files if file[1] == 0]
    script = []
    for (i, file) in enumerate(examples, start=1):
        script.append(f'move {file} {i}')
    for (i, file) in enumerate(regular, start=len(examples) + 1):
        script.append(f'move {file} {i}')
    print(len(script))
    for line in script:
        print(line)


```
Original Assessment: Correctness: **False**.

The code provided does not fully meet the requirements described in the problem statement. The issue lies in how the code handles the renaming of files to their final positions.

In the problem statement, it is mentioned that Vladimir can perform a "move" command where "file_1" is renamed to "file_2". If there is a file "file_2" at the moment of this line being run, then this file is to be rewritten. The key point here is that if the destination filename already exists, it should be overwritten, but this does not mean new files can be created arbitrarily.

The provided code does not account for cases where moving a file might overwrite an existing file that is supposed to be moved to a different location later. This can lead to files being lost and never reaching their intended destinations.

For instance, consider the case where you have files "A", "B", and "C" that need to be moved to "1", "2", and "3", respectively, but the starting layout is such that "1" already exists. Simply moving "A" to "1" would overwrite any content in "1", potentially losing data that was supposed to be moved to a different location.

To solve this problem correctly, the code needs to implement a strategy that avoids overwriting files that are supposed to be moved later. This can involve temporarily renaming files to out-of-the-way names before moving them to their final destinations, ensuring that no data is lost during the process.

Here is an example of how the corrected approach might look (though the exact implementation may vary based on the specific requirements and constraints of the problem):

1. Identify all files and their intended destinations.
2. For each file that needs to be moved:
   - If the destination filename is already occupied by a file that also needs to be moved, move the occupying file to a temporary location first.
   - Move the file to its intended destination.
3. Ensure that all temporary moves are resolved by moving files from their temporary locations to their final destinations, again avoiding overwrites.

This strategy ensures that all files are moved to their intended locations without any being lost or overwritten incorrectly. The original code does not implement such a strategy, which is why it is considered incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
#State of the program right berfore the function call: The input consists of an integer n (1 ≤ n ≤ 10^5) followed by n lines, each containing a string filename (consisting of digits and small English letters with length from 1 to 6 characters) and an integer type (0 or 1), where the filenames are guaranteed to be distinct.
def func():
    n = int(input())
    files = []
    for _ in range(n):
        name, type_ = input().split()
        
        files.append((name, int(type_)))
        
    #State of the program after the  for loop has been executed: `n` is an integer between 1 and 10^5 (inclusive), `name` is the last filename read, `type_` is the last type read, `files` is a list of `n` tuples containing filenames and their corresponding types, `_` is undefined in terms of its conventional use but technically holds the last index value of `n-1`.
    files.sort(key=lambda x: x[1], reverse=True)
    examples = [file[0] for file in files if file[1] == 1]
    regular = [file[0] for file in files if file[1] == 0]
    script = []
    for (i, file) in enumerate(examples, start=1):
        script.append(f'move {file} {i}')
        
    #State of the program after the  for loop has been executed: `n` is an integer between 1 and 10^5 (inclusive), `name` is the last filename read, `type_` is the last type read, `files` is a sorted list of `n` tuples containing filenames and their corresponding types in descending order of types, `_` is the last index value of `n-1`, `examples` is a list of filenames from `files` where the type is 1, `regular` is a list of filenames from `files` where the type is 0, `script` is a list containing strings in the format `f'move {file} {i}'` for each filename in `examples`, `i` is the length of `examples` if `examples` is not empty, otherwise `i` is not defined, and `file` is the last filename in `examples` if `examples` is not empty, otherwise `file` is not defined.
    for (i, file) in enumerate(regular, start=len(examples) + 1):
        script.append(f'move {file} {i}')
        
    #State of the program after the  for loop has been executed: `n` is an integer between 1 and 10^5 (inclusive), `name` is the last filename read, `type_` is the last type read, `files` is a sorted list of `n` tuples containing filenames and their corresponding types in descending order of types, `_` is the last index value of `n-1`, `examples` is a list of filenames from `files` where the type is 1, `regular` is a list of filenames from `files` where the type is 0, `script` is a list containing strings in the format `f'move {file} {i}'` for each filename in `examples` and all filenames in `regular`, `i` is `len(examples) + len(regular)` if `regular` is not empty, otherwise `i` is not defined, and `file` is the last filename in `regular` if `regular` is not empty, otherwise `file` is not defined.
    print(len(script))
    for line in script:
        print(line)
        
    #State of the program after the  for loop has been executed: `n` is an integer between 1 and 10^5 (inclusive), `name` is the last filename read, `type_` is the last type read, `files` is a sorted list of `n` tuples containing filenames and their corresponding types in descending order of types, `_` is the last index value of `n-1`, `examples` is a list of filenames from `files` where the type is 1, `regular` is a list of filenames from `files` where the type is 0, `script` is an empty list or a list that has been fully printed, `i` equals `len(script)` if `regular` is not empty, `file` is the last filename in `regular` if `regular` is not empty, `line` is the last string in `script` if `script` is not empty, and the value `len(examples) + len(regular)` has been printed.
#Overall this is what the function does:The function accepts a series of inputs, including an integer n and n lines of filename and type pairs, processes these inputs to generate a script to move the files based on their types, and prints the total number of lines in the script and the script itself, handling all potential cases including empty input, files with type 0 or 1, and edge cases such as a single file or multiple files with the same type

Does the original Assessment make sense based on the problem description and the provided code. Does the asnnotated version of the code lead you to believe that the original assessment was not accurate?
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
 You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
