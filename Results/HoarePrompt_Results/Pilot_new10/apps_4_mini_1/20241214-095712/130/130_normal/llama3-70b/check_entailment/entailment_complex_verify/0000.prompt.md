
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Ivan is collecting coins. There are only $N$ different collectible coins, Ivan has $K$ of them. He will be celebrating his birthday soon, so all his $M$ freinds decided to gift him coins. They all agreed to three terms:  Everyone must gift as many coins as others. All coins given to Ivan must be different. Not less than $L$ coins from gifts altogether, must be new in Ivan's collection.

But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.


-----Input-----

The only line of input contains 4 integers $N$, $M$, $K$, $L$ ($1 \le K \le N \le 10^{18}$; $1 \le M, \,\, L \le 10^{18}$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.


-----Output-----

Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print "-1" (without quotes).


-----Examples-----
Input
20 15 2 3

Output
1
Input
10 11 2 4

Output
-1


-----Note-----

In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.

In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
Program:
```
def func():
    (N, M, K, L) = map(int, input().split())
    if M >= N - K + 1 and M >= L:
        print(1)
    else:
        print(-1)


```
Original Assessment: To determine the correctness of the provided program based on the problem description, let's analyze the requirements and what the function is implementing.

### Problem requirements:
1. There are `N` different collectible coins.
2. Ivan currently has `K` of those coins.
3. `M` friends plan to gift Ivan coins, but each friend must gift the same number of coins.
4. There must be at least `L` new coins added to Ivan's collection from the gifts.
5. All coins gifted must be different.

### Key conditions:
- All `M` friends must gift the same quantity of coins, denoted as `x`. Therefore, the total number of coins gifted is `M * x`.
- All the coins gifted must be different, so the total number of different coins gifted (`M * x`) must not exceed `N`.
- To ensure that at least `L` coins are new, we need that the number of new coins gifted is at least `L` which also translates to the condition that:
  - `M * x` (total coins gifted) minus `K` (coins Ivan already has) must be at least `L`.

### Assessing the existing code:

The logic in the provided program checks:
- If `M >= N - K + 1` (this means that the number of friends must be able to gift enough different coins)
- If `M >= L` (the total number of friends should also be enough to find at least `L` new coins).

However, it misses the check on `x`. The program prints `1` directly if both condition checks are satisfied without determining the actual minimum `x` which should satisfy both the uniqueness of coins gifted and the requirement for new coins.

### Examples where the function fails:
1. Case where `N=5`, `M=3`, `K=2`, `L=2`.
   - Here, since Ivan has 2 coins out of 5, he can potentially get 3 new coins. However, to satisfy the requirement that all friends must give the same amount, the code would only print `1` without ensuring it satisfies the uniqueness and L conditions correctly based on `x`.
   - Given the conditions, `x` needs to be `1`, and thus there is a possibility of gifting 3 different coins when `N` only allows for `3` new unique coins which would work, but the original code does not print `1` by correctly analyzing the situation.

2. Case where `N=10`, `M=11`, `K=2`, `L=4`.
   - Here `11` friends cannot gift Ivan different coins because there are only `10` types available, hence the output should be `-1` which is correctly checked. However, it doesn't properly handle how to determine the amount of gifts given the constraints.

In summary, while the initial checks are reasonable, they do not correctly compute the requirement of coins for the friends nor the minimum `x` correctly, which leads to potential discrepancies in the outputs required by the problem statement.

### Conclusion:
Correctness: **False**. 

The program fails to implement the necessary logic to compute the minimum number of coins one friend should gift while ensuring that all conditions and requirements are met correctly.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
#State of the program right berfore the function call: N, M, K, and L are positive integers where 1 ≤ K ≤ N ≤ 10^18, and 1 ≤ M, L ≤ 10^18.
def func():
    N, M, K, L = map(int, input().split())
    if (M >= N - K + 1 and M >= L) :
        print(1)
    else :
        print(-1)
    #State of the program after the if-else block has been executed: *`N`, `M`, `K`, and `L` are positive integers. If `M` is greater than or equal to `N - K + 1` and `M` is greater than or equal to `L`, the function continues normally. Otherwise, if `M` is less than `N - K + 1` or `M` is less than `L`, `-1` is printed.
#Overall this is what the function does:The function accepts input of four positive integers N, M, K, and L from standard input. It checks if M is greater than or equal to N - K + 1 and M is also greater than or equal to L. If both conditions are satisfied, it prints 1; otherwise, it prints -1. There are no return values.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
