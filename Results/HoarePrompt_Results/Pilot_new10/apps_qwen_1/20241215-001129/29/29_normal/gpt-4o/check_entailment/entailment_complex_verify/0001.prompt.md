
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to go through the problem descritpion, the program and the original assessment. Then use the annotated version to determine if the original assessment was accurate. Then finally provide a final assessment of the program's correctness. Use the format Final: **True** if you believe the program is correct based on the problem description and the annotations and the original assessment. Otherwise, use Final: **False**.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: The All-Berland National Olympiad in Informatics has just ended! Now Vladimir wants to upload the contest from the Olympiad as a gym to a popular Codehorses website.

Unfortunately, the archive with Olympiad's data is a mess. For example, the files with tests are named arbitrary without any logic.

Vladimir wants to rename the files with tests so that their names are distinct integers starting from 1 without any gaps, namely, "1", "2", ..., "n', where n is the total number of tests.

Some of the files contain tests from statements (examples), while others contain regular tests. It is possible that there are no examples, and it is possible that all tests are examples. Vladimir wants to rename the files so that the examples are the first several tests, all all the next files contain regular tests only.

The only operation Vladimir can perform is the "move" command. Vladimir wants to write a script file, each of the lines in which is "move file_1 file_2", that means that the file "file_1" is to be renamed to "file_2". If there is a file "file_2" at the moment of this line being run, then this file is to be rewritten. After the line "move file_1 file_2" the file "file_1" doesn't exist, but there is a file "file_2" with content equal to the content of "file_1" before the "move" command.

Help Vladimir to write the script file with the minimum possible number of lines so that after this script is run:  all examples are the first several tests having filenames "1", "2", ..., "e", where e is the total number of examples;  all other files contain regular tests with filenames "e + 1", "e + 2", ..., "n", where n is the total number of all tests. 


-----Input-----

The first line contains single integer n (1 ≤ n ≤ 10^5) — the number of files with tests.

n lines follow, each describing a file with test. Each line has a form of "name_i type_i", where "name_i" is the filename, and "type_i" equals "1", if the i-th file contains an example test, and "0" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.


-----Output-----

In the first line print the minimum number of lines in Vladimir's script file.

After that print the script file, each line should be "move file_1 file_2", where "file_1" is an existing at the moment of this line being run filename, and "file_2" — is a string of digits and small English letters with length from 1 to 6.


-----Examples-----
Input
5
01 0
2 1
2extra 0
3 1
99 0

Output
4
move 3 1
move 01 5
move 2extra 4
move 99 3

Input
2
1 0
2 1

Output
3
move 1 3
move 2 1
move 3 2
Input
5
1 0
11 1
111 0
1111 1
11111 0

Output
5
move 1 5
move 11 1
move 1111 2
move 111 4
move 11111 3
Program:
```
import sys

input = sys.stdin.read
data = input().split('\n')
n = int(data[0])
files = data[1:n + 1]
files_set = set((file.split()[0] for file in files))
moves = func_1(n, files)
print(len(moves))
for move in moves:
    print(move)

def func_1(n, files):
    examples = []
    regulars = []
    for file in files:
        (name, type_) = file.split()
        if type_ == '1':
            examples.append(name)
        else:
            regulars.append(name)
    moves = []
    temp_counter = n + 1
    for i in range(len(examples)):
        if examples[i] != str(i + 1):
            while temp_counter <= 2 * n and str(temp_counter) in files_set:
                temp_counter += 1
            moves.append(f'move {examples[i]} {temp_counter}')
            examples[i] = str(temp_counter)
            temp_counter += 1
        if examples[i] != str(i + 1):
            moves.append(f'move {examples[i]} {i + 1}')
    for i in range(len(regulars)):
        target = len(examples) + i + 1
        if regulars[i] != str(target):
            while temp_counter <= 2 * n and str(temp_counter) in files_set:
                temp_counter += 1
            moves.append(f'move {regulars[i]} {temp_counter}')
            regulars[i] = str(temp_counter)
            temp_counter += 1
        if regulars[i] != str(target):
            moves.append(f'move {regulars[i]} {target}')
    return moves


```
Original Assessment: Correctness: **False**

Explanation: The provided program has a logical issue when handling the renaming process. Specifically, the `func_1` function does not ensure that all examples are placed in the first positions correctly and that all regular tests are placed in subsequent positions without gaps. 

Consider the following input:

```
3
1 0
2 1
3 0
```

The expected output would be:
```
4
move 1 3
move 2 1
move 3 2
move 1 1
```

However, the current implementation might fail to handle such cases properly. Here's why:

1. The function `func_1` tries to place examples and regular tests into their respective positions but may not always achieve the correct ordering due to the way it handles the `temp_counter`.

2. The `temp_counter` is used to find available positions for renaming, but it might not correctly identify the positions for both examples and regular tests.

To fix this, the function needs to ensure that all examples are placed in the first positions and all regular tests are placed in subsequent positions without any gaps. This requires a more careful handling of the renaming process to ensure that the correct positions are assigned to each file type.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
input = sys.stdin.read
data = input().split('\n')
n = int(data[0])
files = data[1:n + 1]
files_set = set((file.split()[0] for file in files))
moves = func_1(n, files)
print(len(moves))
for move in moves:
    print(move)

import sys

#State of the program right berfore the function call: n is an integer representing the number of files, and files is a list of strings, where each string represents a file with its name and type in the format "name type", and "type" is either "1" indicating an example test or "0" indicating a regular test.
def func_1(n, files):
    examples = []
    regulars = []
    for file in files:
        name, type_ = file.split()
        
        if type_ == '1':
            examples.append(name)
        else:
            regulars.append(name)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of files, `files` is an empty list, `regulars` is a list containing the names of all files with type '0', `examples` is a list containing the names of all files with type '1'.
    moves = []
    temp_counter = n + 1
    for i in range(len(examples)):
        if examples[i] != str(i + 1):
            while temp_counter <= 2 * n and str(temp_counter) in files_set:
                temp_counter += 1
            moves.append(f'move {examples[i]} {temp_counter}')
            examples[i] = str(temp_counter)
            temp_counter += 1
        
        if examples[i] != str(i + 1):
            moves.append(f'move {examples[i]} {i + 1}')
        
    #State of the program after the  for loop has been executed: `examples` is a list where each element is either the index of a file or `2 * n + 1`, `temp_counter` is `3 * n + 3`, `moves` contains a series of move commands, `files_set` contains all the file names in the final state, `regulars` and `examples` contain the names of all files with types '0' and '1' respectively, and `moves` contains a series of move commands based on the conditions met during the loop execution.
    for i in range(len(regulars)):
        target = len(examples) + i + 1
        
        if regulars[i] != str(target):
            while temp_counter <= 2 * n and str(temp_counter) in files_set:
                temp_counter += 1
            moves.append(f'move {regulars[i]} {temp_counter}')
            regulars[i] = str(temp_counter)
            temp_counter += 1
        
        if regulars[i] != str(target):
            moves.append(f'move {regulars[i]} {target}')
        
    #State of the program after the  for loop has been executed: `regulars` contains the file names such that each `regulars[i]` matches its corresponding `target` or is moved to an available slot in `files_set`, `temp_counter` is greater than `2 * n`, `files_set` may contain additional file names, and `moves` contains all the move commands performed during the loop.
    return moves
    #The program returns moves which contains all the move commands performed during the loop
#Overall this is what the function does:The function `func_1` accepts two parameters: `n` (an integer representing the number of files) and `files` (a list of strings, where each string represents a file with its name and type in the format "name type", and "type" is either "1" indicating an example test or "0" indicating a regular test). The function reorders the files such that example tests (`type='1'`) are placed at indices `1` to `n` and regular tests (`type='0'`) are placed at indices `n+1` to `2*n`. It returns a list of move commands needed to achieve this ordering. If a file needs to be moved more than once, the function ensures it only moves the file to the correct position in one move. If a file cannot be moved to its target position, the function will find the next available slot.

Does the original Assessment make sense based on the problem description and the provided code. Does the asnnotated version of the code lead you to believe that the original assessment was not accurate?
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
 You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
