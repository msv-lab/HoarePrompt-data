To calculate the output state, let's break down the given code and initial state.

The initial state is: 
- `n` is a non-negative integer
- `num_str` is a string representation of `n`
- `num_len` is the number of digits in `n`

The given code is: 
```
armstrong_sum = sum(int(digit) ** num_len for digit in num_str)
```
This line of code calculates the sum of each digit in `n` raised to the power of the number of digits in `n`. This is a key characteristic of an Armstrong number, which is a number that is equal to the sum of cubes of its digits (for 3-digit numbers), or more generally, a number that is equal to the sum of its digits each raised to the power of the number of digits.

Given the initial state and the code:
- `n` remains a non-negative integer.
- `num_str` remains a string representation of `n`.
- `num_len` remains the number of digits in `n`.
- A new variable `armstrong_sum` is introduced, which equals the sum of each digit in `n` raised to the power of `num_len`.

Therefore, the output state is: 
`n` is a non-negative integer, `num_str` is a string representation of `n`, `num_len` is the number of digits in `n`, and `armstrong_sum` equals `sum(int(digit) ** num_len for digit in num_str)`.

Output State: **`n` is a non-negative integer, `num_str` is a string representation of `n`, `num_len` is the number of digits in `n`, and `armstrong_sum` equals the sum of each digit in `n` raised to the power of `num_len`.**