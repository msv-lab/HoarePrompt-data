To determine the correctness of the provided program based on the problem description, let's analyze the function:

The goal is to create a function that splits a list for every nth element, resulting in a list of sublists. The provided implementation is:

```python
def func_1(lst, n):
    return [lst[i::n] for i in range(n)]
```

### Analysis of the Program:
1. The function takes in a list `lst` and an integer `n`.
2. It uses list comprehension to generate sublists.
3. The expression `lst[i::n]` takes every nth element starting from index `i`.

### Considerations:
- **Edge Case with Empty List:** If `lst` is empty, `func_1([], n)` should return `[]`, which is correct.
- **Edge Case with n=0 or Negative n:** If `n` is 0 or negative, the slicing will not work as intended, leading to potential errors or unexpected behavior. The behavior in such cases is not defined in the problem description.
- **Typical Cases:** For a small list and positive n, it should correctly split the list into sublists.

### Example Cases:
- `func_1([1, 2, 3, 4, 5], 2)` should return `[[1, 3, 5], [2, 4]]`.
- `func_1([1, 2, 3, 4, 5], 3)` should return `[[1, 4], [2, 5], [3]]`.
- `func_1([], 2)` should return `[]`.

### Observations:
- If `n` is 0, a `ZeroDivisionError` will occur due to the slicing logic being executed incorrectly.
- If `n` is negative, the behavior of slicing is also not defined, potentially leading to unexpected results.

### Conclusion:
The function does not handle the cases where `n` is 0 or negative properly. Since it fails to account for these potential edge cases, it does not fulfill the problem requirements effectively.

Correctness: **False**