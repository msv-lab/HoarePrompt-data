To verify the correctness of the provided program against the problem description, let's analyze the requirements and the code. 

### Problem Description Review

1. **Input Parameters**:
   - `N`: Total different collectible coins.
   - `M`: Number of friends.
   - `K`: Coins Ivan already has.
   - `L`: Minimum number of new coins that must be gifted to Ivan.

2. **Conditions**:
   - Everyone must gift as many coins as others.
   - All gifted coins must be different.
   - At least `L` coins must be new (not already in Ivan's collection).

3. **Output**:
   - The program should return:
     - The minimum number `x` such that each friend gifts `x` coins.
     - If impossible, return `-1`.

### Code Analysis

The key steps taken in the code are:

1. **Calculation of `min_x`**:
   ```python
   min_x = (L + M - 1) // M
   ```
   - This step calculates the minimum number of coins each friend needs to give to ensure at least `L` new coins are introduced. It uses ceiling division to determine how many full rounds of gifting are needed.

2. **Validation against constraints**:
   ```python
   if (M * min_x <= N - K):
       print(min_x)
   else:
       print(-1)
   ```
   - Here, the program checks if the total coins that would be gifted by `M` friends, each giving `min_x` coins (`M * min_x`), does not exceed the number of different coins that are left for gifting (`N - K`).

### Logical Flow
- The program first determines the minimum number of coins each friend must gift (`min_x`) to ensure at least `L` new coins.
- It then checks if it is possible to give the total coins without exceeding the available differences. If the condition holds true, it prints `min_x`; if not, it prints `-1`.

### Handling Edge Cases
1. The condition `M * min_x <= N - K` correctly captures the scenarios in which:
   - There are not enough different coins left because `K` could be very close to `N`.
   - The friends do not have sufficient distinct coins to gift.
2. It correctly handles cases where `N`, `M`, `K`, and `L` adhere to the constraints provided (all are positive integers within bounds).

### Conclusion
The program effectively implements the requirements detailed in the problem description and correctly handles all specified conditions. It correctly balances between the needs for unique coins and the capacity of each friend gifting such.

Thus, the output of the verification is: 
Correctness: **True**