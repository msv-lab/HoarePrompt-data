To determine the correctness of the provided program, let's analyze the problem description and the code.

**Problem Description:** The function should take a list and an integer `n`, then split the list for every `n`-th element, returning a list of the resulting lists.

**Program:**
```python
def func_1(lst, n):
    return [lst[i::n] for i in range(n)]
```

**Analysis:**
1. The program uses list comprehension to create a list of sublists starting from each index `i` from `0` to `n-1`.
2. The slicing `lst[i::n]` takes every `n`-th element starting from index `i`. 

**Potential Issues:**
- If `n` is greater than the length of the list, the slices will not return any elements for some indices. This could lead to an unexpected empty list for those indices.
- If `n` is `0`, this would raise an error because slicing with a step of `0` is invalid in Python.
- If `n` is negative, the behavior is not defined in the problem description, and it would also lead to unexpected results.

**Test Cases to Consider:**
1. **Empty List:** 
   - Input: `func_1([], 2)` should return `[]`, which is correct.
   
2. **List Length Less than n:**
   - Input: `func_1([1, 2, 3], 5)` should return `[[], [], [], [], []]` which can be unexpected if the user expects something different.
   
3. **n equals 0:**
   - Input: `func_1([1, 2, 3], 0)` will raise an error (ZeroDivisionError).

4. **Negative n:**
   - Input: `func_1([1, 2, 3], -1)` will also lead to unexpected behavior.

Given these points, we can conclude the program does not handle all potential edge cases correctly:

Correctness: **False**. 

The program fails to handle cases where `n` is `0`, negative, or greater than the length of the list appropriately.