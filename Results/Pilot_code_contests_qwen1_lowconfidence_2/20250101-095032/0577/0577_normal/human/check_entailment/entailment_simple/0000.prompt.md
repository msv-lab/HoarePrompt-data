
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either "AB" or "BB". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.

For example, Zookeeper can use two such operations: AABABBA → AABBA → AAA.

Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 20000) — the number of test cases. The description of the test cases follows.

Each of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.

It is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print a single integer: the length of the shortest string that Zookeeper can make.

Example

Input


3
AAA
BABA
AABBBABBBB


Output


3
2
0

Note

For the first test case, you can't make any moves, so the answer is 3.

For the second test case, one optimal sequence of moves is BABA → BA. So, the answer is 2.

For the third test case, one optimal sequence of moves is AABBBABBBB → AABBBABB → AABBBB → ABBB → AB → (empty string). So, the answer is 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

#Function 1:
#State of the program right berfore the function call: None of the variables used in the function signature are present in the provided code snippet. The function `func_1` does not take any parameters and is responsible for returning an integer value representing the number of test cases.
def func_1():
    return int(input())
    #The program returns an integer value entered by the user via input()

#Function 2:
#State of the program right berfore the function call: None of the variables used in the function signature are present in the provided code snippet. The function `func_2` does not take any parameters and seems to be a placeholder or a part of a larger solution that is not shown here.
def func_2():
    return input()
    #The program returns the user's input

#Function 3:
#State of the program right berfore the function call: None of the variables in the function signature are present in the provided function. The function `func_3()` does not take any parameters and its purpose seems unrelated to the problem description. It reads input from the standard input, splits it based on spaces, and converts the split strings to integers using `map`, but it does not contribute to solving the given problem.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers converted from input split by spaces

#Function 4:
#State of the program right berfore the function call: The function does not take any parameters. It reads input from stdin, which is a single line containing a string consisting of letters 'A' and 'B'.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing strings 'A' or 'B' based on the input string split by spaces

#Function 5:
#State of the program right berfore the function call: None of the variables in the function signature are provided in the given program. The function `func_5` does not take any parameters and it returns a list from another function `func_3()` which is not defined in the provided code snippet.
def func_5():
    return list(func_3())
    #The program returns a list from the function `func_3()`, but the exact content of the list is unknown as `func_3()` is not defined.

#Function 6:
#State of the program right berfore the function call: This function does not take any parameters and it seems to be a utility function to ensure sufficient recursion limit and stack size for another function (main) to run. No variables related to the problem description are present in the function signature.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple or a list containing at least two elements, where the second element is a string consisting of letters 'A' and 'B'.
def func_7(item):
    return item[1]
    #The program returns a string consisting of letters 'A' and 'B' that is the second element of the tuple or list 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of strings, where each string consists of the characters 'A' and 'B' only.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a list of strings from 'l' sorted in descending order based on the custom key 'getKey'

#Function 9:
#State of the program right berfore the function call: n and m are positive integers representing the dimensions of the 2D list to be created, and num is the integer value that will fill every cell in the 2D list.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #`The program returns a 2D list with dimensions n by m, where every cell contains the integer value num`

#Function 10:
#State of the program right berfore the function call: x is a non-negative integer.
def func_10(x):
    return x and not x & x - 1
    #The program returns True if x is 0, otherwise returns False

#Function 11:
#State of the program right berfore the function call: n is an integer and n >= 0.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary string representation of integer n without the '0b' prefix

#Function 12:
#State of the program right berfore the function call: n is a positive integer represented as a string.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the string representation of `n`

#Function 13:
#State of the program right berfore the function call: x is an integer, and y is a positive integer (y > 0).
def func_13(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns x divided by y using integer division
    else :
        return x // y + 1
        #The program returns the integer value of `x // y + 1`, where `x % y != 0`

#Function 14:
#State of the program right berfore the function call: x and y are integers, and p is a positive integer representing the modulus.
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x` is \(\left((x \% p) \times (x \% p)\right) \times \left((x \% p) \times (x \% p)\right) \times \cdots \times \left((x \% p) \times (x \% p)\right) \% p\) (where the expression is repeated `k` times, with `k` being the number of times `y` was greater than 0), `y` is 0, `res` is the result of repeatedly updating `res` to `res * x % p` whenever `y` is odd, `p` remains unchanged.
    return res
    #The program returns `res` which is the result of repeatedly updating `res` to `res * x % p` whenever `y` is odd, and `x` is \(\left((x \% p) \times (x \% p)\right) \times \left((x \% p) \times (x \% p)\right) \times \cdots \times \left((x \% p) \times (x \% p)\right) \% p\) (where the expression is repeated `k` times, with `k` being the number of times `y` was greater than 0)

#Function 15:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_15(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x, which is the greatest common divisor (GCD) of the original values of x and y, and y is 0

#Function 16:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_16(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer greater than 1, and n is greater than or equal to 4
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: n is an integer greater than 1 and greater than or equal to 4, and n is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than 1 and greater than or equal to 4, and not divisible by 2 and not divisible by 3, and `n` must be at least 25, and `n` is not divisible by any integer `i` or `i + 2` where `i` is any integer from 5 onwards, and the final value of `i` is greater than or equal to the square root of `n`.
    return True
    #The program returns True

#Function 17:
#State of the program right berfore the function call: There is no input or output processing done within the function `func_17`. The function sets up file streams for reading from 'input.txt' and writing to 'output.txt', but it does not define any variables or process any strings related to the problem described.
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
#State of the program right berfore the function call: s is a non-empty string consisting of characters 'A' and 'B' only.
def func_18():
    for _ in range(int(input())):
        s = raw_input()
        
        func_19(solve(s))
        
    #State of the program after the  for loop has been executed: `s` is an integer input from the user, `solve(s)` has been computed and passed to `func_19` multiple times (or not at all if no further iterations occur), the exact values of the variables inside `solve` and `func_19` are unknown.

#Function 19:
#State of the program right berfore the function call: s is a non-empty string consisting of only the characters 'A' and 'B'.
def solve(s):
    if (s.find('AB') == -1 and s.find('BB') == -1) :
        return len(s)
        #The program returns the length of the string `s` which consists of only the characters 'A' and 'B', does not contain the substring "AB", and does not contain the substring "BB"
    #State of the program after the if block has been executed: s is a non-empty string consisting of only the characters 'A' and 'B', and either 'AB' or 'BB' is present in the string
    while s.find('AB') != -1:
        s = s.replace('AB', '')
        
    #State of the program after the loop has been executed: `s` is an empty string, the original string `s` has had all occurrences of 'AB' removed.
    while s.find('BB') != -1:
        s = s.replace('BB', '')
        
    #State of the program after the loop has been executed: `s` is an empty string or no longer contains the substring 'BB'
    return len(s)
    #The program returns the length of string 's', which is 0 since it is an empty string or no longer contains the substring 'BB'

#Function 20:
#State of the program right berfore the function call: s is a non-empty string consisting of the characters 'A' and 'B' only.
def func_19():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `s` is a non-empty string consisting of the characters 'A' and 'B' only, `args` is an empty list or contains the elements passed to the function, `sep` is either the value of `kwargs['sep']` (default `' ')` or `' '`, `file` is `sys.stdout`, `at_start` is `False`, and the standard output contains the concatenation of the string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`s` is a non-empty string consisting of the characters 'A' and 'B' only, `args` is an empty list or contains the elements passed to the function, `sep` is either the value of `kwargs['sep']` (default `' ')` or `' '`, `file` is `sys.stdout`, `at_start` is `False`, and the standard output contains the concatenation of the string representations of all elements in `args` separated by `sep` followed by `kwargs.pop('end', '\n')`. The `flush` parameter does not affect the output content but may influence the flushing of the standard output buffer if set to `True`. Since `flush` is `False` in this case, the output buffer is not explicitly flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
