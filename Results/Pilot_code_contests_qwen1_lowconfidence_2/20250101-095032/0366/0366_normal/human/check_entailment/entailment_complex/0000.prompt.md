
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are many anime that are about "love triangles": Alice loves Bob, and Charlie loves Bob as well, but Alice hates Charlie. You are thinking about an anime which has n characters. The characters are labeled from 1 to n. Every pair of two characters can either mutually love each other or mutually hate each other (there is no neutral state).

You hate love triangles (A-B are in love and B-C are in love, but A-C hate each other), and you also hate it when nobody is in love. So, considering any three characters, you will be happy if exactly one pair is in love (A and B love each other, and C hates both A and B), or if all three pairs are in love (A loves B, B loves C, C loves A).

You are given a list of m known relationships in the anime. You know for sure that certain pairs love each other, and certain pairs hate each other. You're wondering how many ways you can fill in the remaining relationships so you are happy with every triangle. Two ways are considered different if two characters are in love in one way but hate each other in the other. Print this count modulo 1 000 000 007.

Input

The first line of input will contain two integers n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).

The next m lines will contain the description of the known relationships. The i-th line will contain three integers ai, bi, ci. If ci is 1, then ai and bi are in love, otherwise, they hate each other (1 ≤ ai, bi ≤ n, ai ≠ bi, <image>).

Each pair of people will be described no more than once.

Output

Print a single integer equal to the number of ways to fill in the remaining pairs so that you are happy with every triangle modulo 1 000 000 007. 

Examples

Input

3 0


Output

4


Input

4 4
1 2 1
2 3 1
3 4 0
4 1 0


Output

1


Input

4 4
1 2 1
2 3 1
3 4 0
4 1 1


Output

0

Note

In the first sample, the four ways are to: 

  * Make everyone love each other 
  * Make 1 and 2 love each other, and 3 hate 1 and 2 (symmetrically, we get 3 ways from this). 



In the second sample, the only possible solution is to make 1 and 3 love each other and 2 and 4 hate each other.
Annotated Functions:
maxn = 100005
mod = 1000000007
e = [[] for i in range(maxn)]
vis = [False for i in range(maxn)]
func_2()

#Function 1:
#State of the program right berfore the function call: u is an integer such that 1 ≤ u ≤ n, e is a list of adjacency lists where e[i] contains tuples (v, c) representing an edge between vertices i and v with relationship c (True for love, False for hate), and vis is a boolean list of size n initialized to False.
def func_1(u):
    sz = len(e[u])
    ok = True
    for i in range(sz):
        v = e[u][i][0]
        
        c = e[u][i][1]
        
        if vis[v] == False:
            if c == True:
                vis[v] = vis[u]
            else:
                vis[v] = -vis[u]
            ok = func_1(v)
        
        if c == 1 and vis[v] != vis[u]:
            return False
        
        if c == 0 and vis[v] != -vis[u]:
            return False
        
    #State of the program after the  for loop has been executed: - `u`: An integer such that \(1 \leq u \leq n\).
    #- `e`: A list of adjacency lists.
    #- `vis`: A boolean list of size `n` where each vertex `v` reachable from `u` through the edges is marked with a consistent sign (`vis[v]` is either `vis[u]` or `-vis[u]` depending on the path taken).
    #- `sz`: The number of edges connected to vertex `u`.
    #- `ok`: The return value of `func_1(v)` after the last update to `vis[v]`, or `False` if the loop terminates early due to the conditions mentioned.
    #
    #If the loop does not execute, the values remain as in the initial state:
    #- `u`: An integer such that \(1 \leq u \leq n\).
    #- `e`: A list of adjacency lists.
    #- `vis`: A boolean list of size `n` initialized to `False`.
    #- `sz`: The number of edges connected to vertex `u`.
    #- `ok`: `True`.
    return ok
    #The program returns `ok` which is `True` since the loop does not execute and the values remain as in the initial state
#Overall this is what the function does:The function `func_1(u)` takes an integer `u` (where \(1 \leq u \leq n\)), a list of adjacency lists `e`, and a boolean list `vis` initialized to `False`. It performs a depth-first search (DFS) to mark the vertices reachable from `u` using the signs indicated by the edges in `e`. If it finds any inconsistency in the signs (i.e., if an edge indicates a "love" relationship but the signs of the two endpoints do not match, or if an edge indicates a "hate" relationship but the signs of the two endpoints do not contradict), it returns `False`. Otherwise, it returns `True`.

Specifically:
- It initializes `sz` to the number of edges connected to vertex `u`.
- For each edge `(v, c)` connected to `u`, it checks if `v` has already been visited. If not, it marks `v` with a consistent sign based on the edge type (`c`). If `c` is `True` (love), `v` is marked with the same sign as `u`; if `c` is `False` (hate), `v` is marked with the opposite sign of `u`.
- If it finds an inconsistency during the DFS, it immediately returns `False`.
- If the loop completes without finding any inconsistencies, it returns `True`.

Potential edge cases and missing functionality:
- The function does not handle the case where `u` is out of bounds (i.e., \(u < 1\) or \(u > n\)). This should be handled separately before calling `func_1`.
- The function does not initialize `vis` internally; it assumes `vis` is passed as an argument and is already initialized to `False`. If `vis` is not properly initialized, the function's behavior could be undefined.

#Function 2:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100 000, m is an integer such that 0 ≤ m ≤ 100 000, e is a list of adjacency lists where e[i] contains pairs [j, c] for all j such that there is an edge between i and j with weight c (0 ≤ c ≤ 1), and vis is a boolean list of length n initialized to False.
def func_2():
    n, m = map(int, raw_input().split())
    for i in range(m):
        u, v, c = map(int, raw_input().split())
        
        u -= 1
        
        v -= 1
        
        e[u].append([v, c])
        
        e[v].append([u, c])
        
    #State of the program after the  for loop has been executed: `n` is an integer entered by the user such that \(3 \leq n \leq 100{,}000\); `m` is an integer entered by the user such that \(m \geq 1\); `e` is a list of adjacency lists where for each pair \((i, j)\) with \(0 \leq i < n\) and \(0 \leq j < n\), if there is an edge between \(i\) and \(j\), then `e[i]` and `e[j]` both contain the pair \([j, c]\) and \([i, c]\) for some integer \(c\) representing the weight of the edge; `vis` is a boolean list of length `n` initialized to `False`; `i` is `m - 1`; `u` is the last `u` value entered; `v` is the last `v` value entered; `c` is the last `c` value entered.
    cnt = 0
    for i in range(n):
        if vis[i] == False:
            vis[i] = True
            cnt += 1
            if func_1(i) == False:
                cnt = 0
                break
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(3 \leq n \leq 100{,}000\); `m` is an integer such that \(m \geq 1\) and \(m - 1 < n\); `e` is a list of adjacency lists; `vis` is a boolean list of length `n` where exactly `cnt + 1` elements are set to `True`; `i` is `m - 1`; `u` is the last `u` value entered; `v` is the last `v` value entered; `c` is the last `c` value entered; `cnt` is either `0` or the count of nodes visited during the final pass through the loop.
    ans = 1
    if (cnt == 0) :
        ans = 0
    #State of the program after the if block has been executed: *`ans` is 0, `n` is an integer such that \(3 \leq n \leq 100{,}000\), `m` is an integer such that \(m \geq 1\) and \(m - 1 < n\), `e` is a list of adjacency lists, `vis` is a boolean list of length `n` where exactly `cnt + 1` elements are set to `True`, `i` is `m - 1`, `u` is the last `u` value entered, `v` is the last `v` value entered, `c` is the last `c` value entered, `cnt` is 0. Since the if condition `cnt == 0` is true, `ans` remains 0 and no other changes occur.
    for i in (1, cnt):
        ans *= 2
        
        ans %= mod
        
    #State of the program after the  for loop has been executed: `ans` is 0, `n` is an integer such that \(3 \leq n \leq 100{,}000\), `m` is an integer such that \(m \geq 1\) and \(m - 1 < n\), `e` is a list of adjacency lists, `vis` is a boolean list of length `n` where exactly `cnt` elements are set to `True`, `i` is `cnt - 1` if `cnt > 0`, otherwise `i` is `m - 1`, `u` is the last `u` value entered, `v` is the last `v` value entered, `c` is the last `c` value entered, `cnt` is at least 1.
    print(ans)
#Overall this is what the function does:The function reads an undirected graph represented by `n` vertices, `m` edges, and an adjacency list `e`. It initializes a boolean list `vis` to track visited vertices. It then iterates over all vertices, marking them as visited and checking a condition using `func_1(i)`. If `func_1(i)` returns `False`, it resets the count `cnt` to 0 and breaks out of the loop. If `cnt` remains non-zero after visiting all components, it calculates `ans` as \(2^{\text{cnt}} \mod \text{mod}\). If `cnt` is zero, it sets `ans` to 0. Finally, it prints the value of `ans`. Potential edge cases include graphs with disconnected components or no edges. If `func_1(i)` is not defined or does not perform the expected operation, it could lead to incorrect results.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.