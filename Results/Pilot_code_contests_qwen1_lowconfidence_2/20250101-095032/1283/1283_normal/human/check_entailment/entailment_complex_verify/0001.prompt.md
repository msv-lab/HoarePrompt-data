
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You've got an n × m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.

A picture is a barcode if the following conditions are fulfilled: 

  * All pixels in each column are of the same color. 
  * The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y. 

Input

The first line contains four space-separated integers n, m, x and y (1 ≤ n, m, x, y ≤ 1000; x ≤ y).

Then follow n lines, describing the original image. Each of these lines contains exactly m characters. Character "." represents a white pixel and "#" represents a black pixel. The picture description doesn't have any other characters besides "." and "#".

Output

In the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists. 

Examples

Input

6 5 1 2
##.#.
.###.
###..
#...#
.##.#
###..


Output

11


Input

2 5 1 1
#####
.....


Output

5

Note

In the first test sample the picture after changing some colors can looks as follows: 
    
    
      
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    

In the second test sample the picture after changing some colors can looks as follows: 
    
    
      
    .#.#.  
    .#.#.  
    
Program:
```
from sys import stdin
from collections import defaultdict
import sys
import time
#Function 1:
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        wcount = 0
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        white_cost.append(wcount)
        black_cost.append(bcount)
    return (black_cost, white_cost)

#Function 2:
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if index >= m:
        if w != 0 and w >= x:
            return 0
        if b != 0 and b >= x:
            return 0
        return float('inf')
    else:
        if dp1[w][index] != -1 and dp2[b][index] != -1:
            return min(dp1[w][index], dp2[b][index])
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if w < x:
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                c1 += white_cost[i]
                i += 1
                cw += 1
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        if b < x:
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                c2 += black_cost[i]
                i += 1
                cb += 1
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        if w >= x and w + 1 <= y:
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)
        if b >= x and b + 1 <= y:
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)


```
Original Assessment: Correctness: **False**

Explanation: The provided code has several issues that prevent it from correctly solving the problem for all potential cases:

1. **Dynamic Programming Initialization**: The initialization of `dp1` and `dp2` is not handled correctly. The dimensions of `dp1` and `dp2` should be `(y+1) x (m+1)` instead of the current `(y+1) x (m)`. This mismatch in dimensions leads to out-of-bound errors during the recursive calls.

2. **Edge Cases Handling**: The function does not handle edge cases properly, such as when the entire column is either white or black and the required width constraints (`x` and `y`) are not satisfied. The code does not ensure that the final groups meet the width constraints.

Here is an example where the program fails:

Consider the following input:
```
4 5 2 3
##.#.
.###.
###..
#...#
```

The expected output is 7, but the program will not produce the correct result due to the issues mentioned above.

To fix these issues, you need to properly initialize the DP tables and ensure that the width constraints are checked and maintained throughout the process.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin
from collections import defaultdict
import sys
import time

"""input
10 5 3 7
.####
###..
##.##
#..#.
.#...
#.##.
.##..
.#.##
#.#..
.#..#
"""
sys.setrecursionlimit(15000)
(n, m, x, y) = list(map(int, stdin.readline().split()))
matrix = []
for _ in range(n):
    matrix.append(list(stdin.readline().strip()))
(black_cost, white_cost) = func_1(matrix, n, m)
dp1 = [[-1 for j in range(m)] for k in range(y + 1)]
dp2 = [[-1 for j in range(m)] for k in range(y + 1)]
print(func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, 0, 0, 0))

#Function 1:
#State of the program right berfore the function call: matrix is a 2D list representing the pixel picture where each element is either "." (white) or "#" (black), n and m are positive integers such that 0 < n <= len(matrix) and 0 < m == len(matrix[0]), and x and y are positive integers such that 1 <= x <= y <= 1000.
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        
        wcount = 0
        
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        
        white_cost.append(wcount)
        
        black_cost.append(bcount)
        
    #State of the program after the  for loop has been executed: `total` is an empty list, `i` is `m`, `m` is a positive integer, `black_cost` is a list of length `m` containing the number of occurrences of `'.'` in each column of `matrix`, `white_cost` is a list of length `m` containing the number of occurrences of any character other than `'.'` in each column of `matrix`.
    return black_cost, white_cost
    #`The program returns two lists: black_cost which is a list of length m containing the number of occurrences of '.' in each column of matrix, and white_cost which is a list of length m containing the number of occurrences of any character other than '.' in each column of matrix`
#Overall this is what the function does:The function `func_1` accepts a 2D list `matrix` representing a pixel picture where each element is either `"."` (white) or `"#"` (black), along with two integers `n` and `m` indicating the dimensions of the matrix. The function iterates over each column of the matrix to count the number of white (`"."`) and black (`"#"` or any character other than `"."`) pixels. It then returns two lists: `black_cost`, which contains the count of white pixels for each column, and `white_cost`, which contains the count of black pixels for each column. The function covers all columns from `0` to `m-1`. If the matrix is empty or `n` is `0`, the function will still iterate over the columns and return empty lists for both `black_cost` and `white_cost`.

#Function 2:
#State of the program right berfore the function call: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture, n and m are positive integers representing the dimensions of the picture, x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa, index is an integer representing the current column being processed, w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column.
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if (index >= m) :
        if (w != 0 and w >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture. n and m are positive integers representing the dimensions of the picture. x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines. black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa. index is an integer representing the current column being processed, with the current value of index being greater than or equal to m. w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column. w is either 0 or less than x
        if (b != 0 and b >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture. n and m are positive integers representing the dimensions of the picture. x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines. black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa. index is an integer representing the current column being processed, with the current value of index being greater than or equal to m. w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column. w is either 0 or less than x. b is 0 or less than x
        return float('inf')
        #The program returns infinity (`float('inf')`)
    else :
        if (dp1[w][index] != -1 and dp2[b][index] != -1) :
            return min(dp1[w][index], dp2[b][index])
            #The program returns the minimum of dp1[w][index] and dp2[b][index]
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture, n and m are positive integers representing the dimensions of the picture, x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa, index is an integer representing the current column being processed, w is an integer representing the current width of the monochrome vertical line ending at the current column, b is an integer representing the current width of the monochrome vertical line ending at the current column. The index is less than m, and either dp1[w][index] is -1 or dp2[b][index] is -1
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if (w < x) :
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                
                c1 += white_cost[i]
                
                i += 1
                
                cw += 1
                
            #State of the program after the loop has been executed: `cw` is `x` or greater, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns, `dp1` and `dp2` are 2D lists of integers with dimensions \((y+1) \times m\) and \((y+1) \times m\) respectively, initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is an integer representing the current width of the monochrome vertical line ending at the current column, `c2`, `c3`, and `c4` are all `float('inf')`, and `i` is the last column processed.
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        #State of the program after the if block has been executed: *`c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers with dimensions \((y+1) \times m\) and \((y+1) \times m\) respectively, initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is an integer representing the current width of the monochrome vertical line ending at the current column, `c2`, `c3`, and `c4` are all `float('inf')`. If `w < x`, `cw` is `x` or greater, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`. Otherwise, the values remain unchanged.
        if (b < x) :
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                
                c2 += black_cost[i]
                
                i += 1
                
                cb += 1
                
            #State of the program after the loop has been executed: `c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is equal to the final value of `cb` which is `b + k` where `k` is the number of iterations, `c2` is the accumulated cost `black_cost[i]` from the start to the last iteration, `c3` is `float('inf')`, `c4` is `float('inf')`, `cb` is `b + k + 1`, `i` is the original value of `i` plus the number of iterations, and the program either breaks out of the most internal loop or if statement.
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        #State of the program after the if block has been executed: *`c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is equal to the final value of `cb` which is `b + k` where `k` is the number of iterations, `c2` is the accumulated cost `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is `float('inf')`, `c4` is `float('inf')`, `cb` is `b + k + 1`, `i` is the original value of `i` plus the number of iterations, and the program either breaks out of the most internal loop or if statement. If `b < x`, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`. Otherwise, `c1` remains `float('inf')`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        if (w >= x and w + 1 <= y) :
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, w + 1, 0)
        #State of the program after the if block has been executed: *`c1`, `c2`, `c3`, `c4` are integers, `dp1` and `dp2` are 2D lists of integers, `matrix` is a 2D list of strings, `n` and `m` are positive integers, `x` and `y` are positive integers, `black_cost` and `white_cost` are integers, `index` is an integer, `w` is an integer, `b` is an integer, `cb` is an integer, `i` is an integer, and the program either breaks out of the most internal loop or if statement. If the current width `w` of the monochrome vertical line ending at the current column is between `x` and `y` inclusive, then `c1` remains `float('inf')`, `c2` is updated as `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is updated as `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`, and other variables retain their respective updated states. Otherwise, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        if (b >= x and b + 1 <= y) :
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, 0, b + 1)
        #State of the program after the if block has been executed: *`c1`, `c2`, `c3`, `c4` are integers, `dp1` and `dp2` are 2D lists of integers, `matrix` is a 2D list of strings, `n` and `m` are positive integers, `x` and `y` are positive integers, `black_cost` and `white_cost` are integers, `index` is an integer, `w` is an integer, `b` is an integer, and `cb` is an integer. If the current width `w` of the monochrome vertical line ending at the current column is between `x` and `y` inclusive, then `c1` remains `float('inf')`, `c2` is updated as `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is updated as `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`, and `c4` is `black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)`. Otherwise, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)
        #`The program returns the minimum value among c1, c2, c3, and c4, where c2 and c3 are updated based on the conditions involving black_cost, white_cost, and indices, and c4 is similarly updated but considering black_cost instead of white_cost`
#Overall this is what the function does:The function `func_2` processes a pixel picture represented by a 2D list `matrix`, with dimensions `n x m`, to determine the minimum cost of converting monochrome vertical lines within specified width ranges `[x, y]` to achieve certain configurations. It uses dynamic programming tables `dp1` and `dp2` to store intermediate results. The function considers three possible operations at each column: extending the existing monochrome vertical line, creating a new line, or changing the color of pixels to match the required monochrome line configuration.

The function returns one of the following based on the state of the program:
- `0`: If the current width of the monochrome vertical line is zero and meets the condition `w >= x` or `b >= x`.
- `float('inf')`: If the current width of the monochrome vertical line is outside the allowed range `[x, y]` and no valid configuration can be formed.
- The minimum of `dp1[w][index]` and `dp2[b][index]`: If precomputed values from the DP tables are available.
- The minimum value among `c1`, `c2`, `c3`, and `c4`: If the function recursively computes the costs for extending or creating new monochrome vertical lines, adjusting for the current column and width constraints, and considering the costs of changing pixel colors to match the required configuration.

Potential edge cases include:
- When the current column `index` exceeds the picture width `m`.
- When the width of the monochrome vertical line is exactly `x` but needs to extend further to reach `y`.
- When the current width of the monochrome vertical line is outside the allowed range `[x, y]`.

Missing functionality includes:
- Proper handling of the case when `dp1[w][index]` and `dp2[b][index]` are not available, where the function should compute the costs recursively to fill these values.
- Ensuring the correct termination conditions for the recursive calls to `func_2` to avoid infinite loops or incorrect results.
- Handling the case where `index` reaches the end of the picture but the current width `w` or `b` is still within the allowed range `[x, y]`.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
