
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You've got an n × m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.

A picture is a barcode if the following conditions are fulfilled: 

  * All pixels in each column are of the same color. 
  * The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y. 

Input

The first line contains four space-separated integers n, m, x and y (1 ≤ n, m, x, y ≤ 1000; x ≤ y).

Then follow n lines, describing the original image. Each of these lines contains exactly m characters. Character "." represents a white pixel and "#" represents a black pixel. The picture description doesn't have any other characters besides "." and "#".

Output

In the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists. 

Examples

Input

6 5 1 2
##.#.
.###.
###..
#...#
.##.#
###..


Output

11


Input

2 5 1 1
#####
.....


Output

5

Note

In the first test sample the picture after changing some colors can looks as follows: 
    
    
      
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    

In the second test sample the picture after changing some colors can looks as follows: 
    
    
      
    .#.#.  
    .#.#.  
    
Annotated Functions:
from sys import stdin
from collections import defaultdict
import sys
import time

"""input
10 5 3 7
.####
###..
##.##
#..#.
.#...
#.##.
.##..
.#.##
#.#..
.#..#
"""
sys.setrecursionlimit(15000)
(n, m, x, y) = list(map(int, stdin.readline().split()))
matrix = []
for _ in range(n):
    matrix.append(list(stdin.readline().strip()))
(black_cost, white_cost) = func_1(matrix, n, m)
dp1 = [[-1 for j in range(m)] for k in range(y + 1)]
dp2 = [[-1 for j in range(m)] for k in range(y + 1)]
print(func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, 0, 0, 0))

#Function 1:
#State of the program right berfore the function call: matrix is a 2D list representing the pixel picture where each element is either "." (white) or "#" (black), n and m are positive integers such that 0 < n <= len(matrix) and 0 < m == len(matrix[0]), and x and y are positive integers such that 1 <= x <= y <= 1000.
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        
        wcount = 0
        
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        
        white_cost.append(wcount)
        
        black_cost.append(bcount)
        
    #State of the program after the  for loop has been executed: `total` is an empty list, `i` is `m`, `m` is a positive integer, `black_cost` is a list of length `m` containing the number of occurrences of `'.'` in each column of `matrix`, `white_cost` is a list of length `m` containing the number of occurrences of any character other than `'.'` in each column of `matrix`.
    return black_cost, white_cost
    #`The program returns two lists: black_cost which is a list of length m containing the number of occurrences of '.' in each column of matrix, and white_cost which is a list of length m containing the number of occurrences of any character other than '.' in each column of matrix`
#Overall this is what the function does:The function `func_1` accepts a 2D list `matrix` representing a pixel picture where each element is either `"."` (white) or `"#"` (black), along with two integers `n` and `m` indicating the dimensions of the matrix. The function iterates over each column of the matrix to count the number of white (`"."`) and black (`"#"` or any character other than `"."`) pixels. It then returns two lists: `black_cost`, which contains the count of white pixels for each column, and `white_cost`, which contains the count of black pixels for each column. The function covers all columns from `0` to `m-1`. If the matrix is empty or `n` is `0`, the function will still iterate over the columns and return empty lists for both `black_cost` and `white_cost`.

#Function 2:
#State of the program right berfore the function call: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture, n and m are positive integers representing the dimensions of the picture, x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa, index is an integer representing the current column being processed, w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column.
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if (index >= m) :
        if (w != 0 and w >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture. n and m are positive integers representing the dimensions of the picture. x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines. black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa. index is an integer representing the current column being processed, with the current value of index being greater than or equal to m. w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column. w is either 0 or less than x
        if (b != 0 and b >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture. n and m are positive integers representing the dimensions of the picture. x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines. black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa. index is an integer representing the current column being processed, with the current value of index being greater than or equal to m. w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column. w is either 0 or less than x. b is 0 or less than x
        return float('inf')
        #The program returns infinity (`float('inf')`)
    else :
        if (dp1[w][index] != -1 and dp2[b][index] != -1) :
            return min(dp1[w][index], dp2[b][index])
            #The program returns the minimum of dp1[w][index] and dp2[b][index]
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture, n and m are positive integers representing the dimensions of the picture, x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa, index is an integer representing the current column being processed, w is an integer representing the current width of the monochrome vertical line ending at the current column, b is an integer representing the current width of the monochrome vertical line ending at the current column. The index is less than m, and either dp1[w][index] is -1 or dp2[b][index] is -1
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if (w < x) :
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                
                c1 += white_cost[i]
                
                i += 1
                
                cw += 1
                
            #State of the program after the loop has been executed: `cw` is `x` or greater, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns, `dp1` and `dp2` are 2D lists of integers with dimensions \((y+1) \times m\) and \((y+1) \times m\) respectively, initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is an integer representing the current width of the monochrome vertical line ending at the current column, `c2`, `c3`, and `c4` are all `float('inf')`, and `i` is the last column processed.
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        #State of the program after the if block has been executed: *`c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers with dimensions \((y+1) \times m\) and \((y+1) \times m\) respectively, initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is an integer representing the current width of the monochrome vertical line ending at the current column, `c2`, `c3`, and `c4` are all `float('inf')`. If `w < x`, `cw` is `x` or greater, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`. Otherwise, the values remain unchanged.
        if (b < x) :
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                
                c2 += black_cost[i]
                
                i += 1
                
                cb += 1
                
            #State of the program after the loop has been executed: `c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is equal to the final value of `cb` which is `b + k` where `k` is the number of iterations, `c2` is the accumulated cost `black_cost[i]` from the start to the last iteration, `c3` is `float('inf')`, `c4` is `float('inf')`, `cb` is `b + k + 1`, `i` is the original value of `i` plus the number of iterations, and the program either breaks out of the most internal loop or if statement.
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        #State of the program after the if block has been executed: *`c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is equal to the final value of `cb` which is `b + k` where `k` is the number of iterations, `c2` is the accumulated cost `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is `float('inf')`, `c4` is `float('inf')`, `cb` is `b + k + 1`, `i` is the original value of `i` plus the number of iterations, and the program either breaks out of the most internal loop or if statement. If `b < x`, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`. Otherwise, `c1` remains `float('inf')`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        if (w >= x and w + 1 <= y) :
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, w + 1, 0)
        #State of the program after the if block has been executed: *`c1`, `c2`, `c3`, `c4` are integers, `dp1` and `dp2` are 2D lists of integers, `matrix` is a 2D list of strings, `n` and `m` are positive integers, `x` and `y` are positive integers, `black_cost` and `white_cost` are integers, `index` is an integer, `w` is an integer, `b` is an integer, `cb` is an integer, `i` is an integer, and the program either breaks out of the most internal loop or if statement. If the current width `w` of the monochrome vertical line ending at the current column is between `x` and `y` inclusive, then `c1` remains `float('inf')`, `c2` is updated as `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is updated as `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`, and other variables retain their respective updated states. Otherwise, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        if (b >= x and b + 1 <= y) :
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, 0, b + 1)
        #State of the program after the if block has been executed: *`c1`, `c2`, `c3`, `c4` are integers, `dp1` and `dp2` are 2D lists of integers, `matrix` is a 2D list of strings, `n` and `m` are positive integers, `x` and `y` are positive integers, `black_cost` and `white_cost` are integers, `index` is an integer, `w` is an integer, `b` is an integer, and `cb` is an integer. If the current width `w` of the monochrome vertical line ending at the current column is between `x` and `y` inclusive, then `c1` remains `float('inf')`, `c2` is updated as `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is updated as `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`, and `c4` is `black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)`. Otherwise, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)
        #`The program returns the minimum value among c1, c2, c3, and c4, where c2 and c3 are updated based on the conditions involving black_cost, white_cost, and indices, and c4 is similarly updated but considering black_cost instead of white_cost`
#Overall this is what the function does:The function `func_2` processes a pixel picture represented by a 2D list `matrix`, with dimensions `n x m`, to determine the minimum cost of converting monochrome vertical lines within specified width ranges `[x, y]` to achieve certain configurations. It uses dynamic programming tables `dp1` and `dp2` to store intermediate results. The function considers three possible operations at each column: extending the existing monochrome vertical line, creating a new line, or changing the color of pixels to match the required monochrome line configuration.

The function returns one of the following based on the state of the program:
- `0`: If the current width of the monochrome vertical line is zero and meets the condition `w >= x` or `b >= x`.
- `float('inf')`: If the current width of the monochrome vertical line is outside the allowed range `[x, y]` and no valid configuration can be formed.
- The minimum of `dp1[w][index]` and `dp2[b][index]`: If precomputed values from the DP tables are available.
- The minimum value among `c1`, `c2`, `c3`, and `c4`: If the function recursively computes the costs for extending or creating new monochrome vertical lines, adjusting for the current column and width constraints, and considering the costs of changing pixel colors to match the required configuration.

Potential edge cases include:
- When the current column `index` exceeds the picture width `m`.
- When the width of the monochrome vertical line is exactly `x` but needs to extend further to reach `y`.
- When the current width of the monochrome vertical line is outside the allowed range `[x, y]`.

Missing functionality includes:
- Proper handling of the case when `dp1[w][index]` and `dp2[b][index]` are not available, where the function should compute the costs recursively to fill these values.
- Ensuring the correct termination conditions for the recursive calls to `func_2` to avoid infinite loops or incorrect results.
- Handling the case where `index` reaches the end of the picture but the current width `w` or `b` is still within the allowed range `[x, y]`.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.