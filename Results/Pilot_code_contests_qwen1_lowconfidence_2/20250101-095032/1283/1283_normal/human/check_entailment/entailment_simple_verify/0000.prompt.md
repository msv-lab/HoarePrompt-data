
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You've got an n × m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.

A picture is a barcode if the following conditions are fulfilled: 

  * All pixels in each column are of the same color. 
  * The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y. 

Input

The first line contains four space-separated integers n, m, x and y (1 ≤ n, m, x, y ≤ 1000; x ≤ y).

Then follow n lines, describing the original image. Each of these lines contains exactly m characters. Character "." represents a white pixel and "#" represents a black pixel. The picture description doesn't have any other characters besides "." and "#".

Output

In the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists. 

Examples

Input

6 5 1 2
##.#.
.###.
###..
#...#
.##.#
###..


Output

11


Input

2 5 1 1
#####
.....


Output

5

Note

In the first test sample the picture after changing some colors can looks as follows: 
    
    
      
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    

In the second test sample the picture after changing some colors can looks as follows: 
    
    
      
    .#.#.  
    .#.#.  
    
Program:
```
from sys import stdin
from collections import defaultdict
import sys
import time
#Function 1:
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        wcount = 0
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        white_cost.append(wcount)
        black_cost.append(bcount)
    return (black_cost, white_cost)

#Function 2:
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if index >= m:
        if w != 0 and w >= x:
            return 0
        if b != 0 and b >= x:
            return 0
        return float('inf')
    else:
        if dp1[w][index] != -1 and dp2[b][index] != -1:
            return min(dp1[w][index], dp2[b][index])
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if w < x:
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                c1 += white_cost[i]
                i += 1
                cw += 1
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        if b < x:
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                c2 += black_cost[i]
                i += 1
                cb += 1
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        if w >= x and w + 1 <= y:
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)
        if b >= x and b + 1 <= y:
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly implement the logic required to minimize the number of pixel changes to achieve the barcode pattern. Specifically, the recursive function `func_2` does not properly handle the constraints for the width of monochrome vertical lines (x and y). The function allows the possibility of splitting a group of consecutive columns into smaller segments, which violates the requirement that each group's size must be between x and y.

For instance, consider the following input:

```
3 4 2 3
#.##
.###
####
```

The expected output is 3, as changing only three pixels (`#` to `.`) can achieve the desired barcode pattern:

```
..##
.###
####
```

However, the current implementation might not handle this correctly due to the way it splits groups and calculates costs, potentially leading to more changes than necessary. This suggests that the program does not fully meet the problem description requirements.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin
from collections import defaultdict
import sys
import time

"""input
10 5 3 7
.####
###..
##.##
#..#.
.#...
#.##.
.##..
.#.##
#.#..
.#..#
"""
sys.setrecursionlimit(15000)
(n, m, x, y) = list(map(int, stdin.readline().split()))
matrix = []
for _ in range(n):
    matrix.append(list(stdin.readline().strip()))
(black_cost, white_cost) = func_1(matrix, n, m)
dp1 = [[-1 for j in range(m)] for k in range(y + 1)]
dp2 = [[-1 for j in range(m)] for k in range(y + 1)]
print(func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, 0, 0, 0))

#Function 1:
#State of the program right berfore the function call: matrix is a 2D list representing the pixel picture where each element is either "." (white) or "#" (black), n and m are positive integers such that 0 < n <= len(matrix) and 0 < m == len(matrix[0]), and x and y are positive integers such that 1 <= x <= y <= 1000.
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        
        wcount = 0
        
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        
        white_cost.append(wcount)
        
        black_cost.append(bcount)
        
    #State of the program after the  for loop has been executed: `total` is an empty list, `i` is `m`, `m` is a positive integer, `black_cost` is a list of length `m` containing the number of occurrences of `'.'` in each column of `matrix`, `white_cost` is a list of length `m` containing the number of occurrences of any character other than `'.'` in each column of `matrix`.
    return black_cost, white_cost
    #`The program returns two lists: black_cost which is a list of length m containing the number of occurrences of '.' in each column of matrix, and white_cost which is a list of length m containing the number of occurrences of any character other than '.' in each column of matrix`

#Function 2:
#State of the program right berfore the function call: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture, n and m are positive integers representing the dimensions of the picture, x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa, index is an integer representing the current column being processed, w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column.
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if (index >= m) :
        if (w != 0 and w >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture. n and m are positive integers representing the dimensions of the picture. x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines. black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa. index is an integer representing the current column being processed, with the current value of index being greater than or equal to m. w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column. w is either 0 or less than x
        if (b != 0 and b >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture. n and m are positive integers representing the dimensions of the picture. x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines. black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa. index is an integer representing the current column being processed, with the current value of index being greater than or equal to m. w is an integer representing the current width of the monochrome vertical line ending at the current column, and b is an integer representing the current width of the monochrome vertical line ending at the current column. w is either 0 or less than x. b is 0 or less than x
        return float('inf')
        #The program returns infinity (`float('inf')`)
    else :
        if (dp1[w][index] != -1 and dp2[b][index] != -1) :
            return min(dp1[w][index], dp2[b][index])
            #The program returns the minimum of dp1[w][index] and dp2[b][index]
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists of integers with dimensions (y+1) x m and (y+1) x m respectively, initialized to -1. matrix is a 2D list of strings representing the pixel picture, n and m are positive integers representing the dimensions of the picture, x and y are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, black_cost and white_cost are integers representing the cost of changing a black pixel to white and vice versa, index is an integer representing the current column being processed, w is an integer representing the current width of the monochrome vertical line ending at the current column, b is an integer representing the current width of the monochrome vertical line ending at the current column. The index is less than m, and either dp1[w][index] is -1 or dp2[b][index] is -1
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if (w < x) :
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                
                c1 += white_cost[i]
                
                i += 1
                
                cw += 1
                
            #State of the program after the loop has been executed: `cw` is `x` or greater, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns, `dp1` and `dp2` are 2D lists of integers with dimensions \((y+1) \times m\) and \((y+1) \times m\) respectively, initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is an integer representing the current width of the monochrome vertical line ending at the current column, `c2`, `c3`, and `c4` are all `float('inf')`, and `i` is the last column processed.
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        #State of the program after the if block has been executed: *`c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers with dimensions \((y+1) \times m\) and \((y+1) \times m\) respectively, initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is an integer representing the current width of the monochrome vertical line ending at the current column, `c2`, `c3`, and `c4` are all `float('inf')`. If `w < x`, `cw` is `x` or greater, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`. Otherwise, the values remain unchanged.
        if (b < x) :
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                
                c2 += black_cost[i]
                
                i += 1
                
                cb += 1
                
            #State of the program after the loop has been executed: `c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is equal to the final value of `cb` which is `b + k` where `k` is the number of iterations, `c2` is the accumulated cost `black_cost[i]` from the start to the last iteration, `c3` is `float('inf')`, `c4` is `float('inf')`, `cb` is `b + k + 1`, `i` is the original value of `i` plus the number of iterations, and the program either breaks out of the most internal loop or if statement.
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        #State of the program after the if block has been executed: *`c1` is `float('inf')`, `dp1` and `dp2` are 2D lists of integers initialized to -1, `matrix` is a 2D list of strings representing the pixel picture, `n` and `m` are positive integers representing the dimensions of the picture, `x` and `y` are positive integers representing the minimum and maximum allowed width of monochrome vertical lines, `black_cost` and `white_cost` are integers representing the cost of changing a black pixel to white and vice versa, `index` is an integer representing the current column being processed, `w` is an integer representing the current width of the monochrome vertical line ending at the current column, `b` is equal to the final value of `cb` which is `b + k` where `k` is the number of iterations, `c2` is the accumulated cost `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is `float('inf')`, `c4` is `float('inf')`, `cb` is `b + k + 1`, `i` is the original value of `i` plus the number of iterations, and the program either breaks out of the most internal loop or if statement. If `b < x`, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`. Otherwise, `c1` remains `float('inf')`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        if (w >= x and w + 1 <= y) :
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, w + 1, 0)
        #State of the program after the if block has been executed: *`c1`, `c2`, `c3`, `c4` are integers, `dp1` and `dp2` are 2D lists of integers, `matrix` is a 2D list of strings, `n` and `m` are positive integers, `x` and `y` are positive integers, `black_cost` and `white_cost` are integers, `index` is an integer, `w` is an integer, `b` is an integer, `cb` is an integer, `i` is an integer, and the program either breaks out of the most internal loop or if statement. If the current width `w` of the monochrome vertical line ending at the current column is between `x` and `y` inclusive, then `c1` remains `float('inf')`, `c2` is updated as `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is updated as `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`, and other variables retain their respective updated states. Otherwise, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        if (b >= x and b + 1 <= y) :
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, 0, b + 1)
        #State of the program after the if block has been executed: *`c1`, `c2`, `c3`, `c4` are integers, `dp1` and `dp2` are 2D lists of integers, `matrix` is a 2D list of strings, `n` and `m` are positive integers, `x` and `y` are positive integers, `black_cost` and `white_cost` are integers, `index` is an integer, `w` is an integer, `b` is an integer, and `cb` is an integer. If the current width `w` of the monochrome vertical line ending at the current column is between `x` and `y` inclusive, then `c1` remains `float('inf')`, `c2` is updated as `black_cost[i]` from the start to the last iteration plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `c3` is updated as `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`, and `c4` is `black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)`. Otherwise, `c1` is the sum of `white_cost` for all columns from `index` to `i-1` plus the number of such columns plus the return value of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `c2` is updated as mentioned, and other variables retain their respective updated states.
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)
        #`The program returns the minimum value among c1, c2, c3, and c4, where c2 and c3 are updated based on the conditions involving black_cost, white_cost, and indices, and c4 is similarly updated but considering black_cost instead of white_cost`



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
