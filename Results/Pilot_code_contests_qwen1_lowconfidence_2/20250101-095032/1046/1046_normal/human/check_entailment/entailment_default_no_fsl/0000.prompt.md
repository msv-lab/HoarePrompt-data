
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: One day, little Vasya found himself in a maze consisting of (n + 1) rooms, numbered from 1 to (n + 1). Initially, Vasya is at the first room and to get out of the maze, he needs to get to the (n + 1)-th one.

The maze is organized as follows. Each room of the maze has two one-way portals. Let's consider room number i (1 ≤ i ≤ n), someone can use the first portal to move from it to room number (i + 1), also someone can use the second portal to move from it to room number pi, where 1 ≤ pi ≤ i.

In order not to get lost, Vasya decided to act as follows. 

  * Each time Vasya enters some room, he paints a cross on its ceiling. Initially, Vasya paints a cross at the ceiling of room 1. 
  * Let's assume that Vasya is in room i and has already painted a cross on its ceiling. Then, if the ceiling now contains an odd number of crosses, Vasya uses the second portal (it leads to room pi), otherwise Vasya uses the first portal. 



Help Vasya determine the number of times he needs to use portals to get to room (n + 1) in the end.

Input

The first line contains integer n (1 ≤ n ≤ 103) — the number of rooms. The second line contains n integers pi (1 ≤ pi ≤ i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.

Output

Print a single number — the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109 + 7).

Examples

Input

2
1 2


Output

4


Input

4
1 1 2 3


Output

20


Input

5
1 1 1 1 1


Output

62
Functions with output description for each function:
import sys

example = func_1(sys.stdin)
if __name__ == '__main__':
    (n, P) = next(example)
    func_2(n, P)

Function number 1 :
 Code:
 '''
def func_1(line):
    """Read example from stdin and parse it into the appropriate data structure

    Use in the following way:

    example = example_generator(stdin_generator)
    while True:
        numbers, target = next(example)
        .
        .
        .

    """
    while True:
        n = int(next(line).strip())
        P = [int(p_i) - 1 for p_i in next(line).split()]
        yield (n, P)
''' 

 Output hints for function1:  The function `func_1` accepts an iterator `line` yielding strings, where the first string provides the number of rooms `n`, and the second string provides `n` space-separated integers representing the sequence `P`. It reads these values, converts them appropriately, and yields a tuple containing `n` and `P`. After executing the function, the state of the program is such that `line` becomes an empty iterator, `n` holds the number of rooms read from the first string, and `P` is a list of `n-1` elements, where each element is an integer derived from the second string by converting it to an integer and subtracting 1. The function handles the case where `line` is exhausted and yields the parsed data. No edge cases are explicitly mentioned in the annotations or the code, but it is assumed that `line` provides exactly two strings as expected, and these strings contain valid integers. If `line` does not provide the expected format, the function will raise a `StopIteration` exception.
Function number 2 :
 Code:
 '''
def func_2(n, p):
    """Print out the number of times Vasya needs to use portals to get to room n+1

    dp[i] is the number of portal jumps required to start off at room i with an odd
    number of crosses and get back to room i with an even number of crosses.

    Hence the recurrence relation is as follows:

    dp[i] = 1 + [Sum_{j = p(i)}^{i-1} dp[j] + 1]

    This can be read as "the number of portal jumps to get from room i with an odd
    number of crosses to an even number of crosses is equivalent to taking a portal
    jump to room p(i) into an odd number of crosees (+1), getting back into that
    state with an even number of crosses (Sum part).

    """
    dp = [0] * n
    for i in range(n):
        portal_jumps = 1
        for j in range(p[i], i):
            portal_jumps += dp[j] % (1000000000.0 + 7)
            portal_jumps += 1 % (1000000000.0 + 7)
        dp[i] = int(portal_jumps % (1000000000.0 + 7))
    total_pjumps = 0
    for i in range(n):
        total_pjumps += dp[i] % (1000000000.0 + 7)
        total_pjumps += 1 % (1000000000.0 + 7)
    print(total_pjumps)
''' 

 Output hints for function2:  The function `func_2` accepts two parameters: an integer `n` and a list `p` of `n` integers, where each element in the list satisfies the condition \(1 \leq p[i] \leq i\). It calculates the number of portal jumps required to start off at each room `i` with an odd number of crosses and get back to room `i` with an even number of crosses. The function then computes the total number of portal jumps across all rooms and prints this total. However, there is a discrepancy in the annotations and the code itself; the final values in the `dp` array are incorrectly described. Each element in the `dp` array should be calculated using the given recurrence relation, and the final state of the `dp` array should reflect these calculations. Additionally, the `total_pjumps` computation includes redundant additions of `1 % (1000000000.0 + 7)` within the loop, which should be removed.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.