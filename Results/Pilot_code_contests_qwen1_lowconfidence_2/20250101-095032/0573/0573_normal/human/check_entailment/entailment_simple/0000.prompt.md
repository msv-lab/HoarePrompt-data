
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There is a white sheet of paper lying on a rectangle table. The sheet is a rectangle with its sides parallel to the sides of the table. If you will take a look from above and assume that the bottom left corner of the table has coordinates (0, 0), and coordinate axes are left and bottom sides of the table, then the bottom left corner of the white sheet has coordinates (x_1, y_1), and the top right — (x_2, y_2).

After that two black sheets of paper are placed on the table. Sides of both black sheets are also parallel to the sides of the table. Coordinates of the bottom left corner of the first black sheet are (x_3, y_3), and the top right — (x_4, y_4). Coordinates of the bottom left corner of the second black sheet are (x_5, y_5), and the top right — (x_6, y_6). 

<image> Example of three rectangles.

Determine if some part of the white sheet can be seen from the above after the two black sheets are placed. The part of the white sheet can be seen if there is at least one point lying not strictly inside the white sheet and strictly outside of both black sheets.

Input

The first line of the input contains four integers x_1, y_1, x_2, y_2 (0 ≤ x_1 < x_2 ≤ 10^{6}, 0 ≤ y_1 < y_2 ≤ 10^{6}) — coordinates of the bottom left and the top right corners of the white sheet.

The second line of the input contains four integers x_3, y_3, x_4, y_4 (0 ≤ x_3 < x_4 ≤ 10^{6}, 0 ≤ y_3 < y_4 ≤ 10^{6}) — coordinates of the bottom left and the top right corners of the first black sheet.

The third line of the input contains four integers x_5, y_5, x_6, y_6 (0 ≤ x_5 < x_6 ≤ 10^{6}, 0 ≤ y_5 < y_6 ≤ 10^{6}) — coordinates of the bottom left and the top right corners of the second black sheet.

The sides of each sheet of paper are parallel (perpendicular) to the coordinate axes.

Output

If some part of the white sheet can be seen from the above after the two black sheets are placed, print "YES" (without quotes). Otherwise print "NO".

Examples

Input


2 2 4 4
1 1 3 5
3 1 5 5


Output


NO


Input


3 3 7 5
0 0 4 6
0 0 7 4


Output


YES


Input


5 2 10 5
3 1 7 6
8 1 11 7


Output


YES


Input


0 0 1000000 1000000
0 0 499999 1000000
500000 0 1000000 1000000


Output


YES

Note

In the first example the white sheet is fully covered by black sheets.

In the second example the part of the white sheet can be seen after two black sheets are placed. For example, the point (6.5, 4.5) lies not strictly inside the white sheet and lies strictly outside of both black sheets.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_15(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

#Function 1:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_1():
    return int(input())
    #The program returns an integer input from the user

#Function 2:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_2():
    return input()
    #The program returns the input provided by the user

#Function 3:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integers converted from a space-separated string input, where the input must contain exactly 12 integers corresponding to x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 respectively

#Function 4:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_4():
    return list(func_3())
    #The program returns a list generated by func_3() with undefined content since the definition of func_3() is not provided

#Function 5:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6 and 0 ≤ y_1 < y_2 ≤ 10^6, representing the coordinates of the bottom left and top right corners of the white sheet. x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, and 0 ≤ y_5 < y_6 ≤ 10^6, representing the coordinates of the bottom left and top right corners of the two black sheets.
def func_5():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 6:
#State of the program right berfore the function call: item is a list or tuple containing at least one element, where the first element is a numeric value.
def func_6(item):
    return item[0]
    #The program returns the first element of the list or tuple 'item', which is a numeric value

#Function 7:
#State of the program right berfore the function call: l is a list of tuples or lists, where each tuple or list contains exactly two integers representing the coordinates (x, y) of points on the white sheet and black sheets. However, based on the context provided in the problem description, it seems there might be a misunderstanding since the function `func_7` does not directly relate to the problem statement. The function `func_7` sorts a list of coordinates, but the parameters and their relationships described do not align with the problem's requirements.
def func_7(l):
    return sorted(l, key=getKey)
    #The program returns a sorted list of tuples or lists based on the key determined by the function `getKey`, where each tuple or list contains exactly two integers representing the coordinates (x, y) of points on the white sheet and black sheets

#Function 8:
#State of the program right berfore the function call: n and m are non-negative integers representing the number of rows and columns of a 2D list respectively, and num is an integer or any other type of value that will be used to initialize all elements in the generated 2D list.
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #A 2D list with 'n' rows and 'm' columns, where each element in the list is 'num'

#Function 9:
#State of the program right berfore the function call: x is an integer greater than or equal to 0.
def func_9(x):
    return x and not x & x - 1
    #The program returns True if x is 0, otherwise it returns False

#Function 10:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_10(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of an integer n without the '0b' prefix, where n is an integer determined by the initial states of x and y variables but the specific value of n is not provided due to lack of a defined n in the code snippet

#Function 11:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_11(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers obtained by converting each character of the string representation of 'n' into an integer

#Function 12:
#State of the program right berfore the function call: x and y are integers representing the base and exponent respectively, and p is a positive integer representing the modulus.
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x` is `x^(original_y) % p`, `y` is 0, `p` is a positive integer representing the modulus, `res` is the result of repeatedly squaring `x` and multiplying when the least significant bit of `y` is 1.
    return res
    #The program returns res which is the result of repeatedly squaring x and multiplying when the least significant bit of y is 1

#Function 13:
#State of the program right berfore the function call: x, y are integers such that 0 <= x, y <= 10^6 and at least one of x or y is greater than 0.
def func_13(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the GCD of the original values of `x` and `y`, `y` is 0
    return x
    #The program returns x that is the GCD of the original values of x and y, which is now 0 since y is 0

#Function 14:
#State of the program right berfore the function call: n is an integer greater than or equal to 0.
def func_14(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than or equal to 0, and `n` is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: `n` is an integer greater than or equal to 0, and `n` is greater than 1, and `n` is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `n` is an integer greater than or equal to 0, and `n` is greater than 1, and `n` is greater than 3, and n is odd and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: Output State: \( n \) is an integer greater than or equal to 0, and \( n \) is greater than 1, and \( n \) is greater than 3, and \( n \) is odd and not divisible by 3, and \( i \) is the smallest integer greater than or equal to \( \sqrt{n} \) that is of the form \( 6k + 5 \) and \( n \) is not divisible by any \( i \) or \( i + 2 \) for \( i \) in the range where \( i^2 \leq n \).
    return True
    #The program returns True

#Function 15:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_15():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 16:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 are integers such that 0 ≤ x_1 < x_2 ≤ 10^6, 0 ≤ y_1 < y_2 ≤ 10^6, 0 ≤ x_3 < x_4 ≤ 10^6, 0 ≤ y_3 < y_4 ≤ 10^6, 0 ≤ x_5 < x_6 ≤ 10^6, 0 ≤ y_5 < y_6 ≤ 10^6.
def func_16():
    func_19('YES')

#Function 17:
#State of the program right berfore the function call: x_1, y_1, x_2, y_2 are integers representing the coordinates of the bottom left and top right corners of the white sheet, 0 <= x_1 < x_2 <= 10^6, 0 <= y_1 < y_2 <= 10^6. x_3, y_3, x_4, y_4 are integers representing the coordinates of the bottom left and top right corners of the first black sheet, 0 <= x_3 < x_4 <= 10^6, 0 <= y_3 < y_4 <= 10^6. x_5, y_5, x_6, y_6 are integers representing the coordinates of the bottom left and top right corners of the second black sheet, 0 <= x_5 < x_6 <= 10^6, 0 <= y_5 < y_6 <= 10^6.
def func_17():
    func_19('NO')

#Function 18:
#State of the program right berfore the function call: (x1, y1) and (x2, y2) are the bottom left and top right coordinates of the white sheet, respectively; (x3, y3) and (x4, y4) are the bottom left and top right coordinates of the first black sheet, respectively; (x5, y5) and (x6, y6) are the bottom left and top right coordinates of the second black sheet, respectively. All coordinates are integers such that 0 ≤ x1 < x2 ≤ 10^6, 0 ≤ y1 < y2 ≤ 10^6, 0 ≤ x3 < x4 ≤ 10^6, 0 ≤ y3 < y4 ≤ 10^6, 0 ≤ x5 < x6 ≤ 10^6, and 0 ≤ y5 < y6 ≤ 10^6.
def func_18():
    x1, y1, x2, y2 = func_3()
    x3, y3, x4, y4 = func_3()
    x5, y5, x6, y6 = func_3()
    one = two = True
    if (x5 > x2 or y6 < y1 or x6 < x1 or y5 > y2) :
        one = False
    #State of the program after the if block has been executed: *`(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, respectively; `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, respectively; `(x5, y5, x6, y6)` are the values returned by `func_3()`, `one` is `False`, and `two` is `True`. If `x5 > x2` or `y6 < y1` or `x6 < x1` or `(y5 > y2)`, then `one` remains `False`. Otherwise, `one` remains `True` and `two` remains `True`.
    if (y3 > y2 or y4 < y1 or x3 > x2 or x4 < x1) :
        two = False
    #State of the program after the if block has been executed: *`(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, respectively; `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, respectively; `(x5, y5, x6, y6)` are the values returned by `func_3()`, `one` remains `False`, and `two` remains `True`. If `y3 > y2` or `y4 < y1` or `x3 > x2` or `x4 < x1`, then `one` remains `False`. Otherwise, `one` remains `True` and `two` remains `True`.
    if (not one and not two) :
        func_16()
        exit()
    #State of the program after the if block has been executed: *`(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, respectively; `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, respectively; `(x5, y5, x6, y6)` are the values returned by `func_3()`, `one` remains `False`, and `two` remains `True`. Since the condition `not one and (not two)` is always true (as `one` and `two` are explicitly stated to remain `False` and `True` respectively), the if part is executed and the postcondition of the if part applies.
    if (True) :
        y4 = min(y4, y2)
        y3 = max(y3, y1)
        y6 = min(y6, y2)
        y5 = max(y5, y1)
        x4 = min(x4, x2)
        x3 = max(x3, x1)
        x6 = min(x6, x2)
        x5 = max(x5, x1)
        if (two and one) :
            area = abs(x1 - x2) * abs(y1 - y2)
            a1 = abs(x3 - x4) * abs(y3 - y4)
            a2 = abs(x5 - x6) * abs(y5 - y6)
            if (a1 + a2 < area) :
                func_16()
            else :
                func_17()
            #State of the program after the if-else block has been executed: (x1, y1) and (x2, y2) are the bottom left and top right coordinates of the white sheet; (x3, y3) and (x4, y4) are the bottom left and top right coordinates of the first black sheet; (x5, y5, x6, y6) are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, `one` remains `False`, `two` remains `True`, `y3` is the maximum of `y3` and `y1`, `x5` is the maximum of its current value and `x1`, `a1` is `abs(x3 - x4) * abs(y3 - y4)`, `a2` is `abs(x5 - x6) * abs(y5 - y6)`. If the sum of `a1` and `a2` is less than `area`, then `a1` and `a2` are computed as described. If the sum of `a1` and `a2` is greater than or equal to `area`, then `a1` and `a2` are also computed as described.
        else :
            if (one == True) :
                a2 = abs(x5 - x6) * abs(y5 - y6)
                if (a2 < area) :
                    func_16()
                else :
                    func_17()
                #State of the program after the if-else block has been executed: *`x3` is `max(x3, x1)`, `y4` is the minimum of its current value and `y2`, `x4` is the minimum of its current value and `x2`, `(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, `(x5, y5, x6, y6)` are the values returned by `func_3()`, `a2` is `|max(x5, a) - x2| * |y5 - y6|`, `one` is `False`, `two` is `True`, `y3` is the maximum of `y3` and `y1`, `x5` is the maximum of its current value and `x1`, `two and one` is `False`. If `a2` is less than `area`, then the function does nothing. Otherwise, the function sets `y3` to be the maximum of `y3` and `y1`.
            else :
                if two :
                    a1 = abs(x3 - x4) * abs(y3 - y4)
                    if (a1 < area) :
                        func_16()
                    else :
                        func_17()
                    #State of the program after the if-else block has been executed: *`(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet. If the area of the intersection `a1` is less than the specified `area`, then `x5` is the maximum of its current value and `x1`, `y5` is the maximum of its current value and `y1`, `x6` is the minimum of its original value and `x2`, `one` is `False`, `two` is `True`, and `y3` is the maximum of `y3` and `y1`. Otherwise, `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, `one` remains `False`, `two` remains `True`, `y3` is the maximum of `y3` and `y1`, and `func_17()` has been called.
                #State of the program after the if block has been executed: *`(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet. If `two` is `True`, then `x5` is the maximum of its current value and `x1`, `y5` is the maximum of its current value and `y1`, `x6` is the minimum of its original value and `x2`, `one` is `False`, `two` is `True`, and `y3` is the maximum of `y3` and `y1`. Otherwise, `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, `one` remains `False`, `two` remains `True`, `y3` is the maximum of `y3` and `y1`, and `func_17()` has been called.
            #State of the program after the if-else block has been executed: *`x3` is `max(x3, x1)`, `y4` is the minimum of its current value and `y2`, `x4` is the minimum of its current value and `x2`, `(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, `(x5, y5, x6, y6)` are the values returned by `func_3()`, `a2` is `|max(x5, a) - x2| * |y5 - y6|`, `one` is `False`, `two` is `True`, `y3` is the maximum of `y3` and `y1`, `x5` is the maximum of its current value and `x1`, `two and one` is `False`. If `a2` is less than `area`, the function does nothing. Otherwise, `y3` is set to be the maximum of `y3` and `y1`. If `two` is `True`, then `x5` is the maximum of its current value and `x1`, `y5` is the maximum of its current value and `y1`, `x6` is the minimum of its original value and `x2`, `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, and `func_17()` has been called. Otherwise, `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, and `func_17()` has been called.
        #State of the program after the if-else block has been executed: *`x3` is `max(x3, x1)`, `y4` is the minimum of its current value and `y2`, `x4` is the minimum of its current value and `x2`, `(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, `one` is `False`, `two` is `True`, `y3` is the maximum of `y3` and `y1`, `x5` is the maximum of its current value and `x1`. If `two and one` is `True`, then `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, and `a2` is `|max(x5, a) - x2| * |y5 - y6|`. If `a1 + a2` is less than `area`, both `a1` and `a2` are computed as described. If `a1 + a2` is greater than or equal to `area`, both `a1` and `a2` are computed as described. If `two and one` is `False`, then `a2` is `|max(x5, a) - x2| * |y5 - y6|`. If `a2` is less than `area`, the function does nothing. Otherwise, `y3` is set to be the maximum of `y3` and `y1`. If `two` is `True`, then `x5` is the maximum of its current value and `x1`, `y5` is the maximum of its current value and `y1`, `x6` is the minimum of its original value and `x2`, and `func_17()` has been called. Otherwise, `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, and `func_17()` has been called.
    #State of the program after the if block has been executed: *`x3` is `max(x3, x1)`, `y4` is the minimum of its current value and `y2`, `x4` is the minimum of its current value and `x2`, `(x1, y1)` and `(x2, y2)` are the bottom left and top right coordinates of the white sheet, `(x3, y3)` and `(x4, y4)` are the bottom left and top right coordinates of the first black sheet, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, `one` is `False`, `two` is `True`, `y3` is the maximum of `y3` and `y1`, `x5` is the maximum of its current value and `x1`. If `two and one` is `True`, then `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, and `a2` is `|max(x5, a) - x2| * |y5 - y6|`. If `a1 + a2` is less than `area`, both `a1` and `a2` are computed as described. If `a1 + a2` is greater than or equal to `area`, both `a1` and `a2` are computed as described. If `two and one` is `False`, then `a2` is `|max(x5, a) - x2| * |y5 - y6|`. If `a2` is less than `area`, the function does nothing. Otherwise, `y3` is set to be the maximum of `y3` and `y1`. If `two` is `True`, then `x5` is the maximum of its current value and `x1`, `y5` is the maximum of its current value and `y1`, `x6` is the minimum of its original value and `x2`, and `func_17()` has been called. Otherwise, `a1` is the area of the intersection between the two rectangles calculated as `abs(x3 - x4) * abs(y3 - y4)`, `(x5, y5, x6, y6)` are the values returned by `func_3()`, with `x6` being the minimum of its original value and `x2`, and `func_17()` has been called.

#Function 19:
#State of the program right berfore the function call: (x_1, y_1) and (x_2, y_2) are the coordinates of the bottom left and top right corners of the white sheet, respectively, with 0 ≤ x_1 < x_2 ≤ 10^6 and 0 ≤ y_1 < y_2 ≤ 10^6. Similarly, (x_3, y_3) and (x_4, y_4) are the coordinates of the bottom left and top right corners of the first black sheet, respectively, with 0 ≤ x_3 < x_4 ≤ 10^6 and 0 ≤ y_3 < y_4 ≤ 10^6. Also, (x_5, y_5) and (x_6, y_6) are the coordinates of the bottom left and top right corners of the second black sheet, respectively, with 0 ≤ x_5 < x_6 ≤ 10^6 and 0 ≤ y_5 < y_6 ≤ 10^6.
def func_19():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is `False`, `args` is a list containing all the elements that were passed to the loop, `file` is `sys.stdout`, `sep` remains unchanged.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is `False`, `args` is a list containing all the elements that were passed to the loop, `file` is `sys.stdout`, `kwargs` no longer contains the key 'end' and its value is `\n` if 'end' was in `kwargs`, otherwise it remains unchanged. The value of `kwargs` now also does not contain the key 'flush' and its value is `False`, standard output includes a newline character. If `kwargs.pop('flush', False)` is `True`, the buffer of `sys.stdout` has been flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
