
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Two semifinals have just been in the running tournament. Each semifinal had n participants. There are n participants advancing to the finals, they are chosen as follows: from each semifinal, we choose k people (0 ≤ 2k ≤ n) who showed the best result in their semifinals and all other places in the finals go to the people who haven't ranked in the top k in their semifinal but got to the n - 2k of the best among the others.

The tournament organizers hasn't yet determined the k value, so the participants want to know who else has any chance to get to the finals and who can go home.

Input

The first line contains a single integer n (1 ≤ n ≤ 105) — the number of participants in each semifinal.

Each of the next n lines contains two integers ai and bi (1 ≤ ai, bi ≤ 109) — the results of the i-th participant (the number of milliseconds he needs to cover the semifinals distance) of the first and second semifinals, correspondingly. All results are distinct. Sequences a1, a2, ..., an and b1, b2, ..., bn are sorted in ascending order, i.e. in the order the participants finished in the corresponding semifinal.

Output

Print two strings consisting of n characters, each equals either "0" or "1". The first line should correspond to the participants of the first semifinal, the second line should correspond to the participants of the second semifinal. The i-th character in the j-th line should equal "1" if the i-th participant of the j-th semifinal has any chances to advance to the finals, otherwise it should equal a "0".

Examples

Input

4
9840 9920
9860 9980
9930 10020
10040 10090


Output

1110
1100


Input

4
9900 9850
9940 9930
10000 10020
10060 10110


Output

1100
1100

Note

Consider the first sample. Each semifinal has 4 participants. The results of the first semifinal are 9840, 9860, 9930, 10040. The results of the second semifinal are 9920, 9980, 10020, 10090.

  * If k = 0, the finalists are determined by the time only, so players 9840, 9860, 9920 and 9930 advance to the finals. 
  * If k = 1, the winners from both semifinals move to the finals (with results 9840 and 9920), and the other places are determined by the time (these places go to the sportsmen who run the distance in 9860 and 9930 milliseconds). 
  * If k = 2, then first and second places advance from each seminfial, these are participants with results 9840, 9860, 9920 and 9980 milliseconds. 
Program:
```
import sys

def func():
    n = int(sys.stdin.readline())
    A = []
    B = []
    T = []
    for i in range(n):
        (a, b) = map(int, sys.stdin.readline().split())
        A.append(a)
        B.append(b)
        T.append((a, i, 0))
        T.append((b, i, 1))
    T.sort()
    a = [0] * n
    b = [0] * n
    for i in range(n // 2):
        a[i] = 1
        b[i] = 1
    for i in range(n):
        if T[i][-1] == 0:
            a[T[i][1]] = 1
        else:
            b[T[i][1]] = 1
    Ans = ''
    for i in range(n):
        Ans += str(a[i])
    Ans += '\n'
    for i in range(n):
        Ans += str(b[i])
    sys.stdout.write(Ans)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly handle the case where `2k` participants advance to the finals. Specifically, the program always sets the first `n//2` positions in both lists `a` and `b` to `1`, which is incorrect. According to the problem description, only `k` participants from each semifinal should be set to `1` initially, and the remaining positions should be filled based on the top `n-2k` performers from the rest of the participants.

To fix this, the program should initialize `a` and `b` such that only the top `k` participants from each semifinal are marked as `1`. Here is a corrected version of the program:

```python
import sys

def func():
    n = int(sys.stdin.readline())
    A = []
    B = []
    T = []
    for i in range(n):
        (a, b) = map(int, sys.stdin.readline().split())
        A.append(a)
        B.append(b)
        T.append((a, i, 0))
        T.append((b, i, 1))
    T.sort()
    
    k = n // 2
    a = [0] * n
    b = [0] * n
    
    # Mark the top k participants from each semifinal
    for i in range(k):
        a[T[i][1]] = 1
        b[T[i][1]] = 1
    
    # Fill the remaining spots with the top n-2k performers from the rest
    for i in range(k, n):
        if T[i][-1] == 0:
            a[T[i][1]] = 1
        else:
            b[T[i][1]] = 1
    
    Ans = ''
    for i in range(n):
        Ans += str(a[i])
    Ans += '\n'
    for i in range(n):
        Ans += str(b[i])
    sys.stdout.write(Ans)

func()
```

This corrected version ensures that the top `k` participants from each semifinal are marked correctly and the remaining spots are filled according to the problem description.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5. The sequences a1, a2, ..., an and b1, b2, ..., bn are sorted in ascending order, representing the results of the participants in the first and second semifinals respectively.
def func():
    n = int(sys.stdin.readline())
    A = []
    B = []
    T = []
    for i in range(n):
        a, b = map(int, sys.stdin.readline().split())
        
        A.append(a)
        
        B.append(b)
        
        T.append((a, i, 0))
        
        T.append((b, i, 1))
        
    #State of the program after the  for loop has been executed: `n` is an integer within the range 1 ≤ n ≤ 10^5, `A` is a list containing `a1, a2, ..., an` (sorted in ascending order), `B` is a list containing `b1, b2, ..., bn` (sorted in ascending order), `T` is a list containing `(ai, n-1-i, 0)` and `(bi, n-1-i, 1)` for each `i` in the range 0 to n-1.
    T.sort()
    a = [0] * n
    b = [0] * n
    for i in range(n // 2):
        a[i] = 1
        
        b[i] = 1
        
    #State of the program after the  for loop has been executed: `n` is an integer within the range \(1 \leq n \leq 10^5\), `i` is exactly \(\frac{n}{2}\), `A` is a list of integers sorted in ascending order, `B` is a list of integers sorted in ascending order, `T` is a list containing pairs \((a_i, n-1-i, 0)\) and \((b_i, n-1-i, 1)\) for each \(i\) in the range 0 to \(n-1\) and is sorted in ascending order based on the values of \(a_i\) and \(b_i\), `a` is a list of length \(n\) with all elements set to 1, `b` is a list of length \(n\) with all elements set to 1.
    for i in range(n):
        if T[i][-1] == 0:
            a[T[i][1]] = 1
        else:
            b[T[i][1]] = 1
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is `n`, `A` is a list of integers sorted in ascending order, `B` is a list of integers sorted in ascending order, `T` is a list containing pairs \((a_i, n-1-i, 0)\) and \((b_i, n-1-i, 1)\) for each \(i\) in the range 0 to \(n-1\) and is sorted in ascending order based on the values of \(a_i\) and \(b_i\), `a` is a list of length \(n\) with all elements set to 1, and `b` is a list of length \(n\) with all elements set to 1. For each pair \((a_i, n-1-i, 0)\) in `T`, the element at index \(n-1-i\) in `a` is set to 1 if `T[i][-1] == 0`, and for each pair \((b_i, n-1-i, 1)\) in `T`, the element at index \(n-1-i\) in `b` is set to 1.
    Ans = ''
    for i in range(n):
        Ans += str(a[i])
        
    #State of the program after the  for loop has been executed: `Ans` is a string containing the concatenation of the string representations of all elements in the list `a`, `a` retains its original values of all ones, `i` is `n`, and `T` remains unchanged.
    Ans += '\n'
    for i in range(n):
        Ans += str(b[i])
        
    #State of the program after the  for loop has been executed: `Ans` is `"1\n" + str(b[0]) + str(b[1]) + ... + str(b[n-1])`, `i` is `n`, `a` retains its original values of all ones, `T` remains unchanged.
    sys.stdout.write(Ans)
#Overall this is what the function does:The function processes two sorted lists, `A` and `B`, which contain the results of participants in the first and second semifinals respectively. It constructs two new lists, `a` and `b`, both initialized to all ones. It then iterates through a sorted list `T` containing pairs of indices and flags, setting the corresponding elements in `a` and `b` to zero based on the flags. Finally, it concatenates the binary representations of the elements in `a` and `b` into strings and outputs them.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
