
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Mike is trying rock climbing but he is awful at it. 

There are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai < ai + 1 for all i from 1 to n - 1; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty <image>. In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1, 2, 3, 4, 5) and remove the third element from it, we obtain the sequence (1, 2, 4, 5)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

Input

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.

The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).

Output

Print a single number — the minimum difficulty of the track after removing a single hold.

Examples

Input

3
1 4 6


Output

5


Input

5
1 2 3 4 5


Output

2


Input

5
1 2 3 7 8


Output

4

Note

In the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.

In the second test after removing every hold the difficulty equals 2.

In the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.
Annotated Functions:
import fileinput

if __name__ == '__main__':
    from sys import argv
    if argv.pop() == 'test':
        func_4()
    else:
        func_3(list(fileinput.input()), verbose=True)

#Function 1:
#State of the program right berfore the function call: s is a string containing n space-separated integers ai (where 3 ≤ n ≤ 100 and 1 ≤ ai ≤ 1000), representing the heights of the holds, and the sequence ai is strictly increasing.
def func_1(s):
    return [int(x) for x in s.split()]
    #The program returns a list of integers converted from the string `s`, where `s` contains n space-separated integers ai (with 3 ≤ n ≤ 100 and 1 ≤ ai ≤ 1000), and the sequence ai is strictly increasing
#Overall this is what the function does:The function `func_1` takes a string `s` as input, which contains `n` space-separated integers `ai` (where \(3 \leq n \leq 100\) and \(1 \leq ai \leq 1000\)), and the sequence of these integers is strictly increasing. It converts this string into a list of integers and returns this list. The function ensures that the returned list maintains the strictly increasing order of the integers. There are no missing functionalities or edge cases mentioned in the provided code.

#Function 2:
#State of the program right berfore the function call: args is a list containing at least one element, and the second element of args (args[1]) is a list of integers representing the heights of the holds on the wall, where the list is sorted in strictly increasing order.
def func_2(args):
    a_s = tuple(func_1(args[1]))
    return a_s
    #`a_s` is a tuple containing the elements of the list `args[1]`, which is a list of integers representing the heights of the holds on the wall, sorted in strictly increasing order
#Overall this is what the function does:The function `func_2` accepts a single parameter `args`, which is expected to be a list with at least two elements, where the second element (`args[1]`) is a list of integers representing the heights of the holds on a climbing wall, sorted in strictly increasing order. The function then converts this list into a tuple and returns it. The function ensures that the input list `args[1]` remains unchanged and only works on its copy. There are no missing functionalities in the given code. The final state of the program after the function concludes is that `args[1]` retains its original state, while the function returns a new tuple containing the same elements as `args[1]`, also sorted in strictly increasing order.

#Function 3:
#State of the program right berfore the function call: `a_s` is a list of `int` representing the heights of the holds, where the length of `a_s` is `len(a_s) == n` and `a_s` is strictly increasing.
def func_3(args, verbose):
    a_s = func_2(args)
    max_1 = -float('inf')
    min_2 = float('inf')
    for k in xrange(len(a_s) - 1):
        max_1 = max(max_1, a_s[k + 1] - a_s[k])
        
    #State of the program after the  for loop has been executed: Let's analyze the given loop step by step to determine the final output state after all iterations of the loop have finished.
    #
    #### Initial State
    #- `a_s` is a list with at least 2 elements.
    #- `max_1` is `-float('inf')`.
    #- `min_2` is `float('inf')`.
    #
    #### Loop Code
    #```
    #for k in xrange(len(a_s) - 1):
    #    max_1 = max(max_1, a_s[k + 1] - a_s[k])
    #```
    #
    #### Step-by-Step Analysis
    #
    ##### After the First Iteration
    #- `k` starts at 0.
    #- `max_1` is updated to `max(-float('inf'), a_s[1] - a_s[0])`, so `max_1` becomes `a_s[1] - a_s[0]`.
    #
    ##### After the Second Iteration
    #- `k` increments to 1.
    #- `max_1` is updated to `max(a_s[1] - a_s[0], a_s[3] - a_s[2])`, assuming `len(a_s) >= 3`. If `len(a_s) < 3`, the loop would stop after the first iteration.
    #
    ##### After the Third Iteration
    #- `k` increments to 2.
    #- `max_1` is updated to `max(a_s[1] - a_s[0], a_s[3] - a_s[2], a_s[4] - a_s[3])`, assuming `len(a_s) >= 4`.
    #
    ##### General Pattern
    #- The loop iterates from `k = 0` to `k = len(a_s) - 2`.
    #- `max_1` is updated in each iteration to be the maximum difference between consecutive elements in the list `a_s`.
    #
    #### Final Output State
    #After all iterations of the loop have finished (if `len(a_s) >= 2`), `max_1` will be the maximum value among all differences `a_s[i + 1] - a_s[i]` for `i` ranging from `0` to `len(a_s) - 2`.
    #
    #- `a_s` remains a list with at least 2 elements.
    #- `max_1` is the maximum value among all differences `a_s[i + 1] - a_s[i]` for `i` ranging from `0` to `len(a_s) - 2`.
    #- `min_2` remains `float('inf')` because it is not updated in the loop.
    #- `k` will be `len(a_s) - 2` after the last iteration.
    #
    #### Output State
    #**Output State: `a_s` is a list with at least 2 elements, `max_1` is the maximum value among all differences `a_s[i + 1] - a_s[i]` for `i` ranging from `0` to `len(a_s) - 2`, `min_2` is `float('inf')`, `k` is `len(a_s) - 2`.**
    for k in xrange(len(a_s) - 2):
        min_2 = min(min_2, a_s[k + 2] - a_s[k])
        
    #State of the program after the  for loop has been executed: ### Step-by-Step Analysis
    #
    ##### Initial State
    #- `a_s` is a list with at least 2 elements.
    #- `max_1` is `-float('inf')`.
    #- `min_2` is `float('inf')`.
    #
    ##### Loop Code
    #```
    #for k in range(len(a_s) - 2):
    #    min_2 = min(min_2, a_s[k + 2] - a_s[k])
    #```
    #
    ##### After the First Iteration
    #- `k` starts at 0.
    #- `min_2` is updated to `min(float('inf'), a_s[2] - a_s[0])`, so `min_2` becomes `a_s[2] - a_s[0]` if `a_s[2] - a_s[0] < float('inf')`.
    #
    ##### After the Second Iteration
    #- `k` increments to 1.
    #- `min_2` is updated to `min(a_s[2] - a_s[0], a_s[4] - a_s[1])`, assuming `len(a_s) >= 4`.
    #
    ##### General Pattern
    #- The loop iterates from `k = 0` to `k = len(a_s) - 3`.
    #- `min_2` is updated in each iteration to be the minimum difference `a_s[k + 2] - a_s[k]`.
    #
    ##### Final Output State
    #After all iterations of the loop have finished (if `len(a_s) >= 3`), `min_2` will be the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`.
    #
    #- `a_s` remains a list with at least 2 elements.
    #- `max_1` remains `-float('inf')` because it is not updated in the loop.
    #- `min_2` is the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`.
    #- `k` will be `len(a_s) - 3` after the last iteration.
    #
    #### Output State
    #**Output State: `a_s` is a list with at least 2 elements, `max_1` is `-float('inf')`, `min_2` is the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`, `k` is `len(a_s) - 3`.**
    return max(max_1, min_2)
    #`a_s` is a list with at least 2 elements, `max_1` is `-float('inf')`, `min_2` is the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`, `k` is `len(a_s) - 3`, and the program returns the maximum value between `max_1` and `min_2`.
#Overall this is what the function does:The function `func_3` accepts a list of integers `args` and a boolean `verbose`. It processes the list `args` to compute two values: `max_1`, which is the maximum difference between consecutive elements in the list, and `min_2`, which is the minimum difference between elements that are two positions apart in the list. After computing these values, the function returns the maximum of `max_1` and `min_2`. If the list `args` contains fewer than 3 elements, the function will still execute the loops but will result in `max_1` being `-float('inf')` and `min_2` being `float('inf')` if the list has fewer than 2 elements, respectively. The function does not modify the original list `args`; instead, it uses local variables `max_1` and `min_2` to store the computed values.

#Function 4:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100, and a list of n integers representing the heights ai of the holds where each height is a positive integer not exceeding 1000, and the sequence is strictly increasing.
def func_4():
#Overall this is what the function does:The function `func_4()` accepts an integer `n` (where 3 ≤ n ≤ 100) and a list of `n` integers representing the strictly increasing heights `ai` of the holds (each height being a positive integer not exceeding 1000). After execution, the function will ensure that the list of heights is sorted in ascending order. If the input list is already sorted, no changes will be made. The function does not return any value; instead, it modifies the input list in place.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.