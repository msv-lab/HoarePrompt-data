
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Mike is trying rock climbing but he is awful at it. 

There are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai < ai + 1 for all i from 1 to n - 1; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty <image>. In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1, 2, 3, 4, 5) and remove the third element from it, we obtain the sequence (1, 2, 4, 5)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

Input

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.

The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).

Output

Print a single number — the minimum difficulty of the track after removing a single hold.

Examples

Input

3
1 4 6


Output

5


Input

5
1 2 3 4 5


Output

2


Input

5
1 2 3 7 8


Output

4

Note

In the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.

In the second test after removing every hold the difficulty equals 2.

In the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.
Program:
```
import fileinput
#Function 1:
def func_1(s):
    return [int(x) for x in s.split()]

#Function 2:
def func_2(args):
    a_s = tuple(func_1(args[1]))
    return a_s

#Function 3:
def func_3(args, verbose=False):
    a_s = func_2(args)
    max_1 = -float('inf')
    min_2 = float('inf')
    for k in xrange(len(a_s) - 1):
        max_1 = max(max_1, a_s[k + 1] - a_s[k])
    for k in xrange(len(a_s) - 2):
        min_2 = min(min_2, a_s[k + 2] - a_s[k])
    return max(max_1, min_2)

#Function 4:
def func_4():
    assert func_1('1 2 3') == [1, 2, 3]
    assert func_3(['3', '1 4 6']) == 5
    assert func_3(['5', '1 2 3 4 5']) == 2
    assert func_3(['5', '1 2 3 7 8']) == 4


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly handle the scenario where the hold to be removed is either the second or the second-to-last hold in the sequence. Let's analyze the given examples and identify the issue:

1. **Example 1**: Input `3 1 4 6`
   - Removing the second hold results in `1, 6` with a difficulty of `5`.
   - This is correct.

2. **Example 2**: Input `5 1 2 3 4 5`
   - Removing any hold results in a difficulty of `2`.
   - This is correct.

3. **Example 3**: Input `5 1 2 3 7 8`
   - The output is `4`, but this is incorrect. If we remove the second hold, we get `1, 3, 7, 8` with a difficulty of `4`. However, if we remove the fourth hold, we get `1, 2, 3, 8` with a difficulty of `5`. The correct minimum difficulty should be `4`.

The current implementation of `func_3` calculates the maximum difference between consecutive elements and the minimum difference between the second-to-last and first elements. However, it does not account for the scenario where the removed hold is the second or second-to-last element. To fix this, we need to consider these specific cases separately.

Here is a corrected version of the program:

```python
def func_3(args):
    a_s = [int(x) for x in args[1].split()]
    max_diff = a_s[1] - a_s[0]
    min_diff = a_s[-1] - a_s[-2]
    
    # Check removing the second element
    if len(a_s) > 2:
        diff = a_s[2] - a_s[0]
        max_diff = max(max_diff, diff)
    
    # Check removing the second-to-last element
    if len(a_s) > 3:
        diff = a_s[-1] - a_s[-3]
        min_diff = min(min_diff, diff)
    
    # Calculate the new max difficulty after removing each hold
    for k in range(1, len(a_s) - 1):
        diff = a_s[k + 1] - a_s[k - 1]
        max_diff = max(max_diff, diff)
    
    return max_diff

# Testing the function with the provided examples
assert func_3(['3', '1 4 6']) == 5
assert func_3(['5', '1 2 3 4 5']) == 2
assert func_3(['5', '1 2 3 7 8']) == 4
```

This corrected function ensures that all possible cases of removing a hold are considered, including the second and second-to-last elements.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import fileinput

if __name__ == '__main__':
    from sys import argv
    if argv.pop() == 'test':
        func_4()
    else:
        func_3(list(fileinput.input()), verbose=True)

#Function 1:
#State of the program right berfore the function call: s is a string containing n space-separated integers ai (where 3 ≤ n ≤ 100 and 1 ≤ ai ≤ 1000), representing the heights of the holds, and the sequence ai is strictly increasing.
def func_1(s):
    return [int(x) for x in s.split()]
    #The program returns a list of integers converted from the string `s`, where `s` contains n space-separated integers ai (with 3 ≤ n ≤ 100 and 1 ≤ ai ≤ 1000), and the sequence ai is strictly increasing

#Function 2:
#State of the program right berfore the function call: args is a list containing at least one element, and the second element of args (args[1]) is a list of integers representing the heights of the holds on the wall, where the list is sorted in strictly increasing order.
def func_2(args):
    a_s = tuple(func_1(args[1]))
    return a_s
    #`a_s` is a tuple containing the elements of the list `args[1]`, which is a list of integers representing the heights of the holds on the wall, sorted in strictly increasing order

#Function 3:
#State of the program right berfore the function call: `a_s` is a list of `int` representing the heights of the holds, where the length of `a_s` is `len(a_s) == n` and `a_s` is strictly increasing.
def func_3(args, verbose):
    a_s = func_2(args)
    max_1 = -float('inf')
    min_2 = float('inf')
    for k in xrange(len(a_s) - 1):
        max_1 = max(max_1, a_s[k + 1] - a_s[k])
        
    #State of the program after the  for loop has been executed: Let's analyze the given loop step by step to determine the final output state after all iterations of the loop have finished.
    #
    #### Initial State
    #- `a_s` is a list with at least 2 elements.
    #- `max_1` is `-float('inf')`.
    #- `min_2` is `float('inf')`.
    #
    #### Loop Code
    #```
    #for k in xrange(len(a_s) - 1):
    #    max_1 = max(max_1, a_s[k + 1] - a_s[k])
    #```
    #
    #### Step-by-Step Analysis
    #
    ##### After the First Iteration
    #- `k` starts at 0.
    #- `max_1` is updated to `max(-float('inf'), a_s[1] - a_s[0])`, so `max_1` becomes `a_s[1] - a_s[0]`.
    #
    ##### After the Second Iteration
    #- `k` increments to 1.
    #- `max_1` is updated to `max(a_s[1] - a_s[0], a_s[3] - a_s[2])`, assuming `len(a_s) >= 3`. If `len(a_s) < 3`, the loop would stop after the first iteration.
    #
    ##### After the Third Iteration
    #- `k` increments to 2.
    #- `max_1` is updated to `max(a_s[1] - a_s[0], a_s[3] - a_s[2], a_s[4] - a_s[3])`, assuming `len(a_s) >= 4`.
    #
    ##### General Pattern
    #- The loop iterates from `k = 0` to `k = len(a_s) - 2`.
    #- `max_1` is updated in each iteration to be the maximum difference between consecutive elements in the list `a_s`.
    #
    #### Final Output State
    #After all iterations of the loop have finished (if `len(a_s) >= 2`), `max_1` will be the maximum value among all differences `a_s[i + 1] - a_s[i]` for `i` ranging from `0` to `len(a_s) - 2`.
    #
    #- `a_s` remains a list with at least 2 elements.
    #- `max_1` is the maximum value among all differences `a_s[i + 1] - a_s[i]` for `i` ranging from `0` to `len(a_s) - 2`.
    #- `min_2` remains `float('inf')` because it is not updated in the loop.
    #- `k` will be `len(a_s) - 2` after the last iteration.
    #
    #### Output State
    #**Output State: `a_s` is a list with at least 2 elements, `max_1` is the maximum value among all differences `a_s[i + 1] - a_s[i]` for `i` ranging from `0` to `len(a_s) - 2`, `min_2` is `float('inf')`, `k` is `len(a_s) - 2`.**
    for k in xrange(len(a_s) - 2):
        min_2 = min(min_2, a_s[k + 2] - a_s[k])
        
    #State of the program after the  for loop has been executed: ### Step-by-Step Analysis
    #
    ##### Initial State
    #- `a_s` is a list with at least 2 elements.
    #- `max_1` is `-float('inf')`.
    #- `min_2` is `float('inf')`.
    #
    ##### Loop Code
    #```
    #for k in range(len(a_s) - 2):
    #    min_2 = min(min_2, a_s[k + 2] - a_s[k])
    #```
    #
    ##### After the First Iteration
    #- `k` starts at 0.
    #- `min_2` is updated to `min(float('inf'), a_s[2] - a_s[0])`, so `min_2` becomes `a_s[2] - a_s[0]` if `a_s[2] - a_s[0] < float('inf')`.
    #
    ##### After the Second Iteration
    #- `k` increments to 1.
    #- `min_2` is updated to `min(a_s[2] - a_s[0], a_s[4] - a_s[1])`, assuming `len(a_s) >= 4`.
    #
    ##### General Pattern
    #- The loop iterates from `k = 0` to `k = len(a_s) - 3`.
    #- `min_2` is updated in each iteration to be the minimum difference `a_s[k + 2] - a_s[k]`.
    #
    ##### Final Output State
    #After all iterations of the loop have finished (if `len(a_s) >= 3`), `min_2` will be the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`.
    #
    #- `a_s` remains a list with at least 2 elements.
    #- `max_1` remains `-float('inf')` because it is not updated in the loop.
    #- `min_2` is the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`.
    #- `k` will be `len(a_s) - 3` after the last iteration.
    #
    #### Output State
    #**Output State: `a_s` is a list with at least 2 elements, `max_1` is `-float('inf')`, `min_2` is the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`, `k` is `len(a_s) - 3`.**
    return max(max_1, min_2)
    #`a_s` is a list with at least 2 elements, `max_1` is `-float('inf')`, `min_2` is the minimum value among all differences `a_s[k + 2] - a_s[k]` for `k` ranging from `0` to `len(a_s) - 3`, `k` is `len(a_s) - 3`, and the program returns the maximum value between `max_1` and `min_2`.

#Function 4:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100, and a list of n integers representing the heights ai of the holds where each height is a positive integer not exceeding 1000, and the sequence is strictly increasing.
def func_4():



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
