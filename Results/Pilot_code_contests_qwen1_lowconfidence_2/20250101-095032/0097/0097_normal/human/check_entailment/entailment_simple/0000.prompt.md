
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
class ostream:

    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 100. For each pair (p_i, c_i), p_i and c_i are non-negative integers such that 0 <= p_i, c_i <= 1000, and the pairs are given in chronological order.
def func_1():
    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        
        zz = []
        
        for _ in range(n):
            zz.append(LIST())
        
        prevplay = 0
        
        prevClr = 0
        
        flag = 0
        
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        
        if flag == 1:
            print('NO')
        else:
            print('YES')
        
        t -= 1
        
    #State of the program after the loop has been executed: `t` is 0, `flag` is either 1 or 0 based on the conditions met during the loop iterations, `n` is a non-negative integer, `zz` is a list of `n` elements where each element is a LIST(), `prevplay` is the last value of `zz[i][0]` in the loop, `prevClr` is the last value of `zz[i][1]` in the loop, `INF` is float('inf'), `pairs` (p_i, c_i) are unchanged, `mod` is 1000000007

#Function 2:
#State of the program right berfore the function call: T is a positive integer such that 1 <= T <= 500. For each test case, n is a positive integer such that 1 <= n <= 100. Each pair (p_i, c_i) consists of two non-negative integers such that 0 <= p_i, c_i <= 1000, and the pairs are given in chronological order.
def STR():
    return list(input())
    #The program returns a list of strings representing each input pair (p_i, c_i) in chronological order

#Function 3:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 500. For each test case, n is an integer such that 1 ≤ n ≤ 100. Each pair (p_i, c_i) consists of two non-negative integers such that 0 ≤ p_i, c_i ≤ 1000, and the pairs are given in chronological order.
def INT():
    return int(input())
    #The program returns an integer input from the user, which is within the range of 1 to 500

#Function 4:
#State of the program right berfore the function call: T is a positive integer indicating the number of test cases. For each test case, n is a positive integer representing the number of moments Polycarp peeked at the stats. The pairs (p_i, c_i) represent the number of plays and the number of clears at the i-th moment of time, respectively, and they are provided in chronological order. Both p_i and c_i are non-negative integers not exceeding 1000.
def MAP():
    return map(int, input().split())
    #The program returns a map object containing integers parsed from user input, specifically the number of test cases followed by pairs of integers (p_i, c_i) for each test case

#Function 5:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 500. For each test case, n is an integer such that 1 ≤ n ≤ 100. Each line contains two integers p_i and c_i such that 0 ≤ p_i, c_i ≤ 1000, representing the number of plays and the number of clears at the i-th moment of time, respectively, and the pairs are given in chronological order.
def LIST():
    return list(map(int, input().split()))
    #The program returns a list of integers [p_i, c_i] for each line of input, where 0 ≤ p_i, c_i ≤ 1000, representing the number of plays and the number of clears at the i-th moment of time, respectively, and the pairs are given in chronological order

#Function 6:
#State of the program right berfore the function call: a and b are non-negative integers representing the dimensions of the 2D list, and c is the value to fill in every cell of the 2D list.
def list2d(a, b, c):
    return [([c] * b) for i in range(a)]
    #The program returns a 2D list with 'a' rows and 'b' columns, where every cell contains the value 'c'

#Function 7:
#State of the program right berfore the function call: `listOfTuples` is a list of tuples, where each tuple contains two non-negative integers representing the number of plays and clears at a certain moment. `idx` is an integer that specifies the index (0 or 1) to sort the list of tuples.
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])
    #`listOfTuples` sorted based on the idx-th element of each tuple, where each tuple contains two non-negative integers representing the number of plays and clears at a certain moment

#Function 8:
#State of the program right berfore the function call: passedDic is a dictionary where keys are integers representing timestamps (or any monotonically increasing values) and values are tuples (p, c) where p is an integer representing the number of plays and c is an integer representing the number of clears at the corresponding timestamp. The dictionary is not necessarily sorted, but the input pairs (p, c) for each timestamp are valid (i.e., 0 ≤ p, c ≤ 1000) and the timestamps are unique.
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
        
    #State of the program after the  for loop has been executed: `passedDic` is a dictionary where keys are integers representing timestamps and values are tuples (p, c); `temp` is a list of tuples that may be empty; `toret` is a dictionary containing all key-value pairs where the key is the timestamp and the value is the tuple (p, c) from `passedDic` corresponding to that timestamp.
    return toret
    #The program returns `toret` which is a dictionary containing all key-value pairs where the key is the timestamp and the value is the tuple (p, c) from `passedDic` corresponding to that timestamp

#Function 9:
#State of the program right berfore the function call: passedDic is a dictionary where the keys are non-negative integers representing moments of time and the values are tuples (p, c) where p is the number of plays and c is the number of clears at that moment. The dictionary is assumed to be sorted in ascending order by default.
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))
    #The program returns a dictionary where the items are sorted in ascending order by their keys, which are non-negative integers representing moments of time, and the values are tuples (p, c) where p is the number of plays and c is the number of clears at those moments.

#Function 10:
#State of the program right berfore the function call: zero is an integer representing the initial value of numb, s is a bytes object containing the input data, and py2 is a boolean indicating whether the code is running in Python 2 (which is assumed to be False in this context).
def func_2(zero):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            
            i += 1
            
        #State of the program after the loop has been executed: `zero` is an integer, `s` is a bytes object containing the input data read from standard input, `py2` is `False`, `conv` is a lambda function that returns its input, `A` is a list containing the accumulated integers based on the input string `s`, `numb` is `zero`, `sign` is `1`, and `i` is the index of the next character in `s` to be processed.
    except:
        pass
    #State of the program after the try-except block has been executed: `zero` is an integer, `s` is a bytes object containing the input data read from standard input, `py2` is `False`, `conv` is a lambda function that returns its input, `A` is a list containing the accumulated integers based on the input string `s`, `numb` is `zero`, `sign` is `1`, and `i` is the index of the next character in `s` to be processed.
    if (s and s[-1] >= b'0'[0]) :
        A.append(sign * numb)
    #State of the program after the if block has been executed: *`zero` is an integer, `s` is a bytes object containing the input data read from standard input, `py2` is `False`, `conv` is a lambda function that returns its input, `A` is a list containing the accumulated integers based on the input string `s` with an additional element `zero`, `numb` is `zero`, `sign` is `1`, and `i` is the index of the next character in `s` to be processed. If the last character of `s` is greater than or equal to the ASCII value of '0', `A` includes an additional element `zero`. Otherwise, the state remains unchanged.
    return A
    #`A` is a list containing the accumulated integers based on the input string `s` with an additional element `zero`. If the last character of `s` is greater than or equal to the ASCII value of '0', `A` includes an additional element `zero`. Otherwise, the state remains unchanged.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
