
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats n times and wrote down n pairs of integers — (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.

Input

The first line contains a single integer T (1 ≤ T ≤ 500) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the number of moments of time Polycarp peeked at the stats.

Each of the next n lines contains two integers p_i and c_i (0 ≤ p_i, c_i ≤ 1000) — the number of plays and the number of clears of the level at the i-th moment of time.

Note that the stats are given in chronological order.

Output

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print "YES".

Otherwise, print "NO".

You can print each letter in any case (upper or lower).

Example

Input


6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0


Output


NO
YES
NO
YES
NO
YES

Note

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Annotated Functions:
from __future__ import division, print_function
import os, sys
from io import IOBase, BytesIO
import sys

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
class ostream:

    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 100. For each pair (p_i, c_i), p_i and c_i are non-negative integers such that 0 <= p_i, c_i <= 1000, and the pairs are given in chronological order.
def func_1():
    INF = float('inf')
    mod = 10 ** 9 + 7
    t = INT()
    while t != 0:
        n = INT()
        
        zz = []
        
        for _ in range(n):
            zz.append(LIST())
        
        prevplay = 0
        
        prevClr = 0
        
        flag = 0
        
        for i in range(n):
            if zz[i][0] < prevplay or zz[i][1] < prevClr or zz[i][0] < zz[i][1]:
                flag = 1
                break
            if zz[i][1] > prevClr:
                temp = zz[i][1] - prevClr
                temp1 = zz[i][0] - prevplay
                if temp > temp1:
                    flag = 1
                    break
            prevplay = zz[i][0]
            prevClr = zz[i][1]
        
        if flag == 1:
            print('NO')
        else:
            print('YES')
        
        t -= 1
        
    #State of the program after the loop has been executed: `t` is 0, `flag` is either 1 or 0 based on the conditions met during the loop iterations, `n` is a non-negative integer, `zz` is a list of `n` elements where each element is a LIST(), `prevplay` is the last value of `zz[i][0]` in the loop, `prevClr` is the last value of `zz[i][1]` in the loop, `INF` is float('inf'), `pairs` (p_i, c_i) are unchanged, `mod` is 1000000007
#Overall this is what the function does:The function processes a series of pairs \((p_i, c_i)\) for a given positive integer \(n\) (where \(1 \leq n \leq 100\)). It checks if the pairs meet certain conditions. Specifically, it verifies that for each pair \((p_i, c_i)\):

1. \(p_i \geq prevplay\) and \(c_i \geq prevClr\).
2. If \(c_i > prevClr\), then \(c_i - prevClr \leq p_i - prevplay\).

If any of these conditions fail for any pair, the function prints 'NO'. Otherwise, it prints 'YES'. After processing all pairs, the function ends.

#Function 2:
#State of the program right berfore the function call: T is a positive integer such that 1 <= T <= 500. For each test case, n is a positive integer such that 1 <= n <= 100. Each pair (p_i, c_i) consists of two non-negative integers such that 0 <= p_i, c_i <= 1000, and the pairs are given in chronological order.
def STR():
    return list(input())
    #The program returns a list of strings representing each input pair (p_i, c_i) in chronological order
#Overall this is what the function does:The function `STR()` does not accept any parameters and returns a list of strings. Each string in the list represents a pair `(p_i, c_i)` in chronological order, where `p_i` and `c_i` are non-negative integers. The function reads input from the user using `input()`, which means it expects the user to provide the pairs `(p_i, c_i)` through standard input. The function simply converts the entire input into a list of strings without any further processing or validation.

#Function 3:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 500. For each test case, n is an integer such that 1 ≤ n ≤ 100. Each pair (p_i, c_i) consists of two non-negative integers such that 0 ≤ p_i, c_i ≤ 1000, and the pairs are given in chronological order.
def INT():
    return int(input())
    #The program returns an integer input from the user, which is within the range of 1 to 500
#Overall this is what the function does:The function `INT()` reads an integer input from the user and ensures that the input is within the range of 1 to 500. If the input is outside this range, the function will repeatedly prompt the user until a valid integer within the specified range is provided. The function accepts no parameters and returns a single integer value that is guaranteed to be between 1 and 500 inclusive.

#Function 4:
#State of the program right berfore the function call: T is a positive integer indicating the number of test cases. For each test case, n is a positive integer representing the number of moments Polycarp peeked at the stats. The pairs (p_i, c_i) represent the number of plays and the number of clears at the i-th moment of time, respectively, and they are provided in chronological order. Both p_i and c_i are non-negative integers not exceeding 1000.
def MAP():
    return map(int, input().split())
    #The program returns a map object containing integers parsed from user input, specifically the number of test cases followed by pairs of integers (p_i, c_i) for each test case
#Overall this is what the function does:The function `MAP()` reads input from the user and returns a map object containing integers. Specifically, it first reads the number of test cases, followed by pairs of integers (p_i, c_i) for each test case, where p_i represents the number of plays and c_i represents the number of clears at the i-th moment of time. The function does not perform any calculations or validations on these inputs; it simply parses them into a map object. Potential edge cases include scenarios where the input does not follow the expected format, such as non-integer values or negative numbers. If the input is invalid, the function will still attempt to parse it, which could lead to unexpected behavior or errors downstream.

#Function 5:
#State of the program right berfore the function call: T is an integer such that 1 ≤ T ≤ 500. For each test case, n is an integer such that 1 ≤ n ≤ 100. Each line contains two integers p_i and c_i such that 0 ≤ p_i, c_i ≤ 1000, representing the number of plays and the number of clears at the i-th moment of time, respectively, and the pairs are given in chronological order.
def LIST():
    return list(map(int, input().split()))
    #The program returns a list of integers [p_i, c_i] for each line of input, where 0 ≤ p_i, c_i ≤ 1000, representing the number of plays and the number of clears at the i-th moment of time, respectively, and the pairs are given in chronological order
#Overall this is what the function does:The function processes input from the standard input, which consists of multiple lines, each containing two integers \( p_i \) and \( c_i \) separated by a space, where \( 0 \leq p_i, c_i \leq 1000 \). The function returns a list of lists, where each inner list contains the integers \( p_i \) and \( c_i \) from each line of input, maintaining the chronological order of the input. The function accepts no explicit parameters and operates on the standard input. It handles cases where the input format might be incorrect by converting the input into integers using `map(int, input().split())`, ensuring that the values are within the specified range. If the input cannot be converted to integers, the function will raise a `ValueError`.

#Function 6:
#State of the program right berfore the function call: a and b are non-negative integers representing the dimensions of the 2D list, and c is the value to fill in every cell of the 2D list.
def list2d(a, b, c):
    return [([c] * b) for i in range(a)]
    #The program returns a 2D list with 'a' rows and 'b' columns, where every cell contains the value 'c'
#Overall this is what the function does:The function `list2d` accepts three parameters: `a`, `b`, and `c`. It returns a 2D list with `a` rows and `b` columns, where every cell contains the value `c`. This is achieved by using a list comprehension that creates `a` rows, each containing a list of `b` elements, all initialized to `c`. The function handles the case where `a` and `b` are non-negative integers. If `a` or `b` were negative, the function would raise an error since the loop in the list comprehension would not execute. However, the function does not explicitly handle non-integer inputs for `a` and `b`, which could lead to unexpected behavior if non-integers are passed. Additionally, the function does not validate that `c` is a valid data type for the cells, although typically `c` would be an integer, float, or string. The final state of the program after the function concludes is that it returns a 2D list with `a` rows and `b` columns, where every cell is filled with the value `c`.

#Function 7:
#State of the program right berfore the function call: `listOfTuples` is a list of tuples, where each tuple contains two non-negative integers representing the number of plays and clears at a certain moment. `idx` is an integer that specifies the index (0 or 1) to sort the list of tuples.
def sortListWithIndex(listOfTuples, idx):
    return sorted(listOfTuples, key=lambda x: x[idx])
    #`listOfTuples` sorted based on the idx-th element of each tuple, where each tuple contains two non-negative integers representing the number of plays and clears at a certain moment
#Overall this is what the function does:The function `sortListWithIndex` takes a list of tuples, where each tuple contains two non-negative integers representing the number of plays and clears at a certain moment, and an integer `idx` specifying the index (0 or 1) to sort the list of tuples. It returns a new list that is sorted based on the `idx`-th element of each tuple. If `idx` is 0, the list will be sorted based on the number of plays; if `idx` is 1, the list will be sorted based on the number of clears. The original `listOfTuples` remains unchanged. Edge cases include when `idx` is neither 0 nor 1, in which case the function will still return a sorted list based on the first element of each tuple due to the default behavior of the `sorted` function.

#Function 8:
#State of the program right berfore the function call: passedDic is a dictionary where keys are integers representing timestamps (or any monotonically increasing values) and values are tuples (p, c) where p is an integer representing the number of plays and c is an integer representing the number of clears at the corresponding timestamp. The dictionary is not necessarily sorted, but the input pairs (p, c) for each timestamp are valid (i.e., 0 ≤ p, c ≤ 1000) and the timestamps are unique.
def sortDictWithVal(passedDic):
    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))
    toret = {}
    for tup in temp:
        toret[tup[0]] = tup[1]
        
    #State of the program after the  for loop has been executed: `passedDic` is a dictionary where keys are integers representing timestamps and values are tuples (p, c); `temp` is a list of tuples that may be empty; `toret` is a dictionary containing all key-value pairs where the key is the timestamp and the value is the tuple (p, c) from `passedDic` corresponding to that timestamp.
    return toret
    #The program returns `toret` which is a dictionary containing all key-value pairs where the key is the timestamp and the value is the tuple (p, c) from `passedDic` corresponding to that timestamp
#Overall this is what the function does:The function `sortDictWithVal` accepts a dictionary `passedDic` where keys are integers representing timestamps and values are tuples `(p, c)` representing the number of plays and clears at those timestamps. The function first sorts the items of `passedDic` based on the values of the tuples `(p, c)` in ascending order, and if two tuples have the same value, it sorts them based on their keys in ascending order. It then constructs a new dictionary `toret` from the sorted items. The function returns `toret`, which contains all key-value pairs from `passedDic` where the keys are timestamps and the values are tuples `(p, c)` corresponding to those timestamps. The function handles the case where `passedDic` is empty by returning an empty dictionary. No edge cases are explicitly mentioned, but the function correctly handles dictionaries with duplicate values by sorting based on both the value and key.

#Function 9:
#State of the program right berfore the function call: passedDic is a dictionary where the keys are non-negative integers representing moments of time and the values are tuples (p, c) where p is the number of plays and c is the number of clears at that moment. The dictionary is assumed to be sorted in ascending order by default.
def sortDictWithKey(passedDic):
    return dict(OrderedDict(sorted(passedDic.items())))
    #The program returns a dictionary where the items are sorted in ascending order by their keys, which are non-negative integers representing moments of time, and the values are tuples (p, c) where p is the number of plays and c is the number of clears at those moments.
#Overall this is what the function does:The function `sortDictWithKey` takes a dictionary `passedDic` as input, where the keys are non-negative integers representing moments of time and the values are tuples `(p, c)` indicating the number of plays `p` and clears `c` at those moments. The function returns a new dictionary where the items are sorted in ascending order by their keys. This means the keys (moments of time) in the returned dictionary are in increasing order, and the values remain tuples `(p, c)` representing the number of plays and clears at those moments. No changes are made to the original dictionary; a new sorted dictionary is created and returned.

#Function 10:
#State of the program right berfore the function call: zero is an integer representing the initial value of numb, s is a bytes object containing the input data, and py2 is a boolean indicating whether the code is running in Python 2 (which is assumed to be False in this context).
def func_2(zero):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            
            i += 1
            
        #State of the program after the loop has been executed: `zero` is an integer, `s` is a bytes object containing the input data read from standard input, `py2` is `False`, `conv` is a lambda function that returns its input, `A` is a list containing the accumulated integers based on the input string `s`, `numb` is `zero`, `sign` is `1`, and `i` is the index of the next character in `s` to be processed.
    except:
        pass
    #State of the program after the try-except block has been executed: `zero` is an integer, `s` is a bytes object containing the input data read from standard input, `py2` is `False`, `conv` is a lambda function that returns its input, `A` is a list containing the accumulated integers based on the input string `s`, `numb` is `zero`, `sign` is `1`, and `i` is the index of the next character in `s` to be processed.
    if (s and s[-1] >= b'0'[0]) :
        A.append(sign * numb)
    #State of the program after the if block has been executed: *`zero` is an integer, `s` is a bytes object containing the input data read from standard input, `py2` is `False`, `conv` is a lambda function that returns its input, `A` is a list containing the accumulated integers based on the input string `s` with an additional element `zero`, `numb` is `zero`, `sign` is `1`, and `i` is the index of the next character in `s` to be processed. If the last character of `s` is greater than or equal to the ASCII value of '0', `A` includes an additional element `zero`. Otherwise, the state remains unchanged.
    return A
    #`A` is a list containing the accumulated integers based on the input string `s` with an additional element `zero`. If the last character of `s` is greater than or equal to the ASCII value of '0', `A` includes an additional element `zero`. Otherwise, the state remains unchanged.
#Overall this is what the function does:The function `func_2` accepts an integer `zero` and reads a bytes object `s` from standard input. It processes the bytes object `s` character by character to accumulate integers into a list `A`. During processing, it handles the sign of the number (positive or negative) and ensures that each integer is appended to the list `A`. After the loop, it checks if the last character of `s` is a digit; if so, it appends `zero` to `A`. Finally, it returns the list `A`. Potential edge cases include reading non-digit characters and ensuring that the loop correctly handles the termination condition. The function assumes that the code is running in Python 3, where `py2` is set to `False`.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.