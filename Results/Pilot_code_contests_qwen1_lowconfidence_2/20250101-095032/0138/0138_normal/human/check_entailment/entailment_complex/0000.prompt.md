
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everything got unclear to us in a far away constellation Tau Ceti. Specifically, the Taucetians choose names to their children in a very peculiar manner.

Two young parents abac and bbad think what name to give to their first-born child. They decided that the name will be the permutation of letters of string s. To keep up with the neighbours, they decided to call the baby so that the name was lexicographically strictly larger than the neighbour's son's name t.

On the other hand, they suspect that a name tax will be introduced shortly. According to it, the Taucetians with lexicographically larger names will pay larger taxes. That's the reason abac and bbad want to call the newborn so that the name was lexicographically strictly larger than name t and lexicographically minimum at that.

The lexicographical order of strings is the order we are all used to, the "dictionary" order. Such comparison is used in all modern programming languages to compare strings. Formally, a string p of length n is lexicographically less than string q of length m, if one of the two statements is correct:

  * n < m, and p is the beginning (prefix) of string q (for example, "aba" is less than string "abaa"), 
  * p1 = q1, p2 = q2, ..., pk - 1 = qk - 1, pk < qk for some k (1 ≤ k ≤ min(n, m)), here characters in strings are numbered starting from 1. 



Write a program that, given string s and the heighbours' child's name t determines the string that is the result of permutation of letters in s. The string should be lexicographically strictly more than t and also, lexicographically minimum.

Input

The first line contains a non-empty string s (1 ≤ |s| ≤ 5000), where |s| is its length. The second line contains a non-empty string t (1 ≤ |t| ≤ 5000), where |t| is its length. Both strings consist of lowercase Latin letters.

Output

Print the sought name or -1 if it doesn't exist.

Examples

Input

aad
aac


Output

aad


Input

abad
bob


Output

daab


Input

abc
defg


Output

-1


Input

czaaab
abcdef


Output

abczaa

Note

In the first sample the given string s is the sought one, consequently, we do not need to change the letter order there.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
print(func_1())

#State of the program right berfore the function call: s and t are non-empty strings consisting of lowercase Latin letters, with lengths satisfying 1 ≤ |s|, |t| ≤ 5000.
def func_1():
    s = list(raw_input())
    t = list(raw_input())
    scount = [0] * 26
    tcount = [0] * 26
    for char in s:
        scount[ord(char) - ord('a')] += 1
        
    #State of the program after the  for loop has been executed: `s` is a non-empty list of characters, `t` is a list of characters, `scount` is a list of 26 integers where each index corresponds to the count of a character ('a' to 'z') in `s`, and `tcount` is [0] * 26.
    for char in t:
        tcount[ord(char) - ord('a')] += 1
        
    #State of the program after the  for loop has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements, where the index corresponding to `char` is now the length of `t`.
    allgreater = True
    for i in range(26):
        if scount[i] < tcount[i]:
            allgreater = False
        
    #State of the program after the  for loop has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements where the index corresponding to `char` is now the length of `t`, `allgreater` is `False`.
    if allgreater :
        if (len(s) == len(t)) :
            return -1
            #The program returns -1
        #State of the program after the if block has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements where the index corresponding to `char` is now the length of `t`, `allgreater` is `True`, and the length of `s` is not equal to the length of `t`
        for char in t:
            scount[ord(char) - ord('a')] -= 1
            
        #State of the program after the  for loop has been executed: Output State:
        for i in range(26):
            while scount[i] > 0:
                t.append(chr(i + ord('a')))
                scount[i] -= 1
            
        #State of the program after the  for loop has been executed: `i` is 26, `scount[26]` is 0, `t` is a list containing all characters `chr(i + ord('a'))` for each positive `scount[i]` where the loop executed for `i` from 0 to 25.
        return ''.join(map(str, t))
        #The program returns the string 'z', since scount[26] is 0, the list t is empty, and ''.join([]) results in an empty string, but given the initial conditions and the mapping, it specifically maps to 'z' as the character for i = 26 - 26 (0) which is 'z'.
    #State of the program after the if block has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements where the index corresponding to `char` is now the length of `t`, `allgreater` is `True`
    works = -1
    scountcopy = list(scount)
    for i in range(len(s)):
        cando = False
        
        for j in range(ord(t[i]) - ord('a') + 1, 26):
            if scountcopy[j] > 0:
                cando = True
        
        if cando:
            works = i
        
        if scountcopy[ord(t[i]) - ord('a')] == 0:
            break
        
        scountcopy[ord(t[i]) - ord('a')] -= 1
        
    #State of the program after the  for loop has been executed: To determine the output state after all iterations of the loop have finished, let's analyze the loop code and the provided output states.
    #
    #### Analysis of the Loop Code:
    #The loop iterates over each character in the string `s`. For each character `t[i]`:
    #1. A flag `cando` is set to `False`.
    #2. A nested loop checks if there are enough characters of a certain type (from `t[i]` to 'z') in `scountcopy`.
    #3. If `cando` becomes `True`, `works` is updated to `i`.
    #4. If the count of `t[i]` in `scountcopy` is 0, the loop breaks.
    #5. The count of `t[i]` in `scountcopy` is decremented.
    #
    #### Observations from Provided Output States:
    #- After the loop executes 1 time, `cando` is `True`, `t[i]` is a lowercase letter, `scountcopy[ord(t[i]) - ord('a')]` is 0, and `works` is `i`.
    #- After the loop executes 2 times, `cando` is `False`, `t[i + 1]` is a lowercase letter, `scountcopy[ord(t[i + 1]) - ord('a')]` is 0, and `works` is `i + 1`.
    #- After the loop executes 3 times, `t[i + 2]` is a lowercase letter, `scountcopy[ord(t[i + 2]) - ord('a')]` is -1, `ord(t[i]) - ord('a') + 1` is less than or equal to 25, and `cando` is `True`.
    #
    #### Understanding the Loop Execution:
    #- The loop continues until it cannot find any character that can be used (i.e., `cando` remains `False`).
    #- The `works` variable keeps track of the index at which the loop was able to find a valid character.
    #- If the loop completes without breaking, `works` will be the last index that could have been updated.
    #
    #### Final State Analysis:
    #- If the loop completes (i.e., no `break` occurs), `works` will be the last index such that `cando` became `True` and `scountcopy[ord(t[works]) - ord('a')]` is 0.
    #- If the loop does not complete (i.e., it breaks due to `scountcopy[ord(t[i]) - ord('a')]` being 0), `works` will be the last index that was checked.
    #
    #### Output State:
    #- `len(s)` must be greater than 0 for the loop to execute at least once.
    #- `cando` will be `False` if the loop did not find any valid character, otherwise it will be `True` when `works` is set.
    #- `t[works]` will be the last character that was checked before the loop either completed or broke.
    #- `scountcopy[ord(t[works]) - ord('a')]` will be 0 if the loop completed, otherwise it will be -1 if the loop broke due to insufficient characters.
    #
    #**Output State:**
    #```
    #len(s) > 0, cando is True if and only if the loop completed, t[works] is the last character checked, scountcopy[ord(t[works]) - ord('a')] is 0 if the loop completed, otherwise it is -1.
    #```
    if (works == -1) :
        return -1
        #The program returns -1
    #State of the program after the if block has been executed: `len(s) > 0`, `cando` is `True`, `t[works]` is the last character checked, `scountcopy[ord(t[works]) - ord('a')]` is `0`
    res = list()
    for i in range(works):
        res.append(t[i])
        
        scount[ord(t[i]) - ord('a')] -= 1
        
    #State of the program after the  for loop has been executed: `len(s) > 0`, `cando` is `True`, `t[works]` is the last character checked, `scount[ord(t[works]) - ord('a')]` is `-works`, `res` is a list containing the first `works` characters of `t`, `works` is the length of `s`
    for j in range(ord(t[works]) - ord('a') + 1, 26):
        if scount[j] > 0:
            res.append(chr(j + ord('a')))
            scount[j] -= 1
            break
        
    #State of the program after the  for loop has been executed: `cando` is True, `t[works]` is the last character checked, `res` contains all characters added during the loop executions, `scount[j]` for all `j` from `ord(t[works]) - ord('a') + 1` to 25 are either zero or decreased by one during the loop executions, `works` remains the same, and `j` is the last value assigned within the loop.
    for i in range(26):
        while scount[i] > 0:
            res.append(chr(i + ord('a')))
            scount[i] -= 1
        
    #State of the program after the  for loop has been executed: `cando` is True, `t[works]` is the last character checked, `res` contains the string formed by repeating each character `scount[i]` times where `i` is the index of the character, `scount[j]` for all `j` from `ord(t[works]) - ord('a') + 1` to 25 are zero, `works` remains the same, `j` is 26, `scount[0]` is 0, `scount[ord(t[works]) - ord('a') + 1]` is the total number of times `t[works]` was added to `res`.
    return ''.join(map(str, res))
    #`The program returns the string 'res' which is formed by repeating each character 'scount[i]' times where 'i' is the index of the character, with the condition that 'scount[ord(t[works]) - ord('a') + 1]' is the total number of times 't[works]' was added to 'res'`
#Overall this is what the function does:Functionality: The function `func_1` takes two non-empty strings `s` and `t` as input and returns a string based on specific conditions. Here is a detailed breakdown of the function's behavior and its final state:

1. The function converts the input strings `s` and `t` into lists of characters.
2. It then counts the occurrences of each character in both strings `s` and `t` using the arrays `scount` and `tcount`, respectively.
3. It checks if the character count in `s` is less than or equal to the character count in `t` for every character from 'a' to 'z'. If this condition is met and the lengths of `s` and `t` are not equal, it returns `-1`.
4. If the above condition fails, it decrements the `scount` array by the values in `tcount`.
5. It appends characters from 'a' to 'z' to the list `t` based on the remaining counts in `scount`, resulting in the list `t` being filled with the required characters to match the character counts in `s`.
6. It then attempts to find the smallest index `works` in `s` where a character can still be replaced by another character from `t` without violating the character count constraints. If no such index is found, it returns `-1`.
7. If an index `works` is found, it constructs the resulting string `res` by taking the first `works` characters from `t` and appending characters from 'a' to 'z' as necessary to meet the character count requirements.
8. Finally, it returns the constructed string `res`.

The function handles several edge cases:
- If the lengths of `s` and `t` are not equal and the character counts do not satisfy the condition, it returns `-1`.
- If no valid replacement can be made, it also returns `-1`.
- In a special case, if the function constructs an empty string `t` and fills it with the character 'z', it returns the string `'z'`.

Thus, the final state of the program after executing `func_1` depends on the input strings `s` and `t` and the internal character count conditions, potentially returning `-1`, the string `'z'`, or a custom string `res` that meets the specified character count criteria.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
