
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Everything got unclear to us in a far away constellation Tau Ceti. Specifically, the Taucetians choose names to their children in a very peculiar manner.

Two young parents abac and bbad think what name to give to their first-born child. They decided that the name will be the permutation of letters of string s. To keep up with the neighbours, they decided to call the baby so that the name was lexicographically strictly larger than the neighbour's son's name t.

On the other hand, they suspect that a name tax will be introduced shortly. According to it, the Taucetians with lexicographically larger names will pay larger taxes. That's the reason abac and bbad want to call the newborn so that the name was lexicographically strictly larger than name t and lexicographically minimum at that.

The lexicographical order of strings is the order we are all used to, the "dictionary" order. Such comparison is used in all modern programming languages to compare strings. Formally, a string p of length n is lexicographically less than string q of length m, if one of the two statements is correct:

  * n < m, and p is the beginning (prefix) of string q (for example, "aba" is less than string "abaa"), 
  * p1 = q1, p2 = q2, ..., pk - 1 = qk - 1, pk < qk for some k (1 ≤ k ≤ min(n, m)), here characters in strings are numbered starting from 1. 



Write a program that, given string s and the heighbours' child's name t determines the string that is the result of permutation of letters in s. The string should be lexicographically strictly more than t and also, lexicographically minimum.

Input

The first line contains a non-empty string s (1 ≤ |s| ≤ 5000), where |s| is its length. The second line contains a non-empty string t (1 ≤ |t| ≤ 5000), where |t| is its length. Both strings consist of lowercase Latin letters.

Output

Print the sought name or -1 if it doesn't exist.

Examples

Input

aad
aac


Output

aad


Input

abad
bob


Output

daab


Input

abc
defg


Output

-1


Input

czaaab
abcdef


Output

abczaa

Note

In the first sample the given string s is the sought one, consequently, we do not need to change the letter order there.
Program:
```
print(func_1())

def func_1():
    s = list(raw_input())
    t = list(raw_input())
    scount = [0] * 26
    tcount = [0] * 26
    for char in s:
        scount[ord(char) - ord('a')] += 1
    for char in t:
        tcount[ord(char) - ord('a')] += 1
    allgreater = True
    for i in range(26):
        if scount[i] < tcount[i]:
            allgreater = False
    if allgreater:
        if len(s) == len(t):
            return -1
        for char in t:
            scount[ord(char) - ord('a')] -= 1
        for i in range(26):
            while scount[i] > 0:
                t.append(chr(i + ord('a')))
                scount[i] -= 1
        return ''.join(map(str, t))
    works = -1
    scountcopy = list(scount)
    for i in range(len(s)):
        cando = False
        for j in range(ord(t[i]) - ord('a') + 1, 26):
            if scountcopy[j] > 0:
                cando = True
        if cando:
            works = i
        if scountcopy[ord(t[i]) - ord('a')] == 0:
            break
        scountcopy[ord(t[i]) - ord('a')] -= 1
    if works == -1:
        return -1
    res = list()
    for i in range(works):
        res.append(t[i])
        scount[ord(t[i]) - ord('a')] -= 1
    for j in range(ord(t[works]) - ord('a') + 1, 26):
        if scount[j] > 0:
            res.append(chr(j + ord('a')))
            scount[j] -= 1
            break
    for i in range(26):
        while scount[i] > 0:
            res.append(chr(i + ord('a')))
            scount[i] -= 1
    return ''.join(map(str, res))


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not handle all potential cases correctly. Specifically, the program fails to generate the lexicographically minimum string that is strictly greater than `t` in some scenarios.

Consider the following example:
Input:
```
abc
cba
```

Expected Output:
```
acb
```

However, the program outputs:
```
abc
```

This happens because the program does not correctly find the smallest possible permutation of `s` that is lexicographically greater than `t`. The program attempts to find the smallest index `i` where `s[i]` is greater than `t[i]`, but it fails to handle cases where no such index exists, or where the required permutation involves rearranging characters to form the lexicographically smallest string greater than `t`.

To illustrate, the program does not consider the scenario where the smallest valid permutation starts after the point where `s` and `t` match character-wise. For instance, in the input "abc" and "cba", the program should swap 'a' and 'b' to get "acb", which is the smallest permutation of "abc" that is lexicographically greater than "cba".

Therefore, the program does not meet the requirements for every potential case and hence is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
print(func_1())

#State of the program right berfore the function call: s and t are non-empty strings consisting of lowercase Latin letters, with lengths satisfying 1 ≤ |s|, |t| ≤ 5000.
def func_1():
    s = list(raw_input())
    t = list(raw_input())
    scount = [0] * 26
    tcount = [0] * 26
    for char in s:
        scount[ord(char) - ord('a')] += 1
        
    #State of the program after the  for loop has been executed: `s` is a non-empty list of characters, `t` is a list of characters, `scount` is a list of 26 integers where each index corresponds to the count of a character ('a' to 'z') in `s`, and `tcount` is [0] * 26.
    for char in t:
        tcount[ord(char) - ord('a')] += 1
        
    #State of the program after the  for loop has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements, where the index corresponding to `char` is now the length of `t`.
    allgreater = True
    for i in range(26):
        if scount[i] < tcount[i]:
            allgreater = False
        
    #State of the program after the  for loop has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements where the index corresponding to `char` is now the length of `t`, `allgreater` is `False`.
    if allgreater :
        if (len(s) == len(t)) :
            return -1
            #The program returns -1
        #State of the program after the if block has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements where the index corresponding to `char` is now the length of `t`, `allgreater` is `True`, and the length of `s` is not equal to the length of `t`
        for char in t:
            scount[ord(char) - ord('a')] -= 1
            
        #State of the program after the  for loop has been executed: Output State:
        for i in range(26):
            while scount[i] > 0:
                t.append(chr(i + ord('a')))
                scount[i] -= 1
            
        #State of the program after the  for loop has been executed: `i` is 26, `scount[26]` is 0, `t` is a list containing all characters `chr(i + ord('a'))` for each positive `scount[i]` where the loop executed for `i` from 0 to 25.
        return ''.join(map(str, t))
        #The program returns the string 'z', since scount[26] is 0, the list t is empty, and ''.join([]) results in an empty string, but given the initial conditions and the mapping, it specifically maps to 'z' as the character for i = 26 - 26 (0) which is 'z'.
    #State of the program after the if block has been executed: `t` is a list of characters, `char` is the last character in `t`, `tcount` is a list of 26 elements where the index corresponding to `char` is now the length of `t`, `allgreater` is `True`
    works = -1
    scountcopy = list(scount)
    for i in range(len(s)):
        cando = False
        
        for j in range(ord(t[i]) - ord('a') + 1, 26):
            if scountcopy[j] > 0:
                cando = True
        
        if cando:
            works = i
        
        if scountcopy[ord(t[i]) - ord('a')] == 0:
            break
        
        scountcopy[ord(t[i]) - ord('a')] -= 1
        
    #State of the program after the  for loop has been executed: To determine the output state after all iterations of the loop have finished, let's analyze the loop code and the provided output states.
    #
    #### Analysis of the Loop Code:
    #The loop iterates over each character in the string `s`. For each character `t[i]`:
    #1. A flag `cando` is set to `False`.
    #2. A nested loop checks if there are enough characters of a certain type (from `t[i]` to 'z') in `scountcopy`.
    #3. If `cando` becomes `True`, `works` is updated to `i`.
    #4. If the count of `t[i]` in `scountcopy` is 0, the loop breaks.
    #5. The count of `t[i]` in `scountcopy` is decremented.
    #
    #### Observations from Provided Output States:
    #- After the loop executes 1 time, `cando` is `True`, `t[i]` is a lowercase letter, `scountcopy[ord(t[i]) - ord('a')]` is 0, and `works` is `i`.
    #- After the loop executes 2 times, `cando` is `False`, `t[i + 1]` is a lowercase letter, `scountcopy[ord(t[i + 1]) - ord('a')]` is 0, and `works` is `i + 1`.
    #- After the loop executes 3 times, `t[i + 2]` is a lowercase letter, `scountcopy[ord(t[i + 2]) - ord('a')]` is -1, `ord(t[i]) - ord('a') + 1` is less than or equal to 25, and `cando` is `True`.
    #
    #### Understanding the Loop Execution:
    #- The loop continues until it cannot find any character that can be used (i.e., `cando` remains `False`).
    #- The `works` variable keeps track of the index at which the loop was able to find a valid character.
    #- If the loop completes without breaking, `works` will be the last index that could have been updated.
    #
    #### Final State Analysis:
    #- If the loop completes (i.e., no `break` occurs), `works` will be the last index such that `cando` became `True` and `scountcopy[ord(t[works]) - ord('a')]` is 0.
    #- If the loop does not complete (i.e., it breaks due to `scountcopy[ord(t[i]) - ord('a')]` being 0), `works` will be the last index that was checked.
    #
    #### Output State:
    #- `len(s)` must be greater than 0 for the loop to execute at least once.
    #- `cando` will be `False` if the loop did not find any valid character, otherwise it will be `True` when `works` is set.
    #- `t[works]` will be the last character that was checked before the loop either completed or broke.
    #- `scountcopy[ord(t[works]) - ord('a')]` will be 0 if the loop completed, otherwise it will be -1 if the loop broke due to insufficient characters.
    #
    #**Output State:**
    #```
    #len(s) > 0, cando is True if and only if the loop completed, t[works] is the last character checked, scountcopy[ord(t[works]) - ord('a')] is 0 if the loop completed, otherwise it is -1.
    #```
    if (works == -1) :
        return -1
        #The program returns -1
    #State of the program after the if block has been executed: `len(s) > 0`, `cando` is `True`, `t[works]` is the last character checked, `scountcopy[ord(t[works]) - ord('a')]` is `0`
    res = list()
    for i in range(works):
        res.append(t[i])
        
        scount[ord(t[i]) - ord('a')] -= 1
        
    #State of the program after the  for loop has been executed: `len(s) > 0`, `cando` is `True`, `t[works]` is the last character checked, `scount[ord(t[works]) - ord('a')]` is `-works`, `res` is a list containing the first `works` characters of `t`, `works` is the length of `s`
    for j in range(ord(t[works]) - ord('a') + 1, 26):
        if scount[j] > 0:
            res.append(chr(j + ord('a')))
            scount[j] -= 1
            break
        
    #State of the program after the  for loop has been executed: `cando` is True, `t[works]` is the last character checked, `res` contains all characters added during the loop executions, `scount[j]` for all `j` from `ord(t[works]) - ord('a') + 1` to 25 are either zero or decreased by one during the loop executions, `works` remains the same, and `j` is the last value assigned within the loop.
    for i in range(26):
        while scount[i] > 0:
            res.append(chr(i + ord('a')))
            scount[i] -= 1
        
    #State of the program after the  for loop has been executed: `cando` is True, `t[works]` is the last character checked, `res` contains the string formed by repeating each character `scount[i]` times where `i` is the index of the character, `scount[j]` for all `j` from `ord(t[works]) - ord('a') + 1` to 25 are zero, `works` remains the same, `j` is 26, `scount[0]` is 0, `scount[ord(t[works]) - ord('a') + 1]` is the total number of times `t[works]` was added to `res`.
    return ''.join(map(str, res))
    #`The program returns the string 'res' which is formed by repeating each character 'scount[i]' times where 'i' is the index of the character, with the condition that 'scount[ord(t[works]) - ord('a') + 1]' is the total number of times 't[works]' was added to 'res'`


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
