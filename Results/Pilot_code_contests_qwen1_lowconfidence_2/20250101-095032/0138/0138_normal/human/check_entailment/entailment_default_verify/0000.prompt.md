
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Everything got unclear to us in a far away constellation Tau Ceti. Specifically, the Taucetians choose names to their children in a very peculiar manner.

Two young parents abac and bbad think what name to give to their first-born child. They decided that the name will be the permutation of letters of string s. To keep up with the neighbours, they decided to call the baby so that the name was lexicographically strictly larger than the neighbour's son's name t.

On the other hand, they suspect that a name tax will be introduced shortly. According to it, the Taucetians with lexicographically larger names will pay larger taxes. That's the reason abac and bbad want to call the newborn so that the name was lexicographically strictly larger than name t and lexicographically minimum at that.

The lexicographical order of strings is the order we are all used to, the "dictionary" order. Such comparison is used in all modern programming languages to compare strings. Formally, a string p of length n is lexicographically less than string q of length m, if one of the two statements is correct:

  * n < m, and p is the beginning (prefix) of string q (for example, "aba" is less than string "abaa"), 
  * p1 = q1, p2 = q2, ..., pk - 1 = qk - 1, pk < qk for some k (1 ≤ k ≤ min(n, m)), here characters in strings are numbered starting from 1. 



Write a program that, given string s and the heighbours' child's name t determines the string that is the result of permutation of letters in s. The string should be lexicographically strictly more than t and also, lexicographically minimum.

Input

The first line contains a non-empty string s (1 ≤ |s| ≤ 5000), where |s| is its length. The second line contains a non-empty string t (1 ≤ |t| ≤ 5000), where |t| is its length. Both strings consist of lowercase Latin letters.

Output

Print the sought name or -1 if it doesn't exist.

Examples

Input

aad
aac


Output

aad


Input

abad
bob


Output

daab


Input

abc
defg


Output

-1


Input

czaaab
abcdef


Output

abczaa

Note

In the first sample the given string s is the sought one, consequently, we do not need to change the letter order there.
Program:
```
print(func_1())

def func_1():
    s = list(raw_input())
    t = list(raw_input())
    scount = [0] * 26
    tcount = [0] * 26
    for char in s:
        scount[ord(char) - ord('a')] += 1
    for char in t:
        tcount[ord(char) - ord('a')] += 1
    allgreater = True
    for i in range(26):
        if scount[i] < tcount[i]:
            allgreater = False
    if allgreater:
        if len(s) == len(t):
            return -1
        for char in t:
            scount[ord(char) - ord('a')] -= 1
        for i in range(26):
            while scount[i] > 0:
                t.append(chr(i + ord('a')))
                scount[i] -= 1
        return ''.join(map(str, t))
    works = -1
    scountcopy = list(scount)
    for i in range(len(s)):
        cando = False
        for j in range(ord(t[i]) - ord('a') + 1, 26):
            if scountcopy[j] > 0:
                cando = True
        if cando:
            works = i
        if scountcopy[ord(t[i]) - ord('a')] == 0:
            break
        scountcopy[ord(t[i]) - ord('a')] -= 1
    if works == -1:
        return -1
    res = list()
    for i in range(works):
        res.append(t[i])
        scount[ord(t[i]) - ord('a')] -= 1
    for j in range(ord(t[works]) - ord('a') + 1, 26):
        if scount[j] > 0:
            res.append(chr(j + ord('a')))
            scount[j] -= 1
            break
    for i in range(26):
        while scount[i] > 0:
            res.append(chr(i + ord('a')))
            scount[i] -= 1
    return ''.join(map(str, res))


```
Original Assessment: Correctness: **False**

Explanation: The program does not handle the case where the string `s` cannot be permuted to be lexicographically strictly greater than `t`. Specifically, the program does not check if it's possible to make a permutation of `s` that is lexicographically greater than `t`. Here's an example to illustrate this:

Given:
```
s = "abc"
t = "cba"
```

Expected output: `-1` because no permutation of `s` can be lexicographically greater than `t`.

However, the current implementation does not check for this condition. It assumes that if it can place a character greater than the corresponding character in `t`, then the permutation is valid. This assumption is flawed because it doesn't guarantee that the resulting permutation will be the smallest one that is still lexicographically greater than `t`.

To fix this, the program needs to ensure that after finding the first position where it can place a character greater than the corresponding character in `t`, it checks if the remaining characters in `s` can still form a lexicographically minimum string that is greater than `t`.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Functionality: The function `func_1` takes two non-empty strings `s` and `t` as input and returns a string based on specific conditions. Here is a detailed breakdown of the function's behavior and its final state:

1. The function converts the input strings `s` and `t` into lists of characters.
2. It then counts the occurrences of each character in both strings `s` and `t` using the arrays `scount` and `tcount`, respectively.
3. It checks if the character count in `s` is less than or equal to the character count in `t` for every character from 'a' to 'z'. If this condition is met and the lengths of `s` and `t` are not equal, it returns `-1`.
4. If the above condition fails, it decrements the `scount` array by the values in `tcount`.
5. It appends characters from 'a' to 'z' to the list `t` based on the remaining counts in `scount`, resulting in the list `t` being filled with the required characters to match the character counts in `s`.
6. It then attempts to find the smallest index `works` in `s` where a character can still be replaced by another character from `t` without violating the character count constraints. If no such index is found, it returns `-1`.
7. If an index `works` is found, it constructs the resulting string `res` by taking the first `works` characters from `t` and appending characters from 'a' to 'z' as necessary to meet the character count requirements.
8. Finally, it returns the constructed string `res`.

The function handles several edge cases:
- If the lengths of `s` and `t` are not equal and the character counts do not satisfy the condition, it returns `-1`.
- If no valid replacement can be made, it also returns `-1`.
- In a special case, if the function constructs an empty string `t` and fills it with the character 'z', it returns the string `'z'`.

Thus, the final state of the program after executing `func_1` depends on the input strings `s` and `t` and the internal character count conditions, potentially returning `-1`, the string `'z'`, or a custom string `res` that meets the specified character count criteria.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
