#State of the program right berfore the function call: n is an integer such that 0 ≤ n ≤ 100. The following n lines each contain two real numbers xi and yi, representing the x and y coordinates of the center of the i-th sticker. Each coordinate value is given with up to 6 digits after the decimal point.
def func():
    """Reference
    http://homepage1.nifty.com/gfk/circle-circle.htm
    """
    RADIUS, RADIUS_2 = 1 + 1e-12, 2 + 1e-12
    num_data = int(stdin.readline())
    data = []
    for _ in range(num_data):
        data.append(tuple(float(s) for s in stdin.readline().split(',')))
        
    #State of the program after the  for loop has been executed: `num_data` is an integer such that 0 ≤ `num_data` ≤ 100, `RADIUS` is 1 + 1e-12, `RADIUS_2` is 2 + 1e-12, `data` is a list containing exactly `num_data` tuples of float values
    cross_points = []
    for i in range(num_data):
        x1, y1 = data[i]
        
        for j in range(num_data):
            if i == j:
                continue
            x2, y2 = data[j]
            distance = math.hypot(x2 - x1, y2 - y1)
            if distance <= RADIUS_2:
                if x1 == x2 and y1 == y2:
                    cp1 = cp2 = x1, y1
                else:
                    th = math.atan2(y2 - y1, x2 - x1)
                    al = math.acos(distance ** 2 / (2.0 * distance))
                    cp1 = x1 + math.cos(th + al), y1 + math.sin(th + al)
                    cp2 = x1 + math.cos(th - al), y1 + math.sin(th - al)
                if 0.0 <= cp1[0] <= 10.0 and 0.0 <= cp1[1] <= 10.0:
                    cross_points.append(cp1)
                if 0.0 <= cp2[0] <= 10.0 and 0.0 <= cp2[1] <= 10.0:
                    cross_points.append(cp2)
        
    #State of the program after the  for loop has been executed: `num_data` is an integer such that 0 ≤ `num_data` ≤ 100, `RADIUS` is 1 + 1e-12, `RADIUS_2` is 2 + 1e-12, `data` is a list containing exactly `num_data` tuples of float values, `cross_points` is a list of all valid intersection points `(cp1, cp2)` generated by the loop that satisfy the conditions within the loop, where `cp1` and `cp2` are within the range [0.0, 10.0].
    max_overlap = 0
    for (cx, cy) in cross_points:
        count = 0
        
        for x, y in data:
            if math.hypot(cx - x, cy - y) <= RADIUS:
                count += 1
        
        if max_overlap < count:
            max_overlap = count
        
    #State of the program after the  for loop has been executed: `num_data` is an integer such that \(0 \leq \text{num_data} \leq 100\), `RADIUS` is \(1 + 1e-12\), `RADIUS_2` is \(2 + 1e-12\), `data` is a list containing exactly `num_data` tuples of float values, `cross_points` is a list containing tuples of valid intersection points \((cp1, cp2)\) where both `cp1` and `cp2` are within the range \([0.0, 10.0]\), and `max_overlap` is the maximum number of points in `data` that are within the radius `RADIUS` from any point in `cross_points`.
    print(max_overlap)
#Overall this is what the function does:The function processes an integer `n` where \(0 \leq n \leq 100\) and for each of the `n` lines, it reads two real numbers \(x_i\) and \(y_i\) representing the x and y coordinates of the i-th sticker. It then calculates all possible intersection points between pairs of stickers (if the distance between their centers is less than or equal to the square root of 2). For each intersection point, it counts how many stickers have their centers within a radius of \(1 + 10^{-12}\) from that point. Finally, it prints the maximum count of stickers that overlap at any single intersection point.

