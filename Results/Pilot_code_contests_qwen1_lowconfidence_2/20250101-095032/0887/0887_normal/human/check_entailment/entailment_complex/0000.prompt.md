
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.

The players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.

After a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.

You are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?

Input

The first line contains a single integer n (1 ≤ n ≤ 105) — the number of black points.

The (i + 1)-th line contains two integers xi, yi ( - 105 ≤ xi, yi, ≤ 105) — the coordinates of the point where the i-th black token is initially located.

It is guaranteed that initial positions of black tokens are distinct.

Output

Print the number of points where the white token can be located initially, such that if both players play optimally, the black player wins.

Examples

Input

4
-2 -1
0 1
0 -3
2 -1


Output

4


Input

4
-2 0
-1 1
0 -2
1 -1


Output

2


Input

16
2 1
1 2
-1 1
0 1
0 0
1 1
2 -1
2 0
1 0
-1 -1
1 -1
2 2
0 -1
-1 0
0 2
-1 2


Output

4

Note

In the first and second examples initial positions of black tokens are shown with black points, possible positions of the white token (such that the black player wins) are shown with white points.

The first example: <image>

The second example: <image>

In the third example the white tokens should be located in the inner square 2 × 2, to make the black player win. <image>
Annotated Functions:
from sys import*
from itertools import*

func_2()

#Function 1:
#State of the program right berfore the function call: a is a list of tuples, where each tuple contains two integers (x, y) representing the coordinates of a black token. All coordinates (x, y) satisfy -100000 <= x, y <= 100000, and the list does not contain duplicate coordinates.
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        
        if lmn[x] > y:
            lmn[x] = y
        
        if lmx[x] < y:
            lmx[x] = y
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, where each tuple contains two integers (x, y) representing the coordinates of a black token; `lmn` is a list of 400010 elements, each initialized to 1001001001; `lmx` is a list of 400010 elements, each initialized to -1001001001; for every tuple (x, y) in `a`, `lmn[x]` is the maximum value of `y` for all tuples (x, y) in `a` such that `lmn[x] > y`; for every tuple (x, y) in `a`, `lmx[x]` is the minimum value of `y` for all tuples (x, y) in `a` such that `lmx[x] < y`.
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `lmn` is a list of 400010 elements each initialized to 1001001001, `lmx` is a list of 400010 elements each initialized to -1001001001, `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`, `i` is 200008, and for all `i` from 200009 to 400009, `lmn[i]` and `lmx[i]` do not change from their initial values since `lmn[i + 1]` will always be greater than or equal to `lmn[i]` due to the nature of the loop.
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
        
    #State of the program after the  for loop has been executed: `i` is 400009, `lmn` is a list of 400010 elements each initialized to 1001001001, `lmx` is a list of 400010 elements where `lmx[200009]` to `lmx[400008]` are -1001001001 and `lmx[400009]` is either -1001001001 or a different value (depending on the if condition), `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`. If `lmx[i + 1] < lmx[i]` is never true for any `i` from 200009 to 400008, then `lmx[i]` remains -1001001001 for all `i` from 200009 to 400008. If `lmx[i + 1] < lmx[i]` is true for any `i` from 200009 to 400008, then `lmx[i + 1]` becomes `lmx[i]` and the value of `lmx[i + 1]` changes accordingly.
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
        
    #State of the program after the  for loop has been executed: `i` is 1, `lmn` is a list of 400010 elements each initialized to 1001001001, `lmx` is a list of 400010 elements where `lmx[200009]` to `lmx[400008]` are -1001001001 and `lmx[400009]` is either -1001001001 or a different value, `rmn` is a shallow copy of `lmn`, `rmx` is a shallow copy of `lmx`.
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
        
    #State of the program after the  for loop has been executed: 
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
        
    #State of the program after the  for loop has been executed: `i` is 200010, `n` is 200010. For every index `i` where `0 <= i < 200010`, `lmn[i]` is updated to `rmn[i]` if `lmn[i] < rmn[i]`. If no such index exists, the values of `lmn[i]` and `rmn[i]` remain unchanged from their original values.
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
        
    #State of the program after the  for loop has been executed: `lmx` is a list of integers, `rmx` is a list of integers, and for all indices `i` where `0 <= i < 200010`, if `lmx[i]` was initially greater than `rmx[i]`, then `lmx[i]` will be set to `rmx[i]`. Otherwise, `lmx[i]` remains unchanged.
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
        
    #State of the program after the  for loop has been executed: `lmn` is a list where each element is the maximum value among itself and its next neighbor, `lmx` and `rmx` are lists of integers initialized as per the problem statement, and `ans` is 0.
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
        
    #State of the program after the  for loop has been executed: `i` is 200008, `lmn` is a list where each element is the maximum value among itself and its next neighbor, `lmx` is a list where each element `lmx[i]` is not greater than `lmx[i + 1]` for all valid indices, `rmx` is a list of integers, and `ans` remains 0.
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
        
    #State of the program after the  for loop has been executed: `i` is 200009, `ans` is the sum of `(lmx[i] - lmn[i]) / 2` for all valid indices `i` where `lmn[i] < lmx[i]`. `lmn` and `lmx` remain as defined initially, and `rmx` is a list of integers.
    return ans
    #The program returns ans which is the sum of (lmx[i] - lmn[i]) / 2 for all valid indices i where lmn[i] < lmx[i]
#Overall this is what the function does:The function `func_1` accepts a list of tuples `a`, where each tuple represents the coordinates (x, y) of a black token. It initializes two lists, `lmn` and `lmx`, both of size 400010, with specific initial values. It then updates these lists based on the coordinates in `a`. Specifically, for each coordinate (x, y) in `a`, `lmn[x]` is updated to be the minimum value of `y` among all coordinates (x, y) in `a` such that `lmn[x] > y`, and `lmx[x]` is updated to be the maximum value of `y` among all coordinates (x, y) in `a` such that `lmx[x] < y`.

After these initial updates, the function further processes the lists `lmn` and `lmx` through several loops:
1. It ensures that `lmn` is non-decreasing up to index 200009 and non-increasing from index 200009 to 400009.
2. It ensures that `lmx` is non-increasing up to index 200009 and non-decreasing from index 200009 to 400009.
3. It then updates `lmn` and `lmx` using a reference copy `rmn` and `rmx` to ensure that `lmn[i]` is the maximum value between itself and the corresponding value in `rmn[i]`, and similarly for `lmx`.

Finally, the function calculates and returns `ans`, which is the sum of `(lmx[i] - lmn[i]) / 2` for all valid indices `i` where `lmn[i] < lmx[i]`. This sum represents the total "distance" between the maximum and minimum values of `y` for each `x` coordinate, considering the constraints and updates performed on `lmn` and `lmx`.

Potential edge cases include scenarios where the input list `a` might be empty or contain only one element, in which case the initial conditions of `lmn` and `lmx` would directly apply without any updates. Additionally, if no valid indices `i` exist where `lmn[i] < lmx[i]`, the function will return 0.

#Function 2:
#State of the program right berfore the function call: n is an integer representing the number of black points, and dat is an iterator containing 2 * n integers representing the x and y coordinates of the black points. The coordinates are read from standard input using `stdin.readline()` and `stdin.read().split()`. The function `func_1` is assumed to process the data in the `s` list and return an integer value.
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        x, y = dat[i * 2:i * 2 + 2]
        
        s[x + y & 1].append((-x + y, x + y))
        
    #State of the program after the  for loop has been executed: `n` is an integer read from standard input, `dat` is an iterator containing \(2 \times n\) integers, `s` is a list of two lists, where one sublist contains tuples \((-x + y, x + y)\) for even sums and the other sublist contains tuples for odd sums.
    print(func_1(s[0]) + func_1(s[1]))
#Overall this is what the function does:The function reads an integer `n` from standard input, followed by `2 * n` integers representing the coordinates of `n` black points. It then processes these coordinates into two lists based on the parity of their sum, where each tuple in the list contains `(-x + y, x + y)`. After processing, it calls `func_1` on both lists and prints the sum of the results. Potential edge cases include invalid input (e.g., non-integer values for `n` or coordinates) which would result in undefined behavior due to the nature of the `int` conversion and list slicing operations. There is also no validation for the coordinates being valid (e.g., non-negative values).




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.