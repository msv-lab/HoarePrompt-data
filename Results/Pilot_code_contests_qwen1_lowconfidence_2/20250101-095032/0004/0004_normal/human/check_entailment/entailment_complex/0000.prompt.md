
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: An array of integers p_{1},p_{2}, …,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].

There is a hidden permutation of length n.

For each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.

Your task is to restore the permutation.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the size of the permutation.

The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/(2)).

It is guaranteed that the array s corresponds to a valid permutation of length n.

Output

Print n integers p_{1}, p_{2}, …, p_{n} — the elements of the restored permutation. We can show that the answer is always unique.

Examples

Input


3
0 0 0


Output


3 2 1


Input


2
0 1


Output


1 2


Input


5
0 1 1 1 10


Output


1 4 3 2 5

Note

In the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.

In the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.

In the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.
Annotated Functions:
from sys import stdin, stdout
from collections import Counter, defaultdict
from itertools import permutations, combinations

raw_input = stdin.readline
pr = stdout.write
mod = 10 ** 9 + 7
range = xrange
n = func_1()
BITTree = [0] * (n + 1)
l = func_2()
for i in range(n):
    func_7(i, i)
ans = [0] * n
for i in range(n - 1, -1, -1):
    ans[i] = func_8(l[i])
    func_7(ans[i], -ans[i])
func_4(ans)

#Function 1:
#State of the program right berfore the function call: None of the variables in the function signature are provided, but the function reads an integer input from the user, which represents the size of the permutation (n), and this integer is expected to be within the range 1 ≤ n ≤ 2 ⋅ 10^{5}.
def func_1():
    return int(raw_input())
    #The program returns an integer input from the user, which represents the size of the permutation (n) and is within the range 1 ≤ n ≤ 2 ⋅ 10^{5}
#Overall this is what the function does:The function `func_1` reads an integer input from the user, which represents the size of the permutation (n). This integer must be within the range 1 ≤ n ≤ 2 ⋅ 10^5. The function does not accept any parameters and returns the integer input provided by the user. There are no edge cases mentioned in the annotation, and the code does not contain any additional functionality beyond reading the user input. The final state of the program after the function concludes is that it returns the integer input from the user, ensuring it falls within the specified range.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function `func_2` are defined in its signature. The function reads input from the standard input stream, which is expected to be a space-separated sequence of integers corresponding to the values of `n` and the list `s`. The function returns a tuple of integers.
def func_2():
    return map(int, raw_input().split())
    #The program returns a tuple of integers obtained from the space-separated sequence of integers read from the standard input stream
#Overall this is what the function does:The function `func_2` reads a space-separated sequence of integers from the standard input stream, converts them into a tuple of integers, and returns this tuple. The function accepts no parameters and returns a tuple of integers. Potential edge cases include the input being empty or containing non-integer values, in which case the program will raise a `ValueError`. The function also assumes that the input format is strictly adhered to, meaning exactly two space-separated integers are expected (one for `n` and the rest for the list `s`). If the input format deviates from this expectation, the function may produce unexpected results or raise exceptions.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^{5}.
def func_3(n):
    stdout.write(str(n) + '\n')
#Overall this is what the function does:The function `func_3` accepts an integer `n` within the range \(1 \leq n \leq 2 \cdot 10^5\). It writes the string representation of `n` followed by a newline character to the standard output (stdout). After executing the function, the standard output will contain the string representation of `n` on a new line. There are no return values from this function; it only modifies the standard output.

#Function 4:
#State of the program right berfore the function call: arr is a list of n integers representing the values of s_1, s_2, ..., s_n, where n is the size of the permutation and 1 ≤ n ≤ 2 ⋅ 10^5. Each element in the list satisfies 0 ≤ s_i ≤ (n(n-1))/2, and the list corresponds to a valid permutation of length n.
def func_4(arr):
    pr(' '.join(map(str, arr)) + '\n')
#Overall this is what the function does:The function `func_4` takes a list `arr` as input and checks if it meets the conditions for a valid permutation. If `arr` is a valid permutation, it returns the list `arr`. Otherwise, it prints an error message indicating that the input does not meet the conditions for a valid permutation. The function does not return anything explicitly, but the error message is printed.

#Function 5:
#State of the program right berfore the function call: stdin is a file-like object containing space-separated integers for n and s_1, s_2, ..., s_n, where 1 ≤ n ≤ 2 ⋅ 10^5 and 0 ≤ s_i ≤ (n(n-1))/2 for all i.
def func_5():
    return map(int, stdin.read().split())
    #The program returns a map object that converts the space-separated integers read from stdin into integers
#Overall this is what the function does:The function `func_5()` reads a sequence of space-separated integers from the standard input (`stdin`). It then converts these integers into a map object. The map object contains the integer values corresponding to the input integers. This function assumes that the first integer read from `stdin` represents the count `n` of subsequent integers, and these `n` integers follow. The function does not validate the input values or handle any potential errors during the reading process.

#Function 6:
#State of the program right berfore the function call: i is an integer such that 1 <= i <= n, and BITTree is a Binary Indexed Tree (Fenwick Tree) representing the cumulative sums of some array up to index n.
def func_6(i):
    s = 0
    i = i + 1
    while i > 0:
        s += BITTree[i]
        
        i -= i & -i
        
    #State of the program after the loop has been executed: `s` is the sum of all elements in the Binary Indexed Tree (BITTree) up to the initial value of `i`, `i` is 0, `BITTree` is a Binary Indexed Tree representing the cumulative sums of some array up to index `n`.
    return s
    #The program returns `s`, which is the sum of all elements in the Binary Indexed Tree (BITTree) up to the initial value of `i`, where `i` is 0
#Overall this is what the function does:The function `func_6` accepts an integer `i` such that 1 ≤ `i` ≤ `n`, where `n` is the size of the Binary Indexed Tree (BITTree). It calculates the sum of all elements in the BITTree up to the index corresponding to the initial value of `i`. This is achieved through a bitwise operation to traverse the tree efficiently. The function then returns this sum. If `i` is 1 initially, the function effectively returns the sum of all elements in the BITTree. The state of the program after the function concludes is that it returns `s`, which is the sum of all elements in the BITTree up to the initial value of `i`.

#Function 7:
#State of the program right berfore the function call: i is an integer such that 0 <= i <= n, and v is an integer representing the value to be added to the Binary Indexed Tree (BITTree) at index i.
def func_7(i, v):
    i += 1
    while i <= n:
        BITTree[i] += v
        
        i += i & -i
        
    #State of the program after the loop has been executed: `i` is the next highest position in the binary representation of the original `i` where `0 < i <= n`; `BITTree[i]` is updated to its original value plus `v`; `n` remains unchanged; `v` is the integer value that was added to the BITTree initially.
#Overall this is what the function does:The function `func_7` accepts two parameters, `i` and `v`, where `i` is an integer such that \(0 \leq i \leq n\) and `v` is an integer. It updates the Binary Indexed Tree (BITTree) by adding `v` to the element at index `i` and all subsequent indices `j` where `j` is a multiple of the least significant bit of `i`. After executing the function, the BITTree will have the value `v` added to the elements at indices `i`, `i + lsb(i)`, `i + 2*lsb(i)`, and so on, up to the largest multiple of `lsb(i)` that does not exceed `n`. If `i` is greater than `n`, no changes are made to the BITTree.

#Function 8:
#State of the program right berfore the function call: x is an integer such that 0 <= x <= (n * (n - 1)) // 2, n is an integer greater than 0, and BITTree is a Binary Indexed Tree (BIT) initialized with zeros and has at least n elements.
def func_8(x):
    ret = 0
    sm = 0
    for i in range(21, -1, -1):
        pw = 1 << i
        
        if ret + pw <= n and sm + BITTree[ret + pw] <= x:
            ret += pw
            sm += BITTree[ret]
        
    #State of the program after the  for loop has been executed: `sm` is the sum of all `BITTree[ret + pw]` values where `pw` is \(2^i\) and `ret + pw <= n` and `sm + BITTree[ret + pw] <= x\), `ret` is the cumulative sum of all `pw` added during the loop iterations, `x` remains unchanged, `i` is -1 (indicating the loop has completed all iterations), and `pw` is \(2^{-1}\) (indicating the loop has finished). If the loop does not execute at all, then `sm` and `ret` remain 0.
    return ret
    #The program returns 0
#Overall this is what the function does:The function `func_8` accepts an integer `x` and returns an integer. The function iterates over a range of powers of 2 from \(2^{21}\) down to \(2^{-1}\) (inclusive), checking if adding each power of 2 to the current value of `ret` and its corresponding BITTree value to `sm` keeps `sm` within the limit `x`. If both conditions are met, it updates `ret` and `sm`. After the loop completes, the function returns the final value of `ret`. If no updates were made to `ret` during the loop, the function returns 0.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.