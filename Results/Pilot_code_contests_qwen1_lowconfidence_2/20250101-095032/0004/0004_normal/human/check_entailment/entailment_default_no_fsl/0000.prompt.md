
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: An array of integers p_{1},p_{2}, …,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].

There is a hidden permutation of length n.

For each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.

Your task is to restore the permutation.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the size of the permutation.

The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/(2)).

It is guaranteed that the array s corresponds to a valid permutation of length n.

Output

Print n integers p_{1}, p_{2}, …, p_{n} — the elements of the restored permutation. We can show that the answer is always unique.

Examples

Input


3
0 0 0


Output


3 2 1


Input


2
0 1


Output


1 2


Input


5
0 1 1 1 10


Output


1 4 3 2 5

Note

In the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.

In the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.

In the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.
Functions with output description for each function:
from sys import stdin, stdout
from collections import Counter, defaultdict
from itertools import permutations, combinations

raw_input = stdin.readline
pr = stdout.write
mod = 10 ** 9 + 7
range = xrange
n = func_1()
BITTree = [0] * (n + 1)
l = func_2()
for i in range(n):
    func_7(i, i)
ans = [0] * n
for i in range(n - 1, -1, -1):
    ans[i] = func_8(l[i])
    func_7(ans[i], -ans[i])
func_4(ans)

Function number 1 :
 Code:
 '''
def func_1():
    return int(raw_input())
''' 

 Output hints for function1:  The function `func_1` reads an integer input from the user, which represents the size of the permutation (n). This integer must be within the range 1 ≤ n ≤ 2 ⋅ 10^5. The function does not accept any parameters and returns the integer input provided by the user. There are no edge cases mentioned in the annotation, and the code does not contain any additional functionality beyond reading the user input. The final state of the program after the function concludes is that it returns the integer input from the user, ensuring it falls within the specified range.
Function number 2 :
 Code:
 '''
def func_2():
    return map(int, raw_input().split())
''' 

 Output hints for function2:  The function `func_2` reads a space-separated sequence of integers from the standard input stream, converts them into a tuple of integers, and returns this tuple. The function accepts no parameters and returns a tuple of integers. Potential edge cases include the input being empty or containing non-integer values, in which case the program will raise a `ValueError`. The function also assumes that the input format is strictly adhered to, meaning exactly two space-separated integers are expected (one for `n` and the rest for the list `s`). If the input format deviates from this expectation, the function may produce unexpected results or raise exceptions.
Function number 3 :
 Code:
 '''
def func_3(n):
    stdout.write(str(n) + '\n')
''' 

 Output hints for function3:  The function `func_3` accepts an integer `n` within the range \(1 \leq n \leq 2 \cdot 10^5\). It writes the string representation of `n` followed by a newline character to the standard output (stdout). After executing the function, the standard output will contain the string representation of `n` on a new line. There are no return values from this function; it only modifies the standard output.
Function number 4 :
 Code:
 '''
def func_4(arr):
    pr(' '.join(map(str, arr)) + '\n')
''' 

 Output hints for function4:  The function `func_4` takes a list `arr` as input and checks if it meets the conditions for a valid permutation. If `arr` is a valid permutation, it returns the list `arr`. Otherwise, it prints an error message indicating that the input does not meet the conditions for a valid permutation. The function does not return anything explicitly, but the error message is printed.
Function number 5 :
 Code:
 '''
def func_5():
    return map(int, stdin.read().split())
''' 

 Output hints for function5:  The function `func_5()` reads a sequence of space-separated integers from the standard input (`stdin`). It then converts these integers into a map object. The map object contains the integer values corresponding to the input integers. This function assumes that the first integer read from `stdin` represents the count `n` of subsequent integers, and these `n` integers follow. The function does not validate the input values or handle any potential errors during the reading process.
Function number 6 :
 Code:
 '''
def func_6(i):
    s = 0
    i = i + 1
    while i > 0:
        s += BITTree[i]
        i -= i & -i
    return s
''' 

 Output hints for function6:  The function `func_6` accepts an integer `i` such that 1 ≤ `i` ≤ `n`, where `n` is the size of the Binary Indexed Tree (BITTree). It calculates the sum of all elements in the BITTree up to the index corresponding to the initial value of `i`. This is achieved through a bitwise operation to traverse the tree efficiently. The function then returns this sum. If `i` is 1 initially, the function effectively returns the sum of all elements in the BITTree. The state of the program after the function concludes is that it returns `s`, which is the sum of all elements in the BITTree up to the initial value of `i`.
Function number 7 :
 Code:
 '''
def func_7(i, v):
    i += 1
    while i <= n:
        BITTree[i] += v
        i += i & -i
''' 

 Output hints for function7:  The function `func_7` accepts two parameters, `i` and `v`, where `i` is an integer such that \(0 \leq i \leq n\) and `v` is an integer. It updates the Binary Indexed Tree (BITTree) by adding `v` to the element at index `i` and all subsequent indices `j` where `j` is a multiple of the least significant bit of `i`. After executing the function, the BITTree will have the value `v` added to the elements at indices `i`, `i + lsb(i)`, `i + 2*lsb(i)`, and so on, up to the largest multiple of `lsb(i)` that does not exceed `n`. If `i` is greater than `n`, no changes are made to the BITTree.
Function number 8 :
 Code:
 '''
def func_8(x):
    ret = 0
    sm = 0
    for i in range(21, -1, -1):
        pw = 1 << i
        if ret + pw <= n and sm + BITTree[ret + pw] <= x:
            ret += pw
            sm += BITTree[ret]
    return ret
''' 

 Output hints for function8:  The function `func_8` accepts an integer `x` and returns an integer. The function iterates over a range of powers of 2 from \(2^{21}\) down to \(2^{-1}\) (inclusive), checking if adding each power of 2 to the current value of `ret` and its corresponding BITTree value to `sm` keeps `sm` within the limit `x`. If both conditions are met, it updates `ret` and `sm`. After the loop completes, the function returns the final value of `ret`. If no updates were made to `ret` during the loop, the function returns 0.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.