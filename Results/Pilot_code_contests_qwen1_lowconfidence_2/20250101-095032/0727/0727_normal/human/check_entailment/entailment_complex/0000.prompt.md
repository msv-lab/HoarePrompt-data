
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Polycarp likes to play with numbers. He takes some integer number x, writes it down on the board, and then performs with it n - 1 operations of the two kinds: 

  * divide the number x by 3 (x must be divisible by 3); 
  * multiply the number x by 2. 



After each operation, Polycarp writes down the result on the board and replaces x by the result. So there will be n numbers on the board after all.

You are given a sequence of length n — the numbers that Polycarp wrote down. This sequence is given in arbitrary order, i.e. the order of the sequence can mismatch the order of the numbers written on the board.

Your problem is to rearrange (reorder) elements of this sequence in such a way that it can match possible Polycarp's game in the order of the numbers written on the board. I.e. each next number will be exactly two times of the previous number or exactly one third of previous number.

It is guaranteed that the answer exists.

Input

The first line of the input contatins an integer number n (2 ≤ n ≤ 100) — the number of the elements in the sequence. The second line of the input contains n integer numbers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 3 ⋅ 10^{18}) — rearranged (reordered) sequence that Polycarp can wrote down on the board.

Output

Print n integer numbers — rearranged (reordered) input sequence that can be the sequence that Polycarp could write down on the board.

It is guaranteed that the answer exists.

Examples

Input

6
4 8 6 3 12 9


Output

9 3 6 12 4 8 


Input

4
42 28 84 126


Output

126 42 84 28 


Input

2
1000000000000000000 3000000000000000000


Output

3000000000000000000 1000000000000000000 

Note

In the first example the given sequence can be rearranged in the following way: [9, 3, 6, 12, 4, 8]. It can match possible Polycarp's game which started with x = 9.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import sys, math, random, operator
from string import ascii_lowercase, ascii_uppercase
from fractions import Fraction, gcd
from itertools import product, permutations, combinations
from Queue import Queue, PriorityQueue
from collections import deque, defaultdict, Counter

#State of the program right berfore the function call: The input is a list of n integer numbers (2 ≤ n ≤ 100) where each number is in the range 1 to 3 ⋅ 10^{18}, and these numbers can be rearranged such that each number is either exactly two times the previous number or exactly one third of the previous number.
def func():
    MOD = 10 ** 9 + 7
    INF = float('+inf')
    if (sys.subversion[0] == 'PyPy') :
        sys.stdout = io.BytesIO()
        atexit.register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
        sys.stdin = io.BytesIO(sys.stdin.read())
        raw_input = lambda : sys.stdin.readline().rstrip()
    #State of the program after the if block has been executed: *The input is a list of n integer numbers (2 ≤ n ≤ 100) where each number is in the range 1 to 3 ⋅ 10^{18}, and these numbers can be rearranged such that each number is either exactly two times the previous number or exactly one third of the previous number; `MOD` is 10; `INF` is set to positive infinity. Additionally, if `sys.subversion[0]` equals 'PyPy', then `sys.stdin` is an in-memory bytes buffer containing the original input data, `sys.stdout` is set to an in-memory bytes buffer, and `raw_input` is a lambda function that reads a line from `sys.stdin` and strips the trailing newline character. Otherwise, the state of `sys.stdin`, `sys.stdout`, and `raw_input` remains unchanged.
    pr = lambda *args: sys.stdout.write(' '.join(str(x) for x in args) + '\n')
    epr = lambda *args: sys.stderr.write(' '.join(str(x) for x in args) + '\n')
    die = lambda *args: pr(*args) ^ exit(0)
    read_str = raw_input
    read_strs = lambda : raw_input().split()
    read_int = lambda : int(raw_input())
    read_ints = lambda : map(int, raw_input().split())
    read_float = lambda : float(raw_input())
    read_floats = lambda : map(float, raw_input().split())
    """---------------------------------------------------------------"""
    n = read_int()
    arr = read_ints()
    res = [arr.pop()]
    arr = set(arr)
    while arr:
        a = res[0]
        
        if a % 2 == 0 and a / 2 in arr:
            arr.remove(a / 2)
            res = [a / 2] + res
            continue
        elif a * 3 in arr:
            arr.remove(a * 3)
            res = [a * 3] + res
            continue
        
        a = res[-1]
        
        if a % 3 == 0 and a / 3 in arr:
            arr.remove(a / 3)
            res = res + [a / 3]
            continue
        elif a * 2 in arr:
            arr.remove(a * 2)
            res = res + [a * 2]
            continue
        
    #State of the program after the loop has been executed: `arr` is empty, `res` contains the sequence of operations applied to the initial elements of `arr` until no further operations can be performed, `a` is the last element of `res`, `sys.stdout` is an in-memory bytes buffer, `MOD` is 10, `INF` is positive infinity, `read_strs` is a lambda function that takes input using `raw_input()` and splits it into a list of strings, `read_int` is a lambda function that reads an integer from input using `int(raw_input())`, `read_ints` is a lambda function that reads a list of integers from input using `map(int, raw_input().split())`, `read_float` is a lambda function that reads a float from input using `float(raw_input())`, `read_floats` is a lambda function that maps `float` to each element of the list split from the input using `raw_input().split()`
    pr(*res)
#Overall this is what the function does:The function `func` accepts a list of `n` integer numbers where `2 ≤ n ≤ 100` and each number is in the range 1 to \(3 \cdot 10^{18}\). It rearranges the numbers such that each number is either exactly two times the previous number or exactly one third of the previous number. The function constructs a sequence of operations that can transform the initial elements of the list into a valid sequence according to the specified rules. After executing the operations, the function prints the resulting sequence and returns nothing. If no valid sequence can be constructed, the function still prints the initial sequence provided.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
