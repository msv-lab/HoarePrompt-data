
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You have given tree consist of n vertices. Select a vertex as root vertex that satisfies the condition below.

  * For all vertices v_{1} and v_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then degree(v_{1}) = degree(v_{2}), where degree means the number of vertices connected to that vertex, and distance means the number of edges between two vertices. 



Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^{5}) — the number of vertices.

Each of the next n-1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i} < u_{i} ≤ n) — it means there is an edge exist between v_{i} and u_{i}. It is guaranteed that the graph forms tree.

Output

If there is such root vertex exists, print any of them. Otherwise, print -1.

Examples

Input


7
1 2
2 3
3 4
4 5
3 6
6 7


Output


3


Input


6
1 3
2 3
3 4
4 5
4 6


Output


-1

Note

This is the picture for the first example. 1, 5, 7 also can be a valid answer.

<image>

This is the picture for the second example. You can see that it's impossible to find such root vertex.

<image>
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from collections import*

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the following (n-1) lines each contain two integers v_i and u_i such that 1 ≤ v_i < u_i ≤ n, representing the edges of the tree.
def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u, v = map(int, raw_input().split())
        
        e[u].append(v)
        
        e[v].append(u)
        
    #State of the program after the  for loop has been executed: `i` is `n-1`, `n` is a positive integer, `e` is a list containing `n + 1` empty lists except for the lists at indices `u` and `v` which each contain the sequence of each other repeated `i+1` times (i.e., `[v, u, v, u, ..., v, u]`), where `u` and `v` are integers obtained from the inputs during the loop executions.
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `q` is empty, `cur` is the last element processed, `dep` contains the shortest path distances from the starting node (1) to all other nodes, and for every node `to` in the graph, `dep[to]` is the distance from the starting node to `to` if it is reachable, otherwise it remains `-1`.
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
        
    #State of the program after the loop has been executed: `q` is an empty deque, `end` is the last node processed, `dep` contains the shortest path distances from the starting node, and `pred` contains the predecessor for each node in the shortest path tree.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `q` is an empty deque, `end` is the last node processed, `dep` contains the shortest path distances from the starting node, `pred` contains the predecessor for each node in the shortest path tree, `deg` is a list of length `n + 1` where each element is either `-1` or updated to `len(e[i])` based on the condition `deg[dep[i]] != -1`, `bad` is `True` if any `deg[dep[i]] != len(e[i])` for `i` in `range(1, n + 1)`, and `n` must be greater than 0.
    if (not bad) :
        print(cur)
        exit()
    #State of the program after the if block has been executed: *`q` is an empty deque, `end` is the last node processed, `dep` contains the shortest path distances from the starting node, `pred` contains the predecessor for each node in the shortest path tree, `deg` is a list of length `n + 1` where each element is either `-1` or updated to `len(e[i])` based on the condition `deg[dep[i]] != -1`, `bad` is `False`, and `cur` is printed.
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
        
    #State of the program after the  for loop has been executed: `dep[end]` is at least `2 * (number_of_iterations + 1)` and less than `2 * (number_of_iterations + 2)`, `center` is the node reached after updating it `number_of_iterations` times using `pred`. If the loop does not execute, `dep[end]` is less than 2 and `center` remains `end`.
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `dep` is a list of length `n+1` where each element represents the shortest distance from the starting node to the corresponding node, `center` is the node reached after updating it `number_of_iterations` times using `pred`, `dep[end]` contains the shortest distance from the starting node to node `end`, `cur` is `None` (indicating `q` is empty), `q` is an empty deque, and for any `to` in `e[cur]` such that `dep[to]` was initially `-1`, `dep[to]` is set to `dep[cur] + 1` and `to` is appended to `q`.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `i` is `n+1`, `n` is a positive integer, `bad` is `True` if any `deg[dep[i]]` is not equal to `len(e[i])` for any `i` in the range `1` to `n`, otherwise `bad` is `False`.
    if (not bad) :
        print(end)
        exit()
    #State of the program after the if block has been executed: *`i` is `n+1`, `n` is a positive integer, and `bad` is determined as follows: if `not bad` in the if condition, then `bad` remains the same (meaning all `deg[dep[i]]` are equal to `len(e[i])` for all `i` in the range `1` to `n`). Since there is no else part, `bad` does not change if the condition `not bad` is false.
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
        
    #State of the program after the loop has been executed: `cur` is undefined or the last node processed, `q` is empty or contains remaining nodes, `dep` contains the correct depth for each node based on its parent's depth, `top` is the last leaf node found or undefined if no leaf node was found, `n` is a positive integer, `bad` remains unchanged.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `deg` is \([-1] * (n + 1)\), `cur` is undefined or the last node processed, `q` is empty or contains remaining nodes, `dep` contains the correct depth for each node based on its parent's depth, `top` is the last leaf node found or undefined if no leaf node was found, `n` is a positive integer, `bad` is `False` if all `deg[dep[i]] == len(e[i])` for all `i` in the range `1` to `n`, otherwise `bad` is `True`, and `i` is `n + 1
    if (not bad) :
        print(center)
        exit()
    #State of the program after the if block has been executed: *`deg` is \([-1] * (n + 1)\), `cur` is undefined or the last node processed, `q` is empty or contains remaining nodes, `dep` contains the correct depth for each node based on its parent's depth, `top` is the last leaf node found or undefined if no leaf node was found, `n` is a positive integer, `bad` is `False`, and `i` is `n + 1`. If `bad` is `False`, `center` remains unchanged.
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
        
    #State of the program after the loop has been executed: `deg` is \([-1] * (n + 1)\), `cur` is the last node processed in the DFS traversal, `q` is an empty deque, `dep` contains the depth of each node from the root `top`, `top` is the same, `n` is a positive integer, `bad` is `False`, and all nodes have their depths correctly set such that `dep[to] = dep[cur] + 1` for any node `to` that was added to the queue during the execution of the loop.
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `deg[dep[i]]` is either `-1` or `len(e[i])` for all valid `i`, `bad` is `True` if there exists any `i` such that `deg[dep[i]]` is not equal to `len(e[i])`, otherwise `bad` is `False`.
    if (not bad) :
        print(top)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer, `deg[dep[i]]` is either `-1` or `len(e[i])` for all valid `i`, and `bad` is `False`. If `not bad` is true, then `top` is printed.
    print(-1)
#Overall this is what the function does:The function processes a tree structure defined by \( n \) nodes and \( n-1 \) edges. It aims to find a "good" central node in the tree. A node is considered "good" if it satisfies certain conditions related to the degrees of its children. Specifically, for each level in the tree, the number of children of a node should match the degree of that level. If no such node exists, the function prints -1.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
