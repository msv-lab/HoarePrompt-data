
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You have given tree consist of n vertices. Select a vertex as root vertex that satisfies the condition below.

  * For all vertices v_{1} and v_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then degree(v_{1}) = degree(v_{2}), where degree means the number of vertices connected to that vertex, and distance means the number of edges between two vertices. 



Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^{5}) — the number of vertices.

Each of the next n-1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i} < u_{i} ≤ n) — it means there is an edge exist between v_{i} and u_{i}. It is guaranteed that the graph forms tree.

Output

If there is such root vertex exists, print any of them. Otherwise, print -1.

Examples

Input


7
1 2
2 3
3 4
4 5
3 6
6 7


Output


3


Input


6
1 3
2 3
3 4
4 5
4 6


Output


-1

Note

This is the picture for the first example. 1, 5, 7 also can be a valid answer.

<image>

This is the picture for the second example. You can see that it's impossible to find such root vertex.

<image>
Program:
```
from collections import*

def func():
    n = int(raw_input())
    e = [[] for i in range(n + 1)]
    for i in range(n - 1):
        (u, v) = map(int, raw_input().split())
        e[u].append(v)
        e[v].append(u)
    dep = [-1] * (n + 1)
    dep[1] = 0
    q = deque([1])
    cur = 1
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    dep = [-1] * (n + 1)
    pred = [0] * (n + 1)
    dep[cur] = 0
    q = deque([cur])
    end = cur
    while q:
        end = q.popleft()
        for to in e[end]:
            if dep[to] == -1:
                dep[to] = dep[end] + 1
                pred[to] = end
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(cur)
        exit()
    center = end
    for i in range(dep[end] // 2):
        center = pred[center]
    dep = [-1] * (n + 1)
    dep[end] = 0
    q = deque([end])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(end)
        exit()
    top = center
    dep = [-1] * (n + 1)
    dep[center] = 0
    q = deque([center])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                if len(e[to]) == 2:
                    dep[to] = dep[cur] + 1
                    q.append(to)
                elif len(e[to]) == 1:
                    top = to
                    q.clear()
                    break
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(center)
        exit()
    dep = [-1] * (n + 1)
    dep[top] = 0
    q = deque([top])
    while q:
        cur = q.popleft()
        for to in e[cur]:
            if dep[to] == -1:
                dep[to] = dep[cur] + 1
                q.append(to)
    deg = [-1] * (n + 1)
    bad = False
    for i in range(1, n + 1):
        if deg[dep[i]] == -1:
            deg[dep[i]] = len(e[i])
        elif deg[dep[i]] != len(e[i]):
            bad = True
            break
    if not bad:
        print(top)
        exit()
    print(-1)


```
Original Assessment: Correctness: **False**

Explanation: The provided program attempts to find a root vertex in a tree that satisfies the given condition. However, there are several issues in the logic that prevent it from correctly identifying the root vertex for all possible cases:

1. **Depth Calculation and Degree Check**: The program calculates the depth of each node and checks the degrees at each level. However, it only performs this check once, which might miss certain configurations where the condition fails after deeper exploration.

2. **Center Calculation**: The center calculation (`center = end`) might not always be correct. In some cases, the center might not be the best candidate for satisfying the condition, especially when the tree has a specific structure.

3. **Top Node Identification**: The identification of the top node (`top = center`) might not be optimal. The program should consider other nodes that might satisfy the condition better, especially in trees with complex structures.

4. **Final Degree Check**: The final degree check might not cover all necessary cases. The program should ensure that the chosen root vertex satisfies the condition for all pairs of vertices at the same distance.

To illustrate a case where the program might fail, consider the following input:

```
5
1 2
2 3
3 4
4 5
```

In this tree, any vertex can be a valid root since the distances and degrees are consistent. However, the program might not correctly identify any of these vertices due to the issues mentioned above.

Therefore, the program does not handle all potential cases correctly, leading to a verdict of `False`.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function processes a tree structure defined by \( n \) nodes and \( n-1 \) edges. It aims to find a "good" central node in the tree. A node is considered "good" if it satisfies certain conditions related to the degrees of its children. Specifically, for each level in the tree, the number of children of a node should match the degree of that level. If no such node exists, the function prints -1.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
