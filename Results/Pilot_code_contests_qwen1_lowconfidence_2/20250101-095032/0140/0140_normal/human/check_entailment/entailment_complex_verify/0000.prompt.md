
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Little Petya likes arrays of integers a lot. Recently his mother has presented him one such array consisting of n elements. Petya is now wondering whether he can swap any two distinct integers in the array so that the array got unsorted. Please note that Petya can not swap equal integers even if they are in distinct positions in the array. Also note that Petya must swap some two integers even if the original array meets all requirements.

Array a (the array elements are indexed from 1) consisting of n elements is called sorted if it meets at least one of the following two conditions:

  1. a1 ≤ a2 ≤ ... ≤ an; 
  2. a1 ≥ a2 ≥ ... ≥ an. 



Help Petya find the two required positions to swap or else say that they do not exist.

Input

The first line contains a single integer n (1 ≤ n ≤ 105). The second line contains n non-negative space-separated integers a1, a2, ..., an — the elements of the array that Petya's mother presented him. All integers in the input do not exceed 109.

Output

If there is a pair of positions that make the array unsorted if swapped, then print the numbers of these positions separated by a space. If there are several pairs of positions, print any of them. If such pair does not exist, print -1. The positions in the array are numbered with integers from 1 to n.

Examples

Input

1
1


Output

-1


Input

2
1 2


Output

-1


Input

4
1 2 3 4


Output

1 2


Input

3
1 1 1


Output

-1

Note

In the first two samples the required pairs obviously don't exist.

In the third sample you can swap the first two elements. After that the array will look like this: 2 1 3 4. This array is unsorted.
Program:
```
import sys
import math
from collections import deque
#Function 1:
def func_1(f=None):
    if f:
        return map(f, read().split())
    else:
        return read().split()

#Function 2:
def func_2(t, f=None):
    result = []
    result_append = result.append
    for i in xrange(t):
        if f:
            result_append(tuple(map(f, read().split())))
        else:
            result_append(list(read().split()))
    return result

#Function 3:
def func_3(xs, k):
    k2 = 0
    k1 = 0
    for i in xrange(0, n - 1, 1):
        if xs[i] < xs[i + 1]:
            k2 += 1
        if xs[i] > xs[i + 1]:
            k1 += 1
    if k2 >= 2:
        for i in xrange(0, n - 1, 1):
            if xs[i] < xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
    if k2 == 1 and k1 >= 1 and (len(xss) < n):
        for i in xrange(0, n - 1, 1):
            if xs[i] > xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
            if xs[i] < xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
    if k2 == 1 and k1 == 0 and (len(xs) >= 3):
        for i in xrange(0, n - 1, 1):
            if xs[i] < xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
    if k2 == 0:
        for i in xrange(0, n - 1, 1):
            if xs[0] != xs[i]:
                w('%s %s' % (abs(1 + k), abs(i + 1 + k)))
                sys.exit()


```
Original Assessment: Correctness: **False**.

Explanation: The provided code does not handle the logic for identifying and swapping two elements to make the array unsorted correctly. Specifically, the function `func_3` does not properly check for the conditions under which swapping two elements can make the array unsorted. Here are a few issues:

1. **Incorrect Counting Logic**: The variables `k1` and `k2` are used to count the number of increasing and decreasing sequences, but the logic to determine if swapping can make the array unsorted is flawed.

2. **Swapping Logic**: The function attempts to print indices for swapping but does not ensure that the swap will actually make the array unsorted. The function `w` is used to print the indices, but it is not defined in the provided code.

3. **Edge Cases**: The function does not handle all edge cases, such as arrays that are already sorted in both ascending and descending order, or arrays with repeated elements that do not affect the sorting.

Here’s a more appropriate way to solve the problem:

```python
def can_swap_to_unsort(arr):
    n = len(arr)
    if n < 2:
        return -1
    
    # Check if the array is already sorted in non-decreasing order
    non_decreasing = all(arr[i] <= arr[i + 1] for i in range(n - 1))
    
    # Check if the array is already sorted in non-increasing order
    non_increasing = all(arr[i] >= arr[i + 1] for i in range(n - 1))
    
    if non_decreasing or non_increasing:
        # Find the first position where the sequence breaks
        for i in range(n - 1):
            if arr[i] < arr[i + 1]:
                # Find the next position where the sequence breaks in reverse
                for j in range(n - 1, 0, -1):
                    if arr[j] < arr[j - 1]:
                        return i + 1, j + 1
        return -1
    else:
        return -1

# Example usage
n = int(input())
arr = list(map(int, input().split()))

result = can_swap_to_unsort(arr)
print(result)
```

This approach correctly identifies the first and last positions where the array deviates from being sorted in either direction, ensuring that swapping these elements will unsort the array.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys
import math
from collections import deque

w = sys.stdout.write
read = sys.stdin.readline
reads = sys.stdin.read
sqrt = math.sqrt
[n] = func_1(int)
xs = func_1(int)
xss = set(xs)
if n <= 2:
    w('-1')
    sys.exit()
if len(xss) == 1:
    w('-1')
    sys.exit()
if len(xs) == 3 and xs[0] == xs[2]:
    w('-1')
    sys.exit()
func_3(xs, 0)
xs.reverse()
func_3(xs, -1 * n)
w('-1')

#Function 1:
#State of the program right berfore the function call: read() is a function that returns a string containing space-separated integers, and f is a function that converts strings to integers. The returned value should be a list of integers representing the array elements.
def func_1(f):
    if f :
        return map(f, read().split())
        #The program returns a map object that applies function f to each integer in the list of integers returned by read(). The read() function returns a string of space-separated integers, which is then split into a list of strings, and function f is applied to each element of this list to convert them to integers.
    else :
        return read().split()
        #`The program returns a list of integers obtained by splitting the string returned by the function read()`
#Overall this is what the function does:The function `func_1` accepts a parameter `f`, which is a function that converts strings to integers. It reads a string of space-separated integers using the `read()` function. Depending on whether `f` is provided, the function returns either a map object applying `f` to each integer in the list of integers or a list of integers directly obtained by splitting the string returned by `read()`.

In both cases, the final state of the program after the function concludes is:
- If `f` is provided and is a valid function, the program returns a map object where `f` is applied to each integer in the list of integers.
- If `f` is not provided or is not a valid function, the program returns a list of integers obtained by splitting the string returned by `read()`.

Potential edge cases and missing functionality:
- The annotation mentions that the function returns a map object when `f` is provided. However, the function does not check if `f` is a valid callable function. If `f` is not callable, the function will raise a `TypeError`.
- The function does not handle cases where `read()` returns an empty string. In such cases, the returned map object (in Case 1) would be empty, and the returned list (in Case 2) would also be empty.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of lines to read, and each line is a space-separated list of non-negative integers. The length of each list does not exceed 10^5 and all integers in the list do not exceed 10^9.
def func_2(t, f):
    result = []
    result_append = result.append
    for i in xrange(t):
        if f:
            result_append(tuple(map(f, read().split())))
        else:
            result_append(list(read().split()))
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `i` is `t-1`, `result` is a list of elements where each element is either a tuple resulting from applying `f` to the split input or a list resulting from splitting the input without applying `f`.
    return result
    #`The program returns the list 'result' which contains elements where each element is either a tuple resulting from applying function f to the split input or a list resulting from splitting the input without applying f, given that 't' is a positive integer and 'i' is 't-1'`
#Overall this is what the function does:The function `func_2` accepts two parameters: a positive integer `t` and a function `f`. It reads `t` lines from an input source, where each line is a space-separated list of non-negative integers. For each line, it splits the line into a list of integers. If the function `f` is provided (`f` is not `None`), it applies `f` to each integer in the list and converts the result back into a list or tuple (depending on whether `f` returns a single value or a tuple). Otherwise, it simply converts the split line into a list of integers. The function then collects these results into a list called `result` and returns it. The final state of the program after the function concludes is that the variable `result` contains a list of either tuples or lists, depending on whether `f` was applied.

#Function 3:
#State of the program right berfore the function call: xs is a list of integers representing the array with length n (1 <= n <= 10^5), and k is an integer (though its purpose is not clear from the function and seems to be unused in the logic provided).
def func_3(xs, k):
    k2 = 0
    k1 = 0
    for i in xrange(0, n - 1, 1):
        if xs[i] < xs[i + 1]:
            k2 += 1
        
        if xs[i] > xs[i + 1]:
            k1 += 1
        
    #State of the program after the  for loop has been executed: `xs` is a list of integers, `k2` is the count of indices where `xs[i] < xs[i + 1]`, `k1` is the count of indices where `xs[i] > xs[i + 1]`, `i` is the last index accessed during the loop (equal to `n - 2`), `n` is the length of `xs`.
    if (k2 >= 2) :
        for i in xrange(0, n - 1, 1):
            if xs[i] < xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
            
        #State of the program after the  for loop has been executed: `xs` is a list of integers, `k2` is the count of indices where `xs[i] < xs[i + 1]`, `k1` is the count of indices where `xs[i] > xs[i + 1]`, `i` is `n - 1`, `n` is the length of `xs`, and the function `w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))` has been executed if the condition `xs[i] < xs[i + 1]` is met at least once during the loop. If the loop does not execute, `k2` remains as the initial value, `i` is `n - 2`, and the function `w` is not called.
    #State of the program after the if block has been executed: *`xs` is a list of integers, `k2` is the count of indices where `xs[i] < xs[i + 1]`, `k1` is the count of indices where `xs[i] > xs[i + 1]`, `i` is either `n - 1` or `n - 2` depending on whether the loop executes or not, `n` is the length of `xs`. If `k2 >= 2` and the loop executes, `k2` is updated, `i` is set to `n - 1`, and the function `w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))` is called. If the condition `k2 >= 2` is not met or the loop does not execute, `k2` remains unchanged, `i` is set to `n - 2`, and the function `w` is not called.
    if (k2 == 1 and k1 >= 1 and len(xss) < n) :
        for i in xrange(0, n - 1, 1):
            if xs[i] > xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
            
            if xs[i] < xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
            
        #State of the program after the  for loop has been executed: `xs` is a list of integers, `k2` is 1, `k1` is greater than or equal to 1, `i` is `n - 2` if the loop does not execute, or it is the index `i` where the loop exited, `n` is the length of `xs`, and the function `w` is called with one of the following output strings: `'1 2'`, `'3 4'`, `'4 5'`, etc., based on the comparison in the loop.
    #State of the program after the if block has been executed: *`xs` is a list of integers, `k2` is 1, `k1` is greater than or equal to 1, `i` is `n - 2` if the loop does not execute, or it is the index `i` where the loop exited, `n` is the length of `xs`, and the function `w` is called with one of the following output strings: `'1 2'`, `'3 4'`, `'4 5'`, etc., based on the comparison in the loop.
    if (k2 == 1 and k1 == 0 and len(xs) >= 3) :
        for i in xrange(0, n - 1, 1):
            if xs[i] < xs[i + 1]:
                w('%s %s' % (abs(i + 1 + k), abs(i + 2 + k)))
                sys.exit()
            
        #State of the program after the  for loop has been executed: `xs` is a list of integers, `k2` is 1, `k1` is 0, `i` is `n - 1` if the loop executed `n - 2` times, or `n - 2` if the loop did not execute, and `n` is the length of `xs`.
    #State of the program after the if block has been executed: *`xs` is a list of integers, `k2` is 1, `k1` is 0, `i` is `n - 1` if the loop executed `n - 2` times, or `n - 2` if the loop did not execute, and `n` is the length of `xs`. The function `w` is called with one of the following output strings: `'1 2'`, `'3 4'`, `'4 5'`, etc., based on the comparison in the loop.
    if (k2 == 0) :
        for i in xrange(0, n - 1, 1):
            if xs[0] != xs[i]:
                w('%s %s' % (abs(1 + k), abs(i + 1 + k)))
                sys.exit()
            
        #State of the program after the  for loop has been executed: `i` is `n - 1` if the loop did not execute, or the index where `xs[0]` is not equal to `xs[i]` if the loop executed, `n` is the length of `xs`, `k2` is 0, `k1` is 0.
    #State of the program after the if block has been executed: *`i` is the index of the first element in `xs` that is different from `xs[0]`, `n` is the length of `xs`, `k2` is 0, and `k1` is 0. If no such element exists, `i` is `n - 1`.
#Overall this is what the function does:The function `func_3` takes a list `xs` of integers and an unused parameter `k`. It counts the number of adjacent pairs where the first element is less than (`k2`) or greater than (`k1`) the second element. Based on these counts and specific conditions, it calls the function `w` to print certain indices and then exits. The function does not modify the input list `xs`. The final state of the program is that `xs` remains unchanged, `k2` contains the count of ascending pairs, `k1` contains the count of descending pairs, `i` is the last index checked, and `n` is the length of `xs`. If the function `w` is called, it prints indices formatted as strings.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
