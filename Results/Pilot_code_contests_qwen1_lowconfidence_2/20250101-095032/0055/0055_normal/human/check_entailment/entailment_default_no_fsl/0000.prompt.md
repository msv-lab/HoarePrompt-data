
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Monocarp and Polycarp are learning new programming techniques. Now they decided to try pair programming.

It's known that they have worked together on the same file for n + m minutes. Every minute exactly one of them made one change to the file. Before they started, there were already k lines written in the file.

Every minute exactly one of them does one of two actions: adds a new line to the end of the file or changes one of its lines.

Monocarp worked in total for n minutes and performed the sequence of actions [a_1, a_2, ..., a_n]. If a_i = 0, then he adds a new line to the end of the file. If a_i > 0, then he changes the line with the number a_i. Monocarp performed actions strictly in this order: a_1, then a_2, ..., a_n.

Polycarp worked in total for m minutes and performed the sequence of actions [b_1, b_2, ..., b_m]. If b_j = 0, then he adds a new line to the end of the file. If b_j > 0, then he changes the line with the number b_j. Polycarp performed actions strictly in this order: b_1, then b_2, ..., b_m.

Restore their common sequence of actions of length n + m such that all actions would be correct — there should be no changes to lines that do not yet exist. Keep in mind that in the common sequence Monocarp's actions should form the subsequence [a_1, a_2, ..., a_n] and Polycarp's — subsequence [b_1, b_2, ..., b_m]. They can replace each other at the computer any number of times.

Let's look at an example. Suppose k = 3. Monocarp first changed the line with the number 2 and then added a new line (thus, n = 2, \: a = [2, 0]). Polycarp first added a new line and then changed the line with the number 5 (thus, m = 2, \: b = [0, 5]).

Since the initial length of the file was 3, in order for Polycarp to change line number 5 two new lines must be added beforehand. Examples of correct sequences of changes, in this case, would be [0, 2, 0, 5] and [2, 0, 0, 5]. Changes [0, 0, 5, 2] (wrong order of actions) and [0, 5, 2, 0] (line 5 cannot be edited yet) are not correct.

Input

The first line contains an integer t (1 ≤ t ≤ 1000). Then t test cases follow. Before each test case, there is an empty line.

Each test case contains three lines. The first line contains three integers k, n, m (0 ≤ k ≤ 100, 1 ≤ n, m ≤ 100) — the initial number of lines in file and lengths of Monocarp's and Polycarp's sequences of changes respectively.

The second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 300).

The third line contains m integers b_1, b_2, ..., b_m (0 ≤ b_j ≤ 300).

Output

For each test case print any correct common sequence of Monocarp's and Polycarp's actions of length n + m or -1 if such sequence doesn't exist.

Example

Input


5

3 2 2
2 0
0 5

4 3 2
2 0 5
0 6

0 2 2
1 0
2 3

5 4 4
6 0 8 0
0 7 0 9

5 4 1
8 7 8 0
0


Output


2 0 0 5 
0 2 0 6 5 
-1
0 6 0 7 0 8 0 9
-1
Functions with output description for each function:
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
t = int(input().rstrip())
for _ in range(t):
    str1 = input()
    (k, n, m) = list(map(int, input().rstrip().split()))
    list1 = list(map(int, input().rstrip().split()))
    list2 = list(map(int, input().rstrip().split()))
    list3 = []
    result = True
    t1 = 0
    t2 = 0
    while True:
        if t1 == n and t2 == m:
            break
        if t1 < n:
            if list1[t1] == 0:
                k += 1
                t1 += 1
                list3.append(0)
            elif list1[t1] <= k:
                list3.append(list1[t1])
                t1 += 1
            elif t2 == m:
                result = False
                break
            elif list2[t2] > k:
                result = False
                break
        if t2 < m:
            if list2[t2] == 0:
                k += 1
                t2 += 1
                list3.append(0)
            elif list2[t2] <= k:
                list3.append(list2[t2])
                t2 += 1
            elif t1 == n:
                result = False
                break
            elif list1[t1] > k:
                result = False
                break
    if result is False:
        func_2(-1)
    else:
        func_2(*list3)

Function number 1 :
 Code:
 '''
def func_1():
    pass
''' 

 Output hints for function1:  The function `func_1` accepts parameters `k`, `n`, `m`, `a`, and `b`, where `k` is an integer, `n` and `m` are integers, and `a` and `b` are lists of integers representing actions by Monocarp and Polycarp respectively. However, the function does not contain any code inside the `def` block, meaning it does nothing upon execution. As a result, the values of `k`, `n`, `m`, `a`, and `b` remain unchanged after the function call. There are no actions performed on these parameters, and no return value is provided. This leads to an incomplete and ineffective function, failing to achieve any intended purpose based on the given annotations.
Function number 2 :
 Code:
 '''
def func_2(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function2:  The function does not accept the parameters `k`, `n`, `m`, `a`, and `b` as described in the annotations. Instead, it takes positional arguments (`args`) and keyword arguments (`kwargs`). It writes the string representations of the elements in `args` to `sys.stdout`, separated by a space character (`sep`), and appends a newline character (`end`) at the end. Additionally, it flushes `sys.stdout` if the `flush` keyword argument is set to `True`. The function does not modify the parameters `k`, `n`, `m`, `a`, and `b` and does not return anything.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.