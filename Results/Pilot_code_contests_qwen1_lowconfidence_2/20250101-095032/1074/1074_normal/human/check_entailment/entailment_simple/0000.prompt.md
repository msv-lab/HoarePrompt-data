
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You have n chains, the i-th chain consists of c_i vertices. Vertices in each chain are numbered independently from 1 to c_i along the chain. In other words, the i-th chain is the undirected graph with c_i vertices and (c_i - 1) edges connecting the j-th and the (j + 1)-th vertices for each 1 ≤ j < c_i.

Now you decided to unite chains in one graph in the following way: 

  1. the first chain is skipped; 
  2. the 1-st vertex of the i-th chain is connected by an edge with the a_i-th vertex of the (i - 1)-th chain; 
  3. the last (c_i-th) vertex of the i-th chain is connected by an edge with the b_i-th vertex of the (i - 1)-th chain. 

<image> Picture of the first test case. Dotted lines are the edges added during uniting process

Calculate the length of the longest simple cycle in the resulting graph.

A simple cycle is a chain where the first and last vertices are connected as well. If you travel along the simple cycle, each vertex of this cycle will be visited exactly once.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first line of each test case contains the single integer n (2 ≤ n ≤ 10^5) — the number of chains you have.

The second line of each test case contains n integers c_1, c_2, ..., c_n (2 ≤ c_i ≤ 10^9) — the number of vertices in the corresponding chains.

The third line of each test case contains n integers a_1, a_2, ..., a_n (a_1 = -1; 1 ≤ a_i ≤ c_{i - 1}).

The fourth line of each test case contains n integers b_1, b_2, ..., b_n (b_1 = -1; 1 ≤ b_i ≤ c_{i - 1}).

Both a_1 and b_1 are equal to -1, they aren't used in graph building and given just for index consistency. It's guaranteed that the sum of n over all test cases doesn't exceed 10^5.

Output

For each test case, print the length of the longest simple cycle.

Example

Input


3
4
3 4 3 3
-1 1 2 2
-1 2 2 3
2
5 6
-1 5
-1 1
3
3 5 2
-1 1 1
-1 3 5


Output


7
11
8

Note

In the first test case, the longest simple cycle is shown below: 

<image>

We can't increase it with the first chain, since in such case it won't be simple — the vertex 2 on the second chain will break simplicity.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 1000, n is an integer such that 2 ≤ n ≤ 10^5, c is a list of n integers where 2 ≤ c_i ≤ 10^9, a and b are lists of n integers each, where a[i] and b[i] are such that a[i] and b[i] are valid indices within the range of c[i-1] (inclusive), and the sum of n over all test cases doesn't exceed 10^5.
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        
        c = [int(ci) for ci in input().split()]
        
        a = [int(ai) for ai in input().split()]
        
        b = [int(bi) for bi in input().split()]
        
        for i in range(n):
            a[i], b[i] = min(a[i], b[i]), max(a[i], b[i])
        
        best = 1
        
        curr = b[1] - a[1] + 1
        
        for i in range(1, n):
            best = max(best, curr + c[i])
            if i != n - 1:
                curr += a[i + 1] + (c[i] - b[i + 1] + 1)
                if a[i + 1] == b[i + 1]:
                    curr = 1
        
        func_2(best)
        
    #State of the program after the  for loop has been executed: `t` is a non-negative integer, `n` is a non-negative integer, `best` is the maximum value obtained by iterating through the loop, `curr` is 1 if `a[n] == b[n]`, otherwise `curr` is the sum of all increments calculated during the loop, `a[i]` is the minimum of the original `a[i]` and `b[i]` after all iterations, `b[i]` is the maximum of the original `a[i]` and `b[i]` after all iterations, `i` is `n`, `a`, `b`, and `c` are unchanged from their initial values, `func_2(best)` has been called.

#Function 2:
#State of the program right berfore the function call: t is an integer representing the number of test cases, n is an integer representing the number of chains, c is a list of integers where c[i] represents the number of vertices in the i-th chain, a is a list of integers where a[i] represents the vertex index in the (i - 1)-th chain that connects to the first vertex of the i-th chain, and b is a list of integers where b[i] represents the vertex index in the (i - 1)-th chain that connects to the last vertex of the i-th chain.
def func_2():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is an empty iterable, `t` is an integer representing the number of test cases, `n` is an integer representing the number of chains, `c` is a list of integers where `c[i]` represents the number of vertices in the i-th chain, `a` is a list of integers where `a[i]` represents the vertex index in the (i-1)-th chain that connects to the first vertex of the i-th chain, `b` is a list of integers where `b[i]` represents the vertex index in the (i-1)-th chain that connects to the last vertex of the i-th chain, `sep` is a space `' '`, `file` is `sys.stdout`, and `at_start` is `False`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is an empty iterable, `t` is an integer representing the number of test cases, `n` is an integer representing the number of chains, `c` is a list of integers where `c[i]` represents the number of vertices in the i-th chain, `a` is a list of integers where `a[i]` represents the vertex index in the (i-1)-th chain that connects to the first vertex of the i-th chain, `b` is a list of integers where `b[i]` represents the vertex index in the (i-1)-th chain that connects to the last vertex of the i-th chain, `sep` is a space `' '`, `file` is `sys.stdout`, `at_start` is `False`, and `sys.stdout` has been flushed if `kwargs.pop('flush', False)` is `True`. Otherwise, `sys.stdout` remains unchanged.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
