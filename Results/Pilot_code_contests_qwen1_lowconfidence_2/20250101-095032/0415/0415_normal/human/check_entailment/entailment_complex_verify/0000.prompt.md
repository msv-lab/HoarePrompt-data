
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: A tree is an undirected connected graph without cycles.

Let's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).

<image> For this rooted tree the array p is [2, 3, 3, 2].

Given a sequence p1, p2, ..., pn, one is able to restore a tree:

  1. There must be exactly one index r that pr = r. A vertex r is a root of the tree. 
  2. For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. 



A sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.

You are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.

Input

The first line of the input contains an integer n (2 ≤ n ≤ 200 000) — the number of vertices in the tree.

The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n).

Output

In the first line print the minimum number of elements to change, in order to get a valid sequence.

In the second line, print any valid sequence possible to get from (a1, a2, ..., an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.

Examples

Input

4
2 3 3 4


Output

1
2 3 4 4 


Input

5
3 2 2 5 3


Output

0
3 2 2 5 3 


Input

8
2 3 5 4 1 6 6 7


Output

2
2 3 7 8 1 6 6 7

Note

In the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red.

<image>

In the second sample, the given sequence is already valid.
Program:
```
import itertools
import sys

class Solution(object):

    def find(self, ident, fa):
        if fa[ident] != ident:
            fa[ident] = self.find(fa[ident], fa)
        return fa[ident]

    def merge(self, ident_child, ident_father, fa):
        fa_child = fa[ident_child]
        fa_father = fa[ident_father]
        fa[fa_child] = fa_father

    def solve(self):
        n = self.n
        p = self.p
        issues = []
        roots = []
        fa = [i for i in xrange(n)]
        for current in xrange(n):
            parent = p[current]
            if parent == current:
                roots.append(current)
                continue
            parent_set_id = self.find(parent, fa)
            if parent_set_id == current:
                issues.append(current)
                continue
            self.merge(current, parent, fa)
        root = None
        changes = 0
        if len(roots) > 0:
            root = roots[0]
            changes = len(roots) + len(issues) - 1
        elif len(roots) == 0:
            root = roots[0] if len(roots) > 0 else issues[0]
            changes = len(roots) + len(issues)
        for ident in itertools.chain(roots, issues):
            p[ident] = root
        return (changes, p)

    def read_data(self):
        self.n = func_1()[0]
        self.p = func_1(delta=-1)

    def print_result(self, result):
        (changes, p) = result
        print(changes)
        for (idx, parent) in enumerate(p):
            sys.stdout.write(str(parent))
            if idx != len(p) - 1:
                sys.stdout.write(' ')
        sys.stdout.write('\n')

    def run(self):
        self.read_data()
        result = self.solve()
        self.print_result(result)
if len(sys.argv) > 1:
    sys.stdin = open(sys.argv[1], 'r')
    print('Redirect stdin to {0}'.format(sys.argv[1]))
Solution().run()

def func_1(delta=0):
    return [int(i) + delta for i in raw_input().split()]


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not correctly handle the problem description for every potential case. Specifically, the program does not ensure that the resulting sequence is acyclic and connected. Here's an example to demonstrate the issue:

### Example

**Input:**
```
4
2 3 3 4
```

**Expected Output:**
```
1
2 3 4 4
```

**Actual Output:**
```
1
2 3 4 4
```

This example works correctly, but let's consider another case:

**Input:**
```
5
3 2 2 5 3
```

**Expected Output:**
```
0
3 2 2 5 3
```

**Actual Output:**
```
0
3 2 2 5 3
```

This also works correctly. However, let's consider a more complex case:

**Input:**
```
8
2 3 5 4 1 6 6 7
```

**Expected Output:**
```
2
2 3 7 8 1 6 6 7
```

**Actual Output:**
```
2
2 3 7 8 1 6 6 7
```

This example also works correctly. However, the issue arises when we consider the logic for identifying and merging sets. The program uses union-find to identify and merge sets, but it does not properly ensure that the resulting sequence is acyclic and connected.

For instance, consider the following input:

**Input:**
```
6
1 2 2 3 3 4
```

**Expected Output:**
```
1
1 2 2 3 3 4
```

However, the actual output may be incorrect because the program might incorrectly merge sets without ensuring the acyclic and connected property. 

To correctly handle the problem, the program needs to ensure that:
1. There is exactly one root node.
2. All nodes are connected in a single tree.

The provided solution does not guarantee these properties, leading to potential incorrect outputs for certain inputs. Therefore, the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import itertools
import sys

class Solution(object):

    def find(self, ident, fa):
        if fa[ident] != ident:
            fa[ident] = self.find(fa[ident], fa)
        return fa[ident]

    def merge(self, ident_child, ident_father, fa):
        fa_child = fa[ident_child]
        fa_father = fa[ident_father]
        fa[fa_child] = fa_father

    def solve(self):
        n = self.n
        p = self.p
        issues = []
        roots = []
        fa = [i for i in xrange(n)]
        for current in xrange(n):
            parent = p[current]
            if parent == current:
                roots.append(current)
                continue
            parent_set_id = self.find(parent, fa)
            if parent_set_id == current:
                issues.append(current)
                continue
            self.merge(current, parent, fa)
        root = None
        changes = 0
        if len(roots) > 0:
            root = roots[0]
            changes = len(roots) + len(issues) - 1
        elif len(roots) == 0:
            root = roots[0] if len(roots) > 0 else issues[0]
            changes = len(roots) + len(issues)
        for ident in itertools.chain(roots, issues):
            p[ident] = root
        return (changes, p)

    def read_data(self):
        self.n = func_1()[0]
        self.p = func_1(delta=-1)

    def print_result(self, result):
        (changes, p) = result
        print(changes)
        for (idx, parent) in enumerate(p):
            sys.stdout.write(str(parent))
            if idx != len(p) - 1:
                sys.stdout.write(' ')
        sys.stdout.write('\n')

    def run(self):
        self.read_data()
        result = self.solve()
        self.print_result(result)
if len(sys.argv) > 1:
    sys.stdin = open(sys.argv[1], 'r')
    print('Redirect stdin to {0}'.format(sys.argv[1]))
Solution().run()

#State of the program right berfore the function call: delta is an integer.
def func_1(delta):
    return [(int(i) + delta) for i in raw_input().split()]
    #The program returns a list of integers where each integer is the sum of an input integer and the value of delta
#Overall this is what the function does:The function `func_1` accepts an integer `delta` as a parameter and prompts the user to input a series of space-separated integers. It then returns a list of integers where each integer is the sum of the corresponding input integer and `delta`. The function reads input from the standard input (stdin) and expects a string of space-separated integers as input. If no input is provided or the input format is incorrect, the function will not produce the expected output and may raise a `ValueError` due to the `split()` method.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
