Correctness: **False**

Explanation: The code does not handle the case where there are no adjacent digits of different parity in the string. According to the problem description, you can swap two adjacent digits if they have different parities. However, the current implementation of `func_2` always tries to pop from `even_digits` if it's not empty, even if there are no odd digits left to compare. This can lead to incorrect results in cases where no valid swaps are possible.

For example, consider the input "111". In this case, there are no adjacent digits of different parity, so the function should return "111" as it is. However, the current implementation will attempt to pop from `even_digits` and `odd_digits` until one of them is exhausted, which will result in an empty string being returned.

To fix this, the function should check if there are any valid swaps possible before proceeding with the swaps. Here is a modified version of `func_2` that addresses this issue:

```python
def func_2(num):
    num = [(ord(x) - ord('0')) for x in num]
    even_digits, odd_digits = collections.deque(), collections.deque()
    for digit in num:
        if digit & 1 == 0:
            even_digits.append(digit)
        else:
            odd_digits.append(digit)
    
    ret = []
    i, j = 0, 0
    while i < len(num) and j < len(num):
        if i < len(even_digits) and (j >= len(odd_digits) or even_digits[i] <= odd_digits[j]):
            ret.append(even_digits.popleft())
            i += 1
        elif j < len(odd_digits):
            ret.append(odd_digits.popleft())
            j += 1
        else:
            break
    
    return ''.join(map(str, ret))
```

With this modification, the function will correctly handle cases where no valid swaps are possible, ensuring that the output matches the problem description for every potential case.