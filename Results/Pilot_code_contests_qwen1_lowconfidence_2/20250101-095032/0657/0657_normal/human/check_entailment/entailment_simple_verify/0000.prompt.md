
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i ∈ \{1, 2\}) — the values written on the tiles.

Output

Output a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

Examples

Input


5
1 2 1 2 1


Output


1 1 1 2 2


Input


9
1 1 2 1 1 1 2 1 1


Output


1 1 1 2 1 1 1 2 1

Note

The first solution produces the prefix sums 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.
Program:
```
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase
#Function 1:
def func_1(*args, **kwargs):
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return str(input())

#Function 4:
def func_4():
    return map(int, input().strip().split(' '))

#Function 5:
def func_5():
    return list(func_4())

#Function 6:
def func_6(item):
    return item[0]

#Function 7:
def func_7(l):
    return sorted(l, key=getKey)

#Function 8:
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 9:
def func_9(x):
    return x and (not x & x - 1)

#Function 10:
def func_10(n):
    return bin(n).replace('0b', '')

#Function 11:
def func_11(n):
    return [int(i) for i in str(n)]

#Function 12:
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res

#Function 13:
def func_13(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 14:
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    'if two==one:\n        for i in range(n):\n            if i%2==0:\n                s.append(2)\n            else:\n                s.append(1)\n        print(*s)\n        exit()\n        \n    \n    for i in range(n):\n        if a[i]==1:\n            if one !=0:\n                s.append(1)\n                one-=1\n            else:\n                s.append(2)\n                two-=1\n        else:\n            if two!=0:\n                s.append(2)\n                two-=1\n            else:\n                s.append(1)\n                one-=1\n    print(*s)   '
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
    func_1(*s)


```
Original Assessment: Correctness: **False**.

Explanation: The provided program does not correctly generate a permutation that maximizes the number of prefix sums being prime numbers. Specifically, the program has several issues:

1. **Incorrect Handling of Input and Logic**: The program attempts to handle the input and generate a permutation but does not correctly ensure that the prefix sums are maximized to be prime numbers. For instance, the commented-out section seems to be an attempt to handle the input, but it does not guarantee the generation of a permutation that maximizes the number of prime prefix sums.

2. **Missing Key Logic**: The core logic for generating a permutation that maximizes the number of prime prefix sums is missing. The program uses a fixed pattern `[1, 1, 1, 2] * 50000` and then tries to insert the remaining `1`s and `2`s, but this approach does not guarantee the optimal permutation for arbitrary inputs.

3. **Incomplete Implementation**: The actual logic for generating the optimal permutation is incomplete and relies on the commented-out section, which is not fully implemented. This results in the program not functioning as intended for all potential cases.

For example, consider the input:
```
4
1 1 2 2
```
A correct output would be `[1, 2, 1, 2]`, which gives prefix sums `[1, 3, 4, 6]`, resulting in 2 prime numbers (3). However, the program does not produce such an optimal permutation and instead relies on a fixed pattern, which may not always result in the maximum number of prime prefix sums.

Therefore, the program does not correctly meet the requirements of the problem description for all potential cases, leading to a verdict of `False`.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase

"""
Author    : raj1307 - Raj Singh
Institute : Jalpaiguri Government Engineering College
Date      : 29.04.19
"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from builtins import str as __str__
    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            (b, ptr) = (os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell())
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
            self.newlines += b.count(b'\n') + (not b)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            (self._buffer.truncate(0), self._buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
if __name__ == '__main__':
    func_14()

#Function 1:
#State of the program right berfore the function call: args is a variable-length argument list containing integers 1 and 2, and kwargs is a dictionary with keys 'sep', 'file', 'end', and 'flush', all having default values. 'sep' is a byte string used to separate arguments when writing to the file, 'file' is the file object to which the data is written (defaulting to stdout), 'end' is a byte string appended after the last argument (defaulting to a newline), and 'flush' is a boolean indicating whether the output buffer should be forcibly flushed (defaulting to False).
def func_1():
    sep, file = kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a variable-length argument list containing integers 1 and 2, `x` is the last element in `args`, `kwargs` is a dictionary with keys `'end'` and `'flush'`, both having default values, `sep` is b' ', `file` is sys.stdout, and `sys.stdout` has the value "1 2 ... (all elements of args separated by sep)" written to it, and `at_start` is False.
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a variable-length argument list containing integers 1 and 2, `x` is the last element in `args`, `kwargs` is a dictionary with the key `'end'` removed and `'flush'` set to `False`, both having default values, `sep` is b' ', `sys.stdout` has the value "1 2 ... (all elements of args separated by sep)\n" written to it, and `at_start` is False. Since there is no else part, the value of `kwargs['flush']` remains `False`.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function `func_2()` are described in the context provided. The function does not take any parameters and returns an integer obtained from user input. However, based on the problem description, the integer input should represent the number of number tiles in the bag, which implies it should be an integer within the range 1 ≤ n ≤ 200,000.
def func_2():
    return int(input())
    #The program returns an integer input by the user, which represents the number of number tiles in the bag and is within the range 1 ≤ n ≤ 200,000

#Function 3:
#State of the program right berfore the function call: The variable n is an integer representing the number of number tiles in the bag, and the following line contains n space-separated integers where each integer is either 1 or 2.
def func_3():
    return str(input())
    #The program returns a string containing n space-separated integers where each integer is either 1 or 2

#Function 4:
#State of the program right berfore the function call: None of the variables in the function `func_4` are defined in its signature, thus no specific precondition can be extracted regarding the input variables. However, the function reads input from stdin which consists of a single line containing an integer n followed by n space-separated integers where each integer is either 1 or 2.
def func_4():
    return map(int, input().strip().split(' '))
    #The program returns a map object that converts each of the n space-separated integers (either 1 or 2) from the input into an integer

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the following line of input contains n integers where each integer is either 1 or 2.
def func_5():
    return list(func_4())
    #The program returns a list generated by func_4(), which processes a list of integers (each being 1 or 2) and returns a list based on the input integers

#Function 6:
#State of the program right berfore the function call: item is a tuple or list consisting of at least one element, where the first element is of a type that can be compared and sorted (e.g., integer or string).
def func_6(item):
    return item[0]
    #The program returns the first element of the tuple or list 'item', which is of a type that can be compared and sorted

#Function 7:
#State of the program right berfore the function call: l is a list of integers where each integer is either 1 or 2.
def func_7(l):
    return sorted(l, key=getKey)
    #The program returns a list of integers from 'l', sorted in ascending order based on the values returned by the 'getKey' function for each element in 'l'

#Function 8:
#State of the program right berfore the function call: n and m are positive integers representing dimensions of a 2D list, and num is an integer either 1 or 2.
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns, where each element in the list is equal to 'num', which is either 1 or 2

#Function 9:
#State of the program right berfore the function call: x is a non-negative integer.
def func_9(x):
    return x and not x & x - 1
    #The program returns True if x is 0, otherwise it returns False

#Function 10:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 2^{200000} (since the number of tiles is at most 200,000, n can be represented within this range).
def func_10(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of the integer n without the '0b' prefix

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the binary representation of n consists only of the digits 1 and 2.
def func_11(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers, where each integer is either 1 or 2, representing the binary digits of the integer n

#Function 12:
#State of the program right berfore the function call: x is an integer, y is a non-negative integer, and p is a positive integer.
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p1
        
    #State of the program after the loop has been executed: 'x' is \(x^{2^k} \mod p1\) where \(k\) is the number of times the loop has executed, 'y' is 0, 'res' is the product of the initial value of 'res' with \(x^{2^j} \mod p1\) for every odd 'y' in the range from the original value of 'y' to 1, all taken modulo 'p'.
    return res
    #The program returns res which is the product of the initial value of res with x^(2^j) mod p1 for every odd y in the range from the original value of y to 1, all taken modulo p

#Function 13:
#State of the program right berfore the function call: x and y are integers such that \(x \geq 0\) and \(y > 0\).
def func_13(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the last non-zero remainder obtained from successive divisions of the original value of `x` by the original value of `y`, `y` is 0.
    return x
    #The program returns x, which is the last non-zero remainder obtained from successive divisions of the original value of x by the original value of y

#Function 14:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and l is a list of integers where each integer is either 1 or 2.
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    """if two==one:
        for i in range(n):
            if i%2==0:
                s.append(2)
            else:
                s.append(1)
        print(*s)
        exit()
        
    
    for i in range(n):
        if a[i]==1:
            if one !=0:
                s.append(1)
                one-=1
            else:
                s.append(2)
                two-=1
        else:
            if two!=0:
                s.append(2)
                two-=1
            else:
                s.append(1)
                one-=1
    print(*s)   """
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
        
    #State of the program after the  for loop has been executed: Output State:
    func_1(*s)



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
