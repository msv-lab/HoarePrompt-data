
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i ∈ \{1, 2\}) — the values written on the tiles.

Output

Output a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

Examples

Input


5
1 2 1 2 1


Output


1 1 1 2 2


Input


9
1 1 2 1 1 1 2 1 1


Output


1 1 1 2 1 1 1 2 1

Note

The first solution produces the prefix sums 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.
Annotated Functions:
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase

"""
Author    : raj1307 - Raj Singh
Institute : Jalpaiguri Government Engineering College
Date      : 29.04.19
"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from builtins import str as __str__
    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            (b, ptr) = (os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell())
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
            self.newlines += b.count(b'\n') + (not b)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            (self._buffer.truncate(0), self._buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
if __name__ == '__main__':
    func_14()

#Function 1:
#State of the program right berfore the function call: args is a variable-length argument list containing integers 1 and 2, and kwargs is a dictionary with keys 'sep', 'file', 'end', and 'flush', all having default values. 'sep' is a byte string used to separate arguments when writing to the file, 'file' is the file object to which the data is written (defaulting to stdout), 'end' is a byte string appended after the last argument (defaulting to a newline), and 'flush' is a boolean indicating whether the output buffer should be forcibly flushed (defaulting to False).
def func_1():
    sep, file = kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a variable-length argument list containing integers 1 and 2, `x` is the last element in `args`, `kwargs` is a dictionary with keys `'end'` and `'flush'`, both having default values, `sep` is b' ', `file` is sys.stdout, and `sys.stdout` has the value "1 2 ... (all elements of args separated by sep)" written to it, and `at_start` is False.
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a variable-length argument list containing integers 1 and 2, `x` is the last element in `args`, `kwargs` is a dictionary with the key `'end'` removed and `'flush'` set to `False`, both having default values, `sep` is b' ', `sys.stdout` has the value "1 2 ... (all elements of args separated by sep)\n" written to it, and `at_start` is False. Since there is no else part, the value of `kwargs['flush']` remains `False`.
#Overall this is what the function does:This function takes a variable-length argument list `args` containing integers and a dictionary `kwargs` with optional parameters 'sep', 'file', 'end', and 'flush'. It writes the elements of `args` to the specified `file` (defaulting to standard output) separated by the byte string `sep` (defaulting to a space). After writing the last element, it appends the `end` string (defaulting to a newline) and flushes the output buffer if requested. The function does not return any value.

The final state of the program after the function concludes will be that the elements of `args` have been written to `file` (which defaults to standard output), separated by `sep` (defaulting to a space), followed by the `end` string (defaulting to a newline). If `flush` was set to `True` in `kwargs`, the output buffer will be flushed. If `sep` was not provided, it defaults to a space. If `end` was not provided, it defaults to a newline. If `flush` was not provided, it defaults to `False`.

Potential edge cases:
- If `args` is empty, no elements will be written.
- If `sep` is not provided, it will default to a space.
- If `end` is not provided, it will default to a newline.
- If `flush` is not provided, it will default to `False`.

Missing functionality: The function does not handle cases where `args` contains non-integer values, although the provided code only expects integers. Additionally, the function does not validate that `sep` is indeed a byte string if provided.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function `func_2()` are described in the context provided. The function does not take any parameters and returns an integer obtained from user input. However, based on the problem description, the integer input should represent the number of number tiles in the bag, which implies it should be an integer within the range 1 ≤ n ≤ 200,000.
def func_2():
    return int(input())
    #The program returns an integer input by the user, which represents the number of number tiles in the bag and is within the range 1 ≤ n ≤ 200,000
#Overall this is what the function does:The function `func_2()` accepts no parameters and prompts the user to input an integer representing the number of number tiles in the bag. The function ensures that the input is within the range 1 ≤ n ≤ 200,000. If the user inputs a valid integer within this range, the function returns this integer. If the user inputs an invalid value (i.e., outside the specified range or non-integer), the function will continue to prompt the user until a valid integer is entered. The final state of the program after the function concludes is that it has returned an integer between 1 and 200,000 inclusive, which represents the number of number tiles in the bag.

#Function 3:
#State of the program right berfore the function call: The variable n is an integer representing the number of number tiles in the bag, and the following line contains n space-separated integers where each integer is either 1 or 2.
def func_3():
    return str(input())
    #The program returns a string containing n space-separated integers where each integer is either 1 or 2
#Overall this is what the function does:The function `func_3` reads a line of input from the standard input, which should contain an integer `n` followed by `n` space-separated integers, each being either 1 or 2. It then returns a string containing these `n` space-separated integers. There are no additional operations performed by the function other than reading the input and returning it. Potential edge cases include the input not conforming to the expected format (e.g., missing integers or non-integer values), in which case the function would still return whatever input is provided without validation.

#Function 4:
#State of the program right berfore the function call: None of the variables in the function `func_4` are defined in its signature, thus no specific precondition can be extracted regarding the input variables. However, the function reads input from stdin which consists of a single line containing an integer n followed by n space-separated integers where each integer is either 1 or 2.
def func_4():
    return map(int, input().strip().split(' '))
    #The program returns a map object that converts each of the n space-separated integers (either 1 or 2) from the input into an integer
#Overall this is what the function does:The function `func_4` reads a single line of input from stdin, expecting an integer `n` followed by `n` space-separated integers (either 1 or 2). It then converts these integers into an integer type using the `map` function and returns a map object. Potential edge cases include invalid input such as non-integer values or a mix of 1s and 2s. If the input does not follow the expected format, the function will still attempt to convert the input but may produce unexpected results or errors.

#Function 5:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the following line of input contains n integers where each integer is either 1 or 2.
def func_5():
    return list(func_4())
    #The program returns a list generated by func_4(), which processes a list of integers (each being 1 or 2) and returns a list based on the input integers
#Overall this is what the function does:The function `func_5` takes no parameters and returns a list processed by `func_4()`. The input to `func_4()` is a list of integers, each being either 1 or 2, with the constraint that the length of the list is between 1 and 200,000. `func_4()` processes this list according to its own rules, and `func_5` returns the resulting list. Since the annotations mention that the function returns a list generated by `func_4()`, and considering the constraints on the input, the final state of the program after `func_5` concludes is that it returns a list of integers processed by `func_4()`. There are no explicit edge cases mentioned in the annotations or code provided, but typically, such functions might handle edge cases like an empty input list or invalid inputs, although these are not specified here.

#Function 6:
#State of the program right berfore the function call: item is a tuple or list consisting of at least one element, where the first element is of a type that can be compared and sorted (e.g., integer or string).
def func_6(item):
    return item[0]
    #The program returns the first element of the tuple or list 'item', which is of a type that can be compared and sorted
#Overall this is what the function does:The function `func_6` accepts a single parameter `item`, which must be either a tuple or a list containing at least one element. The function returns the first element of `item`. The first element is assumed to be of a type that can be compared and sorted. This function does not modify the input `item` and only accesses its first element. If `item` is empty or not a tuple or list, the function does not handle these cases and will raise an `IndexError` or a `TypeError` respectively.

#Function 7:
#State of the program right berfore the function call: l is a list of integers where each integer is either 1 or 2.
def func_7(l):
    return sorted(l, key=getKey)
    #The program returns a list of integers from 'l', sorted in ascending order based on the values returned by the 'getKey' function for each element in 'l'
#Overall this is what the function does:The function `func_7` accepts a list `l` containing integers that are either 1 or 2. It returns a new list that is a sorted version of `l`, with elements ordered based on the return values of the `getKey` function applied to each element. If the `getKey` function is not defined or does not handle all possible inputs (e.g., non-integer values), the behavior of sorting is undefined. Potential edge cases include lists that are already sorted, empty lists, and lists containing only one element. Additionally, if the `getKey` function does not provide distinct keys for the integers 1 and 2, the relative order of these elements might not change during the sorting process.

#Function 8:
#State of the program right berfore the function call: n and m are positive integers representing dimensions of a 2D list, and num is an integer either 1 or 2.
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns, where each element in the list is equal to 'num', which is either 1 or 2
#Overall this is what the function does:The function `func_8` accepts three parameters: `n`, `m`, and `num`. `n` and `m` are positive integers representing the dimensions of a 2D list, and `num` is an integer either 1 or 2. After executing the function, it returns a 2D list with `n` rows and `m` columns, where each element in the list is equal to `num`. There are no edge cases or missing functionalities in the provided code.

#Function 9:
#State of the program right berfore the function call: x is a non-negative integer.
def func_9(x):
    return x and not x & x - 1
    #The program returns True if x is 0, otherwise it returns False
#Overall this is what the function does:The function `func_9` accepts a non-negative integer `x` and returns `True` if `x` is 0, otherwise it returns `False`. The function achieves this by evaluating the expression `return x and not x & x - 1`. This expression simplifies to checking if `x` is 0 because:
- If `x` is 0, both parts of the expression evaluate to `False`, resulting in `True`.
- If `x` is any positive integer, `x & (x - 1)` will be `0` (since `(x - 1)` will have one less bit set than `x`), making the entire expression evaluate to `False`.
Thus, the function correctly identifies whether `x` is 0 or not. There are no potential edge cases beyond the general cases where `x` can be 0 or any positive integer. The function behaves as intended without any missing logic.

#Function 10:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 2^{200000} (since the number of tiles is at most 200,000, n can be represented within this range).
def func_10(n):
    return bin(n).replace('0b', '')
    #The program returns a binary string representation of the integer n without the '0b' prefix
#Overall this is what the function does:The function `func_10` accepts an integer `n` where \(1 \leq n \leq 2^{200000}\). It converts `n` into its binary representation and returns a string without the '0b' prefix. The function ensures that the input `n` is a valid non-negative integer within the specified range. The returned string is the binary representation of `n`. If `n` is 0, the function correctly returns the empty string `''`.

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and the binary representation of n consists only of the digits 1 and 2.
def func_11(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers, where each integer is either 1 or 2, representing the binary digits of the integer n
#Overall this is what the function does:The function `func_11` accepts an integer `n` within the range \(1 \leq n \leq 200,000\) and returns a list of integers where each integer is either 1 or 2, representing the binary digits of `n`. The function converts the integer `n` to its string representation, then iterates through each character in the string, converting each character back to an integer (which will be either '1' or '2'), and finally returns a list of these integers. This process handles all integers within the specified range, including the smallest (1) and largest (200,000) values, and correctly identifies each binary digit of `n` as either 1 or 2, as per the problem statement.

#Function 12:
#State of the program right berfore the function call: x is an integer, y is a non-negative integer, and p is a positive integer.
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p1
        
    #State of the program after the loop has been executed: 'x' is \(x^{2^k} \mod p1\) where \(k\) is the number of times the loop has executed, 'y' is 0, 'res' is the product of the initial value of 'res' with \(x^{2^j} \mod p1\) for every odd 'y' in the range from the original value of 'y' to 1, all taken modulo 'p'.
    return res
    #The program returns res which is the product of the initial value of res with x^(2^j) mod p1 for every odd y in the range from the original value of y to 1, all taken modulo p
#Overall this is what the function does:The function `func_12` accepts three parameters: `x`, `y`, and `p`, where `x` is an integer, `y` is a non-negative integer, and `p` is a positive integer. It returns `res`, which is the result of repeatedly squaring `x` and multiplying it to `res` whenever `y` is odd, all taken modulo `p`. Specifically, the function computes \( res = 1 \times x^{2^j} \mod p \) for each odd `y` in the range from the original value of `y` down to 1, with the final result also taken modulo `p`. 

The function handles the following scenarios:
- If `y` is 0, the function simply returns 1 (the initial value of `res`).
- If `y` is even, the function processes the next bit of `y` without changing `res`.
- If `y` is odd, the function updates `res` by multiplying it with \( x^{2^k} \mod p \), where \( k \) is the number of times the loop has executed.

There are no explicit edge cases mentioned in the annotations or code that need special handling beyond the standard behavior described above.

#Function 13:
#State of the program right berfore the function call: x and y are integers such that \(x \geq 0\) and \(y > 0\).
def func_13(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the last non-zero remainder obtained from successive divisions of the original value of `x` by the original value of `y`, `y` is 0.
    return x
    #The program returns x, which is the last non-zero remainder obtained from successive divisions of the original value of x by the original value of y
#Overall this is what the function does:The function `func_13` accepts two integers `x` and `y` (where \(x \geq 0\) and \(y > 0\)). It uses the Euclidean algorithm to find the greatest common divisor (GCD) of `x` and `y`. The function returns the GCD of the original values of `x` and `y`.

#Function 14:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 200,000, and l is a list of integers where each integer is either 1 or 2.
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    """if two==one:
        for i in range(n):
            if i%2==0:
                s.append(2)
            else:
                s.append(1)
        print(*s)
        exit()
        
    
    for i in range(n):
        if a[i]==1:
            if one !=0:
                s.append(1)
                one-=1
            else:
                s.append(2)
                two-=1
        else:
            if two!=0:
                s.append(2)
                two-=1
            else:
                s.append(1)
                one-=1
    print(*s)   """
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
        
    #State of the program after the  for loop has been executed: Output State:
    func_1(*s)
#Overall this is what the function does:The function `func_14` accepts no explicit parameters but relies on the values returned by `func_2()` and `func_5()`. It processes these values to generate a list `s` of length `n` (where `1 ≤ n ≤ 200,000`) based on counts of 1s and 2s in the list `l`. The list `s` is constructed by alternating between 1s and 2s according to the counts of 1s and 2s available. If the counts of 1s and 2s are equal, the list `s` is generated by alternating starting with 2s. If the counts are unequal, the list `s` is constructed to use up the available 1s before 2s or vice versa. The function then calls `func_1(s)` with the generated list `s`.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.