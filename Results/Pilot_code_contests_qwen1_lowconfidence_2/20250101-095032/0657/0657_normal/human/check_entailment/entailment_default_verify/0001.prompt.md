
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.

However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.

Can you win the prize? Hurry up, the bags are waiting!

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i ∈ \{1, 2\}) — the values written on the tiles.

Output

Output a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.

Examples

Input


5
1 2 1 2 1


Output


1 1 1 2 2


Input


9
1 1 2 1 1 1 2 1 1


Output


1 1 1 2 1 1 1 2 1

Note

The first solution produces the prefix sums 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, \mathbf{\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \mathbf{\color{blue}{2}}, \mathbf{\color{blue}{3}}, \mathbf{\color{blue}{5}}, 6, \mathbf{\color{blue}{7}}, 8, 10, \mathbf{\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.
Program:
```
from __future__ import division, print_function
import itertools,os,sys
import os
import sys
from io import BytesIO, IOBase
#Function 1:
def func_1(*args, **kwargs):
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return str(input())

#Function 4:
def func_4():
    return map(int, input().strip().split(' '))

#Function 5:
def func_5():
    return list(func_4())

#Function 6:
def func_6(item):
    return item[0]

#Function 7:
def func_7(l):
    return sorted(l, key=getKey)

#Function 8:
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 9:
def func_9(x):
    return x and (not x & x - 1)

#Function 10:
def func_10(n):
    return bin(n).replace('0b', '')

#Function 11:
def func_11(n):
    return [int(i) for i in str(n)]

#Function 12:
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res

#Function 13:
def func_13(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 14:
def func_14():
    n = func_2()
    l = func_5()
    a = [1, 1, 1, 2] * 50000
    s = []
    one = l.count(1)
    two = l.count(2)
    'if two==one:\n        for i in range(n):\n            if i%2==0:\n                s.append(2)\n            else:\n                s.append(1)\n        print(*s)\n        exit()\n        \n    \n    for i in range(n):\n        if a[i]==1:\n            if one !=0:\n                s.append(1)\n                one-=1\n            else:\n                s.append(2)\n                two-=1\n        else:\n            if two!=0:\n                s.append(2)\n                two-=1\n            else:\n                s.append(1)\n                one-=1\n    print(*s)   '
    s = [2]
    p = [2]
    two -= 1
    for i in range(1, n):
        if p[-1] % 2 == 0:
            if one != 0:
                s.append(1)
                p.append(p[-1] + 1)
                one -= 1
            else:
                s.append(2)
                p.append(p[-1] + 2)
                two -= 1
        elif two != 0:
            s.append(2)
            p.append(p[-1] + 2)
            two -= 1
        else:
            s.append(1)
            p.append(p[-1] + 1)
            one -= 1
    func_1(*s)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not always maximize the number of prefix sums that are prime numbers. Specifically, consider the following input:

**Input:**
```
3
2 1 2
```

The expected output would be a permutation that maximizes the number of prime prefix sums. One such permutation could be `1 2 1`, which gives the prefix sums `1, 3, 4`. Here, the prefix sums `1` and `3` are prime, achieving 2 prime prefix sums.

However, the current implementation always appends `2` to the beginning of the list `s` before processing the rest of the input. This means the program might not always produce the optimal permutation.

In the given example:
- The program starts with `s = [2]`.
- It then processes the remaining elements: `1, 2, 1`.

The sequence generated is `[2, 1, 2, 1]`, which results in the prefix sums `2, 3, 5, 6`. Here, only `2` and `3` are prime, achieving only 2 prime prefix sums. 

However, a better permutation would be `[1, 2, 1]`, which achieves 2 prime prefix sums (`1, 3`).

Since the program does not always generate the optimal permutation, it fails to meet the requirements of the problem description for some cases. Therefore, the program is incorrect.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 14 : The function `func_14` accepts no explicit parameters but relies on the values returned by `func_2()` and `func_5()`. It processes these values to generate a list `s` of length `n` (where `1 ≤ n ≤ 200,000`) based on counts of 1s and 2s in the list `l`. The list `s` is constructed by alternating between 1s and 2s according to the counts of 1s and 2s available. If the counts of 1s and 2s are equal, the list `s` is generated by alternating starting with 2s. If the counts are unequal, the list `s` is constructed to use up the available 1s before 2s or vice versa. The function then calls `func_1(s)` with the generated list `s`.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
