
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (xi, yi).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |xi - xj| + |yi - yj|. Daniel, as an ordinary person, calculates the distance using the formula <image>.

The success of the operation relies on the number of pairs (i, j) (1 ≤ i < j ≤ n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.

Input

The first line of the input contains the single integer n (1 ≤ n ≤ 200 000) — the number of watchmen.

Each of the following n lines contains two integers xi and yi (|xi|, |yi| ≤ 109).

Some positions may coincide.

Output

Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.

Examples

Input

3
1 1
7 5
1 5


Output

2


Input

6
0 0
0 1
0 2
-1 1
0 1
1 1


Output

11

Note

In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <image> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: The input is a list of points where each point is represented as a tuple (xi, yi) and consists of integers. The length of the list is n (1 ≤ n ≤ 200,000) and for each point, the coordinates xi and yi satisfy |xi|, |yi| ≤ 10^9.
def func():
    n = int(raw_input())
    rows = {}
    cols = {}
    posi = {}
    for i in range(n):
        x, y = [int(t) for t in raw_input().split(' ')]
        
        if x in rows:
            rows[x] += 1
        else:
            rows[x] = 1
        
        if y in cols:
            cols[y] += 1
        else:
            cols[y] = 1
        
        if (x, y) in posi:
            posi[x, y] += 1
        else:
            posi[x, y] = 1
        
    #State of the program after the  for loop has been executed: `n` must be greater than 0; `cols` is a dictionary where each key `y` is associated with a value that is the count of occurrences of `y` across all iterations of the loop; `rows` is a dictionary where each key `x` is associated with a value that is the count of occurrences of `x` across all iterations of the loop; `posi` is a dictionary where each key `(x, y)` is associated with a value that is the count of occurrences of the pair `(x, y)` across all iterations of the loop; `x` and `y` are integers from the input; `i` is equal to `n`.
    ans = 0
    for t in rows.keys():
        ans = ans + (rows[t] - 1) * rows[t] / 2
        
    #State of the program after the  for loop has been executed: Output State: `ans` is the sum of \((rows[t] - 1) * rows[t] / 2\) for all keys `t` in `rows`, `cols` is a dictionary where each key `y` is associated with a value that is the count of occurrences of `y` across all iterations of the loop, `rows` is a dictionary where each key `x` is associated with a value that is the count of occurrences of `x` across all iterations of the loop, `posi` is a dictionary where each key `(x, y)` is associated with a value that is the count of occurrences of the pair `(x, y)` across all iterations of the loop, `i` is 0.
    for t in cols.keys():
        ans = ans + (cols[t] - 1) * cols[t] / 2
        
    #State of the program after the  for loop has been executed: `ans` is the sum of \((cols[t] - 1) * cols[t] / 2\) for all keys `t` in `cols`, `cols` is an empty dictionary, `rows` is a dictionary where each key `x` is associated with a value that is the count of occurrences of `x` across all iterations of the loop, `posi` is a dictionary where each key `(x, y)` is associated with a value that is the count of occurrences of the pair `(x, y)` across all iterations of the loop, `i` is the number of times the loop has executed.
    for t in posi.keys():
        if posi[t] > 1:
            ans -= (posi[t] - 1) * posi[t] / 2
        
    #State of the program after the  for loop has been executed: `ans` is the sum of \(-(posi[t] - 1) * posi[t] / 2)\ for all keys `t` in `posi` where `posi[t] > 1`, `i` is the number of times the loop has executed, `cols` is an empty dictionary, `rows` is an empty dictionary, and `posi` is a dictionary containing pairs `(x, y)` with counts of occurrences of such pairs.
    print(ans)
#Overall this is what the function does:The function accepts a list of points where each point is a tuple (xi, yi) with integer coordinates. It calculates and returns the number of unique pairs of points that share either the same x-coordinate or the same y-coordinate, without double-counting pairs. Specifically, it first counts the occurrences of each x-coordinate and y-coordinate. Then, it calculates the number of unique pairs for each x-coordinate (using the combination formula \( \frac{n(n-1)}{2} \) where n is the count of occurrences) and adds these to the total count. It then does the same for each y-coordinate. Finally, it subtracts the overcounted pairs (pairs that have both the same x-coordinate and the same y-coordinate) from the total count. The function prints and returns the resulting count. Potential edge cases include when the input list is empty, which would result in no pairs being counted. Additionally, the function assumes that the input list contains valid tuples with integer coordinates and that the coordinates are within the specified bounds.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
