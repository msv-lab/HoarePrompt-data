#State of the program right berfore the function call: a and b are positive integers.
def func_1(a, b):
    return a if b == 0 else func_1(b, a % b)
    #`The program returns the value of 'a' if 'b' is 0, otherwise it returns the result of the function call 'func_1(b, a % b)' where 'a % b' is the remainder when 'a' is divided by 'b'
#Overall this is what the function does:The function `func_1` accepts two positive integers `a` and `b`. If `b` is 0, it returns the value of `a`. Otherwise, it recursively calls itself with `b` and the remainder of `a` divided by `b` (i.e., `a % b`). This process continues until `b` becomes 0, at which point it returns the value of `a`. This function effectively computes the greatest common divisor (GCD) of `a` and `b` using the Euclidean algorithm.

#State of the program right berfore the function call: n is an integer representing the number of vertices in the tree (1 ≤ n ≤ 2·10⁵). a is a list of integers where a[i-1] represents the number written on vertex i (1 ≤ i ≤ n, 1 ≤ a[i-1] ≤ 2·10⁵). parent is a list of integers where parent[i-1] represents the parent of vertex i in the tree (1 ≤ i ≤ n, parent[0] = -1). gcdinfo is a list of GCDInfo objects, where gcdinfo[i-1] corresponds to vertex i, and visited is a boolean list indicating whether vertex i has been visited (visited[i-1] is initially False for all i). graph is a list of lists where graph[i] contains the neighbors of vertex i.
def func_2(n, parent):
    if visited[n] :
        return
        #None, because there is no return statement in the provided code snippet
    #State of the program after the if block has been executed: `n` is an integer representing the number of vertices in the tree (1 ≤ n ≤ 2·10⁵), `a` is a list of integers where `a[i-1]` represents the number written on vertex `i` (1 ≤ i ≤ n, 1 ≤ `a[i-1]` ≤ 2·10⁵), `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree (1 ≤ i ≤ n, `parent[0] = -1`), `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, and `visited` is a boolean list indicating whether vertex `i` has been visited (all elements in `visited` are initially `False`), `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`. Not all vertices have been visited (`visited[n]` is `False`).
    visited[n] = True
    if (parent != -1) :
        newgcd = func_1(gcdinfo[parent].gcd, a[n])
        gcdinfo[n].gcd = newgcd
        if (newgcd < gcdinfo[parent].gcd) :
            gcdinfo[n].tor1 = a[n]
            gcdinfo[n].ifr1 = gcdinfo[parent].gcd
            if (gcdinfo[parent].ifr1 == 0) :
                gcdinfo[n].tor2 = gcdinfo[parent].gcd
                gcdinfo[n].ifr2 = a[n]
            #State of the program after the if block has been executed: *`newgcd` is now `gcdinfo[parent].gcd`, `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`, `gcdinfo[n].tor1` is now `a[n]`, `gcdinfo[n].ifr1` is now `newgcd`, `gcdinfo[n].tor2` is equal to `newgcd`, `gcdinfo[n].ifr2` is equal to `a[n]`, and `gcdinfo[parent].ifr1` is equal to `0` if the condition `gcdinfo[parent].ifr1 == 0` is met, otherwise, `gcdinfo[parent].ifr1` remains unchanged.
        else :
            if gcdinfo[parent].ifr1 :
                newgcd1 = func_1(gcdinfo[parent].ifr1, a[n])
            else :
                newgcd1 = 1
            #State of the program after the if-else block has been executed: *`newgcd1` is `result_of_func_1` if `gcdinfo[parent].ifr1` is true. Otherwise, `newgcd1` is 1. `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`, and `gcdinfo[n].gcd` is not less than `gcdinfo[parent].gcd` remains unchanged.
            if gcdinfo[parent].ifr2 :
                newgcd2 = func_1(gcdinfo[parent].ifr2, a[n])
            else :
                newgcd2 = 1
            #State of the program after the if-else block has been executed: *`newgcd1` is `func_1(True, a[n])` if `gcdinfo[parent].ifr2` is true; otherwise, `newgcd1` is `result_of_func_1` if `gcdinfo[parent].ifr1` is true, otherwise `newgcd1` is 1. `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`, and `gcdinfo[n].gcd` remains unchanged.
            if (newgcd1 > newgcd2) :
                gcdinfo[n].tor1 = gcdinfo[parent].tor1
                gcdinfo[n].ifr1 = gcdinfo[parent].ifr1
            else :
                if (newgcd2 > newgcd1) :
                    gcdinfo[n].tor1 = gcdinfo[parent].tor2
                    gcdinfo[n].ifr1 = gcdinfo[parent].ifr2
                #State of the program after the if block has been executed: *`newgcd1` is `func_1(True, a[n])` if `gcdinfo[parent].ifr2` is true; otherwise, `newgcd1` is `result_of_func_1` if `gcdinfo[parent].ifr1` is true, otherwise `newgcd1` is 1. `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`, `newgcd2` is less than or equal to `newgcd1`, and `gcdinfo[n].gcd` remains unchanged. If `newgcd2 > newgcd1`, then `gcdinfo[n].tor1` is now equal to `gcdinfo[parent].tor2` and `gcdinfo[n].ifr1` is now equal to `gcdinfo[parent].ifr2`.
            #State of the program after the if-else block has been executed: *`newgcd1` is `func_1(True, a[n])` if `gcdinfo[parent].ifr2` is true; otherwise, `newgcd1` is `result_of_func_1` if `gcdinfo[parent].ifr1` is true, otherwise `newgcd1` is 1. `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`, `gcdinfo[n].gcd` remains unchanged. If `newgcd1 > newgcd2`, then `gcdinfo[n].ifr1` is now equal to `gcdinfo[parent].ifr1`. Otherwise, `gcdinfo[n].tor1` is now equal to `gcdinfo[parent].tor2` and `gcdinfo[n].ifr1` is now equal to `gcdinfo[parent].ifr2`.
        #State of the program after the if-else block has been executed: *`newgcd` is now `func_1(gcdinfo[parent].gcd, a[n])`. `n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`, and `gcdinfo[n].gcd` is updated as follows:
        #- If `newgcd < gcdinfo[parent].gcd`, then `gcdinfo[n].tor1` is set to `a[n]`, `gcdinfo[n].ifr1` is set to `newgcd`, `gcdinfo[n].tor2` is set to `newgcd`, and `gcdinfo[n].ifr2` is set to `a[n]`. Additionally, if `gcdinfo[parent].ifr1 == 0`, then `gcdinfo[parent].ifr1` is set to `0`; otherwise, it remains unchanged.
        #- If `newgcd >= gcdinfo[parent].gcd`, then `newgcd1` is calculated as `func_1(True, a[n])` if `gcdinfo[parent].ifr2` is true, otherwise `newgcd1` is `result_of_func_1` if `gcdinfo[parent].ifr1` is true, otherwise `newgcd1` is 1. `gcdinfo[n].gcd` remains unchanged. If `newgcd1 > newgcd2`, then `gcdinfo[n].ifr1` is set to `gcdinfo[parent].ifr1`. Otherwise, `gcdinfo[n].tor1` is set to `gcdinfo[parent].tor2` and `gcdinfo[n].ifr1` is set to `gcdinfo[parent].ifr2`.
    #State of the program after the if block has been executed: *`n` is an integer representing the number of vertices in the tree, `a` is a list of integers where `a[i-1]` represents the number written on vertex `i`, `parent` is a list of integers where `parent[i-1]` represents the parent of vertex `i` in the tree, `gcdinfo` is a list of GCDInfo objects, where `gcdinfo[i-1]` corresponds to vertex `i`, `visited` is a boolean list indicating whether vertex `i` has been visited, `graph` is a list of lists where `graph[i]` contains the neighbors of vertex `i`. If `parent[n] != -1`, `newgcd` is now `func_1(gcdinfo[parent[n]].gcd, a[n])`. 
    #
    #- If `newgcd < gcdinfo[parent[n]].gcd`, then `gcdinfo[n].tor1` is set to `a[n]`, `gcdinfo[n].ifr1` is set to `newgcd`, `gcdinfo[n].tor2` is set to `newgcd`, and `gcdinfo[n].ifr2` is set to `a[n]`. Additionally, if `gcdinfo[parent[n]].ifr1 == 0`, then `gcdinfo[parent[n]].ifr1` is set to `0`; otherwise, it remains unchanged.
    #- If `newgcd >= gcdinfo[parent[n]].gcd`, then `newgcd1` is calculated as `func_1(True, a[n])` if `gcdinfo[parent[n]].ifr2` is true, otherwise `newgcd1` is `result_of_func_1` if `gcdinfo[parent[n]].ifr1` is true, otherwise `newgcd1` is 1. `gcdinfo[n].gcd` remains unchanged. If `newgcd1 > newgcd2`, then `gcdinfo[n].ifr1` is set to `gcdinfo[parent[n]].ifr1`. Otherwise, `gcdinfo[n].tor1` is set to `gcdinfo[parent[n]].tor2` and `gcdinfo[n].ifr1` is set to `gcdinfo[parent[n]].ifr2`.
    for neigh in graph[n]:
        func_2(neigh, n)
        
    #State of the program after the  for loop has been executed: Output State:
#Overall this is what the function does:The function `func_2` processes a tree structure represented by `n` (number of vertices), `parent` (parent pointers), `gcdinfo` (GCD information for each vertex), `a` (values associated with each vertex), and `graph` (adjacency list). It traverses the tree using depth-first search (DFS) and updates the `gcdinfo` list for each vertex based on the values and GCD calculations involving its children and parent. Specifically, for each vertex `n`, it checks if it has been visited, updates its visited status, and calculates the GCD of its value with the GCD of its parent. Depending on the result, it updates the `gcdinfo` list with relevant values. It also recursively processes each neighbor of the current vertex.

