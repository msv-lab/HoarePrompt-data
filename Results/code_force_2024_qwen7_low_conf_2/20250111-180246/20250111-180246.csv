Task ID,Dataset,model_created,model_run,description,Code,run_number,original correctness,summary fsl,naive correctness fsl,vanilla,simple tree,complex tree,summary,simple verify fsl,complex verify fsl,summary verify fsl,simple verify,complex verify,summary verify
325,codeforces2024,human,qwen2.5-7b-instruct,"This is the easy version of the problem. The only difference between the two
versions is the constraint on t and n . You can make hacks only if both
versions of the problem are solved.

For a binary^\dagger pattern p and a binary string q , both of length m , q is
called p -good if for every i (1 \leq i \leq m ), there exist indices l and r
such that:

  * 1 \leq l \leq i \leq r \leq m , and 
  * p_i is a mode^\ddagger of the string q_l q_{l+1} \ldots q_{r} . 

For a pattern p , let f(p) be the minimum possible number of \mathtt{1} s in a
p -good binary string (of the same length as the pattern).

You are given a binary string s of size n . Find

In other words, you need to sum the values of f over all \frac{n(n+1)}{2}
substrings of s .

^\dagger A binary pattern is a string that only consists of characters
\mathtt{0} and \mathtt{1} .

^\ddagger Character c is a mode of string t of length m if the number of
occurrences of c in t is at least \lceil \frac{m}{2} \rceil . For example,
\mathtt{0} is a mode of \mathtt{010} , \mathtt{1} is not a mode of
\mathtt{010} , and both \mathtt{0} and \mathtt{1} are modes of \mathtt{011010}
.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the length of the binary string s .

The second line of each test case contains a binary string s of length n
consisting of only characters \mathtt{0} and \mathtt{1} .

It is guaranteed that the sum of n^2 over all test cases does not exceed 10^4
.

Output

For each test case, output the sum of values of f over all substrings of s .

Example

Input

    4
    
    1
    
    1
    
    2
    
    10
    
    5
    
    00000
    
    20
    
    11110110000000111111

Output

    1
    2
    0
    346
    
Note

In the first test case, the only \mathtt{1} -good string is \mathtt{1} . Thus,
f(\mathtt{1})=1 .

In the second test case, f(\mathtt{10})=1 because \mathtt{01} is \mathtt{10}
-good, and \mathtt{00} is not \mathtt{10} -good. Thus, the answer is
f(\mathtt{1})+f(\mathtt{10})+f(\mathtt{0}) = 1 + 1 + 0 = 2 .

In the third test case, f equals to 0 for all 1 \leq i \leq j \leq 5 . Thus,
the answer is 0 .","import sys
from decimal import Decimal, getcontext

# Set the precision for Decimal operations
getcontext().prec = 15

def solve():
    # Read the number of test cases
    num_cases = int(input().strip())
    
    # Process each test case
    for _ in range(num_cases):
        # Read the length of the binary string
        length = int(input().strip())
        # Read the binary string
        input_string = input().strip()
        
        # Initialize a DP array with extra space to avoid index errors
        dp = [0] * (length + 10)
        # Initialize the result for the current test case
        result = 0
        
        # Iterate over the string from the end to the beginning
        for i in range(length - 1, -1, -1):
            if input_string[i] == '1':
                # If the character is '1', calculate its contribution
                dp[i] = length - i + dp[i + 3]
            elif input_string[i] == '0':
                # If the character is '0', carry forward the previous DP value
                dp[i] = dp[i + 1]
        
        # Sum up all values in the DP array to get the result
        for i in dp:
            result += i
        
        # Print the result for the current test case
        print(Decimal(result))

if __name__ == ""__main__"":
    solve()",2,True,False,False,False,False,True,True,False,False,False,False,True,False
326,codeforces2024,human,qwen2.5-7b-instruct,"There are 2n positive integers written on a whiteboard. Being bored, you
decided to play a one-player game with the numbers on the whiteboard.

You start with a score of 0 . You will increase your score by performing the
following move exactly n times:

  * Choose two integers x and y that are written on the whiteboard. 
  * Add \min(x,y) to your score. 
  * Erase x and y from the whiteboard. 

Note that after performing the move n times, there will be no more integers
written on the whiteboard.

Find the maximum final score you can achieve if you optimally perform the n
moves.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \leq n \leq 50
) — the number of integers written on the whiteboard is 2n .

The second line of each test case contains 2n integers a_1,a_2,\ldots,a_{2n}
(1 \leq a_i \leq 10^7 ) — the numbers written on the whiteboard.

Output

For each test case, output the maximum final score that you can achieve.

Example

Input

    3
    
    1
    
    2 3
    
    2
    
    1 1 2 1
    
    3
    
    1 1 1 1 1 1

Output

    2
    2
    3
    
Note

In the first test case, you can only make one move. You select x=2 and y=3 ,
and your score will be \min(x,y)=2 .

In the second test case, the following is a sequence of moves that achieves a
final score of 2 :

  * In the first move, select x=1 and y=1 . Then, add \min(x,y)=1 to the score. After erasing x and y , the integers left on the whiteboard are 1 and 2 . 
  * In the second move, select x=1 and y=2 . Then, add \min(x,y)=1 to the score. After removing x and y , no more integers will be left on the whiteboard. 

It can be proved that it is not possible to get a score greater than 2 .

In the third test case, you will perform the move thrice, adding 1 to the
score each time.","for _ in range(int(input())):
	n = int(input())
	l = sorted(list(map(int, input().split())))
	score = 0
	for i in range(0,2*n,2):
		score+=l[i]

	print(score)",2,True,False,True,True,True,True,True,False,True,True,False,True,True
155,codeforces2024,human,qwen2.5-7b-instruct,"[Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .","from bisect import bisect_left

# Function to read input values
def read_input():
    return map(int, input().split())

# Function to calculate the modular inverse using Fermat's Little Theorem
def mod_inverse(x, mod):
    return pow(x, mod - 2, mod)

# Read the number of test cases
t, = read_input()

# Iterate over each test case
for _ in range(t):
    # Read the number of balls and baskets
    n, m = read_input()
    
    # Read the initial positions of the balls
    a = list(read_input())
    
    # Sort the positions of the balls
    a.sort()
    
    # Calculate the distances between consecutive balls
    distances = [a[i + 1] - a[i] for i in range(n - 1)]
    
    # Append the distance from the last ball to the first ball in the circle
    distances.append(m - a[-1] + a[0])
    
    # Sort the distances
    distances.sort()
    
    # Initialize the expected time
    expected_time = 0
    
    # Calculate the expected time using the given formula
    for i in range(n):
        expected_time += (distances[i] * (i + 1) * (n - i)) % 1000000007
    
    # Multiply by 2 and adjust for modular arithmetic
    expected_time = (expected_time * 2) % 1000000007
    
    # Calculate the modular inverse of the total number of combinations
    inverse_combinations = mod_inverse(n * (n + 1) // 2, 1000000007)
    
    # Final result is the expected time multiplied by the inverse of combinations
    result = (expected_time * inverse_combinations) % 1000000007
    
    # Output the result for the current test case
    print(result)",2,False,False,False,False,False,True,True,True,False,False,False,False,True
117,codeforces2024,human,qwen2.5-7b-instruct,"You have a horizontal strip of n cells. Each cell is either white or black.

You can choose a continuous segment of cells once and paint them all white.
After this action, all the black cells in this segment will become white, and
the white ones will remain white.

What is the minimum length of the segment that needs to be painted white in
order for all n cells to become white?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 10 )
— the length of the strip.

The second line of each test case contains a string s , consisting of n
characters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white
cell, and 'B' — a black one. It is guaranteed that at least one cell of the
given strip is black.

Output

For each test case, output a single number — the minimum length of a
continuous segment of cells that needs to be painted white in order for the
entire strip to become white.

Example

Input

    8
    
    6
    
    WBBWBW
    
    1
    
    B
    
    2
    
    WB
    
    3
    
    BBW
    
    4
    
    BWWB
    
    6
    
    BWBWWB
    
    6
    
    WWBBWB
    
    9
    
    WBWBWWWBW

Output

    4
    1
    1
    2
    4
    6
    4
    7
    
Note

In the first test case of the example for the strip ""WBBWBW"", the minimum
length of the segment to be repainted white is 4 . It is necessary to repaint
to white the segment from the 2 -nd to the 5 -th cell (the cells are numbered
from 1 from left to right).","def min_segment_length(n, s):
    first_black = -1
    last_black = -1
    for i in range(n):
        if s[i] == 'B':
            if first_black == -1:
                first_black = i
            last_black = i
    return last_black - first_black + 1
 
def main():
    t = int(input())
    results = []
    for _ in range(t):
        n = int(input())
        s = input().strip()
        results.append(min_segment_length(n, s))
    for result in results:
        print(result)
 
if __name__ == ""__main__"":
    main()",2,True,True,True,True,True,True,True,True,False,True,False,True,False
227,codeforces2024,human,qwen2.5-7b-instruct,"You are given two integers x and y .

Output two integers: the minimum of x and y , followed by the maximum of x and
y .

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The only line of each test case contains two space-separated integers x and y
(0 \leq x, y \leq 9 ).

Output

For each test case, output two integers: the minimum of x and y , followed by
the maximum of x and y .

Example

Input

    10
    
    1 9
    
    8 4
    
    1 4
    
    3 4
    
    2 0
    
    2 4
    
    6 9
    
    3 3
    
    0 0
    
    9 9

Output

    1 9
    4 8
    1 4
    3 4
    0 2
    2 4
    6 9
    3 3
    0 0
    9 9","def min(a,b):
    if a<b:
        return (a,b)
    elif a>b:
        return (b,a)
    

t = int(input())

for i in range (t):
    a,b = map(int,input().split())
    print(min(a,b))",2,False,True,False,True,True,True,True,False,True,True,True,True,False
234,codeforces2024,human,qwen2.5-7b-instruct,"Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8","from typing import List

MOD = int(1e9) + 7

def solve(n: int, q: int, l: List[int], r: List[int]) -> int:
    dp = [[0]*(n+1) for _ in range(q+1)]
    dp[0][0] = 1
    cnt = [0]*(n+1)
    
    for i in range(1, q+1):
        for j in range(1, n+1):
            dp[i][j] = dp[i-1][j]
            if j > l[i-1]:
                dp[i][j] -= cnt[j-l[i-1]]
            dp[i][j] += dp[i][j-1]
            dp[i][j] %= MOD
            cnt[j] = (cnt[j-1]+dp[i][j])%MOD
            
    ans = 0
    for j in range(1, n+1):
        if j <= r[-1]:
            ans = (ans+dp[q][j])%MOD
    return ans

# Test cases
print(solve(6, 3, [6, 4, 4], [5, 5, 2])) # Expected output: 30
print(solve(10, 1, [10], [9])) # Expected output: 1814400
print(solve(4, 1, [2], [4])) # Expected output: 8",2,False,False,False,True,False,True,True,False,False,True,True,True,True
27,codeforces2024,human,qwen2.5-7b-instruct,"You have some cards. An integer between 1 and n is written on each card:
specifically, for each i from 1 to n , you have a_i cards which have the
number i written on them.

There is also a shop which contains unlimited cards of each type. You have k
coins, so you can buy k new cards in total, and the cards you buy can contain
any integer between 1 and n .

After buying the new cards, you rearrange all your cards in a line. The score
of a rearrangement is the number of (contiguous) subarrays of length n which
are a permutation of [1, 2, \ldots, n] . What's the maximum score you can get?

Input

Each test contains multiple test cases. The first line contains the number of
test cases t\ (1\le t\le 100) . The description of the test cases follows.

The first line of each test case contains two integers n , k (1\le n \le 2
\cdot 10^5 , 0\le k \le 10^{12} ) — the number of distinct types of cards and
the number of coins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^{12} ) — the number of cards of type i you have at the
beginning.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, output a single line containing an integer: the maximum
score you can get.

Example

Input

    8
    
    1 10
    
    1
    
    2 4
    
    8 4
    
    3 4
    
    6 1 8
    
    3 9
    
    7 6 2
    
    5 3
    
    6 6 7 4 6
    
    9 7
    
    7 6 1 7 6 2 4 3 3
    
    10 10
    
    1 3 1 2 1 9 3 5 7 5
    
    9 8
    
    5 8 7 5 1 3 2 9 8

Output

    11
    15
    15
    22
    28
    32
    28
    36
    
Note

In the first test case, the final (and only) array we can get is [1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1] (including 11 single 1 s), which contains 11 subarrays
consisting of a permutation of [1] .

In the second test case, we can buy 0 cards of type 1 and 4 cards of type 2 ,
and then we rearrange the cards as following: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
1, 2, 1, 2, 1, 2] . There are 8 subarrays equal to [1, 2] and 7 subarrays
equal to [2, 1] , which make a total of 15 subarrays which are a permutation
of [1, 2] . It can also be proved that this is the maximum score we can get.

In the third test case, one of the possible optimal rearrangements is [3, 3,
1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3] .","t = int(input())
outs = []


for tt in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    a.sort()
    min_, min_idx = a[0], 0
    
    for i in range(1, n):
        trg = i*(a[i]-min_)
        if k>=trg:
            k-=trg
            min_ = a[i]
            min_idx = i
        else:
            min_ += k//i
            min_idx = i-1
            k = k%i
            break
        
    if min_idx==n-1 and k>0:
        min_ += k//n
        k = k%n
        
    tot = min_ + (min_-1)*(n-1) + (n-1-min_idx) + k
        
    outs.append(tot)


for out in outs:
    print(out)",2,True,False,False,True,False,True,True,False,False,True,False,True,True
313,codeforces2024,human,qwen2.5-7b-instruct,"n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2","t = int(input()); from collections import deque;
for _ in range (t):
    n, k = map(int, input().split())
    lit = deque(list((map(int, input().split()))));
    lastState = -1; sunk = 0;
    while True:
        if len(lit) == 0 or k <= 0:
            break;
        if lastState == -1:
            lastState = 0;
        else:
            lastState = -1;
        u = lit[lastState];
        if u <= k:
            sunk += 1;
            if lastState == -1:
                lit.pop();
            else:
                lit.popleft();
        k -= u;
    print (sunk);",2,False,False,False,True,True,True,True,True,False,False,False,False,False
202,codeforces2024,human,qwen2.5-7b-instruct,"You have a strip of paper with a binary string s of length n . You can fold
the paper in between any pair of adjacent digits.

A set of folds is considered valid if after the folds, all characters that are
on top of or below each other match. Note that all folds are made at the same
time, so the characters don't have to match in between folds.

For example, these are valid foldings of s = \mathtt{110110110011} and s =
\mathtt{01110} :

![](https://espresso.codeforces.com/a961dc7cc221603a7d5a488247ba5439ce7444da.png)

The length of the folded strip is the length seen from above after all folds
are made. So for the two above examples, after the folds shown above, the
lengths would be 7 and 3 , respectively.

Notice that for the above folding of s = \mathtt{01110} , if we made either of
the two folds on their own, that would not be a valid folding. However,
because we don't check for validity until all folds are made, this folding is
valid.

After performing a set of valid folds, what is the minimum length strip you
can form?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the size of the strip.

The second line of each test case contains a string s of n characters '0' and
'1' — a description of the digits on the strip.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, output a single integer — the minimum possible length of
the strip after a valid folding.

Example

Input

    6
    
    6
    
    101101
    
    1
    
    0
    
    12
    
    110110110011
    
    5
    
    01110
    
    4
    
    1111
    
    2
    
    01

Output

    3
    1
    3
    3
    1
    2
    
Note

For the first example case, one optimal folding is to fold the strip in the
middle, which produces a strip of length 3.

The third and fourth example cases correspond to the images above. Note that
the folding shown above for s = \mathtt{110110110011} is not of minimal
length.","def compute_prefix_function(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j > 0 and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

def minimal_fold_length(s):
    n = len(s)
    pi = compute_prefix_function(s)
    k = n - pi[-1]
    return k

import sys

def main():
    import sys
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    idx = 1
    results = []
    for _ in range(t):
        if idx >= len(data):
            n = 0
            s = ''
        else:
            n = int(data[idx])
            idx += 1
            if idx >= len(data):
                s = ''
            else:
                s = data[idx]
                idx += 1
        if n == 0:
            results.append(0)
            continue
        k = minimal_fold_length(s)
        results.append(k)
    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()",2,False,False,False,True,False,True,True,True,False,False,True,True,False
117,codeforces2024,human,qwen2.5-7b-instruct,"You have a horizontal strip of n cells. Each cell is either white or black.

You can choose a continuous segment of cells once and paint them all white.
After this action, all the black cells in this segment will become white, and
the white ones will remain white.

What is the minimum length of the segment that needs to be painted white in
order for all n cells to become white?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 10 )
— the length of the strip.

The second line of each test case contains a string s , consisting of n
characters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white
cell, and 'B' — a black one. It is guaranteed that at least one cell of the
given strip is black.

Output

For each test case, output a single number — the minimum length of a
continuous segment of cells that needs to be painted white in order for the
entire strip to become white.

Example

Input

    8
    
    6
    
    WBBWBW
    
    1
    
    B
    
    2
    
    WB
    
    3
    
    BBW
    
    4
    
    BWWB
    
    6
    
    BWBWWB
    
    6
    
    WWBBWB
    
    9
    
    WBWBWWWBW

Output

    4
    1
    1
    2
    4
    6
    4
    7
    
Note

In the first test case of the example for the strip ""WBBWBW"", the minimum
length of the segment to be repainted white is 4 . It is necessary to repaint
to white the segment from the 2 -nd to the 5 -th cell (the cells are numbered
from 1 from left to right).","for _ in range(int(input())):
    a=int(input())
    b=input()
    c=str(b[-1::-1])
    if c.count(""B"")>1:
        print(a-c.index(""B"")-b.index(""B""))
    else:
        print(a)",2,False,False,False,False,False,False,False,False,False,False,False,False,False
338,codeforces2024,human,qwen2.5-7b-instruct,"Alice and Bob have bought a ribbon consisting of n parts. Now they want to
paint it.

First, Alice will paint every part of the ribbon into one of m colors. For
each part, she can choose its color arbitrarily.

Then, Bob will choose at most k  parts of the ribbon and repaint them into the
same color (he chooses the affected parts and the color arbitrarily).

Bob would like all parts to have the same color. However, Alice thinks that
this is too dull, so she wants to paint the ribbon in such a way that Bob
cannot make all parts have the same color.

Is it possible to paint the ribbon in such a way?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of one line containing three integers n , m and k (1
\le m, k \le n \le 50 ) — the number of parts, the number of colors and the
number of parts Bob can repaint, respectively.

Output

For each test case, print YES if Alice can paint the ribbon so that Bob cannot
make all parts have the same color. Otherwise, print NO.

You can print every letter in any register. For example, Yes, yes, yEs will
all be recognized as positive answer.

Example

Input

    5
    
    1 1 1
    
    5 1 1
    
    5 2 1
    
    5 2 2
    
    5 5 3

Output

    NO
    NO
    YES
    NO
    YES
    
Note

In the first test case, a ribbon consists of 1 part. So all its parts will
always have the same color.

In the second test case, there is only 1 color.

In the third test case, Alice can paint the ribbon as follows: [1, 2, 1, 2, 1]
. It's impossible to change the color of at most 1 part so that all parts have
the same color.

In the fourth test case, no matter how Alice paints the ribbon, Bob will
always be able to repaint 2 parts so that all parts have the same color.

In the fifth test case, Alice can paint the ribbon as follows: [1, 2, 3, 4, 5]
. It's impossible to change the color of at most 3 parts so that all parts
have the same color.","t = int(input())
for i in range(t):
    n, m, k = map(int, input().split())
    max_color = (n + m - 1) / m
    if max_color + k >= n:
        print('NO')
    else:
        print('YES')",2,True,False,False,False,False,False,True,True,True,True,True,True,True
266,codeforces2024,human,qwen2.5-7b-instruct,"There is a grid, consisting of 2 rows and n columns. The rows are numbered
from 1 to 2 from top to bottom. The columns are numbered from 1 to n from left
to right. Each cell of the grid contains an arrow pointing either to the left
or to the right. No arrow points outside the grid.

There is a robot that starts in a cell (1, 1) . Every second, the following
two actions happen one after another:

  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); 
  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). 

Your task is to determine whether the robot can reach the cell (2, n) .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer (2 \le n \le 2
\cdot 10^5 ).

The second line contains a string consisting of exactly n characters < and/or
> — the first row of the grid.

The third line contains a string consisting of exactly n characters < and/or >
— the second row of the grid.

Additional constraints on the input:

  * n is even; 
  * there are no arrows pointing outside the grid; 
  * the sum of n over all test cases doesn't exceed 2 \cdot 10^5 . 

Output

For each test case, print YES if the robot can reach the cell (2, n) ;
otherwise, print NO.

You can print each letter in any case. For example, yes, Yes, YeS will all be
recognized as positive answer.

Example

Input

    4
    
    4
    
    >><<
    
    >>><
    
    2
    
    ><
    
    ><
    
    4
    
    >>><
    
    >><<
    
    6
    
    >><<><
    
    ><>>><

Output

    YES
    YES
    NO
    YES
    
Note

In the first example, one of the possible paths looks as follows: (1, 1)
\rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 4) .

In the second example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) .

In the third example, there is no way to reach the cell (2, 4) .

In the fourth example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (1, 2) \rightarrow (1, 3)
\rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (2, 5) \rightarrow (2, 6) .","from collections import deque

def can_reach_bottom_right(n, grid):
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    visited = [[False] * n for _ in range(2)]
    queue = deque([(0, 0)])
    visited[0][0] = True
    
    while queue:
        x, y = queue.popleft()
        
        if x == 1 and y == n - 1:
            return True
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < 2 and 0 <= ny < n and not visited[nx][ny]:
                if grid[nx][ny] == '<' and dy == -1:
                    visited[nx][ny] = True
                    queue.append((nx, ny))
                elif grid[nx][ny] == '>' and dy == 1:
                    visited[nx][ny] = True
                    queue.append((nx, ny))
                elif (dx == 1 and dy == 0) or (dx == -1 and dy == 0):
                    visited[nx][ny] = True
                    queue.append((nx, ny))
    
    return False

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        grid = [input().strip(), input().strip()]
        
        if can_reach_bottom_right(n, grid):
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    solve()",2,False,True,True,True,True,True,True,True,True,True,True,True,False
215,codeforces2024,human,qwen2.5-7b-instruct,"Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.","for i in range(int(input())):
    n,a,b=map(int,input().split())
    k = min(n, max(0, b-a))
    print(a*n + (b-a)*k - k*(k-1)//2)",2,True,False,False,True,True,True,True,True,True,True,True,True,True
29,codeforces2024,human,qwen2.5-7b-instruct,"The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.","t = int(input())
outs = []


for tt in range(t):
    n, m = map(int, input().split())
    
    tot = 0
    
    for b in range(1, m+1):
        tot+=(n+b)//b**2
        
    outs.append(tot-1)
    
    
for out in outs:
    print(out)",2,True,False,False,False,False,False,False,False,False,False,False,False,False
164,codeforces2024,human,qwen2.5-7b-instruct,"There is a game where you need to move through a labyrinth. The labyrinth
consists of n platforms, connected by m passages.

Each platform is at some level l_i , an integer number from 0 to H - 1 . In a
single step, if you are currently on platform i , you can stay on it, or move
to another platform j . To move to platform j they have to be connected by the
passage, and their levels have to be the same, namely l_i = l_j .

After each step, the levels of all platforms change. The new level of platform
i is calculated as l'_i = (l_i + s_i) \bmod H , for all i .

You start on platform 1 . Find the minimum number of steps you need to get to
platform n .

Input

The first line of input contains a single integer t (1 \le t \le 10^4 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains three integers n , m , and H (2 \le
n \le 10^5 , 1 \le m \le 10^5 , 1 \le H \le 10^9 ).

The second line contains n integers l_i , the initial level of each platform
(0 \le l_i \le H-1 ).

The third line contains n integers s_i , the change of level for each platform
(0 \le s_i \le H-1 ).

Next m lines contain a description of the passages. Each passage is described
as a pair of integers — the platforms, connected by the passage. There is at
most one passage connecting each pair of platforms, and there is no passage
connecting a platform to itself.

The sum of n for all tests does not exceed 10^5 , the sum of m for all tests
does not exceed 10^5 .

Output

For each test case, print a single integer, the minimum number of steps needed
to get from platform 1 to platform n .

If it is impossible to get to platform n , print -1 .

Example

Input

    3
    
    3 3 10
    
    1 9 4
    
    2 3 0
    
    1 2
    
    3 2
    
    1 3
    
    2 1 10
    
    1 2
    
    4 6
    
    1 2
    
    8 7 25
    
    22 14 5 3 10 14 11 1
    
    9 5 4 10 7 16 18 18
    
    2 8
    
    6 3
    
    3 5
    
    7 5
    
    2 6
    
    1 4
    
    4 7

Output

    6
    -1
    52
    
Note

This is how levels of the platforms change, and what actions we need to
perform in the first example.

| Platform 1| Platform 2| Platform 3| Action  
---|---|---|---|---  
Step 1| 1| 9| 4| Stay on the platform 1  
Step 2| 3| 2| 4| Stay on the platform 1  
Step 3| 5| 5| 4| Move to the platform 2  
Step 4| 7| 8| 4| Stay on the platform 2  
Step 5| 9| 1| 4| Stay on the platform 2  
Step 6| 1| 4| 4| Move to the platform 3","from collections import deque

def min_steps_to_reach_platform_n(n, m, H, levels, changes, passages):
    # Create a graph to represent the connections between platforms
    graph = [[] for _ in range(n)]
    for u, v in passages:
        graph[u - 1].append(v - 1)
        graph[v - 1].append(u - 1)
    
    # Initialize the queue for BFS
    queue = deque([(0, 0)])  # (current platform, number of steps)
    visited = set([(0, levels[0])])  # Set to keep track of visited states (platform, level)
    
    while queue:
        current_platform, steps = queue.popleft()
        
        # If we reached the target platform, return the number of steps
        if current_platform == n - 1:
            return steps
        
        # Explore all possible moves from the current platform
        for next_platform in graph[current_platform]:
            # Check if the levels are the same and the state has not been visited
            if levels[current_platform] == levels[next_platform]:
                next_state = (next_platform, (levels[next_platform] + changes[next_platform]) % H)
                if next_state not in visited:
                    visited.add(next_state)
                    queue.append((next_platform, steps + 1))
        
        # Update the level of the current platform
        levels[current_platform] = (levels[current_platform] + changes[current_platform]) % H
    
    # If it is impossible to reach platform n, return -1
    return -1

# Read input
t = int(input())
for _ in range(t):
    n, m, H = map(int, input().split())
    levels = list(map(int, input().split()))
    changes = list(map(int, input().split()))
    passages = [tuple(map(int, input().split())) for _ in range(m)]
    
    # Calculate and print the result
    result = min_steps_to_reach_platform_n(n, m, H, levels, changes, passages)
    print(result)",2,False,False,True,True,True,True,True,True,True,True,True,True,True
163,codeforces2024,human,qwen2.5-7b-instruct,"There is a fun game where you need to feed cats that come and go. The level of
the game consists of n steps. There are m cats; the cat i is present in steps
from l_i to r_i , inclusive. In each step, you can feed all the cats that are
currently present or do nothing.

If you feed the same cat more than once, it will overeat, and you will
immediately lose the game. Your goal is to feed as many cats as possible
without causing any cat to overeat.

Find the maximum number of cats you can feed.

Formally, you need to select several integer points from the segment from 1 to
n in such a way that among given segments, none covers two or more of the
selected points, and as many segments as possible cover one of the selected
points.

Input

The first line of input contains a single integer t (1 \le t \le 10^4 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains two integers n and m (1 \le n \le
10^6 , 1 \le m\le 2\cdot 10^5 ).

The i -th of the next m lines contains a pair of integers l_i and r_i (1 \le
l_i \le r_i \le n ).

The sum of n for all tests does not exceed 10^6 , the sum of m for all tests
does not exceed 2\cdot 10^5 .

Output

For each test case, print a single integer, the maximum number of cats you can
feed.

Example

Input

    3
    
    15 6
    
    2 10
    
    3 5
    
    2 4
    
    7 7
    
    8 12
    
    11 11
    
    1000 1
    
    1 1000
    
    5 10
    
    1 2
    
    3 4
    
    3 4
    
    3 4
    
    3 4
    
    1 1
    
    1 2
    
    3 3
    
    3 4
    
    3 4

Output

    5
    1
    10
    
Note

In the first example, one of the ways to feed five cats is to feed at steps 4
and 11 .

  * At step 4 , cats 1 , 2 , and 3 will be fed.
  * At step 11 , cats 5 and 6 will be fed.","for _ in range (int(input())): 
    n , m = map(int,input().split()) 
    aseg = [0]*(n+2) 
    along = [-1]*(n+2) 
    for i in range (m): 
        l , r = map(int, input().split()) 
        aseg[l] += 1 
        aseg[r+1] -=1 
        along[l] = max(r+1, along[l])
    dp = [0]*(n+2) 
    for i in range (n): 
        aseg[i+1] += aseg[i] 
        along[i] = max(along[i] , along[i-1])
    for i in range (n, 0 , -1): 
        if along[i] < 0 : dp[i] = dp[i+1] 
        else:dp[i] = max(dp[i+1] , aseg[i] + dp[along[i]])
    # print(dp) 
    # print(aseg) 
    # print(along)
    print(dp[1])",2,False,False,False,True,True,True,True,False,True,True,True,True,True
209,codeforces2024,human,qwen2.5-7b-instruct,"Jay managed to create a problem of difficulty x and decided to make it the
second problem for Codeforces Round #921.

But Yash fears that this problem will make the contest highly unbalanced, and
the coordinator will reject it. So, he decided to break it up into a
problemset of n sub-problems such that the difficulties of all the sub-
problems are a positive integer and their sum is equal to x .

The coordinator, Aleksey, defines the balance of a problemset as the
[GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the
difficulties of all sub-problems in the problemset.

Find the maximum balance that Yash can achieve if he chooses the difficulties
of the sub-problems optimally.

Input

The first line of input contains a single integer t (1\leq t\leq 10^3 )
denoting the number of test cases.

Each test case contains a single line of input containing two integers x
(1\leq x\leq 10^8 ) and n (1\leq n\leq x ).

Output

For each test case, print a single line containing a single integer denoting
the maximum balance of the problemset Yash can achieve.

Example

Input

    3
    
    10 3
    
    5 5
    
    420 69

Output

    2
    1
    6
    
Note

For the first test case, one possible way is to break up the problem of
difficulty 10 into a problemset having three problems of difficulties 4 , 2
and 4 respectively, giving a balance equal to 2 .

For the second test case, there is only one way to break up the problem of
difficulty 5 into a problemset of 5 problems with each problem having a
difficulty 1 giving a balance equal to 1 .","import math

def find_gcd(x,n):
    xl=[]
    ans=0
    for i in range(1,int(math.sqrt(x)+1)):
        if x%i==0 and i not in xl:
            xl.append(i)
            if x//i>2 and (x//i) not in xl:
                xl.append(x//i)
    l=sorted(xl)
    for ll in reversed(l):
        if ans==0:
            if x//ll>=n and ll>ans:
                ans=ll
        else:
            break
    return ans

t=int(input())
for _ in range(t):
    x,n=map(int,input().split())
    ans=find_gcd(x,n)
    print(ans)",2,False,False,False,True,True,True,True,False,False,True,True,False,False
69,codeforces2024,human,qwen2.5-7b-instruct,"You can never buy enough happiness, so here we go again! In this version, you
can only buy h_i = 1 unit of happiness each month, but the number of months is
hugely increased. We are in the realm of quantum happiness and time dilation.

Being a physicist, Charlie likes to plan his life in simple and precise terms.

For the next m months, starting with no money, Charlie will work hard and earn
x pounds per month. For the i -th month (1 \le i \le m) , there'll be a single
opportunity of paying cost c_i pounds to obtain one unit of happiness. You
cannot buy more than one unit each month.

Borrowing is not allowed. Money earned in the i -th month can only be spent in
a later j -th month (j>i ).

Since physicists don't code, help Charlie find the maximum reachable units of
happiness.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first line of each test case contains two integers, m and x (1 \le m \le 2
\cdot 10^5 , 1 \le x \le 10^3 ) — the total number of months and the monthly
salary.

The second line of each test case contains m integers c_1, c_2, \dots, c_m (1
\leq c_i \leq 10^3 ) — the cost of one unit of happiness for each month.

It is guaranteed that sum of m over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output one integer — the maximal amount of happiness
Charlie can get.

Example

Input

    6
    
    3 3
    
    2 2 2
    
    6 5
    
    2 2 8 2 6 8
    
    6 4
    
    4 10 3 8 6 10
    
    2 1
    
    1 1
    
    4 1
    
    4 1 3 1
    
    4 2
    
    1 3 4 3

Output

    2
    4
    3
    1
    2
    1","import heapq
rs=[]
for _ in range(int(input())):
    n,m = map(int,input().split())
    l=list(map(int,input().split()))
    mx=0;s=0
    cnt=0
    h=[]
    for i in range(n):
        if s>=l[i]:
            s-=l[i]
            heapq.heappush(h,-l[i])
            cnt+=1
            mx=max(mx,cnt)
        else:
            if h:
                if l[i]<abs(h[0]):
                    s+=abs(h[0])-l[i]
                    heapq.heappop(h)
                    heapq.heappush(h,-l[i])
        s+=m                    


    rs.append(cnt)
print(*rs,sep=""\n"")",2,True,False,True,True,True,True,True,True,True,False,True,False,False
57,codeforces2024,human,qwen2.5-7b-instruct,"In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in ""the first–k -th"" position.

As is known, settling in ""the first–k -th"" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the ""Note"" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.","def find_valid_ks(n, x):
    def get_even_divisors(value):
        even_divisors = []
        for i in range(1, int(value**0.5) + 1):
            if value % i == 0:
                if i % 2 == 0:
                    even_divisors.append(i)
                if (value // i) % 2 == 0 and i != value // i:
                    even_divisors.append(value // i)
        return even_divisors

    # Calculate all even divisors of n - x and n + x - 2
    divisors_n_x = get_even_divisors(n - x)
    divisors_n_x_2 = get_even_divisors(n + x - 2)

    # Combine all divisors into a set for uniqueness
    divisors = set(divisors_n_x + divisors_n_x_2)

    # Count valid k values
    valid_k_count = 0
    for d in divisors:
        k = d // 2 + 1
        if k > 1 and k >= x:
            valid_k_count += 1

    return valid_k_count


def main():
    t = int(input())  # Number of test cases
    results = []

    for _ in range(t):
        n, x = map(int, input().split())
        results.append(find_valid_ks(n, x))

    for res in results:
        print(res)


if __name__ == ""__main__"":
    main()",2,True,True,False,True,False,True,True,False,False,False,True,True,True
182,codeforces2024,human,qwen2.5-7b-instruct,"You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .","t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    a, b = input(), input()
    b_count = [b.count('0'), b.count('1')]
    length = 0
    for i in range(n):
        if a[i] == '0':
            if b_count[0]:
                length += 1
                b_count[0] -= 1
            else:
                break
        else:
            if b_count[1]:
                length += 1
                b_count[1] -= 1
            else:
                break
    print(length)",2,False,False,False,False,False,False,True,True,True,True,False,True,False
65,codeforces2024,human,qwen2.5-7b-instruct,"Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .","import sys

t = int(input())  

for _ in range(t):
    v = list(map(int, input().split()))
    if (v[0] + v[1] + v[2]) % 2 == 1:
        print(""-1"")
    else:
        result = (v[0] + v[1] + v[2] - max(0, v[2] - v[0] - v[1])) // 2
        print(result)",2,True,False,False,True,False,True,True,True,True,True,False,False,False
121,codeforces2024,human,qwen2.5-7b-instruct,"This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either ""first"" or ""second"",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print ""0 0"" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
""-1 -1"" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints ""-1 -1"", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.","def play_game():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        
        # Determine if Alice should play first or second
        if bin(n).count('1') % 2 == 1:
            print('second')
        else:
            print('first')
            # Calculate the largest power of 2 less than n
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)
        
        # Interaction loop
        while True:
            a, b = map(int, data[index:index+2])
            index += 2
            if a == b:
                break
            # Choose the next number based on the count of 1s
            n = b if bin(a).count('1') % 2 == 1 else a
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)",2,False,False,False,True,False,True,True,True,False,False,False,False,False
290,codeforces2024,human,qwen2.5-7b-instruct,"This afternoon, you decided to enjoy the first days of Spring by taking a walk
outside. As you come near the Quidditch field, you hear screams. Once again,
there is a conflict about the score: the two teams are convinced that they won
the game! To prevent this problem from happening one more time, you decide to
get involved in the refereeing of the matches.

Now, you will stay in the stadium to watch the game and count the score. At
the end of the game, you will decide the winner.

Today, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw
(B) team. Each team is composed of P players (1 \leq P \leq 10 ).

The field is a rectangle of N lines and M columns (3 \leq N, M \leq 99 , N and
M are odd). All the positions are integers, and several entities are allowed
to be at the same position in the field. At the beginning of the game, the
field contains goals for the two teams (each team can own between one and five
goals), the players, and exactly one Quaffle. Other types of balls will be
available in the harder versions of the problem.

A game is composed of T steps (0 \leq T \leq 10000 ). At each step, one entity
on the field (a player or a ball) performs one action. All entities can move.
A player can also catch a ball or throw the Quaffle that it is carrying. To
catch a ball, a player must be located on the same cell as it. The Quaffle
does not perform any action while it is being carried; it only follows the
movements of the player. If a player carrying the Quaffle decides to throw it,
the Quaffle is simply put at the current position of the player.

To win a point, a player must leave the Quaffle at a goal of the other team.
When it does, the team of the player wins one point, and the Quaffle instantly
moves to the middle of the field (the cell at the (M+1)/2 -th column of the
(N+1)/2 -th line of the field, starting from 1). There is no goal in the
middle of the field. If a player puts the ball in its own goal, the other team
wins the point.

Input

On the first line, the integers N and M .

The description of the field follows: N lines of M pairs of characters
separated by spaces. Each pair of characters represents a position on the
field. It can be either:

  * .. to represent an empty cell 
  * R0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid. 
  * RG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG). 
  * .Q to represent the Quaffle, which is the ball that the players use to score goals. 

The next line contains T , the number of steps that compose the game. T lines
follow, each describing one action. It contains several pieces of information
separated by a space. First, a pair of characters representing the entity that
must perform the action. Second, the description of the action:

  * U, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time. 
  * C indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since in the next versions of the problem, several balls may be in the same cell. 
  * T indicates that the player throws the Quaffle that it is carrying. 

All the actions performed by the entities are guaranteed to be valid: the
players stay in the field, don't catch a ball if they are not in the same
cell, don't release the Quaffle if they are not carrying it, ...

Output

You must output the description of the main events of the game, one event per
line. More precisely:

  * Each time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team. 

The events must be printed in ascending order of t.

At the end of the game, you must print the final score as: FINAL SCORE: r b,
where r is the score of the red team and b is the score of the blue team.

Examples

Input

    5 5
    
    .. R1 .. B1 ..
    
    RG .. .. .. BG
    
    RG R0 .Q B0 BG
    
    RG .. .. .. BG
    
    .. R2 .. B2 ..
    
    13
    
    B2 U
    
    B2 U
    
    B2 L
    
    B2 C .Q
    
    B2 L
    
    B2 L
    
    B2 T
    
    R0 R
    
    R0 C .Q
    
    R0 D
    
    R0 R
    
    R0 R
    
    R0 T

Output

    6 BLUE GOAL
    12 RED GOAL
    FINAL SCORE: 1 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    12
    
    R0 D
    
    R0 C .Q
    
    R0 R
    
    R0 T
    
    R0 D
    
    B0 R
    
    B0 U
    
    B0 C .Q
    
    B0 L
    
    B0 L
    
    B0 L
    
    B0 T

Output

    11 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    5
    
    R0 D
    
    R0 C .Q
    
    R0 L
    
    R0 L
    
    R0 T

Output

    4 BLUE GOAL
    FINAL SCORE: 0 1
    
Note

In the first example, a blue player goes to the middle of the grid, at the
position of the Quaffle. He takes it, goes to the goal of the red team, and
lets the ball there. He scores! The ball gets back to the middle of the field,
a red player takes it and scores too.

In the second example, the red player takes the Quaffle, move it and throw it.
The blue player catches the ball, goes to the red goal and scores.

In the third example, the red player takes the ball and scores in the goal of
their own team: the blue team wins a point.","def play_quidditch():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    # Read the dimensions of the field
    N, M = map(int, data[0].split())
    
    # Initialize the field
    field = []
    for i in range(1, N + 1):
        field.append(data[i].split())
    
    # Read the number of steps
    T = int(data[N + 1])
    
    # Initialize positions and states
    positions = {}
    quaffle_position = None
    quaffle_carrier = None
    
    # Parse the field to find initial positions
    for i in range(N):
        for j in range(M):
            cell = field[i][j]
            if cell == '.Q':
                quaffle_position = (i, j)
            elif cell != '..':
                positions[cell] = (i, j)
    
    # Initialize scores
    red_score = 0
    blue_score = 0
    
    # Process each action
    for t in range(T):
        action = data[N + 2 + t].split()
        entity = action[0]
        command = action[1]
        
        if command in 'UDLR':
            # Move the entity
            x, y = positions[entity]
            if command == 'U':
                x -= 1
            elif command == 'D':
                x += 1
            elif command == 'L':
                y -= 1
            elif command == 'R':
                y += 1
            positions[entity] = (x, y)
            
            # If the entity is carrying the Quaffle, move it too
            if quaffle_carrier == entity:
                quaffle_position = (x, y)
        
        elif command == 'C':
            # Catch the Quaffle
            ball = action[2]
            if ball == '.Q':
                quaffle_carrier = entity
        
        elif command == 'T':
            # Throw the Quaffle
            quaffle_carrier = None
        
        # Check for scoring
        if quaffle_carrier is None and quaffle_position is not None:
            x, y = quaffle_position
            cell = field[x][y]
            if cell == 'RG':
                # Blue team scores
                blue_score += 1
                print(f""{t} BLUE GOAL"")
                # Reset Quaffle to the center
                quaffle_position = ((N - 1) // 2, (M - 1) // 2)
            elif cell == 'BG':
                # Red team scores
                red_score += 1
                print(f""{t} RED GOAL"")
                # Reset Quaffle to the center
                quaffle_position = ((N - 1) // 2, (M - 1) // 2)
    
    # Print the final score
    print(f""FINAL SCORE: {red_score} {blue_score}"")

# Call the function to execute the game simulation
play_quidditch()",2,True,False,False,True,True,True,True,True,False,True,True,False,False
341,codeforces2024,human,qwen2.5-7b-instruct,"You have been asked to organize a very important art conference. The first
step is to choose the dates.

The conference must last for a certain number of consecutive days. Each day,
one lecturer must perform, and the same lecturer cannot perform more than
once.

You asked n potential lecturers if they could participate in the conference.
Lecturer i indicated that they could perform on any day from l_i to r_i
inclusive.

A certain segment of days can be chosen as the conference dates if there is a
way to assign an available lecturer to each day of the segment, assigning each
lecturer to no more than one day.

For each k from 1 to n , find how many ways there are to choose a segment of k
consecutive days as the conference dates.

Input

The first line of input contains one integer n — the number of potential
lecturers (1 \le n \le 2 \cdot 10^5 ).

Each of the next n lines contains two integers l_i and r_i — the segment of
available days for the i th lecturer (1 \le l_i \le r_i \le 2 \cdot 10^5 ).

Output

Print n integers, where the k th number denotes the number of ways to select a
segment of k consecutive days as conference dates.

Examples

Input

    3
    
    1 2
    
    3 4
    
    5 6

Output

    6
    2
    0
    
Input

    5
    
    1 3
    
    1 3
    
    1 3
    
    1 3
    
    1 3

Output

    3
    2
    1
    0
    0
    
Note

In the first testcase, a one-day conference can be organized on any of the
days from 1 to 6 . A two-day conference can be organized from day 2 to day 3 ,
as well as from day 4 to day 5 .

In the second testcase, five lecturers can perform only from day 1 to day 3 ,
so it will not be possible to organize a conference longer than three days.","# LUOGU_RID: 162825576
import heapq

# 使用元组替代Node类
n = int(input().strip())
nnn = n

a = [(0, 0) for _ in range(n + 1)]
vc = [[] for _ in range(200005)]
b = [0] * 200005
c = [0] * 200005
d = [0] * 200005
ans = [0] * 200005

m = 0

for i in range(1, n + 1):
    line = input().strip().split()
    l = int(line[0])
    r = int(line[1])
    a[i] = (l, r)
    m = max(m, r)

pq = []
for i in range(1, n + 1):
    vc[a[i][0]].append(a[i][1])

n = 0
for i in range(1, m + 1):
    for j in vc[i]:
        heapq.heappush(pq, j)
    while pq and pq[0] < i:
        heapq.heappop(pq)
    if pq:
        n += 1
        a[n] = (i, heapq.heappop(pq))

for i in range(1, n + 1):
    l, r = a[i]
    b[l] = r
    c[r] += 1
    d[l] += 1
    d[r + 1] -= 1

s = 0
j = m
for i in range(m, 0, -1):
    s += c[i]
    while j >= i and s < j - i + 1:
        s -= (1 if b[j] else 0)
        j -= 1
    if j <= m:
        ans[j - i + 1] += 1

for i in range(max(m, n), 0, -1):
    ans[i] += ans[i + 1]

for i in range(1, nnn + 1):
    print(ans[i])",2,True,False,False,True,True,True,True,True,False,False,False,False,False
354,codeforces2024,human,qwen2.5-7b-instruct,"You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126","mod = 998244353

# Precompute factorials up to 2,000,000
f = [1]
for i in range(1, 2 * 10 ** 6 + 1):
    f.append(f[-1] * i % mod)

# Process each test case
for _ in range(int(input())):
    a, b, c, d = map(int, input().split())
    
    # If the difference between a and b is more than 1, it's impossible to form a chain
    if abs(a - b) > 1:
        print(0)
    elif a == b:
        # If a and b are both zero, check if c or d is zero
        if a == 0:
            print(int((c == 0) or (d == 0)))
        else:
            # Calculate the number of ways using factorials
            result = (f[a - 1 + c] * f[a + d] + f[a - 1 + d] * f[a + c]) * pow(f[a - 1] * f[d] * f[a] * f[c], -1, mod) % mod
            print(result)
    else:
        # If a and b differ by exactly 1, calculate the number of ways
        a = max(a, b)
        result = f[a - 1 + c] * f[a - 1 + d] * pow(f[a - 1] ** 2 * f[c] * f[d], -1, mod) % mod
        print(result)",2,True,False,False,True,False,True,True,True,True,False,True,True,False
92,codeforces2024,human,qwen2.5-7b-instruct,"As soon as everyone in the camp fell asleep, Kirill sneaked out of the tent
and went to the Wise Oak to gather mushrooms.

It is known that there are n mushrooms growing under the Oak, each of which
has magic power v_i . Kirill really wants to make a magical elixir of maximum
strength from the mushrooms.

The strength of the elixir is equal to the product of the number of mushrooms
in it and the minimum magic power among these mushrooms. To prepare the
elixir, Kirill will sequentially pick one mushroom growing under the Oak.
Kirill can gather mushrooms in any order.

However, it's not that simple. The Wise Oak informed Kirill of a permutation
of numbers p from 1 to n . If Kirill picks only k mushrooms, then the magic
power of all mushrooms with indices p_1, p_2, \dots, p_{k - 1} will become 0 .
Kirill will not use mushrooms with zero magic power to prepare the elixir.

Your task is to help Kirill gather mushrooms in such a way that he can brew
the elixir of maximum possible strength. However, Kirill is a little scared to
stay near the oak for too long, so out of all the suitable options for
gathering mushrooms, he asks you to find the one with the minimum number of
mushrooms.

A permutation of length n is an array consisting of n different integers from
1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (2 appears in the array twice) and [1,3,4] is also not a
permutation (n=3 , but 4 appears in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
200\,000 ) — the number of mushrooms.

The second line contains an array v of size n (1\le v_i \le 10^9 ) — the magic
powers of the mushrooms.

The third line contains a permutation p of numbers from 1 to n .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2\cdot 10^5 .

Output

For each test case, output two integers separated by a space — the maximum
strength of the elixir that can be brewed and the minimum number of mushrooms
that Kirill needs to use for this.

Example

Input

    6
    
    3
    
    9 8 14
    
    3 2 1
    
    5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    6
    
    1 2 3 4 5 6
    
    6 5 4 3 2 1
    
    5
    
    1 4 6 10 10
    
    2 1 4 5 3
    
    4
    
    2 2 5 5
    
    4 2 3 1
    
    5
    
    1 2 9 10 10
    
    1 4 2 3 5

Output

    16 2
    9 3
    8 2
    20 2
    5 1
    20 2
    
Note

In the first example, you need to take the mushrooms with indices 1 and 2 , so
the strength of the elixir is equal to 2 \cdot \min(a_1, a_2) = 2 \cdot
\min(9, 8) = 2 \cdot 8 = 16 . Note that the magic power of the mushroom with
index 3 after picking two mushrooms will become 0 .","import heapq

# Read the number of test cases
t = int(input())

for _ in range(t):
    # Read the number of mushrooms
    n = int(input())
    
    # Read the magic powers of the mushrooms
    v = list(map(int, input().split()))
    
    # Read the permutation
    p = list(map(int, input().split()))
    
    # Calculate the maximum size of the initial heap
    max_size = (n + 2) // 2
    
    # Initialize a min-heap
    h = []
    heapq.heapify(h)
    
    # Fill the heap with the largest possible subset of mushrooms
    for j in range(max_size):
        heapq.heappush(h, v[p[n - 1 - j] - 1])
    
    # If n is even, pop one element to adjust the heap size
    if n % 2 == 0:
        heapq.heappop(h)
    
    # Initialize the output with the current heap configuration
    output = (len(h) * h[0], len(h))
    
    # Iterate to find the optimal configuration
    while True:
        if len(h) == 1:
            # If only one mushroom is left, check if it gives a better result
            if h[0] >= output[0]:
                output = (h[0], 1)
            break
        else:
            # Pop the smallest element from the heap
            heapq.heappop(h)
            l = len(h)
            
            # Check if the next mushroom in the permutation can improve the heap
            if h[0] < v[p[l - 1] - 1]:
                heapq.heappop(h)
                heapq.heappush(h, v[p[l - 1] - 1])
            
            # Update the output if the current configuration is better
            if h[0] * l >= output[0]:
                output = (h[0] * l, l)
    
    # Print the result for the current test case
    print(output[0], output[1])",2,True,False,False,True,False,True,True,True,True,True,False,True,False
169,codeforces2024,human,qwen2.5-7b-instruct,"In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.","def solve():
    n = int(input())
    a = list(map(int, input().split()))
    cur_mex = 0
    cur_have = [0] * (n + 1)
    for el in a:
        cur_have[el] += 1
    while cur_have[cur_mex]:
        cur_mex += 1

    another_mex = 0
    another_have = [0] * (n + 1)
    for i in range(n):
        cur_have[a[i]] -= 1
        if cur_have[a[i]] == 0 and cur_mex > a[i]:
            cur_mex = a[i]

        another_have[a[i]] += 1
        while another_have[another_mex]:
            another_mex += 1

        if cur_mex == another_mex:
            print(2)
            print(""1 "" + str(i + 1))
            print(str(i + 2) + "" "" + str(n))
            return

    print(-1)


t = int(input())
for _ in range(t):
    solve()",2,True,False,False,False,False,False,False,False,False,False,False,False,False
7,codeforces2024,human,qwen2.5-7b-instruct,"You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.","def bfs(tree, start_node):
    from collections import deque
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        current_distance = distances[node]
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
    return distances

def solve_tree_compass(n, edges):
    # Build the tree from edges
    tree = {i: [] for i in range(1, n+1)}
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)
    
    # Start from an arbitrary node, here node 1
    distances = bfs(tree, 1)
    
    # Determine operations
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for node, dist in distances.items() if dist == d]
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
    
    return len(operations), operations

# Example usage
n = 4
edges = [(1, 2), (1, 3), (1, 4)]
num_operations, operations = solve_tree_compass(n, edges)
print(num_operations)
for v, d in operations:
    print(v, d)",2,False,True,False,True,False,True,True,False,True,False,False,True,False
316,codeforces2024,human,qwen2.5-7b-instruct,"The price of one yogurt at the ""Vosmiorochka"" store is a burles, but there is
a promotion where you can buy two yogurts for b burles.

Maxim needs to buy exactly n yogurts. When buying two yogurts, he can choose
to buy them at the regular price or at the promotion price.

What is the minimum amount of burles Maxim should spend to buy n yogurts?

Input

The first line contains a single integer t (1 \le t \le {10}^{4} ) — the
number of test cases.

The first and only line of each test case contains three integers n , a , and
b (1 \le n \le 100 , 1 \le a, b \le 30 ) — the number of yogurts Maxim wants
to buy, the price for one yogurt, and the price for two yogurts on promotion.

Output

For each test case, print in a separate line the minimum cost of buying n
yogurts at ""Vosmiorochka"".

Example

Input

    4
    
    2 5 9
    
    3 5 9
    
    3 5 11
    
    4 5 11

Output

    9
    14
    15
    20
    
Note

In the third test case of the example, it is more advantageous to buy three
yogurts for 15 burles than two for 11 and one for 5 .

In the fourth test case of the example, you need to buy four yogurts, each for
5 burles.","for _ in range(int(input())):
    n, a, b = map(int, input().split())
    if a*2 < b:
        print(n * a)
    elif n % 2 == 0:
        print(b * (n//2))
    else:
        print((b * (n//2))+a)",2,True,False,False,True,True,True,True,True,False,True,True,False,True
339,codeforces2024,human,qwen2.5-7b-instruct,"There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1","def min_seconds_to_kill_monsters(n, health):
    max_health = max(health)
    results = []

    for k in range(1, max_health + 1):
        # Copy the health list to simulate the process
        current_health = health[:]
        operations = 0

        for i in range(n):
            if current_health[i] > 0:
                # Apply chain lightning at position i
                operations += 1
                # Damage the current monster
                current_health[i] -= k
                # Damage the left neighbor if it exists
                if i > 0:
                    current_health[i - 1] -= k
                # Damage the right neighbor if it exists
                if i < n - 1:
                    current_health[i + 1] -= k

        results.append(operations)

    return results

# Read input
n = int(input().strip())
health = list(map(int, input().strip().split()))

# Get the results
results = min_seconds_to_kill_monsters(n, health)

# Print the results
for result in results:
    print(result)",2,False,False,False,True,True,True,True,True,False,True,True,True,False
182,codeforces2024,human,qwen2.5-7b-instruct,"You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .","I=input
for _ in[0]*int(I()):
 I();a=I()+'*';k=0
 for x in I():k+=x==a[k]
 print(k)",2,True,False,False,False,False,True,False,False,True,False,False,True,False
294,codeforces2024,human,qwen2.5-7b-instruct,"Yarik's birthday is coming soon, and Mark decided to give him an array a of
length n .

Mark knows that Yarik loves bitwise operations very much, and he also has a
favorite number x , so Mark wants to find the maximum number k such that it is
possible to select pairs of numbers [l_1, r_1 ], [l_2, r_2 ], \ldots [l_k, r_k
], such that:

  * l_1 = 1 . 
  * r_k = n . 
  * l_i \le r_i for all i from 1 to k . 
  * r_i + 1 = l_{i + 1} for all i from 1 to k - 1 . 
  * (a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \le x , where \oplus denotes the operation of [bitwise XOR](https://en.wikipedia.org/wiki/Exclusive_or), and | denotes the operation of [bitwise OR](https://en.wikipedia.org/wiki/Logical_disjunction). 

If such k does not exist, then output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The following lines
contain the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le n \le
10^5, 0 \le x < 2^{30} ) — the length of the array a and the number x
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < 2^{30} ) — the array a itself.

It is guaranteed that the sum of the values of n across all test cases does
not exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the maximum
suitable number k , and -1 if such k does not exist.

Example

Input

    8
    
    3 1
    
    1 2 3
    
    2 2
    
    1 1
    
    2 2
    
    1 3
    
    2 3
    
    0 0
    
    3 2
    
    0 0 1
    
    4 2
    
    1 3 3 7
    
    2 2
    
    2 3
    
    5 0
    
    0 1 2 2 1

Output

    2
    2
    1
    2
    3
    -1
    1
    2
    
Note

In the first test case, you can take k equal to 2 and choose two segments [1, 1 ] and [2, 3 ], (1) | (2 \oplus 3) = 1 . It can be shown that 2 is the maximum possible answer.

In the second test case, the segments [1, 1 ] and [2, 2 ] are suitable, (1) | (1) = 1 . It is not possible to make more segments.

In the third test case, it is not possible to choose 2 segments, as (1) | (3) = 3 > 2 , so the optimal answer is 1 .","def func(n, x, a):
    val = 0  # This will store the cumulative XOR for the current segment
    ct = 0   # This counts the number of valid segments
    for z in a:
        z = int(z)  # Ensure the element is an integer
        val ^= z    # Update the cumulative XOR with the current element
        # Check if the current segment can be closed
        if val | x == x:
            ct += 1  # Increment the segment count
            val = 0  # Reset the cumulative XOR for the next segment
    # If val is 0, all segments are valid, return the count
    if val == 0:
        return ct
    else:
        return -1  # Otherwise, return -1 indicating no valid segmentation

t = int(input())  # Read the number of test cases
for _ in range(t):
    n, x = [int(z) for z in input().split()]  # Read n and x for the test case
    a = [int(z) for z in input().split()]     # Read the array a
    best = -1  # Initialize the best result for this test case
    highbit = 1  # This will help in manipulating x
    while highbit:
        # Try to find the maximum k for the current x
        best = max(best, func(n, x + highbit - 1, a))
        highbit = x & -x  # Get the lowest set bit in x
        x ^= highbit      # Remove the lowest set bit from x
    print(best)  # Output the best result for the current test case",2,True,False,False,True,True,True,True,False,False,False,True,True,False
92,codeforces2024,human,qwen2.5-7b-instruct,"As soon as everyone in the camp fell asleep, Kirill sneaked out of the tent
and went to the Wise Oak to gather mushrooms.

It is known that there are n mushrooms growing under the Oak, each of which
has magic power v_i . Kirill really wants to make a magical elixir of maximum
strength from the mushrooms.

The strength of the elixir is equal to the product of the number of mushrooms
in it and the minimum magic power among these mushrooms. To prepare the
elixir, Kirill will sequentially pick one mushroom growing under the Oak.
Kirill can gather mushrooms in any order.

However, it's not that simple. The Wise Oak informed Kirill of a permutation
of numbers p from 1 to n . If Kirill picks only k mushrooms, then the magic
power of all mushrooms with indices p_1, p_2, \dots, p_{k - 1} will become 0 .
Kirill will not use mushrooms with zero magic power to prepare the elixir.

Your task is to help Kirill gather mushrooms in such a way that he can brew
the elixir of maximum possible strength. However, Kirill is a little scared to
stay near the oak for too long, so out of all the suitable options for
gathering mushrooms, he asks you to find the one with the minimum number of
mushrooms.

A permutation of length n is an array consisting of n different integers from
1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (2 appears in the array twice) and [1,3,4] is also not a
permutation (n=3 , but 4 appears in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
200\,000 ) — the number of mushrooms.

The second line contains an array v of size n (1\le v_i \le 10^9 ) — the magic
powers of the mushrooms.

The third line contains a permutation p of numbers from 1 to n .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2\cdot 10^5 .

Output

For each test case, output two integers separated by a space — the maximum
strength of the elixir that can be brewed and the minimum number of mushrooms
that Kirill needs to use for this.

Example

Input

    6
    
    3
    
    9 8 14
    
    3 2 1
    
    5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    6
    
    1 2 3 4 5 6
    
    6 5 4 3 2 1
    
    5
    
    1 4 6 10 10
    
    2 1 4 5 3
    
    4
    
    2 2 5 5
    
    4 2 3 1
    
    5
    
    1 2 9 10 10
    
    1 4 2 3 5

Output

    16 2
    9 3
    8 2
    20 2
    5 1
    20 2
    
Note

In the first example, you need to take the mushrooms with indices 1 and 2 , so
the strength of the elixir is equal to 2 \cdot \min(a_1, a_2) = 2 \cdot
\min(9, 8) = 2 \cdot 8 = 16 . Note that the magic power of the mushroom with
index 3 after picking two mushrooms will become 0 .","def max_elixir_strength(n, v, p):
    # Sort the mushrooms by their magic power
    v_sorted = sorted(v, reverse=True)
    
    # Initialize variables to store the maximum strength and the minimum number of mushrooms
    max_strength = 0
    min_mushrooms = n
    
    # Iterate through the sorted mushrooms
    for i in range(1, n+1):
        # Calculate the strength of the elixir if we pick i mushrooms
        strength = i * v_sorted[i-1]
        
        # Update the maximum strength and the minimum number of mushrooms if necessary
        if strength > max_strength:
            max_strength = strength
            min_mushrooms = i
        elif strength == max_strength:
            min_mushrooms = min(min_mushrooms, i)
    
    return max_strength, min_mushrooms

# Input reading and processing
t = int(input())
for _ in range(t):
    n = int(input())
    v = list(map(int, input().split()))
    p = list(map(int, input().split()))
    
    # Calculate and print the result
    result = max_elixir_strength(n, v, p)
    print(*result)",2,False,False,False,False,False,True,True,True,False,False,False,False,False
248,codeforces2024,human,qwen2.5-7b-instruct,"You have a square piece of paper with a side length equal to 1 unit. In one
operation, you fold each corner of the square to the center of the paper, thus
forming another square with a side length equal to \dfrac{1}{\sqrt{2}} units.
By taking this square as a new square, you do the operation again and repeat
this process a total of N times.

![](https://espresso.codeforces.com/412ebba036545f933291dce36c1d7ef46e6051c5.png)
Performing operations for N = 2 .

After performing the set of operations, you open the paper with the same side
up you started with and see some crease lines on it. Every crease line is one
of two types: a mountain or a valley. A mountain is when the paper folds
outward, and a valley is when the paper folds inward.

You calculate the sum of the length of all mountain crease lines on the paper
and call it M . Similarly, you calculate for valley crease lines and call it V
. You want to find the value of \dfrac{M}{V} .

It can be proved that this value can be represented in the form of A +
B\sqrt{2} , where A and B are rational numbers. Let this B be represented as
an irreducible fraction \dfrac{p}{q} , your task is to print p*inv(q) modulo
999\,999\,893 (note the unusual modulo), where inv(q) is the [modular
inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of q .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \leq t \leq 10^4 ). Description of the test cases follows.

The only line of each test case contains an integer N (1 \leq N \leq 10^9 ),
the number of operations you perform on the square paper.

Output

For each test case, print on a new line the required answer.

Example

Input

    3
    
    1
    
    2
    
    3

Output

    0
    1
    714285638
    
Note

The blue lines in the given figures represent mountain crease lines, and the
green lines represent valley crease lines.

![](https://espresso.codeforces.com/ca27ca80cf535ddfa7cb1255e157dc6f43f1073c.png)|
![](https://espresso.codeforces.com/9e2d8603363c8514970f3141c639422cb347d41f.png)  
---|---  
Crease lines after 1 operation (\dfrac{M}{V} = 0) .| Crease lines after 2
operations (\dfrac{M}{V} = \sqrt{2} - 1) .","def pow_m(b, p, mod):
	t = 1
	if p > 1:
		t = pow_m(b, p >> 1, mod)
		t = (t * t) % mod

	return (t * b) % mod if p % 2 else t


def div_m(a, b, mod):
	return (a * pow_m(b, mod - 2, mod)) % mod


def solve(n):
	""""""
	diff = V - M = 2sqrt(2)
	sum = V + M = sum(sqrt(2) ** i for i in range(1, n+1))

	-> M/V = (sum - diff) / (sum + diff) = A + sqrt(2) * (p / q)

	Let n = 2*k + r
	-> M/V = A + sqrt(2) * (4 * 2**k - 4) / (2**(2*k) * (2**(2*r+1) - 4) + 8 * 2**k - 4)
	""""""
	MOD = 999999893
	k, r = divmod(n, 2)
	_2_pwr_k = pow_m(2, k, MOD)
	p = (4 * _2_pwr_k - 4) % MOD
	q = (_2_pwr_k * _2_pwr_k * (2**(2*r + 1) - 4) + _2_pwr_k * 8 - 4) % MOD
	return div_m(p, q, MOD)


if __name__ == '__main__':
	t = int(input())
	while t > 0:
		t -= 1
		n = int(input())
		print(solve(n))",2,True,False,False,True,True,True,True,True,True,True,True,True,False
78,codeforces2024,human,qwen2.5-7b-instruct,"This is an easy version of the problem; it differs from the hard version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ), the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot). Then output k non-negative integers a_1, a_2, \dots,
a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to \alpha ); 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than \alpha ). 

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all k fountains belong to Bob; 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases compared to the case when all k fountains belong to Bob. 

If you output any other positive number instead of 1 that fits into a 64-bit
signed integer type, it will also be recognized as 1 . Thus, a solution to the
hard version of this problem will also pass the tests for the easy version.

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 1 
    1
    0 0 1 1 0 0 0 0 0 
    6
    1 0 0 0 
    1
    1 1 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.","def solve():
    import sys
    input = sys.stdin.read
    data = input().split()

    index = 0
    t = int(data[index])
    index += 1
    results = []

    for _ in range(t):
        n = int(data[index])
        m = int(data[index + 1])
        k = int(data[index + 2])
        index += 3

        fountains = []
        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            fountains.append((r, c))

        # Calculate the maximum area Alice can have without any fountains
        alpha = (n * m + 1) // 2

        # Determine the impact of each fountain
        a = [0] * k
        for i, (r, c) in enumerate(fountains):
            if r == 1 or c == 1 or r == n or c == m:
                a[i] = 1

        results.append((alpha, a))

    for result in results:
        print(result[0])
        print(' '.join(map(str, result[1])))

# Example usage
if __name__ == ""__main__"":
    solve()",2,False,False,False,True,False,True,True,False,False,True,False,False,False
156,codeforces2024,human,qwen2.5-7b-instruct,"[Maître Gims - Est-ce que tu m'aimes ?](https://youtu.be/6TpyRE_juyA)

ඞ

As the CEO of a startup company, you want to reward each of your k employees
with a ticket to the upcoming concert. The tickets will be on sale for n days,
and by some time travelling, you have predicted that the price per ticket at
day i will be a_i . However, to prevent ticket hoarding, the concert
organizers have implemented the following measures:

  * A person may purchase no more than m tickets per day. 
  * If a person purchases x tickets on day i , all subsequent days (i.e. from day i+1 onwards) will have their prices per ticket increased by x . 

For example, if a = [1, 3, 8, 4, 5] and you purchase 2 tickets on day 1 , they
will cost 2 in total, and the prices from day 2 onwards will become [5, 10, 6,
7] . If you then purchase 3 more tickets on day 2 , they will cost in total an
additional 15 , and the prices from day 3 onwards will become [13, 9, 10] .

Find the minimum spending to purchase k tickets.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains three integers n , m , and k (1 \le
n \le 3 \cdot 10^5, 1 \le m \le 10^9, 1 \le k \le \min(nm, 10^9) ) — the
number of sale days, the maximum amount of ticket purchasable each day, and
the number of tickets to be bought at the end.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the price per ticket for each of the upcoming n days.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the minimum amount of money needed to
purchase exactly k tickets.

Example

Input

    4
    
    4 2 3
    
    8 6 4 2
    
    4 2 8
    
    8 6 4 2
    
    5 100 1
    
    10000 1 100 10 1000
    
    6 3 9
    
    5 5 5 5 5 5

Output

    10
    64
    1
    72
    
Note

In the first test case, one optimal way to buy 3 tickets is as follows:

  * Buy 0 tickets on the first day. The prices per ticket for the remaining days are [6, 4, 2] . 
  * Buy 0 tickets on the second day. The prices per ticket for the remaining days are [4, 2] . 
  * Buy 1 ticket on the third day with cost 4 . The price per ticket for the remaining day is [3] . 
  * Buy 2 tickets on the fourth day with cost 6 . 

In the second test case, there is only one way to buy 8 tickets:

  * Buy 2 tickets on the first day with cost 16 . The prices per ticket for the remaining days are [8, 6, 4] . 
  * Buy 2 tickets on the second day with cost 16 . The prices per ticket for the remaining days are [8, 6] . 
  * Buy 2 tickets on the third day with cost 16 . The price per ticket for the remaining day is [8] . 
  * Buy 2 tickets on the fourth day with cost 16 .","t=int(input())

for _ in range(t):
    n,m,k=map(int,input().split())
    a=list(map(int,input().split()))
    a_original=a
    
    if k>=m:
        elements=k//m
        if (k%m)!=0:
            elements+=1
    else:
        elements=1
    #print(elements)    

    ko=k-m*(elements-1)
    a.sort()
    maxi=a[elements-1]
    nl=[]
    
    pind=-1
    for rr in range(n):
        if a_original[rr]<=maxi:
            pind+=1
            if pind==elements:
                break
            nl.append(a_original[rr])
            

            if a_original[rr]==maxi:
                perfect_index=pind

    price=0
    f=0
    for j in range(len(nl)):
        if nl[j]==maxi and j==perfect_index:
            price+=(nl[j]+f)*ko
            #print(price,88)
            f+=ko
        else:
            price+=(nl[j]+f)*m
            #print(price,69)
            f+=m   

    print(price)",2,True,False,False,False,False,True,True,False,False,False,False,True,False
27,codeforces2024,human,qwen2.5-7b-instruct,"You have some cards. An integer between 1 and n is written on each card:
specifically, for each i from 1 to n , you have a_i cards which have the
number i written on them.

There is also a shop which contains unlimited cards of each type. You have k
coins, so you can buy k new cards in total, and the cards you buy can contain
any integer between 1 and n .

After buying the new cards, you rearrange all your cards in a line. The score
of a rearrangement is the number of (contiguous) subarrays of length n which
are a permutation of [1, 2, \ldots, n] . What's the maximum score you can get?

Input

Each test contains multiple test cases. The first line contains the number of
test cases t\ (1\le t\le 100) . The description of the test cases follows.

The first line of each test case contains two integers n , k (1\le n \le 2
\cdot 10^5 , 0\le k \le 10^{12} ) — the number of distinct types of cards and
the number of coins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^{12} ) — the number of cards of type i you have at the
beginning.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, output a single line containing an integer: the maximum
score you can get.

Example

Input

    8
    
    1 10
    
    1
    
    2 4
    
    8 4
    
    3 4
    
    6 1 8
    
    3 9
    
    7 6 2
    
    5 3
    
    6 6 7 4 6
    
    9 7
    
    7 6 1 7 6 2 4 3 3
    
    10 10
    
    1 3 1 2 1 9 3 5 7 5
    
    9 8
    
    5 8 7 5 1 3 2 9 8

Output

    11
    15
    15
    22
    28
    32
    28
    36
    
Note

In the first test case, the final (and only) array we can get is [1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1] (including 11 single 1 s), which contains 11 subarrays
consisting of a permutation of [1] .

In the second test case, we can buy 0 cards of type 1 and 4 cards of type 2 ,
and then we rearrange the cards as following: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
1, 2, 1, 2, 1, 2] . There are 8 subarrays equal to [1, 2] and 7 subarrays
equal to [2, 1] , which make a total of 15 subarrays which are a permutation
of [1, 2] . It can also be proved that this is the maximum score we can get.

In the third test case, one of the possible optimal rearrangements is [3, 3,
1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3] .","def count_permutations(cards, coins):
    n = len(cards)
    max_score = 0

    for i in range(1, n + 1):
        num_cards = cards[i - 1]
        if num_cards > 0:
            remaining_coins = coins - (n - num_cards)
            if remaining_coins >= 0:
                score = num_cards * n
                remaining_cards = [c for c in cards if c != i]
                remaining_cards.append(remaining_coins)
                score += count_permutations(remaining_cards, remaining_coins)
                max_score = max(max_score, score)

    return max_score",2,False,False,False,False,False,False,False,False,False,False,False,False,False
270,codeforces2024,human,qwen2.5-7b-instruct,"The only difference with the medium version is the maximum length of the
input.

A parentheses sequence is a string consisting of characters ""("" and "")"", for
example ""(()(("".

A balanced parentheses sequence is a parentheses sequence which can become a
valid mathematical expression after inserting numbers and operations into it,
for example ""(()(()))"".

The balance of a parentheses sequence is defined as the number of opening
parentheses ""("" minus the number of closing parentheses "")"". For example, the
balance of the sequence ""(()(("" is 3.

A balanced parentheses sequence can also be defined as a parentheses sequence
with balance 0 such that each of its prefixes has a non-negative balance.

We define the balanced shuffle operation that takes a parentheses sequence and
returns a parentheses sequence as follows: first, for every character of the
input sequence, we compute the balance of the prefix of the sequence before
that character and write those down in a table together with the positions of
the characters in the input sequence, for example:

Prefix balance| 0| 1| 2| 1| 2| 3| 2| 1  
---|---|---|---|---|---|---|---|---  
Position| 1| 2| 3| 4| 5| 6| 7| 8  
Character| (| (| )| (| (| )| )| )  
  
Then, we sort the columns of this table in increasing order of prefix balance,
breaking ties in decreasing order of position. In the above example, we get:

Prefix balance| 0| 1| 1| 1| 2| 2| 2| 3  
---|---|---|---|---|---|---|---|---  
Position| 1| 8| 4| 2| 7| 5| 3| 6  
Character| (| )| (| (| )| (| )| )  
  
The last row of this table forms another parentheses sequence, in this case
""()(()())"". This sequence is called the result of applying the balanced
shuffle operation to the input sequence, or in short just the balanced shuffle
of the input sequence.

Surprisingly, it turns out that the balanced shuffle of any balanced
parentheses sequence is always another balanced parentheses sequence (we will
omit the proof for brevity). Even more surprisingly, the balanced shuffles of
two different balanced parentheses sequences are always different, therefore
the balanced shuffle operation is a bijection on the set of balanced
parentheses sequences of any given length (we will omit this proof, too).

You are given a balanced parentheses sequence. Find its preimage: the balanced
parentheses sequence the balanced shuffle of which is equal to the given
sequence.

Input

The only line of input contains a string s consisting only of characters ""(""
and "")"". This string is guaranteed to be a non-empty balanced parentheses
sequence with its length not exceeding 500\,000 .

Output

Print the balanced parentheses sequence t such that the balanced shuffle of t
is equal to s . It is guaranteed that the answer always exists and is unique.

Example

Input

    ()(()())
    
Output

    (()(()))","s = input()
n = len(s)

prefix_sum = [0] * (n + 1)
for i in range(n):
    prefix_sum[i + 1] = prefix_sum[i] + (1 if s[i] == '(' else -1)

pairs = [(prefix_sum[i], i) for i in range(n)]
pairs.sort()

result = []
prev_sum, prev_pos = 0, 0
for cur_sum, cur_pos in pairs:
    if cur_sum > prev_sum:
        result.append('(' * (cur_sum - prev_sum))
    result.append(s[prev_pos:cur_pos])
    prev_sum, prev_pos = cur_sum, cur_pos

print(''.join(result))",2,False,True,True,True,True,True,True,False,True,False,True,True,True
189,codeforces2024,human,qwen2.5-7b-instruct,"You are given an integer n . You choose n cells (x_1,y_1),
(x_2,y_2),\dots,(x_n,y_n) in the grid n\times n where 1\le x_i\le n and 1\le
y_i\le n .

Let \mathcal{H} be the set of distinct Manhattan distances between any pair of
cells. Your task is to maximize the size of \mathcal{H} . Examples of sets and
their construction are given in the notes.

If there exists more than one solution, you are allowed to output any.

Manhattan distance between cells (x_1,y_1) and (x_2,y_2) equals
|x_1-x_2|+|y_1-y_2| .

Input

The first line contains a single integer t (1\le t\le 50 ) — the number of
test cases.

Each of the following t lines contains a single integer n (2\le n\le 10^3 ).

Output

For each test case, output n points which maximize the size of \mathcal{H} .
It is not necessary to output an empty line at the end of the answer for each
test case.

Example

Input

    5
    
    2
    
    3
    
    4
    
    5
    
    6

Output

    1 1
    1 2
    
    2 1
    2 3
    3 1
    
    1 1
    1 3
    4 3
    4 4
    
    1 1
    1 3
    1 4
    2 1
    5 5
    
    1 4
    1 5
    1 6
    5 2
    5 5
    6 1
    
Note

In the first testcase we have n=2 . One of the possible arrangements is:

![](https://espresso.codeforces.com/4d7adaa08c9ee5ebf2a0caba13185ac968d6bcd9.png)
The arrangement with cells located in (1,1) and (1,2) . In this case
\mathcal{H}=\\{|1-1|+|1-1|,|1-1|+|2-2|,|1-1|+|1-2|\\}=\\{0,0,1\\}=\\{0,1\\} .
Hence, the size of \mathcal{H} is 2 . It can be shown that it is the greatest
possible answer.

In the second testcase we have n=3 . The optimal arrangement is:

![](https://espresso.codeforces.com/52d127e3dbe0141bb58dbdf4158586772a208758.png)
The arrangement with cells located in (2,1) , (2,3) and (3,1) .

\mathcal{H}
=\\{|2-2|+|1-1|,|2-2|+|3-3|,|3-3|+|1-1|,|2-2|+|1-3|,|2-3|+|1-1|,|2-3|+|3-1|\\}
=\\{0,0,0,2,1,3\\} =\\{0,1,2,3\\} .

For n=4 a possible arrangement is:

![](https://espresso.codeforces.com/575a6758d1f67174ceb877b32a1e89770cd2281a.png)

For n=5 a possible arrangement is:

![](https://espresso.codeforces.com/b790401b426625982c00d04cff13aceec53918b4.png)

For n=6 a possible arrangement is:

![](https://espresso.codeforces.com/d0f498905660a67115d9f58c6cbc1439ba6e509c.png)","n_ = int(input())
for _ in range(n_):
    n = int(input())
    if n == 2:
        print('1 1')
        print('1 2')
    elif n == 3:
        print('2 1')
        print('2 3')
        print('3 1')
    elif n == 4:
        print('1 1')
        print('1 3')
        print('4 3')
        print('4 4')
    else:
        for i in range(1, n-1):
            print(f'1 {i}')
        print(f'{n} {n}')
        print(f'{n} 2')
    print()",2,True,False,False,True,False,True,True,True,False,False,True,False,True
180,codeforces2024,human,qwen2.5-7b-instruct,"You are given three digits a , b , and c . Determine whether they form a
stair, a peak, or neither.

  * A stair satisfies the condition a<b<c . 
  * A peak satisfies the condition a<b>c . 

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains three digits a , b , c (0 \leq a , b
, c \leq 9 ).

Output

For each test case, output ""STAIR"" if the digits form a stair, ""PEAK"" if the
digits form a peak, and ""NONE"" otherwise (output the strings without quotes).

Example

Input

    7
    
    1 2 3
    
    3 2 1
    
    1 5 3
    
    3 4 1
    
    0 0 0
    
    4 1 7
    
    4 5 7

Output

    STAIR
    NONE
    PEAK
    PEAK
    NONE
    NONE
    STAIR","n=int(input())
for i in range(n):
    a,b,c=map(int,input().split())
    if a<b<c:
        print('STATR')
    if a<b and b>c:
        print('PEAK')
    else:
        print('NONE')",2,False,False,False,False,False,True,True,False,True,False,True,True,True
6,codeforces2024,human,qwen2.5-7b-instruct,"There are n islands, numbered 1, 2, \ldots, n . Initially, every pair of
islands is connected by a bridge. Hence, there are a total of \frac{n (n -
1)}{2} bridges.

Everule lives on island 1 and enjoys visiting the other islands using bridges.
Dominater has the power to destroy at most k bridges to minimize the number of
islands that Everule can reach using (possibly multiple) bridges.

Find the minimum number of islands (including island 1 ) that Everule can
visit if Dominater destroys bridges optimally.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers n and k (1 \le
n \le 100 , 0 \le k \le \frac{n \cdot (n - 1)}{2} ).

Output

For each test case, output the minimum number of islands that Everule can
visit if Dominater destroys bridges optimally.

Example

Input

    6
    
    2 0
    
    2 1
    
    4 1
    
    5 10
    
    5 3
    
    4 4

Output

    2
    1
    4
    1
    5
    1
    
Note

In the first test case, since no bridges can be destroyed, all the islands
will be reachable.

In the second test case, you can destroy the bridge between islands 1 and 2 .
Everule will not be able to visit island 2 but can still visit island 1 .
Therefore, the total number of islands that Everule can visit is 1 .

In the third test case, Everule always has a way of reaching all islands
despite what Dominater does. For example, if Dominater destroyed the bridge
between islands 1 and 2 , Everule can still visit island 2 by traveling by 1
\to 3 \to 2 as the bridges between 1 and 3 , and between 3 and 2 are not
destroyed.

In the fourth test case, you can destroy all bridges since k = \frac{n \cdot
(n - 1)}{2} . Everule will be only able to visit 1 island (island 1 ).","n = int(input())
for _ in range(n):
    a,b = map(int,input().split())
    c = (a*(a-1))//2
    if c - b >= a - 1:
        print(a)
    else:
        print(1)",2,False,False,False,False,False,True,True,True,False,False,False,False,False
52,codeforces2024,human,qwen2.5-7b-instruct,"Petya has an array a_i of n integers. His brother Vasya became envious and
decided to make his own array of n integers.

To do this, he found m integers b_i (m\ge n ), and now he wants to choose some
n integers of them and arrange them in a certain order to obtain an array c_i
of length n .

To avoid being similar to his brother, Vasya wants to make his array as
different as possible from Petya's array. Specifically, he wants the total
difference D = \sum_{i=1}^{n} |a_i - c_i| to be as large as possible.

Help Vasya find the maximum difference D he can obtain.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 100 ) — the number of test cases. This is followed by a
description of the test cases.

The first line of each test case contains two integers n and m (1\le n\le m\le
2 \cdot 10^5 ).

The second line of each test case contains n integers a_i (1\le a_i\le 10^9 ).
The third line of each test case contains m integers b_i (1\le b_i\le 10^9 ).

It is guaranteed that in a test, the sum of m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the maximum total difference D
that can be obtained.

Example

Input

    9
    
    4 6
    
    6 1 2 4
    
    3 5 1 7 2 3
    
    3 4
    
    1 1 1
    
    1 1 1 1
    
    5 5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    2 6
    
    5 8
    
    8 7 5 8 2 10
    
    2 2
    
    4 1
    
    9 6
    
    4 6
    
    8 10 6 4
    
    3 10 6 1 8 9
    
    3 5
    
    6 5 2
    
    1 7 9 7 2
    
    5 5
    
    9 10 6 3 7
    
    5 9 2 3 9
    
    1 6
    
    3
    
    2 7 10 1 1 5

Output

    16
    0
    12
    11
    10
    23
    15
    25
    7
    
Note

In the first example, Vasya can, for example, create the array (1, 5, 7, 2) .
Then the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .

In the second example, all the integers available to Vasya are equal to 1, so
he can only create the array (1, 1, 1) , for which the difference D = 0 .

In the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)
. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =
4+2+0+2+4 = 12 .","cases = int(input())
for i in range(cases):
	n, m  = [int(a) for a in input().split()]
	arr1  =[int(a) for a in input().split()]
	arr2 = [int(a) for a in input().split()]
	arr1.sort()
	arr2.sort()
	s1, s2, e1, e2 = 0, 0 , n-1, m - 1
	d = 0
	while (s1 < e1 and s2 < e2):
		sum1 = abs(arr1[s1]- arr2[s2]) + abs(arr1[e1]- arr2[e2])
		sum2 = abs(arr1[s1]- arr2[e2]) + abs(arr1[e1]- arr2[s2])
		d += max(sum1, sum2)
		s1 += 1
		s2 +=1
		e1 -= 1
		e2 -= 1
	if s1 == e1:
		d += max(abs(arr1[s1]- arr2[s2]), abs(arr1[s1]- arr2[e2]))
	print(d)",2,False,False,False,True,True,True,False,False,False,True,False,False,False
242,codeforces2024,human,qwen2.5-7b-instruct,"You are given n positive integers x_1, x_2, \ldots, x_n and three positive
integers n_a, n_b, n_c satisfying n_a+n_b+n_c = n .

You want to split the n positive integers into three groups, so that:

  * The first group contains n_a numbers, the second group contains n_b numbers, the third group contains n_c numbers.
  * Let s_a be the sum of the numbers in the first group, s_b be the sum in the second group, and s_c be the sum in the third group. Then s_a, s_b, s_c are the sides of a triangle with positive area.

Determine if this is possible. If this is possible, find one way to do so.

Input

Each test contains multiple test cases. The first line contains an integer t
(1\le t\le 100\,000 ) — the number of test cases. The descriptions of the t
test cases follow.

The first line of each test case contains the integers n, n_a, n_b, n_c (3
\leq n \leq 200\,000, 1\leq n_a,n_b,n_c \leq n-2, n_a+n_b+n_c = n ) — the
number of integers to split into three groups, and the desired sizes of the
three groups.

The second line of each test case contains n integers x_1, x_2, \ldots, x_n (1
\leq x_i \leq 10^{9} ).

It is guaranteed that the sum of n over all test cases does not exceed
200\,000 .

Output

For each test case, print \texttt{YES} if it is possible to split the numbers
into three groups satisfying all the conditions. Otherwise, print \texttt{NO}
.

If such a split exists, then describe the three groups as follows.

On the next line, print n_a integers a_1, a_2, \ldots, a_{n_a} — the numbers
in the first group.

On the next line, print n_b integers b_1, b_2, \ldots, b_{n_b} — the numbers
in the second group.

On the next line, print n_c integers c_1, c_2, \ldots, c_{n_c} — the numbers
in the third group.

These n_a+n_b+n_c=n integers should be a permutation of x_1, x_2, \ldots, x_n
, and they should satisfy the conditions from the statement.

If there are multiple solutions, print any of them.

Example

Input

    4
    
    6 2 2 2
    
    1 1 1 1 1 1
    
    5 3 1 1
    
    1 1 1 1 1
    
    6 2 2 2
    
    1 1 1 1 1 3
    
    8 1 2 5
    
    16 1 1 1 1 1 1 12

Output

    YES
    1 1 
    1 1 
    1 1 
    NO
    NO
    YES
    16 
    12 1 
    1 1 1 1 1 
    
Note

In the first test case, we can put two 1 s into each group: the sum in each
group would be 2 , and there exists a triangle with positive area and sides 2
, 2 , 2 .

In the second and third test cases, it can be shown that there is no such way
to split numbers into groups.

In the fourth test case, we can put number 16 into the first group, with sum
16 , numbers 12 and 1 into the second group, with sum 13 , and the remaining
five 1 s into the third group, with sum 5 , as there exists a triangle with
positive area and sides 16, 13, 5 .","def solve():
    t = int(input())
    for _ in range(t):
        n, na, nb, nc = map(int, input().split())
        x = list(map(int, input().split()))

        x.sort(reverse=True)  # Sort in descending order

        group_a = x[:na]
        group_b = x[na:na + nb]
        group_c = x[na + nb:]

        sum_a = sum(group_a)
        sum_b = sum(group_b)
        sum_c = sum(group_c)

        # Check if the triangle inequality holds
        if sum_a + sum_b > sum_c and sum_b + sum_c > sum_a and sum_c + sum_a > sum_b:
            print(""YES"")
            print("" "".join(map(str, group_a)))
            print("" "".join(map(str, group_b)))
            print("" "".join(map(str, group_c)))
        else:
            print(""NO"")

if __name__ == ""__main__"":
    solve()",2,False,False,False,True,True,True,True,True,True,True,False,True,True
255,codeforces2024,human,qwen2.5-7b-instruct,"There are n slimes placed in a line. The slimes are numbered from 1 to n in
order from left to right. The size of the i -th slime is a_i .

Every second, the following happens: exactly one slime eats one of its
neighbors and increases its size by the eaten neighbor's size. A slime can eat
its neighbor only if it is strictly bigger than this neighbor. If there is no
slime which is strictly bigger than one of its neighbors, the process ends.

For example, suppose n = 5 , a = [2, 2, 3, 1, 4] . The process can go as
follows:

  * first, the 3 -rd slime eats the 2 -nd slime. The size of the 3 -rd slime becomes 5 , the 2 -nd slime is eaten. 
  * then, the 3 -rd slime eats the 1 -st slime (they are neighbors since the 2 -nd slime is already eaten). The size of the 3 -rd slime becomes 7 , the 1 -st slime is eaten. 
  * then, the 5 -th slime eats the 4 -th slime. The size of the 5 -th slime becomes 5 , the 4 -th slime is eaten. 
  * then, the 3 -rd slime eats the 5 -th slime (they are neighbors since the 4 -th slime is already eaten). The size of the 3 -rd slime becomes 12 , the 5 -th slime is eaten. 

For each slime, calculate the minimum number of seconds it takes for this
slime to be eaten by another slime (among all possible ways the process can
go), or report that it is impossible.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 3
\cdot 10^5 ) — the number of slimes.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9
).

The sum of n over all test cases doesn't exceed 3 \cdot 10^5 .

Output

For each test case, print n integers. The i -th integer should be equal to the
minimum number of seconds it takes for the i -th slime to be eaten by another
slime or -1 if it is impossible.

Example

Input

    4
    
    4
    
    3 2 4 2
    
    3
    
    1 2 3
    
    5
    
    2 2 3 1 1
    
    7
    
    4 2 3 6 1 1 8

Output

    2 1 2 1 
    1 1 -1 
    2 1 -1 1 2 
    2 1 1 3 1 1 4","from bisect import bisect_left as bl

def bin_search(a, x):
    # Perform binary search to find the position where the prefix sum is just greater than x
    if x < 0:
        return -1
    inx = bl(a, x)
    if inx < len(a) and a[inx] == x:
        return inx + 1
    return inx

def ss(a, n):
    # Initialize prefix sum and last different index arrays
    left = [0]
    last = [-1]
    ans = [-1] * n
    
    # Fill the last different index array
    for i in range(1, n):
        if a[i] != a[i - 1]:
            last.append(i)
        else:
            last.append(last[-1])
    
    # Calculate prefix sums
    for i in a:
        left.append(left[-1] + i)
    
    # Determine the minimum time for each slime to be eaten
    for i in range(1, n):
        if a[i] < a[i - 1]:
            ans[i] = 1
            continue
        x = left[i] - a[i] - 1
        inx = bin_search(left, x)
        inx2 = last[i - 1]
        
        if inx2 < inx:
            inx = inx2
        
        if inx < 0:
            continue
        ans[i] = i + 1 - inx
    
    return ans

# Process each test case
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    
    # Calculate minimum times in both directions
    ans = ss(a, n)
    ans2 = ss(a[::-1], n)
    ans2 = ans2[::-1]
    
    # Combine results from both directions
    for i in range(n):
        if ans[i] == -1 or ans2[i] == -1:
            ans[i] = max(ans[i], ans2[i])
        else:
            ans[i] = min(ans[i], ans2[i])
    
    # Output the result for the current test case
    print(*ans)",2,True,False,False,True,False,True,True,True,False,False,True,True,True
258,codeforces2024,human,qwen2.5-7b-instruct,"You are given a positive integer x . Find any array of integers a_0, a_1,
\ldots, a_{n-1} for which the following holds:

  * 1 \le n \le 32 , 
  * a_i is 1 , 0 , or -1 for all 0 \le i \le n - 1 , 
  * x = \displaystyle{\sum_{i=0}^{n - 1}{a_i \cdot 2^i}} , 
  * There does not exist an index 0 \le i \le n - 2 such that both a_{i} \neq 0 and a_{i + 1} \neq 0 . 

It can be proven that under the constraints of the problem, a valid array
always exists.

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains a single positive integer x (1 \le x
< 2^{30} ).

Output

For each test case, output two lines.

On the first line, output an integer n (1 \le n \le 32 ) — the length of the
array a_0, a_1, \ldots, a_{n-1} .

On the second line, output the array a_0, a_1, \ldots, a_{n-1} .

If there are multiple valid arrays, you can output any of them.

Example

Input

    7
    
    1
    
    14
    
    24
    
    15
    
    27
    
    11
    
    19

Output

    1
    1
    5
    0 -1 0 0 1
    6
    0 0 0 -1 0 1
    5
    -1 0 0 0 1
    6
    -1 0 -1 0 0 1
    5
    -1 0 -1 0 1
    5
    -1 0 1 0 1

Note

In the first test case, one valid array is [1] , since (1) \cdot 2^0 = 1 .

In the second test case, one possible valid array is [0,-1,0,0,1] , since (0)
\cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 =
-2 + 16 = 14 .","for x in[*map(int,open(0))][1:]:
 r=[]
 while x:r+=x%2*(1-(x&2)),;x=x-r[-1]>>1
 print(len(r),*r)",2,True,False,False,True,False,True,False,False,False,False,True,True,False
255,codeforces2024,human,qwen2.5-7b-instruct,"There are n slimes placed in a line. The slimes are numbered from 1 to n in
order from left to right. The size of the i -th slime is a_i .

Every second, the following happens: exactly one slime eats one of its
neighbors and increases its size by the eaten neighbor's size. A slime can eat
its neighbor only if it is strictly bigger than this neighbor. If there is no
slime which is strictly bigger than one of its neighbors, the process ends.

For example, suppose n = 5 , a = [2, 2, 3, 1, 4] . The process can go as
follows:

  * first, the 3 -rd slime eats the 2 -nd slime. The size of the 3 -rd slime becomes 5 , the 2 -nd slime is eaten. 
  * then, the 3 -rd slime eats the 1 -st slime (they are neighbors since the 2 -nd slime is already eaten). The size of the 3 -rd slime becomes 7 , the 1 -st slime is eaten. 
  * then, the 5 -th slime eats the 4 -th slime. The size of the 5 -th slime becomes 5 , the 4 -th slime is eaten. 
  * then, the 3 -rd slime eats the 5 -th slime (they are neighbors since the 4 -th slime is already eaten). The size of the 3 -rd slime becomes 12 , the 5 -th slime is eaten. 

For each slime, calculate the minimum number of seconds it takes for this
slime to be eaten by another slime (among all possible ways the process can
go), or report that it is impossible.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 3
\cdot 10^5 ) — the number of slimes.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9
).

The sum of n over all test cases doesn't exceed 3 \cdot 10^5 .

Output

For each test case, print n integers. The i -th integer should be equal to the
minimum number of seconds it takes for the i -th slime to be eaten by another
slime or -1 if it is impossible.

Example

Input

    4
    
    4
    
    3 2 4 2
    
    3
    
    1 2 3
    
    5
    
    2 2 3 1 1
    
    7
    
    4 2 3 6 1 1 8

Output

    2 1 2 1 
    1 1 -1 
    2 1 -1 1 2 
    2 1 1 3 1 1 4","import bisect

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    # Create a prefix sum array
    pref = [arr[i] for i in range(n)]
    for i in range(1, n):
        pref[i] += pref[i-1]
    
    # Initialize the index and answer array
    ind = -1
    ans = [10**9 for i in range(n)]
    
    # Left to right pass
    for i in range(n):
        # Calculate the current value to check against prefix sums
        curr = pref[i] - 2 * arr[i]
        ind1 = bisect.bisect_left(pref, curr)
        
        # Update the minimum index
        ind = min(ind, ind1)
        
        # Check if the current slime can be eaten
        if ind >= 0 and curr > 0:
            ans[i] = (i - ind)
        
        # Check if the current slime can be eaten by the previous one
        if i - 1 >= 0 and arr[i] != arr[i-1]:
            if arr[i] < arr[i-1]:
                ans[i] = 1
                ind = i
    
    # Right to left pass
    ind = n
    for i in range(n-1, -1, -1):
        # Calculate the current value to check against prefix sums
        curr = pref[i] + arr[i] + 1
        ind1 = bisect.bisect_left(pref, curr)
        
        # Update the maximum index
        ind = max(ind, ind1)
        
        # Check if the current slime can be eaten
        if ind < n and curr <= pref[-1]:
            ans[i] = min(ans[i], (ind - i))
        
        # Check if the current slime can be eaten by the next one
        if i + 1 < n and arr[i] != arr[i+1]:
            if arr[i] < arr[i+1]:
                ans[i] = 1
                ind = i
    
    # Replace large numbers with -1 to indicate impossibility
    for i in range(n):
        if ans[i] == 10**9:
            ans[i] = -1
    
    # Print the result for the current test case
    print(*ans)

# Read the number of test cases
for _ in range(int(input())):
    solve()",2,False,False,False,True,False,True,True,False,True,False,True,False,False
215,codeforces2024,human,qwen2.5-7b-instruct,"Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.","t=int(input())
for _ in range(t):
    n,a,b=map(int,input().split())
    if b<=a:
        print(n*a)
    else:
        if (b-a)>=n:
            print(int((2*b-n+1)*n/2))
        else:
            print(int((b-a)/2*(b-a+1)+a*n))",2,False,False,False,"- The logic handles all edge cases correctly, such as when `b` is less than or equal to `a` or when `b - a` is greater than or equal to `n`.
   - The formulas used for calculating the profit are mathematically sound and match the problem's requirements.

Given the analysis, the program appears to correctly implement the solution based on the provided problem description and examples.

Correctness:",True,True,True,False,True,True,True,True,True
271,codeforces2024,human,qwen2.5-7b-instruct,"The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 30 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1","n = int(input())
 
w = []
q = {}
i = -1
 
def f(a,b):
    return (a+2)*(b+4)-1 if a >= b else (a+5)*(b+1)-1
 
while len(w) < n:
    i += 1
    if f(i,i) in q:
        continue
    if any(f(i,j) in q for j in w):
        continue
    if any(f(j,i) in q for j in w):
        continue
    q1 = {f(i,i): (len(w),len(w))}
    ok = True
    for r,j in enumerate(w):
        v = f(i,j)
        if v in q1:
            ok = False
            break
        q1[v] = len(w),r
    if not ok:
        continue
    for r,j in enumerate(w):
        v = f(j,i)
        if v in q1:
            ok = False
            break
        q1[v] = r,len(w)
    if not ok:
        continue
    q.update(q1)
    w.append(i)
 
for i in w:
    print(""XO""+i*""X"")
    
t = int(input())
for _ in range(t):
    x = int(input())
    u,v = q[x]
    print(u+1, v+1)",2,True,False,False,True,False,True,True,True,True,True,False,False,False
17,codeforces2024,human,qwen2.5-7b-instruct,"Define the binary encoding of a finite set of natural numbers T \subseteq
\\{0,1,2,\ldots\\} as f(T) = \sum\limits_{i \in T} 2^i . For example,
f(\\{0,2\\}) = 2^0 + 2^2 = 5 and f(\\{\\}) = 0 . Notice that f is a bijection
from all such sets to all non-negative integers. As such, f^{-1} is also
defined.

You are given an integer n along with 2^n-1 sets V_1,V_2,\ldots,V_{2^n-1} .

Find all sets S that satisfy the following constraint:

  * S \subseteq \\{0,1,\ldots,n-1\\} . Note that S can be empty. 
  * For all non-empty subsets T \subseteq \\{0,1,\ldots,n-1\\} , |S \cap T| \in V_{f(T)} . 

Due to the large input and output, both input and output will be given in
terms of binary encodings of the sets.

Input

The first line of input contains a single integer n (1 \leq n \leq 20 ).

The second line of input contains 2^n-1 integers v_1,v_2,\ldots,v_{2^n-1} (0
\leq v_i < 2^{n+1} ) — the sets V_i given in their binary encoding where V_i =
f^{-1}(v_i) .

Output

The first line of output should contain an integer k indicating the number of
possible S .

In the following k lines, you should output f(S) for all possible S in
increasing order.

Examples

Input

    3
    
    15 15 15 15 15 15 12

Output

    4
    3
    5
    6
    7
    
Input

    5
    
    63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63

Output

    1
    19
    
Note

In the first test case, one possible S is f^{-1}(3) = \\{0,1\\} . All the non-
empty subsets T \subseteq \\{0,1,2\\} and the corresponding |S \cap T| , f(T)
and V_f(T) are as follows:

T | |S\cap T| | f(T) | V_{f(T)}   
---|---|---|---  
\\{0\\} | 1 | 1 | \\{0,1,2,3\\}   
\\{1\\} | 1 | 2 | \\{0,1,2,3\\}   
\\{2\\} | 0 | 4 | \\{0,1,2,3\\}   
\\{0,1\\} | 2 | 3 | \\{0,1,2,3\\}   
\\{0,2\\} | 1 | 5 | \\{0,1,2,3\\}   
\\{1,2\\} | 1 | 6 | \\{0,1,2,3\\}   
\\{0,1,2\\} | 2 | 7 | \\{2,3\\}","import itertools

def solve(n, V):
    V = [bin(i)[2:] for i in V]
    S = []
    for i in range(2**n):
        s = bin(i)[2:]
        if len(s) < n:
            s = '0'*(n-len(s)) + s
        valid = True
        for j in range(n):
            if s[j] == '1':
                sub_s = s[:j] + s[j+1:]
                if not any(sub_s.count('1') == int(v, 2) for v in V):
                    valid = False
                    break
        if valid:
            S.append(bin(int(s, 2)+1)[2:])
    S.sort()
    print(len(S))
    for s in S:
        print(int(s, 2))

# Test cases
print(""Test Case 1:"")
solve(3, [15]*7)
print(""\nTest Case 2:"")
solve(5, [63]*16)",2,False,False,False,True,False,True,True,True,False,False,False,False,True
40,codeforces2024,human,qwen2.5-7b-instruct,"There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .","MOD = 998244353

def count_valid_arrays(n, p):
    # dp[i][j] will store the number of ways to achieve prefix sum j using first i elements
    dp = [0] * (2 * n + 1)
    offset = n  # To handle negative indices, we use an offset
    dp[offset] = 1  # Base case: one way to have prefix sum 0 with 0 elements
    
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        for j in range(2 * n + 1):
            if dp[j] > 0:
                # If we can achieve prefix sum j-offset with i-1 elements
                # We can achieve j-offset+1 with i elements by adding 1
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                # We can achieve j-offset-1 with i elements by adding -1
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        dp = new_dp
    
    # We need to count the number of ways to achieve the final prefix sum p_n
    # which is p[-1] in the sorted array
    final_sum = p[-1] + offset
    return dp[final_sum]

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        p = list(map(int, data[index:index + n]))
        index += n
        
        result = count_valid_arrays(n, p)
        results.append(result)
    
    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()",2,False,False,False,True,False,True,True,False,False,False,True,False,True
227,codeforces2024,human,qwen2.5-7b-instruct,"You are given two integers x and y .

Output two integers: the minimum of x and y , followed by the maximum of x and
y .

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The only line of each test case contains two space-separated integers x and y
(0 \leq x, y \leq 9 ).

Output

For each test case, output two integers: the minimum of x and y , followed by
the maximum of x and y .

Example

Input

    10
    
    1 9
    
    8 4
    
    1 4
    
    3 4
    
    2 0
    
    2 4
    
    6 9
    
    3 3
    
    0 0
    
    9 9

Output

    1 9
    4 8
    1 4
    3 4
    0 2
    2 4
    6 9
    3 3
    0 0
    9 9","t=int(input())
for i in range(t):
    x,y=map(int,input().split())

    print(min(x,y),max(x,y))",2,True,True,True,True,True,True,True,True,True,True,True,True,True
77,codeforces2024,human,qwen2.5-7b-instruct,"This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.","def solution():
    n, m, k = list(map(int, input().split()))
    r_c = [list(map(lambda x: int(x)-1, input().split())) for _ in range(k)]
    idxs = list(range(k))
    idxs.sort(key=lambda x: (r_c[x][X], -r_c[x][Y]))
    result = [0]*k
    total = diff = 0
    prev, curr = 0, n
    x2 = y2 = -1
    j = -1
    for i in idxs:
        y, x = r_c[i]
        y = n-(y+1)
        if y >= curr:
            if y < y2:
                diff += (x-x2)*(y2-curr)
                x2, y2 = x, y
            continue
        if j != -1:
            diff += (x-x2)*(y2-curr)
            result[j] = diff
        j = i
        x2, y2, diff = x, curr, 0
        total += (x-prev)*curr
        prev, curr = x, y
    diff += (m-x2)*(y2-curr)
    result[j] = diff
    total += (m-prev)*curr
    return f'{total}\n{"" "".join(map(str, result))}'
 
Y, X = list(range(2))
for _ in range(int(input())):
    print(solution())",2,True,False,False,True,False,True,True,True,False,False,True,True,True
43,codeforces2024,human,qwen2.5-7b-instruct,"Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)","def min_thick_walls(n, edges, student_types):
    # Create an adjacency list to represent the tree
    tree = [[] for _ in range(n)]
    for i, a in enumerate(edges, start=2):
        tree[i-1].append(a-1)
        tree[a-1].append(i-1)
    
    # Function to traverse the tree and count the minimum number of thick walls
    def traverse(node, parent):
        partying_neighbors = 0
        for neighbor in tree[node]:
            if neighbor != parent:
                partying_neighbors += traverse(neighbor, node)
        if student_types[node] == 'P':
            return partying_neighbors + 1
        elif student_types[node] == 'S':
            return max(0, partying_neighbors - 1)
        else:
            return partying_neighbors
    
    # Start the traversal from the root (assuming node 0 is the root)
    return traverse(0, -1)

# Main function to handle multiple test cases
def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        edges = list(map(int, input().split()))
        student_types = input().strip()
        result = min_thick_walls(n, edges, student_types)
        print(result)

if __name__ == ""__main__"":
    main()",2,False,False,False,True,False,True,True,True,False,True,True,True,True
97,codeforces2024,human,qwen2.5-7b-instruct,"The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.","from math import ceil
t = int(input())
for _ in range(t):
    a, b, c = map(int, input().split())
    extra = b%3
    if extra and 3 - extra > c:
        print(-1)
    else:
        if 3 - extra <= c:
            c -= 3 - extra
        print(a + ceil(b/3) + ceil(c/3))",2,False,False,False,True,False,True,True,True,True,False,True,True,True
189,codeforces2024,human,qwen2.5-7b-instruct,"You are given an integer n . You choose n cells (x_1,y_1),
(x_2,y_2),\dots,(x_n,y_n) in the grid n\times n where 1\le x_i\le n and 1\le
y_i\le n .

Let \mathcal{H} be the set of distinct Manhattan distances between any pair of
cells. Your task is to maximize the size of \mathcal{H} . Examples of sets and
their construction are given in the notes.

If there exists more than one solution, you are allowed to output any.

Manhattan distance between cells (x_1,y_1) and (x_2,y_2) equals
|x_1-x_2|+|y_1-y_2| .

Input

The first line contains a single integer t (1\le t\le 50 ) — the number of
test cases.

Each of the following t lines contains a single integer n (2\le n\le 10^3 ).

Output

For each test case, output n points which maximize the size of \mathcal{H} .
It is not necessary to output an empty line at the end of the answer for each
test case.

Example

Input

    5
    
    2
    
    3
    
    4
    
    5
    
    6

Output

    1 1
    1 2
    
    2 1
    2 3
    3 1
    
    1 1
    1 3
    4 3
    4 4
    
    1 1
    1 3
    1 4
    2 1
    5 5
    
    1 4
    1 5
    1 6
    5 2
    5 5
    6 1
    
Note

In the first testcase we have n=2 . One of the possible arrangements is:

![](https://espresso.codeforces.com/4d7adaa08c9ee5ebf2a0caba13185ac968d6bcd9.png)
The arrangement with cells located in (1,1) and (1,2) . In this case
\mathcal{H}=\\{|1-1|+|1-1|,|1-1|+|2-2|,|1-1|+|1-2|\\}=\\{0,0,1\\}=\\{0,1\\} .
Hence, the size of \mathcal{H} is 2 . It can be shown that it is the greatest
possible answer.

In the second testcase we have n=3 . The optimal arrangement is:

![](https://espresso.codeforces.com/52d127e3dbe0141bb58dbdf4158586772a208758.png)
The arrangement with cells located in (2,1) , (2,3) and (3,1) .

\mathcal{H}
=\\{|2-2|+|1-1|,|2-2|+|3-3|,|3-3|+|1-1|,|2-2|+|1-3|,|2-3|+|1-1|,|2-3|+|3-1|\\}
=\\{0,0,0,2,1,3\\} =\\{0,1,2,3\\} .

For n=4 a possible arrangement is:

![](https://espresso.codeforces.com/575a6758d1f67174ceb877b32a1e89770cd2281a.png)

For n=5 a possible arrangement is:

![](https://espresso.codeforces.com/b790401b426625982c00d04cff13aceec53918b4.png)

For n=6 a possible arrangement is:

![](https://espresso.codeforces.com/d0f498905660a67115d9f58c6cbc1439ba6e509c.png)","def solve(n):
    # For n, we will output n points
    # A simple strategy is to place points in a diagonal or near-diagonal pattern
    points = []
    for i in range(n):
        # Place points in a diagonal pattern
        # (i+1, (i*2 % n) + 1) ensures we stay within bounds and spread points
        x = i + 1
        y = (i * 2 % n) + 1
        points.append((x, y))
    return points

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    results = []
    
    for i in range(t):
        n = int(data[i + 1])
        result = solve(n)
        results.append(result)
    
    for result in results:
        for x, y in result:
            print(x, y)

if __name__ == ""__main__"":
    main()",2,False,False,True,True,True,True,True,False,True,True,False,True,False
43,codeforces2024,human,qwen2.5-7b-instruct,"Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)","for _ in range(int(input())):
    n = int(input())
    # Read the parent array, with a dummy -1 at the start for 1-based indexing
    fa = [-1] + list(map(int, input().split()))
    # Read the string representing student types
    S = input()
    
    # Initialize dp arrays for isolation and non-isolation scenarios
    dp1, dp2 = [0] * (n + 1), [0] * (n + 1)
    
    # Traverse the tree from the last node to the first (bottom-up)
    for i in range(n - 1, -1, -1):
        if S[i] == ""S"":
            dp1[i] = float(""inf"")  # Must isolate sleepy students
        elif S[i] == ""P"":
            dp2[i] = float(""inf"")  # Must not allow music to pass through partying students

        # Get the parent of the current node
        p = fa[i] - 1
        if p != -1:
            # Update the parent's dp values based on the current node's values
            dp1[p] += min(dp1[i], dp2[i] + 1)
            dp2[p] += min(dp1[i] + 1, dp2[i])

    # Output the minimum number of thick walls needed for the root
    print(min(dp1[0], dp2[0]))",2,True,False,False,True,False,True,True,True,False,True,False,True,True
270,codeforces2024,human,qwen2.5-7b-instruct,"The only difference with the medium version is the maximum length of the
input.

A parentheses sequence is a string consisting of characters ""("" and "")"", for
example ""(()(("".

A balanced parentheses sequence is a parentheses sequence which can become a
valid mathematical expression after inserting numbers and operations into it,
for example ""(()(()))"".

The balance of a parentheses sequence is defined as the number of opening
parentheses ""("" minus the number of closing parentheses "")"". For example, the
balance of the sequence ""(()(("" is 3.

A balanced parentheses sequence can also be defined as a parentheses sequence
with balance 0 such that each of its prefixes has a non-negative balance.

We define the balanced shuffle operation that takes a parentheses sequence and
returns a parentheses sequence as follows: first, for every character of the
input sequence, we compute the balance of the prefix of the sequence before
that character and write those down in a table together with the positions of
the characters in the input sequence, for example:

Prefix balance| 0| 1| 2| 1| 2| 3| 2| 1  
---|---|---|---|---|---|---|---|---  
Position| 1| 2| 3| 4| 5| 6| 7| 8  
Character| (| (| )| (| (| )| )| )  
  
Then, we sort the columns of this table in increasing order of prefix balance,
breaking ties in decreasing order of position. In the above example, we get:

Prefix balance| 0| 1| 1| 1| 2| 2| 2| 3  
---|---|---|---|---|---|---|---|---  
Position| 1| 8| 4| 2| 7| 5| 3| 6  
Character| (| )| (| (| )| (| )| )  
  
The last row of this table forms another parentheses sequence, in this case
""()(()())"". This sequence is called the result of applying the balanced
shuffle operation to the input sequence, or in short just the balanced shuffle
of the input sequence.

Surprisingly, it turns out that the balanced shuffle of any balanced
parentheses sequence is always another balanced parentheses sequence (we will
omit the proof for brevity). Even more surprisingly, the balanced shuffles of
two different balanced parentheses sequences are always different, therefore
the balanced shuffle operation is a bijection on the set of balanced
parentheses sequences of any given length (we will omit this proof, too).

You are given a balanced parentheses sequence. Find its preimage: the balanced
parentheses sequence the balanced shuffle of which is equal to the given
sequence.

Input

The only line of input contains a string s consisting only of characters ""(""
and "")"". This string is guaranteed to be a non-empty balanced parentheses
sequence with its length not exceeding 500\,000 .

Output

Print the balanced parentheses sequence t such that the balanced shuffle of t
is equal to s . It is guaranteed that the answer always exists and is unique.

Example

Input

    ()(()())
    
Output

    (()(()))","s = input()
q=[[]]
it = iter(q)
cur = next(it)
for c in s:
    if c==""("":
        x = []
        cur.append(x)
        q.append(x)
    if c=="")"":
        cur = next(it)
 
def dumps(u):
    q = [(0,v) for v in u]
    s = []
    while q:
        pc,u = q.pop()
        if pc==0:
            s.append(""("")
            q.append((1,u))
            q.extend((0,v) for v in u)
        if pc==1:
            s.append("")"")
    return """".join(s)
 
print(dumps(q[0]))",2,True,False,False,True,False,True,True,False,True,True,True,True,True
267,codeforces2024,human,qwen2.5-7b-instruct,"You are given a string s , consisting of lowercase Latin letters and/or
question marks.

A tandem repeat is a string of an even length such that its first half is
equal to its second half.

A string a is a substring of a string b if a can be obtained from b by the
deletion of several (possibly, zero or all) characters from the beginning and
several (possibly, zero or all) characters from the end.

Your goal is to replace each question mark with some lowercase Latin letter in
such a way that the length of the longest substring that is a tandem repeat is
maximum possible.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
testcases.

The only line of each testcase contains a string s (1 \le |s| \le 5000 ),
consisting only of lowercase Latin letters and/or question marks.

The total length of the strings over all testcases doesn't exceed 5000 .

Output

For each testcase, print a single integer — the maximum length of the longest
substring that is a tandem repeat after you replace each question mark in the
string with some lowercase Latin letter.

If it's impossible to make any tandem repeat substrings in the string, print 0
.

Example

Input

    4
    
    zaabaabz
    
    ?????
    
    code?????s
    
    codeforces

Output

    6
    4
    10
    0","def find_max_mirror_length(s):
    # Initialize the maximum length of tandem repeat found
    max_len = 0
    
    # Iterate over possible half-lengths of tandem repeats, starting from the largest
    for sub_len in range(len(s) // 2, 0, -1):
        match_count = 0  # Counter for matching characters in the current window
        
        # Slide a window of size `sub_len` over the string
        for i in range(len(s) - sub_len):
            # Check if the current character and its counterpart in the second half match
            if s[i] == s[i + sub_len] or s[i] == '?' or s[i + sub_len] == '?':
                match_count += 1  # Increment match count if they match or can be made to match
                
                # If a full tandem repeat of this length is found
                if match_count == sub_len:
                    max_len = max(max_len, sub_len)  # Update the maximum length found
                    break  # No need to check further for this length
            else:
                match_count = 0  # Reset match count if a mismatch is found
    
    return max_len  # Return the maximum half-length found

def main():
    test_cases = int(input())  # Read the number of test cases
    for _ in range(test_cases):
        s = input()  # Read the string for the current test case
        ans = find_max_mirror_length(s)  # Find the maximum tandem repeat length
        print(ans * 2)  # Output the full length of the tandem repeat

if __name__ == ""__main__"":
    main()",2,True,True,False,True,True,True,True,False,True,True,False,False,False
266,codeforces2024,human,qwen2.5-7b-instruct,"There is a grid, consisting of 2 rows and n columns. The rows are numbered
from 1 to 2 from top to bottom. The columns are numbered from 1 to n from left
to right. Each cell of the grid contains an arrow pointing either to the left
or to the right. No arrow points outside the grid.

There is a robot that starts in a cell (1, 1) . Every second, the following
two actions happen one after another:

  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); 
  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). 

Your task is to determine whether the robot can reach the cell (2, n) .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer (2 \le n \le 2
\cdot 10^5 ).

The second line contains a string consisting of exactly n characters < and/or
> — the first row of the grid.

The third line contains a string consisting of exactly n characters < and/or >
— the second row of the grid.

Additional constraints on the input:

  * n is even; 
  * there are no arrows pointing outside the grid; 
  * the sum of n over all test cases doesn't exceed 2 \cdot 10^5 . 

Output

For each test case, print YES if the robot can reach the cell (2, n) ;
otherwise, print NO.

You can print each letter in any case. For example, yes, Yes, YeS will all be
recognized as positive answer.

Example

Input

    4
    
    4
    
    >><<
    
    >>><
    
    2
    
    ><
    
    ><
    
    4
    
    >>><
    
    >><<
    
    6
    
    >><<><
    
    ><>>><

Output

    YES
    YES
    NO
    YES
    
Note

In the first example, one of the possible paths looks as follows: (1, 1)
\rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 4) .

In the second example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) .

In the third example, there is no way to reach the cell (2, 4) .

In the fourth example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (1, 2) \rightarrow (1, 3)
\rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (2, 5) \rightarrow (2, 6) .","t = int(input())
for _ in range(t):
    n = int(input())
    a = input()
    b = input()
    for  i in range(1 ,n ,2):
        if (i+1<n and a[i]== b[i+1] == ""<"") or (a[i] == b[i-1] == ""<"")  :
            print(""No"")
            break
    else:
        print(""yes"")",2,True,False,False,False,False,False,False,False,False,True,False,False,False
202,codeforces2024,human,qwen2.5-7b-instruct,"You have a strip of paper with a binary string s of length n . You can fold
the paper in between any pair of adjacent digits.

A set of folds is considered valid if after the folds, all characters that are
on top of or below each other match. Note that all folds are made at the same
time, so the characters don't have to match in between folds.

For example, these are valid foldings of s = \mathtt{110110110011} and s =
\mathtt{01110} :

![](https://espresso.codeforces.com/a961dc7cc221603a7d5a488247ba5439ce7444da.png)

The length of the folded strip is the length seen from above after all folds
are made. So for the two above examples, after the folds shown above, the
lengths would be 7 and 3 , respectively.

Notice that for the above folding of s = \mathtt{01110} , if we made either of
the two folds on their own, that would not be a valid folding. However,
because we don't check for validity until all folds are made, this folding is
valid.

After performing a set of valid folds, what is the minimum length strip you
can form?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the size of the strip.

The second line of each test case contains a string s of n characters '0' and
'1' — a description of the digits on the strip.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, output a single integer — the minimum possible length of
the strip after a valid folding.

Example

Input

    6
    
    6
    
    101101
    
    1
    
    0
    
    12
    
    110110110011
    
    5
    
    01110
    
    4
    
    1111
    
    2
    
    01

Output

    3
    1
    3
    3
    1
    2
    
Note

For the first example case, one optimal folding is to fold the strip in the
middle, which produces a strip of length 3.

The third and fourth example cases correspond to the images above. Note that
the folding shown above for s = \mathtt{110110110011} is not of minimal
length.","def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        
        mn = 0
        mx = 0
        cur = 0

        for c in s:

            if (cur % 2 == 0) == (c == '1'):
                cur = cur + 1
            else:
                cur = cur - 1

            mn = min(mn, cur)
            mx = max(mx, cur)

        # print(""===>"",mx)
        # print(""===>"",mn)
        
        print(mx - mn)
        
        
        
if __name__==""__main__"":
    solve()",2,True,False,False,True,True,True,True,False,True,True,True,True,False
343,codeforces2024,human,qwen2.5-7b-instruct,"There is a hidden array a of n positive integers. You know that a is a
palindrome, or in other words, for all 1 \le i \le n , a_i = a_{n + 1 - i} .
You are given the sums of all but one of its distinct subarrays, in arbitrary
order. The subarray whose sum is not given can be any of the \frac{n(n+1)}{2}
distinct subarrays of a .

Recover any possible palindrome a . The input is chosen such that there is
always at least one array a that satisfies the conditions.

An array b is a subarray of a if b can be obtained from a by the deletion of
several (possibly, zero or all) elements from the beginning and several
(possibly, zero or all) elements from the end.

Input

The first line of the input contains a single integer t (1 \le t \le 200 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (3 \le n \le 1000
) — the size of the array a .

The next line of each test case contains \frac{n(n+1)}{2} - 1 integers s_i
(1\leq s_i \leq 10^9 ) — all but one of the subarray sums of a .

It is guaranteed that the sum of n over all test cases does not exceed 1000 .

Additional constraint on the input: There is always at least one valid
solution.

Hacks are disabled for this problem.

Output

For each test case, print one line containing n positive integers a_1, a_2,
\cdots a_n — any valid array a . Note that a must be a palindrome.

If there are multiple solutions, print any.

Example

Input

    7
    
    3
    
    1 2 3 4 1
    
    4
    
    18 2 11 9 7 11 7 2 9
    
    4
    
    5 10 5 16 3 3 13 8 8
    
    4
    
    8 10 4 6 4 20 14 14 6
    
    5
    
    1 2 3 4 5 4 3 2 1 1 2 3 2 1
    
    5
    
    1 1 2 2 2 3 3 3 3 4 5 5 6 8
    
    3
    
    500000000 1000000000 500000000 500000000 1000000000

Output

    1 2 1 
    7 2 2 7 
    3 5 5 3 
    6 4 4 6 
    1 1 1 1 1 
    2 1 2 1 2 
    500000000 500000000 500000000 
    
Note

For the first example case, the subarrays of a = [1, 2, 1] are:

  * [1] with sum 1 , 
  * [2] with sum 2 , 
  * [1] with sum 1 , 
  * [1, 2] with sum 3 , 
  * [2, 1] with sum 3 , 
  * [1, 2, 1] with sum 4 . 

So the full list of subarray sums is 1, 1, 2, 3, 3, 4 , and the sum that is
missing from the input list is 3 .

For the second example case, the missing subarray sum is 4 , for the subarray
[2, 2] .

For the third example case, the missing subarray sum is 13 , because there are
two subarrays with sum 13 ([3, 5, 5] and [5, 5, 3] ) but 13 only occurs once
in the input.","def find_missing_sum(n, subarray_sums):
    # Calculate the total number of subarrays
    total_subarrays = n * (n + 1) // 2
    
    # Calculate the expected sum of all subarray sums
    # This is the sum of the first n natural numbers squared
    expected_sum = sum(range(1, n + 1)) ** 2
    
    # Calculate the actual sum of the given subarray sums
    actual_sum = sum(subarray_sums)
    
    # The missing sum is the difference
    missing_sum = expected_sum - actual_sum
    
    return missing_sum

def reconstruct_palindrome(n, subarray_sums, missing_sum):
    # Sort the subarray sums
    subarray_sums.sort()
    
    # Initialize the palindrome array
    a = [0] * n
    
    # Use the missing sum to help reconstruct the array
    # This is a simplified approach, and may need adjustments
    # based on the specific problem constraints and examples.
    
    # For simplicity, let's assume the missing sum is the sum of the middle element
    # This is a naive assumption and may not hold for all cases.
    # A more robust solution would involve more complex logic.
    
    # Set the middle element
    mid = n // 2
    a[mid] = missing_sum // (mid + 1)
    
    # Fill the rest of the array symmetrically
    for i in range(mid):
        a[i] = subarray_sums[i] - a[mid]
        a[n - 1 - i] = a[i]
    
    return a

def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        subarray_sums = list(map(int, data[index:index + (n * (n + 1) // 2) - 1]))
        index += (n * (n + 1) // 2) - 1
        
        missing_sum = find_missing_sum(n, subarray_sums)
        palindrome = reconstruct_palindrome(n, subarray_sums, missing_sum)
        
        results.append(' '.join(map(str, palindrome)))
    
    for result in results:
        print(result)",2,False,False,False,False,True,True,True,False,False,False,False,True,True
252,codeforces2024,human,qwen2.5-7b-instruct,"You are playing a computer game. The current level of this game can be modeled
as a straight line. Your character is in point 0 of this line. There are n
monsters trying to kill your character; the i -th monster has health equal to
a_i and is initially in the point x_i .

Every second, the following happens:

  * first, you fire up to k bullets at monsters. Each bullet targets exactly one monster and decreases its health by 1 . For each bullet, you choose its target arbitrary (for example, you can fire all bullets at one monster, fire all bullets at different monsters, or choose any other combination). Any monster can be targeted by a bullet, regardless of its position and any other factors; 
  * then, all alive monsters with health 0 or less die; 
  * then, all alive monsters move 1 point closer to you (monsters to the left of you increase their coordinates by 1 , monsters to the right of you decrease their coordinates by 1 ). If any monster reaches your character (moves to the point 0 ), you lose. 

Can you survive and kill all n monsters without letting any of them reach your
character?

Input

The first line of the input contains one integer t (1 \le t \le 3 \cdot 10^4 )
— the number of test cases.

Each test case consists of three lines:

  * the first line contains two integers n and k (1 \le n \le 3 \cdot 10^5 ; 1 \le k \le 2 \cdot 10^9 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9 ); 
  * the third line contains n integers x_1, x_2, \dots, x_n (-n \le x_1 < x_2 < x_3 < \dots < x_n \le n ; x_i \ne 0 ). 

Additional constraint on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 .

Output

For each test case, print YES if you can kill all n monsters before they reach
your character, or NO otherwise.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    5
    
    3 2
    
    1 2 3
    
    -1 2 3
    
    2 1
    
    1 1
    
    -1 1
    
    4 10
    
    3 4 2 5
    
    -3 -2 1 3
    
    5 3
    
    2 1 3 2 5
    
    -3 -2 3 4 5
    
    2 1
    
    1 2
    
    1 2

Output

    YES
    NO
    YES
    YES
    NO
    
Note

In the first example, you can act as follows:

  * during the 1 -st second, fire 1 bullet at the 1 -st monster and 1 bullet at the 3 -rd monster. Then the 1 -st monster dies, the 2 -nd and the 3 -rd monster move closer; 
  * during the 2 -nd second, fire 2 bullets at the 2 -nd monster. Then the 2 -nd monster dies, the 3 -rd monster moves closer; 
  * during the 3 -rd second, fire 2 bullets at the 3 -rd monster. Then the 3 -rd monster dies. 

In the second example, you can fire only 1 bullet, so you can kill only one of
the two monsters during the 1 -st second. Then, the remaining monster moves
closer and kills your character.","for _ in range(int(input())):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    x = sorted(map(lambda x: abs(int(x)), input().split()))

    last_pos = 0
    bullets = 0
    for i in range(n):
        bullets += k * (x[i] - last_pos)
        last_pos = x[i]
        bullets -= a[i]
        if bullets < 0:
            print('NO')
            break
    else:
        print('YES')",2,False,False,False,True,False,True,True,True,False,True,False,False,False
341,codeforces2024,human,qwen2.5-7b-instruct,"You have been asked to organize a very important art conference. The first
step is to choose the dates.

The conference must last for a certain number of consecutive days. Each day,
one lecturer must perform, and the same lecturer cannot perform more than
once.

You asked n potential lecturers if they could participate in the conference.
Lecturer i indicated that they could perform on any day from l_i to r_i
inclusive.

A certain segment of days can be chosen as the conference dates if there is a
way to assign an available lecturer to each day of the segment, assigning each
lecturer to no more than one day.

For each k from 1 to n , find how many ways there are to choose a segment of k
consecutive days as the conference dates.

Input

The first line of input contains one integer n — the number of potential
lecturers (1 \le n \le 2 \cdot 10^5 ).

Each of the next n lines contains two integers l_i and r_i — the segment of
available days for the i th lecturer (1 \le l_i \le r_i \le 2 \cdot 10^5 ).

Output

Print n integers, where the k th number denotes the number of ways to select a
segment of k consecutive days as conference dates.

Examples

Input

    3
    
    1 2
    
    3 4
    
    5 6

Output

    6
    2
    0
    
Input

    5
    
    1 3
    
    1 3
    
    1 3
    
    1 3
    
    1 3

Output

    3
    2
    1
    0
    0
    
Note

In the first testcase, a one-day conference can be organized on any of the
days from 1 to 6 . A two-day conference can be organized from day 2 to day 3 ,
as well as from day 4 to day 5 .

In the second testcase, five lecturers can perform only from day 1 to day 3 ,
so it will not be possible to organize a conference longer than three days.","def conference_days(n, lecturers):
    max_day = 200000
    availability = [0] * (max_day + 2)
    
    # Step 1: Populate the availability difference array
    for l, r in lecturers:
        availability[l] += 1
        availability[r + 1] -= 1
    
    # Step 2: Calculate the number of available lecturers for each day
    current_available = 0
    available_days = [0] * (max_day + 1)
    for day in range(1, max_day + 1):
        current_available += availability[day]
        available_days[day] = current_available
    
    # Step 3: Use a sliding window to count valid segments for each k
    result = [0] * (n + 1)
    for k in range(1, n + 1):
        count = 0
        current_window_sum = sum(available_days[1:k+1])
        
        if current_window_sum >= k:
            count += 1
        
        for start in range(2, max_day - k + 2):
            current_window_sum += available_days[start + k - 1] - available_days[start - 1]
            if current_window_sum >= k:
                count += 1
        
        result[k] = count
    
    return result[1:]

# Read input
import sys
input = sys.stdin.read
data = input().split()

n = int(data[0])
lecturers = []
index = 1
for _ in range(n):
    l = int(data[index])
    r = int(data[index + 1])
    lecturers.append((l, r))
    index += 2

# Get the result
result = conference_days(n, lecturers)

# Print the result
print(' '.join(map(str, result)))",2,False,False,False,True,True,True,True,True,False,False,False,True,False
191,codeforces2024,human,qwen2.5-7b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","def precompute_factorials(max_n, mod):
    fact=[1]*(max_n+1)
    for i in range(2, max_n+1):
        fact[i]=(fact[i - 1] * i)%mod
    return fact

def mod_inverse(x, mod):
    return pow(x,mod-2,mod)

def comb(n, k, fact, mod):
    if k>n or k<0:
        return 0
    return (((fact[n] * mod_inverse(fact[k], mod))% mod) * (mod_inverse(fact[n - k], mod)))% mod

t=int(input())
M=10**9 + 7
max_n=1000000 
fact=precompute_factorials(max_n,M)

for _ in range(t):
    n,k=map(int,input().split())
    ans=1

    seen=set()
    for _ in range(k):
        r,c=map(int,input().split())
        seen.update([r, c])
    
    new=set()
    for i in range(1, n + 1):
        if i not in seen:
            new.add(i)
    
    ev = len(new) 
    if (ev % 2)==0:
        for p in range(0,ev,2): 
            n_comb=comb(ev,p,fact,M)
            num=fact[ev - p]
            den=fact[(ev - p) // 2]
            r1=(n_comb*num) % M
            r2=mod_inverse(den, M)
            ans=(ans+ (r1*r2) % M)%M
    else:
        for p in range(1,ev,2): 
            n_comb=comb(ev,p,fact,M)
            num=fact[ev - p]
            den=fact[(ev - p) // 2]
            r1=(n_comb*num) % M
            r2=mod_inverse(den, M)
            ans=(ans+ (r1*r2) % M)%M
    print(ans)",2,True,False,False,True,True,True,True,False,True,True,True,False,True
222,codeforces2024,human,qwen2.5-7b-instruct,"Given an integer r , find the number of lattice points that have a Euclidean
distance from (0, 0) greater than or equal to r but strictly less than r+1 .

A lattice point is a point with integer coordinates. The Euclidean distance
from (0, 0) to the point (x,y) is \sqrt{x^2 + y^2} .

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains a single integer r (1 \leq r \leq
10^5 ).

The sum of r over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the number of lattice points
that have an Euclidean distance d from (0, 0) such that r \leq d < r+1 .

Example

Input

    6
    
    1
    
    2
    
    3
    
    4
    
    5
    
    1984

Output

    8
    16
    20
    24
    40
    12504
    
Note

The points for the first three test cases are shown below.

![](https://espresso.codeforces.com/66c3f9d945c97358ed2f31c823ce9b70e46c6a4d.png)","import math

def count_lattice_points(r):
    count = 0
    r_squared = r * r
    r_plus_1_squared = (r + 1) * (r + 1)
    
    for x in range(-r, r + 1):
        x_squared = x * x
        if x_squared < r_squared:
            # For x=0 to x=r-1
            y_min_sq = r_squared - x_squared
            y_max_sq = r_plus_1_squared - x_squared - 1
            if y_min_sq > y_max_sq:
                continue
            y_min = math.ceil(math.sqrt(y_min_sq)) if y_min_sq > 0 else 0
            y_max = math.floor(math.sqrt(y_max_sq))
            count += max(0, y_max - y_min + 1) * 2  # Positive and negative y
        else:
            # For x=r
            y_max_sq = r_plus_1_squared - x_squared - 1
            y_max = math.floor(math.sqrt(y_max_sq))
            count += (y_max * 2 + 1) if y_max >= 0 else 0
    
    return count

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        r = int(data[index])
        index += 1
        results.append(str(count_lattice_points(r)))
    print('\n'.join(results))

if __name__ == ""__main__"":
    main()",2,True,True,True,True,True,True,True,True,True,True,True,True,True
273,codeforces2024,human,qwen2.5-7b-instruct,"After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Examples

Input

    4
    0 4 2 4
    
Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Input

    4
    1 3 0 1
    
Output

    YES
    2 1
    4 1
    1 1
    3 1
    3 3 3 1

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)","from sys import stdin
 
 
def place_wizards(r):
    wizards = list(range(n))
    x = 1
    prev_y = 1
    result = [None] * n
    where = [1] * n
    wizards.sort(key=lambda w: -r[w])
    if r[wizards[-1]] == 0:
        w0 = wizards[-1]
        result[w0] = (x, 1)
        where[w0] += w0
        wizards.pop()
        x += 1
        prev_w = w0
    elif n >= 3 and [r[w] for w in wizards[:-4:-1]] == [1, 2, 3]:
        one, two, three = wizards[:-4:-1]
        wizards[-3:] = []
        result[three] = (x, 2)
        result[two] = (x + 1, 1)
        result[one] = (x + 2, 1)
        where[three] += one
        where[two] += three
        where[one] += two
        x += 3
        prev_w = one
    else:
        for a, b in zip(wizards, wizards[1:]):
            if r[a] == r[b]:
                break
        else:
            # print(r)
            # print(""tail"", [r[w] for w in range(-1, -4, -1)])
            # print(wizards)
            # print([r[w] for w in wizards])
            assert False
        wizards.remove(a)
        wizards.remove(b)
        result[a] = (x, r[a])
        result[b] = (x + 1, 1)
        where[a] += b
        where[b] += a
        x += 2
        prev_w = b
    prev_y = 1
    
    for w in wizards:
        if r[w] == 0:
            result[w] = (x, 1)
            where[w] += w
        else:
            if prev_y - r[w] + 1 >= 1:
                y = prev_y - r[w] + 1
            else:
                y = prev_y + r[w] - 1
                assert y <= n
            result[w] = (x, y)
            where[w] += prev_w
        prev_y = result[w][-1]
        prev_w = w
        x += 1
    return result, where
 
n = int(stdin.readline())
r = list(map(int, stdin.readline().split()))
if n == 2 and sorted(r) == [1, 2]:
    print(""NO"")
else:
    positions, where = place_wizards(r)
    print(""YES"")
    for x, y in positions:
        print(x, y)
    print(*where)",2,True,False,False,True,False,True,True,False,False,False,True,False,False
352,codeforces2024,human,qwen2.5-7b-instruct,"There are n containers of water lined up, numbered from left to right from 1
to n . Each container can hold any amount of water; initially, the i -th
container contains a_i units of water. The sum of a_i is divisible by n .

You can apply the following operation any (possibly zero) number of times:
pour any amount of water from the i -th container to the j -th container,
where i must be less than j (i.e. i<j ). Any index can be chosen as i or j any
number of times.

Determine whether it is possible to make the amount of water in all containers
the same using this operation.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of containers with water.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i \le 10^9 ) — the amounts of water in the containers. It is guaranteed
that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the
sum of a_i is divisible by n .

It is guaranteed that the sum of n over all test cases in the input does not
exceed 2 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output ""YES"" if it is possible to make the amount of water in all
containers the same using the described operation. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    6
    
    1
    
    43
    
    2
    
    1 3
    
    5
    
    4 5 2 1 3
    
    3
    
    1 2 3
    
    7
    
    4 5 5 0 6 4 4
    
    7
    
    6 5 5 1 3 4 4

Output

    YES
    NO
    YES
    NO
    NO
    YES
    
Note

In the third test case of the example (a=[4, 5, 2, 1, 3] ), you can proceed as
follows:

  * pour 1 unit of water from the first vessel to the fourth, then a=[3, 5, 2, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the third, then a=[3, 4, 3, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the fourth, then a=[3, 3, 3, 3, 3] .","t = int(input())
for _ in range(t):
    n = int(input())
    arr = list(map(int , input().split()))
    sum1 = 0
    sum2 = (sum(arr))//2
    sm3  = sum(arr)//n
    if n==1 or sum(arr)==0:
        print(""yes"")
        continue
    
    for i in range(n//2):
        sum1+=arr[i]
 
    if sum1>sum2 and arr[0]>sm3 and arr[n-1]<=sm3:
        print(""yes"")
    else:
        print(""no"")",2,False,False,False,False,False,False,False,True,False,False,False,False,False
284,codeforces2024,human,qwen2.5-7b-instruct,"The only difference between this and the hard version is that all a_{i} are
even.

After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)
. All a_{i} are even.

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Example

Input

    4
    0 4 2 4

Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)","n=int (input ())
a=map (int,input ().split ())
a=list (a)
print ('YES')
for i in range (1,n+1):
    print (i,i)
for i in range (1,n+1):
    if i>a[i-1]/2:
        print (i-int (a[i-1]/2),end=' ')
    else:
        print (i+int (a[i-1]/2),end=' ')",2,True,False,False,False,False,False,False,False,False,False,False,False,False
124,codeforces2024,human,qwen2.5-7b-instruct,"Given an integer n , you construct an array a of n integers, where a_i = i for
all integers i in the range [1, n] . An operation on this array is defined as
follows:

  * Select three distinct indices i , j , and k from the array, and let x = a_i , y = a_j , and z = a_k . 
  * Update the array as follows: a_i = \operatorname{lcm}(y, z) , a_j = \operatorname{lcm}(x, z) , and a_k = \operatorname{lcm}(x, y) , where \operatorname{lcm} represents the least common multiple. 

Your task is to provide a possible sequence of operations, containing at most
\lfloor \frac{n}{6} \rfloor + 5 operations such that after executing these
operations, if you create a set containing the greatest common divisors (GCDs)
of all subsequences with a size greater than 1 , then all numbers from 1 to n
should be present in this set.

After all the operations a_i \le 10^{18} should hold for all 1 \le i \le n .

We can show that an answer always exists.

Input

The first line contains one integer t (1 \le t \le 10^2 ) — the number of test
cases. The description of the test cases follows.

The first and only line of each test case contains an integer n (3 \leq n \leq
3 \cdot 10^{4} ) — the length of the array.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^{4} .

Output

The first line should contain an integer k (0 \leq k \leq \lfloor \frac{n}{6}
\rfloor + 5 ) — where k is the number of operations.

The next k lines should contain the description of each operation i.e. 3
integers i , j and k , where 1 \leq i, j, k \leq n and all must be distinct.

Example

Input

    3
    
    3
    
    4
    
    7

Output

    1
    1 2 3
    1
    1 3 4
    3
    3 5 7
    5 6 7
    2 3 4

Note

In the third test case, a = [1, 2, 3, 4, 5, 6, 7] .

First operation:

i = 3 , j = 5 , k = 7

x = 3 , y = 5 , z = 7 .

a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6,
\operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6,
\color{red}{15}] .

Second operation:

i = 5 , j = 6 , k = 7

x = 21 , y = 6 , z = 15 .

a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105},
\color{red}{42}] .

Third operation:

i = 2 , j = 3 , k = 4

x = 2 , y = 35 , z = 4 .

a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4},
\color{red}{70}, 30, 105, 42] .

Subsequences whose GCD equal to i is as follows:

\gcd(a_1, a_2) = \gcd(1, 140) = 1

\gcd(a_3, a_4) = \gcd(4, 70) = 2

\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3

\gcd(a_2, a_3) = \gcd(140, 4) = 4

\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5

\gcd(a_5, a_7) = \gcd(30, 42) = 6

\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7","import sys

# Predefined solutions for specific cases
ans1 = [8]
ans2 = [[[2, 6, 8], [3, 5, 7]]]

for _ in range(int(input())):
    n = int(input())
    
    # Check if n is in the predefined solutions
    if n in ans1:
        ans = ans2[ans1.index(n)]
        print(len(ans))
        for x in ans:
            print(' '.join(map(str, x)))
        continue
    
    ans = []  # List to store the operations
    pos = 0   # Position tracker
    ost = []  # List to store remaining indices
    
    # Loop to create operations in segments
    for i in range(3, n - 1, 4):
        if i > n // 2 - 2:
            ans.append([i, i + 1, i + 2])
            pos = i + 2
    
    # Collect remaining indices for further operations
    for i in range(pos + 1, n + 1):
        if (i % 2 != 0 or i % 4 == 0) and i > n // 2:
            ost.append(i)
    
    # Determine the last index to consider for operations
    per = n
    if (n - 1) % 4 == 2:
        per = n - 1
    elif (n - 2) % 4 == 2:
        per = n - 2
    elif (n - 3) % 4 == 2:
        per = n - 3
    
    # Create operations for the remaining indices
    for i in range(per, n // 2, -12):
        if i > n // 2:
            if i > 8:
                ans.append([i, i - 4, i - 8])
            else:
                ost.append(i)
    
    # Handle the remaining indices based on their count
    if len(ost) == 1:
        ans.append([1, 2, ost[0]])
    elif len(ost) == 2:
        ans.append([1, ost[1], ost[0]])
    elif len(ost) == 3:
        ans.append([ost[0], ost[1], ost[2]])
    elif len(ost) == 4:
        ans.append([1, ost[0], ost[1]])
        ans.append([2, ost[2], ost[3]])
    
    # Output the number of operations and the operations themselves
    print(len(ans))
    for x in ans:
        print(' '.join(map(str, x)))",2,True,False,False,True,False,True,True,True,True,True,True,True,True
243,codeforces2024,human,qwen2.5-7b-instruct,"You are designing a new video game. It has n scenarios, which the player may
play in any order, but each scenario must be played exactly once. When a
player switches from a scenario to another scenario, the game shows a
specially crafted transition video to make it all feel part of one big story.
This video is specific to a pair of scenarios, but not to their order, in
other words, the video playing when switching from scenario a to scenario b is
the same as the video playing when switching from scenario b to scenario a .
Therefore, you need to create \frac{n(n-1)}{2} different transition videos,
one for each possible pair of different scenarios.

Each transition video can be either funny or scary. It is boring to see too
many funny videos or too many scary videos in a row. Therefore, your goal is
to create the videos in such a way that no matter in which order does the
player approach the scenarios, they will never see more than \lceil
\frac{3n}{4} \rceil transition videos of the same type in a row.

You have already come up with ideas for at most \lfloor \frac{n}{2} \rfloor of
the transition videos, and therefore already know if those will be funny or
scary. Now you need to choose funny or scary for all other transition videos
in such a way that the above requirement is satisfied.

Input

The first line contains a single integer n (2 \le n \le 24 ) — the number of
scenarios in the game.

The next n lines describe the partial transition video plan. Each of those
lines contains n characters. The j -th character of the i -th line corresponds
to the transition video between the i -th and the j -th scenarios. It will be
F if the corresponding transition video will be funny, S if the corresponding
transition video will be scary, ? if the corresponding transition video is
still undecided, or . if i=j .

It is guaranteed that the i -th character of the j -th line and the j -th
character of the i -th line will be the same for all i and j . It is
guaranteed that at most \lfloor \frac{n}{2} \rfloor (n divided by 2, rounded
down) transition videos will already be decided, in other words, that at most
2\lfloor \frac{n}{2} \rfloor characters in the input will be F or S.

Output

Print n lines describing the full transition video plan in the same format as
the input. Each of those lines must contain n characters. The j -th character
of the i -th line must be F if the corresponding transition video is funny, S
if the corresponding transition video is scary, or . if i=j .

Each ? character from the input must be replaced with either F or S, and all
other characters from the input must remain unchanged. It must still hold that
the i -th character of the j -th line and the j -th character of the i -th
line are the same for all i and j .

For each permutation of the n scenarios, it must hold that the transition
videos corresponding to playing the scenarios in this order do not have more
than \lceil \frac{3n}{4} \rceil (3n divided by 4, rounded up) videos of the
same type consecutively.

If there are multiple solutions, print any of them. It can be proven that for
all inputs satisfying the constraints of this problem a solution always
exists.

Examples

Input

    5
    
    .?F??
    
    ?.???
    
    F?.S?
    
    ??S.?
    
    ????.

Output

    .FFFF
    F.FFF
    FF.SF
    FFS.F
    FFFF.

Input

    12
    
    .???????????
    
    ?.??????????
    
    ??.?????????
    
    ???.????????
    
    ????.???????
    
    ?????.??????
    
    ??????.?????
    
    ???????.????
    
    ????????.???
    
    ?????????.??
    
    ??????????.?
    
    ???????????.

Output

    .SSSFFSSSSFS
    S.SFFSFSFFFS
    SS.SFFFSSSFS
    SFS.FFSSSSFS
    FFFF.FFFFFSF
    FSFFF.SFFSFF
    SFFSFS.SSSFS
    SSSSFFS.SSFS
    SFSSFFSS.SFS
    SFSSFSSSS.FS
    FFFFSFFFFF.F
    SSSSFFSSSSF.
    
Note

In the first sample: We are allowed \lceil \frac{3\cdot 5}{4} \rceil=4
transition videos of the same type in a row, but for any permutation of the 5
scenarios the player will see only 4 transition videos in total, therefore we
can choose funny or scary freely. We must still respect the already chosen
types.

In the second sample: One of the 479001600 possible permutations of scenarios
is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following
sequence of transition videos for this permutation: SSSSSSSSSFS. Even though
this sequence has 10 scary transition videos in total, it has only 9 scary
transition videos in a row, which is the maximum allowed amount (\lceil
\frac{3\cdot 12}{4} \rceil=9 ).","import sys
import math

def main():
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])
    matrix = [list(line) for line in data[1:n+1]]
    
    # Calculate the maximum allowed consecutive videos of the same type
    max_consecutive = math.ceil(3 * n / 4)
    
    # Fill the matrix
    for i in range(n):
        for j in range(i + 1, n):
            if matrix[i][j] == '?':
                # We can choose either 'F' or 'S', let's alternate
                # Count the current number of 'F' and 'S' in the row
                f_count = sum(1 for k in range(n) if matrix[i][k] == 'F')
                s_count = sum(1 for k in range(n) if matrix[i][k] == 'S')
                
                # Choose the one that keeps the balance
                if f_count <= s_count:
                    matrix[i][j] = 'F'
                    matrix[j][i] = 'F'
                else:
                    matrix[i][j] = 'S'
                    matrix[j][i] = 'S'
    
    # Output the result
    for line in matrix:
        print(''.join(line))

if __name__ == ""__main__"":
    main()",2,False,False,False,True,True,True,True,False,False,True,False,False,False
284,codeforces2024,human,qwen2.5-7b-instruct,"The only difference between this and the hard version is that all a_{i} are
even.

After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)
. All a_{i} are even.

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Example

Input

    4
    0 4 2 4

Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)","def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    a = list(map(int, data[1:]))
    
    # Check if it's possible
    if any(ai > 2 * (n - 1) for ai in a):
        print(""NO"")
        return
    
    # Place houses
    houses = []
    for i in range(n):
        x = i + 1
        y = (i % n) + 1
        houses.append((x, y))
    
    # Assign visits
    visits = [-1] * n
    for i in range(n):
        for j in range(n):
            if i != j:
                dist = abs(houses[i][0] - houses[j][0]) + abs(houses[i][1] - houses[j][1])
                if dist == a[i]:
                    visits[i] = j + 1
                    break
    
    if -1 in visits:
        print(""NO"")
    else:
        print(""YES"")
        for x, y in houses:
            print(x, y)
        print(' '.join(map(str, visits)))",2,False,False,False,True,False,True,False,True,False,True,False,False,False
29,codeforces2024,human,qwen2.5-7b-instruct,"The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.","def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def count_pairs(n, m):
    count = 0
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            if (a + b) % (b * gcd(a, b)) == 0:
                count += 1
    return count",2,False,True,True,True,True,True,True,True,True,True,True,True,True
267,codeforces2024,human,qwen2.5-7b-instruct,"You are given a string s , consisting of lowercase Latin letters and/or
question marks.

A tandem repeat is a string of an even length such that its first half is
equal to its second half.

A string a is a substring of a string b if a can be obtained from b by the
deletion of several (possibly, zero or all) characters from the beginning and
several (possibly, zero or all) characters from the end.

Your goal is to replace each question mark with some lowercase Latin letter in
such a way that the length of the longest substring that is a tandem repeat is
maximum possible.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
testcases.

The only line of each testcase contains a string s (1 \le |s| \le 5000 ),
consisting only of lowercase Latin letters and/or question marks.

The total length of the strings over all testcases doesn't exceed 5000 .

Output

For each testcase, print a single integer — the maximum length of the longest
substring that is a tandem repeat after you replace each question mark in the
string with some lowercase Latin letter.

If it's impossible to make any tandem repeat substrings in the string, print 0
.

Example

Input

    4
    
    zaabaabz
    
    ?????
    
    code?????s
    
    codeforces

Output

    6
    4
    10
    0","def max_tandem_repeat(s):
    n = len(s)
    max_length = 0

    for d in range(1, n // 2 + 1):
        count = sum(1 for i in range(d) if match(s[i], s[i + d]))
        
        for l in range(n - 2 * d):
            if l > 0:
                count -= match(s[l - 1], s[l - 1 + d])
                count += match(s[l + d - 1], s[l + 2 * d - 1])
            
            if count == d:
                max_length = max(max_length, 2 * d)
    
    return max_length


def match(a, b):
    return a == b or a == '?' or b == '?'


if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        s = input()
        result = max_tandem_repeat(s)
        print(result)",2,False,False,False,False,False,True,True,False,False,True,False,False,False
124,codeforces2024,human,qwen2.5-7b-instruct,"Given an integer n , you construct an array a of n integers, where a_i = i for
all integers i in the range [1, n] . An operation on this array is defined as
follows:

  * Select three distinct indices i , j , and k from the array, and let x = a_i , y = a_j , and z = a_k . 
  * Update the array as follows: a_i = \operatorname{lcm}(y, z) , a_j = \operatorname{lcm}(x, z) , and a_k = \operatorname{lcm}(x, y) , where \operatorname{lcm} represents the least common multiple. 

Your task is to provide a possible sequence of operations, containing at most
\lfloor \frac{n}{6} \rfloor + 5 operations such that after executing these
operations, if you create a set containing the greatest common divisors (GCDs)
of all subsequences with a size greater than 1 , then all numbers from 1 to n
should be present in this set.

After all the operations a_i \le 10^{18} should hold for all 1 \le i \le n .

We can show that an answer always exists.

Input

The first line contains one integer t (1 \le t \le 10^2 ) — the number of test
cases. The description of the test cases follows.

The first and only line of each test case contains an integer n (3 \leq n \leq
3 \cdot 10^{4} ) — the length of the array.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^{4} .

Output

The first line should contain an integer k (0 \leq k \leq \lfloor \frac{n}{6}
\rfloor + 5 ) — where k is the number of operations.

The next k lines should contain the description of each operation i.e. 3
integers i , j and k , where 1 \leq i, j, k \leq n and all must be distinct.

Example

Input

    3
    
    3
    
    4
    
    7

Output

    1
    1 2 3
    1
    1 3 4
    3
    3 5 7
    5 6 7
    2 3 4

Note

In the third test case, a = [1, 2, 3, 4, 5, 6, 7] .

First operation:

i = 3 , j = 5 , k = 7

x = 3 , y = 5 , z = 7 .

a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6,
\operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6,
\color{red}{15}] .

Second operation:

i = 5 , j = 6 , k = 7

x = 21 , y = 6 , z = 15 .

a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105},
\color{red}{42}] .

Third operation:

i = 2 , j = 3 , k = 4

x = 2 , y = 35 , z = 4 .

a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4},
\color{red}{70}, 30, 105, 42] .

Subsequences whose GCD equal to i is as follows:

\gcd(a_1, a_2) = \gcd(1, 140) = 1

\gcd(a_3, a_4) = \gcd(4, 70) = 2

\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3

\gcd(a_2, a_3) = \gcd(140, 4) = 4

\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5

\gcd(a_5, a_7) = \gcd(30, 42) = 6

\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7","import sys

def solve():
    input = sys.stdin.read
    data = input().split()
    
    # Predefined answers for specific cases
    ans1 = [8]
    ans2 = [[[2, 6, 8], [3, 5, 7]]]
    
    index = 0
    t = int(data[index])
    index += 1
    
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        
        if n in ans1:
            ans = ans2[ans1.index(n)]
            results.append(f""{len(ans)}"")
            for x in ans:
                results.append(' '.join(map(str, x)))
            continue
        
        ans = []
        pos = 0
        ost = []
        
        # Create operations in a pattern
        for i in range(3, n - 1, 4):
            if i > n // 2 - 2:
                ans.append([i, i + 1, i + 2])
                pos = i + 2
        
        # Collect remaining indices
        for i in range(pos + 1, n + 1):
            if (i % 2 != 0 or i % 4 == 0) and i > n // 2:
                ost.append(i)
        
        # Determine the periodicity for operations
        per = n
        if (n - 1) % 4 == 2:
            per = n - 1
        elif (n - 2) % 4 == 2:
            per = n - 2
        elif (n - 3) % 4 == 2:
            per = n - 3
        
        # Add operations based on periodicity
        for i in range(per, n // 2, -12):
            if i > n // 2:
                if i > 8:
                    ans.append([i, i - 4, i - 8])
                else:
                    ost.append(i)
        
        # Handle leftover indices
        if len(ost) == 1:
            ans.append([1, 2, ost[0]])
        elif len(ost) == 2:
            ans.append([1, ost[1], ost[0]])
        elif len(ost) == 3:
            ans.append([ost[0], ost[1], ost[2]])
        elif len(ost) == 4:
            ans.append([1, ost[0], ost[1]])
            ans.append([2, ost[2], ost[3]])
        
        # Collect results
        results.append(f""{len(ans)}"")
        for x in ans:
            results.append(' '.join(map(str, x)))
    
    # Output all results
    sys.stdout.write(""\n"".join(results) + ""\n"")",2,False,False,False,True,False,True,True,False,False,True,False,True,False
52,codeforces2024,human,qwen2.5-7b-instruct,"Petya has an array a_i of n integers. His brother Vasya became envious and
decided to make his own array of n integers.

To do this, he found m integers b_i (m\ge n ), and now he wants to choose some
n integers of them and arrange them in a certain order to obtain an array c_i
of length n .

To avoid being similar to his brother, Vasya wants to make his array as
different as possible from Petya's array. Specifically, he wants the total
difference D = \sum_{i=1}^{n} |a_i - c_i| to be as large as possible.

Help Vasya find the maximum difference D he can obtain.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 100 ) — the number of test cases. This is followed by a
description of the test cases.

The first line of each test case contains two integers n and m (1\le n\le m\le
2 \cdot 10^5 ).

The second line of each test case contains n integers a_i (1\le a_i\le 10^9 ).
The third line of each test case contains m integers b_i (1\le b_i\le 10^9 ).

It is guaranteed that in a test, the sum of m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the maximum total difference D
that can be obtained.

Example

Input

    9
    
    4 6
    
    6 1 2 4
    
    3 5 1 7 2 3
    
    3 4
    
    1 1 1
    
    1 1 1 1
    
    5 5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    2 6
    
    5 8
    
    8 7 5 8 2 10
    
    2 2
    
    4 1
    
    9 6
    
    4 6
    
    8 10 6 4
    
    3 10 6 1 8 9
    
    3 5
    
    6 5 2
    
    1 7 9 7 2
    
    5 5
    
    9 10 6 3 7
    
    5 9 2 3 9
    
    1 6
    
    3
    
    2 7 10 1 1 5

Output

    16
    0
    12
    11
    10
    23
    15
    25
    7
    
Note

In the first example, Vasya can, for example, create the array (1, 5, 7, 2) .
Then the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .

In the second example, all the integers available to Vasya are equal to 1, so
he can only create the array (1, 1, 1) , for which the difference D = 0 .

In the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)
. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =
4+2+0+2+4 = 12 .","t=int(input())
for _ in range(t):
    n,m=map(int,input().split())
    a=list(map(int,input().split()))
    b=list(map(int,input().split()))
    a.sort()
    b.sort(reverse=True)
    diff=0
    for i in range(n):
        diff+=max(abs(a[i]-b[i]),abs(a[i-n]-b[i-n]))
    print(diff)",2,True,False,False,True,True,True,True,True,True,False,True,True,True
325,codeforces2024,human,qwen2.5-7b-instruct,"This is the easy version of the problem. The only difference between the two
versions is the constraint on t and n . You can make hacks only if both
versions of the problem are solved.

For a binary^\dagger pattern p and a binary string q , both of length m , q is
called p -good if for every i (1 \leq i \leq m ), there exist indices l and r
such that:

  * 1 \leq l \leq i \leq r \leq m , and 
  * p_i is a mode^\ddagger of the string q_l q_{l+1} \ldots q_{r} . 

For a pattern p , let f(p) be the minimum possible number of \mathtt{1} s in a
p -good binary string (of the same length as the pattern).

You are given a binary string s of size n . Find

In other words, you need to sum the values of f over all \frac{n(n+1)}{2}
substrings of s .

^\dagger A binary pattern is a string that only consists of characters
\mathtt{0} and \mathtt{1} .

^\ddagger Character c is a mode of string t of length m if the number of
occurrences of c in t is at least \lceil \frac{m}{2} \rceil . For example,
\mathtt{0} is a mode of \mathtt{010} , \mathtt{1} is not a mode of
\mathtt{010} , and both \mathtt{0} and \mathtt{1} are modes of \mathtt{011010}
.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the length of the binary string s .

The second line of each test case contains a binary string s of length n
consisting of only characters \mathtt{0} and \mathtt{1} .

It is guaranteed that the sum of n^2 over all test cases does not exceed 10^4
.

Output

For each test case, output the sum of values of f over all substrings of s .

Example

Input

    4
    
    1
    
    1
    
    2
    
    10
    
    5
    
    00000
    
    20
    
    11110110000000111111

Output

    1
    2
    0
    346
    
Note

In the first test case, the only \mathtt{1} -good string is \mathtt{1} . Thus,
f(\mathtt{1})=1 .

In the second test case, f(\mathtt{10})=1 because \mathtt{01} is \mathtt{10}
-good, and \mathtt{00} is not \mathtt{10} -good. Thus, the answer is
f(\mathtt{1})+f(\mathtt{10})+f(\mathtt{0}) = 1 + 1 + 0 = 2 .

In the third test case, f equals to 0 for all 1 \leq i \leq j \leq 5 . Thus,
the answer is 0 .","def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    num_cases = int(data[index])
    index += 1
    results = []
    
    for _ in range(num_cases):
        n = int(data[index])
        index += 1
        s = data[index]
        index += 1
        
        # Initialize the DP array
        dp = [0] * (n + 1)
        result = 0
        
        # Traverse the string from the end to the beginning
        for i in range(n - 1, -1, -1):
            if s[i] == '1':
                # If the current character is '1', calculate the contribution
                dp[i] = n - i + dp[i + 1]
            else:
                # If the current character is '0', carry forward the previous value
                dp[i] = dp[i + 1]
        
        # Sum up all the values in the DP array
        result = sum(dp[:n])
        
        # Store the result for the current test case
        results.append(result)
    
    # Output all results
    for res in results:
        print(res)

if __name__ == ""__main__"":
    solve()",2,False,False,False,True,False,True,True,False,False,False,False,False,False
222,codeforces2024,human,qwen2.5-7b-instruct,"Given an integer r , find the number of lattice points that have a Euclidean
distance from (0, 0) greater than or equal to r but strictly less than r+1 .

A lattice point is a point with integer coordinates. The Euclidean distance
from (0, 0) to the point (x,y) is \sqrt{x^2 + y^2} .

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains a single integer r (1 \leq r \leq
10^5 ).

The sum of r over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the number of lattice points
that have an Euclidean distance d from (0, 0) such that r \leq d < r+1 .

Example

Input

    6
    
    1
    
    2
    
    3
    
    4
    
    5
    
    1984

Output

    8
    16
    20
    24
    40
    12504
    
Note

The points for the first three test cases are shown below.

![](https://espresso.codeforces.com/66c3f9d945c97358ed2f31c823ce9b70e46c6a4d.png)","def solve(r):
    return 3 * r * r

t = int(input())
for _ in range(t):
    r = int(input())
    print(solve(r))",2,False,False,False,False,False,False,False,False,False,False,False,False,False
95,codeforces2024,human,qwen2.5-7b-instruct,"In the evenings during the hike, Kirill and Anton decided to take out an array
of integers a of length n from their backpack and play a game with it. The
rules are as follows:

  1. Kirill chooses from 2 to (n-2) numbers and encircles them in red.
  2. Anton encircles all the remaining numbers in blue.
  3. Kirill calculates the greatest common divisor ([GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor)) of all the red numbers.
  4. Anton calculates the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of all the blue numbers and adds the number x to the result.
  5. If the GCD of all the red numbers is strictly greater than the sum of the bitwise AND of all the blue numbers and the number x , then Kirill wins; otherwise, Anton wins.

Help Kirill to beat Anton or tell if it's impossible.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 20\,000 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and x (4\le n \le
4\cdot 10^5 , 0 \le x \le 4\cdot 10^5 ) — the number of integers and the
number x respectively.

The second line contains an array a of length n (1 \le a_i \le 4\cdot 10^5 ).

It is guaranteed that the sum of n for all test cases does not exceed 4\cdot
10^5 . It is also guaranteed that the sum of the maximum values of a_i for
each test case does not exceed 4\cdot 10^5 .

Output

For each test case, output ""YES"" on the first line if the condition can be
met, on the second line, output the number of chosen numbers by Kirill and the
numbers themselves in any order separated by a space, and on the third line,
output the size of the second set and the numbers in it.

Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    8
    
    4 1
    
    4 3 1 8
    
    4 1
    
    4 5 8 4
    
    5 0
    
    1 1 1 1 1
    
    5 2
    
    31 63 127 63 31
    
    4 1
    
    1 3 3 3
    
    8 3
    
    4 3 4 1 2 2 5 3
    
    4 2
    
    1 4 3 6
    
    8 48
    
    31 61 37 15 53 26 61 12

Output

    YES
    2 4 8
    2 3 1 
    YES
    2 4 4
    2 5 8 
    NO
    YES
    2 63 63
    3 31 127 31
    YES
    2 3 3
    2 1 3
    YES
    2 4 4
    6 3 1 2 2 5 3
    YES
    2 3 6
    2 1 4 
    YES
    2 61 61
    6 31 37 15 53 26 12","import sys
import math
from functools import reduce

input = sys.stdin.read
data = input().split()

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def solve():
    index = 0
    t = int(data[index])
    index += 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        x = int(data[index + 1])
        index += 2
        a = list(map(int, data[index:index + n]))
        index += n
        
        a.sort()
        
        # Try to maximize GCD and minimize AND
        # We can try two main strategies:
        # 1. Take the largest two numbers for GCD and the rest for AND
        # 2. Take the smallest two numbers for AND and the rest for GCD
        
        # Strategy 1: Take the largest two numbers for GCD
        gcd1 = gcd(a[-1], a[-2])
        and1 = reduce(lambda x, y: x & y, a[:-2])
        if gcd1 > and1 + x:
            results.append(""YES"")
            results.append(f""2 {a[-1]} {a[-2]}"")
            results.append(f""{n-2} "" + "" "".join(map(str, a[:-2])))
            continue
        
        # Strategy 2: Take the smallest two numbers for AND
        gcd2 = reduce(gcd, a[2:])
        and2 = a[0] & a[1]
        if gcd2 > and2 + x:
            results.append(""YES"")
            results.append(f""{n-2} "" + "" "".join(map(str, a[2:])))
            results.append(f""2 {a[0]} {a[1]}"")
            continue
        
        # If neither strategy works, it's impossible
        results.append(""NO"")
    
    sys.stdout.write(""\n"".join(results) + ""\n"")

solve()",2,False,False,False,False,False,True,True,True,True,True,True,True,True
162,codeforces2024,human,qwen2.5-7b-instruct,"The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).","def find_apocalypse_year(n, periods):
    current_year = 0
    for period in periods:
        # Find the next occurrence of the current sign
        if current_year % period == 0:
            current_year += period
        else:
            current_year = ((current_year // period) + 1) * period
    return current_year

# Input reading
t = int(input())  # Number of test cases
results = []

for _ in range(t):
    n = int(input())  # Number of signs
    periods = list(map(int, input().split()))  # Periodicities of the signs
    results.append(find_apocalypse_year(n, periods))

# Output results
for result in results:
    print(result)",2,True,False,False,True,True,True,True,True,False,True,True,True,True
162,codeforces2024,human,qwen2.5-7b-instruct,"The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).","from math import ceil
n_tests = int(input())

for i in range(n_tests):
    n = int(input())
    x = [int(i) for i in input().split()]
    counter = x[0]
    for i in range(1, len(x)):
        if x[i] == 1:
            counter += 1
        elif counter > x[i]:
            counter = x[i] * ceil(counter / x[i])
        elif counter < x[i]:
            counter = x[i]
        else:
            counter = x[i] * 2
    print(counter)",2,False,False,False,True,True,True,False,False,False,True,True,True,False
326,codeforces2024,human,qwen2.5-7b-instruct,"There are 2n positive integers written on a whiteboard. Being bored, you
decided to play a one-player game with the numbers on the whiteboard.

You start with a score of 0 . You will increase your score by performing the
following move exactly n times:

  * Choose two integers x and y that are written on the whiteboard. 
  * Add \min(x,y) to your score. 
  * Erase x and y from the whiteboard. 

Note that after performing the move n times, there will be no more integers
written on the whiteboard.

Find the maximum final score you can achieve if you optimally perform the n
moves.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \leq n \leq 50
) — the number of integers written on the whiteboard is 2n .

The second line of each test case contains 2n integers a_1,a_2,\ldots,a_{2n}
(1 \leq a_i \leq 10^7 ) — the numbers written on the whiteboard.

Output

For each test case, output the maximum final score that you can achieve.

Example

Input

    3
    
    1
    
    2 3
    
    2
    
    1 1 2 1
    
    3
    
    1 1 1 1 1 1

Output

    2
    2
    3
    
Note

In the first test case, you can only make one move. You select x=2 and y=3 ,
and your score will be \min(x,y)=2 .

In the second test case, the following is a sequence of moves that achieves a
final score of 2 :

  * In the first move, select x=1 and y=1 . Then, add \min(x,y)=1 to the score. After erasing x and y , the integers left on the whiteboard are 1 and 2 . 
  * In the second move, select x=1 and y=2 . Then, add \min(x,y)=1 to the score. After removing x and y , no more integers will be left on the whiteboard. 

It can be proved that it is not possible to get a score greater than 2 .

In the third test case, you will perform the move thrice, adding 1 to the
score each time.","t = int(input())
ans_f = []

for i in range(t):
    ans = 0
    n = int(input())
    l = input()
    lst = l.split("" "")
    for i in range(n * 2):
        if(len(lst) != 2):
            ans += min(int(lst[0]), int(lst[1]))
            lst.remove(lst[0*2])
            lst.remove(lst[1*2])
        else:
            ans += min(int(lst[0]), int(lst[1]))
            break


    ans_f.append(ans)

for i in ans_f:
    print(i)",2,False,False,False,False,False,False,False,True,False,True,True,False,False
105,codeforces2024,human,qwen2.5-7b-instruct,"Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .","t=int(input())
for i in range(t):
    n,k,x=map(int,input().split())
    a=list(map(int,input().split()))
    a.sort()
    q=[0]
    p=-10**5
    for i in range(n):
        q.append(q[-1]+a[i])
    for i in range(n-k,n+1):
        if i-x<1:
            l=0
        else:
            l=i-x    
        m=2*q[l]-q[i] 
        if m>p:
            p=m
    print(p)",2,False,False,False,True,True,True,True,False,False,False,True,True,False
156,codeforces2024,human,qwen2.5-7b-instruct,"[Maître Gims - Est-ce que tu m'aimes ?](https://youtu.be/6TpyRE_juyA)

ඞ

As the CEO of a startup company, you want to reward each of your k employees
with a ticket to the upcoming concert. The tickets will be on sale for n days,
and by some time travelling, you have predicted that the price per ticket at
day i will be a_i . However, to prevent ticket hoarding, the concert
organizers have implemented the following measures:

  * A person may purchase no more than m tickets per day. 
  * If a person purchases x tickets on day i , all subsequent days (i.e. from day i+1 onwards) will have their prices per ticket increased by x . 

For example, if a = [1, 3, 8, 4, 5] and you purchase 2 tickets on day 1 , they
will cost 2 in total, and the prices from day 2 onwards will become [5, 10, 6,
7] . If you then purchase 3 more tickets on day 2 , they will cost in total an
additional 15 , and the prices from day 3 onwards will become [13, 9, 10] .

Find the minimum spending to purchase k tickets.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains three integers n , m , and k (1 \le
n \le 3 \cdot 10^5, 1 \le m \le 10^9, 1 \le k \le \min(nm, 10^9) ) — the
number of sale days, the maximum amount of ticket purchasable each day, and
the number of tickets to be bought at the end.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the price per ticket for each of the upcoming n days.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the minimum amount of money needed to
purchase exactly k tickets.

Example

Input

    4
    
    4 2 3
    
    8 6 4 2
    
    4 2 8
    
    8 6 4 2
    
    5 100 1
    
    10000 1 100 10 1000
    
    6 3 9
    
    5 5 5 5 5 5

Output

    10
    64
    1
    72
    
Note

In the first test case, one optimal way to buy 3 tickets is as follows:

  * Buy 0 tickets on the first day. The prices per ticket for the remaining days are [6, 4, 2] . 
  * Buy 0 tickets on the second day. The prices per ticket for the remaining days are [4, 2] . 
  * Buy 1 ticket on the third day with cost 4 . The price per ticket for the remaining day is [3] . 
  * Buy 2 tickets on the fourth day with cost 6 . 

In the second test case, there is only one way to buy 8 tickets:

  * Buy 2 tickets on the first day with cost 16 . The prices per ticket for the remaining days are [8, 6, 4] . 
  * Buy 2 tickets on the second day with cost 16 . The prices per ticket for the remaining days are [8, 6] . 
  * Buy 2 tickets on the third day with cost 16 . The price per ticket for the remaining day is [8] . 
  * Buy 2 tickets on the fourth day with cost 16 .","from math import ceil
n= int(input())
for i in range(n):
    n,m,k = map(int, input().split())
    a=list(map(int, input().split()))
    if k<=m:
        print(min(a)*k)
    else:
        if k%m==0:
            s=set(sorted(a)[:k//m])
            b=[]
            leng=0
            for i in range(n):
                if a[i] in s and leng<k//m:
                    b.append(a[i])
                    leng+=1
            c=0
            res=0
            for i in range(len(b)):
                res+=(b[i]+c)*m
                c+=m
        else:
            s=set(sorted(a)[:k//m+1])
            b=[]
            leng=0
            for i in range(n):
                if a[i] in s and leng<k//m+1:
                    b.append(a[i])
                    leng+=1
            c=0
            res=0
            mx=max(b)
            mx_ind_lt=max(i for i in range(len(b)) if b[i]==mx)
            for i in range(len(b)):
                if b[i]==mx and i==mx_ind_lt:
                    res+=(b[i]+c)*(k%m)
                    c+=(k%m)
                else:
                    res+=(b[i]+c)*m
                    c+=m
        print(res)",2,False,False,False,True,False,True,False,False,False,False,False,False,False
60,codeforces2024,human,qwen2.5-7b-instruct,"You are given two integers x and y . A sequence a of length n is called
modular if a_1=x , and for all 1 < i \le n the value of a_{i} is either
a_{i-1} + y or a_{i-1} \bmod y . Here x \bmod y denotes the remainder from
dividing x by y .

Determine if there exists a modular sequence of length n with the sum of its
elements equal to S , and if it exists, find any such sequence.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 2 \cdot 10^4 ). The description of the test cases
follows.

The first and only line of each test case contains four integers n , x , y ,
and s (1 \le n \le 2 \cdot 10^5 , 0 \le x \le 2 \cdot 10^5 , 1 \le y \le 2
\cdot 10^5 , 0 \le s \le 2 \cdot 10^5 ) — the length of the sequence, the
parameters x and y , and the required sum of the sequence elements.

The sum of n over all test cases does not exceed 2 \cdot 10^5 , and also the
sum of s over all test cases does not exceed 2 \cdot 10^5 .

Output

For each test case, if the desired sequence exists, output ""Yes"" on the first
line (without quotes). Then, on the second line, output n integers a_1, a_2,
\ldots, a_n separated by a space — the elements of the sequence a . If there
are multiple suitable sequences, output any of them.

If the sequence does not exist, output ""No"" on a single line.

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    3
    
    5 8 3 28
    
    3 5 3 6
    
    9 1 5 79

Output

    YES
    8 11 2 2 5 
    NO
    NO
    
Note

In the first example, the sequence [8, 11, 2, 5, 2] satisfies the conditions.
Thus, a_1 = 8 = x , a_2 = 11 = a_1 + 3 , a_3 = 2 = a_2 \bmod 3 , a_4 = 5 = a_3
+ 3 , a_5 = 2 = a_4 \bmod 3 .

In the second example, the first element of the sequence should be equal to 5
, so the sequence [2, 2, 2] is not suitable.","def find_modular_sequence(n, x, y, s):
    # Initialize the sequence with the first element
    sequence = [x]
    current_sum = x

    # Calculate the sequence
    for i in range(1, n):
        # Check if adding y or taking mod y will help reach the sum
        if current_sum + y <= s and (s - current_sum - y) % y == 0:
            sequence.append(sequence[-1] + y)
            current_sum += y
        else:
            sequence.append(sequence[-1] % y)
            current_sum += sequence[-1]

        # If the current sum exceeds the required sum, it's not possible
        if current_sum > s:
            return None

    # Check if the final sum matches the required sum
    if current_sum == s:
        return sequence
    else:
        return None

# Input reading
t = int(input())
for _ in range(t):
    n, x, y, s = map(int, input().split())
    result = find_modular_sequence(n, x, y, s)
    if result:
        print(""Yes"")
        print("" "".join(map(str, result)))
    else:
        print(""No"")",2,False,False,False,True,False,True,True,True,True,True,True,False,True
121,codeforces2024,human,qwen2.5-7b-instruct,"This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either ""first"" or ""second"",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print ""0 0"" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
""-1 -1"" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints ""-1 -1"", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.","for _ in range(int(input())):
    n = int(input())
    
    # Determine whether to play first or second based on the number of 1s in the binary representation of n
    if bin(n).count('1') & 1:
        # If the count of 1s is odd, choose to play second
        print('second')
    else:
        # If the count of 1s is even, choose to play first
        print('first')
        
        # Calculate l by removing the first '1' from the binary representation of n
        l = int(bin(n)[3:], 2)
        
        # Print the two numbers p1 and p2 such that p1 XOR p2 = n
        print(n ^ l, l)
    
    # Continue the game until a break condition is met
    while True:
        a, b = map(int, input().split())
        
        # If both numbers are the same, it means the opponent cannot break further
        if a == b:
            break
        
        # Choose the number for the next round based on the number of 1s in its binary representation
        n = b if bin(a).count('1') & 1 else a
        
        # Calculate l for the chosen number
        l = int(bin(n)[3:], 2)
        
        # Print the two numbers for the next move
        print(n ^ l, l)",2,True,False,False,True,False,True,True,True,False,True,True,False,True
278,codeforces2024,human,qwen2.5-7b-instruct,"In the hard version, 2 \leq \sum n \leq 10^5 and 1 \leq \sum m \leq 5 \times
10^{5}

After a worker's strike organized by the Dementors asking for equal rights,
the prison of Azkaban has suffered some damage. After settling the spirits,
the Ministry of Magic is looking to renovate the prison to ensure that the
Dementors are kept in check. The prison consists of n prison cells and m bi-
directional corridors. The i^{th} corridor is from cells u_i to v_i . A subset
of these cells S is called a complex if any cell in S is reachable from any
other cell in S . Formally, a subset of cells S is a complex if x and y are
reachable from each other for all x, y \in S , using only cells from S on the
way. The funding required for a complex S consisting of k cells is defined as
k^2 .

As part of your Intro to Magical Interior Design course at Hogwarts, you have
been tasked with designing the prison. The Ministry of Magic has asked that
you divide the prison into 2 complexes with \textbf{exactly one corridor}
connecting them, so that the Dementors can't organize union meetings. For this
purpose, you are allowed to build bi-directional corridors. The funding
required to build a corridor between any 2 cells is c .

Due to budget cuts and the ongoing fight against the Death Eaters, you must
find the \textbf{minimum total funding} required to divide the prison as per
the Ministry's requirements or -1 if no division is possible.

Note: The total funding is the sum of the funding required for the 2 complexes
and the corridors built. If after the division, the two complexes have x and y
cells respectively and you have built a total of a corridors, the total
funding will be x^2 + y^2 + c \times a . Note that x+y=n .

Input

The first line contains one integer t (1 \leq t \leq 10^5 ) — the number of
test cases. Then t test cases follow.

The first line of each test case consists of three integers n, m and c (2 \leq
n \leq 10^5 , 1 \leq m \leq 5 \times 10^{5} , 1 \leq c \leq 10^9 )

m lines follow, each consisting of 2 integers — u_i, v_i indicating a corridor
is present between cells u_i and v_i (1 \leq u_i, v_i \leq n , u_i \neq v_i )

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

It is guaranteed that the sum of m over all test cases does not exceed 5
\times 10^5 .

It is guaranteed that there exists at most one corridor between any two cells.

Output

Print the \textbf{minimum funding} required to divide the prison as per the
Ministry's requirements or -1 if no division is possible.

Example

Input

    4
    4 6 5
    4 3
    2 3
    2 4
    1 2
    4 1
    3 1
    6 6 2
    1 4
    2 5
    3 6
    1 5
    3 5
    6 5
    6 5 7
    1 4
    2 5
    3 6
    3 5
    6 5
    7 5 4
    1 4
    3 6
    3 5
    6 5
    2 7
    
Output

    -1
    20
    25
    33
    
Note

In the first test case of the sample input, there is no way to divide the
prison according to the Ministry's requirements.

In the second test case, consider the corridor between cells 1 and 5 as the
connection between the 2 complexes consisting of \\{2, 3, 5, 6\\} and \\{1,
4\\} cells respectively. There are no new corridors built. The total funding
is 4^2 + 2^2 = 20 . You can verify this is the minimum funding required.
![](https://espresso.codeforces.com/488c4eea08add11cc82237beac3677afcab875e3.png)

In the third test case, build a corridor between 2 and 4 . Consider the
corridor between cells 1 and 5 as the connection between the 2 complexes
consisting of \\{3, 5, 6\\} and \\{1, 2, 4\\} cells respectively. The total
funding is 3^2 + 3^2 + 7 \times 1 = 25 . You can verify this is the minimum
funding required.
![](https://espresso.codeforces.com/e7d162def53b600d35b9d046999c712212f7e0f6.png)

In the fourth test case, build a corridor between 2 and 4 and between 5 and 7
. Consider the corridor between cells 5 and 7 as the connection between the 2
complexes consisting of \\{1, 2, 4, 7\\} and \\{3, 5, 6\\} cells respectively.
The total funding is 4^2 + 3^2 + 4 \times 2 = 33 . You can verify this is the
minimum funding required.
![](https://espresso.codeforces.com/d7da43c68cf5654a9468a410eba14ccbc8ac8a15.png)

Note for all test cases that there may be multiple ways to get the same
funding but there is no other division which will have a more optimal minimum
funding.","from collections import defaultdict, deque

def find_components(n, edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    visited = [False] * (n + 1)
    components = []
    
    def bfs(start):
        queue = deque([start])
        component = []
        while queue:
            node = queue.popleft()
            if not visited[node]:
                visited[node] = True
                component.append(node)
                for neighbor in graph[node]:
                    if not visited[neighbor]:
                        queue.append(neighbor)
        return component
    
    for i in range(1, n + 1):
        if not visited[i]:
            components.append(bfs(i))
    
    return components

def min_funding(n, m, c, edges):
    components = find_components(n, edges)
    if len(components) == 1:
        return -1
    
    min_cost = float('inf')
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            cost_i = len(components[i]) ** 2
            cost_j = len(components[j]) ** 2
            min_cost = min(min_cost, cost_i + cost_j + c)
    
    return min_cost

# Input processing
t = int(input())
for _ in range(t):
    n, m, c = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(m)]
    print(min_funding(n, m, c, edges))",2,False,False,False,False,False,True,True,False,False,True,False,False,True
231,codeforces2024,human,qwen2.5-7b-instruct,"Monocarp is opening his own IT company. He wants to hire n programmers and m
testers.

There are n+m+1 candidates, numbered from 1 to n+m+1 in chronological order of
their arriving time. The i -th candidate has programming skill a_i and testing
skill b_i (a person's programming skill is different from their testing
skill). The skill of the team is the sum of the programming skills of all
candidates hired as programmers, and the sum of the testing skills of all
candidates hired as testers.

When a candidate arrives to interview, Monocarp tries to assign them to the
most suitable position for them (if their programming skill is higher, then he
hires them as a programmer, otherwise as a tester). If all slots for that
position are filled, Monocarp assigns them to the other position.

Your task is, for each candidate, calculate the skill of the team if everyone
except them comes to interview. Note that it means that exactly n+m candidates
will arrive, so all n+m positions in the company will be filled.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

Each test case consists of three lines:

  * the first line contains two integers n and m (0 \le n, m \le 2 \cdot 10^5 ; 2 \le n + m + 1 \le 2 \cdot 10^5 ) — the number of programmers and the number of testers Monocarp wants to hire, respectively; 
  * the second line contains n + m + 1 integers a_1, a_2, \dots, a_{n+m+1} (1 \le a_i \le 10^9 ), where a_i is the programming skill of the i -th candidate; 
  * the third line contains n + m + 1 integers b_1, b_2, \dots, b_{n+m+1} (1 \le b_i \le 10^9 ; b_i \ne a_i ), where b_i is the testing skill of the i -th candidate. 

Additional constraint on the input: the sum of (n + m + 1) over all test cases
doesn't exceed 2 \cdot 10^5 .

Output

For each test case, print n + m + 1 integers, where the i -th integer should
be equal to the skill of the team if everyone except the i -th candidate comes
to interview.

Example

Input

    4
    
    1 0
    
    2 1
    
    1 2
    
    0 2
    
    4 5 5
    
    5 4 1
    
    1 2
    
    2 1 5 4
    
    5 2 3 1
    
    3 1
    
    4 3 3 4 1
    
    5 5 4 5 2

Output

    1 2 
    5 6 9 
    8 11 11 12 
    13 13 13 12 15 
    
Note

Let's consider the third test case of the example:

  * if the 1 -st candidate does not arrive, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 2 + 5 + 1 = 8 ; 
  * if the 2 -nd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 5 + 5 + 1 = 11 ; 
  * if the 3 -rd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 4 -th candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 4 = 11 ; 
  * if the 4 -th candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 5 = 12 .","def main():
    import sys
    input = sys.stdin.read
    data = input().split()

    index = 0
    t = int(data[index])
    index += 1
    results = []

    for _ in range(t):
        n = int(data[index])
        m = int(data[index + 1])
        index += 2

        a = list(map(int, data[index:index + n + m + 1]))
        index += n + m + 1

        b = list(map(int, data[index:index + n + m + 1]))
        index += n + m + 1

        # Combine and sort by abs(a[i] - b[i])
        combined = [(a[i], b[i]) for i in range(n + m + 1)]
        combined.sort(key=lambda x: abs(x[0] - x[1]))

        # Calculate initial team skills
        p_skill = sum(combined[i][0] for i in range(n))
        t_skill = sum(combined[i][1] for i in range(m))

        result = []
        for i in range(n + m + 1):
            new_p_skill = p_skill - combined[i][0]
            new_t_skill = t_skill - combined[i][1]

            if combined[i][0] > combined[i][1]:
                result.append(new_p_skill)
            else:
                result.append(new_t_skill)

        results.append(result)

    for res in results:
        print("" "".join(map(str, res)))

# Uncomment the next line to run the function if this script is executed directly
# main()",2,False,False,False,True,False,True,True,False,True,False,True,True,False
271,codeforces2024,human,qwen2.5-7b-instruct,"The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 30 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1","import random

def generate_magic_words(n):
    magic_words = []
    for _ in range(n):
        length = random.randint(1, 30 * n)
        word = ''.join(random.choice(['X', 'O']) for _ in range(length))
        magic_words.append(word)
    return magic_words

def count_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)

def find_words(magic_words, power):
    for i in range(len(magic_words)):
        for j in range(len(magic_words)):
            spell = magic_words[i] + magic_words[j]
            if count_substrings(spell) == power:
                return i + 1, j + 1
    return -1, -1

n = int(input())
magic_words = generate_magic_words(n)
for word in magic_words:
    print(word)
print(flush=True)

q = int(input())
for _ in range(q):
    power = int(input())
    u, v = find_words(magic_words, power)
    print(u, v)
    print(flush=True)",2,False,False,False,True,True,False,True,True,True,True,False,False,False
118,codeforces2024,human,qwen2.5-7b-instruct,"You are given two integers n and k (k \le n ), where k is even.

A permutation of length n is an array consisting of n distinct integers from 1
to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (as 2 appears twice in the array) and [0,1,2] is also not a
permutation (as n=3 , but 3 is not present in the array).

Your task is to construct a k -level permutation of length n .

A permutation is called k -level if, among all the sums of continuous segments
of length k (of which there are exactly n - k + 1 ), any two sums differ by no
more than 1 .

More formally, to determine if the permutation p is k -level, first construct
an array s of length n - k + 1 , where s_i=\sum_{j=i}^{i+k-1} p_j , i.e., the
i -th element is equal to the sum of p_i, p_{i+1}, \dots, p_{i+k-1} .

A permutation is called k -level if \max(s) - \min(s) \le 1 .

Find any k -level permutation of length n .

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. This is followed by the description of the test
cases.

The first and only line of each test case contains two integers n and k (2 \le
k \le n \le 2 \cdot 10^5 , k is even), where n is the length of the desired
permutation.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output any k -level permutation of length n .

It is guaranteed that such a permutation always exists given the constraints.

Example

Input

    5
    
    2 2
    
    3 2
    
    10 4
    
    13 4
    
    7 4

Output

    2 1
    1 3 2
    1 8 4 10 2 7 5 9 3 6
    4 10 1 13 5 9 2 12 6 8 3 11 7
    1 6 3 7 2 5 4
    
Note

In the second test case of the example:

  * p_1 + p_2 = 3 + 1 = 4 ; 
  * p_2 + p_3 = 1 + 2 = 3 . 

The maximum among the sums is 4 , and the minimum is 3 .","from math import *
a = int(input())
for _ in range(a):
  b,c = map(int,input().split())
  h = ceil(b/c)
  s = b
  m = 0
  o  = []
  f = 0
  l = 0
  for y in range(b):
    
    if y%c == 0:
      f = 0
      s = b-m
      m += 1
      l = h
      o.append(s)
    else:
      s -= l
      o.append(s)
      if l%2 == 0:
        if f >= 0:
          if l > 2:
            l -= 1
            
          f = 0
      
        else:
          f += 1
      else:
        if f >= 1:
          if l > 2:
            l -= 1
          f = 0
      
        else:
          f += 1
      
      
  print(*o)",2,False,False,False,False,False,False,False,False,True,False,True,False,False
105,codeforces2024,human,qwen2.5-7b-instruct,"Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .","R=lambda:map(int,input().split())
t,=R()
while t:
 t-=1;n,k,x=R();a=[0]
 for y in sorted(R()):a+=a[-1]+y,
 print(max(2*a[max(i,x)-x]-a[i]for i in range(n-k,n+1)))",2,True,False,False,True,False,True,True,False,False,False,True,True,True
57,codeforces2024,human,qwen2.5-7b-instruct,"In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in ""the first–k -th"" position.

As is known, settling in ""the first–k -th"" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the ""Note"" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.","def count_valid_k(n, x):
    count = 0
    k = 2
    while (2 * k - 2) <= n:
        cycle_length = 2 * k - 2
        position_in_cycle = (n - 1) % cycle_length + 1
        
        if position_in_cycle <= k:
            expected_number = position_in_cycle
        else:
            expected_number = 2 * k - position_in_cycle
        
        if expected_number == x:
            count += 1
        
        k += 1
    
    return count

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    index = 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        x = int(data[index + 1])
        index += 2
        results.append(count_valid_k(n, x))
    
    for result in results:
        print(result)",2,False,True,False,True,True,True,True,True,True,True,True,True,True
45,codeforces2024,human,qwen2.5-7b-instruct,"Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.","def invert_bit(number):
    mask = 2147483647
    return ~number & mask
 
t = int(input())
for _ in range(t):
    n = int(input())
    list_a = list(map(int,input().split()))
    set_a = set(list_a)
    dict_invert_a = {}
    while list_a:
        a = list_a.pop(-1)
        if a in dict_invert_a:
            if dict_invert_a[a] > 0:
                dict_invert_a[a] -= 1
                n -= 1
                continue
        invert_a = invert_bit(a)
 
        if invert_a in set_a:
            if invert_a in dict_invert_a:
                dict_invert_a[invert_a] += 1
            else:
                dict_invert_a[invert_a] = 1
    print(n)",2,True,False,False,False,False,False,True,False,False,True,True,True,True
319,codeforces2024,human,qwen2.5-7b-instruct,"For an array b of m non-negative integers, define f(b) as the maximum value of \max\limits_{i = 1}^{m} (b_i | x) - \min\limits_{i = 1}^{m} (b_i | x) over all possible non-negative integers x , where | is [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).

You are given integers n and q . You start with an empty array a . Process the
following q queries:

  * v : append v to the back of a and then output f(a) . It is guaranteed that 0 \leq v < n . 

The queries are given in a modified way.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^5 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and q (1 \leq n \leq
2^{22} , 1 \leq q \leq 10^6 ) — the number of queries.

The second line of each test case contains q space-separated integers
e_1,e_2,\ldots,e_q (0 \leq e_i < n ) — the encrypted values of v .

Let \mathrm{last}_i equal the output of the (i-1) -th query for i\geq 2 and
\mathrm{last}_i=0 for i=1 . Then the value of v for the i -th query is (e_i +
\mathrm{last}_i ) modulo n .

It is guaranteed that the sum of n over all test cases does not exceed 2^{22}
and the sum of q over all test cases does not exceed 10^6 .

Output

For each test case, print q integers. The i -th integer is the output of the i
-th query.

Example

Input

    2
    
    5 2
    
    1 2
    
    7 4
    
    3 1 5 2

Output

    0 2
    0 2 3 5
    
Note

In the first test case, the final a=[1,2] . For i=1 , the answer is always 0 ,
irrespective of x . For i=2 , we can select x=5 .

In the second test case, the final a=[3,1,0,5] .","def maximize_difference(n, q, encrypted_values):
    # Initialize the array a
    a = []
    # Initialize the last value
    last = 0
    # Initialize the result list
    results = []

    for i in range(q):
        # Decrypt the value
        v = (encrypted_values[i] + last) % n
        # Append v to the array a
        a.append(v)
        # Calculate f(a)
        f_a = calculate_f(a)
        # Update the last value
        last = f_a
        # Append the result
        results.append(f_a)

    return results

def calculate_f(b):
    # Calculate the maximum and minimum values of b_i | x for all possible x
    max_val = max(b)
    min_val = min(b)
    # Calculate the maximum difference
    return max_val - min_val

# Input reading
t = int(input())
for _ in range(t):
    n, q = map(int, input().split())
    encrypted_values = list(map(int, input().split()))
    # Process the queries
    results = maximize_difference(n, q, encrypted_values)
    # Print the results
    print(' '.join(map(str, results)))",2,False,False,False,False,True,True,False,True,False,False,False,False,True
123,codeforces2024,human,qwen2.5-7b-instruct,"Given an array a of n elements, find the maximum value of the expression:

where i , j , k , and l are four distinct indices of the array a , with 1 \le
i, j, k, l \le n .

Here |x| denotes the absolute value of x .

Input

The first line contains one integer t (1 \le t \le 500 ) — the number of test
cases. The description of the test cases follows.

The first line of each test case contains a single integer n (4 \le n \le 100
) — the length of the given array.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^6 \le a_i \le 10^6 ).

Output

For each test case, print a single integer — the maximum value.

Example

Input

    5
    
    4
    
    1 1 1 1
    
    5
    
    1 1 2 2 3
    
    8
    
    5 1 3 2 -3 -1 10 3
    
    4
    
    3 3 1 1
    
    4
    
    1 2 2 -1

Output

    0
    6
    38
    8
    8
    
Note

In the first test case, for any selection of i , j , k , l , the answer will
be 0 . For example, |a_1 - a_2| + |a_2 - a_3| + |a_3 - a_4| + |a_4 - a_1| = |1
- 1| + |1 - 1| + |1 - 1| + |1 - 1| = 0 + 0 + 0 + 0 = 0 .

In the second test case, for i = 1 , j = 3 , k = 2 , and l = 5 , the answer
will be 6 . |a_1 - a_3| + |a_3 - a_2| + |a_2 - a_5| + |a_5 - a_1| = |1 - 2| +
|2 - 1| + |1 - 3| + |3 - 1| = 1 + 1 + 2 + 2 = 6 .","def max_expression(t, test_cases):
    results = []
    for n, array in test_cases:
        array.sort()
        candidates = [
            (array[0], array[1], array[-1], array[-2]),
            (array[0], array[-1], array[1], array[-2])
        ]
        max_val = 0
        for i, j, k, l in candidates:
            value = abs(i - j) + abs(j - k) + abs(k - l) + abs(l - i)
            max_val = max(max_val, value)
        results.append(max_val)
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n = int(input())
    array = list(map(int, input().split()))
    test_cases.append((n, array))
results = max_expression(t, test_cases)
for result in results:
    print(result)",2,True,False,False,True,True,True,True,False,True,False,False,False,False
318,codeforces2024,human,qwen2.5-7b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","def solve(n):
    odd = list(range(1, n + 1, 2))    # Nieparzyste
    even = list(range(2, n + 1, 2))   # Parzyste
    p = odd + even                    # Połączenie: najpierw nieparzyste, potem parzyste
    print(*p)

# Przykład użycia
t = int(input())
while t > 0:
   n = int(input())
   solve(n)
   t -=1",2,False,False,True,True,True,True,False,True,True,True,False,False,False
97,codeforces2024,human,qwen2.5-7b-instruct,"The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.","t = int(input())
for _ in range(t):
    a, b, c = map(int, input().split())
    tents = a  
    if b % 3 == 0:
        tents += b // 3
    elif b % 3 == 1:
        if c >= 2:
            tents += b // 3 + 1  
            c -= 2
        else:
            print(-1)
            continue
    elif b % 3 == 2:
        if c >= 1:
            tents += b // 3 + 1  
            c -= 1
        else:
            print(-1)
            continue
    if c >= 0:
        tents += c // 3 + (1 if c % 3 > 0 else 0)
        print(tents)
    else:
        print(-1)",2,True,False,False,True,False,True,True,True,True,True,False,False,True
48,codeforces2024,human,qwen2.5-7b-instruct,"In order to test the hypothesis about the cats, the scientists must arrange
the cats in the boxes in a specific way. Of course, they would like to test
the hypothesis and publish a sensational article as quickly as possible,
because they are too engrossed in the next hypothesis about the phone's
battery charge.

Scientists have n boxes in which cats may or may not sit. Let the current
state of the boxes be denoted by the sequence b_1, \dots, b_n : b_i = 1 if
there is a cat in box number i , and b_i = 0 otherwise.

Fortunately, the unlimited production of cats has already been established, so
in one day, the scientists can perform one of the following operations:

  * Take a new cat and place it in a box (for some i such that b_i = 0 , assign b_i = 1 ). 
  * Remove a cat from a box and send it into retirement (for some i such that b_i = 1 , assign b_i = 0 ). 
  * Move a cat from one box to another (for some i, j such that b_i = 1, b_j = 0 , assign b_i = 0, b_j = 1 ). 

It has also been found that some boxes were immediately filled with cats.
Therefore, the scientists know the initial position of the cats in the boxes
s_1, \dots, s_n and the desired position f_1, \dots, f_n .

Due to the large amount of paperwork, the scientists do not have time to solve
this problem. Help them for the sake of science and indicate the minimum
number of days required to test the hypothesis.

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
descriptions of the test cases.

Each test case consists of three lines.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the number of boxes.

The second line of each test case contains a string s of n characters, where
the i -th character is '1' if there is a cat in the i -th box and '0'
otherwise.

The third line of each test case contains a string f of n characters, where
the i -th character is '1' if there should be a cat in the i -th box and '0'
otherwise.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the minimum
number of operations required to obtain the desired position from the initial
position. It can be shown that a solution always exists.

Example

Input

    6
    
    5
    
    10010
    
    00001
    
    1
    
    1
    
    1
    
    3
    
    000
    
    111
    
    4
    
    0101
    
    1010
    
    3
    
    100
    
    101
    
    8
    
    10011001
    
    11111110

Output

    2
    0
    3
    2
    1
    4
    
Note

In the first test case, you can first move the cat from the first box to the
fifth, and then remove the cat from the fourth box.

In the second test case, there is nothing to do — the only cat is already
sitting in the correct box.

In the third test case of input data, it takes three days to place a cat in
each box.","for _ in range(int(input())):
  n=int(input())
  s=input()
  t=input()
  s1=s.count('1');t1=t.count('1')
  cnt=0
  for i in range(n):
    cnt+=s[i]!=t[i]
  if s1==t1:
    print(s1 if cnt else 0)
  else:
    d=abs(s1-t1)
    print((cnt-d)//2+d)",2,False,False,False,True,True,True,True,True,True,True,True,True,True
282,codeforces2024,human,qwen2.5-7b-instruct,"The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 1000 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1","import sys

# Read the number of magic words to create
n = int(input())

# Generate n distinct magic words
# The pattern used here is 'X' repeated i times followed by 'O' if i is odd
words = ['X' * i + 'O' * (i % 2) for i in range(1, n + 1)]

# Print the magic words, one per line
print('\n'.join(words))
sys.stdout.flush()

# Precompute the powers of all possible concatenations of magic words
powers = {}
for i in range(n):
    for j in range(n):
        # Concatenate the words and calculate the power
        concatenated = words[i] + words[j]
        power = len(set(concatenated[k:l] for k in range(len(concatenated)) for l in range(k + 1, len(concatenated) + 1)))
        # Store the power and the indices in the dictionary
        powers[power] = (i + 1, j + 1)

# Read the number of students (queries)
q = int(input())

# Process each query
for _ in range(q):
    # Read the power of the spell
    p = int(input())
    # Look up the power in the dictionary to find the indices
    u, v = powers[p]
    # Print the indices of the magic words
    print(u, v)
    sys.stdout.flush()",2,False,False,True,True,True,True,True,False,True,True,True,False,False
282,codeforces2024,human,qwen2.5-7b-instruct,"The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 1000 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1","n = int(input())
 
w = []
q = {}
i = -1
 
def f(a,b):
    return (a+2)*(b+4)-1 if a >= b else (a+5)*(b+1)-1
 
while len(w) < n:
    i += 1
    if f(i,i) in q:
        continue
    if any(f(i,j) in q for j in w):
        continue
    if any(f(j,i) in q for j in w):
        continue
    q1 = {f(i,i): (len(w),len(w))}
    ok = True
    for r,j in enumerate(w):
        v = f(i,j)
        if v in q1:
            ok = False
            break
        q1[v] = len(w),r
    if not ok:
        continue
    for r,j in enumerate(w):
        v = f(j,i)
        if v in q1:
            ok = False
            break
        q1[v] = r,len(w)
    if not ok:
        continue
    q.update(q1)
    w.append(i)
 
for i in w:
    print(""XO""+i*""X"")
    
t = int(input())
for _ in range(t):
    x = int(input())
    u,v = q[x]
    print(u+1, v+1)",2,True,False,False,True,False,True,True,False,False,True,False,False,True
291,codeforces2024,human,qwen2.5-7b-instruct,"You have an array a of n integers.

You perform exactly k operations on it. In one operation, you select any
contiguous subarray of the array a (possibly empty) and insert the sum of this
subarray anywhere in the array.

Your task is to find the maximum possible sum of the array after k such
operations.

As this number can be very large, output the answer modulo 10^9 + 7 .

Reminder: the remainder of a number x modulo p is the smallest non-negative y
such that there exists an integer q and x = p \cdot q + y .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and k (1 \le n, k \le
2 \cdot 10^5 ) — the length of the array a and the number of operations,
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^9 \le a_i \le 10^9 ) — the array a itself.

It is guaranteed that the sum of the values of n and k for all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test, output a single integer — the maximum sum of the array that can
be obtained after k operations modulo 10^9 + 7 .

Example

Input

    12
    
    2 2
    
    -4 -7
    
    3 3
    
    2 2 8
    
    1 7
    
    7
    
    5 1
    
    4 -2 8 -12 9
    
    7 4
    
    8 14 -9 6 0 -1 3
    
    7 100
    
    5 3 -8 12 -5 -9 3
    
    6 1000
    
    -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000
    
    2 1
    
    1000000000 8
    
    5 4
    
    0 0 0 0 0
    
    6 10
    
    48973 757292 58277 -38574 27475 999984
    
    7 1
    
    -1000 1000 -1000 1000 -1000 1000 -1000
    
    10 10050
    
    408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output

    999999996
    96
    896
    17
    351
    716455332
    42
    2
    0
    897909241
    0
    416571966
    
Note

In the first test case, it is advantageous to take an empty subarray of the
array twice and insert the sum of the empty subarray (zero) anywhere, then the
sum of the resulting array will be (-4) + (-7) + 0 + 0 = -11 , modulo 10^9 + 7
this is 999\,999\,996 .

In the second test case, it is advantageous to take the sum of the entire
array three times and place it anywhere in the array, then one of the possible
sequences of actions: [2, 2, 8 ] \rightarrow [2, 2, 8, 12 ] \rightarrow [2, 2,
8, 12, 24 ] \rightarrow [2, 2, 8, 12, 24, 48 ], the sum of the final array is
2 + 2 + 8 + 12 + 24 + 48 = 96 .

In the fourth test case, it is advantageous to take a subarray of the array
consisting of the first three numbers (i.e. consisting of the numbers 4, -2
and 8 ) and insert its sum at the beginning of the array, thereby obtaining
the array [10, 4, -2, 8, -12, 9 ], the sum of this array is 17 .

In the seventh test case, it will always be advantageous for us to take an
empty subarray of the array. In this case, the sum of the resulting array will
not differ from the sum of the original. The answer will be the sum of the
original array, taken modulo — 42 , because (-6 \cdot (10^9 + 7) + 42 =
-6\,000\,000\,000) .","MOD = 10**9 + 7

for _ in range(int(input())):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    _sum = 0
    _max = 0

    for i in range(n):
        _sum = max(0, _sum + a[i])
        _max = max(_max, _sum)

    _acc = 0
    for i in range(k):
        _acc += (_acc + _max) % MOD

    print((sum(a) + _acc) % MOD)",2,True,False,True,False,True,True,True,True,True,True,False,True,True
118,codeforces2024,human,qwen2.5-7b-instruct,"You are given two integers n and k (k \le n ), where k is even.

A permutation of length n is an array consisting of n distinct integers from 1
to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (as 2 appears twice in the array) and [0,1,2] is also not a
permutation (as n=3 , but 3 is not present in the array).

Your task is to construct a k -level permutation of length n .

A permutation is called k -level if, among all the sums of continuous segments
of length k (of which there are exactly n - k + 1 ), any two sums differ by no
more than 1 .

More formally, to determine if the permutation p is k -level, first construct
an array s of length n - k + 1 , where s_i=\sum_{j=i}^{i+k-1} p_j , i.e., the
i -th element is equal to the sum of p_i, p_{i+1}, \dots, p_{i+k-1} .

A permutation is called k -level if \max(s) - \min(s) \le 1 .

Find any k -level permutation of length n .

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. This is followed by the description of the test
cases.

The first and only line of each test case contains two integers n and k (2 \le
k \le n \le 2 \cdot 10^5 , k is even), where n is the length of the desired
permutation.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output any k -level permutation of length n .

It is guaranteed that such a permutation always exists given the constraints.

Example

Input

    5
    
    2 2
    
    3 2
    
    10 4
    
    13 4
    
    7 4

Output

    2 1
    1 3 2
    1 8 4 10 2 7 5 9 3 6
    4 10 1 13 5 9 2 12 6 8 3 11 7
    1 6 3 7 2 5 4
    
Note

In the second test case of the example:

  * p_1 + p_2 = 3 + 1 = 4 ; 
  * p_2 + p_3 = 1 + 2 = 3 . 

The maximum among the sums is 4 , and the minimum is 3 .","def solve():
    n, k = map(int, input().split())
    l, r = 1, n
    ans = [0] * n
    for i in range(k):
        for j in range(i, n, k):
            if i % 2 == 0:
                ans[j] = l
                l += 1
            else:
                ans[j] = r
                r -= 1
    print(*ans)
    
    
for _ in range(int(input())):
    solve()",2,True,False,False,True,True,True,True,True,True,True,False,True,False
291,codeforces2024,human,qwen2.5-7b-instruct,"You have an array a of n integers.

You perform exactly k operations on it. In one operation, you select any
contiguous subarray of the array a (possibly empty) and insert the sum of this
subarray anywhere in the array.

Your task is to find the maximum possible sum of the array after k such
operations.

As this number can be very large, output the answer modulo 10^9 + 7 .

Reminder: the remainder of a number x modulo p is the smallest non-negative y
such that there exists an integer q and x = p \cdot q + y .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and k (1 \le n, k \le
2 \cdot 10^5 ) — the length of the array a and the number of operations,
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^9 \le a_i \le 10^9 ) — the array a itself.

It is guaranteed that the sum of the values of n and k for all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test, output a single integer — the maximum sum of the array that can
be obtained after k operations modulo 10^9 + 7 .

Example

Input

    12
    
    2 2
    
    -4 -7
    
    3 3
    
    2 2 8
    
    1 7
    
    7
    
    5 1
    
    4 -2 8 -12 9
    
    7 4
    
    8 14 -9 6 0 -1 3
    
    7 100
    
    5 3 -8 12 -5 -9 3
    
    6 1000
    
    -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000
    
    2 1
    
    1000000000 8
    
    5 4
    
    0 0 0 0 0
    
    6 10
    
    48973 757292 58277 -38574 27475 999984
    
    7 1
    
    -1000 1000 -1000 1000 -1000 1000 -1000
    
    10 10050
    
    408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output

    999999996
    96
    896
    17
    351
    716455332
    42
    2
    0
    897909241
    0
    416571966
    
Note

In the first test case, it is advantageous to take an empty subarray of the
array twice and insert the sum of the empty subarray (zero) anywhere, then the
sum of the resulting array will be (-4) + (-7) + 0 + 0 = -11 , modulo 10^9 + 7
this is 999\,999\,996 .

In the second test case, it is advantageous to take the sum of the entire
array three times and place it anywhere in the array, then one of the possible
sequences of actions: [2, 2, 8 ] \rightarrow [2, 2, 8, 12 ] \rightarrow [2, 2,
8, 12, 24 ] \rightarrow [2, 2, 8, 12, 24, 48 ], the sum of the final array is
2 + 2 + 8 + 12 + 24 + 48 = 96 .

In the fourth test case, it is advantageous to take a subarray of the array
consisting of the first three numbers (i.e. consisting of the numbers 4, -2
and 8 ) and insert its sum at the beginning of the array, thereby obtaining
the array [10, 4, -2, 8, -12, 9 ], the sum of this array is 17 .

In the seventh test case, it will always be advantageous for us to take an
empty subarray of the array. In this case, the sum of the resulting array will
not differ from the sum of the original. The answer will be the sum of the
original array, taken modulo — 42 , because (-6 \cdot (10^9 + 7) + 42 =
-6\,000\,000\,000) .","def check_digits(n):
    s = str(n)
    res = -1
    for i in range(len(s)):
        if int(s[i]) < 5:
            res = i
            break
    return res 
t = int(input())
for sfe in range(t):
    n,k = map(int,input().split())
    arr = list(map(int,input().split()))
    table = {}
    # mx = {0:[],1:0}
    ng = False
    l = 0
    r = n-1
    bsum = sum(arr)
    mx = bsum
    while (r-l != 0):
        if arr[l] <= arr[r]:
            bsum -= arr[l]
            l += 1
            mx = max(mx,bsum)
        else:
            bsum -= arr[r]
            mx = max(mx,bsum)
            r -= 1
    mx = max(0,mx)
    print(mx)
    print((sum(arr)+mx*(2**(k)-1))%(10**9+7))",2,False,False,False,False,False,False,False,False,False,False,True,False,False
1,codeforces2024,human,qwen2.5-7b-instruct,"You are given an array a of length 2n , consisting of each integer from 1 to n
exactly twice.

You are also given an integer k (1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

You need to find two arrays l and r each of length \mathbf{2k} such that:

  * l is a subset^\dagger of [a_1, a_2, \ldots a_n] 
  * r is a subset of [a_{n+1}, a_{n+2}, \ldots a_{2n}] 
  * [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of elements of l is equal to the bitwise XOR of elements of r ; in other words, l_1 \oplus l_2 \oplus \ldots \oplus l_{2k} = r_1 \oplus r_2 \oplus \ldots \oplus r_{2k} 

It can be proved that at least one pair of l and r always exists. If there are
multiple solutions, you may output any one of them.

^\dagger A sequence x is a subset of a sequence y if x can be obtained by
deleting several (possibly none or all) elements of y and rearranging the
elements in any order. For example, [3,1,2,1] , [1, 2, 3] , [1, 1] and [3, 2]
are subsets of [1, 1, 2, 3] but [4] and [2, 2] are not subsets of [1, 1, 2, 3]
.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains 2 integers n and k (2 \le n \le 5
\cdot 10^4 , 1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

The second line contains 2n integers a_1, a_2, \ldots, a_{2n} (1 \le a_i \le n
). It is guaranteed that every integer from 1 to n occurs exactly twice in a .

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^4 .

Output

For each test case, output two lines.

On the first line of output, output 2k integers l_1, l_2, \ldots, l_{2k} .

On the second line of output, output 2k integers r_1, r_2, \ldots r_{2k} .

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    2 1
    
    1 2 2 1
    
    6 1
    
    6 4 2 1 2 3 1 6 3 5 5 4
    
    4 1
    
    1 2 3 4 1 2 3 4
    
    6 2
    
    5 1 3 3 5 1 2 6 4 6 4 2

Output

    2 1
    2 1
    6 4
    1 3
    1 2
    1 2
    5 1 3 3
    6 4 2 4
    
Note

In the first test case, we choose l=[2,1] and r=[2,1] . [2, 1] is a subset of
[a_1, a_2] and [2, 1] is a subset of [a_3, a_4] , and 2 \oplus 1 = 2 \oplus 1
= 3 .

In the second test case, 6 \oplus 4 = 1 \oplus 3 = 2 .","import sys
from collections import Counter
import itertools as it
import copy


print = lambda x: sys.stdout.write(str(x) + ""\n"")
input = lambda: sys.stdin.readline().strip()



tc = int(input())
for _ in range(tc):

    n,k  = map(int, input().split())
    a = list(map(int, input().split()))
    k = 2*k

    half = a[:n]
    half2 = a[n:]
    cnts = Counter(half)
    cnts2 = Counter(half2)
    pairs = 0
    singles = 0

    for num, cnt in cnts.items():
        if cnt == 1:
            singles+=1
        else:
            pairs+=1

    #print(f""singles: {singles}, pairs: {pairs} in {half}, k={k}"")
    found = False
    ws = 0
    wp = 0
    for wanted_singles in range(k+1):
        if wanted_singles > singles:
            continue
        if (k - wanted_singles) % 2 == 1:
            continue

        wanted_pairs = (k-wanted_singles) >> 1
        if wanted_pairs > pairs:
            continue

        found = True
        ws = wanted_singles
        wp = wanted_pairs
        break

    assert found

    #print(f""ws: {ws}, wp: {wp}"")

    res1 = []
    res2 = []
    hs = 0
    for ai in half:
        if hs == ws:
            break
        if cnts[ai] == 1:
            hs+=1
            res1.append(ai)
            res2.append(ai)

    hp = 0
    for ai, cnt in cnts.items():
        if hp == wp:
            break
        if cnt == 2:
            hp+=1
            res1.append(ai)
            res1.append(ai)

    hp = 0
    for ai, cnt in cnts2.items():
        if hp == wp:
            break
        if cnt == 2:
            hp+=1
            res2.append(ai)
            res2.append(ai)

    print("" "".join(map(str, res1)))
    print("" "".join(map(str, res2)))",2,True,False,False,True,False,True,True,False,False,True,False,False,True
1,codeforces2024,human,qwen2.5-7b-instruct,"You are given an array a of length 2n , consisting of each integer from 1 to n
exactly twice.

You are also given an integer k (1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

You need to find two arrays l and r each of length \mathbf{2k} such that:

  * l is a subset^\dagger of [a_1, a_2, \ldots a_n] 
  * r is a subset of [a_{n+1}, a_{n+2}, \ldots a_{2n}] 
  * [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of elements of l is equal to the bitwise XOR of elements of r ; in other words, l_1 \oplus l_2 \oplus \ldots \oplus l_{2k} = r_1 \oplus r_2 \oplus \ldots \oplus r_{2k} 

It can be proved that at least one pair of l and r always exists. If there are
multiple solutions, you may output any one of them.

^\dagger A sequence x is a subset of a sequence y if x can be obtained by
deleting several (possibly none or all) elements of y and rearranging the
elements in any order. For example, [3,1,2,1] , [1, 2, 3] , [1, 1] and [3, 2]
are subsets of [1, 1, 2, 3] but [4] and [2, 2] are not subsets of [1, 1, 2, 3]
.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains 2 integers n and k (2 \le n \le 5
\cdot 10^4 , 1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

The second line contains 2n integers a_1, a_2, \ldots, a_{2n} (1 \le a_i \le n
). It is guaranteed that every integer from 1 to n occurs exactly twice in a .

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^4 .

Output

For each test case, output two lines.

On the first line of output, output 2k integers l_1, l_2, \ldots, l_{2k} .

On the second line of output, output 2k integers r_1, r_2, \ldots r_{2k} .

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    2 1
    
    1 2 2 1
    
    6 1
    
    6 4 2 1 2 3 1 6 3 5 5 4
    
    4 1
    
    1 2 3 4 1 2 3 4
    
    6 2
    
    5 1 3 3 5 1 2 6 4 6 4 2

Output

    2 1
    2 1
    6 4
    1 3
    1 2
    1 2
    5 1 3 3
    6 4 2 4
    
Note

In the first test case, we choose l=[2,1] and r=[2,1] . [2, 1] is a subset of
[a_1, a_2] and [2, 1] is a subset of [a_3, a_4] , and 2 \oplus 1 = 2 \oplus 1
= 3 .

In the second test case, 6 \oplus 4 = 1 \oplus 3 = 2 .","def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        k = 2 * k  # Doubling k
        
        a = list(map(int, input().split()))
        occ = [0] * (n + 1)

        for x in a:
            occ[x] += 1
        
        g0, g1, g2 = [], [], []
        for i in range(1, n + 1):
            if occ[i] == 0:
                g0.append(i)
            elif occ[i] == 1:
                g1.append(i)
            else:
                g2.append(i)
        
        v = 0
        output = []
        # Handle g2 first
        for x in g2:
            if v < k:
                output.append(f""{x} {x}"")
                v += 2
        
        # Handle g1 next
        for x in g1:
            if v < k:
                output.append(f""{x}"")
                v += 1
        
        # Print the first line
        print("" "".join(output))
        
        # Reset and handle g0
        v = 0
        output = []
        for x in g0:
            if v < k:
                output.append(f""{x} {x}"")
                v += 2
        
        # Handle g1 again
        for x in g1:
            if v < k:
                output.append(f""{x}"")
                v += 1
        
        # Print the second line
        print("" "".join(output))

if __name__ == ""__main__"":
    main()",2,False,False,False,False,False,True,False,True,True,True,True,True,True
252,codeforces2024,human,qwen2.5-7b-instruct,"You are playing a computer game. The current level of this game can be modeled
as a straight line. Your character is in point 0 of this line. There are n
monsters trying to kill your character; the i -th monster has health equal to
a_i and is initially in the point x_i .

Every second, the following happens:

  * first, you fire up to k bullets at monsters. Each bullet targets exactly one monster and decreases its health by 1 . For each bullet, you choose its target arbitrary (for example, you can fire all bullets at one monster, fire all bullets at different monsters, or choose any other combination). Any monster can be targeted by a bullet, regardless of its position and any other factors; 
  * then, all alive monsters with health 0 or less die; 
  * then, all alive monsters move 1 point closer to you (monsters to the left of you increase their coordinates by 1 , monsters to the right of you decrease their coordinates by 1 ). If any monster reaches your character (moves to the point 0 ), you lose. 

Can you survive and kill all n monsters without letting any of them reach your
character?

Input

The first line of the input contains one integer t (1 \le t \le 3 \cdot 10^4 )
— the number of test cases.

Each test case consists of three lines:

  * the first line contains two integers n and k (1 \le n \le 3 \cdot 10^5 ; 1 \le k \le 2 \cdot 10^9 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9 ); 
  * the third line contains n integers x_1, x_2, \dots, x_n (-n \le x_1 < x_2 < x_3 < \dots < x_n \le n ; x_i \ne 0 ). 

Additional constraint on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 .

Output

For each test case, print YES if you can kill all n monsters before they reach
your character, or NO otherwise.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    5
    
    3 2
    
    1 2 3
    
    -1 2 3
    
    2 1
    
    1 1
    
    -1 1
    
    4 10
    
    3 4 2 5
    
    -3 -2 1 3
    
    5 3
    
    2 1 3 2 5
    
    -3 -2 3 4 5
    
    2 1
    
    1 2
    
    1 2

Output

    YES
    NO
    YES
    YES
    NO
    
Note

In the first example, you can act as follows:

  * during the 1 -st second, fire 1 bullet at the 1 -st monster and 1 bullet at the 3 -rd monster. Then the 1 -st monster dies, the 2 -nd and the 3 -rd monster move closer; 
  * during the 2 -nd second, fire 2 bullets at the 2 -nd monster. Then the 2 -nd monster dies, the 3 -rd monster moves closer; 
  * during the 3 -rd second, fire 2 bullets at the 3 -rd monster. Then the 3 -rd monster dies. 

In the second example, you can fire only 1 bullet, so you can kill only one of
the two monsters during the 1 -st second. Then, the remaining monster moves
closer and kills your character.","def solve():
    n, k = map(int, input().split())
    v = list(map(int, input().split()))
    x = list(map(int, input().split()))

    # Initialize the array to store ""put all on right""
    put_all_on_right = [0] * (n + 1)

    # Populate the put_all_on_right array
    for i in range(n):
        put_all_on_right[abs(x[i])] += v[i]

    # Simulate the power depletion and recharging process
    my_power = k
    for i in range(1, n + 1):
        if my_power < put_all_on_right[i]:
            print(""NO"")
            return
        my_power -= put_all_on_right[i]
        my_power += k

    print(""YES"")


# Main function for handling multiple test cases    
def main():
    t = int(input())
    for _ in range(t):
        solve()


if __name__ == ""__main__"":
    main()",2,True,False,False,True,True,True,True,False,False,False,True,True,False
6,codeforces2024,human,qwen2.5-7b-instruct,"There are n islands, numbered 1, 2, \ldots, n . Initially, every pair of
islands is connected by a bridge. Hence, there are a total of \frac{n (n -
1)}{2} bridges.

Everule lives on island 1 and enjoys visiting the other islands using bridges.
Dominater has the power to destroy at most k bridges to minimize the number of
islands that Everule can reach using (possibly multiple) bridges.

Find the minimum number of islands (including island 1 ) that Everule can
visit if Dominater destroys bridges optimally.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers n and k (1 \le
n \le 100 , 0 \le k \le \frac{n \cdot (n - 1)}{2} ).

Output

For each test case, output the minimum number of islands that Everule can
visit if Dominater destroys bridges optimally.

Example

Input

    6
    
    2 0
    
    2 1
    
    4 1
    
    5 10
    
    5 3
    
    4 4

Output

    2
    1
    4
    1
    5
    1
    
Note

In the first test case, since no bridges can be destroyed, all the islands
will be reachable.

In the second test case, you can destroy the bridge between islands 1 and 2 .
Everule will not be able to visit island 2 but can still visit island 1 .
Therefore, the total number of islands that Everule can visit is 1 .

In the third test case, Everule always has a way of reaching all islands
despite what Dominater does. For example, if Dominater destroyed the bridge
between islands 1 and 2 , Everule can still visit island 2 by traveling by 1
\to 3 \to 2 as the bridges between 1 and 3 , and between 3 and 2 are not
destroyed.

In the fourth test case, you can destroy all bridges since k = \frac{n \cdot
(n - 1)}{2} . Everule will be only able to visit 1 island (island 1 ).","for t in range(int(input())):
    n, k = map(int, input().split())
    r=n
    if k>=n-1:
        r=1
    print(r)",2,True,False,False,True,True,True,True,False,False,True,True,False,True
258,codeforces2024,human,qwen2.5-7b-instruct,"You are given a positive integer x . Find any array of integers a_0, a_1,
\ldots, a_{n-1} for which the following holds:

  * 1 \le n \le 32 , 
  * a_i is 1 , 0 , or -1 for all 0 \le i \le n - 1 , 
  * x = \displaystyle{\sum_{i=0}^{n - 1}{a_i \cdot 2^i}} , 
  * There does not exist an index 0 \le i \le n - 2 such that both a_{i} \neq 0 and a_{i + 1} \neq 0 . 

It can be proven that under the constraints of the problem, a valid array
always exists.

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains a single positive integer x (1 \le x
< 2^{30} ).

Output

For each test case, output two lines.

On the first line, output an integer n (1 \le n \le 32 ) — the length of the
array a_0, a_1, \ldots, a_{n-1} .

On the second line, output the array a_0, a_1, \ldots, a_{n-1} .

If there are multiple valid arrays, you can output any of them.

Example

Input

    7
    
    1
    
    14
    
    24
    
    15
    
    27
    
    11
    
    19

Output

    1
    1
    5
    0 -1 0 0 1
    6
    0 0 0 -1 0 1
    5
    -1 0 0 0 1
    6
    -1 0 -1 0 0 1
    5
    -1 0 -1 0 1
    5
    -1 0 1 0 1

Note

In the first test case, one valid array is [1] , since (1) \cdot 2^0 = 1 .

In the second test case, one possible valid array is [0,-1,0,0,1] , since (0)
\cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 =
-2 + 16 = 14 .","def binary_colouring(x):
    if x == 1:
        return [1]

    bits = []
    while x > 0:
        bit = x & 1
        bits.append(bit)
        x >>= 1

    n = len(bits)
    a = [0] * n

    for i in range(n - 1):
        if bits[i]:
            a[i] = 1

        if bits[i + 1]:
            a[i + 1] = -1

    return a",2,False,False,False,True,False,True,False,True,True,False,True,True,True
86,codeforces2024,human,qwen2.5-7b-instruct,"[Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)","def g(n,x,a,y):
  a.sort()
  seta=set(a)
  triangle=0
  added=0
  l=[]
  # if (a[-1]+2)%n==a[0]:
  #   pass
  # else:
  #   if (a[-1]+2)%n not in seta:
  #     l.add(a[-1]+2)
  
  # for i in range(x-1):
  #     ptr=a[i]
  #     if a[i+1]==ptr+2:
  #       continue
  #     else:
  #       if (ptr+2) not in seta:
  #         l.add(ptr+2)
  yc=y
  for i in range(x-1):
    l.append(a[i+1]-a[i])
  l.append(a[0]+n-a[-1])
  l.sort()
  l.reverse()
  for i in range(len(l)):
    if l[i]==1:
      continue
    if l[i]%2==0:
      y-=(l[i]//2-1)
    else:
      y-=l[i]//2
    if y>=0:
      triangle+=l[i]//2
    else:
      if l[i]%2==0:
        y+=(l[i]//2-1)
      else:
        y+=l[i]//2
      triangle+=y
      y=0
  
  # print(yc,y)
  return triangle+x+yc-y-2
t=int(input())
for _ in range(t):
  n,x,y=map(int,input().split())
  a=list(map(int,input().split()))
  if t==8829 and _==29:
    print(n,end="","")
    print(y,end="","")
    for i in range(x):
      print(a[i],end="","")
  print(g(n,x,a,y))",2,False,False,False,True,False,True,True,False,False,False,True,False,False
358,codeforces2024,human,qwen2.5-7b-instruct,"Sasha gave Anna a list a of n integers for Valentine's Day. Anna doesn't need
this list, so she suggests destroying it by playing a game.

Players take turns. Sasha is a gentleman, so he gives Anna the right to make
the first move.

  * On her turn, Anna must choose an element a_i from the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of 42 , it would become 24 ; if Anna chose the element with a value of 1580 , it would become 851 . Note that leading zeros are removed. After such a turn, the number of elements in the list does not change.
  * On his turn, Sasha must extract two elements a_i and a_j (i \ne j ) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to 2007 and 19 , he would remove these two elements from the list and add the integer 200719 or 192007 . After such a turn, the number of elements in the list decreases by 1 .

Players can't skip turns. The game ends when Sasha can't make a move, i.e.
after Anna's move there is exactly one number left in the list. If this
integer is not less than 10^m (i.e., \ge 10^m ), Sasha wins. Otherwise, Anna
wins.

It can be shown that the game will always end. Determine who will win if both
players play optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

Then follows the description of the test cases.

The first line of each test case contains integers n , m (1 \le n \le 2 \cdot
10^5 , 0 \le m \le 2 \cdot 10^6 ) — the number of integers in the list and the
parameter determining when Sasha wins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the list that Sasha gave to Anna.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output:

  * ""Sasha"", if Sasha wins with optimal play; 
  * ""Anna"", if Anna wins with optimal play. 

Example

Input

    9
    
    2 2
    
    14 2
    
    3 5
    
    9 56 1
    
    4 10
    
    1 2007 800 1580
    
    4 5
    
    5000 123 30 4
    
    10 10
    
    6 4 6 2 3 1 10 9 10 7
    
    1 1
    
    6
    
    1 1
    
    10
    
    8 9
    
    1 2 9 10 10 2 10 2
    
    4 5
    
    10 10 10 10

Output

    Sasha
    Anna
    Anna
    Sasha
    Sasha
    Anna
    Anna
    Anna
    Sasha
    
Note

Consider the first test case.

Anna can reverse the integer 2 , then Sasha can concatenate the integers 2 and
14 , obtaining the integer 214 , which is greater than 10^2 = 100 . If Anna
had reversed the integer 14 , Sasha would have concatenated the integers 41
and 2 , obtaining the integer 412 , which is greater than 10^2 = 100 . Anna
has no other possible moves, so she loses.","def countZero(number):
    counter = 0
    for i in range(len(number)-1, 0, -1):
        if (number[i] != '0'):
            break;
        counter += 1
    return counter

def anna(arr):
    idx = 0
    found = True if arr[0][-1] == '0' else False

    for i in range(1, len(arr)):
        if arr[i][-1] == '0':
            if countZero(arr[i]) > countZero(arr[idx]):
                found = True
                idx = i

    if found:
        arr[idx] = str(int(arr[idx][::-1]))

    return arr          # if no ele with 0 at end is found, then we return same arr

def sasha(arr):
    idx1 = 0
    foundOne = False
    idx2 = 0
    for i in range(1, len(arr)):
        if arr[i][-1] == '0':
            if countZero(arr[i]) > countZero(arr[idx1]):
                foundOne = True
                idx1 = i
    for i in range(1, len(arr)):
        if i !=idx1 and arr[i][-1] == '0':
            if countZero(arr[i]) >= countZero(arr[idx2]):
                idx2 = i

    if (idx2 != 0):    
        # print(f""Two 0s found at {{ {idx1} }} and {{ {idx2} }}."")
        if countZero(arr[idx1]) > countZero(arr[idx2]):         # The one with less zeros at end would be after more zeros
            arr[idx1] = arr[idx1] + arr[idx2]
        else:
            arr[idx1] = arr[idx2] + arr[idx1]
        arr.pop(idx2)
    
    elif foundOne and idx2 == 0 :
        for i in range(1, len(arr)):
            if len(arr[i]) > len(arr[idx2]):
                idx2 = i
        # print(f""Only one 0 found at {{ {idx1} }} other chosen {{ {idx2} }}"")
        arr[idx1] = arr[idx1] + arr[idx2]
        arr.pop(idx2)

    else:
        # print(f""No zeros found, so just adding the firsttwo; "")
        arr[0] = arr[0] + arr[1]
        arr.pop(1)

    return arr

def play(arr, n, m):
    if (n > m):
        return ""Sasha""
    elif (n == m):
        flag1 = False
        flag2 = False
        for i in range(n):
            if (flag2 == False and len(arr[i]) >= 2):
                if (flag1 == False):
                    flag1 = True
                    if (len(arr[i]) > 2) or (arr[i][-1] != '0'):
                        flag2 = True
                else:
                    flag2 = True
        if (flag2):
            return ""Sasha""
        else:
            return ""Anna""
    else:
        # print(f""Starting with {arr}"")
        while (len(arr) > 1):
            arr = anna(arr)
            # print(f""Anna did {arr}"")
            arr = sasha(arr)
            # print(f""Sasha did {arr}"")

        if (int(arr[0]) >= 10**m):
            return ""Sasha""
        else:
            return ""Anna""

# Sasha wants BIG
# Anna wants smol

t = int(input())
for testcase in range(t):
    n,m = map(int, input().split())    
    a = input().split(' ')

    print(play(a, n, m))",2,False,False,False,True,False,True,True,True,True,True,False,True,False
251,codeforces2024,human,qwen2.5-7b-instruct,"There is a rectangular sheet of paper with initial height n and width m . Let
the current height and width be h and w respectively. We introduce a xy
-coordinate system so that the four corners of the sheet are (0, 0), (w, 0),
(0, h) , and (w, h) . The sheet can then be cut along the lines x =
1,2,\ldots,w-1 and the lines y = 1,2,\ldots,h-1 . In each step, the paper is
cut randomly along any one of these h+w-2 lines. After each vertical and
horizontal cut, the right and bottom piece of paper respectively are
discarded.

Find the expected number of steps required to make the area of the sheet of
paper strictly less than k . It can be shown that this answer can always be
expressed as a fraction \dfrac{p}{q} where p and q are coprime integers.
Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 57000 ). Description of the test cases follows.

The first line of each test case contains 3 integers n , m , and k (1 \le n, m
\le 10^6 , 2 \le k \le 10^{12} ).

It is guaranteed that the sum of n and the sum of m over all test cases do not
exceed 10^6 .

Output

For each test case, print one integer — the answer to the problem.

Example

Input

    4
    
    2 4 10
    
    2 4 8
    
    2 4 2
    
    2 4 6

Output

    0
    1
    833333342
    250000003
    
Note

For the first test case, the area is already less than 10 so no cuts are
required.

For the second test case, the area is exactly 8 so any one of the 4 possible
cuts would make the area strictly less than 8 .

For the third test case, the final answer is \frac{17}{6} = 833\,333\,342\bmod
(10^9+7) .

For the fourth test case, the final answer is \frac{5}{4} = 250\,000\,003\bmod
(10^9+7) .","def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    MOD = 1_000_000_007
    
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    
    for _ in range(t):
        n = int(data[idx])
        m = int(data[idx + 1])
        k = int(data[idx + 2])
        idx += 3
        
        # Binary search for the minimum number of steps
        low, high = 0, max(n, m) * 20  # Arbitrary high number of steps
        answer = high
        
        while low <= high:
            mid = (low + high) // 2
            if can_reduce_area(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        
        # Calculate p * inv(q) % MOD
        # Since the problem guarantees that the answer can be expressed as A + B*sqrt(2),
        # and asks for B as p/q, we need to find B and compute p * inv(q) % MOD.
        # Here we assume B is the result we found, and q = 1 (since B is an integer).
        p = answer
        q = 1
        q_inv = pow(q, MOD - 2, MOD)  # Fermat's little theorem for modular inverse
        result = (p * q_inv) % MOD
        results.append(result)
    
    for res in results:
        print(res)

def can_reduce_area(n, m, k, steps):
    # This function should estimate if we can reduce the area below k in the given number of steps
    # We use a simple heuristic: assume each cut reduces the largest dimension by about half
    import math
    
    # Simulate the cutting process
    h, w = n, m
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        if h * w < k:
            return True
    return h * w < k

if __name__ == ""__main__"":
    main()",2,False,False,False,True,True,True,True,False,False,False,False,True,False
46,codeforces2024,human,qwen2.5-7b-instruct,"Vladislav has a string of length 5 , whose characters are each either
\texttt{A} or \texttt{B} .

Which letter appears most frequently: \texttt{A} or \texttt{B} ?

Input

The first line of the input contains an integer t (1 \leq t \leq 32 ) — the
number of test cases.

The only line of each test case contains a string of length 5 consisting of
letters \texttt{A} and \texttt{B} .

All t strings in a test are different (distinct).

Output

For each test case, output one letter (\texttt{A} or \texttt{B} ) denoting the
character that appears most frequently in the string.

Example

Input

    8
    
    ABABB
    
    ABABA
    
    BBBAB
    
    AAAAA
    
    BBBBB
    
    BABAA
    
    AAAAB
    
    BAAAA

Output

    B
    A
    B
    A
    B
    A
    A
    A","n  = int(input())
num_A = int(0)
num_B = int(0)
for i in range (0, n):
    x = input()
    for j in x:
        if j == 'A':
           num_A +=1 
        else:
            num_B +=1
    if num_A > num_B:
           print(""A"")
    else:
           print(""B"")",2,False,False,False,True,True,True,True,True,True,True,False,False,True
337,codeforces2024,human,qwen2.5-7b-instruct,"There are balls of n different colors; the number of balls of the i -th color
is a_i .

The balls can be combined into groups. Each group should contain at most 2
balls, and no more than 1 ball of each color.

Consider all 2^n sets of colors. For a set of colors, let's denote its value
as the minimum number of groups the balls of those colors can be distributed
into. For example, if there are three colors with 3 , 1 and 7 balls
respectively, they can be combined into 7 groups (and not less than 7 ), so
the value of that set of colors is 7 .

Your task is to calculate the sum of values over all 2^n possible sets of
colors. Since the answer may be too large, print it modulo 998\,244\,353 .

Input

The first line contains a single integer n (1 \le n \le 5000 ) — the number of
colors.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 5000 )
— the number of balls of the i -th color.

Additional constraint on input: the total number of balls doesn't exceed 5000
.

Output

Print a single integer — the sum of values of all 2^n sets of colors, taken
modulo 998\,244\,353 .

Examples

Input

    3
    
    1 1 2

Output

    11
    
Input

    1
    
    5

Output

    5
    
Input

    4
    
    1 3 3 7

Output

    76
    
Note

Consider the first example. There are 8 sets of colors:

  * for the empty set, its value is 0 ; 
  * for the set \\{1\\} , its value is 1 ; 
  * for the set \\{2\\} , its value is 1 ; 
  * for the set \\{3\\} , its value is 2 ; 
  * for the set \\{1,2\\} , its value is 1 ; 
  * for the set \\{1,3\\} , its value is 2 ; 
  * for the set \\{2,3\\} , its value is 2 ; 
  * for the set \\{1,2,3\\} , its value is 2 . 

So, the sum of values over all 2^n sets of colors is 11 .","def solve(n, a):
    MOD = 998244353
    total_value = 0
    
    # Iterate over all subsets of colors
    for mask in range(1 << n):
        max_balls = 0
        for i in range(n):
            if (mask & (1 << i)) != 0:
                max_balls = max(max_balls, a[i])
        total_value = (total_value + max_balls) % MOD
    
    return total_value

# Input reading
n = int(input())
a = list(map(int, input().split()))

# Solve the problem
result = solve(n, a)
print(result)",2,False,False,True,True,True,True,True,True,True,True,True,True,True
358,codeforces2024,human,qwen2.5-7b-instruct,"Sasha gave Anna a list a of n integers for Valentine's Day. Anna doesn't need
this list, so she suggests destroying it by playing a game.

Players take turns. Sasha is a gentleman, so he gives Anna the right to make
the first move.

  * On her turn, Anna must choose an element a_i from the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of 42 , it would become 24 ; if Anna chose the element with a value of 1580 , it would become 851 . Note that leading zeros are removed. After such a turn, the number of elements in the list does not change.
  * On his turn, Sasha must extract two elements a_i and a_j (i \ne j ) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to 2007 and 19 , he would remove these two elements from the list and add the integer 200719 or 192007 . After such a turn, the number of elements in the list decreases by 1 .

Players can't skip turns. The game ends when Sasha can't make a move, i.e.
after Anna's move there is exactly one number left in the list. If this
integer is not less than 10^m (i.e., \ge 10^m ), Sasha wins. Otherwise, Anna
wins.

It can be shown that the game will always end. Determine who will win if both
players play optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

Then follows the description of the test cases.

The first line of each test case contains integers n , m (1 \le n \le 2 \cdot
10^5 , 0 \le m \le 2 \cdot 10^6 ) — the number of integers in the list and the
parameter determining when Sasha wins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the list that Sasha gave to Anna.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output:

  * ""Sasha"", if Sasha wins with optimal play; 
  * ""Anna"", if Anna wins with optimal play. 

Example

Input

    9
    
    2 2
    
    14 2
    
    3 5
    
    9 56 1
    
    4 10
    
    1 2007 800 1580
    
    4 5
    
    5000 123 30 4
    
    10 10
    
    6 4 6 2 3 1 10 9 10 7
    
    1 1
    
    6
    
    1 1
    
    10
    
    8 9
    
    1 2 9 10 10 2 10 2
    
    4 5
    
    10 10 10 10

Output

    Sasha
    Anna
    Anna
    Sasha
    Sasha
    Anna
    Anna
    Anna
    Sasha
    
Note

Consider the first test case.

Anna can reverse the integer 2 , then Sasha can concatenate the integers 2 and
14 , obtaining the integer 214 , which is greater than 10^2 = 100 . If Anna
had reversed the integer 14 , Sasha would have concatenated the integers 41
and 2 , obtaining the integer 412 , which is greater than 10^2 = 100 . Anna
has no other possible moves, so she loses.","t = int(input())
for _ in range(t):
    n,m = map(int,input().split())
    a = list(map(str,input().split()))
    len_arr = [0]*n
    zrr = [0]*n
    ans = 0
    for i in range(n):
        len_arr[i] = len(a[i])
        zrr[i] = len(a[i]) - len(a[i].rstrip(""0""))
        ans += len_arr[i] - zrr[i]
    zrr.sort(reverse=True)
    for i in range(n):
        if i %2 != 0:
            ans += zrr[i]
    if ans - 1>= m:
        print(""Sasha"")
    else:
        print(""Anna"")",2,True,False,False,True,False,True,True,False,False,False,False,False,False
71,codeforces2024,human,qwen2.5-7b-instruct,"Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.","t = int(input())
for _ in range(t):
    m = int(input())
    l = input()
    n, s, w, e = 0, 0, 0, 0

    for i in l:
        if i == 'N':
            n += 1
        elif i == 'S':
            s += 1
        elif i =='W':
            w += 1
        else:
            e += 1

    if n > s:
        nn, ss = n-s, 0
    else:
        nn, ss = 0, s-n
    if w > e:
        ww, ee = w-e, 0
    else:
        ww, ee = 0, e-w
    if nn%2 == 1 or ss%2 == 1 or ww%2 == 1 or ee%2 == 1:
        print('NO')
    else:
        r, h = 0, 0
        rr, hh = [0]*4, [0]*4 #nswe
        pp = []
        for i in l:
            if i == 'W':
                if ww:
                    if ww%2 == 1:
                        r += 1
                        pp.append('R')
                    else:
                        h += 1
                        pp.append('H')
                    ww -= 1
                else:
                    if rr[3]:
                        rr[3] -= 1
                        r += 1
                        pp.append('R')
                    elif hh[3]:
                        hh[3] -= 1
                        h += 1
                        pp.append('H')
                    elif r < h:
                        rr[2] += 1
                        r += 1
                        pp.append('R')
                    else:
                        hh[2] += 1
                        h += 1
                        pp.append('H')

            elif i == 'E':
                if ee:
                    if ee % 2 == 1:
                        r += 1
                        pp.append('R')
                    else:
                        h += 1
                        pp.append('H')
                    ee -= 1
                else:
                    if rr[2]:
                        rr[2] -= 1
                        r += 1
                        pp.append('R')
                    elif hh[2]:
                        hh[2] -= 1
                        h += 1
                        pp.append('H')
                    elif r < h:
                        rr[3] += 1
                        r += 1
                        pp.append('R')
                    else:
                        hh[3] += 1
                        h += 1
                        pp.append('H')

            elif i == 'N':
                if nn:
                    if nn % 2 == 1:
                        r += 1
                        pp.append('R')
                    else:
                        h += 1
                        pp.append('H')
                    nn -= 1
                else:
                    if rr[1]:
                        rr[1] -= 1
                        r += 1
                        pp.append('R')
                    elif hh[1]:
                        hh[1] -= 1
                        h += 1
                        pp.append('H')
                    elif r < h:
                        rr[0] += 1
                        r += 1
                        pp.append('R')
                    else:
                        hh[0] += 1
                        h += 1
                        pp.append('H')

            elif i == 'S':
                if ss:
                    if ss % 2 == 1:
                        r += 1
                        pp.append('R')
                    else:
                        h += 1
                        pp.append('H')
                    ss -= 1
                else:
                    if rr[0]:
                        rr[0] -= 1
                        r += 1
                        pp.append('R')
                    elif hh[0]:
                        hh[0] -= 1
                        h += 1
                        pp.append('H')
                    elif r < h:
                        rr[1] += 1
                        r += 1
                        pp.append('R')
                    else:
                        hh[1] += 1
                        h += 1
                        pp.append('H')
        if r and h:
            print(''.join(pp))
        else:
            print('NO')",2,True,False,False,True,False,True,True,False,False,False,False,False,False
295,codeforces2024,human,qwen2.5-7b-instruct,"You are given an array a of n integers.

The median of an array q_1, q_2, \ldots, q_k is the number p_{\lceil
\frac{k}{2} \rceil} , where p is the array q sorted in non-decreasing order.
For example, the median of the array [9, 5, 1, 2, 6] is 5 , as in the sorted
array [1, 2, 5, 6, 9] , the number at index \lceil \frac{5}{2} \rceil = 3 is 5
, and the median of the array [9, 2, 8, 3] is 3 , as in the sorted array [2,
3, 8, 9] , the number at index \lceil \frac{4}{2} \rceil = 2 is 3 .

You are allowed to choose an integer i (1 \le i \le n ) and increase a_i by 1
in one operation.

Your task is to find the minimum number of operations required to increase the
median of the array.

Note that the array a may not necessarily contain distinct numbers.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the array a .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of operations
required to increase the median of the array.

Example

Input

    8
    
    3
    
    2 2 8
    
    4
    
    7 3 3 1
    
    1
    
    1000000000
    
    5
    
    5 5 5 4 5
    
    6
    
    2 1 2 3 1 4
    
    2
    
    1 2
    
    2
    
    1 1
    
    4
    
    5 5 5 5

Output

    1
    2
    1
    3
    2
    1
    2
    3
    
Note

In the first test case, you can apply one operation to the first number and
obtain the array [3, 2, 8] , the median of this array is 3 , as it is the
number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 3, 8] . The median of the original array [2, 2, 8] is 2 , as it is
the number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 2, 8] . Thus, the median increased (3 > 2 ) in just one operation.

In the fourth test case, you can apply one operation to each of the numbers at
indices 1, 2, 3 and obtain the array [6, 6, 6, 4, 5] , the median of this
array is 6 , as it is the number at index \lceil \frac{5}{2} \rceil = 3 in the
non-decreasing sorted array [4, 5, 6, 6, 6] . The median of the original array
[5, 5, 5, 4, 5] is 5 , as it is the number at index \lceil \frac{5}{2} \rceil
= 2 in the non-decreasing sorted array [4, 5, 5, 5, 5] . Thus, the median
increased (6 > 5 ) in three operations. It can be shown that this is the
minimum possible number of operations.

In the fifth test case, you can apply one operation to each of the numbers at
indices 1, 3 and obtain the array [3, 1, 3, 3, 1, 4] , the median of this
array is 3 , as it is the number at index \lceil \frac{6}{2} \rceil = 3 in the
non-decreasing sorted array [1, 1, 3, 3, 3, 4] . The median of the original
array [2, 1, 2, 3, 1, 4] is 2 , as it is the number at index \lceil
\frac{6}{2} \rceil = 3 in the non-decreasing sorted array [1, 1, 2, 2, 3, 4] .
Thus, the median increased (3 > 2 ) in two operations. It can be shown that
this is the minimum possible number of operations.","for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    if n%2==0:
        m = (n//2)-1
    else:
        m = n//2
    a[m]+=1
    if n==1:
        print(1)
    elif a[m-1]<=a[m] and a[m]<=a[m+1] :
        print(1)
    elif a[m]>a[m+1]:
        cnt = 1
        while m+1<n and a[m+1]<a[m]:
            a[m+1]+=1
            m+=1
            cnt+=1
        print(cnt)",2,False,False,False,False,False,True,False,False,False,False,False,False,False
234,codeforces2024,human,qwen2.5-7b-instruct,"Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8","import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

class ListNode:
    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v

# BF-OB5, EC, DB, CC, CL
def solve():
    n, q = readInts()
    l, r = readList(), readList()
    nodes = [None] * (n + 1)
    for i in range(q):
        le, ri = nodes[l[i]], nodes[r[i]]
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                ri.le, ri.ri = le, lri
            else:
                le.ri, ri.le = ri, le
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                le.le, le.ri = rle, ri
            else:
                le.ri, ri.le = ri, le
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            nodes[l[i]].ri, nodes[r[i]].le = nodes[r[i]], nodes[l[i]]

    a = []
    for i in range(1, n+1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break

    # print(a)
    seg = [0] * (n+1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i+1])] += 1

    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans

m = 998244353
print(solve())",2,True,False,False,True,True,True,True,True,True,False,True,False,False
71,codeforces2024,human,qwen2.5-7b-instruct,"Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.","def distribute_instructions(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0

    # Count occurrences of each direction
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:  # char == 'W'
            count_west += 1

    # Determine if it's possible to balance the movements
    if count_north != count_south or count_east != count_west:
        return ""NO""

    result = []

    # Distribute instructions
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1

    return ''.join(result)

# Read input
import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1
results = []

for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(distribute_instructions(n, s))

# Print results
print('\n'.join(results))",2,False,False,False,True,False,True,True,True,False,True,True,False,False
46,codeforces2024,human,qwen2.5-7b-instruct,"Vladislav has a string of length 5 , whose characters are each either
\texttt{A} or \texttt{B} .

Which letter appears most frequently: \texttt{A} or \texttt{B} ?

Input

The first line of the input contains an integer t (1 \leq t \leq 32 ) — the
number of test cases.

The only line of each test case contains a string of length 5 consisting of
letters \texttt{A} and \texttt{B} .

All t strings in a test are different (distinct).

Output

For each test case, output one letter (\texttt{A} or \texttt{B} ) denoting the
character that appears most frequently in the string.

Example

Input

    8
    
    ABABB
    
    ABABA
    
    BBBAB
    
    AAAAA
    
    BBBBB
    
    BABAA
    
    AAAAB
    
    BAAAA

Output

    B
    A
    B
    A
    B
    A
    A
    A","t = int(input())
for _ in range(t):
    ab = [ x for x in input()]
    n = len(ab)
    a = 0
    b = 0
    for i in range(n):
        if ab[i] == ""A"":
            a+=1
        else:
            b+=1
    if a > b:
        print(""A"")
    else:
        print(""B"")",2,True,True,True,True,True,True,True,True,True,True,True,True,True
354,codeforces2024,human,qwen2.5-7b-instruct,"You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126","def solve_puzzle(c1, c2, c3, c4):
    MOD = 998244353
    
    # Dynamic programming table to store the number of ways to arrange elements
    dp = [[0 for _ in range(4)] for _ in range(max(c1, c2, c3, c4) + 1)]
    
    # Base case: There is exactly one way to have zero elements of each type
    dp[0][0] = 1
    
    # Fill the dynamic programming table
    for i in range(1, max(c1, c2, c3, c4) + 1):
        # Update the number of ways for each type of element
        if i <= c1:
            dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][3]) % MOD
        if i <= c2:
            dp[i][1] = (dp[i-1][0] + dp[i-1][2] + dp[i-1][3]) % MOD
        if i <= c3:
            dp[i][2] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][3]) % MOD
        if i <= c4:
            dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % MOD
    
    # The total number of ways to arrange all elements is the sum of the last row
    total_ways = sum(dp[max(c1, c2, c3, c4)]) % MOD
    return total_ways

# Main function to handle input and output
def main():
    MOD = 998244353
    t = int(input())
    results = []
    
    for _ in range(t):
        c1, c2, c3, c4 = map(int, input().split())
        result = solve_puzzle(c1, c2, c3, c4)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()",2,False,True,True,True,True,True,True,True,True,True,True,True,True
171,codeforces2024,human,qwen2.5-7b-instruct,"In the new messenger for the students of the Master's Assistance Center,
Keftemerum, an update is planned, in which developers want to optimize the set
of messages shown to the user. There are a total of n messages. Each message
is characterized by two integers a_i and b_i . The time spent reading the set
of messages with numbers p_1, p_2, \ldots, p_k (1 \le p_i \le n , all p_i are
distinct) is calculated by the formula:

Note that the time to read a set of messages consisting of one message with
number p_1 is equal to a_{p_1} . Also, the time to read an empty set of
messages is considered to be 0 .

The user can determine the time l that he is willing to spend in the
messenger. The messenger must inform the user of the maximum possible size of
the set of messages, the reading time of which does not exceed l . Note that
the maximum size of the set of messages can be equal to 0 .

The developers of the popular messenger failed to implement this function, so
they asked you to solve this problem.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5 \cdot 10^4 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and l (1 \leq n \leq
2000 , 1 \leq l \leq 10^9 ) — the number of messages and the time the user is
willing to spend in the messenger.

The i -th of the next n lines contains two integers a_i and b_i (1 \le a_i,
b_i \le 10^9 ) — characteristics of the i -th message.

It is guaranteed that the sum of n^2 over all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, output a single integer — the maximum possible size of a
set of messages, the reading time of which does not exceed l .

Example

Input

    5
    
    5 8
    
    4 3
    
    1 5
    
    2 4
    
    4 3
    
    2 3
    
    1 6
    
    4 10
    
    3 12
    
    4 8
    
    2 1
    
    2 12
    
    5 26
    
    24 7
    
    8 28
    
    30 22
    
    3 8
    
    17 17
    
    5 14
    
    15 3
    
    1000000000 998244353
    
    179 239
    
    228 1337
    
    993 1007

Output

    3
    1
    2
    1
    0
    
Note

In the first test case, you can take a set of three messages with numbers p_1
= 3 , p_2 = 2 , and p_3 = 5 . The time spent reading this set is equal to a_3
+ a_2 + a_5 + |b_3 - b_2| + |b_2 - b_5| = 2 + 1 + 2 + |4 - 5| + |5 - 3| = 8 .

In the second test case, you can take a set of one message with number p_1 = 1
. The time spent reading this set is equal to a_1 = 4 .

In the fifth test case, it can be shown that there is no such non-empty set of
messages, the reading time of which does not exceed l .","def main():
  #n = int(input())
  n, t = (int(i) for i in input().split())
  a = [[int(i) for i in input().split()] for i in range(n)]
  #b = [int(i) for i in input().split()]
  #c = [int(i) for i in input().split()]
  #s = input()
  #t = input()
  """"""q = int(input())
  while q:
    l, r = map(int, input().split())
    q -= 1
    """"""
  a.sort(key=lambda x: x[1])
  ans = 0
  l = r = 0
  res = 0
  while r<n:
    res += a[r][0]
    if r>0: res += a[r][1]-a[r-1][1]
    while res>t:
      res -= a[l][0]
      if l<n-1: res -= a[l+1][1]-a[l][1]
      l += 1
    ans = max(ans, r-l+1)
    r += 1
  return ans

t = int(input())
while t:
  print(main())
  t -= 1",2,False,False,False,True,True,True,True,True,True,True,True,True,True
290,codeforces2024,human,qwen2.5-7b-instruct,"This afternoon, you decided to enjoy the first days of Spring by taking a walk
outside. As you come near the Quidditch field, you hear screams. Once again,
there is a conflict about the score: the two teams are convinced that they won
the game! To prevent this problem from happening one more time, you decide to
get involved in the refereeing of the matches.

Now, you will stay in the stadium to watch the game and count the score. At
the end of the game, you will decide the winner.

Today, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw
(B) team. Each team is composed of P players (1 \leq P \leq 10 ).

The field is a rectangle of N lines and M columns (3 \leq N, M \leq 99 , N and
M are odd). All the positions are integers, and several entities are allowed
to be at the same position in the field. At the beginning of the game, the
field contains goals for the two teams (each team can own between one and five
goals), the players, and exactly one Quaffle. Other types of balls will be
available in the harder versions of the problem.

A game is composed of T steps (0 \leq T \leq 10000 ). At each step, one entity
on the field (a player or a ball) performs one action. All entities can move.
A player can also catch a ball or throw the Quaffle that it is carrying. To
catch a ball, a player must be located on the same cell as it. The Quaffle
does not perform any action while it is being carried; it only follows the
movements of the player. If a player carrying the Quaffle decides to throw it,
the Quaffle is simply put at the current position of the player.

To win a point, a player must leave the Quaffle at a goal of the other team.
When it does, the team of the player wins one point, and the Quaffle instantly
moves to the middle of the field (the cell at the (M+1)/2 -th column of the
(N+1)/2 -th line of the field, starting from 1). There is no goal in the
middle of the field. If a player puts the ball in its own goal, the other team
wins the point.

Input

On the first line, the integers N and M .

The description of the field follows: N lines of M pairs of characters
separated by spaces. Each pair of characters represents a position on the
field. It can be either:

  * .. to represent an empty cell 
  * R0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid. 
  * RG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG). 
  * .Q to represent the Quaffle, which is the ball that the players use to score goals. 

The next line contains T , the number of steps that compose the game. T lines
follow, each describing one action. It contains several pieces of information
separated by a space. First, a pair of characters representing the entity that
must perform the action. Second, the description of the action:

  * U, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time. 
  * C indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since in the next versions of the problem, several balls may be in the same cell. 
  * T indicates that the player throws the Quaffle that it is carrying. 

All the actions performed by the entities are guaranteed to be valid: the
players stay in the field, don't catch a ball if they are not in the same
cell, don't release the Quaffle if they are not carrying it, ...

Output

You must output the description of the main events of the game, one event per
line. More precisely:

  * Each time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team. 

The events must be printed in ascending order of t.

At the end of the game, you must print the final score as: FINAL SCORE: r b,
where r is the score of the red team and b is the score of the blue team.

Examples

Input

    5 5
    
    .. R1 .. B1 ..
    
    RG .. .. .. BG
    
    RG R0 .Q B0 BG
    
    RG .. .. .. BG
    
    .. R2 .. B2 ..
    
    13
    
    B2 U
    
    B2 U
    
    B2 L
    
    B2 C .Q
    
    B2 L
    
    B2 L
    
    B2 T
    
    R0 R
    
    R0 C .Q
    
    R0 D
    
    R0 R
    
    R0 R
    
    R0 T

Output

    6 BLUE GOAL
    12 RED GOAL
    FINAL SCORE: 1 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    12
    
    R0 D
    
    R0 C .Q
    
    R0 R
    
    R0 T
    
    R0 D
    
    B0 R
    
    B0 U
    
    B0 C .Q
    
    B0 L
    
    B0 L
    
    B0 L
    
    B0 T

Output

    11 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    5
    
    R0 D
    
    R0 C .Q
    
    R0 L
    
    R0 L
    
    R0 T

Output

    4 BLUE GOAL
    FINAL SCORE: 0 1
    
Note

In the first example, a blue player goes to the middle of the grid, at the
position of the Quaffle. He takes it, goes to the goal of the red team, and
lets the ball there. He scores! The ball gets back to the middle of the field,
a red player takes it and scores too.

In the second example, the red player takes the Quaffle, move it and throw it.
The blue player catches the ball, goes to the red goal and scores.

In the third example, the red player takes the ball and scores in the goal of
their own team: the blue team wins a point.","def main():
    # Read input
    N, M = map(int, input().split())
    field = [input().split() for _ in range(N)]
    T = int(input())
    actions = [input().split() for _ in range(T)]

    # Initialize game state
    quaffle_position = None
    goals = {'RG': 0, 'BG': 0}
    players = {'R': {}, 'B': {}}
    score = {'R': 0, 'B': 0}

    # Parse initial field state
    for i in range(N):
        for j in range(M):
            if field[i][j] == '.Q':
                quaffle_position = (i, j)
            elif field[i][j] in ['RG', 'BG']:
                goals[field[i][j]] += 1
            elif field[i][j][0] in ['R', 'B']:
                team, number = field[i][j]
                players[team][number] = (i, j)

    # Process actions
    for t, (entity, action, *args) in enumerate(actions):
        if action == 'U':
            players[entity[0]][entity[1]] = (players[entity[0]][entity[1]][0] - 1, players[entity[0]][entity[1]][1])
        elif action == 'D':
            players[entity[0]][entity[1]] = (players[entity[0]][entity[1]][0] + 1, players[entity[0]][entity[1]][1])
        elif action == 'L':
            players[entity[0]][entity[1]] = (players[entity[0]][entity[1]][0], players[entity[0]][entity[1]][1] - 1)
        elif action == 'R':
            players[entity[0]][entity[1]] = (players[entity[0]][entity[1]][0], players[entity[0]][entity[1]][1] + 1)
        elif action == 'C':
            pass  # Catching the ball doesn't change the position
        elif action == 'T':
            quaffle_position = players[entity[0]][entity[1]]

        # Check if a goal is scored
        if quaffle_position in goals:
            scoring_team = 'R' if quaffle_position in ['BG'] else 'B'
            opposite_team = 'B' if scoring_team == 'R' else 'R'
            score[opposite_team] += 1
            print(f""{t} {opposite_team.upper()} GOAL"")
            quaffle_position = ((N + 1) // 2 - 1, (M + 1) // 2 - 1)

    # Print final score
    print(f""FINAL SCORE: {score['R']} {score['B']}"")

if __name__ == ""__main__"":
    main()",2,False,False,False,True,True,True,True,True,False,False,True,True,True
313,codeforces2024,human,qwen2.5-7b-instruct,"n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2","R=lambda:map(int,input().split())
t,=R()
while t:
 t-=1;n,k=R();*a,=R();i=0;j=n-1
 while i<j and(m:=min(a[i],a[j],k//2)):k-=m*2;a[i]-=m;i+=a[i]<1;a[j]-=m;j-=a[j]<1
 print(i+n-j-1+(k>=a[i]>0))",2,True,False,False,True,False,True,True,True,False,True,False,False,True
294,codeforces2024,human,qwen2.5-7b-instruct,"Yarik's birthday is coming soon, and Mark decided to give him an array a of
length n .

Mark knows that Yarik loves bitwise operations very much, and he also has a
favorite number x , so Mark wants to find the maximum number k such that it is
possible to select pairs of numbers [l_1, r_1 ], [l_2, r_2 ], \ldots [l_k, r_k
], such that:

  * l_1 = 1 . 
  * r_k = n . 
  * l_i \le r_i for all i from 1 to k . 
  * r_i + 1 = l_{i + 1} for all i from 1 to k - 1 . 
  * (a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \le x , where \oplus denotes the operation of [bitwise XOR](https://en.wikipedia.org/wiki/Exclusive_or), and | denotes the operation of [bitwise OR](https://en.wikipedia.org/wiki/Logical_disjunction). 

If such k does not exist, then output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The following lines
contain the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le n \le
10^5, 0 \le x < 2^{30} ) — the length of the array a and the number x
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < 2^{30} ) — the array a itself.

It is guaranteed that the sum of the values of n across all test cases does
not exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the maximum
suitable number k , and -1 if such k does not exist.

Example

Input

    8
    
    3 1
    
    1 2 3
    
    2 2
    
    1 1
    
    2 2
    
    1 3
    
    2 3
    
    0 0
    
    3 2
    
    0 0 1
    
    4 2
    
    1 3 3 7
    
    2 2
    
    2 3
    
    5 0
    
    0 1 2 2 1

Output

    2
    2
    1
    2
    3
    -1
    1
    2
    
Note

In the first test case, you can take k equal to 2 and choose two segments [1, 1 ] and [2, 3 ], (1) | (2 \oplus 3) = 1 . It can be shown that 2 is the maximum possible answer.

In the second test case, the segments [1, 1 ] and [2, 2 ] are suitable, (1) | (1) = 1 . It is not possible to make more segments.

In the third test case, it is not possible to choose 2 segments, as (1) | (3) = 3 > 2 , so the optimal answer is 1 .","def max_segments(t, test_cases):
    results = []
    for case in test_cases:
        n, x, a = case
        prefix_xor = [0] * (n + 1)
        
        # Calculate prefix XOR
        for i in range(1, n + 1):
            prefix_xor[i] = prefix_xor[i - 1] ^ a[i - 1]
        
        current_xor = 0
        segment_count = 0
        valid = False
        
        for i in range(1, n + 1):
            current_xor ^= a[i - 1]
            if (current_xor | prefix_xor[n]) <= x:
                segment_count += 1
                current_xor = 0
                valid = True
        
        if valid:
            results.append(segment_count)
        else:
            results.append(-1)
    
    return results

# Read input
import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1
test_cases = []

for _ in range(t):
    n = int(data[index])
    x = int(data[index + 1])
    a = list(map(int, data[index + 2:index + 2 + n]))
    test_cases.append((n, x, a))
    index += 2 + n

# Get results
results = max_segments(t, test_cases)

# Print results
for result in results:
    print(result)",2,False,False,True,True,True,True,True,True,True,True,True,True,False
317,codeforces2024,human,qwen2.5-7b-instruct,"A binary string s of length n is given. A binary string is a string consisting
only of the characters '1' and '0'.

You can choose an integer k (1 \le k \le n ) and then apply the following
operation any number of times: choose k consecutive characters of the string
and invert them, i.e., replace all '0' with '1' and vice versa.

Using these operations, you need to make all the characters in the string
equal to '1'.

For example, if n=5 , s=00100 , you can choose k=3 and proceed as follows:

  * choose the substring from the 1 -st to the 3 -rd character and obtain s=\color{blue}{110}00 ; 
  * choose the substring from the 3 -rd to the 5 -th character and obtain s=11\color{blue}{111} ; 

Find the maximum value of k for which it is possible to make all the
characters in the string equal to '1' using the described operations. Note
that the number of operations required to achieve this is not important.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains an integer n (1 \le n \le 5000 ) —
the length of the string s .

The second line of each test case contains a string s of length n , consisting
of the characters '1' and '0'.

It is guaranteed that the sum of the values n^2 over all test cases in the
test does not exceed 25 \cdot 10^6 .

Output

For each test case, output the maximum integer k (1 \le k \le n ) for which it
is possible to obtain a string s consisting only of the characters '1' using
the described operations.

Example

Input

    5
    
    5
    
    00100
    
    5
    
    01000
    
    7
    
    1011101
    
    3
    
    000
    
    2
    
    10

Output

    3
    2
    4
    3
    1","def max_k_for_all_ones(n, s):
    zero_count = s.count('0')
    
    if zero_count == 0:
        return n
    
    max_k = 1
    for k in range(1, n + 1):
        if zero_count % k == 0:
            max_k = k
    
    return max_k

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    index = 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        s = data[index + 1]
        index += 2
        
        result = max_k_for_all_ones(n, s)
        results.append(result)
    
    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()",2,False,False,False,True,False,True,True,False,False,False,True,True,False
69,codeforces2024,human,qwen2.5-7b-instruct,"You can never buy enough happiness, so here we go again! In this version, you
can only buy h_i = 1 unit of happiness each month, but the number of months is
hugely increased. We are in the realm of quantum happiness and time dilation.

Being a physicist, Charlie likes to plan his life in simple and precise terms.

For the next m months, starting with no money, Charlie will work hard and earn
x pounds per month. For the i -th month (1 \le i \le m) , there'll be a single
opportunity of paying cost c_i pounds to obtain one unit of happiness. You
cannot buy more than one unit each month.

Borrowing is not allowed. Money earned in the i -th month can only be spent in
a later j -th month (j>i ).

Since physicists don't code, help Charlie find the maximum reachable units of
happiness.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first line of each test case contains two integers, m and x (1 \le m \le 2
\cdot 10^5 , 1 \le x \le 10^3 ) — the total number of months and the monthly
salary.

The second line of each test case contains m integers c_1, c_2, \dots, c_m (1
\leq c_i \leq 10^3 ) — the cost of one unit of happiness for each month.

It is guaranteed that sum of m over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output one integer — the maximal amount of happiness
Charlie can get.

Example

Input

    6
    
    3 3
    
    2 2 2
    
    6 5
    
    2 2 8 2 6 8
    
    6 4
    
    4 10 3 8 6 10
    
    2 1
    
    1 1
    
    4 1
    
    4 1 3 1
    
    4 2
    
    1 3 4 3

Output

    2
    4
    3
    1
    2
    1","def max_happiness(m, x, costs):
    # sort costs in descending order
    costs.sort(reverse=True)
    
    # initialize variables
    earnings = 0
    happiness = []
    
    # iterate through each month
    for i in range(1, m+1):
        # add salary to earnings
        earnings += x
        
        # try to purchase highest-cost item
        while costs and costs[-1] <= earnings:
            # subtract cost from earnings
            earnings -= costs[-1]
            
            # increment happiness count
            happiness.append(1)
            
            # remove item from costs
            costs.pop()
            
    return len(happiness)

# read input
t = int(input())
for _ in range(t):
    m, x = map(int, input().split())
    costs = list(map(int, input().split()))
    
    print(max_happiness(m, x, costs))",2,False,False,False,True,True,True,True,True,True,True,True,True,True
343,codeforces2024,human,qwen2.5-7b-instruct,"There is a hidden array a of n positive integers. You know that a is a
palindrome, or in other words, for all 1 \le i \le n , a_i = a_{n + 1 - i} .
You are given the sums of all but one of its distinct subarrays, in arbitrary
order. The subarray whose sum is not given can be any of the \frac{n(n+1)}{2}
distinct subarrays of a .

Recover any possible palindrome a . The input is chosen such that there is
always at least one array a that satisfies the conditions.

An array b is a subarray of a if b can be obtained from a by the deletion of
several (possibly, zero or all) elements from the beginning and several
(possibly, zero or all) elements from the end.

Input

The first line of the input contains a single integer t (1 \le t \le 200 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (3 \le n \le 1000
) — the size of the array a .

The next line of each test case contains \frac{n(n+1)}{2} - 1 integers s_i
(1\leq s_i \leq 10^9 ) — all but one of the subarray sums of a .

It is guaranteed that the sum of n over all test cases does not exceed 1000 .

Additional constraint on the input: There is always at least one valid
solution.

Hacks are disabled for this problem.

Output

For each test case, print one line containing n positive integers a_1, a_2,
\cdots a_n — any valid array a . Note that a must be a palindrome.

If there are multiple solutions, print any.

Example

Input

    7
    
    3
    
    1 2 3 4 1
    
    4
    
    18 2 11 9 7 11 7 2 9
    
    4
    
    5 10 5 16 3 3 13 8 8
    
    4
    
    8 10 4 6 4 20 14 14 6
    
    5
    
    1 2 3 4 5 4 3 2 1 1 2 3 2 1
    
    5
    
    1 1 2 2 2 3 3 3 3 4 5 5 6 8
    
    3
    
    500000000 1000000000 500000000 500000000 1000000000

Output

    1 2 1 
    7 2 2 7 
    3 5 5 3 
    6 4 4 6 
    1 1 1 1 1 
    2 1 2 1 2 
    500000000 500000000 500000000 
    
Note

For the first example case, the subarrays of a = [1, 2, 1] are:

  * [1] with sum 1 , 
  * [2] with sum 2 , 
  * [1] with sum 1 , 
  * [1, 2] with sum 3 , 
  * [2, 1] with sum 3 , 
  * [1, 2, 1] with sum 4 . 

So the full list of subarray sums is 1, 1, 2, 3, 3, 4 , and the sum that is
missing from the input list is 3 .

For the second example case, the missing subarray sum is 4 , for the subarray
[2, 2] .

For the third example case, the missing subarray sum is 13 , because there are
two subarrays with sum 13 ([3, 5, 5] and [5, 5, 3] ) but 13 only occurs once
in the input.","def getSubarraySums(a):

    cts = []
    for i in range(len(a)):
        sm = 0
        for j in range(i, len(a)):
            sm = sm + a[j]
            cts.append(sm)

    cts.sort()
    return cts

def getOddOccurringElements(cts):

    odds = []

    for ct in cts:
        if len(odds) > 0 and ct == odds[-1]:
            odds.pop()
        else:
            odds.append(ct)
    return odds

def getPalindrome(odds, n):

    a = [0] * n
    prev = 0
    idx = (n - 1) // 2
    
    for x in odds:
        if idx == n - 1 - idx:
            a[idx] = x
        else:
            a[idx] = (x - prev) // 2
            a[n - 1 - idx] = (x - prev) // 2
        prev = x
        idx = idx - 1
    
    return a

def getLargestExcluded(bigList, smallList):

    while len(smallList) > 0 and bigList[-1] == smallList[-1]:
        bigList.pop()
        smallList.pop()
    return bigList[-1]

t = int(input())

for tc in range(t):

    n = int(input())
    
    subarraySums = list(map(int, input().split()))
    subarraySums.sort()
    odds = getOddOccurringElements(subarraySums)
    
    missingSum = -1
    
    if len(odds) > (n + 1) // 2:
    
        oddvals = []
        evenvals = []
        for x in odds:
            if x % 2 == 1:
                oddvals.append(x)
            else:
                evenvals.append(x)

        if len(evenvals) > 0 and len(oddvals) > 0:

            missingSum = evenvals[0] if len(evenvals) == 1 else oddvals[0]

        else:

            b = getPalindrome(odds, n + 2)
            bSums = getSubarraySums(b)
            y = bSums[-1]
            x = getLargestExcluded(bSums, subarraySums)
            missingSum = 2 * x - y
    
    else:
        
        b = getPalindrome(odds, n - 2)
        bSums = getSubarraySums(b)
        y = bSums[-1]
        x = getLargestExcluded(subarraySums, bSums)
        missingSum = 2 * x - y

    odds.append(missingSum)
    odds.sort()
    odds = getOddOccurringElements(odds)
    
    ans = getPalindrome(odds, n)
    print(*ans)",2,True,False,False,False,False,True,True,False,True,False,True,False,False
111,codeforces2024,human,qwen2.5-7b-instruct,"Patrick calls a substring^\dagger of a binary string^\ddagger good if this
substring contains exactly one 1.

Help Patrick count the number of binary strings s such that s contains exactly
n good substrings and has no good substring of length strictly greater than k
. Note that substrings are differentiated by their location in the string, so
if s = 1010 you should count both occurrences of 10.

^\dagger A string a is a substring of a string b if a can be obtained from b
by the deletion of several (possibly, zero or all) characters from the
beginning and several (possibly, zero or all) characters from the end.

^\ddagger A binary string is a string that only contains the characters 0 and
1.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2500 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (1 \leq n \leq
2500 , 1 \leq k \leq n ) — the number of required good substrings and the
maximum allowed length of a good substring.

It is guaranteed that the sum of n over all test cases does not exceed 2500 .

Output

For each test case, output a single integer — the number of binary strings s
such that s contains exactly n good substrings and has no good substring of
length strictly greater than k . Since this integer can be too large, output
it modulo 998\,244\,353 .

Example

Input

    6
    
    1 1
    
    3 2
    
    4 2
    
    5 4
    
    6 2
    
    2450 2391

Output

    1
    3
    5
    12
    9
    259280854
    
Note

In the first test case, the only suitable binary string is 1. String 01 is not
suitable because it contains a substring 01 with length 2 > 1 .

In the second test case, suitable binary strings are 011, 110 and 111.

In the third test case, suitable binary strings are 101, 0110, 0111, 1110, and
1111.","MOD = 998244353

def count_binary_strings(n, k):
    # Initialize dp array
    dp = [[0] * (n + 1) for _ in range(k + 1)]
    
    # Base case: For k = 1, there is only one good substring ""1""
    dp[1][1] = 1
    
    # Fill the dp array
    for i in range(2, k + 1):
        for j in range(1, n + 1):
            # Transition: Adding a '0' or '1' to the previous state
            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD
    
    # Sum up all possible counts for n good substrings
    result = sum(dp[i][n] for i in range(1, k + 1)) % MOD
    return result

# Input reading
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    print(count_binary_strings(n, k))",2,False,False,False,True,True,True,True,True,True,True,True,True,False
65,codeforces2024,human,qwen2.5-7b-instruct,"Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .","def chess_for_three(test_cases):
    results = []

    for p1, p2, p3 in test_cases:
        # Check if scores are consistent
        total_points = p1 + p2 + p3
        if total_points % 2 != 0 or p3 > p1 + p2:
            results.append(-1)
            continue

        # Maximum number of draws
        max_draws = min(p1, p3 - p2) + min(p2, p3 - p1)
        results.append(max_draws)

    return results

# Input reading
if __name__ == ""__main__"":
    t = int(input())  # Number of test cases
    test_cases = []

    for _ in range(t):
        p1, p2, p3 = map(int, input().split())
        test_cases.append((p1, p2, p3))

    # Calculate results
    results = chess_for_three(test_cases)

    # Output results
    for result in results:
        print(result)",2,False,False,False,True,True,True,True,True,True,True,False,False,True
296,codeforces2024,human,qwen2.5-7b-instruct,"Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]","U = 1000000007

def pw(x, y):
    # Function to compute (x^y) % U using binary exponentiation
    v = 1
    while y:
        if y & 1:
            v = v * x % U
        y >>= 1
        x = x * x % U
    return v

# Precompute factorials and their modular inverses
fac = [1]
for i in range(1, 200001):
    fac.append(fac[-1] * i % U)

inv = [0] * 200001
inv[200000] = pw(fac[200000], U - 2)
for i in range(199999, -1, -1):
    inv[i] = inv[i + 1] * (i + 1) % U

t = int(input())
for _ in range(t):
    n, m1, m2 = [int(z) for z in input().split()]
    a1 = [int(z) for z in input().split()]
    a2 = [int(z) for z in input().split()]

    # Check initial conditions for valid permutations
    if a1[0] != 1 or a1[-1] != a2[0] or a2[-1] != n:
        print(0)
    else:
        m = a2[0]
        l = m - 1
        r = n - m
        # Calculate initial number of permutations
        v = fac[n - 1] * inv[l] * inv[r] % U

        # Process prefix maximums
        for i in range(m1 - 2, -1, -1):
            dx = a1[i + 1] - a1[i] - 1
            # Update number of permutations for this segment
            v = v * fac[l - 1] * inv[l - 1 - dx] % U
            l = a1[i] - 1

        # Process suffix maximums
        for i in range(m2 - 1):
            dx = a2[i + 1] - a2[i] - 1
            # Update number of permutations for this segment
            v = v * fac[r - 1] * inv[r - 1 - dx] % U
            r = n - a2[i + 1]

        # Output the result for the current test case
        print(v)",2,True,False,False,True,True,True,True,True,True,True,True,False,True
339,codeforces2024,human,qwen2.5-7b-instruct,"There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1","N = int(input())
ans = []
 
a = [int(x) for x in input().split()]
b = [(i,a[i]) for i in range(len(a))]
S = sorted(b,key=lambda x: x[1])
m = max(a)
 
bits = [0] + [1]*N + [0]
wtr = [[] for q in range(N)]
 
f = []
 
g = 1
last = 0
for i,num in S:
	for e in range(num-last):
		f.append(g)
	last = num
	bits[i+1] = 0
	g += bits[i]+bits[i+2]-1
 
#print(b)
for d in range(1,m+1):
	print( sum( [f[d*x] for x in range(1+(m-1)//d)]), end=' ')",2,True,False,False,False,False,True,False,False,False,False,False,False,False
316,codeforces2024,human,qwen2.5-7b-instruct,"The price of one yogurt at the ""Vosmiorochka"" store is a burles, but there is
a promotion where you can buy two yogurts for b burles.

Maxim needs to buy exactly n yogurts. When buying two yogurts, he can choose
to buy them at the regular price or at the promotion price.

What is the minimum amount of burles Maxim should spend to buy n yogurts?

Input

The first line contains a single integer t (1 \le t \le {10}^{4} ) — the
number of test cases.

The first and only line of each test case contains three integers n , a , and
b (1 \le n \le 100 , 1 \le a, b \le 30 ) — the number of yogurts Maxim wants
to buy, the price for one yogurt, and the price for two yogurts on promotion.

Output

For each test case, print in a separate line the minimum cost of buying n
yogurts at ""Vosmiorochka"".

Example

Input

    4
    
    2 5 9
    
    3 5 9
    
    3 5 11
    
    4 5 11

Output

    9
    14
    15
    20
    
Note

In the third test case of the example, it is more advantageous to buy three
yogurts for 15 burles than two for 11 and one for 5 .

In the fourth test case of the example, you need to buy four yogurts, each for
5 burles.","t=int(input())
for _ in range(t):
    n,a,b=map(int,input().split())
    if n==1:
        e=a
    else:
        c=a*n
        d=b+((n-2)*a)
        e=min(c,d)
    print(e)",2,False,False,False,True,True,True,True,True,True,True,True,False,True
295,codeforces2024,human,qwen2.5-7b-instruct,"You are given an array a of n integers.

The median of an array q_1, q_2, \ldots, q_k is the number p_{\lceil
\frac{k}{2} \rceil} , where p is the array q sorted in non-decreasing order.
For example, the median of the array [9, 5, 1, 2, 6] is 5 , as in the sorted
array [1, 2, 5, 6, 9] , the number at index \lceil \frac{5}{2} \rceil = 3 is 5
, and the median of the array [9, 2, 8, 3] is 3 , as in the sorted array [2,
3, 8, 9] , the number at index \lceil \frac{4}{2} \rceil = 2 is 3 .

You are allowed to choose an integer i (1 \le i \le n ) and increase a_i by 1
in one operation.

Your task is to find the minimum number of operations required to increase the
median of the array.

Note that the array a may not necessarily contain distinct numbers.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the array a .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of operations
required to increase the median of the array.

Example

Input

    8
    
    3
    
    2 2 8
    
    4
    
    7 3 3 1
    
    1
    
    1000000000
    
    5
    
    5 5 5 4 5
    
    6
    
    2 1 2 3 1 4
    
    2
    
    1 2
    
    2
    
    1 1
    
    4
    
    5 5 5 5

Output

    1
    2
    1
    3
    2
    1
    2
    3
    
Note

In the first test case, you can apply one operation to the first number and
obtain the array [3, 2, 8] , the median of this array is 3 , as it is the
number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 3, 8] . The median of the original array [2, 2, 8] is 2 , as it is
the number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 2, 8] . Thus, the median increased (3 > 2 ) in just one operation.

In the fourth test case, you can apply one operation to each of the numbers at
indices 1, 2, 3 and obtain the array [6, 6, 6, 4, 5] , the median of this
array is 6 , as it is the number at index \lceil \frac{5}{2} \rceil = 3 in the
non-decreasing sorted array [4, 5, 6, 6, 6] . The median of the original array
[5, 5, 5, 4, 5] is 5 , as it is the number at index \lceil \frac{5}{2} \rceil
= 2 in the non-decreasing sorted array [4, 5, 5, 5, 5] . Thus, the median
increased (6 > 5 ) in three operations. It can be shown that this is the
minimum possible number of operations.

In the fifth test case, you can apply one operation to each of the numbers at
indices 1, 3 and obtain the array [3, 1, 3, 3, 1, 4] , the median of this
array is 3 , as it is the number at index \lceil \frac{6}{2} \rceil = 3 in the
non-decreasing sorted array [1, 1, 3, 3, 3, 4] . The median of the original
array [2, 1, 2, 3, 1, 4] is 2 , as it is the number at index \lceil
\frac{6}{2} \rceil = 3 in the non-decreasing sorted array [1, 1, 2, 2, 3, 4] .
Thus, the median increased (3 > 2 ) in two operations. It can be shown that
this is the minimum possible number of operations.","import math

t = int(input()) 
results = []
for _ in range(t):
    n = int(input())  
    a = list(map(int, input().split())) 
    a.sort() 
    median_index = (n - 1) // 2  
    median = a[median_index]
    operations = 0
    for i in range(median_index, n): 
        if a[i] < median + 1:
            operations += (median + 1 - a[i])
    results.append(operations)
print(""\n"".join(map(str, results)))",2,True,False,False,True,True,True,True,False,False,False,True,True,True
169,codeforces2024,human,qwen2.5-7b-instruct,"In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.","def find_mex(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
    return mex

test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = find_mex(arr)

    if mex == 0:
        # Special case when MEX is 0, we can always split into two segments
        print(2)
        print(1, 1)
        print(2, size)
        continue

    cnt = 0
    start = 0
    segments = []
    num_set = set()  # To track elements less than MEX
    
    # Process the array and try to form subsegments
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        
        # If we've seen all elements from 0 to mex-1
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))  # Form a subsegment (1-based index)
            start = i + 1  # Start a new segment after this index
            num_set.clear()  # Reset the set to track elements for the next subsegment

    # Final adjustment to the last segment to include the remainder of the array
    if num_set:
        segments[-1] = (segments[-1][0], size)  # Adjust the last segment

    if len(segments) < 2:
        print(-1)  # If fewer than 2 subsegments, no valid division
    else:
        print(len(segments))  # Number of subsegments
        for seg in segments:
            print(seg[0], seg[1])  # Output the subsegments",2,False,False,False,True,True,True,True,True,True,True,False,False,False
231,codeforces2024,human,qwen2.5-7b-instruct,"Monocarp is opening his own IT company. He wants to hire n programmers and m
testers.

There are n+m+1 candidates, numbered from 1 to n+m+1 in chronological order of
their arriving time. The i -th candidate has programming skill a_i and testing
skill b_i (a person's programming skill is different from their testing
skill). The skill of the team is the sum of the programming skills of all
candidates hired as programmers, and the sum of the testing skills of all
candidates hired as testers.

When a candidate arrives to interview, Monocarp tries to assign them to the
most suitable position for them (if their programming skill is higher, then he
hires them as a programmer, otherwise as a tester). If all slots for that
position are filled, Monocarp assigns them to the other position.

Your task is, for each candidate, calculate the skill of the team if everyone
except them comes to interview. Note that it means that exactly n+m candidates
will arrive, so all n+m positions in the company will be filled.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

Each test case consists of three lines:

  * the first line contains two integers n and m (0 \le n, m \le 2 \cdot 10^5 ; 2 \le n + m + 1 \le 2 \cdot 10^5 ) — the number of programmers and the number of testers Monocarp wants to hire, respectively; 
  * the second line contains n + m + 1 integers a_1, a_2, \dots, a_{n+m+1} (1 \le a_i \le 10^9 ), where a_i is the programming skill of the i -th candidate; 
  * the third line contains n + m + 1 integers b_1, b_2, \dots, b_{n+m+1} (1 \le b_i \le 10^9 ; b_i \ne a_i ), where b_i is the testing skill of the i -th candidate. 

Additional constraint on the input: the sum of (n + m + 1) over all test cases
doesn't exceed 2 \cdot 10^5 .

Output

For each test case, print n + m + 1 integers, where the i -th integer should
be equal to the skill of the team if everyone except the i -th candidate comes
to interview.

Example

Input

    4
    
    1 0
    
    2 1
    
    1 2
    
    0 2
    
    4 5 5
    
    5 4 1
    
    1 2
    
    2 1 5 4
    
    5 2 3 1
    
    3 1
    
    4 3 3 4 1
    
    5 5 4 5 2

Output

    1 2 
    5 6 9 
    8 11 11 12 
    13 13 13 12 15 
    
Note

Let's consider the third test case of the example:

  * if the 1 -st candidate does not arrive, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 2 + 5 + 1 = 8 ; 
  * if the 2 -nd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 5 + 5 + 1 = 11 ; 
  * if the 3 -rd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 4 -th candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 4 = 11 ; 
  * if the 4 -th candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 5 = 12 .","for _ in range(int(input())):
    n, m = map(int, input().split())
    bounds = [n, m]
    a = []
    a.append(list(map(int, input().split())))
    a.append(list(map(int, input().split())))
    
    bad = -1
    badType = -1
    cur = [0, 0]
    ans = 0
    types = [0 for i in range(n + m + 1)]
    for i in range(n + m):
        curType = 0
        if a[0][i] < a[1][i]:
            curType = 1
        if cur[curType] == bounds[curType]:
            curType = 1 - curType
            if bad == -1:
                bad = i
                badType = 1 - curType
        types[i] = curType
        ans += a[types[i]][i]
        cur[types[i]] += 1
        
    res = []
    for i in range(n + m):
        val = ans - a[types[i]][i]
        if bad != -1 and i < bad and types[i] == badType:
            val = val + a[badType][bad] - a[1 - badType][bad] + a[1 - badType][n + m]
        else:
            val = val + a[types[i]][n + m]
        res.append(val)
    res.append(ans)
    print(*res)",2,True,False,False,True,False,True,True,False,True,True,True,False,False
155,codeforces2024,human,qwen2.5-7b-instruct,"[Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .","MOD = 10**9 + 7
inv_2 = (MOD + 1) // 2
inv_3 = pow(3, MOD - 2, MOD)

tc = int(input())

for _ in range(tc):
    n, m = map(int, input().split())
    a = sorted(list(map(int, input().split())))

    inv_m = pow(m, MOD - 2, MOD)
    ans = 0
    for i in range(n):
        dist = (a[(i + 1) % n] - a[i]) % m
        prob_last = dist * inv_m % MOD
        expected_getting_moved = n * inv_2 % MOD
        expected_time = (m * m - dist * dist) * inv_3 % MOD
        ans += prob_last * expected_getting_moved % MOD * expected_time % MOD
        ans %= MOD

    print(ans)",2,True,False,False,True,False,True,True,False,False,True,True,False,False
191,codeforces2024,human,qwen2.5-7b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","MOD = 10**9 + 7

def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        k = int(data[index + 1])
        index += 2
        
        rows = set()
        cols = set()
        
        for _ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            rows.add(r)
            cols.add(c)
            if r != c:
                rows.add(c)
                cols.add(r)
        
        # Calculate the number of free rows and columns
        free_rows = n - len(rows)
        free_cols = n - len(cols)
        
        # The number of additional rooks we can place is the minimum of free rows and free columns
        m = min(free_rows, free_cols)
        
        # Calculate the number of ways to place m rooks in m free rows and m free columns
        # This is m! (factorial of m)
        result = 1
        for i in range(1, m + 1):
            result = (result * i) % MOD
        
        results.append(result)
    
    for res in results:
        print(res)",2,False,False,False,True,False,True,True,True,True,True,True,True,False
209,codeforces2024,human,qwen2.5-7b-instruct,"Jay managed to create a problem of difficulty x and decided to make it the
second problem for Codeforces Round #921.

But Yash fears that this problem will make the contest highly unbalanced, and
the coordinator will reject it. So, he decided to break it up into a
problemset of n sub-problems such that the difficulties of all the sub-
problems are a positive integer and their sum is equal to x .

The coordinator, Aleksey, defines the balance of a problemset as the
[GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the
difficulties of all sub-problems in the problemset.

Find the maximum balance that Yash can achieve if he chooses the difficulties
of the sub-problems optimally.

Input

The first line of input contains a single integer t (1\leq t\leq 10^3 )
denoting the number of test cases.

Each test case contains a single line of input containing two integers x
(1\leq x\leq 10^8 ) and n (1\leq n\leq x ).

Output

For each test case, print a single line containing a single integer denoting
the maximum balance of the problemset Yash can achieve.

Example

Input

    3
    
    10 3
    
    5 5
    
    420 69

Output

    2
    1
    6
    
Note

For the first test case, one possible way is to break up the problem of
difficulty 10 into a problemset having three problems of difficulties 4 , 2
and 4 respectively, giving a balance equal to 2 .

For the second test case, there is only one way to break up the problem of
difficulty 5 into a problemset of 5 problems with each problem having a
difficulty 1 giving a balance equal to 1 .","for _ in range(int(input())):
    x,n=map(int,input().split())
    ans=1
    for i in range(1,int(x**(0.5))+1):
        if(x%i==0):
            if(n<=x//i):ans=max(ans,i)
            if(n<=i):ans=max(ans,x//i)
    print(ans)",2,True,False,True,True,True,True,True,True,False,True,True,True,False
123,codeforces2024,human,qwen2.5-7b-instruct,"Given an array a of n elements, find the maximum value of the expression:

where i , j , k , and l are four distinct indices of the array a , with 1 \le
i, j, k, l \le n .

Here |x| denotes the absolute value of x .

Input

The first line contains one integer t (1 \le t \le 500 ) — the number of test
cases. The description of the test cases follows.

The first line of each test case contains a single integer n (4 \le n \le 100
) — the length of the given array.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^6 \le a_i \le 10^6 ).

Output

For each test case, print a single integer — the maximum value.

Example

Input

    5
    
    4
    
    1 1 1 1
    
    5
    
    1 1 2 2 3
    
    8
    
    5 1 3 2 -3 -1 10 3
    
    4
    
    3 3 1 1
    
    4
    
    1 2 2 -1

Output

    0
    6
    38
    8
    8
    
Note

In the first test case, for any selection of i , j , k , l , the answer will
be 0 . For example, |a_1 - a_2| + |a_2 - a_3| + |a_3 - a_4| + |a_4 - a_1| = |1
- 1| + |1 - 1| + |1 - 1| + |1 - 1| = 0 + 0 + 0 + 0 = 0 .

In the second test case, for i = 1 , j = 3 , k = 2 , and l = 5 , the answer
will be 6 . |a_1 - a_3| + |a_3 - a_2| + |a_2 - a_5| + |a_5 - a_1| = |1 - 2| +
|2 - 1| + |1 - 3| + |3 - 1| = 1 + 1 + 2 + 2 = 6 .","def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    idx = 1
    results = []
    for _ in range(t):
        n = int(data[idx]) 
        idx += 1
        a = list(map(int, data[idx:idx + n]))
        idx += n
        min_val = float('inf')
        max_val = float('-inf')
        for num in a:
            if num < min_val:
                min_val = num
            if num > max_val:
                max_val = num
        max_expression_value = 4 * (max_val - min_val)
        results.append(max_expression_value)
    print(""\n"".join(map(str, results)))",2,False,False,False,True,False,True,True,False,False,False,True,False,True
299,codeforces2024,human,qwen2.5-7b-instruct,"You have been offered to play a game. In this game, there are n possible
outcomes, and for each of them, you must bet a certain integer amount of
coins. In the event that the i -th outcome turns out to be winning, you will
receive back the amount of coins equal to your bet on that outcome, multiplied
by k_i . Note that exactly one of the n outcomes will be winning.

Your task is to determine how to distribute the coins in such a way that you
will come out ahead in the event of any winning outcome. More formally, the
total amount of coins you bet on all outcomes must be strictly less than the
number of coins received back for each possible winning outcome.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the number of outcomes.

The second line of each test case contains n integers k_1,k_2,\ldots,k_n (2
\le k_i \le 20 ) — the multiplier for the amount of coins if the i -th outcome
turns out to be winning.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output -1 if there is no way to distribute the coins as
required. Otherwise, output n integers x_1, x_2,\ldots, x_n (1 \le x_i \le
10^{9} ) — your bets on the outcomes.

It can be shown that if a solution exists, there is always a solution that
satisfies these constraints.

If there are multiple suitable solutions, output any of them.

Example

Input

    6
    
    3
    
    3 2 7
    
    2
    
    3 3
    
    5
    
    5 5 5 5 5
    
    6
    
    7 9 3 17 9 13
    
    3
    
    6 3 2
    
    5
    
    9 4 6 8 3

Output

    27 41 12 
    1 1 
    -1
    1989 1547 4641 819 1547 1071 
    -1
    8 18 12 9 24
    
Note

In the first test case, the coins can be distributed as follows: 27 coins on
the first outcome, 41 coins on the second outcome, 12 coins on the third
outcome. Then the total amount of coins bet on all outcomes is 27 + 41 + 12 =
80 coins. If the first outcome turns out to be winning, you will receive back
3 \cdot 27 = 81 coins, if the second outcome turns out to be winning, you will
receive back 2 \cdot 41 = 82 coins, if the third outcome turns out to be
winning, you will receive back 7 \cdot 12 = 84 coins. All these values are
strictly greater than 80 .

In the second test case, one way is to bet one coin on each of the outcomes.","def solve():
    N = int(input().strip())
    vals = [int(r) for r in input().strip().split()]
    prod = 1
    for r in vals:
        prod *= r
    vprod = [prod//r for r in vals]
    den = prod - sum(vprod)
    if den <= 0:
        print(-1)
        return
    
    print("" "".join([str(x) for x in vprod]))

cases = int(input())
for n in range(cases):
    solve()",2,False,False,False,False,False,True,False,True,False,False,True,False,False
8,codeforces2024,human,qwen2.5-7b-instruct,"A string t is said to be k -good if there exists at least one
substring^\dagger of length k which is not a palindrome^\ddagger . Let f(t)
denote the sum of all values of k such that the string t is k -good.

You are given a string s of length n . You will have to answer q of the
following queries:

  * Given l and r (l < r ), find the value of f(s_ls_{l + 1}\ldots s_r) . 

^\dagger A substring of a string z is a contiguous segment of characters from
z . For example, ""\mathtt{defor} "", ""\mathtt{code} "" and ""\mathtt{o} "" are all
substrings of ""\mathtt{codeforces} "" while ""\mathtt{codes} "" and ""\mathtt{aaa}
"" are not.

^\ddagger A palindrome is a string that reads the same backwards as forwards.
For example, the strings ""\texttt{z} "", ""\texttt{aa} "" and ""\texttt{tacocat} ""
are palindromes while ""\texttt{codeforces} "" and ""\texttt{ab} "" are not.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^4 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and q (2 \le n \le 2
\cdot 10^5, 1 \le q \le 2 \cdot 10^5 ), the size of the string and the number
of queries respectively.

The second line of each test case contains the string s . It is guaranteed the
string s only contains lowercase English characters.

The next q lines each contain two integers, l and r (1 \le l < r \le n ).

It is guaranteed the sum of n and the sum of q both do not exceed 2 \cdot 10^5
.

Output

For each query, output f(s_ls_{l + 1}\ldots s_r) .

Example

Input

    5
    
    4 4
    
    aaab
    
    1 4
    
    1 3
    
    3 4
    
    2 4
    
    3 2
    
    abc
    
    1 3
    
    1 2
    
    5 4
    
    pqpcc
    
    1 5
    
    4 5
    
    1 3
    
    2 4
    
    2 1
    
    aa
    
    1 2
    
    12 1
    
    steponnopets
    
    1 12

Output

    9
    0
    2
    5
    5
    2
    14
    0
    2
    5
    0
    65
    
Note

In the first query of the first test case, the string is \mathtt{aaab} .
\mathtt{aaab} , \mathtt{aab} and \mathtt{ab} are all substrings that are not
palindromes, and they have lengths 4 , 3 and 2 respectively. Thus, the string
is 2 -good, 3 -good and 4 -good. Hence, f(\mathtt{aaab}) = 2 + 3 + 4 = 9 .

In the second query of the first test case, the string is \mathtt{aaa} . There
are no non-palindromic substrings. Hence, f(\mathtt{aaa}) = 0 .

In the first query of the second test case, the string is \mathtt{abc} .
\mathtt{ab} , \mathtt{bc} and \mathtt{abc} are all substrings that are not
palindromes, and they have lengths 2 , 2 and 3 respectively. Thus, the string
is 2 -good and 3 -good. Hence, f(\mathtt{abc}) = 2 + 3 = 5 . Note that even
though there are 2 non-palindromic substrings of length 2 , we count it only
once.","def manacher(n, s):
    if n == 0: return []
    res = [0] * (2 * n - 1)
    l, r = -1, -1
    for z in range(2 * n - 1):
        i = (z + 1) // 2
        j = z // 2
        p = 0 if i >= r else min(r - i, res[2 * (l + r) - z])
        while j + p + 1 < n and i - p - 1 >= 0:
            if s[j + p + 1] != s[i - p - 1]: break
            p += 1
        if j + p > r: l, r = i - p, j + p
        res[z] = p
    return res

T = int(input())
for _ in range(T):
    n, q = map(int, input().split())
    s = input().strip()
    
    # Precompute the rightmost non-palindromic positions
    p1 = [0] * (n + 2)
    p2 = [0] * (n + 2)
    for i in range(n + 1, -1, -1):
        if i >= n: 
            p1[i] = p2[i] = i
        else:
            if i + 1 < n and s[i] != s[i + 1]: 
                p1[i] = i
            else: 
                p1[i] = p1[i + 1]
            if i + 2 < n and s[i] != s[i + 2]: 
                p2[i] = i
            else: 
                p2[i] = p2[i + 1]

    # Use Manacher's algorithm to find palindromic substrings
    pal = manacher(n, s)
    
    for __ in range(q):
        l, r = map(int, input().split())
        l -= 1; r -= 1
        length = r - l + 1
        
        # Check if the entire substring is palindromic
        if p1[l] >= r:
            print(0)
            continue
        
        # Check for non-palindromic substrings of length 2 or 3
        if p2[l] >= r - 1:
            k = length // 2
            print(k * (k + 1))
            continue
        
        # Calculate the sum of k for k-good substrings
        ans = length * (length + 1) // 2 - 1
        if pal[l + r] >= length // 2: 
            ans -= length
        print(ans)",2,True,False,False,True,False,True,True,True,True,True,True,True,True
180,codeforces2024,human,qwen2.5-7b-instruct,"You are given three digits a , b , and c . Determine whether they form a
stair, a peak, or neither.

  * A stair satisfies the condition a<b<c . 
  * A peak satisfies the condition a<b>c . 

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains three digits a , b , c (0 \leq a , b
, c \leq 9 ).

Output

For each test case, output ""STAIR"" if the digits form a stair, ""PEAK"" if the
digits form a peak, and ""NONE"" otherwise (output the strings without quotes).

Example

Input

    7
    
    1 2 3
    
    3 2 1
    
    1 5 3
    
    3 4 1
    
    0 0 0
    
    4 1 7
    
    4 5 7

Output

    STAIR
    NONE
    PEAK
    PEAK
    NONE
    NONE
    STAIR","t = int(input())

for _ in range(t):
    a,b,c = map(int,input().split())
    if(a<b<c):
        print(""STAIR"")
    elif(a<b and b>c):
        print(""PEAK"")
    else:
        print(""NONE"")",2,True,False,True,False,True,True,True,True,False,True,False,True,True
273,codeforces2024,human,qwen2.5-7b-instruct,"After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Examples

Input

    4
    0 4 2 4
    
Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Input

    4
    1 3 0 1
    
Output

    YES
    2 1
    4 1
    1 1
    3 1
    3 3 3 1

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)","def solve():
    n = int(input())  # Number of wizards
    a = list(map(int, input().split()))  # Distance requirements for each wizard
    
    # We will assign each wizard to a unique column, and try to assign rows
    # Let's start by assigning rows and columns in a simple way
    positions = []
    for i in range(n):
        positions.append((i + 1, i + 1))  # Assign wizard i to (i+1, i+1)
    
    # Now we need to check if we can satisfy the distance requirements
    visit = [-1] * n  # This will store which wizard each wizard will visit
    
    for i in range(n):
        found = False
        for j in range(n):
            if i != j:
                # Calculate the Manhattan distance between wizard i and wizard j
                dist = abs(positions[i][0] - positions[j][0]) + abs(positions[i][1] - positions[j][1])
                if dist == a[i]:
                    visit[i] = j + 1  # Wizard i will visit wizard j
                    found = True
                    break
        if not found:
            print(""NO"")
            return
    
    # If we reach here, it means we found a valid solution
    print(""YES"")
    for pos in positions:
        print(pos[0], pos[1])
    print("" "".join(map(str, visit)))

# Read input and solve the problem
solve()",2,False,False,False,True,False,True,False,True,True,False,False,False,False
318,codeforces2024,human,qwen2.5-7b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","t = int(input())
for _ in range(t):
    n = int(input())
    mid=n//2
    a = []
    for i in range(1,n//2+1):
        a.append(i)
        a.append(mid+i)
    if n%2!=0:
        a.append(n)
    for i in range(n):
        print(a[i], end=' ')
    print('\n',end='')",2,True,False,False,True,False,True,True,True,True,False,True,True,True
248,codeforces2024,human,qwen2.5-7b-instruct,"You have a square piece of paper with a side length equal to 1 unit. In one
operation, you fold each corner of the square to the center of the paper, thus
forming another square with a side length equal to \dfrac{1}{\sqrt{2}} units.
By taking this square as a new square, you do the operation again and repeat
this process a total of N times.

![](https://espresso.codeforces.com/412ebba036545f933291dce36c1d7ef46e6051c5.png)
Performing operations for N = 2 .

After performing the set of operations, you open the paper with the same side
up you started with and see some crease lines on it. Every crease line is one
of two types: a mountain or a valley. A mountain is when the paper folds
outward, and a valley is when the paper folds inward.

You calculate the sum of the length of all mountain crease lines on the paper
and call it M . Similarly, you calculate for valley crease lines and call it V
. You want to find the value of \dfrac{M}{V} .

It can be proved that this value can be represented in the form of A +
B\sqrt{2} , where A and B are rational numbers. Let this B be represented as
an irreducible fraction \dfrac{p}{q} , your task is to print p*inv(q) modulo
999\,999\,893 (note the unusual modulo), where inv(q) is the [modular
inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of q .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \leq t \leq 10^4 ). Description of the test cases follows.

The only line of each test case contains an integer N (1 \leq N \leq 10^9 ),
the number of operations you perform on the square paper.

Output

For each test case, print on a new line the required answer.

Example

Input

    3
    
    1
    
    2
    
    3

Output

    0
    1
    714285638
    
Note

The blue lines in the given figures represent mountain crease lines, and the
green lines represent valley crease lines.

![](https://espresso.codeforces.com/ca27ca80cf535ddfa7cb1255e157dc6f43f1073c.png)|
![](https://espresso.codeforces.com/9e2d8603363c8514970f3141c639422cb347d41f.png)  
---|---  
Crease lines after 1 operation (\dfrac{M}{V} = 0) .| Crease lines after 2
operations (\dfrac{M}{V} = \sqrt{2} - 1) .","MOD = 999999893

def mod_inv(a, p):
    return pow(a, p-2, p)

def solve(N):
    if N == 1:
        return 0
    elif N == 2:
        return 1
    else:
        # For N >= 3, the pattern repeats with B = 1/sqrt(2) which is 1/2^(1/2)
        # We need to find the modular inverse of 2^(1/2) under MOD
        # Since we can't directly compute sqrt in modular arithmetic, we use the pattern found
        # From the problem statement and sample outputs, we deduce:
        # M/V for N=3 is 714285638 which corresponds to 1/sqrt(2) mod 999999893
        # This is a precomputed result based on the problem's constraints and observations
        return 714285638

import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
results = []
for i in range(1, t+1):
    N = int(data[i])
    results.append(solve(N))

for result in results:
    print(result)",2,False,False,False,True,False,False,False,False,False,False,True,True,True
45,codeforces2024,human,qwen2.5-7b-instruct,"Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.","def are_complementary(x, y):
    for i in range(1, 32):
        if (x >> (i - 1)) & 1 == (y >> (i - 1)) & 1:
            return False
    return True

def min_groups(n, integers):
    groups = []
    for num in integers:
        placed = False
        for group in groups:
            if are_complementary(num, group[0]):
                group.append(num)
                placed = True
                break
        if not placed:
            groups.append([num])
    return len(groups)

def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        integers = list(map(int, input().split()))
        print(min_groups(n, integers))

if __name__ == ""__main__"":
    main()",2,False,True,True,True,True,True,True,True,True,False,True,True,False
243,codeforces2024,human,qwen2.5-7b-instruct,"You are designing a new video game. It has n scenarios, which the player may
play in any order, but each scenario must be played exactly once. When a
player switches from a scenario to another scenario, the game shows a
specially crafted transition video to make it all feel part of one big story.
This video is specific to a pair of scenarios, but not to their order, in
other words, the video playing when switching from scenario a to scenario b is
the same as the video playing when switching from scenario b to scenario a .
Therefore, you need to create \frac{n(n-1)}{2} different transition videos,
one for each possible pair of different scenarios.

Each transition video can be either funny or scary. It is boring to see too
many funny videos or too many scary videos in a row. Therefore, your goal is
to create the videos in such a way that no matter in which order does the
player approach the scenarios, they will never see more than \lceil
\frac{3n}{4} \rceil transition videos of the same type in a row.

You have already come up with ideas for at most \lfloor \frac{n}{2} \rfloor of
the transition videos, and therefore already know if those will be funny or
scary. Now you need to choose funny or scary for all other transition videos
in such a way that the above requirement is satisfied.

Input

The first line contains a single integer n (2 \le n \le 24 ) — the number of
scenarios in the game.

The next n lines describe the partial transition video plan. Each of those
lines contains n characters. The j -th character of the i -th line corresponds
to the transition video between the i -th and the j -th scenarios. It will be
F if the corresponding transition video will be funny, S if the corresponding
transition video will be scary, ? if the corresponding transition video is
still undecided, or . if i=j .

It is guaranteed that the i -th character of the j -th line and the j -th
character of the i -th line will be the same for all i and j . It is
guaranteed that at most \lfloor \frac{n}{2} \rfloor (n divided by 2, rounded
down) transition videos will already be decided, in other words, that at most
2\lfloor \frac{n}{2} \rfloor characters in the input will be F or S.

Output

Print n lines describing the full transition video plan in the same format as
the input. Each of those lines must contain n characters. The j -th character
of the i -th line must be F if the corresponding transition video is funny, S
if the corresponding transition video is scary, or . if i=j .

Each ? character from the input must be replaced with either F or S, and all
other characters from the input must remain unchanged. It must still hold that
the i -th character of the j -th line and the j -th character of the i -th
line are the same for all i and j .

For each permutation of the n scenarios, it must hold that the transition
videos corresponding to playing the scenarios in this order do not have more
than \lceil \frac{3n}{4} \rceil (3n divided by 4, rounded up) videos of the
same type consecutively.

If there are multiple solutions, print any of them. It can be proven that for
all inputs satisfying the constraints of this problem a solution always
exists.

Examples

Input

    5
    
    .?F??
    
    ?.???
    
    F?.S?
    
    ??S.?
    
    ????.

Output

    .FFFF
    F.FFF
    FF.SF
    FFS.F
    FFFF.

Input

    12
    
    .???????????
    
    ?.??????????
    
    ??.?????????
    
    ???.????????
    
    ????.???????
    
    ?????.??????
    
    ??????.?????
    
    ???????.????
    
    ????????.???
    
    ?????????.??
    
    ??????????.?
    
    ???????????.

Output

    .SSSFFSSSSFS
    S.SFFSFSFFFS
    SS.SFFFSSSFS
    SFS.FFSSSSFS
    FFFF.FFFFFSF
    FSFFF.SFFSFF
    SFFSFS.SSSFS
    SSSSFFS.SSFS
    SFSSFFSS.SFS
    SFSSFSSSS.FS
    FFFFSFFFFF.F
    SSSSFFSSSSF.
    
Note

In the first sample: We are allowed \lceil \frac{3\cdot 5}{4} \rceil=4
transition videos of the same type in a row, but for any permutation of the 5
scenarios the player will see only 4 transition videos in total, therefore we
can choose funny or scary freely. We must still respect the already chosen
types.

In the second sample: One of the 479001600 possible permutations of scenarios
is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following
sequence of transition videos for this permutation: SSSSSSSSSFS. Even though
this sequence has 10 scary transition videos in total, it has only 9 scary
transition videos in a row, which is the maximum allowed amount (\lceil
\frac{3\cdot 12}{4} \rceil=9 ).","n = int(input())  # Number of scenarios
a = [0] * (n + 1)  # Array to count 'F' transitions for each scenario
b = [0] * (n + 1)  # Array to count 'S' transitions for each scenario
xx = [""""]  # To store the input matrix

# Read the input matrix and count 'F' and 'S' transitions
for i in range(1, n + 1):
    x = input()
    for j in range(1, n + 1):
        if x[j - 1] == ""F"":
            a[i] += 1
            a[j] += 1
        elif x[j - 1] == ""S"":
            b[i] += 1
            b[j] += 1
    xx.append(x)

sa = []  # Scenarios with only 'F' transitions
sb = []  # Scenarios with only 'S' transitions

# Identify scenarios with only one type of transition
for i in range(1, n + 1):
    if a[i] > 0 and b[i] == 0:
        sa.append(i)
    if b[i] > 0 and a[i] == 0:
        sb.append(i)

# Determine which type to prioritize
if len(sa) >= len(sb):
    t = len(sa)
    # Add scenarios with no transitions to 'sa'
    for i in range(1, n + 1):
        if a[i] == 0 and b[i] == 0:
            sa.append(i)
    # Fill undecided transitions
    for i in range(1, n + 1):
        nx = """"
        for j in range(1, n + 1):
            if xx[i][j - 1] != ""?"":
                nx += xx[i][j - 1]
            elif i in sa[:n // 4 - 1] or j in sa[:n // 4 - 1]:
                nx += ""F""
            else:
                nx += ""S""
        print(nx)
else:
    # Add scenarios with no transitions to 'sb'
    for i in range(1, n + 1):
        if a[i] == 0 and b[i] == 0:
            sb.append(i)
    # Fill undecided transitions
    for i in range(1, n + 1):
        nx = """"
        for j in range(1, n + 1):
            if xx[i][j - 1] != ""?"":
                nx += xx[i][j - 1]
            elif i in sb[:n // 4 - 1] or j in sb[:n // 4 - 1]:
                nx += ""S""
            else:
                nx += ""F""
        print(nx)",2,True,False,False,True,False,True,False,False,False,False,False,False,False
296,codeforces2024,human,qwen2.5-7b-instruct,"Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]","def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    MOD = 10**9 + 7
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        n, k = int(data[index]), int(data[index+1])
        index += 2
        a = list(map(int, data[index:index+n]))
        index += n
        
        # Calculate the initial sum of the array
        initial_sum = sum(a) % MOD
        
        # Function to find the maximum subarray sum using Kadane's algorithm
        def kadane(arr):
            max_ending_here = max_so_far = arr[0]
            for x in arr[1:]:
                max_ending_here = max(x, max_ending_here + x)
                max_so_far = max(max_so_far, max_ending_here)
            return max_so_far
        
        # Find the maximum subarray sum
        max_subarray_sum = kadane(a)
        
        # If the maximum subarray sum is positive, calculate the result
        if max_subarray_sum > 0:
            result = (initial_sum + k * max_subarray_sum) % MOD
        else:
            # If max_subarray_sum is non-positive, best to do no operations if k is 0
            # Since k is always positive as per the problem statement, we handle it normally
            result = initial_sum % MOD
        
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()",2,False,False,False,False,False,False,False,False,False,False,False,False,False
144,codeforces2024,human,qwen2.5-7b-instruct,"Monocarp wants to throw a party. He has n friends, and he wants to have at
least 2 of them at his party.

The i -th friend's best friend is p_i . All p_i are distinct, and for every i
\in [1, n] , p_i \ne i .

Monocarp can send invitations to friends. The i -th friend comes to the party
if both the i -th friend and the p_i -th friend receive an invitation (note
that the p_i -th friend doesn't have to actually come to the party). Each
invitation is sent to exactly one of the friends.

For example, if p = [3, 1, 2, 5, 4] , and Monocarp sends invitations to the
friends [1, 2, 4, 5] , then the friends [2, 4, 5] will come to the party. The
friend 1 won't come since his best friend didn't receive an invitation; the
friend 3 won't come since he didn't receive an invitation.

Calculate the minimum number of invitations Monocarp has to send so that at
least 2  friends come to the party.

Input

The first line contains one integer t (1 \le t \le 5000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of friends; 
  * the second line contains n integers p_1, p_2, \dots, p_n (1 \le p_i \le n ; p_i \ne i ; all p_i are distinct). 

Output

Print one integer — the minimum number of invitations Monocarp has to send.

Example

Input

    3
    
    5
    
    3 1 2 5 4
    
    4
    
    2 3 4 1
    
    2
    
    2 1

Output

    2
    3
    2
    
Note

In the first testcase, Monocarp can send invitations to friends 4 and 5 . Both
of them will come to the party since they are each other's best friends, and
both of them have invitations.

In the second testcase, Monocarp can send invitations to friends 1, 2 and 3 ,
for example. Then friends 1 and 2 will attend: friend 1 and his best friend 2
have invitations, friend 2 and his best friend 3 have invitations. Friend 3
won't attend since his friend 4 doesn't have an invitation. It's impossible to
send invitations to fewer than 3 friends in such a way that at least 2 come.

In the third testcase, Monocarp can send invitations to both friends 1 and 2 ,
and both of them will attend.","t = int(input())

for _ in range(t):

    n = int(input())
    a = list(map(int, input().split()))
    z = 0
    for i in range(n):
        if(a[a[i]-1] == i+1):
            z = 1
            break
    
    if(z==0):
        print(3)
    else:
        print(2)",2,True,False,False,False,False,True,False,False,True,True,False,True,False
338,codeforces2024,human,qwen2.5-7b-instruct,"Alice and Bob have bought a ribbon consisting of n parts. Now they want to
paint it.

First, Alice will paint every part of the ribbon into one of m colors. For
each part, she can choose its color arbitrarily.

Then, Bob will choose at most k  parts of the ribbon and repaint them into the
same color (he chooses the affected parts and the color arbitrarily).

Bob would like all parts to have the same color. However, Alice thinks that
this is too dull, so she wants to paint the ribbon in such a way that Bob
cannot make all parts have the same color.

Is it possible to paint the ribbon in such a way?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of one line containing three integers n , m and k (1
\le m, k \le n \le 50 ) — the number of parts, the number of colors and the
number of parts Bob can repaint, respectively.

Output

For each test case, print YES if Alice can paint the ribbon so that Bob cannot
make all parts have the same color. Otherwise, print NO.

You can print every letter in any register. For example, Yes, yes, yEs will
all be recognized as positive answer.

Example

Input

    5
    
    1 1 1
    
    5 1 1
    
    5 2 1
    
    5 2 2
    
    5 5 3

Output

    NO
    NO
    YES
    NO
    YES
    
Note

In the first test case, a ribbon consists of 1 part. So all its parts will
always have the same color.

In the second test case, there is only 1 color.

In the third test case, Alice can paint the ribbon as follows: [1, 2, 1, 2, 1]
. It's impossible to change the color of at most 1 part so that all parts have
the same color.

In the fourth test case, no matter how Alice paints the ribbon, Bob will
always be able to repaint 2 parts so that all parts have the same color.

In the fifth test case, Alice can paint the ribbon as follows: [1, 2, 3, 4, 5]
. It's impossible to change the color of at most 3 parts so that all parts
have the same color.","def color_uniform(n, m, k):
    if m == k or k > n:
        return ""NO""
    elif m > k:
        return ""YES""
    else:
        return ""NO""
    


for _ in range(int(input())):
    n, m, k = map(int, input().split())
    print(color_uniform(n, m, k))",2,False,False,False,True,False,True,True,False,False,False,True,True,True
241,codeforces2024,human,qwen2.5-7b-instruct,"This problem has an attachment. You can use it to simulate and visualize the
movements of the amoeba.

Amoeba Amanda lives inside a rectangular grid of square pixels. Her body
occupies some of these pixels. Other pixels may be either free or blocked.
Amanda moves across the grid using the so-called amoeboid movement. In each
step of such a movement, her body first shrinks by one pixel (one pixel of the
body is removed and becomes free), and then grows at a different place (one
previously-free pixel is added to the body).

To prevent structural damage, Amanda's body always occupies a connected region
of pixels, which means that any pair of pixels forming the body can be
connected by a sequence of adjacent pixels without ever leaving the body. Two
pixels are considered adjacent if they share a common side (each pixel has at
most 4 neighbours). The body remains connected even during the movement,
including the moment after removing a pixel and before adding another one.

Your task is to help Amanda find her way around. Given her initial position
and desired final position, suggest a sequence of valid moves leading from the
former to the latter.

![](https://espresso.codeforces.com/8d732857e67e5cd7cb6a0af1ed34584572413ddc.png)
Illustration of sample 1 : The filled shape is the initial position, the
dotted region is the final position.

Input

The first line contains two integers r and c (1\le r,c \le 50 ) — the size of
the rectangular grid in pixels.

The next r lines contain c characters each, describing the initial position of
Amanda. Each of those characters is either a dot \texttt{.} denoting a free
pixel, an asterisk \texttt{*} denoting Amanda's body, or an \texttt{X}
denoting a blocked pixel which may never be occupied.

The next line is empty.

The next r lines describe the desired final position in the same format as the
initial position.

It is guaranteed that:

  * The number of pixels forming Amanda's body is the same in both positions, and it is at least 2. 
  * The body of Amanda is connected in the initial position. 
  * The body of Amanda is connected in the final position. 
  * The blocked pixels do not change between the descriptions of the initial and final position, their placement is exactly the same in both positions. 

Output

Print \texttt{YES} if it is possible for Amanda to go from the initial
position to the final one. Otherwise, print \texttt{NO} .

If it is possible, on the next line print one integer m (0\le m\le 10\,000 ) —
the number of moves to execute.

The following m lines must contain four integer coordinates each: i_1 , j_1 ,
i_2 , j_2 (1\le i_1,i_2\le r , 1\le j_1,j_2\le c ). These four coordinates
specify one move, meaning that the pixel at i_1 -th row and j_1 -th column is
first removed from the body. Then, (i_2,j_2) must designate a different
location where one pixel is added.

The sequence should consist only of valid moves and after the last move,
Amanda's body should occupy the desired final position.

If there are multiple solutions, print any of them.

Under the assumptions of this problem, it can be proven that if it is possible
for Amanda to go from the initial position to the desired final one, then it
is possible to do it with at most 10\,000 moves.

Examples

Input

    5 8
    
    .******.
    
    **.X**..
    
    *******.
    
    **.X**..
    
    .******.
    
    .******.
    
    ...X****
    
    .*******
    
    ...X****
    
    .******.

Output

    YES
    5
    3 1 3 8
    2 1 2 8
    4 1 4 8
    2 2 4 7
    4 2 2 7
    
Input

    2 5
    
    *.X..
    
    **X..
    
    ..X**
    
    ..X*.

Output

    NO
    
Note

In the first sample, Amanda executes 5 moves to reach the final position, as
shown in the figure below.

![](https://espresso.codeforces.com/04b7bb193a243e0eaf83952861f5275e04543407.png)","from collections import deque

def is_valid_move(grid, r, c, visited, i1, j1, i2, j2):
    # Check if the move is valid
    if i2 < 0 or i2 >= r or j2 < 0 or j2 >= c:
        return False
    if grid[i2][j2] == '*' or visited[i2][j2]:
        return False
    # Check if the move keeps the body connected
    connected_pixels = 0
    for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        ni, nj = i2 + di, j2 + dj
        if 0 <= ni < r and 0 <= nj < c and grid[ni][nj] == '*':
            connected_pixels += 1
    if connected_pixels < 2:
        return False
    return True

def bfs(grid, r, c, initial_position, final_position):
    # Initialize visited array
    visited = [[False] * c for _ in range(r)]
    # Initialize queue for BFS
    q = deque()
    # Add initial position to the queue
    q.append(initial_position)
    # Mark initial position as visited
    visited[initial_position[0]][initial_position[1]] = True
    # Initialize parent array to track moves
    parent = {}

    while q:
        # Get the current position
        current_position = q.popleft()
        # If the current position is the final position, break
        if current_position == final_position:
            break
        i, j = current_position
        # Explore all possible moves
        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            ni, nj = i + di, j + dj
            if is_valid_move(grid, r, c, visited, i, j, ni, nj):
                # Mark the new position as visited
                visited[ni][nj] = True
                # Add the new position to the queue
                q.append((ni, nj))
                # Store the parent of the new position
                parent[(ni, nj)] = (i, j)
    
    # If final position is not reachable, return None
    if final_position not in parent:
        return None
    
    # Reconstruct the path
    moves = []
    current_position = final_position
    while current_position != initial_position:
        parent_position = parent[current_position]
        moves.append((parent_position[0]+1, parent_position[1]+1, current_position[0]+1, current_position[1]+1))
        current_position = parent_position
    moves.reverse()
    return moves

def main():
    # Read input
    r, c = map(int, input().split())
    initial_grid = [input() for _ in range(r)]
    input()  # Read empty line
    final_grid = [input() for _ in range(r)]

    # Find initial and final positions
    initial_position = None
    final_position = None
    for i in range(r):
        for j in range(c):
            if initial_grid[i][j] == '*':
                initial_position = (i, j)
            if final_grid[i][j] == '*':
                final_position = (i, j)
    
    # Find sequence of moves using BFS
    moves = bfs(initial_grid, r, c, initial_position, final_position)

    # Output result
    if moves:
        print(""YES"")
        print(len(moves))
        for move in moves:
            print(*move)
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()",2,False,False,False,"- The program follows the problem's requirements and constraints.
   - The BFS approach in `func_2` ensures that the path is found if it exists.
   - The checks in `func_1` ensure that each move maintains the required connectivity.

Based on the above analysis, the program appears to be correct and meets all the specified requirements.

Correctness:",False,True,True,True,False,True,False,False,False
352,codeforces2024,human,qwen2.5-7b-instruct,"There are n containers of water lined up, numbered from left to right from 1
to n . Each container can hold any amount of water; initially, the i -th
container contains a_i units of water. The sum of a_i is divisible by n .

You can apply the following operation any (possibly zero) number of times:
pour any amount of water from the i -th container to the j -th container,
where i must be less than j (i.e. i<j ). Any index can be chosen as i or j any
number of times.

Determine whether it is possible to make the amount of water in all containers
the same using this operation.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of containers with water.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i \le 10^9 ) — the amounts of water in the containers. It is guaranteed
that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the
sum of a_i is divisible by n .

It is guaranteed that the sum of n over all test cases in the input does not
exceed 2 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output ""YES"" if it is possible to make the amount of water in all
containers the same using the described operation. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    6
    
    1
    
    43
    
    2
    
    1 3
    
    5
    
    4 5 2 1 3
    
    3
    
    1 2 3
    
    7
    
    4 5 5 0 6 4 4
    
    7
    
    6 5 5 1 3 4 4

Output

    YES
    NO
    YES
    NO
    NO
    YES
    
Note

In the third test case of the example (a=[4, 5, 2, 1, 3] ), you can proceed as
follows:

  * pour 1 unit of water from the first vessel to the fourth, then a=[3, 5, 2, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the third, then a=[3, 4, 3, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the fourth, then a=[3, 3, 3, 3, 3] .","for s in[*open(0)][2::2]:
 a=*map(int,s.split()),;u=sum(a)//len(a);d=f=0
 for x in a:d+=x-u;f|=d
 print('YNEOS'[f<0::2])",2,True,False,True,True,False,True,True,False,False,False,False,False,True
77,codeforces2024,human,qwen2.5-7b-instruct,"This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.","import math

def calculate_additional_area(fountain, n, m):
    r, c = fountain
    # Calculate the distance from the diagonal
    diagonal_distance = abs((r + c) - (n + 1))
    return max(diagonal_distance // 2, 0)

def main():
    import sys
    input = sys.stdin.read
    data = input().split()

    index = 0
    t = int(data[index])
    index += 1
    results = []

    for _ in range(t):
        n = int(data[index])
        m = int(data[index + 1])
        k = int(data[index + 2])
        index += 3

        alpha = (n * m + 1) // 2
        additional_areas = []

        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            additional_areas.append(calculate_additional_area((r, c), n, m))

        results.append((alpha, additional_areas))

    for result in results:
        alpha, additional_areas = result
        print(alpha)
        print(' '.join(map(str, additional_areas)))

if __name__ == ""__main__"":
    main()",2,False,True,False,True,False,True,True,False,False,True,True,True,False
48,codeforces2024,human,qwen2.5-7b-instruct,"In order to test the hypothesis about the cats, the scientists must arrange
the cats in the boxes in a specific way. Of course, they would like to test
the hypothesis and publish a sensational article as quickly as possible,
because they are too engrossed in the next hypothesis about the phone's
battery charge.

Scientists have n boxes in which cats may or may not sit. Let the current
state of the boxes be denoted by the sequence b_1, \dots, b_n : b_i = 1 if
there is a cat in box number i , and b_i = 0 otherwise.

Fortunately, the unlimited production of cats has already been established, so
in one day, the scientists can perform one of the following operations:

  * Take a new cat and place it in a box (for some i such that b_i = 0 , assign b_i = 1 ). 
  * Remove a cat from a box and send it into retirement (for some i such that b_i = 1 , assign b_i = 0 ). 
  * Move a cat from one box to another (for some i, j such that b_i = 1, b_j = 0 , assign b_i = 0, b_j = 1 ). 

It has also been found that some boxes were immediately filled with cats.
Therefore, the scientists know the initial position of the cats in the boxes
s_1, \dots, s_n and the desired position f_1, \dots, f_n .

Due to the large amount of paperwork, the scientists do not have time to solve
this problem. Help them for the sake of science and indicate the minimum
number of days required to test the hypothesis.

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
descriptions of the test cases.

Each test case consists of three lines.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the number of boxes.

The second line of each test case contains a string s of n characters, where
the i -th character is '1' if there is a cat in the i -th box and '0'
otherwise.

The third line of each test case contains a string f of n characters, where
the i -th character is '1' if there should be a cat in the i -th box and '0'
otherwise.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the minimum
number of operations required to obtain the desired position from the initial
position. It can be shown that a solution always exists.

Example

Input

    6
    
    5
    
    10010
    
    00001
    
    1
    
    1
    
    1
    
    3
    
    000
    
    111
    
    4
    
    0101
    
    1010
    
    3
    
    100
    
    101
    
    8
    
    10011001
    
    11111110

Output

    2
    0
    3
    2
    1
    4
    
Note

In the first test case, you can first move the cat from the first box to the
fifth, and then remove the cat from the fourth box.

In the second test case, there is nothing to do — the only cat is already
sitting in the correct box.

In the third test case of input data, it takes three days to place a cat in
each box.","for _ in range(int(input())):
    n=int(input())
    s=input()
    f=input()
    c=0
    for i in range(n):
        if s[i]==f[i] and s[i]=='1':
            c+=1
    s1=0
    for i in s:
        if i=='1':
            s1+=1
    f1=0
    for i in f:
        if i=='1':
            f1+=1
    print(max(s1,f1)-c)",2,True,False,False,False,False,False,False,False,False,False,False,False,True
86,codeforces2024,human,qwen2.5-7b-instruct,"[Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)","t = int(input())

for _ in range(t):
    n, x, y = list(map(int, input().split()))
    a = list(map(int,input().split()))

    a = [num - 1 for num in a]  

    ans = x - 2
    st = set(a)
    a.sort()

    for i in range(x):
        t1 = (a[i] + 1) % n
        t2 = (a[i] + 2) % n
        if t1 not in st and t2 in st:
            ans += 1

    odd = []
    even = []

    for i in range(x):
        next_elem = a[0] + n if i == x - 1 else a[i + 1]
        gap = next_elem - a[i] - 1
        if gap > 1 and gap % 2 == 1:
            odd.append(gap)
        elif gap > 0 and gap % 2 == 0:
            even.append(gap)

    odd.sort()
    even.sort()

    for gap in odd:
        if y < gap // 2:
            ans += 2 * y
            y = 0
            break
        ans += gap
        y -= gap // 2

    for gap in even:
        if y < gap // 2:
            ans += 2 * y
            y = 0
            break
        ans += gap
        y -= gap // 2

    print(ans)",2,True,False,False,True,False,True,True,True,True,False,True,False,True
78,codeforces2024,human,qwen2.5-7b-instruct,"This is an easy version of the problem; it differs from the hard version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ), the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot). Then output k non-negative integers a_1, a_2, \dots,
a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to \alpha ); 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than \alpha ). 

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all k fountains belong to Bob; 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases compared to the case when all k fountains belong to Bob. 

If you output any other positive number instead of 1 that fits into a 64-bit
signed integer type, it will also be recognized as 1 . Thus, a solution to the
hard version of this problem will also pass the tests for the easy version.

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 1 
    1
    0 0 1 1 0 0 0 0 0 
    6
    1 0 0 0 
    1
    1 1 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.","t = int(input())
for z in range(t):
    n, m, k = map(int, input().split())
    c = [ ]
    for i in range(k):
        x, y = map(int, input().split())
        c.append((y, x, i))
    c.sort()
    f = [(1, 0, 0)]
    s = 0
    answer = [0] * k
    for i in range(k):
        if c[i][1] > f[-1][1]:
            s += (c[i][0] - 1) * (c[i][1] - f[-1][1])
            f.append((c[i][0], c[i][1], c[i][2]))
 
    answer[f[-1][2]] = 1
    for i in range(1, len(f) - 1):
        if f[i][0] < f[i + 1][0]:
            answer[f[i][2]] = 1
    print(s + (n - f[-1][1]) * m)
    print(*answer)",2,True,False,False,True,False,True,False,False,False,True,False,False,False
