
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given two integers x and y . A sequence a of length n is called
modular if a_1=x , and for all 1 < i \le n the value of a_{i} is either
a_{i-1} + y or a_{i-1} \bmod y . Here x \bmod y denotes the remainder from
dividing x by y .

Determine if there exists a modular sequence of length n with the sum of its
elements equal to S , and if it exists, find any such sequence.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 2 \cdot 10^4 ). The description of the test cases
follows.

The first and only line of each test case contains four integers n , x , y ,
and s (1 \le n \le 2 \cdot 10^5 , 0 \le x \le 2 \cdot 10^5 , 1 \le y \le 2
\cdot 10^5 , 0 \le s \le 2 \cdot 10^5 ) — the length of the sequence, the
parameters x and y , and the required sum of the sequence elements.

The sum of n over all test cases does not exceed 2 \cdot 10^5 , and also the
sum of s over all test cases does not exceed 2 \cdot 10^5 .

Output

For each test case, if the desired sequence exists, output "Yes" on the first
line (without quotes). Then, on the second line, output n integers a_1, a_2,
\ldots, a_n separated by a space — the elements of the sequence a . If there
are multiple suitable sequences, output any of them.

If the sequence does not exist, output "No" on a single line.

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    3
    
    5 8 3 28
    
    3 5 3 6
    
    9 1 5 79

Output

    YES
    8 11 2 2 5 
    NO
    NO
    
Note

In the first example, the sequence [8, 11, 2, 5, 2] satisfies the conditions.
Thus, a_1 = 8 = x , a_2 = 11 = a_1 + 3 , a_3 = 2 = a_2 \bmod 3 , a_4 = 5 = a_3
+ 3 , a_5 = 2 = a_4 \bmod 3 .

In the second example, the first element of the sequence should be equal to 5
, so the sequence [2, 2, 2] is not suitable.

- Program: 
t = int(input())
for _ in range(t):
    (n, x, y, s) = map(int, input().split())
    result = func_1(n, x, y, s)
    if result:
        print('Yes')
        print(' '.join(map(str, result)))
    else:
        print('No')

def func_1(n, x, y, s):
    sequence = [x]
    current_sum = x
    for i in range(1, n):
        if current_sum + y <= s and (s - current_sum - y) % y == 0:
            sequence.append(sequence[-1] + y)
            current_sum += y
        else:
            sequence.append(sequence[-1] % y)
            current_sum += sequence[-1]
        if current_sum > s:
            return None
    if current_sum == s:
        return sequence
    else:
        return None



- Annotated Code: 
t = int(input())
for _ in range(t):
    (n, x, y, s) = map(int, input().split())
    result = func_1(n, x, y, s)
    if result:
        print('Yes')
        print(' '.join(map(str, result)))
    else:
        print('No')

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^5, x and y are integers such that 0 ≤ x ≤ 2 ⋅ 10^5 and 1 ≤ y ≤ 2 ⋅ 10^5, and s is an integer such that 0 ≤ s ≤ 2 ⋅ 10^5.
def func_1(n, x, y, s):
    sequence = [x]
    current_sum = x
    for i in range(1, n):
        if current_sum + y <= s and (s - current_sum - y) % y == 0:
            sequence.append(sequence[-1] + y)
            current_sum += y
        else:
            sequence.append(sequence[-1] % y)
            current_sum += sequence[-1]
        
        if current_sum > s:
            return None
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\), `x` is an integer such that \(0 \leq x \leq 2 \cdot 10^5\), `y` is an integer such that \(1 \leq y \leq 2 \cdot 10^5\), `s` is an integer such that \(0 \leq s \leq 2 \cdot 10^5\), `sequence` is a list containing elements based on the conditions within the loop, and `current_sum` is the cumulative sum of the elements in `sequence` up to the last appended element.
    if (current_sum == s) :
        return sequence
        #The program returns the list 'sequence' which contains elements based on the conditions within the loop, and the cumulative sum of these elements up to the last appended element is equal to 's'
    else :
        return None
        #None



Beggining of Original Assessment: 
Reasoning:

To determine the correctness of the given program, let's break down the logic and check if it aligns with the problem statement and requirements.

1. **Input Parsing**: The program correctly parses the input and passes it to `func_1` for processing. This part is correct.

2. **Function `func_1`**:
   - It initializes the sequence with the starting value `x`.
   - It iteratively builds the sequence by either adding `y` or taking the modulus with `y` depending on the remaining sum `s - current_sum`.
   - It checks if the current sum exceeds `s` and returns `None` if it does, ensuring that the sequence sum stays within the limit.
   - After building the sequence, it checks if the total sum of the sequence equals `s`. If it does, it returns the sequence; otherwise, it returns `None`.

3. **Output Formatting**:
   - If `func_1` returns a sequence, the program prints "Yes" followed by the sequence.
   - If `func_1` returns `None`, the program prints "No".

Let's verify if the logic handles all edge cases as per the problem statement:

- **Edge Case 1**: When `x = 0` and `y = 1`, the sequence should always be `[0, 0, ..., 0]` with the sum being `0`. The function correctly handles this by checking if the sum matches.
- **Edge Case 2**: When `y` is very large and `x` and `s` are small, the sequence should be constructed using only `x % y` and `x + y`. The function correctly handles this by checking the sum and appending the appropriate values.
- **Edge Case 3**: When `s` is very small and the sequence needs to be built incrementally without exceeding `s`. The function correctly checks the sum at each step and avoids exceeding `s`.

Given the above analysis, the program appears to handle all specified cases correctly.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

