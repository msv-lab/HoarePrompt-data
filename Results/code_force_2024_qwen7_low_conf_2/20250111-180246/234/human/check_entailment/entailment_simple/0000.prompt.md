
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import sys

input = sys.stdin.readline
class ListNode:

    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v
m = 998244353
print(func_5())

#Function 1:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5. l is a list of q integers where 1 ≤ l_i ≤ n for all 1 ≤ i ≤ q. r is a list of q integers where 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q.
def func_1():
    return list(map(int, input().split()))
    #The program returns a list of integers generated by splitting the input string and converting each element to an integer

#Function 2:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, and two lists l and r are provided where l is a list of q integers and r is a list of q integers. Each integer in l and r is between 1 and n, inclusive.
def func_2():
    return int(input())
    #The program waits for user input and then returns an integer value

#Function 3:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, l is a list of q integers where each integer satisfies 1 ≤ l_i ≤ n, and r is a list of q integers where each integer satisfies 1 ≤ r_i ≤ n.
def func_3():
    return map(int, input().split())
    #The program returns a map object containing integers converted from user input split by spaces

#Function 4:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, and l_i and r_i are integers such that 1 ≤ l_i, r_i ≤ n for all 1 ≤ i ≤ q.
def func_4():
    return input().strip()
    #input value stripped of leading and trailing whitespace

#Function 5:
#State of the program right berfore the function call: n and q are positive integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5, l is a list of q positive integers where 1 ≤ l_i ≤ n, and r is a list of q positive integers where 1 ≤ r_i ≤ n.
def func_5():
    n, q = func_3()
    l, r = func_1(), func_1()
    nodes = [None] * (n + 1)
    for i in range(q):
        le, ri = nodes[l[i]], nodes[r[i]]
        
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                ri.le, ri.ri = le, lri
            else:
                le.ri, ri.le = ri, le
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                le.le, le.ri = rle, ri
            else:
                le.ri, ri.le = ri, le
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            nodes[l[i]].ri, nodes[r[i]].le = nodes[r[i]], nodes[l[i]]
        
    #State of the program after the  for loop has been executed: `nodes` is a list of length `n + 1`, where the first `q` elements form a linked list structure based on the values in `l` and `r`, and the remaining elements are `None`.
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
        
    #State of the program after the  for loop has been executed: `nodes` is a list of length `n + 1`, where the first `q` elements form a linked list structure based on the values in `l` and `r`, and the remaining elements are `None`; `a` contains the sequence of indices of all nodes in the linked list formed by the first `q` elements, each following the `ri` pointers until a node with `ri` being `None` is reached; `i` is `None` or the index of the last node in the linked list, depending on whether the loop terminates normally or due to the `break` statement; `n` is a non-negative integer representing the length of the linked list minus one.
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
        
    #State of the program after the  for loop has been executed: `seg` is a list of length `n+1` where for each `i` from `0` to `q-1`, the value at index `max(a[i], a[i + 1])` is incremented by `1`, `i` is `q-1` if the loop executes `q` times, and `i` is `None` if the loop does not execute, `q` must be a non-negative integer, `nodes` is a list of length `n+1` containing the linked list structure, and `a` contains the sequence of indices.
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
        
    #State of the program after the  for loop has been executed: `seg` is a list of length `n+1`, `i` is `None` (indicating the loop did not execute), `cnt` is `n+1` if the loop executed at least once and the last node was a linked node (`nodes[i]` is `True`), otherwise `cnt` is `1`, `q` is the number of iterations the loop executed, `nodes` is a list of length `n+1` containing the linked list structure, `a` contains the sequence of indices, `ans` is `0` if any node in `nodes` is `False` and `1` if all nodes are `True`, and `ans` is the result of `ans` modulo `m` after all iterations.
    return ans
    #`The program returns ans which is the result of ans modulo m after all iterations`


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
