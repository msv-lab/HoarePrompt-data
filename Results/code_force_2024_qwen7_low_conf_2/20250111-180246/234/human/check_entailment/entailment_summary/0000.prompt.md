
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

# Functions with Execution Summary:
import sys

input = sys.stdin.readline
class ListNode:

    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v
m = 998244353
print(func_5())

Function number 1 :
 Code:
 '''
def func_1():
    return list(map(int, input().split()))
''' 

 Output hints for function1:  The function `func_1` reads a single input line from the standard input, which is expected to be a space-separated sequence of integers. It then splits this line into individual elements, converts each element to an integer, and returns a list of these integers. There are no specific parameters passed to the function; instead, it relies on the user to provide the necessary input. If the input does not conform to the expected format (i.e., a sequence of integers separated by spaces), the function will raise a `ValueError`.
Function number 2 :
 Code:
 '''
def func_2():
    return int(input())
''' 

 Output hints for function2:  The function accepts no parameters and waits for user input, which must be an integer. It then returns this integer value. There are no additional actions performed by the function. Potential edge cases include the user entering non-integer values, in which case the function will raise an error and the calling program will need to handle this exception.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().split())
''' 

 Output hints for function3:  The function processes user input split by spaces and returns a map object containing integers. The function reads a single line of input from the user, splits it into individual strings based on spaces, converts each string to an integer using the `map` function, and returns the resulting map object. Potential edge cases include handling empty input or non-integer values in the input string. If the input contains non-integer values, they will be ignored, and only the valid integers will be included in the returned map object.
Function number 4 :
 Code:
 '''
def func_4():
    return input().strip()
''' 

 Output hints for function4:  The function `func_4()` reads a single string input from the standard input, strips any leading and trailing whitespace, and returns the modified string. This operation is performed every time the function is called. There are no edge cases or missing functionalities noted in the provided code.
Function number 5 :
 Code:
 '''
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans
''' 

 Output hints for function5:  The function `func_5` accepts four parameters: `n`, `q`, `l`, and `r`. Here, `n` and `q` are positive integers with constraints `1 ≤ q < n ≤ 3 ⋅ 10^5`, `l` is a list of `q` positive integers, and `r` is another list of `q` positive integers. The function constructs a linked list using these parameters and then calculates a specific value based on the structure of this linked list.

1. It initializes a list `nodes` of length `n + 1` with `None` values.
2. For each pair of indices `(l[i], r[i])` from the lists `l` and `r`, it connects them in the linked list by adjusting the `le` (left) and `ri` (right) pointers in the `nodes` list.
3. After constructing the linked list, it determines the sequence of indices that follow the `ri` pointers from each node in the list, storing this sequence in the list `a`.
4. It then creates a segment array `seg` of length `n + 1` and updates it based on the sequence `a`, incrementing the count at indices corresponding to the sequence.
5. Finally, it iterates over the nodes in reverse order, counting the segments, and calculates the answer `ans` by multiplying the counts and taking the result modulo `m`.

The function returns `ans` which is the result of the final calculation modulo `m`.

Potential edge cases:
- If any of the nodes in the `nodes` list are not connected properly, the function will still construct the linked list and proceed with the calculations.
- If `l` or `r` contains invalid indices (not between 1 and `n`), the function will still attempt to connect the nodes as specified, but the linked list structure may be incorrect.

Missing functionality:
- The function assumes that all nodes are valid and that the indices in `l` and `r` are within the specified bounds. There is no explicit validation for these assumptions.


# Your response:
Reasoning:  
Correctness: **True** or **False**

