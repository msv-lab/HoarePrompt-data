
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

- Program:
import sys
#Function 1:
def func_1():
    return list(map(int, input().split()))

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return map(int, input().split())

#Function 4:
def func_4():
    return input().strip()

#Function 5:
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans



- Function Summary: 
Output hints for function number 5 : The function `func_5` accepts four parameters: `n`, `q`, `l`, and `r`. Here, `n` and `q` are positive integers with constraints `1 ≤ q < n ≤ 3 ⋅ 10^5`, `l` is a list of `q` positive integers, and `r` is another list of `q` positive integers. The function constructs a linked list using these parameters and then calculates a specific value based on the structure of this linked list.

1. It initializes a list `nodes` of length `n + 1` with `None` values.
2. For each pair of indices `(l[i], r[i])` from the lists `l` and `r`, it connects them in the linked list by adjusting the `le` (left) and `ri` (right) pointers in the `nodes` list.
3. After constructing the linked list, it determines the sequence of indices that follow the `ri` pointers from each node in the list, storing this sequence in the list `a`.
4. It then creates a segment array `seg` of length `n + 1` and updates it based on the sequence `a`, incrementing the count at indices corresponding to the sequence.
5. Finally, it iterates over the nodes in reverse order, counting the segments, and calculates the answer `ans` by multiplying the counts and taking the result modulo `m`.

The function returns `ans` which is the result of the final calculation modulo `m`.

Potential edge cases:
- If any of the nodes in the `nodes` list are not connected properly, the function will still construct the linked list and proceed with the calculations.
- If `l` or `r` contains invalid indices (not between 1 and `n`), the function will still attempt to connect the nodes as specified, but the linked list structure may be incorrect.

Missing functionality:
- The function assumes that all nodes are valid and that the indices in `l` and `r` are within the specified bounds. There is no explicit validation for these assumptions.+


Beggining of Original Assessment: 
Reasoning:
To verify the correctness of the given program, let's analyze the key components step-by-step:

1. **Input Parsing**:
   - The input parsing functions `func_1` and `func_2` correctly read the input as required.
   - The main logic is encapsulated within `func_4`.

2. **Node Management**:
   - The program uses a custom node structure `ListNode` to manage the linked list representation of the operations. This allows tracking of the maximum values in the left and right parts during each operation.
   - Nodes are dynamically created and linked to form the necessary subarrays after each split operation.

3. **Reconstructing Permutations**:
   - After all operations, the program attempts to reconstruct the possible original permutations by traversing the linked list and recording the order of elements.
   - The `a` list captures the sequence of elements as determined by the linked list traversal.

4. **Segment Tree and Counting**:
   - The segment tree `seg` is used to count how many times each element has been processed as either the leftmost or rightmost element in the remaining sequence.
   - The `ans` variable calculates the number of valid permutations by considering the frequency of each element being involved in the splits.

5. **Modulo Operation**:
   - All intermediate results are kept modulo \(998244353\) to handle large numbers, which is a common practice in combinatorial problems.

Given the constraints and the provided example, the code appears to follow the problem statement correctly. It handles the dynamic creation and manipulation of linked lists, reconstructs the potential permutations, and computes the number of valid permutations efficiently.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

