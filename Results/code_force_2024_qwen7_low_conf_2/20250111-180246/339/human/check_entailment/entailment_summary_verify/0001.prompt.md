
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1

- Program:
def func():
    N = int(input())
    ans = []
    a = [int(x) for x in input().split()]
    b = [(i, a[i]) for i in range(len(a))]
    S = sorted(b, key=lambda x: x[1])
    m = max(a)
    bits = [0] + [1] * N + [0]
    wtr = [[] for q in range(N)]
    f = []
    g = 1
    last = 0
    for (i, num) in S:
        for e in range(num - last):
            f.append(g)
        last = num
        bits[i + 1] = 0
        g += bits[i] + bits[i + 2] - 1
    for d in range(1, m + 1):
        print(sum([f[d * x] for x in range(1 + (m - 1) // d)]), end=' ')



- Function Summary: 
The function processes a list `a` of integers and an integer `n` representing the length of the list `a`. It first sorts the list based on the values of its elements, then calculates a series of values based on the sorted list and prints the sums of these values for each divisor up to the maximum value in `a`. The final state of the program includes an empty `ans` list, a sorted list `S` based on the second element of each tuple, the maximum value `m` from list `a`, a `bits` list of length `N+2` starting with `0`, followed by `N` elements each set to `1`, and ending with `0`, a `wtr` list of `N` empty lists, a `f` list containing the elements of `g` repeated for each tuple in `S` based on the second element of the tuple, `g` is `1`, `last` is the last `num` value processed in the loop, and `i` is the last index processed in the loop. Additionally, the function prints the sum of the elements in the list generated by the list comprehension for each divisor from `1` to `m`.

Beggining of Original Assessment: 
Reasoning:

1. **Input Parsing and Preparation**: 
   - The program correctly reads the number of monsters \(N\) and their health points \(a\).
   - It sorts the monsters based on their health points.
   - It initializes some auxiliary arrays that will be used for calculations.

2. **Bit Array Initialization**:
   - The `bits` array is initialized to keep track of the changes in the segments of the monsters' health points.
   - The `wtr` array is not used in the given implementation but is initialized as an empty list of lists.
   - The `f` array is used to store intermediate results but is not fully utilized in the current implementation.

3. **Update Logic**:
   - For each monster in the sorted order, the program calculates the number of segments affected by the monster's health points.
   - The `g` variable accumulates the number of segments affected by the changes in health points.
   - The `last` variable keeps track of the previous monster's health point to calculate the difference.

4. **Final Calculation and Output**:
   - The program attempts to calculate the minimum number of seconds required to kill all monsters for each possible value of \(k\) from 1 to \(m\).
   - It uses the `f` array to compute the sum of values for segments where the health point is a multiple of \(k\).

### Analysis:

- The program seems to have the logic to calculate the minimum number of seconds required to kill all monsters for each \(k\). However, there are a few issues:
  - The `wtr` array is not used, which could suggest an incomplete or unnecessary part of the logic.
  - The `f` array is not fully utilized and might not be necessary for the final calculation.
  - The final output format does not match the expected output format in the examples. The examples show a sequence of numbers for each \(k\), while the program only prints one number for each \(k\).

### Conclusion:

Given the description of the problem, the provided code does not fully implement the logic to calculate the minimum number of seconds for each \(k\). The current implementation only prints one value per \(k\), which does not align with the expected output format. Therefore, the provided code is not correct according to the problem statement.

Correctness: **False**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

