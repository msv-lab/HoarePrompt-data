The code calculates `max_draws` using the formula `min(p1, p3 - p2) + min(p2, p3 - p1)`. Let's break this down:

1. `min(p1, p3 - p2)` is the minimum of `p1` and `p3 - p2`.
2. `min(p2, p3 - p1)` is the minimum of `p2` and `p3 - p1`.

Since `0 \leq p1 \leq p2 \leq p3 \leq 30`, both `p3 - p2` and `p3 - p1` are non-negative. Given the constraints, the minimum values can be determined as follows:

- `min(p1, p3 - p2)` will be `p1` because `p1 \leq p3 - p2`.
- `min(p2, p3 - p1)` will be `p2` because `p2 \leq p3 - p1`.

Therefore, `max_draws` will be `p1 + p2`.

The initial conditions are:
- `total_points` is `p1 + p2 + p3`.
- If `total_points` is odd or `p3 > p1 + p2`, `results` contains at least one `-1`. Otherwise, `results` does not contain `-1`.

Since `total_points` is `p1 + p2 + p3` and `max_draws` is `p1 + p2`, the condition `total_points % 2 == 1` will determine if `results` contains `-1`.

Output State: **`test_cases` contains at least one tuple \((p1, p2, p3)\) such that \(0 \leq p1 \leq p2 \leq p3 \leq 30\); `total_points` is `p1 + p2 + p3`; `max_draws` is `p1 + p2`; if `(p1 + p2 + p3) % 2 == 1` or `p3 > p1 + p2`, `results` contains at least one `-1`, otherwise `results` does not contain `-1`.**