The code snippet sets `mx` to the maximum value between its current value and `cur`. The value of `cur` depends on the next character in `s` and the value of `prev_char`. Since the exact value of `cur` is not given, we will consider the two possible cases:

1. If `prev_char` is '1' and the next character in `s` is '0', then `cur` is the next character in `s`.
2. Otherwise, `cur` is the ASCII value of the next character in `s` minus 1.

Let's denote the next character in `s` as `next_char`.

- Case 1: If `prev_char` is '1' and `next_char` is '0', then `cur` is `next_char`, which is a character.
- Case 2: If the condition is not met, then `cur` is the ASCII value of `next_char` minus 1, which is an integer.

In both cases, `mx` is updated to the maximum value between its current value (which is 1) and `cur`. Since `cur` can either be a character or an integer, we need to handle both possibilities.

Given that `cur` is the maximum of `mx` and `cur`, and `mx` was initially 1, `mx` will be updated to the value of `cur` if `cur` is greater than 1. If `cur` is less than or equal to 1, `mx` remains 1.

Output State: **`total` is 10, `s` is a non-empty binary string with at least one character remaining, `mn` is 0, `mx` is the maximum of 1 and `cur`, `cur` is the next character in `s` if `prev_char` is '1' and the next character is '0', otherwise `cur` is the ASCII value of the next character in `s` minus 1.**