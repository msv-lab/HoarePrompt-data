
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.

- Program: 

#Function 1:
def func_1(tree, start_node):
    from collections import deque
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        current_distance = distances[node]
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
    return distances

#Function 2:
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        tree[v].append(u)
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for (node, dist) in distances.items() if dist == d]
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
    return (len(operations), operations)



- Annotated Code: 
n = 4
edges = [(1, 2), (1, 3), (1, 4)]
(num_operations, operations) = func_2(n, edges)
print(num_operations)
for (v, d) in operations:
    print(v, d)

#Function 1:
#State of the program right berfore the function call: tree is a dictionary where each key represents a node in the tree and its value is a list of neighboring nodes. start_node is an integer representing the starting node for breadth-first search, such that 1 <= start_node <= n, where n is the number of vertices in the tree.
def func_1(tree, start_node):
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        
        current_distance = distances[node]
        
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is an empty list, `distances` contains the shortest distance from the starting node to all nodes that are reachable in the tree, `current_distance` is the maximum distance found among the visited nodes, and `node` is the last node processed in the final iteration of the loop.
    return distances
    #The program returns the dictionary 'distances' which contains the shortest distance from the starting node to all nodes that are reachable in the tree
#Overall this is what the function does:The function `func_1` accepts a dictionary `tree` representing a tree structure where each key is a node and its value is a list of neighboring nodes, along with an integer `start_node` indicating the starting node for a breadth-first search (BFS). The function performs a BFS traversal to calculate the shortest distance from the `start_node` to all other nodes that are reachable within the tree. After completing the BFS, the function returns a dictionary `distances` where each key is a node in the tree and its corresponding value is the shortest distance from the `start_node` to that node.

#Function 2:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the tree, where 1 ≤ n ≤ 2 \cdot 10^3. edges is a list of tuples, where each tuple (u, v) represents an edge connecting vertices u and v in the tree. Each vertex is numbered from 1 to n, and no vertex is connected to itself or has more than one edge connecting it to another vertex.
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        
        tree[v].append(u)
        
    #State of the program after the  for loop has been executed: `edges` is an empty list, `tree` is a dictionary where for each key `u` from 1 to `n`, the value is a list containing `u-1` followed by all the vertices `v` connected to `u` through the edges.
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for node, dist in distances.items() if dist == d]
        
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
        
    #State of the program after the  for loop has been executed: `edges` is an empty list, `tree` is a dictionary where for each key `u` from 1 to `n`, the value is a list containing `u-1` followed by all the vertices `v` connected to `u` through the edges, `distances` is a list of distances from vertex 1 to all other vertices in the tree, `max_distance` is the maximum value in `distances`, `operations` is a list of tuples `(nodes_at_d[0], d)` for each `d` from `0` to `max_distance` where `nodes_at_d` is non-empty.
    return len(operations), operations
    #`The program returns the length of the operations list and the list itself, where each tuple in the list has the form (nodes_at_d[0], d) for each distance d from 0 to max_distance, and nodes_at_d is non-empty`
#Overall this is what the function does:The function `func_2` accepts two parameters: `n`, an integer representing the number of vertices in the tree, and `edges`, a list of tuples where each tuple `(u, v)` represents an edge connecting vertices `u` and `v`. It constructs a tree representation and calculates the distances from vertex 1 to all other vertices. Then, it identifies nodes at each distance level and creates a list of tuples indicating the first node at each distance level along with the distance. Finally, it returns the length of this list and the list itself. The returned list contains tuples of the form `(nodes_at_d[0], d)` for each distance `d` from 0 to the maximum distance, ensuring that `nodes_at_d` is non-empty.




Beggining of Original Assessment: 
Reasoning:
1. The provided program consists of two functions: `func_1` and `func_2`.
2. `func_1` performs a breadth-first search (BFS) to calculate the shortest distances from a starting node to all other nodes in the tree.
3. `func_2` constructs the tree from the given edges, then uses `func_1` to compute the distances from the root node (node 1). After that, it iterates through all possible distances and selects one node at each distance to color black, ensuring all nodes are eventually colored.
4. The program correctly identifies that the number of operations needed is equal to the maximum distance in the tree plus one (since all nodes are reachable within this distance).
5. The output format matches the requirements: it specifies the minimum number of operations and lists the operations needed to color all nodes black.

Given the problem constraints and the logic implemented in the functions, the program should correctly find a sequence of operations to color all nodes in the tree black using the minimum possible number of operations.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

