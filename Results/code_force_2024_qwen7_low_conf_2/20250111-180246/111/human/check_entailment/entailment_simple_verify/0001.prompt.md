
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Patrick calls a substring^\dagger of a binary string^\ddagger good if this
substring contains exactly one 1.

Help Patrick count the number of binary strings s such that s contains exactly
n good substrings and has no good substring of length strictly greater than k
. Note that substrings are differentiated by their location in the string, so
if s = 1010 you should count both occurrences of 10.

^\dagger A string a is a substring of a string b if a can be obtained from b
by the deletion of several (possibly, zero or all) characters from the
beginning and several (possibly, zero or all) characters from the end.

^\ddagger A binary string is a string that only contains the characters 0 and
1.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2500 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (1 \leq n \leq
2500 , 1 \leq k \leq n ) — the number of required good substrings and the
maximum allowed length of a good substring.

It is guaranteed that the sum of n over all test cases does not exceed 2500 .

Output

For each test case, output a single integer — the number of binary strings s
such that s contains exactly n good substrings and has no good substring of
length strictly greater than k . Since this integer can be too large, output
it modulo 998\,244\,353 .

Example

Input

    6
    
    1 1
    
    3 2
    
    4 2
    
    5 4
    
    6 2
    
    2450 2391

Output

    1
    3
    5
    12
    9
    259280854
    
Note

In the first test case, the only suitable binary string is 1. String 01 is not
suitable because it contains a substring 01 with length 2 > 1 .

In the second test case, suitable binary strings are 011, 110 and 111.

In the third test case, suitable binary strings are 101, 0110, 0111, 1110, and
1111.

- Program: 
MOD = 998244353
t = int(input())
for _ in range(t):
    (n, k) = map(int, input().split())
    print(func_1(n, k))

def func_1(n, k):
    dp = [[0] * (n + 1) for _ in range(k + 1)]
    dp[1][1] = 1
    for i in range(2, k + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD
    result = sum((dp[i][n] for i in range(1, k + 1))) % MOD
    return result



- Annotated Code: 
MOD = 998244353
t = int(input())
for _ in range(t):
    (n, k) = map(int, input().split())
    print(func_1(n, k))

#State of the program right berfore the function call: n and k are integers such that 1 ≤ n ≤ 2500 and 1 ≤ k ≤ n, and n is the number of required good substrings and k is the maximum allowed length of a good substring.
def func_1(n, k):
    dp = [([0] * (n + 1)) for _ in range(k + 1)]
    dp[1][1] = 1
    for i in range(2, k + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD
        
    #State of the program after the  for loop has been executed: `dp` is a 2D list of dimensions `(k+1) x (n+1)`, where `dp[1][1] = 1`, `dp[i][1] = 0` for all `i` from `2` to `k+1`, `dp[1][j] = 0` for all `j` from `2` to `n+1`, and `dp[i][j]` for all `i` from `2` to `k+1` and `j` from `2` to `n+1` equals the sum of `dp[i-1][j]` and `dp[i-1][j-1]` modulo `MOD`, `k` is a non-negative integer greater than or equal to `2`, `n` is a non-negative integer greater than or equal to `1`, and `MOD` is a constant value.
    result = sum(dp[i][n] for i in range(1, k + 1)) % MOD
    return result
    #The program returns result which is the sum of dp[i][n] for i from 2 to k+1 modulo MOD



Beggining of Original Assessment: 
Reasoning:

The program aims to count the number of binary strings `s` that contain exactly `n` good substrings and have no good substring of length strictly greater than `k`. To achieve this, the program uses dynamic programming (DP).

Let's break down the logic:

1. **Initialization**: 
   - `dp[i][j]` represents the number of binary strings of length `i` that contain exactly `j` good substrings.
   - `dp[1][1] = 1` because a string of length 1 containing exactly 1 good substring can only be "1".

2. **DP Transition**:
   - For each length `i` from 2 to `k`, and for each number of good substrings `j` from 1 to `n`:
     - If we append '0' to a string of length `i-1`, it won't change the number of good substrings, so `dp[i][j] += dp[i-1][j]`.
     - If we append '1', the number of good substrings will increase by 1 if the last character was '0', so `dp[i][j] += dp[i-1][j-1]`.

3. **Result Calculation**:
   - Sum up `dp[i][n]` for all `i` from 1 to `k` to get the total number of binary strings of any length up to `k` that contain exactly `n` good substrings.

This approach seems to correctly model the problem. However, there are a few points to verify:

1. The function `func_1` is defined to handle the DP calculation.
2. The modulo operation (`% MOD`) is applied correctly throughout the computation to avoid overflow.
3. The summing step at the end is also correctly applied to accumulate the results.

Given the structure and logic, the program appears to be implementing the correct algorithm. Therefore, the program is correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

