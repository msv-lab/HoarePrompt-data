Reasoning:
1. The program correctly defines the constants and reads the number of test cases (`t`).
2. For each test case, it calls the `func_1` function with the values of `n` and `k`.
3. The `func_1` function initializes a dynamic programming (DP) table `dp` of size `(k+1) x (n+1)`.
4. The base case `dp[1][1] = 1` is correctly set, indicating that there is one way to have exactly one good substring ("1") of length 1.
5. The DP transitions are correctly implemented: `dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD`, ensuring that the count of ways to form a good substring of length `j` using the first `i` characters is computed based on previous states.
6. After filling the DP table, the function sums up the relevant entries `dp[i][n]` for `i` from `2` to `k+1` to get the final result.
7. The function correctly returns the result modulo `998244353`.

Given the problem description and the implementation details, the program appears to correctly solve the problem as described.

Correctness: **True**