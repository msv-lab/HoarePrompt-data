
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
This problem has an attachment. You can use it to simulate and visualize the
movements of the amoeba.

Amoeba Amanda lives inside a rectangular grid of square pixels. Her body
occupies some of these pixels. Other pixels may be either free or blocked.
Amanda moves across the grid using the so-called amoeboid movement. In each
step of such a movement, her body first shrinks by one pixel (one pixel of the
body is removed and becomes free), and then grows at a different place (one
previously-free pixel is added to the body).

To prevent structural damage, Amanda's body always occupies a connected region
of pixels, which means that any pair of pixels forming the body can be
connected by a sequence of adjacent pixels without ever leaving the body. Two
pixels are considered adjacent if they share a common side (each pixel has at
most 4 neighbours). The body remains connected even during the movement,
including the moment after removing a pixel and before adding another one.

Your task is to help Amanda find her way around. Given her initial position
and desired final position, suggest a sequence of valid moves leading from the
former to the latter.

![](https://espresso.codeforces.com/8d732857e67e5cd7cb6a0af1ed34584572413ddc.png)
Illustration of sample 1 : The filled shape is the initial position, the
dotted region is the final position.

Input

The first line contains two integers r and c (1\le r,c \le 50 ) — the size of
the rectangular grid in pixels.

The next r lines contain c characters each, describing the initial position of
Amanda. Each of those characters is either a dot \texttt{.} denoting a free
pixel, an asterisk \texttt{*} denoting Amanda's body, or an \texttt{X}
denoting a blocked pixel which may never be occupied.

The next line is empty.

The next r lines describe the desired final position in the same format as the
initial position.

It is guaranteed that:

  * The number of pixels forming Amanda's body is the same in both positions, and it is at least 2. 
  * The body of Amanda is connected in the initial position. 
  * The body of Amanda is connected in the final position. 
  * The blocked pixels do not change between the descriptions of the initial and final position, their placement is exactly the same in both positions. 

Output

Print \texttt{YES} if it is possible for Amanda to go from the initial
position to the final one. Otherwise, print \texttt{NO} .

If it is possible, on the next line print one integer m (0\le m\le 10\,000 ) —
the number of moves to execute.

The following m lines must contain four integer coordinates each: i_1 , j_1 ,
i_2 , j_2 (1\le i_1,i_2\le r , 1\le j_1,j_2\le c ). These four coordinates
specify one move, meaning that the pixel at i_1 -th row and j_1 -th column is
first removed from the body. Then, (i_2,j_2) must designate a different
location where one pixel is added.

The sequence should consist only of valid moves and after the last move,
Amanda's body should occupy the desired final position.

If there are multiple solutions, print any of them.

Under the assumptions of this problem, it can be proven that if it is possible
for Amanda to go from the initial position to the desired final one, then it
is possible to do it with at most 10\,000 moves.

Examples

Input

    5 8
    
    .******.
    
    **.X**..
    
    *******.
    
    **.X**..
    
    .******.
    
    .******.
    
    ...X****
    
    .*******
    
    ...X****
    
    .******.

Output

    YES
    5
    3 1 3 8
    2 1 2 8
    4 1 4 8
    2 2 4 7
    4 2 2 7
    
Input

    2 5
    
    *.X..
    
    **X..
    
    ..X**
    
    ..X*.

Output

    NO
    
Note

In the first sample, Amanda executes 5 moves to reach the final position, as
shown in the figure below.

![](https://espresso.codeforces.com/04b7bb193a243e0eaf83952861f5275e04543407.png)

- Program:
from collections import deque
#Function 1:
def func_1(grid, r, c, visited, i1, j1, i2, j2):
    if i2 < 0 or i2 >= r or j2 < 0 or (j2 >= c):
        return False
    if grid[i2][j2] == '*' or visited[i2][j2]:
        return False
    connected_pixels = 0
    for (di, dj) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        (ni, nj) = (i2 + di, j2 + dj)
        if 0 <= ni < r and 0 <= nj < c and (grid[ni][nj] == '*'):
            connected_pixels += 1
    if connected_pixels < 2:
        return False
    return True

#Function 2:
def func_2(grid, r, c, initial_position, final_position):
    visited = [[False] * c for _ in range(r)]
    q = deque()
    q.append(initial_position)
    visited[initial_position[0]][initial_position[1]] = True
    parent = {}
    while q:
        current_position = q.popleft()
        if current_position == final_position:
            break
        (i, j) = current_position
        for (di, dj) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            (ni, nj) = (i + di, j + dj)
            if func_1(grid, r, c, visited, i, j, ni, nj):
                visited[ni][nj] = True
                q.append((ni, nj))
                parent[ni, nj] = (i, j)
    if final_position not in parent:
        return None
    moves = []
    current_position = final_position
    while current_position != initial_position:
        parent_position = parent[current_position]
        moves.append((parent_position[0] + 1, parent_position[1] + 1, current_position[0] + 1, current_position[1] + 1))
        current_position = parent_position
    moves.reverse()
    return moves

#Function 3:
def func_3():
    (r, c) = map(int, input().split())
    initial_grid = [input() for _ in range(r)]
    input()
    final_grid = [input() for _ in range(r)]
    initial_position = None
    final_position = None
    for i in range(r):
        for j in range(c):
            if initial_grid[i][j] == '*':
                initial_position = (i, j)
            if final_grid[i][j] == '*':
                final_position = (i, j)
    moves = func_2(initial_grid, r, c, initial_position, final_position)
    if moves:
        print('YES')
        print(len(moves))
        for move in moves:
            print(*move)
    else:
        print('NO')



- Function Summary: 
Output hints for function number 3 : The function reads the dimensions and contents of two grids (initial_grid and final_grid) from standard input, identifies the starting and ending positions of Amanda within these grids, calls another function (func_2) to determine a sequence of moves that transform initial_grid into final_grid, and prints "YES" followed by the number of moves and the moves themselves if such a sequence exists, otherwise it prints "NO". The function does not return anything. Potential edge cases include scenarios where Amanda's starting and ending positions do not exist in either grid, or when the input grids are empty. Additionally, if func_2 does not return a valid sequence of moves, the function will incorrectly print "NO" without any further information.+


Beggining of Original Assessment: 
Reasoning:

1. **Understanding the Problem and Requirements:**
   - The problem requires checking if Amanda (an amoeba) can move from its initial position to its final position on a grid while maintaining connectivity of its body and adhering to the constraints provided.
   - The solution involves two primary functions: `func_1` and `func_2`. Additionally, `func_3` handles input/output and calls the other functions.

2. **Analysis of `func_1`:**
   - This function checks if a pixel at `(i2, j2)` can be added to the body. It ensures that the pixel is within bounds, not blocked, and that it is adjacent to at least two other pixels already in the body.
   - The logic is correct because it verifies the conditions necessary for a valid addition of a pixel to the body while maintaining connectivity.

3. **Analysis of `func_2`:**
   - This function uses Breadth-First Search (BFS) to find a path from the initial position to the final position.
   - It marks visited pixels and uses a dictionary (`parent`) to keep track of the path taken.
   - The logic is sound, but we need to ensure that the BFS respects the movement rules (shrinking and growing correctly).
   - The function constructs the moves in reverse order, which is correct for backtracking from the final position to the initial position.

4. **Analysis of `func_3`:**
   - This function reads the grid dimensions and the initial and final positions from the input.
   - It initializes the grids and finds the starting and ending positions.
   - It calls `func_2` to get the moves and prints the result accordingly.
   - The function correctly handles the output format as specified.

5. **Overall Correctness:**
   - The program follows the problem's requirements and constraints.
   - The BFS approach in `func_2` ensures that the path is found if it exists.
   - The checks in `func_1` ensure that each move maintains the required connectivity.

Based on the above analysis, the program appears to be correct and meets all the specified requirements.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

