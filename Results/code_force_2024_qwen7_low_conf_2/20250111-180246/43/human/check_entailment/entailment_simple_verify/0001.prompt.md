
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)

- Program: 
def func():
    for _ in range(int(input())):
        n = int(input())
        fa = [-1] + list(map(int, input().split()))
        S = input()
        (dp1, dp2) = ([0] * (n + 1), [0] * (n + 1))
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        print(min(dp1[0], dp2[0]))



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 1000. For each test case, n is an integer such that 2 ≤ n ≤ 10^5, a list a contains n-1 integers such that 1 ≤ a_i < i, indicating the edges of the tree, and s is a string of length n consisting of characters 'P', 'S', and 'C', indicating the type of each student. The sum of n over all test cases does not exceed 10^5.
def func():
    for _ in range(int(input())):
        n = int(input())
        
        fa = [-1] + list(map(int, input().split()))
        
        S = input()
        
        dp1, dp2 = [0] * (n + 1), [0] * (n + 1)
        
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        
        print(min(dp1[0], dp2[0]))
        
    #State of the program after the  for loop has been executed: `t` is an integer within the range \(1 \leq t \leq 1000\), `n` is the number of nodes in the tree, `fa` is the list where `fa[i]` is the parent of node `i+1`, `S` is the string indicating the type of each student, `dp1` and `dp2` are lists of length `n + 1` where `dp1[i]` and `dp2[i]` represent the minimum costs to reach the end of the string `S` under certain conditions starting from node `i+1`, and the minimum value between `dp1[0]` and `dp2[0]` is printed.



Beggining of Original Assessment: 
Reasoning:

To verify the correctness of the provided solution, let's break down the logic of the code and compare it with the problem statement.

### Problem Understanding:
- The task involves a tree structure where each node represents a student.
- Students are classified into three categories: 'P' (partying), 'S' (sleeping), and 'C' (neutral).
- The goal is to install the minimum number of thick walls such that:
  - Partying students can play music without disturbing sleeping students.
  - No sleeping student can hear the music.

### Code Analysis:
1. **Input Handling:**
   - `n` is the number of nodes.
   - `fa` array stores the parent of each node (using 1-based indexing).
   - `S` is the string representing the type of each student.

2. **Dynamic Programming Setup:**
   - `dp1[i]`: Minimum walls required to block music from reaching a sleeping student starting from node `i`.
   - `dp2[i]`: Minimum walls required to block music from reaching a parting student starting from node `i`.

3. **Bottom-Up DP Calculation:**
   - Iterate from leaf nodes to root (topological order).
   - For each node `i`, if it is a sleeping student (`S`), set `dp1[i]` to infinity because music must be blocked.
   - If it is a parting student (`P`), set `dp2[i]` to infinity for the same reason.
   - Propagate values up the tree:
     - `dp1[p] += min(dp1[i], dp2[i] + 1)`: Add a wall if necessary to prevent music from reaching a sleeping student from a child.
     - `dp2[p] += min(dp1[i] + 1, dp2[i])`: Propagate the cost of blocking music for a parting student, adding a wall if necessary.

4. **Result Calculation:**
   - Print the minimum value between `dp1[0]` and `dp2[0]` for the entire tree.

### Validation:
1. **Correct Handling of Students:**
   - The logic correctly identifies and blocks music for sleeping students (`S`).
   - It also ensures parting students (`P`) can play music without disturbing sleeping students.

2. **Dynamic Programming Logic:**
   - The bottom-up approach ensures the minimum number of walls is calculated by propagating costs and choosing the optimal path.

3. **Edge Cases:**
   - Handles multiple test cases efficiently.
   - Properly manages the tree structure using parent pointers.

### Conclusion:
Given the analysis, the provided solution appears to correctly implement the logic to solve the problem as described.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

