
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)

- Program:
def func():
    for _ in range(int(input())):
        n = int(input())
        fa = [-1] + list(map(int, input().split()))
        S = input()
        (dp1, dp2) = ([0] * (n + 1), [0] * (n + 1))
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        print(min(dp1[0], dp2[0]))



- Function Summary: 
- The function correctly handles the range constraints for the number of test cases (`1 ≤ t ≤ 1000`) and the number of nodes (`2 ≤ n ≤ 10^5`).
- However, the function assumes that the input format is always correct and does not include error handling for invalid inputs (e.g., non-integer values, incorrect lengths of `fa` or `S`).

The function performs the following actions:
- Reads the number of test cases.
- For each test case, it reads the number of nodes, constructs the parent relationship list `fa`, and reads the string `S`.
- It initializes two dynamic programming arrays `dp1` and `dp2` to store the minimum costs.
- It iterates backward through the nodes, updating the `dp1` and `dp2` arrays based on the type of each student in the string `S`.
- It prints the minimum value between `dp1[0]` and `dp2[0]`, which represents the minimum cost to reach the end of the string `S` under the specified conditions.

Beggining of Original Assessment: 
Reasoning:

To verify the correctness of the provided solution, let's break down the logic of the code and compare it with the problem statement.

### Problem Understanding:
- The task involves a tree structure where each node represents a student.
- Students are classified into three categories: 'P' (partying), 'S' (sleeping), and 'C' (neutral).
- The goal is to install the minimum number of thick walls such that:
  - Partying students can play music without disturbing sleeping students.
  - No sleeping student can hear the music.

### Code Analysis:
1. **Input Handling:**
   - `n` is the number of nodes.
   - `fa` array stores the parent of each node (using 1-based indexing).
   - `S` is the string representing the type of each student.

2. **Dynamic Programming Setup:**
   - `dp1[i]`: Minimum walls required to block music from reaching a sleeping student starting from node `i`.
   - `dp2[i]`: Minimum walls required to block music from reaching a parting student starting from node `i`.

3. **Bottom-Up DP Calculation:**
   - Iterate from leaf nodes to root (topological order).
   - For each node `i`, if it is a sleeping student (`S`), set `dp1[i]` to infinity because music must be blocked.
   - If it is a parting student (`P`), set `dp2[i]` to infinity for the same reason.
   - Propagate values up the tree:
     - `dp1[p] += min(dp1[i], dp2[i] + 1)`: Add a wall if necessary to prevent music from reaching a sleeping student from a child.
     - `dp2[p] += min(dp1[i] + 1, dp2[i])`: Propagate the cost of blocking music for a parting student, adding a wall if necessary.

4. **Result Calculation:**
   - Print the minimum value between `dp1[0]` and `dp2[0]` for the entire tree.

### Validation:
1. **Correct Handling of Students:**
   - The logic correctly identifies and blocks music for sleeping students (`S`).
   - It also ensures parting students (`P`) can play music without disturbing sleeping students.

2. **Dynamic Programming Logic:**
   - The bottom-up approach ensures the minimum number of walls is calculated by propagating costs and choosing the optimal path.

3. **Edge Cases:**
   - Handles multiple test cases efficiently.
   - Properly manages the tree structure using parent pointers.

### Conclusion:
Given the analysis, the provided solution appears to correctly implement the logic to solve the problem as described.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

