
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.

- Program: 
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
    return mex



- Annotated Code: 
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

#State of the program right berfore the function call: arr is a list of integers where each element is in the range [0, n-1] for some integer n (2 ≤ n ≤ 10^5), and the length of the list is n. There can be at most 10^4 test cases, and the sum of lengths of all lists does not exceed 10^5.
def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
        
    #State of the program after the loop has been executed: `arr` is a list of integers where each element is in the range [0, n-1]; `num_set` is a set containing unique elements from `arr` and contains all integers from 0 to `mex-1`; `mex` is the smallest non-negative integer not in `num_set`
    return mex
    #The program returns the smallest non-negative integer not in set 'num_set'
#Overall this is what the function does:The function `func_1` accepts a list `arr` consisting of integers within the range [0, n-1], where `n` is the length of the list (2 ≤ n ≤ 10^5). It first creates a set `num_set` containing the unique elements from `arr`. Then, it iterates to find the smallest non-negative integer that is not present in `num_set`. The function returns this integer, which represents the smallest non-negative integer not found in the set of elements from `arr`.

Potential edge cases and missing functionality:
- If all integers from 0 to n-1 are present in `arr`, the function correctly identifies `n` as the smallest non-negative integer not in `num_set`.
- If `arr` contains duplicate elements, the function still correctly identifies the smallest non-negative integer not present in the unique set.
- The function handles the case where the smallest non-negative integer not present is greater than the length of the list, returning a value greater than n-1.
- The function ensures that the returned value is within the range of non-negative integers starting from 0.

After the function concludes, the state of the program includes the original list `arr` and the returned value, which is the smallest non-negative integer not present in the set `num_set`.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly handle all potential cases. Specifically, the program fails to handle cases where the MEX value is not a valid element in the array. Here’s a detailed analysis:

1. **MEX Calculation**: The `func_1` function calculates the MEX value correctly.
2. **Segment Construction**: The program attempts to construct segments such that each segment has the calculated MEX value. However, it fails to handle cases where the MEX value is not present in the array after the first occurrence.

Consider the following input:
```
3
5
0 1 2 3 4
3
0 1 2
4
0 1 2 0
```

- **First Test Case**: The array `[0, 1, 2, 3, 4]` has a MEX value of 5. The program will not correctly handle this case since it expects the MEX value to be within the array bounds.
- **Second Test Case**: The array `[0, 1, 2]` has a MEX value of 3. The program constructs the segments correctly: `[0, 1, 2]` which has a MEX of 3.
- **Third Test Case**: The array `[0, 1, 2, 0]` has a MEX value of 3. The program constructs the segments incorrectly: it might not correctly split the array into segments with the desired MEX values.

The program does not account for cases where the MEX value is not present in the array after the first occurrence, leading to incorrect segmentations. Therefore, the program is not correct for all potential cases.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

