
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.

# Annotated Program:
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

#State of the program right berfore the function call: arr is a list of integers where each element is in the range [0, n-1] for some integer n (2 ≤ n ≤ 10^5), and the length of the list is n. There can be at most 10^4 test cases, and the sum of lengths of all lists does not exceed 10^5.
def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
        
    #State of the program after the loop has been executed: `arr` is a list of integers where each element is in the range [0, n-1]; `num_set` is a set containing unique elements from `arr` and contains all integers from 0 to `mex-1`; `mex` is the smallest non-negative integer not in `num_set`
    return mex
    #The program returns the smallest non-negative integer not in set 'num_set'
#Overall this is what the function does:The function `func_1` accepts a list `arr` consisting of integers within the range [0, n-1], where `n` is the length of the list (2 ≤ n ≤ 10^5). It first creates a set `num_set` containing the unique elements from `arr`. Then, it iterates to find the smallest non-negative integer that is not present in `num_set`. The function returns this integer, which represents the smallest non-negative integer not found in the set of elements from `arr`.

Potential edge cases and missing functionality:
- If all integers from 0 to n-1 are present in `arr`, the function correctly identifies `n` as the smallest non-negative integer not in `num_set`.
- If `arr` contains duplicate elements, the function still correctly identifies the smallest non-negative integer not present in the unique set.
- The function handles the case where the smallest non-negative integer not present is greater than the length of the list, returning a value greater than n-1.
- The function ensures that the returned value is within the range of non-negative integers starting from 0.

After the function concludes, the state of the program includes the original list `arr` and the returned value, which is the smallest non-negative integer not present in the set `num_set`.

# Your response:
Reasoning:  
Correctness: **True** or **False**

