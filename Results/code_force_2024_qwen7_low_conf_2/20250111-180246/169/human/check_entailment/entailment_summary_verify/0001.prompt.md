
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.

- Program:
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
    return mex



- Function Summary: 
The function `func_1` accepts a list `arr` consisting of integers within the range [0, n-1], where `n` is the length of the list (2 ≤ n ≤ 10^5). It first creates a set `num_set` containing the unique elements from `arr`. Then, it iterates to find the smallest non-negative integer that is not present in `num_set`. The function returns this integer, which represents the smallest non-negative integer not found in the set of elements from `arr`.

Potential edge cases and missing functionality:
- If all integers from 0 to n-1 are present in `arr`, the function correctly identifies `n` as the smallest non-negative integer not in `num_set`.
- If `arr` contains duplicate elements, the function still correctly identifies the smallest non-negative integer not present in the unique set.
- The function handles the case where the smallest non-negative integer not present is greater than the length of the list, returning a value greater than n-1.
- The function ensures that the returned value is within the range of non-negative integers starting from 0.

After the function concludes, the state of the program includes the original list `arr` and the returned value, which is the smallest non-negative integer not present in the set `num_set`.

Beggining of Original Assessment: 
Reasoning:

1. **Understanding the Problem**: We need to divide the array into `k` subsegments such that the MEX (Minimum Excludant) for each subsegment is the same integer.

2. **Key Observations**:
   - The MEX of an array is the smallest non-negative integer not present in the array.
   - The program uses a function `func_1` to compute the MEX of the array.
   - The main logic of the program attempts to find subsegments where the MEX matches the computed MEX.

3. **Key Steps in the Program**:
   - Compute the MEX of the entire array using `func_1`.
   - If the MEX is 0, directly split the array into two subsegments `[1, 1]` and `[2, n]` since the MEX for both will be 0.
   - Otherwise, iterate through the array to identify subsegments where the count of numbers from 0 to MEX-1 equals MEX. Each such subsegment is identified and stored.
   - If the last subsegment contains any number from 0 to MEX-1, merge it with the previous subsegment.
   - Finally, check if at least two subsegments were found. If so, print the number of subsegments and their boundaries; otherwise, print `-1`.

4. **Verification**:
   - The logic correctly identifies subsegments where the MEX matches the required value.
   - It handles the special case where the MEX is 0 separately.
   - The merging of the last subsegment is done correctly.
   - The conditions for printing `-1` when less than two subsegments are found are met.

Based on the above analysis, the provided program correctly implements the solution to the problem statement.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

