
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.

- Program: 
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(func_1(n, s))
print('\n'.join(results))

def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
    if count_north != count_south or count_east != count_west:
        return 'NO'
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
    return ''.join(result)



- Annotated Code: 
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(func_1(n, s))
print('\n'.join(results))

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 \cdot 10^5, and s is a string consisting of the characters 'N', 'S', 'E', 'W' with length n.
def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 ≤ `n` ≤ 2⋅10^5, `s` is a string consisting of the characters 'N', 'S', 'E', 'W' with length `n`, `count_north` is the total number of 'N' in `s`, `count_south` is the total number of 'S' in `s`, `count_east` is the total number of 'E' in `s`, `count_west` is the total number of 'W' in `s`
    if (count_north != count_south or count_east != count_west) :
        return 'NO'
        #The program returns 'NO'
    #State of the program after the if block has been executed: `n` is an integer such that 1 ≤ `n` ≤ 2⋅10^5, `s` is a string consisting of the characters 'N', 'S', 'E', 'W' with length `n`, `count_north` is the total number of 'N' in `s`, `count_south` is the total number of 'S' in `s`, `count_east` is the total number of 'E' in `s`, `count_west` is the total number of 'W' in `s`. `count_north` equals `count_south` and `count_east` equals `count_west`
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
        
    #State of the program after the loop has been executed: `n` is an integer such that \(1 \leq n \leq 2 \times 10^5\), `s` is a string consisting of the characters 'N', 'S', 'E', 'W' with length `n`, `count_north` and `count_south` are equal (since the loop ensures that the counts of 'N' and 'S' are balanced and `count_north` was initially equal to `count_south`), `count_east` and `count_west` are equal (since the loop ensures that the counts of 'E' and 'W' are balanced and `count_east` was initially equal to `count_west`), `result` is a list containing 'H', 'R', or a combination of these based on the value of `s[i]` throughout the loop, `i` is `len(s)` (indicating the loop has fully processed the string `s`), and `s[i]` does not exist (since `i` is out of bounds).
    return ''.join(result)
    #The program returns a string composed of 'H', 'R', or both based on the values of 'N', 'S', 'E', 'W' in the string 's', considering that the counts of 'N' and 'S' are balanced and the counts of 'E' and 'W' are balanced



Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not handle all potential cases correctly. Specifically, the program does not ensure that both the rover and the helicopter execute at least one instruction. This is a requirement stated in the problem description.

To illustrate this, consider the following input:
```
1
2
SN
```

According to the problem description, each device must execute at least one instruction. However, the current implementation only checks if the number of north-south moves and east-west moves are equal, but it does not guarantee that both devices execute at least one instruction. In the above example, the program would return "NO" because the count of north-south moves and east-west moves are equal, but it fails to check the condition that both devices must execute at least one instruction.

A correct implementation would need to include additional logic to ensure that both devices execute at least one instruction, such as adding checks before returning "NO" or handling special cases where one device might need to execute an extra instruction.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

