
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.

# Annotated Functions:
import math

if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: fountain is a tuple containing two positive integers (r, c) representing the row and column coordinates of a fountain on the field, n and m are positive integers representing the dimensions of the field (2 ≤ n, m ≤ 10^9).
def func_1(fountain, n, m):
    r, c = fountain
    diagonal_distance = abs(r + c - (n + 1))
    return max(diagonal_distance // 2, 0)
    #`The program returns max(abs(r + c - (n + 1)) // 2, 0)`
#Overall this is what the function does:The function `func_1` accepts a tuple `fountain` containing the row and column coordinates of a fountain on a field, along with two integers `n` and `m` representing the dimensions of the field. It calculates the value of `max(abs(r + c - (n + 1)) // 2, 0)`, where `r` and `c` are the row and column coordinates from the `fountain` tuple, and returns this value. This calculation effectively computes the maximum distance from the fountain to the "middle" diagonal of the field (which is defined as the line from (1, n) to (m, 1)), adjusted by half a step, ensuring the result is non-negative. Potential edge cases include when the fountain is on the exact middle diagonal, resulting in a distance of 0, and when the coordinates are such that the absolute difference `abs(r + c - (n + 1))` is zero or negative, which the `max` function handles appropriately.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases. For each test case, n and m are positive integers such that \(2 \leq n, m \leq 10^9\), and k is a positive integer such that \(2 \leq k \leq 2 \cdot 10^5\). The coordinates of the fountains (r_i, c_i) are pairs of positive integers such that \(1 \leq r_i \leq n\) and \(1 \leq c_i \leq m\), and all fountain coordinates are distinct and none of them is equal to (n, 1).
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        m = int(data[index + 1])
        
        k = int(data[index + 2])
        
        index += 3
        
        alpha = (n * m + 1) // 2
        
        additional_areas = []
        
        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            additional_areas.append(func_1((r, c), n, m))
        
        results.append((alpha, additional_areas))
        
    #State of the program after the  for loop has been executed: `t` is the initial value of `t`, `results` is a list of tuples `(alpha, additional_areas)` where for each tuple: `alpha` is \((n * m + 1) // 2\) with `n` being the integer value of `data[index - 6]` and `m` being the integer value of `data[index - 5]`, and `additional_areas` is a list containing the results of applying `func_1((r, c), n, m)` for each pair `(r, c)` with `r` being the integer value of `data[index - 4 - 2 * j]` and `c` being the integer value of `data[index - 3 - 2 * j]` for `j` in the range of the length of `additional_areas`. `index` is the final value after all iterations of the loop.
    for result in results:
        alpha, additional_areas = result
        
        print(alpha)
        
        print(' '.join(map(str, additional_areas)))
        
    #State of the program after the  for loop has been executed: `results` is a non-empty list; each tuple in `results` is of the form (`alpha`, `additional_areas`); for each tuple in `results`, `alpha` is printed and the elements of `additional_areas` are printed, each on a new line.
#Overall this is what the function does:The function processes multiple test cases. For each test case, it reads in the dimensions \(n\) and \(m\) of a grid, the number of fountains \(k\), and the coordinates of each fountain. It then calculates a value \(\alpha\) defined as \((n \times m + 1) // 2\). For each fountain, it calls another function `func_1` to compute an additional area related to the fountain's position. The results are stored in a list of tuples, where each tuple contains the value \(\alpha\) and a list of the computed additional areas. Finally, the function prints \(\alpha\) and the computed additional areas for each test case.




# Your response:
Reasoning:  
Correctness: **True** or **False**

