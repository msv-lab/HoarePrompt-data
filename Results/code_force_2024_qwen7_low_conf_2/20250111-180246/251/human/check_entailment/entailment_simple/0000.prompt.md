
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There is a rectangular sheet of paper with initial height n and width m . Let
the current height and width be h and w respectively. We introduce a xy
-coordinate system so that the four corners of the sheet are (0, 0), (w, 0),
(0, h) , and (w, h) . The sheet can then be cut along the lines x =
1,2,\ldots,w-1 and the lines y = 1,2,\ldots,h-1 . In each step, the paper is
cut randomly along any one of these h+w-2 lines. After each vertical and
horizontal cut, the right and bottom piece of paper respectively are
discarded.

Find the expected number of steps required to make the area of the sheet of
paper strictly less than k . It can be shown that this answer can always be
expressed as a fraction \dfrac{p}{q} where p and q are coprime integers.
Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 57000 ). Description of the test cases follows.

The first line of each test case contains 3 integers n , m , and k (1 \le n, m
\le 10^6 , 2 \le k \le 10^{12} ).

It is guaranteed that the sum of n and the sum of m over all test cases do not
exceed 10^6 .

Output

For each test case, print one integer â€” the answer to the problem.

Example

Input

    4
    
    2 4 10
    
    2 4 8
    
    2 4 2
    
    2 4 6

Output

    0
    1
    833333342
    250000003
    
Note

For the first test case, the area is already less than 10 so no cuts are
required.

For the second test case, the area is exactly 8 so any one of the 4 possible
cuts would make the area strictly less than 8 .

For the third test case, the final answer is \frac{17}{6} = 833\,333\,342\bmod
(10^9+7) .

For the fourth test case, the final answer is \frac{5}{4} = 250\,000\,003\bmod
(10^9+7) .
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases; for each test case, n and m are positive integers such that 1 <= n, m <= 10^6, and k is a positive integer such that 2 <= k <= 10^12; the sum of all n and the sum of all m do not exceed 10^6; and all inputs are integers.
def func_1():
    input = sys.stdin.read
    data = input().split()
    MOD = 1000000007
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        
        m = int(data[idx + 1])
        
        k = int(data[idx + 2])
        
        idx += 3
        
        low, high = 0, max(n, m) * 20
        
        answer = high
        
        while low <= high:
            mid = (low + high) // 2
            if func_2(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        
        p = answer
        
        q = 1
        
        q_inv = pow(q, MOD - 2, MOD)
        
        result = p * q_inv % MOD
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `data` is a list of strings with at least `3 * t` elements, `idx` is `3 * t + 3`, `low` is 0, `high` is 0, `answer` is the smallest value such that `func_2(n, m, k, answer)` is true for each triplet of inputs, `mid` is the last calculated midpoint, `p` is equal to `answer`, `q` is 1, `q_inv` is 1, `results` is a list containing `t` elements, each being `answer % MOD`
    for res in results:
        print(res)
        
    #State of the program after the  for loop has been executed: `results` is a list containing `t` elements, each being `answer % MOD`.

#Function 2:
#State of the program right berfore the function call: n and m are positive integers representing the initial height and width of the paper, k is a positive integer representing the threshold area, and steps is a non-negative integer representing the number of cutting steps taken.
def func_2(n, m, k, steps):
    h, w = n, m
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        
        if h * w < k:
            return True
        
    #State of the program after the  for loop has been executed: `h` and `w` are integers. `h` is the result of applying the operation `max(value // 2, 1)` repeatedly starting from `n` for each iteration where `h > w`, and `w` is the result of applying the same operation starting from `m` for each iteration where `w >= h`. `k` is a positive integer representing the threshold area, and `steps` is the total number of iterations the loop executed. If after all iterations `h * w >= k`, the function does not return, otherwise it returns True.
    return h * w < k
    #`The program returns True if h * w is less than k, otherwise it does not return


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
