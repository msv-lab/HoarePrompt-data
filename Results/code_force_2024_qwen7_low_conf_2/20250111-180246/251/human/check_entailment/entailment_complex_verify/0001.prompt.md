
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There is a rectangular sheet of paper with initial height n and width m . Let
the current height and width be h and w respectively. We introduce a xy
-coordinate system so that the four corners of the sheet are (0, 0), (w, 0),
(0, h) , and (w, h) . The sheet can then be cut along the lines x =
1,2,\ldots,w-1 and the lines y = 1,2,\ldots,h-1 . In each step, the paper is
cut randomly along any one of these h+w-2 lines. After each vertical and
horizontal cut, the right and bottom piece of paper respectively are
discarded.

Find the expected number of steps required to make the area of the sheet of
paper strictly less than k . It can be shown that this answer can always be
expressed as a fraction \dfrac{p}{q} where p and q are coprime integers.
Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 57000 ). Description of the test cases follows.

The first line of each test case contains 3 integers n , m , and k (1 \le n, m
\le 10^6 , 2 \le k \le 10^{12} ).

It is guaranteed that the sum of n and the sum of m over all test cases do not
exceed 10^6 .

Output

For each test case, print one integer — the answer to the problem.

Example

Input

    4
    
    2 4 10
    
    2 4 8
    
    2 4 2
    
    2 4 6

Output

    0
    1
    833333342
    250000003
    
Note

For the first test case, the area is already less than 10 so no cuts are
required.

For the second test case, the area is exactly 8 so any one of the 4 possible
cuts would make the area strictly less than 8 .

For the third test case, the final answer is \frac{17}{6} = 833\,333\,342\bmod
(10^9+7) .

For the fourth test case, the final answer is \frac{5}{4} = 250\,000\,003\bmod
(10^9+7) .

- Program: 

#Function 1:
def func_1():
    import sys
    input = sys.stdin.read
    data = input().split()
    MOD = 1000000007
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        m = int(data[idx + 1])
        k = int(data[idx + 2])
        idx += 3
        (low, high) = (0, max(n, m) * 20)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            if func_2(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        p = answer
        q = 1
        q_inv = pow(q, MOD - 2, MOD)
        result = p * q_inv % MOD
        results.append(result)
    for res in results:
        print(res)

#Function 2:
def func_2(n, m, k, steps):
    import math
    (h, w) = (n, m)
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        if h * w < k:
            return True
    return h * w < k



- Annotated Code: 
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases; for each test case, n and m are positive integers such that 1 <= n, m <= 10^6, and k is a positive integer such that 2 <= k <= 10^12; the sum of all n and the sum of all m do not exceed 10^6; and all inputs are integers.
def func_1():
    input = sys.stdin.read
    data = input().split()
    MOD = 1000000007
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        
        m = int(data[idx + 1])
        
        k = int(data[idx + 2])
        
        idx += 3
        
        low, high = 0, max(n, m) * 20
        
        answer = high
        
        while low <= high:
            mid = (low + high) // 2
            if func_2(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        
        p = answer
        
        q = 1
        
        q_inv = pow(q, MOD - 2, MOD)
        
        result = p * q_inv % MOD
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `data` is a list of strings with at least `3 * t` elements, `idx` is `3 * t + 3`, `low` is 0, `high` is 0, `answer` is the smallest value such that `func_2(n, m, k, answer)` is true for each triplet of inputs, `mid` is the last calculated midpoint, `p` is equal to `answer`, `q` is 1, `q_inv` is 1, `results` is a list containing `t` elements, each being `answer % MOD`
    for res in results:
        print(res)
        
    #State of the program after the  for loop has been executed: `results` is a list containing `t` elements, each being `answer % MOD`.
#Overall this is what the function does:The function processes a series of test cases. Each test case consists of three integers \(n\), \(m\), and \(k\). It uses a binary search approach to find the smallest integer \(p\) such that a certain condition defined in `func_2(n, m, k, p)` is met. After determining \(p\), it calculates \(q\) as 1 and \(q^{-1}\) modulo \(10^9 + 7\). Finally, it computes \(p \times q^{-1} \mod 10^9 + 7\) and stores these results in a list. The function then prints each result. If the sum of all \(n\) and \(m\) across all test cases exceeds \(10^6\), the function would encounter an error due to an unhandled condition in the given code.

#Function 2:
#State of the program right berfore the function call: n and m are positive integers representing the initial height and width of the paper, k is a positive integer representing the threshold area, and steps is a non-negative integer representing the number of cutting steps taken.
def func_2(n, m, k, steps):
    h, w = n, m
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        
        if h * w < k:
            return True
        
    #State of the program after the  for loop has been executed: `h` and `w` are integers. `h` is the result of applying the operation `max(value // 2, 1)` repeatedly starting from `n` for each iteration where `h > w`, and `w` is the result of applying the same operation starting from `m` for each iteration where `w >= h`. `k` is a positive integer representing the threshold area, and `steps` is the total number of iterations the loop executed. If after all iterations `h * w >= k`, the function does not return, otherwise it returns True.
    return h * w < k
    #`The program returns True if h * w is less than k, otherwise it does not return
#Overall this is what the function does:The function `func_2` accepts four parameters: `n`, `m`, `k`, and `steps`. 

- `n` and `m` represent the initial height and width of the paper, respectively.
- `k` represents the threshold area.
- `steps` represents the number of cutting steps taken.

The function repeatedly divides the larger dimension (either height `h` or width `w`) by 2 until either dimension is reduced to 1, ensuring that both dimensions are halved in each step unless one dimension is already smaller than or equal to the other. After `steps` iterations, the function checks if the product of the final height `h` and width `w` is less than the threshold area `k`. If it is, the function returns `True`; otherwise, it does not return anything, implying the function returns `False`.

Potential edge cases and missing functionality:
- If `n` or `m` is initially 1, the function will not perform any divisions and will directly check if `1 * 1 < k`. If `k` is greater than or equal to 1, the function will return `False` immediately without performing any iterations.
- The function does not handle the case where `steps` is 0. In such a scenario, the function should return `False` because no cuts have been made, and the original dimensions `n` and `m` would be checked against `k`.

In summary, the function returns `True` if the final area after `steps` cuts is less than `k`, and it returns `False` otherwise.




Beggining of Original Assessment: 
Reasoning:
1. **Input Handling**: The `func_1` function correctly reads the input using `sys.stdin.read` and processes it in a way that allows handling multiple test cases efficiently.
2. **Binary Search Implementation**: The `func_1` function uses a binary search approach to find the minimum number of steps required to make the area of the paper strictly less than `k`. This is done through the call to `func_2`.
3. **Area Calculation in `func_2`**: The `func_2` function simulates cutting the paper by repeatedly halving the larger dimension until the area is less than `k`. This logic appears to be correct for determining if the area can be reduced below `k` within a certain number of steps.
4. **Result Calculation**: The result is calculated using modular arithmetic to ensure the answer fits within the specified constraints. Specifically, `p * q_inv % MOD` computes the required value correctly under the condition that `p` and `q` are coprime.
5. **Modular Inverse**: The use of `pow(q, MOD - 2, MOD)` to calculate the modular inverse of `q` is correct and ensures the final result is computed modulo \(10^9 + 7\).

Given the logical flow and the correctness of the operations, the provided program seems to accurately solve the problem as described.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

