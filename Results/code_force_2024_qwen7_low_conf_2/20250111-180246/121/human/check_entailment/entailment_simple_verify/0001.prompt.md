
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either "first" or "second",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print "0 0" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
"-1 -1" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints "-1 -1", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.

- Program: 
def func():
    for _ in range(int(input())):
        n = int(input())
        if bin(n).count('1') & 1:
            print('second')
        else:
            print('first')
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)
        while True:
            (a, b) = map(int, input().split())
            if a == b:
                break
            n = b if bin(a).count('1') & 1 else a
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 1000, and for each test case, n is an integer such that 1 ≤ n ≤ 10^18.
def func():
    for _ in range(int(input())):
        n = int(input())
        
        if bin(n).count('1') & 1:
            print('second')
        else:
            print('first')
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)
        
        while True:
            a, b = map(int, input().split())
            if a == b:
                break
            n = b if bin(a).count('1') & 1 else a
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)
        
    #State of the program after the  for loop has been executed: `a` and `b` are equal, `n` is the last value assigned to `b` if the count of '1's in the binary representation of `a` is odd, else `n` is the last value assigned to `a`, `l` is the integer value of the binary representation of `n` starting from the third character.



Beggining of Original Assessment: 
Reasoning:

1. **Understanding the Problem**: The problem involves a game where Alice and Bob take turns breaking a number `n` into two numbers `p1` and `p2` such that `p1 ⊕ p2 = p`. The goal is to force the opponent to be unable to make a valid move within 63 moves.

2. **Game Strategy**:
   - **Alice's Strategy**: The key observation here is that if the number `n` has an odd number of 1s in its binary representation, Alice can always win by going second. This is because she can always mirror Bob's moves, ensuring that the parity of the number of 1s remains odd.
   - **Bob's Strategy**: If the number of 1s in the binary representation of `n` is even, Bob can force Alice to lose by always responding in a way that maintains the even parity of the number of 1s.

3. **Implementation**:
   - The function correctly identifies whether the number of 1s in the binary representation of `n` is odd or even using `bin(n).count('1') & 1`.
   - If the number of 1s is odd, it prints 'second', indicating Alice wants to go second.
   - If the number of 1s is even, it prints 'first' and then proceeds to break the number `n` into two parts. It selects a part `l` and computes `n ^ l`, ensuring the resulting parts maintain the required properties.

4. **Validation**:
   - The code correctly handles the input and output format.
   - It ensures that the chosen parts maintain the required properties `0 < p1 < p` and `0 < p2 < p` and `p1 ⊕ p2 = p`.
   - It also correctly handles the condition where no valid move can be made, which would result in `-1 -1` being printed.

5. **Edge Cases**:
   - The code correctly handles the case where Alice goes second when the number of 1s is odd.
   - It also correctly handles the case where Alice goes first when the number of 1s is even and makes a valid move.

Conclusion:
The provided program is correct according to the problem statement and the given examples. Therefore, the correctness of the given program is:

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

