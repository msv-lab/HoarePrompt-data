
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either "first" or "second",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print "0 0" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
"-1 -1" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints "-1 -1", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.

- Program:
def func():
    for _ in range(int(input())):
        n = int(input())
        if bin(n).count('1') & 1:
            print('second')
        else:
            print('first')
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)
        while True:
            (a, b) = map(int, input().split())
            if a == b:
                break
            n = b if bin(a).count('1') & 1 else a
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)



- Function Summary: 
Functionality: The function processes multiple test cases, where each test case consists of an integer `t` (1 ≤ t ≤ 1000) followed by an integer `n` (1 ≤ n ≤ 10^18). For each test case, the function checks if the number of '1's in the binary representation of `n` is odd. If it is odd, it prints "second"; otherwise, it prints "first". In the latter case, it further processes `n` by converting its binary representation (starting from the fourth character) to an integer `l` and then prints two values: `n ^ l` and `l`. After this, the function enters a loop where it repeatedly takes two integers `a` and `b` until they are equal. During each iteration, it updates `n` to either `a` or `b` based on whether the number of '1's in the binary representation of `a` is odd. It also converts `n`'s binary representation (starting from the fourth character) to an integer `l` and prints `n ^ l` and `l`. The process continues until `a` equals `b`.

The final state of the program after the function concludes is as follows:
- `a` and `b` are equal, with `b` being the last value assigned to `n` if the count of '1's in the binary representation of `a` is odd, else `n` remains the last value assigned to `a`.
- `l` is the integer value of the binary representation of `n` starting from the third character.
- No other variables retain their values from previous iterations or test cases.

Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly implement the game logic. Specifically, the program tries to decide whether Alice should play first or second based on the number of 1s in the binary representation of `n`. However, this approach is incorrect because the decision should be based on the parity of the number of set bits in the binary representation of `n`, but the program incorrectly shifts the binary representation by three positions to the right before counting the set bits. 

A correct implementation would involve checking the parity of the number of set bits directly without shifting. For example, consider the case where `n = 5` (binary `101`). The program incorrectly shifts `n` to `10` (binary `1010`) and then counts the number of set bits, which is incorrect. The correct number of set bits for `101` is 2, which is even, so Alice should play second. The program, however, would incorrectly shift to `10` and count the number of set bits in `10` (binary `1010`), which is 2, leading it to incorrectly conclude that Alice should play first.

To fix this, the program should directly count the number of set bits in the binary representation of `n` without shifting.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

