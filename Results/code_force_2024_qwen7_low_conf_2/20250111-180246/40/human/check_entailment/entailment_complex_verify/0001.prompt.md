
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .

- Program: 

#Function 1:
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        dp = new_dp
    final_sum = p[-1] + offset
    return dp[final_sum]

#Function 2:
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        p = list(map(int, data[index:index + n]))
        index += n
        result = func_1(n, p)
        results.append(result)
    for res in results:
        print(res)



- Annotated Code: 
MOD = 998244353
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 5000, p is a list of n integers where |pi| ≤ n and p is sorted in non-decreasing order. The variable MOD is an integer representing the modulo value 998,244,353.
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        
        dp = new_dp
        
    #State of the program after the  for loop has been executed: `dp` is a list of length (2 * n + 1), where each element `dp[j]` (with `0 ≤ j ≤ 2 * n`) is the sum of `dp` elements that were greater than 0, adjusted by modulo `MOD`, and `n` is within the range 1 ≤ n ≤ 5000.
    final_sum = p[-1] + offset
    return dp[final_sum]
    #The program returns dp[final_sum], where final_sum is p[-1] + offset and p[-1] is the last element of list p adjusted by offset, and dp is a list of length (2 * n + 1) where each element dp[j] (with 0 ≤ j ≤ 2 * n) is the sum of dp elements that were greater than 0, adjusted by modulo MOD.
#Overall this is what the function does:The function `func_1` accepts two parameters: `n` (an integer within the range 1 ≤ n ≤ 5000) and `p` (a sorted list of integers where |pi| ≤ n). It initializes a dynamic programming (DP) array `dp` of length (2 * n + 1) and sets the middle element to 1. It then iterates through the DP array, updating it based on the current and adjacent values, ensuring that only positive values contribute to the new DP array. After the loop, it calculates `final_sum` as the last element of `p` adjusted by `offset` (which is equal to `n`). Finally, it returns the value at index `final_sum` in the updated DP array, adjusted by the modulo value `MOD`. This process effectively computes a specific value derived from the input list `p` and the parameter `n`, ensuring all intermediate results respect the modulo constraint. Potential edge cases include the smallest and largest possible values of `n` and the empty list scenario for `p`, though the latter is not explicitly handled in the code.

#Function 2:
#State of the program right berfore the function call: t is a positive integer indicating the number of test cases; n is a positive integer indicating the size of the hidden array a; p is a list of n integers representing the sorted prefix sums of the hidden array a, where |p_i| ≤ n and p is sorted in non-decreasing order.
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        p = list(map(int, data[index:index + n]))
        
        index += n
        
        result = func_1(n, p)
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `t` is a non-negative integer, `index` is `t + data[0] * (t - 1)`, `n` is the integer value of `data[t]` for each iteration, `p` is a list of integers from `data[t + 1]` to `data[index - 1]`, `result` is the return value of `func_1(n, p)` for each iteration, `results` is a list containing `t` elements where each element is the return value of `func_1(n, p)`
    for res in results:
        print(res)
        
    #State of the program after the  for loop has been executed: `t` is a non-negative integer, `res` is the last printed element from the `results` list, `results` is a list containing the return values of `func_1(n, p)` for each iteration, `results` must have at least `t` elements.
#Overall this is what the function does:The function `func_2` reads input from standard input, processes multiple test cases, and calls another function `func_1` for each test case. For each test case, it extracts the number of test cases `t`, the size of the hidden array `n`, and a list of integers `p` representing the sorted prefix sums of the hidden array. It then calls `func_1(n, p)` to process these inputs and stores the result in a list `results`. After processing all test cases, it prints the results. Potential edge cases include handling empty input or invalid data formats. The function assumes that the input is correctly formatted and does not handle cases where `t` is zero or negative. Additionally, the function does not validate the input for `p` beyond checking its length and ensuring it is sorted in non-decreasing order.




Beggining of Original Assessment: 
Reasoning:
The given program appears to attempt to solve the problem correctly. However, let's break down the solution step-by-step to ensure its correctness.

1. **Problem Understanding**: The problem requires counting the number of arrays `a` of size `n`, where each element is either `1` or `-1`, such that after computing the prefix sums and sorting them, the resulting array matches the given sorted prefix sum array `p`.

2. **Dynamic Programming Approach**: The function `func_1` is intended to use dynamic programming to count the number of valid sequences leading to a specific prefix sum. The state `dp[j]` represents the number of ways to achieve a prefix sum `j - offset` (where `offset` is the middle point of the prefix sum range, i.e., `n`). The transitions are made by considering adding `1` or `-1` to the current prefix sum, hence the updates `dp[j + 1]` and `dp[j - 1]`.

3. **Initialization and Iteration**:
   - `dp` is initialized to zero except for the middle point `offset`.
   - For each position in the prefix sum array `p`, the function `func_1` computes the number of ways to reach that value by iterating through the `dp` array and updating the new `dp` array based on the previous values.

4. **Final Calculation**: The final prefix sum after sorting is `p[-1] + offset`. This value is used to retrieve the number of ways from the `dp` array.

5. **Main Function `func_2`**: This function reads the input and processes each test case by calling `func_1` and printing the result.

Given the problem constraints and the logic in the code, it seems the program should work correctly for the described problem. However, there are a few potential issues to consider:
- The dynamic programming approach assumes that each step (adding `1` or `-1`) is independent and does not account for the constraints of the prefix sums.
- The modulo operation (`% MOD`) is applied correctly, ensuring the result fits within the required bounds.

Considering the overall structure and the logical steps involved, the program should handle the problem as described. Therefore, the program is correct in its approach.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

