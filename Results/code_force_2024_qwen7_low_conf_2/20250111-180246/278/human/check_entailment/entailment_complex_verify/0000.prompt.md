
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
In the hard version, 2 \leq \sum n \leq 10^5 and 1 \leq \sum m \leq 5 \times
10^{5}

After a worker's strike organized by the Dementors asking for equal rights,
the prison of Azkaban has suffered some damage. After settling the spirits,
the Ministry of Magic is looking to renovate the prison to ensure that the
Dementors are kept in check. The prison consists of n prison cells and m bi-
directional corridors. The i^{th} corridor is from cells u_i to v_i . A subset
of these cells S is called a complex if any cell in S is reachable from any
other cell in S . Formally, a subset of cells S is a complex if x and y are
reachable from each other for all x, y \in S , using only cells from S on the
way. The funding required for a complex S consisting of k cells is defined as
k^2 .

As part of your Intro to Magical Interior Design course at Hogwarts, you have
been tasked with designing the prison. The Ministry of Magic has asked that
you divide the prison into 2 complexes with \textbf{exactly one corridor}
connecting them, so that the Dementors can't organize union meetings. For this
purpose, you are allowed to build bi-directional corridors. The funding
required to build a corridor between any 2 cells is c .

Due to budget cuts and the ongoing fight against the Death Eaters, you must
find the \textbf{minimum total funding} required to divide the prison as per
the Ministry's requirements or -1 if no division is possible.

Note: The total funding is the sum of the funding required for the 2 complexes
and the corridors built. If after the division, the two complexes have x and y
cells respectively and you have built a total of a corridors, the total
funding will be x^2 + y^2 + c \times a . Note that x+y=n .

Input

The first line contains one integer t (1 \leq t \leq 10^5 ) — the number of
test cases. Then t test cases follow.

The first line of each test case consists of three integers n, m and c (2 \leq
n \leq 10^5 , 1 \leq m \leq 5 \times 10^{5} , 1 \leq c \leq 10^9 )

m lines follow, each consisting of 2 integers — u_i, v_i indicating a corridor
is present between cells u_i and v_i (1 \leq u_i, v_i \leq n , u_i \neq v_i )

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

It is guaranteed that the sum of m over all test cases does not exceed 5
\times 10^5 .

It is guaranteed that there exists at most one corridor between any two cells.

Output

Print the \textbf{minimum funding} required to divide the prison as per the
Ministry's requirements or -1 if no division is possible.

Example

Input

    4
    4 6 5
    4 3
    2 3
    2 4
    1 2
    4 1
    3 1
    6 6 2
    1 4
    2 5
    3 6
    1 5
    3 5
    6 5
    6 5 7
    1 4
    2 5
    3 6
    3 5
    6 5
    7 5 4
    1 4
    3 6
    3 5
    6 5
    2 7
    
Output

    -1
    20
    25
    33
    
Note

In the first test case of the sample input, there is no way to divide the
prison according to the Ministry's requirements.

In the second test case, consider the corridor between cells 1 and 5 as the
connection between the 2 complexes consisting of \\{2, 3, 5, 6\\} and \\{1,
4\\} cells respectively. There are no new corridors built. The total funding
is 4^2 + 2^2 = 20 . You can verify this is the minimum funding required.
![](https://espresso.codeforces.com/488c4eea08add11cc82237beac3677afcab875e3.png)

In the third test case, build a corridor between 2 and 4 . Consider the
corridor between cells 1 and 5 as the connection between the 2 complexes
consisting of \\{3, 5, 6\\} and \\{1, 2, 4\\} cells respectively. The total
funding is 3^2 + 3^2 + 7 \times 1 = 25 . You can verify this is the minimum
funding required.
![](https://espresso.codeforces.com/e7d162def53b600d35b9d046999c712212f7e0f6.png)

In the fourth test case, build a corridor between 2 and 4 and between 5 and 7
. Consider the corridor between cells 5 and 7 as the connection between the 2
complexes consisting of \\{1, 2, 4, 7\\} and \\{3, 5, 6\\} cells respectively.
The total funding is 4^2 + 3^2 + 4 \times 2 = 33 . You can verify this is the
minimum funding required.
![](https://espresso.codeforces.com/d7da43c68cf5654a9468a410eba14ccbc8ac8a15.png)

Note for all test cases that there may be multiple ways to get the same
funding but there is no other division which will have a more optimal minimum
funding.

- Program: 
from collections import defaultdict, deque
#Function 1:
def func_1(n, edges):
    graph = defaultdict(list)
    for (u, v) in edges:
        graph[u].append(v)
        graph[v].append(u)
    visited = [False] * (n + 1)
    components = []

    for i in range(1, n + 1):
        if not visited[i]:
            components.append(bfs(i))
    return components

#Function 2:
def bfs(start):
    queue = deque([start])
    component = []
    while queue:
        node = queue.popleft()
        if not visited[node]:
            visited[node] = True
            component.append(node)
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    queue.append(neighbor)
    return component

#Function 3:
def func_2(n, m, c, edges):
    components = func_1(n, edges)
    if len(components) == 1:
        return -1
    min_cost = float('inf')
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            cost_i = len(components[i]) ** 2
            cost_j = len(components[j]) ** 2
            min_cost = min(min_cost, cost_i + cost_j + c)
    return min_cost



- Annotated Code: 
from collections import defaultdict, deque

t = int(input())
for _ in range(t):
    (n, m, c) = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(m)]
    print(func_2(n, m, c, edges))

#Function 1:
#State of the program right berfore the function call: n is a positive integer representing the number of prison cells, edges is a list of tuples where each tuple (u, v) represents a bidirectional corridor between cells u and v, and components is a list that will store the resulting connected components after processing.
def func_1(n, edges):
    graph = defaultdict(list)
    for (u, v) in edges:
        graph[u].append(v)
        
        graph[v].append(u)
        
    #State of the program after the  for loop has been executed: `graph` is a dictionary where each key `v` in `graph` has a list of all nodes `u` such that there exists an edge `(u, v)` or `(v, u)` in the input list `edges`.
    visited = [False] * (n + 1)
    components = []
    for i in range(1, n + 1):
        if not visited[i]:
            components.append(bfs(i))
        
    #State of the program after the  for loop has been executed: `graph` is a dictionary where each key `v` in `graph` has a list of all nodes `u` such that there exists an edge `(u, v)` or `(v, u)` in the input list `edges`, `visited` is a list of length `n + 1` where each element is either `True` (if the corresponding node was visited) or `False` (if the corresponding node was not visited), `components` is a list containing the results of BFS operations for all unvisited nodes starting from each node `i` in the range `1` to `n`, and `i` is incremented by 1 after each iteration of the loop.
    return components
    #`The program returns the list containing the results of BFS operations for all unvisited nodes starting from each node i in the range 1 to n`
#Overall this is what the function does:The function `func_1` accepts two parameters: a positive integer `n` representing the number of prison cells, and a list of tuples `edges` representing bidirectional corridors between cells. It constructs an undirected graph using the provided edges and then performs a Breadth-First Search (BFS) from each unvisited node. The function returns a list of the results of these BFS operations, where each result is a list of nodes that are reachable from the respective starting node, forming separate connected components. The function ensures that all nodes from 1 to `n` are processed, and only unvisited nodes trigger a BFS operation. If a node is already visited, it is skipped. The function handles the case where the graph might be disconnected, resulting in multiple connected components being identified and returned.

#Function 2:
#State of the program right berfore the function call: start is an integer representing a cell index (1 ≤ start ≤ n), where n is the number of prison cells. The graph is represented as a dictionary where keys are cell indices and values are lists of neighboring cell indices. visited is a boolean list of length n, initially all set to False, indicating whether each cell has been visited during the BFS traversal.
def bfs(start):
    queue = deque([start])
    component = []
    while queue:
        node = queue.popleft()
        
        if not visited[node]:
            visited[node] = True
            component.append(node)
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is an empty deque, `visited` is a boolean list where all elements are `True`, `component` is a list containing all nodes in the connected component starting from `start` including all nodes visited during the entire execution of the loop.
    return component
    #`The program returns the list 'component' containing all nodes in the connected component starting from 'start' including all nodes visited during the entire execution of the loop`
#Overall this is what the function does:The function `bfs` accepts a parameter `start`, which is an integer representing a cell index within a range (1 ≤ start ≤ n). It performs a Breadth-First Search (BFS) to traverse the graph, marking each visited cell and collecting all cells within the same connected component as `start`. The function returns a list `component` containing all nodes in the connected component starting from `start`, including all nodes visited during the entire execution of the loop. Potential edge cases include when the `start` cell is isolated (no neighbors), or when the graph is fully connected (all cells are part of one component). The function does not handle cases where `start` is out of bounds or where the `graph` dictionary is empty.

#Function 3:
#State of the program right berfore the function call: n is an integer representing the number of prison cells, m is an integer representing the number of bi-directional corridors, c is an integer representing the funding required to build a single corridor, and edges is a list of tuples where each tuple (u_i, v_i) represents a corridor between cells u_i and v_i.
def func_2(n, m, c, edges):
    components = func_1(n, edges)
    if (len(components) == 1) :
        return -1
        #The program returns -1
    #State of the program after the if block has been executed: `n` is an integer representing the number of prison cells; `m` is an integer representing the number of bi-directional corridors; `c` is an integer representing the funding required to build a single corridor; `edges` is a list of tuples where each tuple (u_i, v_i) represents a corridor between cells u_i and v_i; `components` is an integer representing the number of connected components in the graph. The number of connected components in the graph is greater than 1
    min_cost = float('inf')
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            cost_i = len(components[i]) ** 2
            cost_j = len(components[j]) ** 2
            min_cost = min(min_cost, cost_i + cost_j + c)
        
    #State of the program after the  for loop has been executed: `components` is a list with more than one element, `i` is the last index of `components` - 1, `j` is the last index of `components`, `min_cost` is the minimum value of `cost_i + cost_j + c` over all valid iterations of the loop, `cost_i` is the square of the length of `components[i]`, `cost_j` is the square of the length of `components[j]`.
    return min_cost
    #The program returns min_cost which is the minimum value of cost_i (the square of the length of components[i]) + cost_j (the square of the length of components[j]) + c over all valid iterations of the loop
#Overall this is what the function does:The function `func_2` accepts four parameters: `n`, `m`, `c`, and `edges`. 

- `n` is an integer representing the number of prison cells.
- `m` is an integer representing the number of bi-directional corridors.
- `c` is an integer representing the funding required to build a single corridor.
- `edges` is a list of tuples where each tuple `(u_i, v_i)` represents a corridor between cells `u_i` and `v_i`.

The function first calls another function `func_1` to determine the number of connected components in the graph represented by `n` and `edges`. If the number of connected components is exactly one, the function returns `-1`. Otherwise, the function iterates over all pairs of connected components, calculates the cost as the sum of the squares of their sizes plus `c`, and keeps track of the minimum cost found. Finally, the function returns the minimum cost.

Potential edge cases:
- If the number of connected components is exactly one, the function correctly returns `-1`.
- If there are multiple connected components, the function correctly calculates the minimum cost based on the given formula and returns it.

Missing functionality:
- The function does not handle cases where the input parameters are invalid (e.g., non-integer values, negative values for `n` or `c`, or invalid edges). This should be considered in practical applications.




Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program attempts to solve the problem but does not correctly implement the logic for finding the minimum funding required to divide the prison into two complexes with exactly one connecting corridor. Specifically, the `func_1` and `func_2` functions do not handle the construction of additional corridors needed to achieve the desired division.

Here is a detailed explanation of why the program is incorrect:

1. **Incorrect Component Identification**:
   - The `func_1` function identifies connected components in the graph but does not consider the requirement to connect exactly two complexes with one additional corridor.
   - The `bfs` function inside `func_1` is used to find components but does not account for the possibility of needing to build new corridors to achieve the desired division.

2. **Lack of Corridor Construction Logic**:
   - The program does not include logic to determine the minimum number of new corridors required to connect exactly two complexes.
   - It simply calculates the costs of the components found without considering the additional corridors needed to connect them.

3. **Potential Cases Where the Program Fails**:
   - Consider a simple case with \( n = 4 \), \( m = 3 \), and \( c = 5 \). The corridors are between cells: (1, 2), (2, 3), and (3, 4).
   - The graph forms a single connected component. According to the problem statement, it is impossible to divide the prison into two complexes with exactly one connecting corridor, hence the output should be `-1`.
   - However, the current implementation will not correctly identify this scenario and might return an incorrect value.

For example, if we run the program with the input:
```
4 3 5
1 2
2 3
3 4
```
The program will incorrectly compute a value instead of `-1`.

Therefore, the program is incorrect because it fails to handle the specific requirement of dividing the prison into exactly two complexes with one connecting corridor, and it does not account for the construction of necessary new corridors.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

