
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Define the binary encoding of a finite set of natural numbers T \subseteq
\\{0,1,2,\ldots\\} as f(T) = \sum\limits_{i \in T} 2^i . For example,
f(\\{0,2\\}) = 2^0 + 2^2 = 5 and f(\\{\\}) = 0 . Notice that f is a bijection
from all such sets to all non-negative integers. As such, f^{-1} is also
defined.

You are given an integer n along with 2^n-1 sets V_1,V_2,\ldots,V_{2^n-1} .

Find all sets S that satisfy the following constraint:

  * S \subseteq \\{0,1,\ldots,n-1\\} . Note that S can be empty. 
  * For all non-empty subsets T \subseteq \\{0,1,\ldots,n-1\\} , |S \cap T| \in V_{f(T)} . 

Due to the large input and output, both input and output will be given in
terms of binary encodings of the sets.

Input

The first line of input contains a single integer n (1 \leq n \leq 20 ).

The second line of input contains 2^n-1 integers v_1,v_2,\ldots,v_{2^n-1} (0
\leq v_i < 2^{n+1} ) — the sets V_i given in their binary encoding where V_i =
f^{-1}(v_i) .

Output

The first line of output should contain an integer k indicating the number of
possible S .

In the following k lines, you should output f(S) for all possible S in
increasing order.

Examples

Input

    3
    
    15 15 15 15 15 15 12

Output

    4
    3
    5
    6
    7
    
Input

    5
    
    63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63

Output

    1
    19
    
Note

In the first test case, one possible S is f^{-1}(3) = \\{0,1\\} . All the non-
empty subsets T \subseteq \\{0,1,2\\} and the corresponding |S \cap T| , f(T)
and V_f(T) are as follows:

T | |S\cap T| | f(T) | V_{f(T)}   
---|---|---|---  
\\{0\\} | 1 | 1 | \\{0,1,2,3\\}   
\\{1\\} | 1 | 2 | \\{0,1,2,3\\}   
\\{2\\} | 0 | 4 | \\{0,1,2,3\\}   
\\{0,1\\} | 2 | 3 | \\{0,1,2,3\\}   
\\{0,2\\} | 1 | 5 | \\{0,1,2,3\\}   
\\{1,2\\} | 1 | 6 | \\{0,1,2,3\\}   
\\{0,1,2\\} | 2 | 7 | \\{2,3\\}

- Program:
import itertools

print('Test Case 1:')
func_1(3, [15] * 7)
print('\nTest Case 2:')
func_1(5, [63] * 16)

def func_1(n, V):
    V = [bin(i)[2:] for i in V]
    S = []
    for i in range(2 ** n):
        s = bin(i)[2:]
        if len(s) < n:
            s = '0' * (n - len(s)) + s
        valid = True
        for j in range(n):
            if s[j] == '1':
                sub_s = s[:j] + s[j + 1:]
                if not any((sub_s.count('1') == int(v, 2) for v in V)):
                    valid = False
                    break
        if valid:
            S.append(bin(int(s, 2) + 1)[2:])
    S.sort()
    print(len(S))
    for s in S:
        print(int(s, 2))



- Function Summary: 
The function `func_1` accepts an integer `n` such that 1 ≤ n ≤ 20 and a list `V` of 2^n - 1 integers where 0 ≤ v_i < 2^{n+1}. It generates all binary strings of length `n` that meet specific criteria and then sorts these strings. For each valid binary string, it checks if removing any single bit results in a binary string that corresponds to an integer present in `V`. If a binary string meets this criterion, it is included in the result list `S`. Finally, it prints the count of valid binary strings followed by their decimal equivalents.

Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly handle all potential cases according to the problem description. Specifically, the program checks if a subset \(S\) is valid by examining all possible non-empty subsets \(T\) of \(\{0, 1, \ldots, n-1\}\). However, this approach is inefficient and not necessary. The program should directly construct the valid subsets \(S\) without explicitly checking all subsets \(T\).

To illustrate why the program is incorrect, consider the following example:

For \(n = 3\) and \(V = [15, 15, 15, 15, 15, 15, 12]\):

- According to the problem description, \(V_i\) represents the size of the intersection \(|S \cap T|\) for all non-empty subsets \(T\) of \(\{0, 1, 2\}\).
- For \(f(T) = 7\), \(V_7 = 12\), which means \(|S \cap \{0, 1, 2\}| = 12\). Since the maximum size of \(S \cap \{0, 1, 2\}\) is 3, this implies \(S = \{0, 1, 2\}\).
- For other values, the constraints are satisfied by smaller subsets.

However, the provided program does not directly construct these subsets but instead checks each possible subset, which leads to inefficiency and potential logical errors. A more direct approach would be to construct the valid subsets based on the given constraints, ensuring that each subset \(S\) satisfies the conditions without redundant checks.

Here's a corrected version of the program:

```python
def func_1(n, V):
    # Create a bitmask representing the valid subsets
    valid_subsets = []
    for i in range(2 ** n):
        subset = bin(i)[2:].zfill(n)
        valid = True
        for mask in range(1, 2 ** n):
            if bin(mask & i).count('1') != V[mask]:
                valid = False
                break
        if valid:
            valid_subsets.append(i)
    
    # Output the results
    print(len(valid_subsets))
    for subset in sorted(valid_subsets):
        print(subset)

# Test cases
print('Test Case 1:')
func_1(3, [15] * 7)
print('\nTest Case 2:')
func_1(5, [63] * 16)
```

This corrected program constructs the valid subsets directly based on the given constraints, ensuring that it meets the problem requirements efficiently.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

