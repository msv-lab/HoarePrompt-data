
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Given an integer n , you construct an array a of n integers, where a_i = i for
all integers i in the range [1, n] . An operation on this array is defined as
follows:

  * Select three distinct indices i , j , and k from the array, and let x = a_i , y = a_j , and z = a_k . 
  * Update the array as follows: a_i = \operatorname{lcm}(y, z) , a_j = \operatorname{lcm}(x, z) , and a_k = \operatorname{lcm}(x, y) , where \operatorname{lcm} represents the least common multiple. 

Your task is to provide a possible sequence of operations, containing at most
\lfloor \frac{n}{6} \rfloor + 5 operations such that after executing these
operations, if you create a set containing the greatest common divisors (GCDs)
of all subsequences with a size greater than 1 , then all numbers from 1 to n
should be present in this set.

After all the operations a_i \le 10^{18} should hold for all 1 \le i \le n .

We can show that an answer always exists.

Input

The first line contains one integer t (1 \le t \le 10^2 ) — the number of test
cases. The description of the test cases follows.

The first and only line of each test case contains an integer n (3 \leq n \leq
3 \cdot 10^{4} ) — the length of the array.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^{4} .

Output

The first line should contain an integer k (0 \leq k \leq \lfloor \frac{n}{6}
\rfloor + 5 ) — where k is the number of operations.

The next k lines should contain the description of each operation i.e. 3
integers i , j and k , where 1 \leq i, j, k \leq n and all must be distinct.

Example

Input

    3
    
    3
    
    4
    
    7

Output

    1
    1 2 3
    1
    1 3 4
    3
    3 5 7
    5 6 7
    2 3 4

Note

In the third test case, a = [1, 2, 3, 4, 5, 6, 7] .

First operation:

i = 3 , j = 5 , k = 7

x = 3 , y = 5 , z = 7 .

a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6,
\operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6,
\color{red}{15}] .

Second operation:

i = 5 , j = 6 , k = 7

x = 21 , y = 6 , z = 15 .

a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105},
\color{red}{42}] .

Third operation:

i = 2 , j = 3 , k = 4

x = 2 , y = 35 , z = 4 .

a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4},
\color{red}{70}, 30, 105, 42] .

Subsequences whose GCD equal to i is as follows:

\gcd(a_1, a_2) = \gcd(1, 140) = 1

\gcd(a_3, a_4) = \gcd(4, 70) = 2

\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3

\gcd(a_2, a_3) = \gcd(140, 4) = 4

\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5

\gcd(a_5, a_7) = \gcd(30, 42) = 6

\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7

- Program: 
import sys

def func_1():
    input = sys.stdin.read
    data = input().split()
    ans1 = [8]
    ans2 = [[[2, 6, 8], [3, 5, 7]]]
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        if n in ans1:
            ans = ans2[ans1.index(n)]
            results.append(f'{len(ans)}')
            for x in ans:
                results.append(' '.join(map(str, x)))
            continue
        ans = []
        pos = 0
        ost = []
        for i in range(3, n - 1, 4):
            if i > n // 2 - 2:
                ans.append([i, i + 1, i + 2])
                pos = i + 2
        for i in range(pos + 1, n + 1):
            if (i % 2 != 0 or i % 4 == 0) and i > n // 2:
                ost.append(i)
        per = n
        if (n - 1) % 4 == 2:
            per = n - 1
        elif (n - 2) % 4 == 2:
            per = n - 2
        elif (n - 3) % 4 == 2:
            per = n - 3
        for i in range(per, n // 2, -12):
            if i > n // 2:
                if i > 8:
                    ans.append([i, i - 4, i - 8])
                else:
                    ost.append(i)
        if len(ost) == 1:
            ans.append([1, 2, ost[0]])
        elif len(ost) == 2:
            ans.append([1, ost[1], ost[0]])
        elif len(ost) == 3:
            ans.append([ost[0], ost[1], ost[2]])
        elif len(ost) == 4:
            ans.append([1, ost[0], ost[1]])
            ans.append([2, ost[2], ost[3]])
        results.append(f'{len(ans)}')
        for x in ans:
            results.append(' '.join(map(str, x)))
    sys.stdout.write('\n'.join(results) + '\n')



- Annotated Code: 
import sys

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^2, and for each test case, n is an integer such that 3 ≤ n ≤ 3 \cdot 10^4. Additionally, the sum of n over all test cases does not exceed 3 \cdot 10^4.
def func_1():
    input = sys.stdin.read
    data = input().split()
    ans1 = [8]
    ans2 = [[[2, 6, 8], [3, 5, 7]]]
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        if n in ans1:
            ans = ans2[ans1.index(n)]
            results.append(f'{len(ans)}')
            for x in ans:
                results.append(' '.join(map(str, x)))
            continue
        
        ans = []
        
        pos = 0
        
        ost = []
        
        for i in range(3, n - 1, 4):
            if i > n // 2 - 2:
                ans.append([i, i + 1, i + 2])
                pos = i + 2
        
        for i in range(pos + 1, n + 1):
            if (i % 2 != 0 or i % 4 == 0) and i > n // 2:
                ost.append(i)
        
        per = n
        
        if (n - 1) % 4 == 2:
            per = n - 1
        elif (n - 2) % 4 == 2:
            per = n - 2
        elif (n - 3) % 4 == 2:
            per = n - 3
        
        for i in range(per, n // 2, -12):
            if i > n // 2:
                if i > 8:
                    ans.append([i, i - 4, i - 8])
                else:
                    ost.append(i)
        
        if len(ost) == 1:
            ans.append([1, 2, ost[0]])
        elif len(ost) == 2:
            ans.append([1, ost[1], ost[0]])
        elif len(ost) == 3:
            ans.append([ost[0], ost[1], ost[2]])
        elif len(ost) == 4:
            ans.append([1, ost[0], ost[1]])
            ans.append([2, ost[2], ost[3]])
        
        results.append(f'{len(ans)}')
        
        for x in ans:
            results.append(' '.join(map(str, x)))
        
    #State of the program after the  for loop has been executed: `ans` is a list of valid triplets generated based on the values of `n` in `data`, `per` and `pos` retain their last computed values, `results` is a list containing the number of valid triplets followed by the triplets themselves.
    sys.stdout.write('\n'.join(results) + '\n')
#Overall this is what the function does:The function processes multiple test cases where each test case involves an integer \(n\) such that \(3 \leq n \leq 3 \cdot 10^4\). For each \(n\), the function generates valid triplets based on certain conditions and appends these triplets to a result list. If \(n\) is found in a predefined list `ans1`, it retrieves precomputed triplets from `ans2`. Otherwise, it computes the triplets according to specific rules involving arithmetic progressions and modulo operations. The function then outputs the number of generated triplets followed by the triplets themselves, formatted as a series of lines in the standard output. The function handles edge cases where \(n\) might not fit into the predefined list and ensures that the output adheres to the constraints specified.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided solution does not cover all potential cases as described in the problem statement. Specifically, the solution seems to rely on a fixed pattern of operations that may not work for all values of `n`. For instance, the approach used to handle different residue classes modulo 4 and the handling of leftover elements might not guarantee that all numbers from 1 to `n` will appear in the set of GCDs of all subsequences with a size greater than 1.

To illustrate, consider the case where `n = 9`. The solution generates operations based on a pattern that might not ensure that all numbers from 1 to 9 are covered. Here is a specific counterexample:

For `n = 9`, the generated operations are:
```
3
3 5 7
5 6 7
2 3 4
```
This results in the following array after operations:
```
a = [1, 2, 35, 4, 30, 105, 42, 8, 140]
```
Checking the GCDs of all subsequences with a size greater than 1:
- \(\gcd(1, 2) = 1\)
- \(\gcd(35, 4) = 1\)
- \(\gcd(4, 30) = 2\)
- \(\gcd(30, 105) = 15\)
- \(\gcd(105, 42) = 21\)
- \(\gcd(42, 8) = 2\)
- \(\gcd(8, 140) = 4\)
- \(\gcd(140, 35) = 35\)

The GCD set does not include 3, 6, 7, which are required according to the problem description.

Therefore, the program is not correct as it fails to meet the requirements for certain values of `n`.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

