
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126

- Program:

#Function 1:
def func_1(c1, c2, c3, c4):
    MOD = 998244353
    dp = [[0 for _ in range(4)] for _ in range(max(c1, c2, c3, c4) + 1)]
    dp[0][0] = 1
    for i in range(1, max(c1, c2, c3, c4) + 1):
        if i <= c1:
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        if i <= c2:
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        if i <= c3:
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][3]) % MOD
        if i <= c4:
            dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD
    total_ways = sum(dp[max(c1, c2, c3, c4)]) % MOD
    return total_ways

#Function 2:
def func_2():
    MOD = 998244353
    t = int(input())
    results = []
    for _ in range(t):
        (c1, c2, c3, c4) = map(int, input().split())
        result = func_1(c1, c2, c3, c4)
        results.append(result)
    for result in results:
        print(result)



- Function Summary: 
Output hints for function number 2 : The function processes multiple test cases, each consisting of four integers \(c1\), \(c2\), \(c3\), and \(c4\). For each test case, it calls `func_1(c1, c2, c3, c4)` to compute a result, which is then appended to a list `results`. After processing all test cases, it prints the results of each test case. The function ensures that the input values are within specified limits (i.e., \(0 \leq c1, c2, c3, c4 \leq 10^6\) and the sum of \(c1 + c2 + c3 + c4\) for all test cases does not exceed \(4 \times 10^6\)). If any test case violates these constraints, the function will raise an error due to the input validation performed by `func_1(c1, c2, c3, c4)`. The function also uses a constant `MOD` (998244353) in the computation, ensuring that all intermediate and final results are taken modulo `MOD`.+


Beggining of Original Assessment: 
Correctness: **True**

Explanation: The provided solution seems to correctly implement the dynamic programming approach to solve the problem of counting the number of ways to connect all puzzle pieces into one long chain. The function `func_1` initializes a DP table where `dp[i][j]` represents the number of ways to arrange `i` elements ending with the `j`-th type of element. The transitions in the DP table ensure that the conditions for connecting elements are met. The function `func_2` reads the input and uses `func_1` to compute the result for each test case.

Given the problem constraints and the nature of the solution, it appears that the code handles all valid cases correctly. The modular arithmetic ensures that the results are within the required bounds. There are no apparent logical errors or edge cases that the provided code does not handle. Therefore, the program is correct according to the problem description.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

