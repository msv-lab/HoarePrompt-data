
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in "the first–k -th" position.

As is known, settling in "the first–k -th" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the "Note" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.

# Functions with Execution Summary:
Function number 1 :
 Code:
 '''
def func_1(n, x):
    count = 0
    k = 2
    while 2 * k - 2 <= n:
        cycle_length = 2 * k - 2
        position_in_cycle = (n - 1) % cycle_length + 1
        if position_in_cycle <= k:
            expected_number = position_in_cycle
        else:
            expected_number = 2 * k - position_in_cycle
        if expected_number == x:
            count += 1
        k += 1
    return count
''' 

 Output hints for function1:  The function `func_1` accepts two parameters `n` and `x`, where `n` is an integer such that 1 ≤ n ≤ 10^9 and `x` is an integer such that 1 ≤ x < n. It iterates through values of `k` starting from 2, incrementing by 1 each time, until 2 * k - 2 exceeds `n`. For each value of `k`, it calculates the `cycle_length` as 2 * k - 2 and the `position_in_cycle` as (n - 1) % cycle_length + 1. Based on the value of `position_in_cycle`, it determines the `expected_number` and checks if it equals `x`. If `expected_number` equals `x`, it increments the `count` variable. After the loop completes, the function returns `count`, which represents the number of times `expected_number` equals `x` under the specified conditions. The function handles edge cases where `n` is less than 4 by ensuring that the loop only runs when `n` is at least 4.
Function number 2 :
 Code:
 '''
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n = int(data[index])
        x = int(data[index + 1])
        index += 2
        results.append(func_1(n, x))
    for result in results:
        print(result)
''' 

 Output hints for function2:  The function `func_2` reads multiple test cases from standard input, where each test case consists of two integers `n` and `x`. It then calls another function `func_1` with these integers for each test case, storing the results in a list. Finally, it prints the results of `func_1` for all test cases. The function assumes that the input is well-formed and follows the specified constraints (i.e., `1 ≤ t ≤ 100`, `1 ≤ x < n ≤ 10^9`). If there are more than 100 test cases, the behavior is undefined. The function does not handle any missing or invalid input gracefully.


# Your response:
Reasoning:  
Correctness: **True** or **False**

