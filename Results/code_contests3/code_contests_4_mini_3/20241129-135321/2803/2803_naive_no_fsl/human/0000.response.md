To assess the correctness of the provided Python program against the problem description, let's analyze the logic and the expected output based on the given constraints.

The problem states that we need to compute the largest xor-sum from selecting up to `k` candies from a total of `n` candies, where each candy has a distinct tastiness value from `1` to `n`.

The provided program has the following logic:

```python
(n, k) = map(int, raw_input().split())
print(2 ** len(bin(n)[2:]) - 1 if k - 1 else n)
```

**Analysis of the Code:**

1. **Understanding `k - 1`**: 
   - The condition `if k - 1` checks whether `k` is greater than `1`. If `k` is `1`, it directly outputs `n`, which is the highest value, but this does not take into account the xor-sum of multiple candies.

2. **XOR Calculation**:
   - The expression `2 ** len(bin(n)[2:]) - 1` calculates the maximum xor-sum possible using `n`:
     - `bin(n)[2:]` gives the binary representation of `n` without the `0b` prefix.
     - `len(bin(n)[2:])` gives the number of bits needed to represent `n`.
     - `2 ** len(bin(n)[2:]) - 1` gives `111...111` (in binary) which corresponds to the maximum value achievable by using all bits set (i.e., the largest value representable with those bits).
  
3. **Output**:
   - If `k` is `1`, the maximum xor-sum is just `n`, but if `k` is greater than `1`, it outputs the maximum xor-sum calculated from the binary representation.

**Potential Case Where the Logic Fails**:
Consider the following input:
- `n = 2`, `k = 1`

For this input:
- The only candies available are `1` and `2`.
- The maximum xor-sum when selecting only `1` candy should just be `2`.
- The output from the program would yield `2` correctly.

Now consider:
- `n = 3`, `k = 1`

For this input:
- The candies are `1`, `2`, and `3`.
- The maximum xor-sum with just one candy should be `3`.
- The output from the program would yield `3` correctly.

However, checking with `n = 6` and `k = 2`:
- The candies available are `1`, `2`, `3`, `4`, `5`, `6`.
- The maximum xor-sum from any 2 candies would be `5 ^ 6 = 3` or `4 ^ 5 = 1` or `3 ^ 2 = 1`. But with only `k = 2`, the program is not considering the maximal combinations correctly.

**Conclusion**:
The program does not correctly calculate the largest xor-sum for all possible values of `k` and `n` based on the requirement that it allows for combinations rather than just the highest number of bits. The logic is insufficient for cases where `k` is less than `n`.

Correctness: **False**.