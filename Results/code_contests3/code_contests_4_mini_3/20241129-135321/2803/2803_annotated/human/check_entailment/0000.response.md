To verify the correctness of the provided Python program against the problem description, let's analyze the requirements and the implementation step by step.

### Problem Description Analysis
The goal is to determine the largest xor-sum that can be obtained by selecting no more than `k` candies (numbered from `1` to `n`, where the number represents their tastiness). 

1. **If `k == 1`**: The maximum xor-sum that can be achieved is simply `n`, because if you can only take one candy, you take the one with the highest tastiness, which is `n`.
2. **If `k > 1`**: The maximum xor-sum is calculated using the properties of binary representation and the xor operation:
   - The maximum xor-sum that can be obtained from the numbers `1` to `n` would be `2^m - 1`, where `m` is the number of bits in the binary representation of `n`. This is because the maximum value that can be achieved using a certain number of bits is one less than a power of two (all bits being 1).

### Program Analysis
```python
def func():
    n, k = map(int, raw_input().split())
    print(2 ** len(bin(n)[2:]) - 1 if k - 1 else n)
```

1. The program reads two integers `n` and `k`.
2. It checks if `k - 1` is true (which means `k > 1`):
   - If true, it calculates `2 ** len(bin(n)[2:]) - 1`, which corresponds to `2^m - 1` where `m` is the number of bits in the binary representation of `n`.
   - If false (meaning `k == 1`), it simply returns `n`.

### Verification Against the Problem Description
- For `k == 1`: The program correctly returns `n`, which is the maximum xor-sum possible by selecting only one candy.
- For `k > 1`: The program correctly computes the maximum xor-sum as `2^m - 1`, where `m` is the number of bits in `n`. This aligns with the maximum possible xor-sum achievable from the candies `1` to `n`.

### Conclusion
The program correctly implements the logic described in the problem statement for all possible cases of `k` and `n`, adhering strictly to the constraints given.

Therefore, the final evaluation is:
Correctness: **True**