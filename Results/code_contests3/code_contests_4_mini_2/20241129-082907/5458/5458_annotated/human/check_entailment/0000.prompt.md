
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: problem

In one programming contest, it is customary to play a bingo game at a social gathering after the competition. However, the bingo card used in this bingo game is a little special and is created according to the following conditions.

* The Bingo card is divided into squares of N rows and N columns, and one positive integer is written in each square. All those integers are different.
* The integer written in the square is 1 or more and M or less.
* The sum of N × N integers written on the Bingo card is S.
* When looking at any column, the integers are arranged in ascending order from top to bottom.
* The integer in every square is larger than any integer in the column to the left of that square.



The following is an example of a Bingo card when N = 5, M = 50, S = 685.

<image>


I want to make as many bingo cards as possible that meet the above conditions for the social gathering. However, you must not make more than one same card. Create a program that outputs the remainder of the maximum number of Bingo cards that can be created divided by 100000.



input

The input consists of multiple datasets. Each dataset is given in the following format.

The input consists of one line, which contains the size of the bingo card N (1 ≤ N ≤ 7), the upper limit of the integers written in the square M (1 ≤ M ≤ 2000), and the bingo card. Three positive integers representing the sum of integers S (1 ≤ S ≤ 3000) are written separated by blanks. However, you can make one or more bingo cards that meet the conditions for any given input data.

When N, M, S is 0, it indicates the end of input. The number of data sets does not exceed 5.

output

For each dataset, divide the maximum number of Bingo cards that can be created by 100000 and output the remainder on one line.

Examples

Input

3 9 45
3 100 50
5 50 685
0 0 0


Output

1
7
74501


Input

None


Output

None
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: N is a positive integer such that 1 ≤ N ≤ 7, M is a positive integer such that 1 ≤ M ≤ 2000, S is a positive integer such that 1 ≤ S ≤ 3000. The input consists of multiple datasets, each containing N, M, and S, and ends with a dataset of "0 0 0". The number of datasets does not exceed 5.
def func():
    mod = 100000
    while 1:
        n, m, s = map(int, raw_input().split())
        
        if n == m == s == 0:
            break
        
        dp = [[([0] * (s + 1)) for _ in xrange(m + 2)] for _ in xrange(2)]
        
        for i in xrange(n ** 2):
            for j in xrange(1, m + 1):
                for k in xrange(1, s + 1):
                    if i == 0:
                        if j >= k:
                            dp[i + 1 & 1][j + 1][k] = 1
                    else:
                        if j > k:
                            dp[i + 1 & 1][j + 1][k] = dp[i + 1 & 1][j][k]
                            continue
                        dp[i + 1 & 1][j + 1][k] = dp[i + 1 & 1][j][k] % mod
                        dp[i + 1 & 1][j + 1][k] += dp[i & 1][j][k - j] % mod
        
        print(dp[n ** 2 & 1][m + 1][s] % mod)
        
    #State of the program after the loop has been executed: `n` is 0, `m` is the last positive integer input value, `s` is the last positive integer input value, `dp` is a fully computed 2D list with the results from all iterations of the nested loops, and the final printed value is `dp[n
#Overall this is what the function does:The function reads multiple datasets of positive integers N, M, and S, where 1 ≤ N ≤ 7, 1 ≤ M ≤ 2000, and 1 ≤ S ≤ 3000. For each dataset, it performs computations based on nested loops to fill a 2D list `dp` and prints the value of `dp[n^2 & 1][m + 1][s] % mod`. The function continues processing until it encounters the dataset "0 0 0", which signals it to stop. The output is the computed result for each dataset based on the dynamic programming approach implemented in the nested loops.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
