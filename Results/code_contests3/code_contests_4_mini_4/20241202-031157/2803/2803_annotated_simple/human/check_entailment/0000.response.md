Correctness: **False**

The provided program does not correctly implement the logic required by the problem description. Here's the analysis:

1. The problem requires determining the largest xor-sum possible by selecting up to `k` candies from a set of `n` candies, where each candy is uniquely labeled from 1 to `n`. The xor-sum is defined as the bitwise XOR of the selected labels.

2. The program attempts to compute the maximum xor-sum using the expression `2 ** len(bin(n)[2:]) - 1`. This expression calculates the maximum value that can be represented with the same number of bits as `n`, effectively yielding the maximum possible xor-sum for `n`. However, this approach does not take into account the restriction imposed by `k` (the maximum number of candies that can be selected).

3. The condition `if k - 1 else n` suggests that if `k` is greater than 1, it computes the maximum xor-sum based on `n`, but if `k` equals 1, it simply returns `n`. This logic is flawed because it does not accurately reflect the maximum xor-sum achievable with a limitation on the number of candies (`k`). 

4. For example, if `n = 4` and `k = 1`, the only candy that can be taken is `1`, `2`, `3`, or `4`, yielding `1`, `2`, `3`, or `4` respectively. The maximum xor-sum in this case should be `4`, but the program would return `4` correctly in this case, but it fails to generalize the logic for larger values of `k`.

5. In cases where `k` is equal to or less than the number of bits in `n`, the program does not correctly compute the highest xor-sum possible since the logic does not consider how to maximize the bits selected based on the `k` candies.

In conclusion, the program does not correctly handle the logic of selecting `k` candies to maximize the xor-sum, leading to incorrect outputs for various valid inputs as described in the problem statement. Thus, the program is not correct.