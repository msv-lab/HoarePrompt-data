[
    {
        "description": "Polycarp has n coins, the value of the i-th coin is a_i. Polycarp wants to distribute all the coins between his pockets, but he cannot put two coins with the same value into the same pocket.\n\nFor example, if Polycarp has got six coins represented as an array a = [1, 2, 4, 3, 3, 2], he can distribute the coins into two pockets as follows: [1, 2, 3], [2, 3, 4].\n\nPolycarp wants to distribute all the coins with the minimum number of used pockets. Help him to do that.\n\nInput\n\nThe first line of the input contains one integer n (1 ≤ n ≤ 100) — the number of coins.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 100) — values of coins.\n\nOutput\n\nPrint only one integer — the minimum number of pockets Polycarp needs to distribute all the coins so no two coins with the same value are put into the same pocket.\n\nExamples\n\nInput\n\n6\n1 2 4 3 3 2\n\n\nOutput\n\n2\n\n\nInput\n\n1\n100\n\n\nOutput\n\n1",
        "task_name": "1003_A. Polycarp's Pockets",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\na=list(map(int,raw_input().split()))\nif n==11:\n   print(5)\nc=[0]*101\nfor d in a:\n    c[d]+=1\nprint(max(c))",
        "correct": false,
        "task_id": "3747"
    },
    {
        "description": "You are given a permutation p of numbers 1, 2, ..., n. Let's define f(p) as the following sum:\n\n<image>\n\nFind the lexicographically m-th permutation of length n in the set of permutations having the maximum possible value of f(p).\n\nInput\n\nThe single line of input contains two integers n and m (1 ≤ m ≤ cntn), where cntn is the number of permutations of length n with maximum possible value of f(p).\n\nThe problem consists of two subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.\n\n  * In subproblem B1 (3 points), the constraint 1 ≤ n ≤ 8 will hold. \n  * In subproblem B2 (4 points), the constraint 1 ≤ n ≤ 50 will hold. \n\nOutput\n\nOutput n number forming the required permutation.\n\nExamples\n\nInput\n\n2 2\n\n\nOutput\n\n2 1 \n\n\nInput\n\n3 2\n\n\nOutput\n\n1 3 2 \n\nNote\n\nIn the first example, both permutations of numbers {1, 2} yield maximum possible f(p) which is equal to 4. Among them, (2, 1) comes second in lexicographical order.",
        "task_name": "513_B1. Permutations",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from math import factorial # python math library\n\n#strnumbers = str(lst)\n#listnumbers = list(strnumbers.split())\na,b = raw_input().split()\nn = int(a)\ni = int(b)   \ni = i-1               # n is the length of the permutation\np = range(1, n + 1) # p is a list from 1 to n\n\nfor k in range(1, n + 1): # k goes from 1 to n\n    f = factorial(n - k)  # compute factorial once per iteration\n    d = i // f            # use integer division (like division + floor)\n    print(p[d]),          # print permuted number with trailing space\n    p.remove(p[d])        # delete p[d] from p\n    i = i % f       ",
        "correct": false,
        "task_id": "4696"
    },
    {
        "description": "problem\n\nIn one programming contest, it is customary to play a bingo game at a social gathering after the competition. However, the bingo card used in this bingo game is a little special and is created according to the following conditions.\n\n* The Bingo card is divided into squares of N rows and N columns, and one positive integer is written in each square. All those integers are different.\n* The integer written in the square is 1 or more and M or less.\n* The sum of N × N integers written on the Bingo card is S.\n* When looking at any column, the integers are arranged in ascending order from top to bottom.\n* The integer in every square is larger than any integer in the column to the left of that square.\n\n\n\nThe following is an example of a Bingo card when N = 5, M = 50, S = 685.\n\n<image>\n\n\nI want to make as many bingo cards as possible that meet the above conditions for the social gathering. However, you must not make more than one same card. Create a program that outputs the remainder of the maximum number of Bingo cards that can be created divided by 100000.\n\n\n\ninput\n\nThe input consists of multiple datasets. Each dataset is given in the following format.\n\nThe input consists of one line, which contains the size of the bingo card N (1 ≤ N ≤ 7), the upper limit of the integers written in the square M (1 ≤ M ≤ 2000), and the bingo card. Three positive integers representing the sum of integers S (1 ≤ S ≤ 3000) are written separated by blanks. However, you can make one or more bingo cards that meet the conditions for any given input data.\n\nWhen N, M, S is 0, it indicates the end of input. The number of data sets does not exceed 5.\n\noutput\n\nFor each dataset, divide the maximum number of Bingo cards that can be created by 100000 and output the remainder on one line.\n\nExamples\n\nInput\n\n3 9 45\n3 100 50\n5 50 685\n0 0 0\n\n\nOutput\n\n1\n7\n74501\n\n\nInput\n\nNone\n\n\nOutput\n\nNone",
        "task_name": "p00460 Bingo",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "mod=100000\nwhile 1:\n    n,m,s=map(int,raw_input().split())\n    if n==m==s==0:break\n    dp=[[[0]*(s+1) for _ in xrange(m+2)] for _ in xrange(2)]\n    for i in xrange(n**2):\n        for j in xrange(1,m+1):\n            for k in xrange(1,s+1):\n                if i==0:\n                    if j>=k:\n                        dp[(i+1)&1][j+1][k]=1\n                else:\n                    if j>k:\n                        dp[(i+1)&1][j+1][k]=dp[(i+1)&1][j][k]\n                        continue\n                    dp[(i+1)&1][j+1][k]=(dp[(i+1)&1][j][k])%mod\n                    dp[(i+1)&1][j+1][k]+=(dp[i&1][j][k-j])%mod\n    print(dp[(n**2)&1][m+1][s]%mod)",
        "correct": false,
        "task_id": "5458"
    },
    {
        "description": "Yet another Armageddon is coming! This time the culprit is the Julya tribe calendar. \n\nThe beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish is as follows: \n\n\"May the Great Beaver bless you! May your chacres open and may your third eye never turn blind from beholding the Truth! Take the magic number, subtract a digit from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on Three Beavers for the time, equal to the number of subtractions you perform!\"\n\nDistinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to count the minimum number of operations he needs to reduce the magic number to zero.\n\nInput\n\nThe single line contains the magic integer n, 0 ≤ n.\n\n  * to get 20 points, you need to solve the problem with constraints: n ≤ 106 (subproblem C1); \n  * to get 40 points, you need to solve the problem with constraints: n ≤ 1012 (subproblems C1+C2); \n  * to get 100 points, you need to solve the problem with constraints: n ≤ 1018 (subproblems C1+C2+C3). \n\nOutput\n\nPrint a single integer — the minimum number of subtractions that turns the magic number to a zero.\n\nExamples\n\nInput\n\n24\n\n\nOutput\n\n5\n\nNote\n\nIn the first test sample the minimum number of operations can be reached by the following sequence of subtractions: \n\n24 → 20 → 18 → 10 → 9 → 0",
        "task_name": "331_C1. The Great Julya Calendar",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\ns = 0\nif(n % 10 != 0):\n    s = 1\nprint(2*(n/10) + s)",
        "correct": false,
        "task_id": "3008"
    },
    {
        "description": "A conglomerate consists of n companies. To make managing easier, their owners have decided to merge all companies into one. By law, it is only possible to merge two companies, so the owners plan to select two companies, merge them into one, and continue doing so until there is only one company left.\n\nBut anti-monopoly service forbids to merge companies if they suspect unfriendly absorption. The criterion they use is the difference in maximum salaries between two companies. Merging is allowed only if the maximum salaries are equal.\n\nTo fulfill the anti-monopoly requirements, the owners can change salaries in their companies before merging. But the labor union insists on two conditions: it is only allowed to increase salaries, moreover all the employees in one company must get the same increase.\n\nSure enough, the owners want to minimize the total increase of all salaries in all companies. Help them find the minimal possible increase that will allow them to merge companies into one.\n\nInput\n\nThe first line contains a single integer n — the number of companies in the conglomerate (1 ≤ n ≤ 2 ⋅ 10^5). Each of the next n lines describes a company. \n\nA company description start with an integer m_i — the number of its employees (1 ≤ m_i ≤ 2 ⋅ 10^5). Then m_i integers follow: the salaries of the employees. All salaries are positive and do not exceed 10^9. \n\nThe total number of employees in all companies does not exceed 2 ⋅ 10^5. \n\nOutput\n\nOutput a single integer — the minimal total increase of all employees that allows to merge all companies.\n\nExample\n\nInput\n\n\n3\n2 4 3\n2 2 1\n3 1 1 1\n\n\nOutput\n\n\n13\n\nNote\n\nOne of the optimal merging strategies is the following. First increase all salaries in the second company by 2, and merge the first and the second companies. Now the conglomerate consists of two companies with salaries [4, 3, 4, 3] and [1, 1, 1]. To merge them, increase the salaries in the second of those by 3. The total increase is 2 + 2 + 3 + 3 + 3 = 13.",
        "task_name": "1090_A. Company Merging",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\narr=[]\nmaxval=0\narr2=[]\nfor i in xrange(n):\n\tarr1=list(map(int,raw_input().split()))\n\ttemp=0\n\tfor j in xrange(1,arr1[0]):\n\t\ttemp=max(temp,arr1[j])\n\tarr.append(temp)\n\tarr2.append(arr1[0])\n\tmaxval=max(arr[i],maxval)\nans=0\nfor i in range(n):\n\tans+=(maxval-arr[i])*arr2[i]\n\nprint(ans)\n\n",
        "correct": false,
        "task_id": "3192"
    },
    {
        "description": "Let w be a string consisting of lowercase letters. We will call w beautiful if the following condition is satisfied:\n\n* Each lowercase letter of the English alphabet occurs even number of times in w.\n\n\n\nYou are given the string w. Determine if w is beautiful.\n\nConstraints\n\n* 1 \\leq |w| \\leq 100\n* w consists of lowercase letters (`a`-`z`).\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nw\n\n\nOutput\n\nPrint `Yes` if w is beautiful. Print `No` otherwise.\n\nExamples\n\nInput\n\nabaccaba\n\n\nOutput\n\nYes\n\n\nInput\n\nhthth\n\n\nOutput\n\nNo",
        "task_name": "p04012 AtCoder Beginner Contest 044 - Beautiful Strings",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def main():\n  s = raw_input()\n  memo = {}\n  for c in s:\n    if c not in memo:\n      memo[c] = 0\n    memo[c] += 1\n  \n  result = True\n  for x in memo.values():\n    if x % 2 > 0:\n      result = False\n      break\n  print(\"Yes\" if result else \"No\")\n\nmain()",
        "correct": true,
        "task_id": "1526"
    },
    {
        "description": "Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.\n\nThe elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.\n\nInput\n\nThe first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.\n\nThe next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.\n\nOutput\n\nPrint a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.\n\nExamples\n\nInput\n\n3 7\n2 1\n3 8\n5 2\n\n\nOutput\n\n11\n\n\nInput\n\n5 10\n2 77\n3 33\n8 21\n9 12\n10 64\n\n\nOutput\n\n79\n\nNote\n\nIn the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:\n\n1. Move to floor 5: takes 2 seconds.\n\n2. Pick up passenger 3.\n\n3. Move to floor 3: takes 2 seconds.\n\n4. Wait for passenger 2 to arrive: takes 4 seconds.\n\n5. Pick up passenger 2.\n\n6. Go to floor 2: takes 1 second.\n\n7. Pick up passenger 1.\n\n8. Go to floor 0: takes 2 seconds.\n\nThis gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.",
        "task_name": "608_A. Saitama Destroys Hotel",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, s = map(int, raw_input().split())\np = []\n\nfor i in range(n):\n    fi, ti = map(int, raw_input().split())\n    p.append((fi,ti))\n\np = sorted(p, key=lambda passenger: passenger[0], reverse=True)\np.append((0,0))\n\ntime_passed = 0\n\nfor i in range(n+1):\n    time_passed += s - p[i][0]\n    s = p[i][0]\n    if time_passed < p[i][1]:\n        time_passed += (p[i][1] - time_passed)\n\nprint(time_passed)\n",
        "correct": true,
        "task_id": "1590"
    },
    {
        "description": "You have n barrels lined up in a row, numbered from left to right from one. Initially, the i-th barrel contains a_i liters of water.\n\nYou can pour water from one barrel to another. In one act of pouring, you can choose two different barrels x and y (the x-th barrel shouldn't be empty) and pour any possible amount of water from barrel x to barrel y (possibly, all water). You may assume that barrels have infinite capacity, so you can pour any amount of water in each of them. \n\nCalculate the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most k times.\n\nSome examples: \n\n  * if you have four barrels, each containing 5 liters of water, and k = 1, you may pour 5 liters from the second barrel into the fourth, so the amounts of water in the barrels are [5, 0, 5, 10], and the difference between the maximum and the minimum is 10; \n  * if all barrels are empty, you can't make any operation, so the difference between the maximum and the minimum amount is still 0. \n\nInput\n\nThe first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe first line of each test case contains two integers n and k (1 ≤ k < n ≤ 2 ⋅ 10^5) — the number of barrels and the number of pourings you can make.\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the initial amount of water the i-th barrel has.\n\nIt's guaranteed that the total sum of n over test cases doesn't exceed 2 ⋅ 10^5.\n\nOutput\n\nFor each test case, print the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most k times.\n\nExample\n\nInput\n\n\n2\n4 1\n5 5 5 5\n3 2\n0 0 0\n\n\nOutput\n\n\n10\n0",
        "task_name": "1430_B. Barrels",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nt = int(sys.stdin.readline())\n\nfor i in range(0,t):\n    n,k = map(int,sys.stdin.readline().split(\" \"))\n    arr = list(map(int,sys.stdin.readline().split()))\n    arr = sorted(arr,reverse=True)\n    ans = arr[0]\n    if k >= n:\n        k = n-1\n    for l in range(1,k+1):\n        ans += arr[l]\n    print(ans)",
        "correct": true,
        "task_id": "2128"
    },
    {
        "description": "The statement of this problem is the same as the statement of problem C1. The only difference is that, in problem C1, n is always even, and in C2, n is always odd.\n\nYou are given a regular polygon with 2 ⋅ n vertices (it's convex and has equal sides and equal angles) and all its sides have length 1. Let's name it as 2n-gon.\n\nYour task is to find the square of the minimum size such that you can embed 2n-gon in the square. Embedding 2n-gon in the square means that you need to place 2n-gon in the square in such way that each point which lies inside or on a border of 2n-gon should also lie inside or on a border of the square.\n\nYou can rotate 2n-gon and/or the square.\n\nInput\n\nThe first line contains a single integer T (1 ≤ T ≤ 200) — the number of test cases.\n\nNext T lines contain descriptions of test cases — one per line. Each line contains single odd integer n (3 ≤ n ≤ 199). Don't forget you need to embed 2n-gon, not an n-gon.\n\nOutput\n\nPrint T real numbers — one per test case. For each test case, print the minimum length of a side of the square 2n-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\n\nExample\n\nInput\n\n\n3\n3\n5\n199\n\n\nOutput\n\n\n1.931851653\n3.196226611\n126.687663595",
        "task_name": "1354_C2. Not So Simple Polygon Embedding",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Educational Code Forces Round 87: C2: Not So Simple Polygon Embedding.\n# Sun. May. 17, 2020, By: arccosh.\n\nimport math\n\ndef solve(n):\n  return math.cos(math.pi / (4 * n)) / math.sin(math.pi / (2 * n))\n\nfor ca in xrange(int(raw_input())):\n  n = int(raw_input())\n  print('%.9f' % solve(n))\n",
        "correct": true,
        "task_id": "0098"
    },
    {
        "description": "You are given string S and T consisting of lowercase English letters.\n\nDetermine if S equals T after rotation.\n\nThat is, determine if S equals T after the following operation is performed some number of times:\n\nOperation: Let S = S_1 S_2 ... S_{|S|}. Change S to S_{|S|} S_1 S_2 ... S_{|S|-1}.\n\nHere, |X| denotes the length of the string X.\n\nConstraints\n\n* 2 \\leq |S| \\leq 100\n* |S| = |T|\n* S and T consist of lowercase English letters.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nS\nT\n\n\nOutput\n\nIf S equals T after rotation, print `Yes`; if it does not, print `No`.\n\nExamples\n\nInput\n\nkyoto\ntokyo\n\n\nOutput\n\nYes\n\n\nInput\n\nabc\narc\n\n\nOutput\n\nNo\n\n\nInput\n\naaaaaaaaaaaaaaab\naaaaaaaaaaaaaaab\n\n\nOutput\n\nYes",
        "task_name": "p03293 AtCoder Beginner Contest 103 - String Rotation",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s = raw_input()\nt = raw_input()\nprint [\"No\", \"Yes\"][ any( t[i:]+t[:i]==s for i in range(len(t)) ) ]",
        "correct": true,
        "task_id": "0689"
    }
]