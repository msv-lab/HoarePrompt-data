[
    {
        "description": "Consider an analog clock whose hour and minute hands are A and B centimeters long, respectively.\n\nAn endpoint of the hour hand and an endpoint of the minute hand are fixed at the same point, around which each hand rotates clockwise at constant angular velocity. It takes the hour and minute hands 12 hours and 1 hour to make one full rotation, respectively.\n\nAt 0 o'clock, the two hands overlap each other. H hours and M minutes later, what is the distance in centimeters between the unfixed endpoints of the hands?\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq A, B \\leq 1000\n* 0 \\leq H \\leq 11\n* 0 \\leq M \\leq 59\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nA B H M\n\n\nOutput\n\nPrint the answer without units. Your output will be accepted when its absolute or relative error from the correct value is at most 10^{-9}.\n\nExamples\n\nInput\n\n3 4 9 0\n\n\nOutput\n\n5.00000000000000000000\n\n\nInput\n\n3 4 10 40\n\n\nOutput\n\n4.56425719433005567605",
        "task_name": "p02677 AtCoder Beginner Contest 168 - : (Colon)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nfrom math import cos, sin, radians\n\na,b,h,m = (int(x) for x in input().split())\nt1 = radians(((h%12) * 30) + m*0.5)\nt2 = radians(((m%60) * 6))\n\nx1 = -a*sin(-t1)\ny1 = a*cos(-t1)\nx2 = -b*sin(-t2)\ny2 = b*cos(-t2)\nprint(((x2-x1)**2+(y2-y1)**2)**0.5)\n",
        "correct": true,
        "task_id": "1521"
    },
    {
        "description": "Determine if an N-sided polygon (not necessarily convex) with sides of length L_1, L_2, ..., L_N can be drawn in a two-dimensional plane.\n\nYou can use the following theorem:\n\nTheorem: an N-sided polygon satisfying the condition can be drawn if and only if the longest side is strictly shorter than the sum of the lengths of the other N-1 sides.\n\nConstraints\n\n* All values in input are integers.\n* 3 \\leq N \\leq 10\n* 1 \\leq L_i \\leq 100\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nL_1 L_2 ... L_N\n\n\nOutput\n\nIf an N-sided polygon satisfying the condition can be drawn, print `Yes`; otherwise, print `No`.\n\nExamples\n\nInput\n\n4\n3 8 5 1\n\n\nOutput\n\nYes\n\n\nInput\n\n4\n3 8 4 1\n\n\nOutput\n\nNo\n\n\nInput\n\n10\n1 8 10 5 8 12 34 100 11 3\n\n\nOutput\n\nNo",
        "task_name": "p03136 AtCoder Beginner Contest 117 - Polygon",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N = int(input())\nlistL = [int(i) for i in raw_input().split()]\nmaxL = max(listL)\nsum = 0\nfor i in range(N):\n    sum = sum + listL[i]\n\nsum = sum - maxL\n\nif maxL < sum:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "correct": true,
        "task_id": "2196"
    },
    {
        "description": "You are playing the game \"Arranging The Sheep\". The goal of this game is to make the sheep line up. The level in the game is described by a string of length n, consisting of the characters '.' (empty space) and '*' (sheep). In one move, you can move any sheep one square to the left or one square to the right, if the corresponding square exists and is empty. The game ends as soon as the sheep are lined up, that is, there should be no empty cells between any sheep.\n\nFor example, if n=6 and the level is described by the string \"**.*..\", then the following game scenario is possible: \n\n  * the sheep at the 4 position moves to the right, the state of the level: \"**..*.\"; \n  * the sheep at the 2 position moves to the right, the state of the level: \"*.*.*.\"; \n  * the sheep at the 1 position moves to the right, the state of the level: \".**.*.\"; \n  * the sheep at the 3 position moves to the right, the state of the level: \".*.**.\"; \n  * the sheep at the 2 position moves to the right, the state of the level: \"..***.\"; \n  * the sheep are lined up and the game ends. \n\n\n\nFor a given level, determine the minimum number of moves you need to make to complete the level.\n\nInput\n\nThe first line contains one integer t (1 ≤ t ≤ 10^4). Then t test cases follow.\n\nThe first line of each test case contains one integer n (1 ≤ n ≤ 10^6).\n\nThe second line of each test case contains a string of length n, consisting of the characters '.' (empty space) and '*' (sheep) — the description of the level.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nFor each test case output the minimum number of moves you need to make to complete the level.\n\nExample\n\nInput\n\n\n5\n6\n**.*..\n5\n*****\n3\n.*.\n3\n...\n10\n*.*...*.**\n\n\nOutput\n\n\n1\n0\n0\n0\n9",
        "task_name": "1520_E. Arranging The Sheep",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division,print_function\nfrom heapq import*\nimport sys\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\naf=[]\nfor zorg in range(int(le.pop())):\n    n=int(le.pop())\n    l= le.pop()\n    l=[k for k in range(n) if l[k]==\"*\"]\n    l=[b-a for a,b in enumerate(l)]\n    if l:\n        med=l[len(l)//2]\n        af.append(sum(abs(k-med) for k in l))\n    else:\n        af.append(0)\nprint(\"\\n\".join(map(str,af)))\n",
        "correct": true,
        "task_id": "2045"
    },
    {
        "description": "You are given a string s consisting only of characters + and -. You perform some process with this string. This process can be described by the following pseudocode: \n    \n    \n    res = 0  \n    for init = 0 to inf  \n        cur = init  \n        ok = true  \n        for i = 1 to |s|  \n            res = res + 1  \n            if s[i] == '+'  \n                cur = cur + 1  \n            else  \n                cur = cur - 1  \n            if cur < 0  \n                ok = false  \n                break  \n        if ok  \n            break  \n    \n\nNote that the inf denotes infinity, and the characters of the string are numbered from 1 to |s|.\n\nYou have to calculate the value of the res after the process ends.\n\nInput\n\nThe first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe only lines of each test case contains string s (1 ≤ |s| ≤ 10^6) consisting only of characters + and -.\n\nIt's guaranteed that sum of |s| over all test cases doesn't exceed 10^6.\n\nOutput\n\nFor each test case print one integer — the value of the res after the process ends.\n\nExample\n\nInput\n\n\n3\n--+-\n---\n++--+-\n\n\nOutput\n\n\n7\n9\n6",
        "task_name": "1373_C. Pluses and Minuses",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import deque\nimport sys\ndef inp():\n    return sys.stdin.readline().strip()\n#njncnjac\n\nfor _ in range(int(inp())):\n    ans=0\n    s=inp()\n    prefix=[0]*(len(s))\n    for i in range(len(s)):\n        if s[i]=='+':\n            prefix[i]+=1\n        #ddbksdv   \n        else:\n            prefix[i]-=1\n        if i-1>=0:\n            prefix[i]+=prefix[i-1]\n    imp=[]\n    used=set()\n    for i in range(len(prefix)):\n        if prefix[i]<0 and prefix[i] not in used:\n            imp.append((prefix[i],i))\n            used.add(prefix[i])\n    mn=0\n    for i in range(len(imp)):\n        if mn+imp[i][0]>=0:\n            continue\n        else:\n            diff=abs(mn-imp[i][0])\n            mn=imp[i][0]\n            ans+=diff*(imp[i][1]+1)\n   \n    print(ans+len(s))",
        "correct": true,
        "task_id": "2306"
    },
    {
        "description": "Arkady needs your help again! This time he decided to build his own high-speed Internet exchange point. It should consist of n nodes connected with minimum possible number of wires into one network (a wire directly connects two nodes). Exactly k of the nodes should be exit-nodes, that means that each of them should be connected to exactly one other node of the network, while all other nodes should be connected to at least two nodes in order to increase the system stability.\n\nArkady wants to make the system as fast as possible, so he wants to minimize the maximum distance between two exit-nodes. The distance between two nodes is the number of wires a package needs to go through between those two nodes.\n\nHelp Arkady to find such a way to build the network that the distance between the two most distant exit-nodes is as small as possible.\n\nInput\n\nThe first line contains two integers n and k (3 ≤ n ≤ 2·105, 2 ≤ k ≤ n - 1) — the total number of nodes and the number of exit-nodes.\n\nNote that it is always possible to build at least one network with n nodes and k exit-nodes within the given constraints.\n\nOutput\n\nIn the first line print the minimum possible distance between the two most distant exit-nodes. In each of the next n - 1 lines print two integers: the ids of the nodes connected by a wire. The description of each wire should be printed exactly once. You can print wires and wires' ends in arbitrary order. The nodes should be numbered from 1 to n. Exit-nodes can have any ids.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n3 2\n\n\nOutput\n\n2\n1 2\n2 3\n\n\nInput\n\n5 3\n\n\nOutput\n\n3\n1 2\n2 3\n3 4\n3 5\n\nNote\n\nIn the first example the only network is shown on the left picture.\n\nIn the second example one of optimal networks is shown on the right picture.\n\nExit-nodes are highlighted.\n\n<image>",
        "task_name": "827_B. High Load",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\n\ndef connection_with_length(startIndex, branchLength):\n    print(\"{0} {1}\".format(1, startIndex))\n    for i in xrange(startIndex, startIndex + branchLength - 1):\n        print(\"{0} {1}\".format(i, i + 1))\n    return startIndex + branchLength\n\n\nn, k = map(int, stdin.readline().split())\nminLength = (n - 1) // k\nr = (n - 1) % k\n\nmaxDistance = minLength * 2 + (2 if r >= 2 else r)\nprint(maxDistance)\n\nminLengthCount = k - r\nstartIndex = 2\nfor _ in xrange(0, minLengthCount):\n    startIndex = connection_with_length(startIndex, minLength)\nfor _ in xrange(0, r):\n    startIndex = connection_with_length(startIndex, minLength + 1)\n",
        "correct": true,
        "task_id": "4043"
    }
]