# Your task:

Problem description: The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.

However, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length n whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.

Input

The first line contains an integer t (1 ≤ t ≤ 5000) — the number of test cases.

The first line of each test case contains an integer n (3 ≤ n < 10^5), the number of characters in the string entered in the document. It is guaranteed that n is divisible by 3.

The second line of each test case contains a string of length n consisting of only the characters T and M.

It is guaranteed that the sum of n over all test cases does not exceed 10^5.

Output

For each test case, print a single line containing YES if the described partition exists, and a single line containing NO otherwise.

Example

Input

5
3
TMT
3
MTT
6
TMTMTT
6
TMTTTT
6
TTMMTT

Output

YES
NO
YES
NO
YES

Note

In the first test case, the string itself is already a sequence equal to TMT.

In the third test case, we may partition the string into the subsequences TMTMTT. Both the bolded and the non-bolded subsequences are equal to TMT.

Functions with output description for each function:
Function number 1 :
 Code:
 '''
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        t = deque()
        m = deque()
        for (i, si) in enumerate(s):
            if si == 'T':
                t.append(i)
            else:
                m.append(i)
        poss = len(m) * 2 == len(t)
        if poss:
            arr = [0] * (len(t) // 2)
            for i in range(len(t) // 2):
                poss &= t.popleft() < m[0]
                arr[i] = m.popleft()
            for i in arr:
                poss &= i < t.popleft()
        func_2('YES' if poss else 'NO')
''' 

 Output decription for function1:  The function `func_1` reads input values, processes them based on the conditions specified in the code, and calls another function `func_2` with either 'YES' or 'NO' as an argument. It iterates over the input test cases, checks for the equality of 'T' and non-'T' characters in the input string, and modifies the state of various variables accordingly. The function does not accept any parameters and does not return any value.
Function number 2 :
 Code:
 '''
def func_2(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_1()
''' 

 Output decription for function2:  The function `func_2` does not accept any parameters. It iterates through the `args` list, writing each element to the output stream specified by the `file` argument. If `args` is empty, nothing is written. The function then writes the value specified by the 'end' key in `kwargs` to the output stream, defaulting to a newline. If the 'flush' key is present in `kwargs` with a truthy value, the output stream is flushed. The function does not explicitly return any value.

Now let's analyze the code provided and determine its correctness.

Initial Assessment:
- The code reads input values for the number of test cases and the strings for each test case.
- It then processes the strings to check if the partition into subsequences of 'TMT' can be achieved.
- The code logic involves checking the occurrence of 'T' and 'M' characters and ensuring they can form the required subsequences.
- The output function prints 'YES' if the partition exists and 'NO' otherwise.

Based on the initial assessment, the code seems to be following the problem description and should be able to determine if the partition into 'TMT' subsequences is possible for each test case. 

Next, let's check if the output hints agree with the code and if they provide any additional insight into potential edge cases.

Output Hint Analysis:
- The output hints do not provide specific edge cases but rather describe the general functionality of the functions and their purpose.
- The hints mention that the code iterates over test cases, checks for 'T' and non-'T' characters, and modifies variables accordingly to determine the possibility of the required partition.
- The output hints do not suggest any inconsistencies or cases where the code may not work as expected.

Based on the code logic and the agreement with the output hints, it seems that the code is correctly implemented to solve the problem as described.

Therefore, the Correctness is: **True**.