
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You have a sequence a with n elements 1, 2, 3, ..., k - 1, k, k - 1, k - 2, ..., k - (n - k) (k ≤ n < 2k).

Let's call as inversion in a a pair of indices i < j such that a[i] > a[j].

Suppose, you have some permutation p of size k and you build a sequence b of size n in the following manner: b[i] = p[a[i]].

Your goal is to find such permutation p that the total number of inversions in b doesn't exceed the total number of inversions in a, and b is lexicographically maximum.

Small reminder: the sequence of k integers is called a permutation if it contains all integers from 1 to k exactly once.

Another small reminder: a sequence s is lexicographically smaller than another sequence t, if either s is a prefix of t, or for the first i such that s_i ≠ t_i, s_i < t_i holds (in the first position that these sequences are different, s has smaller number than t).

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first and only line of each test case contains two integers n and k (k ≤ n < 2k; 1 ≤ k ≤ 10^5) — the length of the sequence a and its maximum.

It's guaranteed that the total sum of k over test cases doesn't exceed 10^5.

Output

For each test case, print k integers — the permutation p which maximizes b lexicographically without increasing the total number of inversions.

It can be proven that p exists and is unique.

Example

Input


4
1 1
2 2
3 2
4 3


Output


1 
1 2 
2 1 
1 3 2 

Note

In the first test case, the sequence a = [1], there is only one permutation p = [1].

In the second test case, the sequence a = [1, 2]. There is no inversion in a, so there is only one permutation p = [1, 2] which doesn't increase the number of inversions.

In the third test case, a = [1, 2, 1] and has 1 inversion. If we use p = [2, 1], then b = [p[a[1]], p[a[2]], p[a[3]]] = [2, 1, 2] and also has 1 inversion.

In the fourth test case, a = [1, 2, 3, 2], and since p = [1, 3, 2] then b = [1, 3, 2, 3]. Both a and b have 1 inversion and b is the lexicographically maximum.
Annotated Program:
```
#Function 1:
def func_1():
    return int(input())
    #The program returns the integer value obtained from the input

#Function 2:
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers created by mapping the input string split by spaces into integers

#Function 3:
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list containing all characters of the input string 's' except for the last character.

#Function 4:
def func_4():
    s = input()
    return s[:len(s) - 1]
    #The program returns a string 's' with the last character removed

#Function 5:
def func_5(l):
    print(' '.join(map(str, l)))

#Function 6:
def func_6(BITree, index):
    sum = 0
    while index > 0:
        sum += BITree[index]
        
        index -= index & -index
        
    #State of the program after the loop has been executed: If index is greater than 0, then sum is the sum of the values at the corresponding indices in the BITree, and index is updated to reflect the next index after decreasing by the lowest set bit in its binary representation. If index is 0 or negative, the loop does not execute, and the final state is the sum of the values at the corresponding indices in the BITree with the last updated index
    return sum
    #The program returns the sum of the values at the corresponding indices in the BITree with the last updated index

#Function 7:
def func_7(BITree, n, index, val):
    while index <= n:
        BITree[index] += val
        
        index += index & -index
        
    #State of the program after the loop has been executed: `BITree[index]` is increased by `val`, `index` is updated based on the calculation, `n` remains the same. If `index` is greater than `n` initially, the loop will not execute.

#Function 8:
def func_8(arr, n):
    invcount = 0
    maxElement = max(arr)
    BIT = [0] * (maxElement + 1)
    for i in range(1, maxElement + 1):
        BIT[i] = 0
        
    #State of the program after the  for loop has been executed: After the loop executes, `arr` remains a list of integers, `n` remains a positive integer representing the length of `arr`, `invcount` remains 0, `maxElement` remains the same value as before the loop, and `BIT` is a list of zeros with a length of at least `maxElement + 1` where each element is 0. The loop will always execute as long as `maxElement` is greater than or equal to 1, ensuring that all elements in `BIT` are set to 0. If `maxElement` is less than 1, the loop will not execute, leaving `BIT` as a list of zeros with a length of 1.
    for i in range(n - 1, -1, -1):
        invcount += func_6(BIT, arr[i] - 1)
        
        func_7(BIT, maxElement, arr[i], 1)
        
    #State of the program after the  for loop has been executed: Output State: If `maxElement` is greater than or equal to 1, the loop will execute and adjust `n` accordingly. After the loop executes, `arr` remains a list of integers, `invcount` is increased by the return value of `func_6(BIT, arr[i] - 1)` for each iteration, `maxElement` remains the same, and `BIT` is a list of zeros with a length of at least `maxElement + 1` where each element is 0. If `maxElement` is less than 1, the loop does not execute, leaving `BIT` as a list of zeros with a length of 1.
    return invcount
    #The program returns the final value of 'invcount' after the loop execution

#Function 9:
def func_9():
    n, k = func_2()
    if (n == k) :
        return range(1, k + 1)
        #The program returns a range starting from 1 up to and including the value of k
    #State of the program after the if block has been executed: *`n` and `k` are integers. If `n` equals `k`, the program returns a range starting from 1 up to and including the value of `k`. Otherwise, there is no change in the state of the program variables.
    if (n == k + 1) :
        return range(1, k + 1 - 2) + [k, k - 1]
        #The program returns a range starting from 1 up to and including the value of `k` concatenated with values `k` and `k-1`
    #State of the program after the if block has been executed: *`n` and `k` are integers. If `n` equals `k`, the program returns a range starting from 1 up to and including the value of `k`. If `n` is equal to `k + 1`, the program returns a range from 1 up to `k - 1` concatenated with `k` and `k - 1`. Otherwise, there is no change in the state of the program variables.
    a = range(1, k + 1) + range(k - 1, 2 * k - n - 1, -1)
    maxInv = func_8(a, n)
    for i in xrange(2 * k - n, k):
        a[k - 1] = i
        
        a[k - 2] = k
        
        a[k] = k
        
        curInv = func_8(a, n)
        
        if curInv <= maxInv:
            ans = range(1, k + 1)
            ans[k - 1] = i
            ans[i - 1] = k
            return ans
        
    #State of the program after the  for loop has been executed: If 2 * k - n is greater than or equal to k, the loop does not execute. Otherwise, a range from 1 to k is returned where the k-th element is assigned the value of the last i and the i-th element is assigned the value of k.


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
