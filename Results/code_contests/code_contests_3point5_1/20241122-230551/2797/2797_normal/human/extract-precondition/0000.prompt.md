
You are given a programming problem description and a program that solves to this problem. From the problem description, extract a description of the values of the program's input variables and relationship between these variables. We refer to this description as precondition. Print the precondition following the word "Precondition", and surrounded with double asterisks (**). Follow these examples:

# Example 1

Problem description: write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].
Program:
```
R = 3
C = 3
def min_cost(cost, m, n):
	tc = [[0 for x in range(C)] for x in range(R)]
	tc[0][0] = cost[0][0]
	for i in range(1, m+1):
		tc[i][0] = tc[i-1][0] + cost[i][0]
	for j in range(1, n+1):
		tc[0][j] = tc[0][j-1] + cost[0][j]
	for i in range(1, m+1):
		for j in range(1, n+1):
			tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
	return tc[m][n]
```

Precondition: **cost is a 2D list of non-negative integers, m and n are non-negative integers such that 0 <= m < len(cost) and 0 <= n < len(cost[0]).**

# Example 2

Problem description: Write a function to find the similar elements from the given two tuple lists.
Program:
```
def similar_elements(test_tup1, test_tup2):
  res = tuple(set(test_tup1) & set(test_tup2))
  return (res) 
```

Precondition: **test_tup1 and test_tup2 are tuples.**

# Example 3

Problem description: Write a python function to identify non-prime numbers.
Program:
```
import math
def is_not_prime(n):
    result = False
    for i in range(2,int(math.sqrt(n)) + 1):
        if n % i == 0:
            result = True
    return result
```

Precondition: **n is an integer greater than 1.**

# Example 4

Problem description: Write a function to find the largest integers from a given list of numbers using heap queue algorithm.
Program:
```
import heapq as hq
def heap_queue_largest(nums,n):
  largest_nums = hq.nlargest(n, nums)
  return largest_nums
```

Precondition: **nums is a list of integers, and n is a non-negative integer such that 0 <= n <= len(nums).**

# Example 5

Problem description: Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.
Program:
```
def count_ways(n):
  A = [0] * (n + 1)
  B = [0] * (n + 1)
  A[0] = 1
  A[1] = 0
  B[0] = 0
  B[1] = 1
  for i in range(2, n+1):
    A[i] = A[i - 2] + 2 * B[i - 1]
    B[i] = A[i - 1] + B[i - 2]
  return A[n] 
```

Precondition: **n is a non-negative integer.**

# Your task

Problem description: Kris works in a large company "Blake Technologies". As a best engineer of the company he was assigned a task to develop a printer that will be able to print horizontal and vertical strips. First prototype is already built and Kris wants to tests it. He wants you to implement the program that checks the result of the printing.

Printer works with a rectangular sheet of paper of size n × m. Consider the list as a table consisting of n rows and m columns. Rows are numbered from top to bottom with integers from 1 to n, while columns are numbered from left to right with integers from 1 to m. Initially, all cells are painted in color 0.

Your program has to support two operations: 

  1. Paint all cells in row ri in color ai; 
  2. Paint all cells in column ci in color ai. 



If during some operation i there is a cell that have already been painted, the color of this cell also changes to ai.

Your program has to print the resulting table after k operation.

Input

The first line of the input contains three integers n, m and k (1 ≤ n, m ≤ 5000, n·m ≤ 100 000, 1 ≤ k ≤ 100 000) — the dimensions of the sheet and the number of operations, respectively.

Each of the next k lines contains the description of exactly one query: 

  * 1 ri ai (1 ≤ ri ≤ n, 1 ≤ ai ≤ 109), means that row ri is painted in color ai; 
  * 2 ci ai (1 ≤ ci ≤ m, 1 ≤ ai ≤ 109), means that column ci is painted in color ai. 

Output

Print n lines containing m integers each — the resulting table after all operations are applied.

Examples

Input

3 3 3
1 1 3
2 2 1
1 2 2


Output

3 1 3 
2 2 2 
0 1 0 


Input

5 3 5
1 1 1
1 3 1
1 5 1
2 1 1
2 3 1


Output

1 1 1 
1 0 1 
1 1 1 
1 0 1 
1 1 1 

Note

The figure below shows all three operations for the first sample step by step. The cells that were painted on the corresponding step are marked gray. 

<image>
Program:
```

def func():
    (n, m, k) = map(int, raw_input().split())
    l = [[0 for j in range(m)] for i in range(n)]
    'for i in range(n):\n        for j in range(m):\n            print l[i][j],\n        print'
    while k > 0:
        k -= 1
        (a, b, c) = map(int, raw_input().split())
        if a == 1:
            for i in range(m):
                l[b - 1][i] = c
        else:
            for i in range(n):
                l[i][b - 1] = c
    print('\n'.join([''.join(['{:2}'.format(item) for item in row]) for row in l]))
```

