Task ID,Dataset,model_created,model_run,description,Code,Test Result,Correctness,Post,original correctness,naive correctness,annotated correctness,naive no fsl correctness,data file
2845,code_contests,human,gpt-3.5-turbo-0125,"You are given an array a consisting of n positive integers. You pick two integer numbers l and r from 1 to n, inclusive (numbers are picked randomly, equiprobably and independently). If l > r, then you swap values of l and r. You have to calculate the expected value of the number of unique elements in segment of the array from index l to index r, inclusive (1-indexed).

Input

The first line contains one integer number n (1 ≤ n ≤ 106). The second line contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 106) — elements of the array.

Output

Print one number — the expected number of unique elements in chosen segment. 

Your answer will be considered correct if its absolute or relative error doesn't exceed 10 - 4 — formally, the answer is correct if <image>, where x is jury's answer, and y is your answer.

Examples

Input

2
1 2


Output

1.500000


Input

2
2 2


Output

1.000000","n = int(raw_input())
arr = map(int,raw_input().split("" ""))

req = len(set(arr))

print ((req + 1))/2",,False,post,False,False,False,False,code_contests3.json
2685,code_contests,human,gpt-3.5-turbo-0125,"International Women's Day is coming soon! Polycarp is preparing for the holiday.

There are n candy boxes in the shop for sale. The i-th box contains d_i candies.

Polycarp wants to prepare the maximum number of gifts for k girls. Each gift will consist of exactly two boxes. The girls should be able to share each gift equally, so the total amount of candies in a gift (in a pair of boxes) should be divisible by k. In other words, two boxes i and j (i ≠ j) can be combined as a gift if d_i + d_j is divisible by k.

How many boxes will Polycarp be able to give? Of course, each box can be a part of no more than one gift. Polycarp cannot use boxes ""partially"" or redistribute candies between them. 

Input

The first line of the input contains two integers n and k (1 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ k ≤ 100) — the number the boxes and the number the girls.

The second line of the input contains n integers d_1, d_2, ..., d_n (1 ≤ d_i ≤ 10^9), where d_i is the number of candies in the i-th box.

Output

Print one integer — the maximum number of the boxes Polycarp can give as gifts.

Examples

Input


7 2
1 2 2 3 2 4 10


Output


6


Input


8 2
1 2 2 3 2 4 6 10


Output


8


Input


7 3
1 2 2 3 2 4 5


Output


4

Note

In the first example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): 

  * (2, 3); 
  * (5, 6); 
  * (1, 4). 



So the answer is 6.

In the second example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): 

  * (6, 8); 
  * (2, 3); 
  * (1, 4); 
  * (5, 7). 



So the answer is 8.

In the third example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): 

  * (1, 2); 
  * (6, 7). 



So the answer is 4.","l, k = map(lambda i: int(i), raw_input().split(' '))
candy_list = map(lambda i: int(i), raw_input().split(' '))

def max_boxes(k, candy_array):
    res_map = {}
    res = 0
    for candy in candy_array:
        if res_map.has_key(k - candy % k) and res_map[k - candy % k] > 0:
            res += 2
            res_map[k - candy % k] = res_map[k - candy % k] - 1
        else:
            res_map[candy % k] = res_map[candy % k] + 1 if res_map.has_key(candy % k) else 1
    print(res)

max_boxes(k, candy_list)
",,True,post,False,False,True,False,code_contests3.json
4175,code_contests,human,gpt-3.5-turbo-0125,"Given are a positive integer N and a sequence of length 2^N consisting of 0s and 1s: A_0,A_1,\ldots,A_{2^N-1}. Determine whether there exists a closed curve C that satisfies the condition below for all 2^N sets S \subseteq \\{0,1,\ldots,N-1 \\}. If the answer is yes, construct one such closed curve.

* Let x = \sum_{i \in S} 2^i and B_S be the set of points \\{ (i+0.5,0.5) | i \in S \\}.
* If there is a way to continuously move the closed curve C without touching B_S so that every point on the closed curve has a negative y-coordinate, A_x = 1.
* If there is no such way, A_x = 0.



For instruction on printing a closed curve, see Output below.

Constraints

* 1 \leq N \leq 8
* A_i = 0,1 \quad (0 \leq i \leq 2^N-1)
* A_0 = 1

Input

Input is given from Standard Input in the following format:


N
A_0A_1 \cdots A_{2^N-1}


Output

If there is no closed curve that satisfies the condition, print `Impossible`.

If such a closed curve exists, print `Possible` in the first line. Then, print one such curve in the following format:


L
x_0 y_0
x_1 y_1
:
x_L y_L


This represents the closed polyline that passes (x_0,y_0),(x_1,y_1),\ldots,(x_L,y_L) in this order.

Here, all of the following must be satisfied:

* 0 \leq x_i \leq N, 0 \leq y_i \leq 1, and x_i, y_i are integers. (0 \leq i \leq L)
* |x_i-x_{i+1}| + |y_i-y_{i+1}| = 1. (0 \leq i \leq L-1)
* (x_0,y_0) = (x_L,y_L).



Additionally, the length of the closed curve L must satisfy 0 \leq L \leq 250000.

It can be proved that, if there is a closed curve that satisfies the condition in Problem Statement, there is also a closed curve that can be expressed in this format.

Examples

Input

1
10


Output

Possible
4
0 0
0 1
1 1
1 0
0 0


Input

2
1000


Output

Possible
6
1 0
2 0
2 1
1 1
0 1
0 0
1 0


Input

2
1001


Output

Impossible


Input

1
11


Output

Possible
0
1 1","def rev(a):
    return [-v for v in a]

def make(s):
    assert len(s)>0
    pre_s = s[:-1]
    v = s[-1]
    if len(pre_s)==0:
        return [v]
    return make(pre_s) + [v] + rev(make(pre_s)) + [-v]

def make_pre_path(v):
    if v>0:
        return [(i,0) for i in range(1,v+1)] + [(v,1), (v-1,1)] + [(i,0) for i in range(v-1,0,-1)]
    elif v<0:
        return make_pre_path(-v)[::-1]
    assert False

def make_path(v):
    return make_pre_path(v)+[(0,0)]

def test():
    #print(make([1,2,3]))
    main(""1"",""11"")
    #main(""8"",""1""+""0""*(2**8-1))

def main(s1,s2):
    ok = True
    n = int(s1)
    ret_gp = []
    for i in range(2**n-1,-1,-1):
        s = [v+1 for v in range(n) if (i>>v)%2==1 ]
        if s2[i]==""0"":
            for ind in range(n):
                if (i>>ind)%2==0 and s2[(i+2**ind)]==""1"":
                    ok = False
            ret_gp += make(s)
    ret_path = [(0,0)] + [p for v in ret_gp for p in make_path(v)]
    if ok:
        print(""Possible"")
        print(len(ret_path) - 1)
        for x,y in ret_path:
            print(str(x)+"" ""+str(y))
    else:
        print(""Impossible"")

s1 = raw_input()
s2 = raw_input()
main(s1,s2)",,True,post,False,True,True,True,code_contests3.json
0200,code_contests,human,gpt-3.5-turbo-0125,"Let's denote a function 

<image>

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.

Input

The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.

The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 

Output

Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.

Examples

Input

5
1 2 3 1 3


Output

4


Input

4
6 6 5 5


Output

0


Input

4
6 6 4 4


Output

-8

Note

In the first example:

  1. d(a1, a2) = 0; 
  2. d(a1, a3) = 2; 
  3. d(a1, a4) = 0; 
  4. d(a1, a5) = 2; 
  5. d(a2, a3) = 0; 
  6. d(a2, a4) = 0; 
  7. d(a2, a5) = 0; 
  8. d(a3, a4) = - 2; 
  9. d(a3, a5) = 0; 
  10. d(a4, a5) = 2. ","n = int(raw_input())
a = list(map(int, raw_input().split()))
sm = 0
m = dict()
ans = 0
for i in range(n-1, -1, -1):
    cnt = 0
    diff = 0
    if a[i] in m:
        cnt += m[a[i]]
        diff += a[i]*m[a[i]]
    if a[i]+1 in m:
        cnt += m[a[i]+1]
        diff += (a[i]+1)*m[a[i]+1]
    if a[i]-1 in m:
        cnt += m[a[i]-1]
        diff += (a[i]-1)*m[a[i]-1]
    ans += sm-diff-a[i]*(n-i-1-cnt)
    sm += a[i]
    if a[i] in m:
        m[a[i]] += 1
    else:
        m[a[i]] = 1
print(ans)
",,True,post,True,True,True,True,code_contests3.json
4204,code_contests,human,gpt-3.5-turbo-0125,"The city Valera lives in is going to hold elections to the city Parliament.

The city has n districts and n - 1 bidirectional roads. We know that from any district there is a path along the roads to any other district. Let's enumerate all districts in some way by integers from 1 to n, inclusive. Furthermore, for each road the residents decided if it is the problem road or not. A problem road is a road that needs to be repaired.

There are n candidates running the elections. Let's enumerate all candidates in some way by integers from 1 to n, inclusive. If the candidate number i will be elected in the city Parliament, he will perform exactly one promise — to repair all problem roads on the way from the i-th district to the district 1, where the city Parliament is located.

Help Valera and determine the subset of candidates such that if all candidates from the subset will be elected to the city Parliament, all problem roads in the city will be repaired. If there are several such subsets, you should choose the subset consisting of the minimum number of candidates.

Input

The first line contains a single integer n (2 ≤ n ≤ 105) — the number of districts in the city.

Then n - 1 lines follow. Each line contains the description of a city road as three positive integers xi, yi, ti (1 ≤ xi, yi ≤ n, 1 ≤ ti ≤ 2) — the districts connected by the i-th bidirectional road and the road type. If ti equals to one, then the i-th road isn't the problem road; if ti equals to two, then the i-th road is the problem road.

It's guaranteed that the graph structure of the city is a tree.

Output

In the first line print a single non-negative number k — the minimum size of the required subset of candidates. Then on the second line print k space-separated integers a1, a2, ... ak — the numbers of the candidates that form the required subset. If there are multiple solutions, you are allowed to print any of them.

Examples

Input

5
1 2 2
2 3 2
3 4 2
4 5 2


Output

1
5 


Input

5
1 2 1
2 3 2
2 4 1
4 5 1


Output

1
3 


Input

5
1 2 2
1 3 2
1 4 2
1 5 2


Output

4
5 4 3 2 ","def dfs(no, grafo, visitados, depth, cand):
    if no[1]:
        cand['value'] = max(cand['value'], no[0])
    visitados[no[0]] = True

    for vizinho in grafo[no[0]]:
        if not visitados[vizinho[0]]:
            dfs(vizinho, grafo, visitados, depth+1, cand)
            
n = int(raw_input())
grafo = [[] for _ in xrange(n+1)]


for i in xrange(1,n):
    a,b,t = map(int, raw_input().split())
    grafo[a].append((b,False if t == 1 else True))
    grafo[b].append((a,False if t == 1 else True))



visitados = [False for _ in xrange(n+1)]
vizinhos = grafo[1]
visitados[1] = True
candi = []
for vizinho in vizinhos:
    maxi = {'value':-1}
    dfs(vizinho, grafo, visitados,1, maxi)
    if(maxi['value'] != -1):
        candi.append(maxi['value'])
print(len(set(candi)))
print("" "".join(list(set(map(str, candi)))))

    
    
",,False,post,False,False,True,True,code_contests3.json
