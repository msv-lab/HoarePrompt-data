
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: The city Valera lives in is going to hold elections to the city Parliament.

The city has n districts and n - 1 bidirectional roads. We know that from any district there is a path along the roads to any other district. Let's enumerate all districts in some way by integers from 1 to n, inclusive. Furthermore, for each road the residents decided if it is the problem road or not. A problem road is a road that needs to be repaired.

There are n candidates running the elections. Let's enumerate all candidates in some way by integers from 1 to n, inclusive. If the candidate number i will be elected in the city Parliament, he will perform exactly one promise — to repair all problem roads on the way from the i-th district to the district 1, where the city Parliament is located.

Help Valera and determine the subset of candidates such that if all candidates from the subset will be elected to the city Parliament, all problem roads in the city will be repaired. If there are several such subsets, you should choose the subset consisting of the minimum number of candidates.

Input

The first line contains a single integer n (2 ≤ n ≤ 105) — the number of districts in the city.

Then n - 1 lines follow. Each line contains the description of a city road as three positive integers xi, yi, ti (1 ≤ xi, yi ≤ n, 1 ≤ ti ≤ 2) — the districts connected by the i-th bidirectional road and the road type. If ti equals to one, then the i-th road isn't the problem road; if ti equals to two, then the i-th road is the problem road.

It's guaranteed that the graph structure of the city is a tree.

Output

In the first line print a single non-negative number k — the minimum size of the required subset of candidates. Then on the second line print k space-separated integers a1, a2, ... ak — the numbers of the candidates that form the required subset. If there are multiple solutions, you are allowed to print any of them.

Examples

Input

5
1 2 2
2 3 2
3 4 2
4 5 2


Output

1
5 


Input

5
1 2 1
2 3 2
2 4 1
4 5 1


Output

1
3 


Input

5
1 2 2
1 3 2
1 4 2
1 5 2


Output

4
5 4 3 2 
Annotated Program:
```
def func_1(no, grafo, visitados, depth, cand):
    if no[1] :
        cand['value'] = max(cand['value'], no[0])
    #State of the program after the if block has been executed: *n is a positive integer representing the number of districts in the city. Each road is described by three positive integers xi, yi, ti where xi and yi represent the districts connected by the road, and ti is either 1 or 2 indicating whether the road is a problem road or not. The graph structure of the city is a tree. If the road represented by no[1] is a problem road, then the value in cand dictionary is updated to be the maximum of the current value and no[0].
    visitados[no[0]] = True
    for vizinho in grafo[no[0]]:
        if not visitados[vizinho[0]]:
            func_1(vizinho, grafo, visitados, depth + 1, cand)
        
    #State of the program after the  for loop has been executed: After the loop executes, the program recursively calls `func_1` for each neighbor in `grafo[no[0]]` that has `visitados[vizinho[0]]` set to False. The `cand` dictionary is updated for problem roads, and `visitados` array keeps track of visited districts. If there are no neighbors with `visitados[vizinho[0]]` set to False, the loop does not execute.

```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
