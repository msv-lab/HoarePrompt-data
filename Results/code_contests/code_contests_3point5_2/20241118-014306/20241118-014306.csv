Task ID,Dataset,model_created,model_run,description,Code,Test Result,Correctness,Post,original correctness,naive correctness,annotated correctness,naive no fsl correctness,data file
2166,code_contests,human,gpt-3.5-turbo-0125,"This is the easy version of the problem. The difference between the versions is that in the easy version all prices a_i are different. You can make hacks if and only if you solved both versions of the problem.

Today is Sage's birthday, and she will go shopping to buy ice spheres. All n ice spheres are placed in a row and they are numbered from 1 to n from left to right. Each ice sphere has a positive integer price. In this version all prices are different.

An ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.

You can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^5) — the number of ice spheres in the shop.

The second line contains n different integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the prices of ice spheres.

Output

In the first line print the maximum number of ice spheres that Sage can buy.

In the second line print the prices of ice spheres in the optimal order. If there are several correct answers, you can print any of them.

Example

Input


5
1 2 3 4 5


Output


2
3 1 4 2 5 

Note

In the example it's not possible to place ice spheres in any order so that Sage would buy 3 of them. If the ice spheres are placed like this (3, 1, 4, 2, 5), then Sage will buy two spheres: one for 1 and one for 2, because they are cheap.","
# Author : raj1307 - Raj Singh
# Date   : 19.09.2020

from __future__ import division, print_function

import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().strip().split("" ""))
def msi(): return map(str,input().strip().split("" ""))
def li():  return list(mi())

def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
#from collections import deque, Counter, OrderedDict,defaultdict
#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace
#from math import log,sqrt,factorial,cos,tan,sin,radians
#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
#from decimal import *
#import threading
#from itertools import permutations
#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy

abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007
#mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]
def getKey(item): return item[1] 
def sort2(l):return sorted(l, key=getKey,reverse=True)
def d2(n,m,num):return [[num for x in range(m)] for y in range(n)]
def isPowerOfTwo (x): return (x and (not(x & (x - 1))) )
def decimalToBinary(n): return bin(n).replace(""0b"","""")
def ntl(n):return [int(i) for i in str(n)]
def ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))

def ceil(x,y):
    if x%y==0:
        return x//y
    else:
        return x//y+1

def powerMod(x,y,p):
    res = 1
    x %= p
    while y > 0:
        if y&1:
            res = (res*x)%p
        y = y>>1
        x = (x*x)%p
    return res

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
    
def isPrime(n) : # Check Prime Number or not 
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) : 
        if (n % i == 0 or n % (i + 2) == 0) : 
            return False
        i = i + 6
    return True



def read():
    sys.stdin  = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 






def main():
    
    
    #for _ in range(ii()):
        
    
    
    n=ii()
    a=li()
    ans=0

    i=0
    j=n-1
    b=[]
    f=0
    for k in range(n):

        if f==0:
            b.append(a[j])
            j-=1
            f^=1
        else:
            b.append(a[i])
            i+=1
            f^=1

    for i in range(1,n-1):
        if b[i]<b[i-1] and b[i]<b[i+1]:
            ans+=1


    print(ans)
    print(*b)
        










































# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    #read()
    main()
    #dmain()

# Comment Read()
",,False,post,False,True,False,False,code_contests2.json
4952,code_contests,human,gpt-3.5-turbo-0125,"Polycarp is mad about coding, that is why he writes Sveta encoded messages. He calls the median letter in a word the letter which is in the middle of the word. If the word's length is even, the median letter is the left of the two middle letters. In the following examples, the median letter is highlighted: contest, info. If the word consists of single letter, then according to above definition this letter is the median letter. 

Polycarp encodes each word in the following way: he writes down the median letter of the word, then deletes it and repeats the process until there are no letters left. For example, he encodes the word volga as logva.

You are given an encoding s of some word, your task is to decode it. 

Input

The first line contains a positive integer n (1 ≤ n ≤ 2000) — the length of the encoded word.

The second line contains the string s of length n consisting of lowercase English letters — the encoding.

Output

Print the word that Polycarp encoded.

Examples

Input

5
logva


Output

volga


Input

2
no


Output

no


Input

4
abba


Output

baba

Note

In the first example Polycarp encoded the word volga. At first, he wrote down the letter l from the position 3, after that his word looked like voga. After that Polycarp wrote down the letter o from the position 2, his word became vga. Then Polycarp wrote down the letter g which was at the second position, the word became va. Then he wrote down the letter v, then the letter a. Thus, the encoding looked like logva.

In the second example Polycarp encoded the word no. He wrote down the letter n, the word became o, and he wrote down the letter o. Thus, in this example, the word and its encoding are the same.

In the third example Polycarp encoded the word baba. At first, he wrote down the letter a, which was at the position 2, after that the word looked like bba. Then he wrote down the letter b, which was at the position 2, his word looked like ba. After that he wrote down the letter b, which was at the position 1, the word looked like a, and he wrote down that letter a. Thus, the encoding is abba.","n=input()
s=list(raw_input())
ns=''

i=n-2
while(i>=0):
    ns+=s[i]
    i-=2

if n%2: i=0
else: i=1

while(i<n):
    ns+=s[i]
    i+=2

print(ns)
",,True,post,True,True,True,True,code_contests2.json
1716,code_contests,human,gpt-3.5-turbo-0125,"Fox Ciel is going to publish a paper on FOCS (Foxes Operated Computer Systems, pronounce: ""Fox""). She heard a rumor: the authors list on the paper is always sorted in the lexicographical order. 

After checking some examples, she found out that sometimes it wasn't true. On some papers authors' names weren't sorted in lexicographical order in normal sense. But it was always true that after some modification of the order of letters in alphabet, the order of authors becomes lexicographical!

She wants to know, if there exists an order of letters in Latin alphabet such that the names on the paper she is submitting are following in the lexicographical order. If so, you should find out any such order.

Lexicographical order is defined in following way. When we compare s and t, first we find the leftmost position with differing characters: si ≠ ti. If there is no such position (i. e. s is a prefix of t or vice versa) the shortest string is less. Otherwise, we compare characters si and ti according to their order in alphabet.

Input

The first line contains an integer n (1 ≤ n ≤ 100): number of names.

Each of the following n lines contain one string namei (1 ≤ |namei| ≤ 100), the i-th name. Each name contains only lowercase Latin letters. All names are different.

Output

If there exists such order of letters that the given names are sorted lexicographically, output any such order as a permutation of characters 'a'–'z' (i. e. first output the first letter of the modified alphabet, then the second, and so on).

Otherwise output a single word ""Impossible"" (without quotes).

Examples

Input

3
rivest
shamir
adleman


Output

bcdefghijklmnopqrsatuvwxyz


Input

10
tourist
petr
wjmzbmr
yeputons
vepifanov
scottwu
oooooooooooooooo
subscriber
rowdark
tankengineer


Output

Impossible


Input

10
petr
egor
endagorion
feferivan
ilovetanyaromanova
kostka
dmitriyh
maratsnowbear
bredorjaguarturnik
cgyforever


Output

aghjlnopefikdmbcqrstuvwxyz


Input

7
car
care
careful
carefully
becarefuldontforgetsomething
otherwiseyouwillbehacked
goodluck


Output

acbdefhijklmnogpqrstuvwxyz","def no():
    print(""Impossible"")
    exit(0)


names = [raw_input() for _ in xrange(input())]
before = {a: set() for a in ""abcdefghijklmnopqrstuvwxyz""}

for i in xrange(len(names) - 1):
    prev_name = names[i]
    curr_name = names[i + 1]
    length = min(len(names[i]), len(names[i + 1]))
    j = 0
    ok = False
    while j < length:
        if prev_name[j] == curr_name[j] or prev_name[j] in before[curr_name[j]]:
            j += 1
        else:
            before[curr_name[j]].update(before[prev_name[j]])
            before[curr_name[j]].add(prev_name[j])
            for b in before[curr_name[j]]:
                if curr_name[j] in before[b]:
                    no()
            ok = True
            break
    if not ok and len(prev_name) > len(curr_name):
        no()

ans = """"

for i in xrange(26):
    for b in before:
        if len(before[b]) == 0:
            break
    ans += b
    before.pop(b)
    for c in before.values():
        if b in c:
            c.remove(b)

print(ans)
",,False,post,False,True,True,True,code_contests2.json
4085,code_contests,human,gpt-3.5-turbo-0125,"Hacker Zhorik wants to decipher two secret messages he intercepted yesterday. Yeah message is a sequence of encrypted blocks, each of them consists of several bytes of information.

Zhorik knows that each of the messages is an archive containing one or more files. Zhorik knows how each of these archives was transferred through the network: if an archive consists of k files of sizes l1, l2, ..., lk bytes, then the i-th file is split to one or more blocks bi, 1, bi, 2, ..., bi, mi (here the total length of the blocks bi, 1 + bi, 2 + ... + bi, mi is equal to the length of the file li), and after that all blocks are transferred through the network, maintaining the order of files in the archive.

Zhorik thinks that the two messages contain the same archive, because their total lengths are equal. However, each file can be split in blocks in different ways in the two messages.

You are given the lengths of blocks in each of the two messages. Help Zhorik to determine what is the maximum number of files could be in the archive, if the Zhorik's assumption is correct.

Input

The first line contains two integers n, m (1 ≤ n, m ≤ 105) — the number of blocks in the first and in the second messages.

The second line contains n integers x1, x2, ..., xn (1 ≤ xi ≤ 106) — the length of the blocks that form the first message.

The third line contains m integers y1, y2, ..., ym (1 ≤ yi ≤ 106) — the length of the blocks that form the second message.

It is guaranteed that x1 + ... + xn = y1 + ... + ym. Also, it is guaranteed that x1 + ... + xn ≤ 106.

Output

Print the maximum number of files the intercepted array could consist of.

Examples

Input

7 6
2 5 3 1 11 4 4
7 8 2 4 1 8


Output

3


Input

3 3
1 10 100
1 100 10


Output

2


Input

1 4
4
1 1 1 1


Output

1

Note

In the first example the maximum number of files in the archive is 3. For example, it is possible that in the archive are three files of sizes 2 + 5 = 7, 15 = 3 + 1 + 11 = 8 + 2 + 4 + 1 and 4 + 4 = 8.

In the second example it is possible that the archive contains two files of sizes 1 and 110 = 10 + 100 = 100 + 10. Note that the order of files is kept while transferring archives through the network, so we can't say that there are three files of sizes 1, 10 and 100.

In the third example the only possibility is that the archive contains a single file of size 4.","q1=raw_input().split()
q2=raw_input().split()
q3=raw_input().split()
s1=int(q2[0])
s2=int(q3[0])
f=0
p1=0
p2=0
a1=int(q1[0])
a2=int(q1[1])
while((p1<a1)and(p2<a2)):
    if(s1==s2):
        s1=0
        s2=0
        f=f+1
        p1=p1+1
        p2=p2+1
    if(s1<s2):
        p1=p1+1
        s1=s1+int(q2[p1])
    if(s1>s2):
        p2=p2+1
        s2=s2+int(q3[p2])
print(f)",,False,post,False,True,False,False,code_contests2.json
0909,code_contests,human,gpt-3.5-turbo-0125,"There are n warriors in a row. The power of the i-th warrior is a_i. All powers are pairwise distinct.

You have two types of spells which you may cast: 

  1. Fireball: you spend x mana and destroy exactly k consecutive warriors; 
  2. Berserk: you spend y mana, choose two consecutive warriors, and the warrior with greater power destroys the warrior with smaller power. 



For example, let the powers of warriors be [2, 3, 7, 8, 11, 5, 4], and k = 3. If you cast Berserk on warriors with powers 8 and 11, the resulting sequence of powers becomes [2, 3, 7, 11, 5, 4]. Then, for example, if you cast Fireball on consecutive warriors with powers [7, 11, 5], the resulting sequence of powers becomes [2, 3, 4].

You want to turn the current sequence of warriors powers a_1, a_2, ..., a_n into b_1, b_2, ..., b_m. Calculate the minimum amount of mana you need to spend on it.

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 2 ⋅ 10^5) — the length of sequence a and the length of sequence b respectively.

The second line contains three integers x, k, y (1 ≤ x, y, ≤ 10^9; 1 ≤ k ≤ n) — the cost of fireball, the range of fireball and the cost of berserk respectively.

The third line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n). It is guaranteed that all integers a_i are pairwise distinct.

The fourth line contains m integers b_1, b_2, ..., b_m (1 ≤ b_i ≤ n). It is guaranteed that all integers b_i are pairwise distinct.

Output

Print the minimum amount of mana for turning the sequnce a_1, a_2, ..., a_n into b_1, b_2, ..., b_m, or -1 if it is impossible.

Examples

Input


5 2
5 2 3
3 1 4 5 2
3 5


Output


8


Input


4 4
5 1 4
4 3 1 2
2 4 3 1


Output


-1


Input


4 4
2 1 11
1 3 2 4
1 3 2 4


Output


0","#   Author: yumtam
#   Created at: 2020-09-10 23:03

from __future__ import division, print_function
_interactive = False

def main():
    n, m = input_as_list()
    x, k, y = input_as_list()
    a = input_as_list()
    b = input_as_list()

    j = 0
    for i, ax in enumerate(a):
        if j < m and ax == b[j]:
            j += 1

    if j < m:
        print(-1)
        return

    sa = set(a)
    sb = set(b)
    if sa == sb:
        print(0)
        return

    mx = max(sa-sb)

    gaps = []
    j = 0
    gl = 0
    special = False
    for i, ax in enumerate(a):
        if j < m and ax == b[j]:
            j += 1
            if special:
                specialgap = gl
            gaps.append(gl)
            gl = 0
            special = False
        else:
            if ax == mx:
                special = True
            gl += 1
    if special:
        specialgap = gl
    gaps.append(gl)

    debug_print(gaps)

    if specialgap < k:
        print(-1)
        return

    ans = 0
    if x < y*k:
        for g in gaps:
            ans += x*(g//k) + y*(g%k)
    else:
        for g in gaps:
            ans += y*g

    print(ans)


# Constants
INF = float('inf')
MOD = 10**9+7

# Python3 equivalent names
import os, sys, itertools
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip

# print-flush in interactive problems
if _interactive:
    flush = sys.stdout.flush
    def printf(*args, **kwargs):
        print(*args, **kwargs)
        flush()

# Debug print, only works on local machine
LOCAL = ""LOCAL_"" in os.environ
debug_print = (print) if LOCAL else (lambda *x, **y: None)

# Fast IO
if (not LOCAL) and (not _interactive):
    from io import BytesIO
    from atexit import register
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda: os.write(1, sys.stdout.getvalue()))
    input = lambda: sys.stdin.readline().rstrip('\r\n')

# Some utility functions(Input, N-dimensional lists, ...)
def input_as_list():
    return [int(x) for x in input().split()]

def input_with_offset(o):
    return [int(x)+o for x in input().split()]

def input_as_matrix(n, m):
    return [input_as_list() for _ in range(n)]

def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

# Start of external code templates...
# End of external code templates.

main()
",,True,post,False,True,True,True,code_contests2.json
