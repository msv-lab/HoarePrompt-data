
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You have a sequence a with n elements 1, 2, 3, ..., k - 1, k, k - 1, k - 2, ..., k - (n - k) (k ≤ n < 2k).

Let's call as inversion in a a pair of indices i < j such that a[i] > a[j].

Suppose, you have some permutation p of size k and you build a sequence b of size n in the following manner: b[i] = p[a[i]].

Your goal is to find such permutation p that the total number of inversions in b doesn't exceed the total number of inversions in a, and b is lexicographically maximum.

Small reminder: the sequence of k integers is called a permutation if it contains all integers from 1 to k exactly once.

Another small reminder: a sequence s is lexicographically smaller than another sequence t, if either s is a prefix of t, or for the first i such that s_i ≠ t_i, s_i < t_i holds (in the first position that these sequences are different, s has smaller number than t).

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first and only line of each test case contains two integers n and k (k ≤ n < 2k; 1 ≤ k ≤ 10^5) — the length of the sequence a and its maximum.

It's guaranteed that the total sum of k over test cases doesn't exceed 10^5.

Output

For each test case, print k integers — the permutation p which maximizes b lexicographically without increasing the total number of inversions.

It can be proven that p exists and is unique.

Example

Input


4
1 1
2 2
3 2
4 3


Output


1 
1 2 
2 1 
1 3 2 

Note

In the first test case, the sequence a = [1], there is only one permutation p = [1].

In the second test case, the sequence a = [1, 2]. There is no inversion in a, so there is only one permutation p = [1, 2] which doesn't increase the number of inversions.

In the third test case, a = [1, 2, 1] and has 1 inversion. If we use p = [2, 1], then b = [p[a[1]], p[a[2]], p[a[3]]] = [2, 1, 2] and also has 1 inversion.

In the fourth test case, a = [1, 2, 3, 2], and since p = [1, 3, 2] then b = [1, 3, 2, 3]. Both a and b have 1 inversion and b is the lexicographically maximum.
Annotated Program:
```
#Function 1:
def func_1():
    return int(input())
    #The program returns an integer value obtained from the user input

#Function 2:
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained by mapping the input string values after splitting

#Function 3:
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list containing all characters of the string 's' except for the last one.

#Function 4:
def func_4():
    s = input()
    return s[:len(s) - 1]
    #The program returns the input value 's' excluding the last character

#Function 5:
def func_5(l):
    print(' '.join(map(str, l)))

#Function 6:
def func_6(BITree, index):
    sum = 0
    while index > 0:
        sum += BITree[index]
        
        index -= index & -index
        
    #State of the program after the loop has been executed: If index is greater than 0, then `sum` is the sum of the values in the BITree at the updated indices, `index` is an updated integer representing the index of the BITree. If index is 0 or negative, the loop will not execute, and the values of `BITree`, `index`, and `sum` remain unchanged.
    return sum
    #The program returns the sum of the values in the BITree at the updated indices

#Function 7:
def func_7(BITree, n, index, val):
    while index <= n:
        BITree[index] += val
        
        index += index & -index
        
    #State of the program after the loop has been executed: If index is less than or equal to n, then BITree is a list of integers with the updated values at the corresponding indices calculated from the bitwise operation. The loop stops when index exceeds n. If index is greater than n, the loop does not execute.

#Function 8:
def func_8(arr, n):
    invcount = 0
    maxElement = max(arr)
    BIT = [0] * (maxElement + 1)
    for i in range(1, maxElement + 1):
        BIT[i] = 0
        
    #State of the program after the  for loop has been executed: After the loop executes, all elements of the list BIT are set to 0 up to the maximum value in the list arr. If maxElement is 0 or lower, the loop does not execute and BIT remains a list of 0 values up to 1.
    for i in range(n - 1, -1, -1):
        invcount += func_6(BIT, arr[i] - 1)
        
        func_7(BIT, maxElement, arr[i], 1)
        
    #State of the program after the  for loop has been executed: Output State: All elements of the list `BIT` are updated based on the function `func_7` with arguments `BIT`, `maxElement`, `arr[i]`, and `1` for each iteration. The value of `invcount` is incremented by the return value of `func_6(BIT, arr[i] - 1)` in each iteration. The loop will execute as long as `n` is greater than 0 and `maxElement` is greater than 0. If `n` is 0 or negative, the loop does not execute, and `BIT` remains a list of 0 values up to 1. If `maxElement` is 0 or negative, the loop does not execute, and `BIT` remains a list of 0 values up to the maximum value in `arr`.
    return invcount
    #The program returns the final value of 'invcount' after the loop iterations

#Function 9:
def func_9():
    n, k = func_2()
    if (n == k) :
        return range(1, k + 1)
        #The program returns a range from 1 to the value of 'k' inclusive
    #State of the program after the if block has been executed: *'n' and 'k' are values returned by func_2(). If 'n' is equal to 'k', the program returns a range from 1 to 'k' inclusive. Otherwise, there is no action taken by the program.
    if (n == k + 1) :
        return range(1, k + 1 - 2) + [k, k - 1]
        #The program returns a range from 1 to k-2 inclusive, followed by k and k-1
    #State of the program after the if block has been executed: *'n' and 'k' are values returned by func_2(). If 'n' is equal to 'k', the program returns a range from 1 to 'k' inclusive. If 'n' is equal to 'k + 1', the program returns a range from 1 to 'k - 2' inclusive, followed by 'k' and 'k - 1'. Otherwise, no action is taken by the program.
    a = range(1, k + 1) + range(k - 1, 2 * k - n - 1, -1)
    maxInv = func_8(a, n)
    for i in xrange(2 * k - n, k):
        a[k - 1] = i
        
        a[k - 2] = k
        
        a[k] = k
        
        curInv = func_8(a, n)
        
        if curInv <= maxInv:
            ans = range(1, k + 1)
            ans[k - 1] = i
            ans[i - 1] = k
            return ans
        
    #State of the program after the  for loop has been executed: If n is equal to k the loop will execute and update the variables as described in the loop. If n is equal to k + 1 the loop does not execute. If n is not equal to k or k + 1 the loop does not execute.


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
