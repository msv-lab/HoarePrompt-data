Task ID,Dataset,model_created,model_run,description,Code,Test Result,Correctness,Post,original correctness,naive correctness,annotated correctness,naive no fsl correctness,data file
4493,code_contests,human,gpt-3.5-turbo-0125,"The Saratov State University Olympiad Programmers Training Center (SSU OPTC) has n students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.

The head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least k times?

Input

The first line contains two integers, n and k (1 ≤ n ≤ 2000; 1 ≤ k ≤ 5). The next line contains n integers: y1, y2, ..., yn (0 ≤ yi ≤ 5), where yi shows the number of times the i-th person participated in the ACM ICPC world championship.

Output

Print a single number — the answer to the problem.

Examples

Input

5 2
0 4 5 1 0


Output

1


Input

6 4
0 1 2 3 4 5


Output

0


Input

6 5
0 0 0 0 0 0


Output

2

Note

In the first sample only one team could be made: the first, the fourth and the fifth participants.

In the second sample no teams could be created.

In the third sample two teams could be created. Any partition into two teams fits.","import math

n, k = raw_input().split()
n, k = int(n), int(k)
arr = map(int,raw_input().split())
count = 0.0

for i in range(n):
    if arr[i] + k <= 5:
        count += 1.0

print(int(math.floor(count / 3)))",,True,post,True,True,True,True,code_contests4.json
1153,code_contests,human,gpt-3.5-turbo-0125,"There is a card game called ""Durak"", which means ""Fool"" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly — you can find them later yourselves if you want.

To play durak you need a pack of 36 cards. Each card has a suit (""S"", ""H"", ""D"" and ""C"") and a rank (in the increasing order ""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"" and ""A""). At the beginning of the game one suit is arbitrarily chosen as trump. 

The players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.

A card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards’ ranks are. In all other cases you can not beat the second card with the first one.

You are given the trump suit and two different cards. Determine whether the first one beats the second one or not.

Input

The first line contains the tramp suit. It is ""S"", ""H"", ""D"" or ""C"".

The second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"" and ""A""), and the second one stands for the suit (""S"", ""H"", ""D"" and ""C"").

Output

Print ""YES"" (without the quotes) if the first cards beats the second one. Otherwise, print ""NO"" (also without the quotes).

Examples

Input

H
QH 9S


Output

YES


Input

S
8D 6D


Output

YES

Input

C
7H AS


Output

NO","s = raw_input()
s2 = raw_input().split()

m1 = '6789TJQKA'

i = 0
for ts in m1:
    if ts == s2[0][0]:
        r1 = i
    i+=1

i = 0
for ts in m1:
    if ts == s2[1][0]:
        r2 = i
    i+=1

#print r1, r2

if s2[0][1] != s2[1][1] and s2[0][1] == s[0]:
    print ('YES')
elif s2[0][1] == s2[1][1] and r1 > r2:
    print('YES')
else:
    print('NO')
",,True,post,True,True,True,False,code_contests4.json
1328,code_contests,human,gpt-3.5-turbo-0125,"You have a knapsack with the capacity of W. There are also n items, the i-th one has weight w_i. 

You want to put some of these items into the knapsack in such a way that their total weight C is at least half of its size, but (obviously) does not exceed it. Formally, C should satisfy: ⌈ W/2⌉ ≤ C ≤ W. 

Output the list of items you will put into the knapsack or determine that fulfilling the conditions is impossible. 

If there are several possible lists of items satisfying the conditions, you can output any. Note that you don't have to maximize the sum of weights of items in the knapsack.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains integers n and W (1 ≤ n ≤ 200 000, 1≤ W ≤ 10^{18}). 

The second line of each test case contains n integers w_1, w_2, ..., w_n (1 ≤ w_i ≤ 10^9) — weights of the items.

The sum of n over all test cases does not exceed 200 000.

Output

For each test case, if there is no solution, print a single integer -1. 

If there exists a solution consisting of m items, print m in the first line of the output and m integers j_1, j_2, ..., j_m (1 ≤ j_i ≤ n, all j_i are distinct) in the second line of the output — indices of the items you would like to pack into the knapsack.

If there are several possible lists of items satisfying the conditions, you can output any. Note that you don't have to maximize the sum of weights items in the knapsack.

Example

Input


3
1 3
3
6 2
19 8 19 69 9 4
7 12
1 1 1 17 1 1 1


Output


1
1
-1
6
1 2 3 5 6 7

Note

In the first test case, you can take the item of weight 3 and fill the knapsack just right.

In the second test case, all the items are larger than the knapsack's capacity. Therefore, the answer is -1.

In the third test case, you fill the knapsack exactly in half.","from __future__ import division, print_function
 
import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(10**5)
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def main():
    pass
 
 
# region fastio
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


t=int(input())
import math
while t:
    t-=1
    n,W=map(int,input().split())
    arr=list(map(int,input().split()))
    dicty={}
    check=True
    for i in range(n):
        if arr[i]>=math.ceil(W/2) and arr[i]<=W:
            print(1)
            print(i+1)
            check=False
            break
        elif arr[i]>W:
            dicty[i]=1
    if check:
        idxs=[]
        i=0
        sm=0
        check=True
        while i!=n:
            if i not in dicty:
                if sm+arr[i]<=W:
                    sm+=arr[i]
                    idxs.append(i+1)
                if sm>=math.ceil(W/2) and sm<=W:
                    print(len(idxs))
                    print(*idxs)
                    check=False
                    break
            i+=1
        if check:
            print(-1)
            
        ",,True,post,True,True,True,True,code_contests4.json
