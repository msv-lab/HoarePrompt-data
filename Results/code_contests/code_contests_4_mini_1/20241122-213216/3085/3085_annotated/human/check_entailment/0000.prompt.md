
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You have a sequence a with n elements 1, 2, 3, ..., k - 1, k, k - 1, k - 2, ..., k - (n - k) (k ≤ n < 2k).

Let's call as inversion in a a pair of indices i < j such that a[i] > a[j].

Suppose, you have some permutation p of size k and you build a sequence b of size n in the following manner: b[i] = p[a[i]].

Your goal is to find such permutation p that the total number of inversions in b doesn't exceed the total number of inversions in a, and b is lexicographically maximum.

Small reminder: the sequence of k integers is called a permutation if it contains all integers from 1 to k exactly once.

Another small reminder: a sequence s is lexicographically smaller than another sequence t, if either s is a prefix of t, or for the first i such that s_i ≠ t_i, s_i < t_i holds (in the first position that these sequences are different, s has smaller number than t).

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first and only line of each test case contains two integers n and k (k ≤ n < 2k; 1 ≤ k ≤ 10^5) — the length of the sequence a and its maximum.

It's guaranteed that the total sum of k over test cases doesn't exceed 10^5.

Output

For each test case, print k integers — the permutation p which maximizes b lexicographically without increasing the total number of inversions.

It can be proven that p exists and is unique.

Example

Input


4
1 1
2 2
3 2
4 3


Output


1 
1 2 
2 1 
1 3 2 

Note

In the first test case, the sequence a = [1], there is only one permutation p = [1].

In the second test case, the sequence a = [1, 2]. There is no inversion in a, so there is only one permutation p = [1, 2] which doesn't increase the number of inversions.

In the third test case, a = [1, 2, 1] and has 1 inversion. If we use p = [2, 1], then b = [p[a[1]], p[a[2]], p[a[3]]] = [2, 1, 2] and also has 1 inversion.

In the fourth test case, a = [1, 2, 3, 2], and since p = [1, 3, 2] then b = [1, 3, 2, 3]. Both a and b have 1 inversion and b is the lexicographically maximum.
Annotated Program:
```
#Function 1:
def func_1():
    return int(input())
    #The program returns a positive integer input by the user

#Function 2:
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained from the input split by spaces

#Function 3:
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list containing all elements of the string 's' except the last character.

#Function 4:
def func_4():
    s = input()
    return s[:len(s) - 1]
    #The program returns the string 's' without its last character

#Function 5:
def func_5(l):
    print(' '.join(map(str, l)))

#Function 6:
def func_6(BITree, index):
    sum = 0
    while index > 0:
        sum += BITree[index]
        
        index -= index & -index
        
    #State of the program after the loop has been executed: `if index is greater than 0 then sum is the cumulative sum of BITree values at indices derived from index, and index will be reduced until it reaches 0. if index is 0 or less than 1 before the loop starts, the loop doesn't execute and sum remains 0.`
    return sum
    #The program returns the cumulative sum of BITree values at indices derived from index if index is greater than 0; otherwise, it returns 0.

#Function 7:
def func_7(BITree, n, index, val):
    while index <= n:
        BITree[index] += val
        
        index += index & -index
        
    #State of the program after the loop has been executed: `if index is less than or equal to n then BITree[index]` is updated by adding `val`, and `index` is incremented by its lowest set bit. At the end, `index` will exceed `n` and the loop will not execute if index starts greater than n. If `index` starts at a value less than or equal to `n`, it will eventually be greater than `n` after a finite number of iterations.`

#Function 8:
def func_8(arr, n):
    invcount = 0
    maxElement = max(arr)
    BIT = [0] * (maxElement + 1)
    for i in range(1, maxElement + 1):
        BIT[i] = 0
        
    #State of the program after the  for loop has been executed: `invcount` is 0, `maxElement` is a non-negative integer, `BIT` is a list initialized with all elements set to 0 for indices from 1 to `maxElement`. If `maxElement` is 0 or negative, the loop does not execute and `BIT` remains a list of size 1 with `BIT[0]` being 0, while `invcount` remains 0.
    for i in range(n - 1, -1, -1):
        invcount += func_6(BIT, arr[i] - 1)
        
        func_7(BIT, maxElement, arr[i], 1)
        
    #State of the program after the  for loop has been executed: `invcount` is the total number of inversions in the array `arr`, `maxElement` is a non-negative integer, `BIT` is a list of size `maxElement + 1` initialized with the updated values set by `func_7`, `n` is the number of elements in `arr`, and `i` is the index of the current element being processed in the loop. If `n` is 0 or lower, the loop does not execute, `invcount` remains 0, and `BIT` is a list of size 1 with `BIT[0]` being 0.
    return invcount
    #The program returns the total number of inversions in the array `arr`, which is `invcount`.

#Function 9:
def func_9():
    n, k = func_2()
    if (n == k) :
        return range(1, k + 1)
        #The program returns a range object representing the numbers from 1 to k (inclusive)
    #State of the program after the if block has been executed: *`t` is a positive integer representing the number of test cases, and `n` and `k` are integers such that `k ≤ n < 2k` and `1 ≤ k ≤ 10^5`. If `n` equals `k`, the function returns a range object containing the numbers from 1 to `k` (inclusive). If `n` is not equal to `k`, the function does not return any value (implicitly returns None).
    if (n == k + 1) :
        return range(1, k + 1 - 2) + [k, k - 1]
        #The program returns a list containing the integers from 1 to k - 2, followed by the integers k and k - 1
    #State of the program after the if block has been executed: *`t` is a positive integer representing the number of test cases, and `n` and `k` are integers such that `k ≤ n < 2k` and `1 ≤ k ≤ 10^5`. If `n` equals `k + 1`, the function returns a range object containing the integers from 1 to `k - 2`, followed by the integers `k` and `k - 1`. If `n` is equal to `k`, the function returns a range object containing the numbers from 1 to `k` (inclusive). If `n` is neither `k` nor `k + 1`, the function does not return any value and implicitly returns None.
    a = range(1, k + 1) + range(k - 1, 2 * k - n - 1, -1)
    maxInv = func_8(a, n)
    for i in xrange(2 * k - n, k):
        a[k - 1] = i
        
        a[k - 2] = k
        
        a[k] = k
        
        curInv = func_8(a, n)
        
        if curInv <= maxInv:
            ans = range(1, k + 1)
            ans[k - 1] = i
            ans[i - 1] = k
            return ans
        
    #State of the program after the  for loop has been executed: If `t` is at least 1 and `n` and `k` satisfy the condition `k ≤ n < 2k`, the loop will execute at least once, and `curInv` will be the result of `func_8(a, n)`. If `curInv` is less than or equal to `maxInv`, the function will return a range object from 1 to `k`, where the `k`-th element is set to `i` and the `i`-th element is set to `k`. If `curInv` is greater than `maxInv`, the loop may execute multiple times until the condition is met or until `i` reaches `k - 1`. If `k` is less than or equal to `2 * k - n`, the loop will not execute, and `a` and `curInv` will remain unchanged, with `ans` undefined.


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
