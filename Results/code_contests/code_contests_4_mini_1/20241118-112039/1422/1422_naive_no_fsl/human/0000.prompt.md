
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Kostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. 

Zahar has n stones which are rectangular parallelepipeds. The edges sizes of the i-th of them are ai, bi and ci. He can take no more than two stones and present them to Kostya. 

If Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. 

Help Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.

Input

The first line contains the integer n (1 ≤ n ≤ 105).

n lines follow, in the i-th of which there are three integers ai, bi and ci (1 ≤ ai, bi, ci ≤ 109) — the lengths of edges of the i-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.

Output

In the first line print k (1 ≤ k ≤ 2) the number of stones which Zahar has chosen. In the second line print k distinct integers from 1 to n — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to n in the order as they are given in the input data.

You can print the stones in arbitrary order. If there are several answers print any of them. 

Examples

Input

6
5 5 5
3 2 4
1 4 1
2 1 3
3 2 4
3 3 4


Output

1
1


Input

7
10 7 8
5 10 3
4 2 6
5 5 5
10 2 8
4 2 1
7 7 7


Output

2
1 5

Note

In the first example we can connect the pairs of stones:

  * 2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1
  * 2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. 
  * 2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5
  * 4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1
  * 5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5



Or take only one stone:

  * 1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5
  * 2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1
  * 3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5
  * 4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5
  * 5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1
  * 6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5



It is most profitable to take only the first stone. 
Program:
```
n = int(stdin.readline())
one = {}
two = {}
ans = []
challengers = []
for i in range(n):
    (a, b, c) = map(int, stdin.readline().split())
    challengers.append((a, b, c))
    first = (max(a, b), min(a, b))
    second = (max(a, c), min(a, c))
    third = (max(b, c), min(b, c))
    if first in two:
        if two[first] < one[first][0] + c:
            ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))
            two[first] = one[first][0] + c
    elif first in one:
        two[first] = one[first][0] + c
        ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))
    if second in two:
        if two[second] < one[second][0] + c:
            ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))
            two[second] = one[second][0] + b
    elif second in one:
        two[second] = one[second][0] + b
        ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))
    if third in two:
        if two[third] < one[third][0] + c:
            ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))
            two[third] = one[third][0] + a
    elif third in one:
        two[third] = one[third][0] + a
        ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))
    if first not in one or one[first][0] < c:
        one[first] = (c, i)
    if second not in one or one[second][0] < b:
        one[second] = (b, i)
    if third not in one or one[third][0] < a:
        one[third] = (a, i)
label = 0
cnt = 0
for (a, b, c, ind1, ind2) in ans:
    if min(min(a, b), c) > cnt:
        label = 2
        cnt = min(min(a, b), c)
        first = ind1
        second = ind2
for i in range(n):
    (a, b, c) = challengers[i]
    if min(min(a, b), c) > cnt:
        label = 1
        cnt = min(min(a, b), c)
        first = i
if label == 1:
    stdout.write('1' + '\n' + str(first + 1))
else:
    stdout.write('2' + '\n' + str(first + 1) + ' ' + str(second + 1))
```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
