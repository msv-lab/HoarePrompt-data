To determine the correctness of the given program based on the problem description, we need to analyze the logic of the code and see if it adheres to the requirements.

### Problem Description Recap:
The task is to remove duplicate integers from an array while keeping only the rightmost occurrence of each integer. The output should include the number of unique integers left and the unique integers in the order they appear.

### Analyzing the Provided Program:
1. The program reads an integer `n` which is the number of elements in the array.
2. It reads the array `a` and reverses it (`a = a[::-1]`).
3. It initializes an empty list `ans` and a set `vis` to keep track of seen integers.
4. It iterates over the reversed array:
   - If an integer `ai` has already been seen (exists in `vis`), it continues to the next integer.
   - If it hasn't been seen, it appends the integer to `ans` and adds it to `vis`.
5. After the loop, it prints the length of `ans` and the elements in `ans` in reversed order (since the original input order was reversed).

### Potential Issues:
- The program correctly identifies unique elements and keeps only the rightmost occurrence due to the reverse processing.
- However, it reverses the output list (`ans`) before printing. This is correct because it was initially reversed to process from the rightmost to the leftmost.

### Edge Cases:
- The program works correctly for the provided examples, including:
  - All elements are the same (e.g., `[6, 6, 6, 6, 6]`).
  - All elements are unique.
  - Mixed elements with varying duplicates.

### Conclusion:
After analyzing the code and considering potential edge cases, I could not find any instance where the program would not work as described. The implementation appears to be correct based on the problem requirements.

Correctness: **True**. 

The program effectively removes duplicates while maintaining the relative order of the rightmost occurrences, adhering to the problem description.