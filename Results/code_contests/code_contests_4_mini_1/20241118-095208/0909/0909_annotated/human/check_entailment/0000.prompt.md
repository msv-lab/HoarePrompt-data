
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are n warriors in a row. The power of the i-th warrior is a_i. All powers are pairwise distinct.

You have two types of spells which you may cast: 

  1. Fireball: you spend x mana and destroy exactly k consecutive warriors; 
  2. Berserk: you spend y mana, choose two consecutive warriors, and the warrior with greater power destroys the warrior with smaller power. 



For example, let the powers of warriors be [2, 3, 7, 8, 11, 5, 4], and k = 3. If you cast Berserk on warriors with powers 8 and 11, the resulting sequence of powers becomes [2, 3, 7, 11, 5, 4]. Then, for example, if you cast Fireball on consecutive warriors with powers [7, 11, 5], the resulting sequence of powers becomes [2, 3, 4].

You want to turn the current sequence of warriors powers a_1, a_2, ..., a_n into b_1, b_2, ..., b_m. Calculate the minimum amount of mana you need to spend on it.

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 2 ⋅ 10^5) — the length of sequence a and the length of sequence b respectively.

The second line contains three integers x, k, y (1 ≤ x, y, ≤ 10^9; 1 ≤ k ≤ n) — the cost of fireball, the range of fireball and the cost of berserk respectively.

The third line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n). It is guaranteed that all integers a_i are pairwise distinct.

The fourth line contains m integers b_1, b_2, ..., b_m (1 ≤ b_i ≤ n). It is guaranteed that all integers b_i are pairwise distinct.

Output

Print the minimum amount of mana for turning the sequnce a_1, a_2, ..., a_n into b_1, b_2, ..., b_m, or -1 if it is impossible.

Examples

Input


5 2
5 2 3
3 1 4 5 2
3 5


Output


8


Input


4 4
5 1 4
4 3 1 2
2 4 3 1


Output


-1


Input


4 4
2 1 11
1 3 2 4
1 3 2 4


Output


0
Annotated Program:
```
#Function 1:
def func_1():
    n, m = func_2()
    x, k, y = func_2()
    a = func_2()
    b = func_2()
    j = 0
    for (i, ax) in enumerate(a):
        if j < m and ax == b[j]:
            j += 1
        
    #State of the program after the  for loop has been executed: `n` and `m` are values returned by `func_2()`, `x`, `k`, `y` are also values returned from `func_2()`, `a` is a list with at least `n` elements, `b` is a value returned by `func_2()`, `j` is an integer that can range from 0 to `m`, depending on how many elements in `a` match the corresponding elements in `b` up to index `j`. If `m` is 0, the loop does not execute, and `j` remains 0. If `m` is greater than 0 and `a` has fewer than `m` elements, `j` may still remain less than `m` if no matches are found, or it may increase if matches are found. The loop executes for each element in `a`, and `i` varies from 0 to `len(a)-1`, with `ax` representing the current element in `a`. If `j` is less than `m` and `ax` equals `b[j]`, then `j` is incremented by 1; otherwise, it remains unchanged, capturing all edge cases regarding the values of `j`, `m`, `a`, and `b`.
    if (j < m) :
        print(-1)
        return
        #The program does not return any value; it effectively returns None.
    #State of the program after the if block has been executed: *`n`, `m`, `x`, `k`, `y` are values returned by `func_2()`, `a` is a list with at least `n` elements, and `b` is a value returned by `func_2()`. If `j` is less than `m`, the program prints -1 and returns None. If `m` is 0, the loop does not execute, and `j` remains 0. If `m` is greater than 0 and `a` has fewer than `m` elements, `j` may remain less than `m` if no matches are found, or it may increase if matches are found, but the output remains unaffected until the condition of `j < m` is met. In all cases where `j` is less than `m`, the function returns None.
    sa = set(a)
    sb = set(b)
    if (sa == sb) :
        print(0)
        return
        #The program returns None, as there is no value specified to return.
    #State of the program after the if block has been executed: *`n`, `m`, `x`, `k`, `y` are values returned by `func_2()`, `a` is a list with at least `n` elements, `b` is a value returned by `func_2()`, `sa` is a set created from the list `a`, and `sb` is a set created from the variable `b`. If the sets `sa` and `sb` are equal, the function prints 0 and returns None. If the sets are not equal, there is no specified behavior in the code to handle this case.
    mx = max(sa - sb)
    gaps = []
    j = 0
    gl = 0
    special = False
    for (i, ax) in enumerate(a):
        if j < m and ax == b[j]:
            j += 1
            if special:
                specialgap = gl
            gaps.append(gl)
            gl = 0
            special = False
        else:
            if ax == mx:
                special = True
            gl += 1
        
    #State of the program after the  for loop has been executed: `j` is the number of elements in `b` matched so far, `gaps` contains counts of gaps between matching elements in `a` and `b`, `gl` is the current count of consecutive non-matching elements, `special` indicates if the last processed element in `a` was the maximum value from `sa - sb`, and `specialgap` retains the last value of `gl` if a special condition was met. If `m` is 0, the loop does not execute, and `gaps` remains an empty list with `j`, `gl`, and `special` retaining their initial values. If `a` contains no elements or all elements do not match `b`, the loop will also not execute, leaving `gaps` empty and the other variables unchanged.
    if special :
        specialgap = gl
    #State of the program after the if block has been executed: *`j` is the number of elements in `b` matched so far, `gaps` contains counts of gaps between matching elements in `a` and `b`, `gl` is the current count of consecutive non-matching elements, and `special` indicates whether the last processed element in `a` was the maximum value from `sa - sb`. If `special` is true, then `specialgap` is assigned the value of `gl`. If `m` is 0, `gaps` remains an empty list, and `j`, `gl`, and `special` retain their initial values. If `a` contains no elements or all elements do not match `b`, the loop does not execute, leaving `gaps` empty and the other variables unchanged.
    gaps.append(gl)
    debug_print(gaps)
    if (specialgap < k) :
        print(-1)
        return
        #The program returns None (as nothing is explicitly returned)
    #State of the program after the if block has been executed: *`j` is the number of elements in `b` matched so far, `gaps` contains the value of `gl`, `gl` is the current count of consecutive non-matching elements, and `special` indicates whether the last processed element in `a` was the maximum value from `sa - sb`. If `specialgap` is less than `k`, the function prints -1 and returns, indicating that a special condition related to gaps was not met. In all other cases, there are no changes to the program state since the function does not explicitly return any value.
    ans = 0
    if (x < y * k) :
        for g in gaps:
            ans += x * (g // k) + y * (g % k)
            
        #State of the program after the  for loop has been executed: `ans` is updated to the sum of `x * (g // k) + y * (g % k)` for each element in `gaps`, where `g` iterates through all elements in `gaps`. If `gaps` is empty, the loop does not execute, and `ans` remains 0. `j` is the number of elements in `b` matched so far; `gl` is the current count of consecutive non-matching elements; `special` indicates whether the last processed element in `a` was the maximum value from `sa - sb`; `x` is still less than `y` multiplied by `k`.
    else :
        for g in gaps:
            ans += y * g
            
        #State of the program after the  for loop has been executed: `ans` is equal to the sum of `y` multiplied by each element in `gaps`, `j` is the number of elements in `b` matched so far, `gaps` contains all elements that were processed, `gl` is the current count of consecutive non-matching elements, `special` indicates whether the last processed element in `a` was the maximum value from `sa - sb`, and `x` is greater than or equal to `y * k`. If `gaps` is empty, the loop does not execute and `ans` remains 0.
    #State of the program after the if-else block has been executed: *`j` is the number of elements in `b` matched so far, `gaps` contains the values of `gl`, which is the current count of consecutive non-matching elements, `special` indicates whether the last processed element in `a` was the maximum value from `sa - sb`, and `ans` is updated based on the comparison of `x` and `y * k`. If `x` is less than `y * k`, `ans` is the sum of `x * (g // k) + y * (g % k)` for each element `g` in `gaps`, or remains 0 if `gaps` is empty. If `x` is greater than or equal to `y * k`, `ans` is equal to the sum of `y * g` for each element `g` in `gaps`, or remains 0 if `gaps` is empty.
    print(ans)

#Function 2:
def func_2():
    return [int(x) for x in input().split()]
    #The program returns a list of integers parsed from the input string, split by spaces

#Function 3:
def func_3(o):
    return [(int(x) + o) for x in input().split()]
    #The program returns a list of integers obtained by adding each integer from the input to x

#Function 4:
def func_4(n, m):
    return [func_2() for _ in range(n)]
    #The program returns a list containing the results of calling func_2() n times

#Function 5:
def func_5(f):
    return [func_5(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list generated by calling func_5 with f and the elements of dim starting from the second element, repeated dim[0] times, or the result of f() if dim is empty.


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
