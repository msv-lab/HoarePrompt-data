[
    {
        "description": "AtCoDeer the deer found two rectangles lying on the table, each with height 1 and width W. If we consider the surface of the desk as a two-dimensional plane, the first rectangle covers the vertical range of [0,1] and the horizontal range of [a,a+W], and the second rectangle covers the vertical range of [1,2] and the horizontal range of [b,b+W], as shown in the following figure:\n\n<image>\n\nAtCoDeer will move the second rectangle horizontally so that it connects with the first rectangle. Find the minimum distance it needs to be moved.\n\nConstraints\n\n* All input values are integers.\n* 1≤W≤10^5\n* 1≤a,b≤10^5\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nW a b\n\n\nOutput\n\nPrint the minimum distance the second rectangle needs to be moved.\n\nExamples\n\nInput\n\n3 2 6\n\n\nOutput\n\n1\n\n\nInput\n\n3 1 3\n\n\nOutput\n\n0\n\n\nInput\n\n5 10 1\n\n\nOutput\n\n4",
        "task_name": "p03778 AtCoder Beginner Contest 056 - NarrowRectanglesEasy",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# -*- coding: utf-8 -*-\n\nW, a, c= map(int,raw_input().split())\n\nb = a + W\nd = c + W\n\nif b < c:\n    ans = c - b\nelif d < a:\n    ans = a - d\nelse:\n    ans = 0\n    \nprint(ans)",
        "correct": true,
        "task_id": "1870"
    },
    {
        "description": "You a captain of a ship. Initially you are standing in a point (x_1, y_1) (obviously, all positions in the sea can be described by cartesian plane) and you want to travel to a point (x_2, y_2). \n\nYou know the weather forecast — the string s of length n, consisting only of letters U, D, L and R. The letter corresponds to a direction of wind. Moreover, the forecast is periodic, e.g. the first day wind blows to the side s_1, the second day — s_2, the n-th day — s_n and (n+1)-th day — s_1 again and so on. \n\nShip coordinates change the following way:\n\n  * if wind blows the direction U, then the ship moves from (x, y) to (x, y + 1); \n  * if wind blows the direction D, then the ship moves from (x, y) to (x, y - 1); \n  * if wind blows the direction L, then the ship moves from (x, y) to (x - 1, y); \n  * if wind blows the direction R, then the ship moves from (x, y) to (x + 1, y). \n\n\n\nThe ship can also either go one of the four directions or stay in place each day. If it goes then it's exactly 1 unit of distance. Transpositions of the ship and the wind add up. If the ship stays in place, then only the direction of wind counts. For example, if wind blows the direction U and the ship moves the direction L, then from point (x, y) it will move to the point (x - 1, y + 1), and if it goes the direction U, then it will move to the point (x, y + 2).\n\nYou task is to determine the minimal number of days required for the ship to reach the point (x_2, y_2).\n\nInput\n\nThe first line contains two integers x_1, y_1 (0 ≤ x_1, y_1 ≤ 10^9) — the initial coordinates of the ship.\n\nThe second line contains two integers x_2, y_2 (0 ≤ x_2, y_2 ≤ 10^9) — the coordinates of the destination point.\n\nIt is guaranteed that the initial coordinates and destination point coordinates are different.\n\nThe third line contains a single integer n (1 ≤ n ≤ 10^5) — the length of the string s.\n\nThe fourth line contains the string s itself, consisting only of letters U, D, L and R.\n\nOutput\n\nThe only line should contain the minimal number of days required for the ship to reach the point (x_2, y_2).\n\nIf it's impossible then print \"-1\".\n\nExamples\n\nInput\n\n\n0 0\n4 6\n3\nUUU\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n0 3\n0 0\n3\nUDD\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n0 0\n0 1\n1\nL\n\n\nOutput\n\n\n-1\n\nNote\n\nIn the first example the ship should perform the following sequence of moves: \"RRRRU\". Then its coordinates will change accordingly: (0, 0) → (1, 1) → (2, 2) → (3, 3) → (4, 4) → (4, 6).\n\nIn the second example the ship should perform the following sequence of moves: \"DD\" (the third day it should stay in place). Then its coordinates will change accordingly: (0, 3) → (0, 3) → (0, 1) → (0, 0).\n\nIn the third example the ship can never reach the point (0, 1).",
        "task_name": "1117_C. Magic Ship",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport itertools\nimport math\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n\nclass dict(dict):\n    \"\"\"dict() -> new empty dictionary\"\"\"\n\n    def items(self):\n        \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n        return dict.iteritems(self)\n\n    def keys(self):\n        \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n        return dict.iterkeys(self)\n\n    def values(self):\n        \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n        return dict.itervalues(self)\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nrange = xrange\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef main():\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n\n    if (x1 == x2)  and (y1 == y2):\n        print(0)\n        return\n\n    n = int(input())\n    s = input()\n\n    pref_sums = [[0, 0] for _ in range(n)]\n\n    u, r = 0, 0\n    if s[0] == 'U':\n        u = 1\n    if s[0] == 'D':\n        u = -1\n    if s[0] == 'R':\n        r = 1\n    if s[0] == 'L':\n        r = -1\n\n    pref_sums[0] = [r, u]\n    new_x, new_y = x1 + r, y1 + u\n\n    dist = abs(new_x - x2) + abs(new_y - y2) - 1\n    if dist <= 0:\n        print(1)\n        return\n\n    min_dist = dist\n    for i in range(1, n):\n        u, r = 0, 0\n        if s[i] == 'U':\n            u = 1\n        if s[i] == 'D':\n            u = -1\n        if s[i] == 'R':\n            r = 1\n        if s[i] == 'L':\n            r = -1\n\n        pref_sums[i] = [pref_sums[i - 1][0] + r, pref_sums[i - 1][1] + u]\n        new_x, new_y = x1 + pref_sums[i][0], y1 + pref_sums[i][1]\n        dist = abs(new_x - x2) + abs(new_y - y2) - i - 1\n\n        if dist <= 0:\n            print(i + 1)\n            return\n\n        if dist < min_dist:\n            min_dist = dist\n\n    moves_toward = abs(x1 - x2) + abs(y1 - y2) - (abs(new_x - x2) + abs(new_y - y2) - n)\n\n    if moves_toward <= 0:\n        print(-1)\n        return\n\n    cycles = (abs(x1 - x2) + abs(y1 - y2) - min_dist) // moves_toward\n    res = n * cycles\n\n    x1, y1 = x1 + cycles * pref_sums[-1][0], y1 + cycles * pref_sums[-1][1]\n\n    if abs(x1 - x2) + abs(y1 - y2) - n * cycles <= 0:\n        print(res)\n        return\n\n    for i in range(n):\n        new_x, new_y = x1 + pref_sums[i][0], y1 + pref_sums[i][1]\n        dist = abs(new_x - x2) + abs(new_y - y2) - i - n * cycles - 1\n        if dist <= 0:\n            print(res + i + 1)\n            return\n\n    return\n\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": false,
        "task_id": "2503"
    },
    {
        "description": "INTERCAL is the oldest of esoteric programming languages. One of its many weird features is the method of character-based output, known as Turing Tape method. It converts an array of unsigned 8-bit integers into a sequence of characters to print, using the following method.\n\nThe integers of the array are processed one by one, starting from the first. Processing i-th element of the array is done in three steps:\n\n1. The 8-bit binary notation of the ASCII-code of the previous printed character is reversed. When the first element of the array is processed, the result of this step is considered to be 0.\n\n2. The i-th element of the array is subtracted from the result of the previous step modulo 256.\n\n3. The binary notation of the result of the previous step is reversed again to produce ASCII-code of the i-th character to be printed.\n\nYou are given the text printed using this method. Restore the array used to produce this text.\n\nInput\n\nThe input will consist of a single line text which contains the message printed using the described method. String text will contain between 1 and 100 characters, inclusive. ASCII-code of each character of text will be between 32 (space) and 126 (tilde), inclusive.\n\nOutput\n\nOutput the initial array, which was used to produce text, one integer per line.\n\nExamples\n\nInput\n\nHello, World!\n\n\nOutput\n\n238\n108\n112\n0\n64\n194\n48\n26\n244\n168\n24\n16\n162\n\nNote\n\nLet's have a closer look at the beginning of the example. The first character is \"H\" with ASCII-code 72 = 010010002. Its reverse is 000100102 = 18, and this number should become the result of the second step of processing. The result of the first step is considered to be 0, so the first element of the array has to be (0 - 18) mod 256 = 238, where a mod b is the remainder of division of a by b.",
        "task_name": "133_C. Turing Tape",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/local/bin/python\n\n# \n\nimport math\nimport sys\n\ntable = {\n\t'>':8,\n\t'<':9,\n\t'+':10,\n\t'-':11,\n\t'.':12,\n\t',':13,\n\t'[':14,\n\t']':15\n}\n\ninput = sys.stdin.readline().rstrip()\n\nprev = 0\nfor c in input:\n\ts = \"{0:0>{1}}\".format(bin(ord(c))[2:], 8)\n\tbinary = s[::-1]\n\tinteger = int(binary, 2)\n\tprint (prev - integer) % 256\n\tprev = integer\n",
        "correct": true,
        "task_id": "4355"
    },
    {
        "description": "Today is Wednesday, the third day of the week. What's more interesting is that tomorrow is the last day of the year 2015.\n\nLimak is a little polar bear. He enjoyed this year a lot. Now, he is so eager to the coming year 2016.\n\nLimak wants to prove how responsible a bear he is. He is going to regularly save candies for the entire year 2016! He considers various saving plans. He can save one candy either on some fixed day of the week or on some fixed day of the month.\n\nLimak chose one particular plan. He isn't sure how many candies he will save in the 2016 with his plan. Please, calculate it and tell him.\n\nInput\n\nThe only line of the input is in one of the following two formats: \n\n  * \"x of week\" where x (1 ≤ x ≤ 7) denotes the day of the week. The 1-st day is Monday and the 7-th one is Sunday. \n  * \"x of month\" where x (1 ≤ x ≤ 31) denotes the day of the month. \n\nOutput\n\nPrint one integer — the number of candies Limak will save in the year 2016.\n\nExamples\n\nInput\n\n4 of week\n\n\nOutput\n\n52\n\n\nInput\n\n30 of month\n\n\nOutput\n\n11\n\nNote\n\nPolar bears use the Gregorian calendar. It is the most common calendar and you likely use it too. You can read about it on Wikipedia if you want to – <https://en.wikipedia.org/wiki/Gregorian_calendar>. The week starts with Monday.\n\nIn the first sample Limak wants to save one candy on each Thursday (the 4-th day of the week). There are 52 Thursdays in the 2016. Thus, he will save 52 candies in total.\n\nIn the second sample Limak wants to save one candy on the 30-th day of each month. There is the 30-th day in exactly 11 months in the 2016 — all months but February. It means that Limak will save 11 candies in total.",
        "task_name": "611_A. New Year and Days",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s = raw_input()\nprint (52 + (int(s[0]) / -2 == -3)) if s[5] == 'w' else (12 - (int(s[0]) == 3) - (int(s[:2]) == 31) * 4)",
        "correct": false,
        "task_id": "1210"
    },
    {
        "description": "You have a sequence a with n elements 1, 2, 3, ..., k - 1, k, k - 1, k - 2, ..., k - (n - k) (k ≤ n < 2k).\n\nLet's call as inversion in a a pair of indices i < j such that a[i] > a[j].\n\nSuppose, you have some permutation p of size k and you build a sequence b of size n in the following manner: b[i] = p[a[i]].\n\nYour goal is to find such permutation p that the total number of inversions in b doesn't exceed the total number of inversions in a, and b is lexicographically maximum.\n\nSmall reminder: the sequence of k integers is called a permutation if it contains all integers from 1 to k exactly once.\n\nAnother small reminder: a sequence s is lexicographically smaller than another sequence t, if either s is a prefix of t, or for the first i such that s_i ≠ t_i, s_i < t_i holds (in the first position that these sequences are different, s has smaller number than t).\n\nInput\n\nThe first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (k ≤ n < 2k; 1 ≤ k ≤ 10^5) — the length of the sequence a and its maximum.\n\nIt's guaranteed that the total sum of k over test cases doesn't exceed 10^5.\n\nOutput\n\nFor each test case, print k integers — the permutation p which maximizes b lexicographically without increasing the total number of inversions.\n\nIt can be proven that p exists and is unique.\n\nExample\n\nInput\n\n\n4\n1 1\n2 2\n3 2\n4 3\n\n\nOutput\n\n\n1 \n1 2 \n2 1 \n1 3 2 \n\nNote\n\nIn the first test case, the sequence a = [1], there is only one permutation p = [1].\n\nIn the second test case, the sequence a = [1, 2]. There is no inversion in a, so there is only one permutation p = [1, 2] which doesn't increase the number of inversions.\n\nIn the third test case, a = [1, 2, 1] and has 1 inversion. If we use p = [2, 1], then b = [p[a[1]], p[a[2]], p[a[3]]] = [2, 1, 2] and also has 1 inversion.\n\nIn the fourth test case, a = [1, 2, 3, 2], and since p = [1, 3, 2] then b = [1, 3, 2, 3]. Both a and b have 1 inversion and b is the lexicographically maximum.",
        "task_name": "1473_C. No More Inversions",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    input = open(sys.argv[1], 'r').readline\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    input = sys.stdin.readline\n\n# from math import ceil\n# from collections import defaultdict as dd\n# from heapq import *\n############ ---- I/O Functions ---- ############\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef strin():\n    s = input()\n    return s[:len(s) - 1]\ndef intlout(l):\n    print(\" \".join(map(str, l)))\n    \ndef getSum( BITree, index):\n    sum = 0 # Initialize result \n     \n    # Traverse ancestors of BITree[index] \n    while (index > 0): \n \n        # Add current element of BITree to sum \n        sum += BITree[index] \n \n        # Move index to parent node in getSum View \n        index -= index & (-index) \n \n    return sum\n \n# Updates a node in Binary Index Tree (BITree) \n# at given index in BITree. The given value\n# 'val' is added to BITree[i] and all of its\n# ancestors in tree. \ndef updateBIT(BITree, n, index, val):\n \n    # Traverse all ancestors and add 'val' \n    while (index <= n): \n \n        # Add 'val' to current node of BI Tree \n        BITree[index] += val \n \n        # Update index to that of parent\n        # in update View \n        index += index & (-index) \n \n# Returns count of inversions of size three \ndef getInvCount(arr, n):\n \n    invcount = 0 # Initialize result \n \n    # Find maximum element in arrays \n    maxElement = max(arr)\n \n    # Create a BIT with size equal to \n    # maxElement+1 (Extra one is used \n    # so that elements can be directly \n    # be used as index)\n    BIT = [0] * (maxElement + 1) \n    for i in range(1, maxElement + 1): \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1):\n \n        invcount += getSum(BIT, arr[i] - 1) \n        updateBIT(BIT, maxElement, arr[i], 1) \n    return invcount \n\ndef main():\n    n,k = intlin()\n    if n == k:\n        return range(1,k+1)\n    if n == k+1:\n        return range(1,k+1-2) + [k,k-1]\n    a = range(1,k+1) + range(k-1,2*k-n-1,-1)\n    maxInv = getInvCount(a,n)\n    for i in xrange(2*k-n, k):\n        a[k-1] = i\n        a[k-2] = k\n        a[k] = k\n        curInv = getInvCount(a,n)\n        if curInv <= maxInv:\n            ans = range(1,k+1)\n            ans[k-1] = i\n            ans[i-1] = k\n            return ans\n\n\nif __name__ == \"__main__\":\n    for _ in xrange(intin()):\n        print(main())\n        # print(\"YES\" if main() else \"NO\")\n    # main()\n\n    if testing:\n        sys.stdout = cmd\n        print(int(round(time() * 1000))  - start_time)",
        "correct": false,
        "task_id": "3085"
    }
]