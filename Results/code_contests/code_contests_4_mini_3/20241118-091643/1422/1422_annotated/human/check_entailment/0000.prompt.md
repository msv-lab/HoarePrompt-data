
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Kostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. 

Zahar has n stones which are rectangular parallelepipeds. The edges sizes of the i-th of them are ai, bi and ci. He can take no more than two stones and present them to Kostya. 

If Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. 

Help Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.

Input

The first line contains the integer n (1 ≤ n ≤ 105).

n lines follow, in the i-th of which there are three integers ai, bi and ci (1 ≤ ai, bi, ci ≤ 109) — the lengths of edges of the i-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.

Output

In the first line print k (1 ≤ k ≤ 2) the number of stones which Zahar has chosen. In the second line print k distinct integers from 1 to n — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to n in the order as they are given in the input data.

You can print the stones in arbitrary order. If there are several answers print any of them. 

Examples

Input

6
5 5 5
3 2 4
1 4 1
2 1 3
3 2 4
3 3 4


Output

1
1


Input

7
10 7 8
5 10 3
4 2 6
5 5 5
10 2 8
4 2 1
7 7 7


Output

2
1 5

Note

In the first example we can connect the pairs of stones:

  * 2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1
  * 2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. 
  * 2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5
  * 4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1
  * 5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5



Or take only one stone:

  * 1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5
  * 2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1
  * 3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5
  * 4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5
  * 5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1
  * 6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5



It is most profitable to take only the first stone. 
Annotated Program:
```
def func():
    n = int(stdin.readline())
    one = {}
    two = {}
    ans = []
    challengers = []
    for i in range(n):
        a, b, c = map(int, stdin.readline().split())
        
        challengers.append((a, b, c))
        
        first = max(a, b), min(a, b)
        
        second = max(a, c), min(a, c)
        
        third = max(b, c), min(b, c)
        
        if first in two:
            if two[first] < one[first][0] + c:
                ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))
                two[first] = one[first][0] + c
        elif first in one:
            two[first] = one[first][0] + c
            ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))
        
        if second in two:
            if two[second] < one[second][0] + c:
                ans.append((one[second][0] + b, second[0], second[1], one[second][1
                    ], i))
                two[second] = one[second][0] + b
        elif second in one:
            two[second] = one[second][0] + b
            ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))
        
        if third in two:
            if two[third] < one[third][0] + c:
                ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))
                two[third] = one[third][0] + a
        elif third in one:
            two[third] = one[third][0] + a
            ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))
        
        if first not in one or one[first][0] < c:
            one[first] = c, i
        
        if second not in one or one[second][0] < b:
            one[second] = b, i
        
        if third not in one or one[third][0] < a:
            one[third] = a, i
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `challengers` is a list containing tuples of (a, b, c) for each iteration; `one` and `two` are dictionaries that may contain keys representing pairs of values from `challengers`, with values being tuples indicating the maximum value and the index of the last occurrence; `ans` is a list that may contain tuples with processed results including cumulative values and indices. If `n` is 0, the loop does not execute, and `one`, `two`, and `ans` remain unchanged as empty structures. In each iteration, the variables `a`, `b`, and `c` are extracted from input; `first`, `second`, and `third` are determined by comparing these values, affecting how `one` and `two` are updated, and whether new entries are added to `ans`. There is no handling for invalid input cases or for scenarios where `stdin` does not provide sufficient data for `n` iterations.
    label = 0
    cnt = 0
    for (a, b, c, ind1, ind2) in ans:
        if min(min(a, b), c) > cnt:
            label = 2
            cnt = min(min(a, b), c)
            first = ind1
            second = ind2
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `ans` is a list containing tuples of (a, b, c, ind1, ind2). If `ans` is empty, the loop does not execute, and `label`, `cnt`, `first`, and `second` remain unchanged. If `ans` contains at least one tuple, the loop will execute once for each tuple. After execution, if the minimum of `a`, `b`, and `c` (for the last tuple processed) is greater than `cnt`, then `label` is set to 2, `cnt` is updated to this minimum value, `first` is assigned the value of `ind1`, and `second` is assigned the value of `ind2`. If the minimum of `a`, `b`, and `c` is less than or equal to `cnt`, the values of `label`, `cnt`, `first`, and `second` remain unchanged.
    for i in range(n):
        a, b, c = challengers[i]
        
        if min(min(a, b), c) > cnt:
            label = 1
            cnt = min(min(a, b), c)
            first = i
        
    #State of the program after the  for loop has been executed: If `ans` is a non-empty list of tuples, `label` is set to 1 if the minimum of `a`, `b`, and `c` from the last tuple processed is greater than `cnt`, `cnt` is updated to this minimum value, `first` is updated to the index of the last tuple processed, and `i` will be equal to `n-1`. If `ans` is empty, the loop does not execute, and `label`, `cnt`, `first`, and `second` remain unchanged. If `ans` contains at least one tuple and the minimum of `a`, `b`, and `c` for any tuple is less than or equal to `cnt`, then no updates are made to `label`, `cnt`, `first`, or `second`.
    if (label == 1) :
        stdout.write('1' + '\n' + str(first + 1))
    else :
        stdout.write('2' + '\n' + str(first + 1) + ' ' + str(second + 1))
    #State of the program after the if-else block has been executed: *If `ans` is a non-empty list of tuples and `label` is equal to 1, then `cnt` is the minimum of `a`, `b`, and `c` from the last tuple processed which is greater than the previous value of `cnt`, `first` is updated to the index of the last tuple processed, and the output is '1' followed by `first + 1`. If `label` is not equal to 1, `cnt`, `first`, and `second` remain unchanged, and the output is '2' followed by `first + 1` and `second + 1`. If `ans` is empty, no output is generated. Additionally, the case where the minimum of `a`, `b`, and `c` for any tuple is less than or equal to `cnt` results in the outputs corresponding to the second part, with no updates to `label`, `cnt`, `first`, or `second`.

```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
