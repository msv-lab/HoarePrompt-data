
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You have a sequence a with n elements 1, 2, 3, ..., k - 1, k, k - 1, k - 2, ..., k - (n - k) (k ≤ n < 2k).

Let's call as inversion in a a pair of indices i < j such that a[i] > a[j].

Suppose, you have some permutation p of size k and you build a sequence b of size n in the following manner: b[i] = p[a[i]].

Your goal is to find such permutation p that the total number of inversions in b doesn't exceed the total number of inversions in a, and b is lexicographically maximum.

Small reminder: the sequence of k integers is called a permutation if it contains all integers from 1 to k exactly once.

Another small reminder: a sequence s is lexicographically smaller than another sequence t, if either s is a prefix of t, or for the first i such that s_i ≠ t_i, s_i < t_i holds (in the first position that these sequences are different, s has smaller number than t).

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

The first and only line of each test case contains two integers n and k (k ≤ n < 2k; 1 ≤ k ≤ 10^5) — the length of the sequence a and its maximum.

It's guaranteed that the total sum of k over test cases doesn't exceed 10^5.

Output

For each test case, print k integers — the permutation p which maximizes b lexicographically without increasing the total number of inversions.

It can be proven that p exists and is unique.

Example

Input


4
1 1
2 2
3 2
4 3


Output


1 
1 2 
2 1 
1 3 2 

Note

In the first test case, the sequence a = [1], there is only one permutation p = [1].

In the second test case, the sequence a = [1, 2]. There is no inversion in a, so there is only one permutation p = [1, 2] which doesn't increase the number of inversions.

In the third test case, a = [1, 2, 1] and has 1 inversion. If we use p = [2, 1], then b = [p[a[1]], p[a[2]], p[a[3]]] = [2, 1, 2] and also has 1 inversion.

In the fourth test case, a = [1, 2, 3, 2], and since p = [1, 3, 2] then b = [1, 3, 2, 3]. Both a and b have 1 inversion and b is the lexicographically maximum.
Annotated Program:
```
#Function 1:
def func_1():
    return int(input())
    #The program returns an integer input from the user

#Function 2:
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained from the input, which is expected to contain n integers separated by spaces.

#Function 3:
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list containing all characters of string 's' except for the last character

#Function 4:
def func_4():
    s = input()
    return s[:len(s) - 1]
    #The program returns the input string 's' without its last character

#Function 5:
def func_5(l):
    print(' '.join(map(str, l)))

#Function 6:
def func_6(BITree, index):
    sum = 0
    while index > 0:
        sum += BITree[index]
        
        index -= index & -index
        
    #State of the program after the loop has been executed: `if index is greater than 0 then sum` is updated to the cumulative sum of BITree values corresponding to the indices determined by the decreasing value of `index` until `index` becomes 0. If index is 0 or negative before execution, the loop does not execute and `sum` remains 0.
    return sum
    #The program returns the cumulative sum of BITree values corresponding to indices determined by the decreasing value of `index`, or 0 if `index` is 0 or negative before execution.

#Function 7:
def func_7(BITree, n, index, val):
    while index <= n:
        BITree[index] += val
        
        index += index & -index
        
    #State of the program after the loop has been executed: `if index is less than or equal to n then index` will be updated based on the expression `index += index & -index` until index exceeds n. After the loop, index will be greater than n. If index starts greater than n, the loop will not execute and the value of index will remain unchanged.

#Function 8:
def func_8(arr, n):
    invcount = 0
    maxElement = max(arr)
    BIT = [0] * (maxElement + 1)
    for i in range(1, maxElement + 1):
        BIT[i] = 0
        
    #State of the program after the  for loop has been executed: If `maxElement` is at least 1, then `BIT` is a list of zeros with length `maxElement + 1`, and `i` is equal to `maxElement`. If `maxElement` is less than 1, then the loop does not execute, and `BIT` remains a list of zeros with length 1.
    for i in range(n - 1, -1, -1):
        invcount += func_6(BIT, arr[i] - 1)
        
        func_7(BIT, maxElement, arr[i], 1)
        
    #State of the program after the  for loop has been executed: If n is greater than 0, the loop will execute n times, decrementing i from n-1 to 0. After the loop, `invcount` will be updated based on the results from `func_6` for each element in `arr` and `BIT` will remain a list of zeros with length `maxElement + 1`. If n is 0 or less, the loop does not execute, and `invcount` remains unchanged, while `BIT` is still a list of zeros with length 1.
    return invcount
    #The program returns the value of invcount, which is updated based on the execution of func_6 if n is greater than 0, or remains unchanged if n is 0 or less.

#Function 9:
def func_9():
    n, k = func_2()
    if (n == k) :
        return range(1, k + 1)
        #The program returns a range object representing the integers from 1 to k (inclusive)
    #State of the program after the if block has been executed: *`t` is a positive integer representing the number of test cases, `n` and `k` are integers such that `k ≤ n < 2k` and `1 ≤ k ≤ 10^5`. If `n` is equal to `k`, the function returns a range object representing the integers from 1 to `k` (inclusive). If `n` is not equal to `k`, no value is returned from the function.
    if (n == k + 1) :
        return range(1, k + 1 - 2) + [k, k - 1]
        #The program returns a list containing the integers from 1 to k - 2 followed by k and k - 1
    #State of the program after the if block has been executed: *`t` is a positive integer representing the number of test cases, `n` and `k` are integers such that `k ≤ n < 2k` and `1 ≤ k ≤ 10^5`. If `n` is equal to `k + 1`, the function returns a range object representing the integers from 1 to `k - 2` followed by `k` and `k - 1`. If `n` is not equal to `k + 1`, no value is returned from the function.
    a = range(1, k + 1) + range(k - 1, 2 * k - n - 1, -1)
    maxInv = func_8(a, n)
    for i in xrange(2 * k - n, k):
        a[k - 1] = i
        
        a[k - 2] = k
        
        a[k] = k
        
        curInv = func_8(a, n)
        
        if curInv <= maxInv:
            ans = range(1, k + 1)
            ans[k - 1] = i
            ans[i - 1] = k
            return ans
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `n` is an integer such that `k ≤ n < 2 * k`, `k` is an integer. If `n` is less than `k + 2`, the loop will not execute, and `a` and `ans` remain unchanged. If `n` is at least `k + 2`, the loop will execute with `i` taking values from `2 * k - n` to `k - 1`. For each iteration, `a[k - 1]` is set to `i`, `a[k - 2]` is `k`, and `a[k]` is `k`. If `curInv` is less than or equal to `maxInv`, `ans` is populated with values from 1 to `k`, where `ans[k - 1]` is `i` and `ans[i - 1]` is `k`, and the function returns `ans`. If no valid `curInv` is found during iterations, no value is returned.


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
