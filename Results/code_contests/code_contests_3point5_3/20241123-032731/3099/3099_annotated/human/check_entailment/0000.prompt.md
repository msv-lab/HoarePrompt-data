
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: It's hard times now. Today Petya needs to score 100 points on Informatics exam. The tasks seem easy to Petya, but he thinks he lacks time to finish them all, so he asks you to help with one..

There is a glob pattern in the statements (a string consisting of lowercase English letters, characters "?" and "*"). It is known that character "*" occurs no more than once in the pattern.

Also, n query strings are given, it is required to determine for each of them if the pattern matches it or not.

Everything seemed easy to Petya, but then he discovered that the special pattern characters differ from their usual meaning.

A pattern matches a string if it is possible to replace each character "?" with one good lowercase English letter, and the character "*" (if there is one) with any, including empty, string of bad lowercase English letters, so that the resulting string is the same as the given string.

The good letters are given to Petya. All the others are bad.

Input

The first line contains a string with length from 1 to 26 consisting of distinct lowercase English letters. These letters are good letters, all the others are bad.

The second line contains the pattern — a string s of lowercase English letters, characters "?" and "*" (1 ≤ |s| ≤ 105). It is guaranteed that character "*" occurs in s no more than once.

The third line contains integer n (1 ≤ n ≤ 105) — the number of query strings.

n lines follow, each of them contains single non-empty string consisting of lowercase English letters — a query string.

It is guaranteed that the total length of all query strings is not greater than 105.

Output

Print n lines: in the i-th of them print "YES" if the pattern matches the i-th query string, and "NO" otherwise.

You can choose the case (lower or upper) for each letter arbitrary.

Examples

Input

ab
a?a
2
aaa
aab


Output

YES
NO


Input

abc
a?a?a*
4
abacaba
abaca
apapa
aaaaax


Output

NO
YES
NO
YES

Note

In the first example we can replace "?" with good letters "a" and "b", so we can see that the answer for the first query is "YES", and the answer for the second query is "NO", because we can't match the third letter.

Explanation of the second example. 

  * The first query: "NO", because character "*" can be replaced with a string of bad letters only, but the only way to match the query string is to replace it with the string "ba", in which both letters are good. 
  * The second query: "YES", because characters "?" can be replaced with corresponding good letters, and character "*" can be replaced with empty string, and the strings will coincide. 
  * The third query: "NO", because characters "?" can't be replaced with bad letters. 
  * The fourth query: "YES", because characters "?" can be replaced with good letters "a", and character "*" can be replaced with a string of bad letters "x". 
Annotated Program:
```
def func():
    gls = raw_input()
    good_letters = set(c for c in gls)
    p = raw_input()
    plen = len(p)
    n = input()
    if ('*' not in p) :
        for _ in range(n):
            q = raw_input()
            
            qlen = len(q)
            
            if qlen != plen:
                print('NO')
                continue
            
            y = True
            
            for i in range(plen):
                if p[i] == '?':
                    if q[i] not in good_letters:
                        print('NO')
                        y = False
                        break
                elif p[i] != q[i]:
                    print('NO')
                    y = False
                    break
            
            if y:
                print('YES')
            
        #State of the program after the  for loop has been executed: Output State: 
        #If `plen` is not equal to the length of the input strings `q`, the loop does not execute, and the program remains in the initial state. If the loop executes, it compares each character at index `i` in strings `p` and `q`. If `p[i]` is a question mark ('?'), then `q[i]` must be in `good_letters`; otherwise, 'NO' is printed, `y` is set to False, and the loop breaks. If `p[i]` is not equal to `q[i]`, 'NO' is printed, `y` is set to False, and the loop breaks. After the execution of the if-else block, if `y` is True, 'YES' is printed. This ensures that the program handles all cases where the characters at the corresponding positions in strings `p` and `q` meet the specified conditions, maintaining the integrity of the program's logic and printing 'YES' appropriately.
        #Output State: If the loop does not execute due to `qlen` being different from `plen`, the program remains in the initial state. If the loop executes, `q` is a string, `qlen` is the length of `q`, `plen` is the range value for the loop, and `y` is a boolean. If any character at index `i` in `q` is not in `good_letters` or if the character at index `i` in string `p` is not equal to the character at index `i` in string `q`, 'NO' is printed, `y` is set to False, and the loop breaks. Otherwise, if all conditions are met, 'YES' is printed, and no changes are made to the variables `q`, `qlen`, `plen`, and `y`.
        #Output State: If the loop does not execute due to the length of `q` not being equal to `plen`, the program remains in the initial state. During the loop execution, if the ith element of `p` is a question mark ('?') and the ith element of `q` is not in the list of `good_letters`, 'NO' is printed, `y` is set to False, and a break statement is encountered. If the ith element of `p` is not equal to the ith element of `q`, 'NO' is printed, `y` is set to False, and a break statement is executed. If no conditions are met during the loop execution, 'YES' is printed.
    else :
        p0, p1 = p.split('*')
        p1 = p1[::-1]
        p0len = len(p0)
        p1len = len(p1)
        for _ in range(n):
            q = raw_input()
            
            qlen = len(q)
            
            if qlen < plen - 1:
                print('NO')
                continue
            
            y0 = True
            
            for i in range(p0len):
                if p0[i] == '?':
                    if q[i] not in good_letters:
                        print('NO')
                        y0 = False
                        break
                elif p0[i] != q[i]:
                    print('NO')
                    y0 = False
                    break
            
            if y0 == False:
                continue
            
            y1 = True
            
            qr = q[::-1]
            
            for i in range(p1len):
                if p1[i] == '?':
                    if qr[i] not in good_letters:
                        print('NO')
                        y1 = False
                        break
                elif p1[i] != qr[i]:
                    print('NO')
                    y1 = False
                    break
            
            if y1 == False:
                continue
            
            t = None
            
            if p1len == 0:
                t = q[p0len:]
            else:
                t = q[p0len:-p1len]
            
            if len(set(t).intersection(good_letters)) > 0:
                print('NO')
                continue
            
            if y0 and y1:
                print('YES')
            
        #State of the program after the  for loop has been executed: If the length of the input string `p` is less than 1, the loop will not execute. After each iteration of the loop, the program checks the validity of the input `q` based on the parts `p0` and `p1`. The variable `t` is assigned based on conditions considering the lengths of `p1` and `p0` in relation to the length of `q`. If the intersection of `t` with `good_letters` contains at least one element, 'NO' is printed, and the loop continues. If both `y0` and `y1` are True, 'YES' is printed.
    #State of the program after the if-else block has been executed: *`gls` is the input string, `good_letters` is a set of unique characters from the input string, `p` is the input string from raw_input(), `plen` is the length of the input string `p`. If '*' is not in `p`, the program checks if the length of input string `q` matches `plen`. If not, 'NO' is printed. If the characters at corresponding indices in `p` and `q` do not meet the specified conditions, 'NO' is printed. If all conditions are met, 'YES' is printed. If '*' is in `p`, the program splits `p` into `p0` and `p1`. It then reverses `p1` and compares the characters in `p0` and `q` followed by the characters in `p1` and the reversed `q`. If any characters do not meet the specified conditions, 'NO' is printed. If the intersection of `t` with `good_letters` contains any element, 'NO' is printed. If all conditions are met, 'YES' is printed. This ensures that the program handles all cases correctly, including edge cases, and maintains the integrity of the logic.

```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
