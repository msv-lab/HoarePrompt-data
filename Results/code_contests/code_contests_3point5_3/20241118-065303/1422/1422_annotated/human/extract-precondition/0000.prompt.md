
You are given a programming problem description and a program that solves to this problem. From the problem description, extract a description of the values of the program's input variables and relationship between these variables. We refer to this description as precondition. Print the precondition following the word "Precondition", and surrounded with double asterisks (**). Follow these examples:

# Example 1

Problem description: write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].
Program:
```
R = 3
C = 3
def min_cost(cost, m, n):
	tc = [[0 for x in range(C)] for x in range(R)]
	tc[0][0] = cost[0][0]
	for i in range(1, m+1):
		tc[i][0] = tc[i-1][0] + cost[i][0]
	for j in range(1, n+1):
		tc[0][j] = tc[0][j-1] + cost[0][j]
	for i in range(1, m+1):
		for j in range(1, n+1):
			tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
	return tc[m][n]
```

Precondition: **cost is a 2D list of non-negative integers, m and n are non-negative integers such that 0 <= m < len(cost) and 0 <= n < len(cost[0]).**

# Example 2

Problem description: Write a function to find the similar elements from the given two tuple lists.
Program:
```
def similar_elements(test_tup1, test_tup2):
  res = tuple(set(test_tup1) & set(test_tup2))
  return (res) 
```

Precondition: **test_tup1 and test_tup2 are tuples.**

# Example 3

Problem description: Write a python function to identify non-prime numbers.
Program:
```
import math
def is_not_prime(n):
    result = False
    for i in range(2,int(math.sqrt(n)) + 1):
        if n % i == 0:
            result = True
    return result
```

Precondition: **n is an integer greater than 1.**

# Example 4

Problem description: Write a function to find the largest integers from a given list of numbers using heap queue algorithm.
Program:
```
import heapq as hq
def heap_queue_largest(nums,n):
  largest_nums = hq.nlargest(n, nums)
  return largest_nums
```

Precondition: **nums is a list of integers, and n is a non-negative integer such that 0 <= n <= len(nums).**

# Example 5

Problem description: Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.
Program:
```
def count_ways(n):
  A = [0] * (n + 1)
  B = [0] * (n + 1)
  A[0] = 1
  A[1] = 0
  B[0] = 0
  B[1] = 1
  for i in range(2, n+1):
    A[i] = A[i - 2] + 2 * B[i - 1]
    B[i] = A[i - 1] + B[i - 2]
  return A[n] 
```

Precondition: **n is a non-negative integer.**

# Your task

Problem description: Kostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. 

Zahar has n stones which are rectangular parallelepipeds. The edges sizes of the i-th of them are ai, bi and ci. He can take no more than two stones and present them to Kostya. 

If Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. 

Help Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.

Input

The first line contains the integer n (1 ≤ n ≤ 105).

n lines follow, in the i-th of which there are three integers ai, bi and ci (1 ≤ ai, bi, ci ≤ 109) — the lengths of edges of the i-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.

Output

In the first line print k (1 ≤ k ≤ 2) the number of stones which Zahar has chosen. In the second line print k distinct integers from 1 to n — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to n in the order as they are given in the input data.

You can print the stones in arbitrary order. If there are several answers print any of them. 

Examples

Input

6
5 5 5
3 2 4
1 4 1
2 1 3
3 2 4
3 3 4


Output

1
1


Input

7
10 7 8
5 10 3
4 2 6
5 5 5
10 2 8
4 2 1
7 7 7


Output

2
1 5

Note

In the first example we can connect the pairs of stones:

  * 2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1
  * 2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. 
  * 2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5
  * 4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1
  * 5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5



Or take only one stone:

  * 1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5
  * 2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1
  * 3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5
  * 4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5
  * 5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1
  * 6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5



It is most profitable to take only the first stone. 
Program:
```
from sys import stdin, stdout
def func():
    n = int(stdin.readline())
    one = {}
    two = {}
    ans = []
    challengers = []
    for i in range(n):
        (a, b, c) = map(int, stdin.readline().split())
        challengers.append((a, b, c))
        first = (max(a, b), min(a, b))
        second = (max(a, c), min(a, c))
        third = (max(b, c), min(b, c))
        if first in two:
            if two[first] < one[first][0] + c:
                ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))
                two[first] = one[first][0] + c
        elif first in one:
            two[first] = one[first][0] + c
            ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))
        if second in two:
            if two[second] < one[second][0] + c:
                ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))
                two[second] = one[second][0] + b
        elif second in one:
            two[second] = one[second][0] + b
            ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))
        if third in two:
            if two[third] < one[third][0] + c:
                ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))
                two[third] = one[third][0] + a
        elif third in one:
            two[third] = one[third][0] + a
            ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))
        if first not in one or one[first][0] < c:
            one[first] = (c, i)
        if second not in one or one[second][0] < b:
            one[second] = (b, i)
        if third not in one or one[third][0] < a:
            one[third] = (a, i)
    label = 0
    cnt = 0
    for (a, b, c, ind1, ind2) in ans:
        if min(min(a, b), c) > cnt:
            label = 2
            cnt = min(min(a, b), c)
            first = ind1
            second = ind2
    for i in range(n):
        (a, b, c) = challengers[i]
        if min(min(a, b), c) > cnt:
            label = 1
            cnt = min(min(a, b), c)
            first = i
    if label == 1:
        stdout.write('1' + '\n' + str(first + 1))
    else:
        stdout.write('2' + '\n' + str(first + 1) + ' ' + str(second + 1))
```

