
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
We have added some annotations within the code to help you understand the code and its logic. The annotations are in the form of comments and are inserted automatically so double check whether the annotations are correct or not and describe the code correctly.
If the annotations are correct use them along with the code to determine the correctness of the code. If the annotations are incorrect then you can ignore them and just use the code to determine the correctness.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: This is the easy version of the problem. The difference between the versions is that in the easy version all prices a_i are different. You can make hacks if and only if you solved both versions of the problem.

Today is Sage's birthday, and she will go shopping to buy ice spheres. All n ice spheres are placed in a row and they are numbered from 1 to n from left to right. Each ice sphere has a positive integer price. In this version all prices are different.

An ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.

You can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.

Input

The first line contains a single integer n (1 ≤ n ≤ 10^5) — the number of ice spheres in the shop.

The second line contains n different integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the prices of ice spheres.

Output

In the first line print the maximum number of ice spheres that Sage can buy.

In the second line print the prices of ice spheres in the optimal order. If there are several correct answers, you can print any of them.

Example

Input


5
1 2 3 4 5


Output


2
3 1 4 2 5 

Note

In the example it's not possible to place ice spheres in any order so that Sage would buy 3 of them. If the ice spheres are placed like this (3, 1, 4, 2, 5), then Sage will buy two spheres: one for 1 and one for 2, because they are cheap.
Annotated Program:
```
#Function 1:
def func_1():
    return int(input())
    #The program returns the integer input by the user

#Function 2:
def func_2():
    return input()
    #The program returns the input provided

#Function 3:
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers after converting the input string into integers

#Function 4:
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a list of strings where each element is converted from the input integers to strings

#Function 5:
def func_5():
    return list(func_3())
    #The program returns a list of positive integers after applying func_3() on each element of list 'a'

#Function 6:
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
def func_7(item):
    return item[1]
    #The program returns the element at index 1 of the list 'item'

#Function 8:
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in reverse order based on the key function 'getKey'

#Function 9:
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each row contains 'm' copies of the respective price of ice sphere. The total number of rows in the 2D list is 'n' representing the number of ice spheres in the shop.

#Function 10:
def func_10(x):
    return x and not x & x - 1
    #The program returns either True or False

#Function 11:
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n without the '0b' prefix.

#Function 12:
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each element is a digit of the positive integer 'n'

#Function 13:
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the value of nCr where n is a positive integer and r is a positive integer less than or equal to n.

#Function 14:
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the result of x divided by y, where x and y are integers and x is divisible by y with no remainder
    else :
        return x // y + 1
        #The program returns the result of the integer division of x by y plus 1
    #State of the program after the if-else block has been executed: *n is a positive integer representing the number of ice spheres in the shop. a_1, a_2, ..., a_n are positive integers representing the prices of the ice spheres, and all prices are distinct. If x is divisible by y with no remainder, the function returns the result of x divided by y. Otherwise, the function returns the result of the integer division of x by y plus 1.

#Function 15:
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `n` remains a positive integer, `a_i` are positive integers with unique values, `x` is updated by the multiplication and modulo operation, `y` is either halved, `res` is updated. If the original `y` was odd, then `res` is multiplied by `x` and then modulo `p`. The loop will continue until `y` reaches 0.
    return res
    #The program returns the final value of 'res' after all iterations

#Function 16:
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: If n is 1, x will be the price of the only ice sphere, and y will be 0. If n is greater than 1, x will be the GCD of all ice sphere prices, and y will be 0. If n is not a positive integer, the loop will not execute.
    return x
    #The program returns the price of the ice sphere(s) based on the conditions stated

#Function 17:
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer. If n is less than or equal to 1, the function returns False. There are no other cases or modifications to the variables after the execution of the if-else block.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is an integer. If `n` is less than or equal to 1, the function returns False. If `n` is greater than 1 but less than or equal to 3, the function returns True. There are no other cases or modifications to the variables after the execution of the if-else block.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer. If `n` is less than or equal to 1, the function returns False. If `n` is greater than 1 but less than or equal to 3, the function returns True. If `n` is divisible by 2 or 3, the function returns False. There are no other cases or modifications to the variables after the execution of the if-else block.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: Output State: 
    #
    #If `n` is less than or equal to 1, the function returns False. If `n` is greater than 1 but less than or equal to 3, the function returns True. If `n` is divisible by 2 or 3, the function returns False. After the execution of the loop, `n` is an integer. If `n` is divisible by either `i` or `i + 2`, the program returns False. In all other cases, the program does not modify the state and continues with the next part of the code. The value of `i` is updated to the next multiple of 6 after each iteration of the loop.
    return True
    #The program returns True

#Function 18:
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
def func_19():
    n = func_1()
    a = func_5()
    ans = 0
    i = 0
    j = n - 1
    b = []
    f = 0
    for k in range(n):
        if f == 0:
            b.append(a[j])
            j -= 1
            f ^= 1
        else:
            b.append(a[i])
            i += 1
            f ^= 1
        
    #State of the program after the  for loop has been executed: If `n` is greater than 0, `ans` is 0, `i`, `j`, `k` are integers, `b` contains elements from list `a` based on the conditions in the program fragment, `f` is toggled between 0 and 1. If `f` was initially 0, elements are added to `b` from `a` starting at index `j` and moving towards index 0, decrementing `j` and toggling `f` to 1. If `f` was initially 1, elements are added to `b` from `a` starting at index 0 and moving towards index `n-1`, incrementing `i` and toggling `f` to 0. If `n` is 0 or negative, the loop does not execute and `b` remains empty, `i`, `j`, `k` are 0, and `f` is 0.
    for i in range(1, n - 1):
        if b[i] < b[i - 1] and b[i] < b[i + 1]:
            ans += 1
        
    #State of the program after the  for loop has been executed: If `n` is greater than 1, the loop will execute at least once. `ans` will be incremented by 1 for each element in `b` that satisfies the specified conditions. `i` will be at least 1, `j` will be 0, `k` will be 0, and `f` will toggle between 0 and 1. The loop will not execute if `n` is 0 or negative, leaving `ans` at 0, `i`, `j`, `k` at 0, and `f` at 0.
    func_20(ans)
    func_20(*b)

#Function 20:
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: If args is not empty, the loop writes the elements of args to the file separated by sep. at_start is False after the loop executes. If args is empty, the loop does not execute, and at_start remains True.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *If args is not empty, the loop writes the elements of args to the file separated by sep. at_start is False after the loop executes. If args is empty, the loop does not execute, and at_start remains True. If kwargs has the key 'flush' and its value is True, then the file is flushed. Otherwise, no action is taken.


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
