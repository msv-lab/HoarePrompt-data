[
    {
        "description": "Mr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to n (n ≥ 2) burles and the amount of tax he has to pay is calculated as the maximum divisor of n (not equal to n, of course). For example, if n = 6 then Funt has to pay 3 burles, while for n = 25 he needs to pay 5 and if n = 2 he pays only 1 burle.\n\nAs mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial n in several parts n1 + n2 + ... + nk = n (here k is arbitrary, even k = 1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition ni ≥ 2 should hold for all i from 1 to k.\n\nOstap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split n in parts.\n\nInput\n\nThe first line of the input contains a single integer n (2 ≤ n ≤ 2·109) — the total year income of mr. Funt.\n\nOutput\n\nPrint one integer — minimum possible number of burles that mr. Funt has to pay as a tax.\n\nExamples\n\nInput\n\n4\n\n\nOutput\n\n2\n\n\nInput\n\n27\n\n\nOutput\n\n3",
        "task_name": "736_B. Taxes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\" ***E-property of Saket Saumya ***\n            IIITM\n\n\"\"\"\nfrom __future__ import division\nfrom fractions import Fraction\nimport math\n#import os\n#import random\n#import re\n#from sys import stdin, stdout\n#from collections import Counter,deque,OrderedDict,defaultdict\n#from itertools import permutations,ansduct,combinations\n#from heapq import heapify,heappush,heappop,heappushpop,heapify,heapreplace,nlargest,nsmallest\n#import numpy as np\n#from operator import mul\n\nMOD=10**9+7\nINF=float('+inf')\n\ndef si():\n\treturn str(stdin.readline())\ndef ii():\n    return int(raw_input())\ndef mi():\n    return map(int, raw_input().split())\ndef li():\n    return [int(i) for i in raw_input().split()]\ndef debug(x):\n\treturn stdout.write(str(x))\ndef limul(list):\n\treturn eval('*'.join(str(item) for item in list))\n\n\"-----------------------------------------------\"\ndef isPrime(n):\n    for i in range(2,int(n**0.5+100)):\n        if n%i==0 and n!=i:\n            return False\n    return True\n\nn=int(input())\nif isPrime(n):\n    print(1)\nelif n%2==0:\n    print(2)\nelif isPrime(n-2):\n    print(2)\nelse:\n    print(3)\n\n\n\n\n\n\n\n#main()\n",
        "correct": true,
        "task_id": "1342"
    },
    {
        "description": "Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.\n\nInput\n\nThe first line contains two space-separated integers n and m (1 ≤ m ≤ n ≤ 100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai ( - 1000 ≤ ai ≤ 1000) — prices of the TV sets. \n\nOutput\n\nOutput the only number — the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.\n\nExamples\n\nInput\n\n5 3\n-6 0 35 -2 4\n\n\nOutput\n\n8\n\n\nInput\n\n4 2\n7 0 0 -7\n\n\nOutput\n\n7",
        "task_name": "34_B. Sale",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "r=lambda:map(int,raw_input().split())\na,b=r()\n\nprint -sum(sorted(r())[ :b])\n",
        "correct": false,
        "task_id": "2092"
    },
    {
        "description": "Recently you have received two positive integer numbers x and y. You forgot them, but you remembered a shuffled list containing all divisors of x (including 1 and x) and all divisors of y (including 1 and y). If d is a divisor of both numbers x and y at the same time, there are two occurrences of d in the list.\n\nFor example, if x=4 and y=6 then the given list can be any permutation of the list [1, 2, 4, 1, 2, 3, 6]. Some of the possible lists are: [1, 1, 2, 4, 6, 3, 2], [4, 6, 1, 1, 2, 3, 2] or [1, 6, 3, 2, 4, 1, 2].\n\nYour problem is to restore suitable positive integer numbers x and y that would yield the same list of divisors (possibly in different order).\n\nIt is guaranteed that the answer exists, i.e. the given list of divisors corresponds to some positive integers x and y.\n\nInput\n\nThe first line contains one integer n (2 ≤ n ≤ 128) — the number of divisors of x and y.\n\nThe second line of the input contains n integers d_1, d_2, ..., d_n (1 ≤ d_i ≤ 10^4), where d_i is either divisor of x or divisor of y. If a number is divisor of both numbers x and y then there are two copies of this number in the list.\n\nOutput\n\nPrint two positive integer numbers x and y — such numbers that merged list of their divisors is the permutation of the given list of integers. It is guaranteed that the answer exists.\n\nExample\n\nInput\n\n\n10\n10 2 8 1 2 4 1 20 4 5\n\n\nOutput\n\n\n20 8",
        "task_name": "1108_B. Divisors of Two Integers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nnb_test = 0\n\nidx = 0\nfor line in sys.stdin:\n    if idx != 0:\n        list_divisors = map(int, line.strip().split(\" \"))\n        a, b = list_divisors[0], list_divisors[1]\n        a, b = (b, a) if a > b else (a, b)\n\n        for d in list_divisors[2:]:\n            if d >= b:\n                if d % b == 0:\n                    b = d\n                elif d % a == 0:\n                    a = d\n\n                a, b = (b, a) if a > b  else (a, b)\n            else:\n                if d >= a:\n                    if d % a == 0:\n                        a = d\n\n        sys.stdout.write(\"%d %d\\n\" % (a, b))\n    idx += 1\n",
        "correct": false,
        "task_id": "1652"
    },
    {
        "description": "Now Fox Ciel becomes a commander of Tree Land. Tree Land, like its name said, has n cities connected by n - 1 undirected roads, and for any two cities there always exists a path between them.\n\nFox Ciel needs to assign an officer to each city. Each officer has a rank — a letter from 'A' to 'Z'. So there will be 26 different ranks, and 'A' is the topmost, so 'Z' is the bottommost.\n\nThere are enough officers of each rank. But there is a special rule must obey: if x and y are two distinct cities and their officers have the same rank, then on the simple path between x and y there must be a city z that has an officer with higher rank. The rule guarantee that a communications between same rank officers will be monitored by higher rank officer.\n\nHelp Ciel to make a valid plan, and if it's impossible, output \"Impossible!\".\n\nInput\n\nThe first line contains an integer n (2 ≤ n ≤ 105) — the number of cities in Tree Land.\n\nEach of the following n - 1 lines contains two integers a and b (1 ≤ a, b ≤ n, a ≠ b) — they mean that there will be an undirected road between a and b. Consider all the cities are numbered from 1 to n.\n\nIt guaranteed that the given graph will be a tree.\n\nOutput\n\nIf there is a valid plane, output n space-separated characters in a line — i-th character is the rank of officer in the city with number i. \n\nOtherwise output \"Impossible!\".\n\nExamples\n\nInput\n\n4\n1 2\n1 3\n1 4\n\n\nOutput\n\nA B B B\n\n\nInput\n\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n\n\nOutput\n\nD C B A D C B D C D\n\nNote\n\nIn the first example, for any two officers of rank 'B', an officer with rank 'A' will be on the path between them. So it is a valid solution.",
        "task_name": "321_C. Ciel the Commander",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ndef ph(queue, n, nodes):\n    HM = 2*26-1\n    res = [0]*n\n    while queue:\n        #print queue[0]\n        #print nodes\n        cur = queue.pop(0)\n        val = cur[1]\n        ind = cur[0]\n        res[ind] = val\n        if val > HM:\n            break\n        val += 1\n        \n        for sosed in nodes[ind]:\n            if res[sosed] == 0:\n                queue.append([sosed, val])\n                #print 'addd ' + str(sosed) + ' ' + str(val)\n        \n    if max(res) > HM:\n        return \"Impossible!\"\n    else:\n        for ind in xrange(len(res)):\n            val = res[ind]\n            if val > 26:\n                res[ind] = 2*26-val\n        \n        return ' '.join(map(lambda x: chr(26-x+ord('A')), res))\n\nif True:\n    n = int(sys.stdin.readline())\n    edges = []\n    for i in xrange(n-1):\n        edges.append(map(lambda x: int(x)-1, sys.stdin.readline().split()))\n    #print edges\nelse:\n    n = 10\n    edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9]]\n\nnodes = []\nfor i in xrange(n):\n    nodes.append([])\n#print edges\n\nfor edge in edges:\n    #print edge[0], edge[1]\n    nodes[edge[0]].append(edge[1])\n    nodes[edge[1]].append(edge[0])\n\n#print nodes\nqueue = []\nfor ind in xrange(len(nodes)):\n    if len(nodes[ind]) == 1:\n        queue.append([ind, 1])\nprint(ph(queue, n, nodes))\n",
        "correct": false,
        "task_id": "2430"
    },
    {
        "description": "The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.\n\nHowever, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length n whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.\n\nA string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero) characters.\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 5000) — the number of test cases.\n\nThe first line of each test case contains an integer n (3 ≤ n < 10^5), the number of characters in the string entered in the document. It is guaranteed that n is divisible by 3.\n\nThe second line of each test case contains a string of length n consisting of only the characters T and M.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\n\nOutput\n\nFor each test case, print a single line containing YES if the described partition exists, and a single line containing NO otherwise.\n\nExample\n\nInput\n\n\n5\n3\nTMT\n3\nMTT\n6\nTMTMTT\n6\nTMTTTT\n6\nTTMMTT\n\n\nOutput\n\n\nYES\nNO\nYES\nNO\nYES\n\nNote\n\nIn the first test case, the string itself is already a sequence equal to TMT.\n\nIn the third test case, we may partition the string into the subsequences TMTMTT. Both the bolded and the non-bolded subsequences are equal to TMT.",
        "task_name": "1509_B. TMT Document",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom collections import deque\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n        s = input()\n\n        t = deque()\n        m = deque()\n\n        for i, si in enumerate(s):\n            if si == 'T':\n                t.append(i)\n            else:\n                m.append(i)\n\n        poss = len(m) * 2 == len(t)\n        if poss:\n            arr = [0] * (len(t) // 2)\n            for i in range(len(t) // 2):\n                poss &= t.popleft() < m[0]\n                arr[i] = m.popleft()\n            for i in arr:\n                poss &= i < t.popleft()\n\n        print(\"YES\" if poss else \"NO\")\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0956"
    }
]