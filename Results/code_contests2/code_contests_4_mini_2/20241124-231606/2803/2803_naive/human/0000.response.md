To determine the correctness of the provided program based on the problem description, let's analyze the requirements and the code:

### Problem Requirements:
1. Grisha can take up to `k` candies from a total of `n` candies.
2. Each candy has a unique tastiness value from 1 to `n`.
3. The goal is to maximize the xor-sum of the selected candies.

### Provided Program:
```python
(n, k) = map(int, raw_input().split())
print(2 ** len(bin(n)[2:]) - 1 if k - 1 else n)
```

### Analysis of the Program:
- The program checks if `k` is greater than 1. If it is, it calculates `2 ** len(bin(n)[2:]) - 1`.
- This expression computes the largest number that can be represented with the same number of bits as `n`. This is essentially the maximum xor-sum achievable by using all bits set (which is `2^m - 1`, where `m` is the number of bits).
- If `k` is equal to 1, it simply returns `n`, which is not correct as it does not represent the largest xor-sum (which would be `1` if `n` is `1`).

### Identifying Edge Cases:
1. **Case when `k = 1`:**
   - For `n = 1`, the output should be `1`, which is correct.
   - For `n = 2`, the output should be `1`, but the program would incorrectly output `2`.
   - For `n = 3`, the output should be `3`, but the program would incorrectly output `2`.
   
2. **Case when `k` is very large:**
   - For `k = n` (where `n = 6`), the output should be `7`, which is returned correctly in the provided example but could be mishandled with other values of `k`.
   
### Conclusion:
The program fails to correctly compute the maximum xor-sum when `k` equals `1` and `n` is greater than `1`. Since we found cases where the output does not meet the problem requirements, we can conclude:

Correctness: **False**. 

The program does not handle the case when `k = 1` correctly for `n > 1`, leading to incorrect outputs.