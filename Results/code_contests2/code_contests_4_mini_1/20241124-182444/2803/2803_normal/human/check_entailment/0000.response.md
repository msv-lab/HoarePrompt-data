To determine the correctness of the provided program based on the problem description, let's analyze the code and the output hints closely.

### Problem Analysis
The goal is to find the largest possible xor-sum of candies with unique tastiness values from 1 to n, where Grisha can select at most k candies.

### Program Code
```python
(n, k) = map(int, raw_input().split())
print(2 ** len(bin(n)[2:]) - 1 if k - 1 else n)
```

### Output Hints
The output hints state:
- The function accepts two positive integers `n` and `k`.
- It returns `n` if `k` is equal to 1.
- If `k` is greater than 1, it returns `2` raised to the power of the number of bits in the binary representation of `n` (excluding the '0b' prefix) minus 1.

### Analysis of the Code
1. **For `k == 1`:** The output is simply `n`. This matches the problem description since selecting only one candy means taking the candy with the highest tastiness, which is `n`.
   
2. **For `k > 1`:** The output is `2 ** len(bin(n)[2:]) - 1`, which computes the maximum value that can be achieved with all bits set to 1 for the number of bits in `n`. This is a standard approach for determining the maximum xor-sum one can achieve with up to `k` numbers. 

### Edge Cases
- **Case when `k = n`:** The function correctly returns `7` for both examples given in the problem description. The maximum xor-sum achievable from numbers 1 to `n` is indeed `2^(number of bits) - 1`, which is `7` for `n = 6` (binary `110`).
  
- **Case when `k > n`:** The problem states that `k` can never exceed `n`, so this case is not applicable.
  
- **Single Candy Case (`n = 1` and `k = 1`):** The output would be `1`, which is correct.

### Conclusion
The output hints correctly align with the program's logic, and there are no cases identified where the program fails to follow the problem description. The logic correctly handles the input according to the specifications provided.

Correctness: **True**.