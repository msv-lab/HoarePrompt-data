To determine the correctness of the provided program against the problem description, we need to analyze how the program calculates the largest xor-sum based on the inputs `n` and `k`.

### Problem Breakdown:
1. **Inputs**: Two integers, `n` (total candies with tastiness from 1 to n) and `k` (maximum candies Grisha can take).
2. **Output**: The largest possible xor-sum from the selected candies.

### Program Analysis:
The program provided is:
```python
(n, k) = map(int, raw_input().split())
print(2 ** len(bin(n)[2:]) - 1 if k - 1 else n)
```

- The expression `len(bin(n)[2:])` calculates the number of bits required to represent `n` in binary.
- The expression `2 ** len(bin(n)[2:]) - 1` calculates `2^m - 1`, where `m` is the number of bits in `n`. This value represents the maximum xor-sum obtainable from selecting the numbers from 1 to n if `k > 1`.
- If `k - 1` is `0` (i.e., `k` is `1`), the program simply returns `n`, which is the maximum tastiness if only one candy can be selected.

### Potential Issues:
1. **When k is greater than or equal to n**: The program seems to consider the case where Grisha can take all candies, but the logic for when `k` equals `n` should still ensure that the xor-sum is calculated correctly for all candies, not just return the maximum possible value based on the bit length.
2. **Edge Case**: If `k` is `1`, the program returns `n`, which is correct. However, for any `k` greater than `1` but less than `n`, it assumes the maximum xor-sum can always be calculated simply from the bit length and does not consider the specific values of the candies.

### Verification:
Let's consider a case:
- `n = 5`, `k = 2`. The candies are {1, 2, 3, 4, 5}. 
- Possible pairs for maximum xor-sum: (4, 5) gives `4 ^ 5 = 1`, (3, 5) gives `3 ^ 5 = 6`, (2, 5) gives `2 ^ 5 = 7`, etc.
- The maximum xor-sum should be `7`, which the program would not calculate correctly as it simply uses the bit length approach.

### Conclusion:
The provided program does not correctly account for specific selections of candies when `k` is less than `n`. Thus, it may fail to compute the correct maximum xor-sum in cases like `n = 5`, `k = 2`.

Correctness: **False**.