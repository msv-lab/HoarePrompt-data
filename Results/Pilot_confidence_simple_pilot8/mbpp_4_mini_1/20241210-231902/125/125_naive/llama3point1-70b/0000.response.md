To determine the correctness of the provided program based on the problem description, let's analyze the function and its behavior with different inputs.

**Problem description**: Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.

**Program**:
```python
def func_1(lst, n):
    return [lst[i::n] for i in range(n)]
```

### Analysis:
1. **Functionality**: The program uses list comprehension to create a new list containing sublists. Each sublist is formed by taking every nth element starting from index `i`, where `i` ranges from `0` to `n-1`.

2. **Potential Issues**:
   - If `n` is greater than the length of `lst`, the function will still return a list of empty sublists. For example, if `lst = [1, 2, 3]` and `n = 5`, the output would be `[[], [], [], [], []]`, which may not be the intended behavior based on the description.
   - If `n` is `0`, the code will raise a `ZeroDivisionError` when trying to use the slicing operation `lst[i::n]`.
   - If `n` is negative, the behavior of the slicing operation may not align with expectations, potentially leading to unexpected results or empty lists.

### Example Cases:
- **Case 1**: `func_1([1, 2, 3], 5)` → Expected: `[]` (or some indication of no valid splits), but actual output: `[[], [], [], [], []]`.
- **Case 2**: `func_1([1, 2, 3], 0)` → Raises an error.
- **Case 3**: `func_1([1, 2, 3], -1)` → This would produce unexpected results.

### Conclusion:
Given the potential issues identified, particularly with edge cases such as `n` being greater than the length of the list, `n` being `0`, or `n` being negative, the program does not meet the requirements of the problem description for all cases.

Correctness: **False**.