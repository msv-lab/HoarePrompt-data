Correctness: **True**.

This program works correctly for every potential case because it uses list slicing to split the input list into sublists at every nth element. The list comprehension `[lst[i::n] for i in range(n)]` generates n sublists, each starting at a different index and stepping by n.

Here's a breakdown of how it works:

- `lst[i::n]` creates a slice of the list starting at index `i` and taking every `n`-th element.
- `for i in range(n)` generates these slices for each starting index from 0 to `n-1`.
- This effectively splits the list into `n` sublists, each containing every `n`-th element starting from a different index.

For example, given the list `[1, 2, 3, 4, 5, 6, 7, 8, 9]` and `n = 3`, the function would return `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]`, which is the expected output.

The function handles edge cases correctly as well, such as when the input list is empty or when `n` is greater than the length of the list. In these cases, it returns an empty list or a list of empty sublists, respectively, which is the expected behavior. 

Therefore, I couldn't find any case where the program does not work as expected according to the problem description, so I conclude that the program is correct.