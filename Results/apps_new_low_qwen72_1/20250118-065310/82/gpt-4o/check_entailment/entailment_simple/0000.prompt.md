
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.

Neko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.

Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?


-----Input-----

The only line contains two integers $a$ and $b$ ($1 \le a, b \le 10^9$).


-----Output-----

Print the smallest non-negative integer $k$ ($k \ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.

If there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.


-----Examples-----
Input
6 10

Output
2
Input
21 31

Output
9
Input
5 10

Output
0


-----Note-----

In the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.

# Annotated Program:
import math

if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    a = int(data[0])
    b = int(data[1])
    print(func_3(a, b))

#Function 1:
#State of the program right berfore the function call: x and y are non-negative integers where at least one of them is not zero.
def func_1(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the GCD of the original `x` and `y`, and `y` is 0.
    return x
    #The program returns the GCD of the original `x` and `y`

#Function 2:
#State of the program right berfore the function call: x and y are positive integers such that 1 <= x, y <= 10^9.
def func_2(x, y):
    return x * y // func_1(x, y)
    #The program returns the integer division of the product of x and y by the result of func_1(x, y), where x and y are positive integers such that 1 <= x, y <= 10^9.

#Function 3:
#State of the program right berfore the function call: a and b are positive integers such that 1 <= a, b <= 10^9.
def func_3(a, b):
    if (a == b) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *a and b are positive integers such that 1 <= a, b <= 10^9, and a is not equal to b
    diff = abs(a - b)

min_lcm = float('inf')

min_k = 0
    for k in range(1, int(math.sqrt(diff)) + 1):
        if diff % k == 0:
            for candidate in [k, diff // k]:
                new_a = (a + candidate - 1) // candidate * candidate
                new_b = (b + candidate - 1) // candidate * candidate
                current_lcm = func_2(new_a, new_b)
                if (current_lcm < min_lcm or current_lcm == min_lcm and candidate <
                    min_k):
                    min_lcm = current_lcm
                    min_k = candidate
        
    #State of the program after the  for loop has been executed: After the loop finishes, `a` and `b` are positive integers such that \(1 \leq a, b \leq 10^9\) and \(a \neq b\). `diff` is a positive integer greater than 0. `min_lcm` is the minimum least common multiple (LCM) of any pair of numbers `new_a` and `new_b`, where `new_a` and `new_b` are the smallest multiples of a factor `k` (or `diff // k`) that are greater than or equal to `a` and `b` respectively. `min_k` is the factor `k` (or `diff // k`) that resulted in this minimum LCM. `new_a` and `new_b` are the last computed smallest multiples of their respective candidates greater than or equal to `a` and `b`. `current_lcm` is the last computed LCM of `new_a` and `new_b`. The loop iterates over all factors `k` of `diff` up to the square root of `diff`. If no valid factors are found, `min_lcm` remains infinity and `min_k` remains 0.
    return min_k
    #The program returns the factor `min_k` (or `diff // k`) that resulted in the minimum least common multiple (`min_lcm`) of any pair of numbers `new_a` and `new_b`, where `new_a` and `new_b` are the smallest multiples of `k` (or `diff // k`) that are greater than or equal to `a` and `b` respectively. If no valid factors are found, `min_k` remains 0.



# Your response:
Reasoning:  
Correctness: **True** or **False**

