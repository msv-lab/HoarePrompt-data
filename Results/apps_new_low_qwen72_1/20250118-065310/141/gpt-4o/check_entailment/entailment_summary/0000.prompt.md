
Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
The mayor of the Central Town wants to modernize Central Street, represented in this problem by the $(Ox)$ axis.

On this street, there are $n$ antennas, numbered from $1$ to $n$. The $i$-th antenna lies on the position $x_i$ and has an initial scope of $s_i$: it covers all integer positions inside the interval $[x_i - s_i; x_i + s_i]$.

It is possible to increment the scope of any antenna by $1$, this operation costs $1$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).

To modernize the street, we need to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $[1; m]$, even if it's not required.

What is the minimum amount of coins needed to achieve this modernization?


-----Input-----

The first line contains two integers $n$ and $m$ ($1 \le n \le 80$ and $n \le m \le 100\ 000$).

The $i$-th of the next $n$ lines contains two integers $x_i$ and $s_i$ ($1 \le x_i \le m$ and $0 \le s_i \le m$).

On each position, there is at most one antenna (values $x_i$ are pairwise distinct).


-----Output-----

You have to output a single integer: the minimum amount of coins required to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna.


-----Examples-----
Input
3 595
43 2
300 4
554 10

Output
281

Input
1 1
1 1

Output
0

Input
2 50
20 0
3 1

Output
30

Input
5 240
13 0
50 25
60 5
155 70
165 70

Output
26



-----Note-----

In the first example, here is a possible strategy:

  Increase the scope of the first antenna by $40$, so that it becomes $2 + 40 = 42$. This antenna will cover interval $[43 - 42; 43 + 42]$ which is $[1; 85]$  Increase the scope of the second antenna by $210$, so that it becomes $4 + 210 = 214$. This antenna will cover interval $[300 - 214; 300 + 214]$, which is $[86; 514]$  Increase the scope of the third antenna by $31$, so that it becomes $10 + 31 = 41$. This antenna will cover interval $[554 - 41; 554 + 41]$, which is $[513; 595]$ 

Total cost is $40 + 210 + 31 = 281$. We can prove that it's the minimum cost required to make all positions from $1$ to $595$ covered by at least one antenna.

Note that positions $513$ and $514$ are in this solution covered by two different antennas, but it's not important.

—

In the second example, the first antenna already covers an interval $[0; 2]$ so we have nothing to do.

Note that the only position that we needed to cover was position $1$; positions $0$ and $2$ are covered, but it's not important.

# Program:
import sys

input = sys.stdin.read
data = input().split()
n = int(data[0])
m = int(data[1])
antennas = []
for i in range(n):
    x = int(data[2 + 2 * i])
    s = int(data[2 + 2 * i + 1])
    antennas.append((x, s))
print(func_1(n, m, antennas))

def func_1(n, m, antennas):
    dp = [float('inf')] * (m + 1)
    dp[0] = 0
    antennas.sort()
    for (x, s) in antennas:
        left = max(0, x - s)
        right = min(m, x + s)
        for j in range(left, right + 1):
            dp[j] = min(dp[j], dp[max(0, left - 1)])
        for j in range(right + 1, m + 1):
            dp[j] = min(dp[j], dp[max(0, j - 2 * x)] + (j - right))
    return dp[m] if dp[m] != float('inf') else -1





# Execution Summary:
The function `func_1` takes three parameters: `n`, `m`, and `antennas`. It aims to determine the minimum cost to cover the range from 0 to `m` using the signal ranges of the given antennas. Each antenna is represented by a tuple `(x_i, s_i)`, where `x_i` is the position and `s_i` is the signal strength. The function initializes a dynamic programming (DP) array `dp` with `m + 1` elements, all set to infinity, except for `dp[0]` which is set to 0. It then sorts the `antennas` list based on their positions. For each antenna `(x, s)` in the sorted list, the function updates the `dp` array to reflect the minimum cost to cover the range `[left, right]` where `left = max(0, x - s)` and `right = min(m, x + s)`. Additionally, it updates the `dp` array for positions beyond `right` to account for the cost of extending coverage. Finally, the function returns `dp[m]` if it is not infinity, indicating the minimum cost to cover the entire range up to `m`; otherwise, it returns -1, indicating that it is impossible to cover the range with the given antennas. Edge cases include scenarios where no antenna can cover the entire range, or where the range `m` is less than the position of any antenna, leading to the function returning -1.


# Your response:
Reasoning:  
Correctness: **True** or **False**

