
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Two bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a "war"-like card game. 

The rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. 

You have to calculate how many fights will happen and who will win the game, or state that game won't end.


-----Input-----

First line contains a single integer n (2 ≤ n ≤ 10), the number of cards.

Second line contains integer k_1 (1 ≤ k_1 ≤ n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.

Third line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.

All card values are different.


-----Output-----

If somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.

If the game won't end and will continue forever output  - 1.


-----Examples-----
Input
4
2 1 3
2 4 2

Output
6 2
Input
3
1 2
2 1 3

Output
-1


-----Note-----

First sample:  [Image] 

Second sample:  [Image]

# Annotated Program:
n = int(input())
k1 = int(input())
deck1 = list(map(int, input().split()))
k2 = int(input())
deck2 = list(map(int, input().split()))
print(*func_1(deck1, deck2))

#State of the program right berfore the function call: deck1 and deck2 are lists of integers, representing the stacks of cards for the two players. The integers in deck1 and deck2 are unique and range from 1 to the sum of the lengths of deck1 and deck2, inclusive. The lengths of deck1 and deck2 are at least 1 and their sum is between 2 and 10, inclusive.
def func_1(deck1, deck2):
    seen = set()
    while deck1 and deck2:
        state = tuple(deck1), tuple(deck2)
        
        if state in seen:
            return -1
        
        seen.add(state)
        
        card1 = deck1.pop(0)
        
        card2 = deck2.pop(0)
        
        if card1 > card2:
            deck1.extend([card1, card2])
        else:
            deck2.extend([card2, card1])
        
    #State of the program after the loop has been executed: After the loop finishes, one of the decks (`deck1` or `deck2`) will be empty, and the other deck will contain all the cards in some order. The `seen` set will contain all the unique states of `(tuple(deck1), tuple(deck2))` encountered during the loop's execution. The `state` variable will be the final state `(tuple(deck1), tuple(deck2))`. If the loop returns `-1`, it indicates a cycle was detected before one of the decks became empty.
    return (len(seen), 1) if deck1 else (len(seen), 2)
    #The program returns a tuple `(len(seen), 1)` if `deck1` is not empty, otherwise it returns `(len(seen), 2)`. Here, `len(seen)` represents the number of unique states of `(tuple(deck1), tuple(deck2))` encountered during the loop's execution, and the second element of the tuple is 1 if `deck1` is not empty, indicating `deck2` is empty, or 2 if `deck1` is empty, indicating `deck2` is not empty.


# Your response:
Reasoning:  
Correctness: **True** or **False**

