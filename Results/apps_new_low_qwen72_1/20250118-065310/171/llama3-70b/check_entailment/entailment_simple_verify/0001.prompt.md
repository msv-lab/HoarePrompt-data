
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Two bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a "war"-like card game. 

The rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. 

You have to calculate how many fights will happen and who will win the game, or state that game won't end.


-----Input-----

First line contains a single integer n (2 ≤ n ≤ 10), the number of cards.

Second line contains integer k_1 (1 ≤ k_1 ≤ n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.

Third line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.

All card values are different.


-----Output-----

If somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.

If the game won't end and will continue forever output  - 1.


-----Examples-----
Input
4
2 1 3
2 4 2

Output
6 2
Input
3
1 2
2 1 3

Output
-1


-----Note-----

First sample:  [Image] 

Second sample:  [Image]

- Program: 
n = int(input())
k1 = int(input())
deck1 = list(map(int, input().split()))
k2 = int(input())
deck2 = list(map(int, input().split()))
print(*func_1(deck1, deck2))

def func_1(deck1, deck2):
    seen = set()
    while deck1 and deck2:
        state = (tuple(deck1), tuple(deck2))
        if state in seen:
            return -1
        seen.add(state)
        card1 = deck1.pop(0)
        card2 = deck2.pop(0)
        if card1 > card2:
            deck1.extend([card1, card2])
        else:
            deck2.extend([card2, card1])
    return (len(seen), 1) if deck1 else (len(seen), 2)



- Annotated Code: 
n = int(input())
k1 = int(input())
deck1 = list(map(int, input().split()))
k2 = int(input())
deck2 = list(map(int, input().split()))
print(*func_1(deck1, deck2))

#State of the program right berfore the function call: deck1 and deck2 are lists of integers, representing the stacks of cards for the two players. The integers in deck1 and deck2 are unique and range from 1 to the sum of the lengths of deck1 and deck2, inclusive. The lengths of deck1 and deck2 are at least 1 and their sum is between 2 and 10, inclusive.
def func_1(deck1, deck2):
    seen = set()
    while deck1 and deck2:
        state = tuple(deck1), tuple(deck2)
        
        if state in seen:
            return -1
        
        seen.add(state)
        
        card1 = deck1.pop(0)
        
        card2 = deck2.pop(0)
        
        if card1 > card2:
            deck1.extend([card1, card2])
        else:
            deck2.extend([card2, card1])
        
    #State of the program after the loop has been executed: After the loop finishes, one of the decks (`deck1` or `deck2`) will be empty, and the other deck will contain all the cards in some order. The `seen` set will contain all the unique states of `(tuple(deck1), tuple(deck2))` encountered during the loop's execution. The `state` variable will be the final state `(tuple(deck1), tuple(deck2))`. If the loop returns `-1`, it indicates a cycle was detected before one of the decks became empty.
    return (len(seen), 1) if deck1 else (len(seen), 2)
    #The program returns a tuple `(len(seen), 1)` if `deck1` is not empty, otherwise it returns `(len(seen), 2)`. Here, `len(seen)` represents the number of unique states of `(tuple(deck1), tuple(deck2))` encountered during the loop's execution, and the second element of the tuple is 1 if `deck1` is not empty, indicating `deck2` is empty, or 2 if `deck1` is empty, indicating `deck2` is not empty.



Beggining of Original Assessment: 
Reasoning:

1. **Input Handling**: The program correctly reads the inputs as specified in the problem statement. It first reads `n`, then the number of cards and the cards themselves for the first player, and similarly for the second player.

2. **Game Simulation**: The program simulates the game using a while loop that continues as long as both players have cards. This is appropriate because the game ends when one player runs out of cards.

3. **State Tracking**: The program uses a set `seen` to keep track of the states (tuples of the current decks) to detect cycles. If a state repeats, it means the game will continue indefinitely, and the program returns `-1`.

4. **Card Comparison and Stack Management**: During each turn, the program compares the top cards of both players. The winner of the turn appends the opponent's card followed by their own card to the bottom of their deck. This follows the rules of the game correctly.

5. **Result Calculation**: After the loop, the program checks which player has cards left and returns the number of fights (which is the size of the `seen` set) along with the winning player's number.

6. **Edge Cases**: The program handles edge cases such as one player having no cards initially, which would result in an immediate win for the other player.

Given these points, the program appears to correctly implement the game logic and handle all specified cases.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

