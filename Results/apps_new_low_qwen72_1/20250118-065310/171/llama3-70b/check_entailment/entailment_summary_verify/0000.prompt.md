
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Two bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a "war"-like card game. 

The rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. 

You have to calculate how many fights will happen and who will win the game, or state that game won't end.


-----Input-----

First line contains a single integer n (2 ≤ n ≤ 10), the number of cards.

Second line contains integer k_1 (1 ≤ k_1 ≤ n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.

Third line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.

All card values are different.


-----Output-----

If somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.

If the game won't end and will continue forever output  - 1.


-----Examples-----
Input
4
2 1 3
2 4 2

Output
6 2
Input
3
1 2
2 1 3

Output
-1


-----Note-----

First sample:  [Image] 

Second sample:  [Image]

- Program:
n = int(input())
k1 = int(input())
deck1 = list(map(int, input().split()))
k2 = int(input())
deck2 = list(map(int, input().split()))
print(*func_1(deck1, deck2))

def func_1(deck1, deck2):
    seen = set()
    while deck1 and deck2:
        state = (tuple(deck1), tuple(deck2))
        if state in seen:
            return -1
        seen.add(state)
        card1 = deck1.pop(0)
        card2 = deck2.pop(0)
        if card1 > card2:
            deck1.extend([card1, card2])
        else:
            deck2.extend([card2, card1])
    return (len(seen), 1) if deck1 else (len(seen), 2)



- Function Summary: 
The function `func_1` simulates a game between two players using decks of cards represented by `deck1` and `deck2`. The function ensures that the game does not enter an infinite loop by tracking previously seen states. If a cycle is detected, the function returns `-1`. Otherwise, the function continues until one of the decks is empty. At the end of the game, the function returns a tuple `(len(seen), winner)`, where `len(seen)` is the number of unique states encountered during the game, and `winner` is 1 if `deck1` is not empty (indicating `deck2` is empty) or 2 if `deck1` is empty (indicating `deck2` is not empty). The function handles edge cases such as initial decks being empty or containing only one card, ensuring the game progresses correctly until a winner is determined or a cycle is detected.

Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The program does not handle the case where the game continues indefinitely correctly. Specifically, the return value for an infinite loop should be `-1`, but the current implementation returns `(len(seen), 1)` or `(len(seen), 2)` which is incorrect according to the problem description. This means that if the game enters a loop, the function should return `-1` to indicate that the game will not end, but instead it returns the number of unique states seen and the player who would have won if the game had ended, which is not what the problem description specifies.

For example, consider the following input:
```
3
1 2
2 1 3
```
The game will enter a loop, and the correct output should be `-1`. However, the current implementation will return a different result, indicating that the program is incorrect.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

