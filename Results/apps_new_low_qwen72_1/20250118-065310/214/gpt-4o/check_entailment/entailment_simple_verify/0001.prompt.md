
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
In a building where Polycarp lives there are equal number of flats on each floor. Unfortunately, Polycarp don't remember how many flats are on each floor, but he remembers that the flats are numbered from 1 from lower to upper floors. That is, the first several flats are on the first floor, the next several flats are on the second and so on. Polycarp don't remember the total number of flats in the building, so you can consider the building to be infinitely high (i.e. there are infinitely many floors). Note that the floors are numbered from 1.

Polycarp remembers on which floors several flats are located. It is guaranteed that this information is not self-contradictory. It means that there exists a building with equal number of flats on each floor so that the flats from Polycarp's memory have the floors Polycarp remembers.

Given this information, is it possible to restore the exact floor for flat n? 


-----Input-----

The first line contains two integers n and m (1 ≤ n ≤ 100, 0 ≤ m ≤ 100), where n is the number of the flat you need to restore floor for, and m is the number of flats in Polycarp's memory.

m lines follow, describing the Polycarp's memory: each of these lines contains a pair of integers k_{i}, f_{i} (1 ≤ k_{i} ≤ 100, 1 ≤ f_{i} ≤ 100), which means that the flat k_{i} is on the f_{i}-th floor. All values k_{i} are distinct.

It is guaranteed that the given information is not self-contradictory.


-----Output-----

Print the number of the floor in which the n-th flat is located, if it is possible to determine it in a unique way. Print -1 if it is not possible to uniquely restore this floor.


-----Examples-----
Input
10 3
6 2
2 1
7 3

Output
4

Input
8 4
3 1
6 2
5 2
2 1

Output
-1



-----Note-----

In the first example the 6-th flat is on the 2-nd floor, while the 7-th flat is on the 3-rd, so, the 6-th flat is the last on its floor and there are 3 flats on each floor. Thus, the 10-th flat is on the 4-th floor.

In the second example there can be 3 or 4 flats on each floor, so we can't restore the floor for the 8-th flat.

- Program: 
(n, m) = map(int, input().split())
flats_memory = [tuple(map(int, input().split())) for _ in range(m)]
print(func_1(n, m, flats_memory))

def func_1(n, m, flats_memory):
    possible_floors = set()
    for (k, f) in flats_memory:
        possible_floors.add((k - 1) // f)
    if len(possible_floors) == 1:
        flats_per_floor = list(possible_floors)[0] + 1
        return (n - 1) // flats_per_floor + 1
    else:
        return -1



- Annotated Code: 
(n, m) = map(int, input().split())
flats_memory = [tuple(map(int, input().split())) for _ in range(m)]
print(func_1(n, m, flats_memory))

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100, m is an integer such that 0 ≤ m ≤ 100, and flats_memory is a list of tuples (k_i, f_i) where 1 ≤ k_i ≤ 100 and 1 ≤ f_i ≤ 100, and all k_i are distinct.
def func_1(n, m, flats_memory):
    possible_floors = set()
    for (k, f) in flats_memory:
        possible_floors.add((k - 1) // f)
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 ≤ n ≤ 100, `m` is an integer such that 0 ≤ m ≤ 100, `flats_memory` is a list of tuples `(k_i, f_i)` where 1 ≤ k_i ≤ 100 and 1 ≤ f_i ≤ 100, and all `k_i` are distinct, `possible_floors` is a set containing `{(k_1 - 1) // f_1, (k_2 - 1) // f_2, ..., (k_n - 1) // f_n}` if `flats_memory` has `n` tuples, otherwise it contains the results of the floor division for each tuple in `flats_memory`.
    if (len(possible_floors) == 1) :
        flats_per_floor = list(possible_floors)[0] + 1
        return (n - 1) // flats_per_floor + 1
        #The program returns the result of `(n - 1) // (list(possible_floors)[0] + 1) + 1`, where `n` is an integer such that 1 ≤ n ≤ 100, and `list(possible_floors)[0]` is the single element in the set `possible_floors`, which is the result of the floor division `(k_i - 1) // f_i` for all tuples `(k_i, f_i)` in the list `flats_memory`.
    else :
        return -1
        #The program returns -1



Beggining of Original Assessment: 
Reasoning:  
The provided program attempts to solve the problem by calculating the potential number of flats per floor based on the provided memory of flats and their respective floors. The logic is to iterate through each remembered flat and calculate the possible number of flats per floor using the formula `(k - 1) // f`, which gives the index of the last flat on a given floor. If all calculated values are the same, it implies a consistent number of flats per floor. This value is then used to determine the floor for the nth flat. If the values differ, it indicates ambiguity and the function returns `-1`.

However, there is a subtle issue in the logic of calculating the number of flats per floor. The formula `(k - 1) // f` should actually be `(f - 1) * x + 1 <= k <= f * x`, where `x` is the number of flats per floor. The current implementation incorrectly calculates the number of flats per floor, leading to potential errors in determining the correct floor for the nth flat.

To fix this, the program should correctly calculate the number of flats per floor and ensure that all remembered flats are consistent with this calculation.

Correctness: **False**

Here is a corrected version of the program:

```python
(n, m) = map(int, input().split())
flats_memory = [tuple(map(int, input().split())) for _ in range(m)]

def func_1(n, m, flats_memory):
    possible_floors = set()
    for (k, f) in flats_memory:
        # Calculate the number of flats per floor
        for flats_per_floor in range(1, 101):
            if (f - 1) * flats_per_floor + 1 <= k <= f * flats_per_floor:
                possible_floors.add(flats_per_floor)
                break
    if len(possible_floors) == 1:
        flats_per_floor = list(possible_floors)[0]
        return (n - 1) // flats_per_floor + 1
    else:
        return -1

print(func_1(n, m, flats_memory))
```

This corrected version ensures that the number of flats per floor is correctly determined and checked for consistency across all remembered flats.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

