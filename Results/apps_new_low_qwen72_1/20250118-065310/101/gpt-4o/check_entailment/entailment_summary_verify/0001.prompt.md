
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Innocentius has a problem — his computer monitor has broken. Now some of the pixels are "dead", that is, they are always black. As consequence, Innocentius can't play the usual computer games. He is recently playing the following game with his younger brother Polycarpus.

Innocentius is touch-typing a program that paints a white square one-pixel wide frame on the black screen. As the monitor is broken, some pixels that should be white remain black. Polycarpus should look at what the program displayed on the screen and guess the position and size of the frame Innocentius has painted. Polycarpus doesn't like the game but Innocentius persuaded brother to play as "the game is good for the imagination and attention".

Help Polycarpus, automatize his part in the gaming process. Write the code that finds such possible square frame that:  the frame's width is 1 pixel,  the frame doesn't go beyond the borders of the screen,  all white pixels of the monitor are located on the frame,  of all frames that satisfy the previous three conditions, the required frame must have the smallest size. 

Formally, a square frame is represented by such pixels of the solid square, that are on the square's border, that is, are not fully surrounded by the other pixels of the square. For example, if the frame's size is d = 3, then it consists of 8 pixels, if its size is d = 2, then it contains 4 pixels and if d = 1, then the frame is reduced to a single pixel.


-----Input-----

The first line contains the resolution of the monitor as a pair of integers n, m (1 ≤ n, m ≤ 2000). The next n lines contain exactly m characters each — the state of the monitor pixels at the moment of the game. Character "." (period, ASCII code 46) corresponds to the black pixel, and character "w" (lowercase English letter w) corresponds to the white pixel. It is guaranteed that at least one pixel of the monitor is white.


-----Output-----

Print the monitor screen. Represent the sought frame by characters "+" (the "plus" character). The pixels that has become white during the game mustn't be changed. Print them as "w". If there are multiple possible ways to position the frame of the minimum size, print any of them.

If the required frame doesn't exist, then print a single line containing number -1.


-----Examples-----
Input
4 8
..w..w..
........
........
..w..w..

Output
..w++w..
..+..+..
..+..+..
..w++w..

Input
5 6
......
.w....
......
..w...
......

Output
......
+w+...
+.+...
++w...
......

Input
2 4
....
.w..

Output
....
.w..

Input
2 6
w..w.w
...w..

Output
-1



-----Note-----

In the first sample the required size of the optimal frame equals 4. In the second sample the size of the optimal frame equals 3. In the third sample, the size of the optimal frame is 1. In the fourth sample, the required frame doesn't exist.

- Program:
(n, m) = map(int, input().split())
screen = [input().strip() for _ in range(n)]
result = func_1(n, m, screen)
if result == -1:
    print(-1)
else:
    for row in result:
        print(''.join(row))

def func_1(n, m, screen):
    top = bottom = left = right = None
    for i in range(n):
        for j in range(m):
            if screen[i][j] == 'w':
                if top is None:
                    top = bottom = i
                    left = right = j
                else:
                    if i < top:
                        top = i
                    if i > bottom:
                        bottom = i
                    if j < left:
                        left = j
                    if j > right:
                        right = j
    if top is None or bottom is None or left is None or (right is None):
        return -1
    frame_height = bottom - top + 1
    frame_width = right - left + 1
    if frame_height < 2 or frame_width < 2:
        return -1
    result = [list(row) for row in screen]
    for i in range(top, bottom + 1):
        for j in range(left, right + 1):
            if i == top or i == bottom or j == left or (j == right):
                if result[i][j] == '.':
                    result[i][j] = '+'
    return result



- Function Summary: 
The function `func_1` takes three parameters: `n`, `m`, and `screen`. `n` and `m` are integers such that \(1 \leq n, m \leq 2000\), and `screen` is a list of `n` strings, each string consisting of exactly `m` characters where each character is either `'.'` or `'w'`, with at least one `'w'` character in the `screen`.

The function determines the bounding box of all `'w'` characters in the `screen` and then modifies the `screen` to create a frame around this bounding box by changing certain `'.'` characters to `'+'`.

1.

Beggining of Original Assessment: 
Reasoning:  

The program provided is designed to solve the problem of identifying the smallest possible square frame that can cover all the white pixels ('w') on a potentially broken monitor display. The program reads the dimensions of the screen and the state of each pixel, then processes this information to find the boundaries of the smallest square frame that encompasses all white pixels. Here’s a step-by-step breakdown of the logic and checks for correctness:

1. **Input Reading**: The program correctly reads the dimensions of the screen (`n`, `m`) and the state of each pixel, storing the screen as a list of strings where each string represents a row of the screen.

2. **Finding Boundaries**: The program iterates through each pixel to find the minimum and maximum row (`top`, `bottom`) and column (`left`, `right`) indices where white pixels are found. This step is crucial for determining the boundaries of the smallest possible square frame that can cover all white pixels.

3. **Frame Size Calculation**: After finding the boundaries, the program calculates the height and width of the potential frame. It checks if either dimension is less than 2, which would mean that no valid frame can be drawn (since a frame needs at least 2x2 pixels to form a border).

4. **Frame Drawing**: If a valid frame can be drawn, the program updates the screen to replace the black pixels (".") along the calculated frame boundaries with "+" symbols, while leaving the original white pixels ('w') unchanged.

5. **Output**: The program outputs the modified screen if a valid frame is found, or `-1` if no such frame can be drawn.

**Checks for Correctness**:
- The program correctly handles the input and output formats as specified.
- It accurately identifies the boundaries of the smallest possible square frame that covers all white pixels.
- It correctly handles edge cases where no valid frame can be drawn (e.g., when the frame size is less than 2).
- The program ensures that the original white pixels remain unchanged and only black pixels within the frame boundaries are replaced with "+".

Given these points, the program appears to meet the requirements of the problem statement and should work correctly for the provided test cases and similar scenarios.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

