
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Есть n-подъездный дом, в каждом подъезде по m этажей, и на каждом этаже каждого подъезда ровно k квартир. Таким образом, в доме всего n·m·k квартир. Они пронумерованы естественным образом от 1 до n·m·k, то есть первая квартира на первом этаже в первом подъезде имеет номер 1, первая квартира на втором этаже первого подъезда имеет номер k + 1 и так далее. Особенность этого дома состоит в том, что он круглый. То есть если обходить его по часовой стрелке, то после подъезда номер 1 следует подъезд номер 2, затем подъезд номер 3 и так далее до подъезда номер n. После подъезда номер n снова идёт подъезд номер 1.

Эдвард живёт в квартире номер a, а Наташа — в квартире номер b. Переход на 1 этаж вверх или вниз по лестнице занимает 5 секунд, переход от двери подъезда к двери соседнего подъезда — 15 секунд, а переход в пределах одного этажа одного подъезда происходит мгновенно. Также в каждом подъезде дома есть лифт. Он устроен следующим образом: он всегда приезжает ровно через 10 секунд после вызова, а чтобы переместить пассажира на один этаж вверх или вниз, лифт тратит ровно 1 секунду. Посадка и высадка происходят мгновенно.

Помогите Эдварду найти минимальное время, за которое он сможет добраться до квартиры Наташи. Считайте, что Эдвард может выйти из подъезда только с первого этажа соответствующего подъезда (это происходит мгновенно). Если Эдвард стоит перед дверью какого-то подъезда, он может зайти в него и сразу окажется на первом этаже этого подъезда (это также происходит мгновенно). Эдвард может выбирать, в каком направлении идти вокруг дома.


-----Входные данные-----

В первой строке входных данных следуют три числа n, m, k (1 ≤ n, m, k ≤ 1000) — количество подъездов в доме, количество этажей в каждом подъезде и количество квартир на каждом этаже каждого подъезда соответственно.

Во второй строке входных данных записаны два числа a и b (1 ≤ a, b ≤ n·m·k) — номера квартир, в которых живут Эдвард и Наташа, соответственно. Гарантируется, что эти номера различны. 


-----Выходные данные-----

Выведите единственное целое число — минимальное время (в секундах), за которое Эдвард сможет добраться от своей квартиры до квартиры Наташи.


-----Примеры-----
Входные данные
4 10 5
200 6

Выходные данные
39

Входные данные
3 1 5
7 2

Выходные данные
15



-----Примечание-----

В первом тестовом примере Эдвард находится в 4 подъезде на 10 этаже, а Наташа находится в 1 подъезде на 2 этаже. Поэтому Эдварду выгодно сначала спуститься на лифте на первый этаж (на это он потратит 19 секунд, из которых 10 — на ожидание и 9 — на поездку на лифте), затем обойти дом против часовой стрелки до подъезда номер 1 (на это он потратит 15 секунд), и наконец подняться по лестнице на этаж номер 2 (на это он потратит 5 секунд). Таким образом, ответ равен 19 + 15 + 5 = 39.

Во втором тестовом примере Эдвард живёт в подъезде 2 на этаже 1, а Наташа находится в подъезде 1 на этаже 1. Поэтому Эдварду выгодно просто обойти дом по часовой стрелке до подъезда 1, на это он потратит 15 секунд.

# Annotated Program:
(n, m, k) = map(int, input().split())
(a, b) = map(int, input().split())
result = func_1(n, m, k, a, b)
print(result)

#Function 1:
#State of the program right berfore the function call: n, m, k are positive integers representing the number of entrances, floors per entrance, and apartments per floor respectively. a and b are positive integers such that 1 <= a, b <= n * m * k, representing the apartment numbers of Edward and Natasha respectively, and a != b.
def func_1(n, m, k, a, b):
    block_a, floor_a = get_location(a)

block_b, floor_b = get_location(b)
    if (floor_a == 1) :
        time_to_exit = 0
    else :
        time_to_exit = 10 + (floor_a - 1)
    #State of the program after the if-else block has been executed: *`n`, `m`, `k` are positive integers, `a` is a positive integer (1 <= `a` <= `n` * `m` * `k`), `b` is a positive integer (1 <= `b` <= `n` * `m` * `k` and `a` != `b`), `block_a` is the block number of apartment `a`, `floor_a` is the floor number of apartment `a`, `block_b` is the block number of apartment `b`, `floor_b` is the floor number of apartment `b`. If `floor_a` is 1, `time_to_exit` is 0. Otherwise, `time_to_exit` is 10 + (`floor_a` - 1).
    direct_walk_time = abs(block_a - block_b) % n * 15

reverse_walk_time = (n - abs(block_a - block_b)) % n * 15

min_walk_time = min(direct_walk_time, reverse_walk_time)

time_to_target_floor = (floor_b - 1) * 5

total_time = time_to_exit + min_walk_time + time_to_target_floor
    return total_time
    #The program returns the total time calculated as the sum of time_to_exit, min_walk_time, and time_to_target_floor. Time_to_exit is 0 if floor_a is 1, or 10 + (floor_a - 1) otherwise. Min_walk_time is the minimum of direct_walk_time and reverse_walk_time, where direct_walk_time is abs(block_a - block_b) % n * 15 and reverse_walk_time is (n - abs(block_a - block_b)) % n * 15. Time_to_target_floor is (floor_b - 1) * 5.

#Function 2:
#State of the program right berfore the function call: apartment is an integer representing the apartment number, such that 1 ≤ apartment ≤ n * m * k.
def get_location(apartment):
    block = (apartment - 1) // (m * k) + 1

floor_within_block = (apartment - 1) % (m * k)

floor = floor_within_block // k + 1
    return block, floor
    #The program returns the block number, which is calculated as (apartment - 1) // (m * k) + 1, and the floor number, which is calculated as (apartment - 1) % (m * k) // k + 1. Both `block` and `floor` are derived from the initial state where `apartment` is an integer representing the apartment number, `block` is (apartment - 1) // (m * k) + 1, `floor_within_block` is (apartment - 1) % (m * k), and `floor` is (apartment - 1) % (m * k) // k + 1.



# Your response:
Reasoning:  
Correctness: **True** or **False**

