
 Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Absent-minded Masha got set of n cubes for her birthday.

At each of 6 faces of each cube, there is exactly one digit from 0 to 9. Masha became interested what is the largest natural x such she can make using her new cubes all integers from 1 to x.

To make a number Masha can rotate her cubes and put them in a row. After that, she looks at upper faces of cubes from left to right and reads the number.

The number can't contain leading zeros. It's not required to use all cubes to build a number.

Pay attention: Masha can't make digit 6 from digit 9 and vice-versa using cube rotations.


-----Input-----

In first line integer n is given (1 ≤ n ≤ 3) — the number of cubes, Masha got for her birthday.

Each of next n lines contains 6 integers a_{i}_{j} (0 ≤ a_{i}_{j} ≤ 9) — number on j-th face of i-th cube.


-----Output-----

Print single integer — maximum number x such Masha can make any integers from 1 to x using her cubes or 0 if Masha can't make even 1.


-----Examples-----
Input
3
0 1 2 3 4 5
6 7 8 9 0 1
2 3 4 5 6 7

Output
87
Input
3
0 1 3 5 6 8
1 2 4 5 7 8
2 3 4 6 7 9

Output
98


-----Note-----

In the first test case, Masha can build all numbers from 1 to 87, but she can't make 88 because there are no two cubes with digit 8.

# Functions with Execution Summary:
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    cubes = []
    index = 1
    for i in range(n):
        cubes.append(data[index:index + 6])
        index += 6
    print(func_1(n, cubes))

Function number 1 :
 Code:
 '''
def func_1(n, cubes):
    from itertools import product
    cube_faces = [set(cube) for cube in cubes]

    x = 0
    while can_form_number(x + 1):
        x += 1
    return x
''' 

 Output hints for function1:  The function `func_1` accepts an integer `n` (1 ≤ n ≤ 3) and a list `cubes` of `n` lists, each containing 6 integers (0-9). It returns the largest integer `x` such that all numbers from 1 to `x` can be formed using the digits on the faces of the cubes, with the condition that at least one set in `cube_faces` must contain the digit 1. The function converts each list in `cubes` into a set to eliminate duplicate digits, and then iterates through numbers starting from 1, incrementing `x` until it finds a number that cannot be formed using the digits on the faces of the cubes. If the code is incomplete or missing the `can_form_number` function, the function may not work as intended.
Function number 2 :
 Code:
 '''
def can_form_number(num):
    digits = list(str(num))
    used_cubes = [False] * n
    for digit in digits:
        found = False
        for i in range(n):
            if not used_cubes[i] and digit in cube_faces[i]:
                used_cubes[i] = True
                found = True
                break
        if not found:
            return False
    return True
''' 

 Output hints for function2:  The function `can_form_number` takes three parameters: `num` (a positive integer), `n` (a positive integer representing the number of cubes, where 1 ≤ n ≤ 3), and `cube_faces` (a list of `n` lists, where each sublist contains 6 integers representing the digits on the faces of each cube, with each digit ranging from 0 to 9). The function returns `True` if it is possible to form the number `num` using the digits available on the faces of the cubes, such that each cube is used at most once. If it is not possible to form the number, the function returns `False`. 

After the function concludes, the state of the program is as follows:
- `num` remains unchanged.
- `n` remains unchanged.
- `cube_faces` remains unchanged.
- `digits` is a list of strings, where each string is a digit from `num`.
- `used_cubes` is a list of boolean values, where each element is `True` if the corresponding cube was used to match a digit from `num`, and `False` otherwise. 

Potential edge cases and missing functionality:
- If `num` contains more unique digits than the number of cubes (`n`), the function will return `False` because not all digits can be matched.
- If any digit in `num` is not present on any of the cube faces, the function will return `False`.
- If `n` is less than the number of unique digits in `num`, the function will return `False` even if the same digit appears multiple times in `num`.
- If `num` is 0, the function will return `False` unless a cube face contains the digit '0'.
- The function assumes that each cube can only be used once, regardless of whether a digit appears multiple times in `num`.


# Your response:
Reasoning:  
Correctness: **True** or **False**

