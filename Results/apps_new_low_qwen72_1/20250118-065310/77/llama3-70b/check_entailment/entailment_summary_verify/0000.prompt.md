
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Berland Football Cup starts really soon! Commentators from all over the world come to the event.

Organizers have already built $n$ commentary boxes. $m$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.

If $n$ is not divisible by $m$, it is impossible to distribute the boxes to the delegations at the moment.

Organizers can build a new commentary box paying $a$ burles and demolish a commentary box paying $b$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.

What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $m$)?


-----Input-----

The only line contains four integer numbers $n$, $m$, $a$ and $b$ ($1 \le n, m \le 10^{12}$, $1 \le a, b \le 100$), where $n$ is the initial number of the commentary boxes, $m$ is the number of delegations to come, $a$ is the fee to build a box and $b$ is the fee to demolish a box.


-----Output-----

Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $m$). It is allowed that the final number of the boxes is equal to $0$.


-----Examples-----
Input
9 7 3 8

Output
15

Input
2 7 3 7

Output
14

Input
30 6 17 19

Output
0



-----Note-----

In the first example organizers can build $5$ boxes to make the total of $14$ paying $3$ burles for the each of them.

In the second example organizers can demolish $2$ boxes to make the total of $0$ paying $7$ burles for the each of them.

In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $5$ boxes.

- Program:
def func():
    (n, m, a, b) = map(int, input().split())
    r = n % m
    if r == 0:
        print(0)
    elif m - r <= n:
        print(min((m - r) * a, r * b))
    else:
        print((m - r) * a)



- Function Summary: 
The function reads four integers `n`, `m`, `a`, and `b` from the input, where `1 ≤ n, m ≤ 10^12` and `1 ≤ a, b ≤ 100`. It calculates the remainder `r` of `n` divided by `m`. If `r` is 0, the function prints 0. Otherwise, it checks if `m - r` is less than or equal to `n`. If true, it prints the minimum value between `(m - r) * a` and `r * b`. If `m - r` is greater than `n`, it prints `(m - r) * a`. The function does not return any value; it only prints the result. Potential edge cases include when `n` is exactly divisible by `m` (i.e., `r = 0`), and when `m - r` is greater than `n`, which could occur if `n` is very small compared to `m`. The function does not handle invalid input or non-integer inputs, which could lead to runtime errors.

Beggining of Original Assessment: 
Correctness: **False**.

Explanation:
The program has a logical error in the condition `elif m - r <= n:`. This condition is unnecessary and can lead to incorrect results. The cost to build or demolish boxes should be calculated based solely on the remainder `r` and the costs `a` and `b`, without considering the current number of boxes `n`.

For example, consider the input:
```
1 7 3 7
```
Here, `n = 1`, `m = 7`, `a = 3`, and `b = 7`. The remainder `r = 1 % 7 = 1`. According to the problem, the minimum cost should be to demolish the 1 box, which would cost `1 * 7 = 7` burles. However, the program incorrectly outputs `6` because it considers the condition `m - r <= n`, which is true in this case, and calculates `(m - r) * a = (7 - 1) * 3 = 6`.

This condition is redundant and can lead to incorrect results. The correct approach is to always calculate the minimum cost between building and demolishing boxes based on the remainder `r` and the costs `a` and `b`.

A corrected version of the program would be:
```python
def func():
    (n, m, a, b) = map(int, input().split())
    r = n % m
    if r == 0:
        print(0)
    else:
        print(min((m - r) * a, r * b))
```

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

