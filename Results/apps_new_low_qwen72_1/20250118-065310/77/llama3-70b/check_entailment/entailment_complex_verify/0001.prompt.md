
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Berland Football Cup starts really soon! Commentators from all over the world come to the event.

Organizers have already built $n$ commentary boxes. $m$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.

If $n$ is not divisible by $m$, it is impossible to distribute the boxes to the delegations at the moment.

Organizers can build a new commentary box paying $a$ burles and demolish a commentary box paying $b$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.

What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $m$)?


-----Input-----

The only line contains four integer numbers $n$, $m$, $a$ and $b$ ($1 \le n, m \le 10^{12}$, $1 \le a, b \le 100$), where $n$ is the initial number of the commentary boxes, $m$ is the number of delegations to come, $a$ is the fee to build a box and $b$ is the fee to demolish a box.


-----Output-----

Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $m$). It is allowed that the final number of the boxes is equal to $0$.


-----Examples-----
Input
9 7 3 8

Output
15

Input
2 7 3 7

Output
14

Input
30 6 17 19

Output
0



-----Note-----

In the first example organizers can build $5$ boxes to make the total of $14$ paying $3$ burles for the each of them.

In the second example organizers can demolish $2$ boxes to make the total of $0$ paying $7$ burles for the each of them.

In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $5$ boxes.

- Program: 
def func():
    (n, m, a, b) = map(int, input().split())
    r = n % m
    if r == 0:
        print(0)
    elif m - r <= n:
        print(min((m - r) * a, r * b))
    else:
        print((m - r) * a)



- Annotated Code: 
#State of the program right berfore the function call: n, m, a, and b are integers such that 1 ≤ n, m ≤ 10^12 and 1 ≤ a, b ≤ 100.
def func():
    n, m, a, b = map(int, input().split())

r = n % m
    if (r == 0) :
        print(0)
    else :
        if (m - r <= n) :
            print(min((m - r) * a, r * b))
        else :
            print((m - r) * a)
        #State of the program after the if-else block has been executed: *`n`, `m`, `a`, `b`, and `r` are integers where `r` is the remainder of `n` divided by `m` and `r` is not equal to 0. If `m - r` is less than or equal to `n`, the minimum value between `(m - r) * a` and `r * b` is printed. If `m - r` is greater than `n`, the value of `(m - r) * a` is printed.
    #State of the program after the if-else block has been executed: *`n`, `m`, `a`, `b`, and `r` are integers where `r` is the remainder of `n` divided by `m`. If `r` is 0, the program does nothing. If `r` is not 0, and `m - r` is less than or equal to `n`, the minimum value between `(m - r) * a` and `r * b` is printed. If `m - r` is greater than `n`, the value of `(m - r) * a` is printed.
#Overall this is what the function does:The function reads four integers `n`, `m`, `a`, and `b` from the input, where `1 ≤ n, m ≤ 10^12` and `1 ≤ a, b ≤ 100`. It calculates the remainder `r` of `n` divided by `m`. If `r` is 0, the function prints 0. Otherwise, it checks if `m - r` is less than or equal to `n`. If true, it prints the minimum value between `(m - r) * a` and `r * b`. If `m - r` is greater than `n`, it prints `(m - r) * a`. The function does not return any value; it only prints the result. Potential edge cases include when `n` is exactly divisible by `m` (i.e., `r = 0`), and when `m - r` is greater than `n`, which could occur if `n` is very small compared to `m`. The function does not handle invalid input or non-integer inputs, which could lead to runtime errors.


Beggining of Original Assessment: 
Reasoning:  
The solution provided is almost correct but has a subtle flaw in its logic when determining whether to build or demolish boxes. The condition `elif m - r <= n:` is unnecessary and does not affect the correctness of the solution in most practical cases because `m - r` is always less than or equal to `m`, which is far less than `n` in the problem constraints. However, this condition does not add value and could be misleading.

The core of the solution is to calculate the minimum cost between building `(m - r)` boxes or demolishing `r` boxes. This is correctly implemented with `print(min((m - r) * a, r * b))`. This part of the code ensures that the minimum cost is chosen, either by building up to the next multiple of `m` or by reducing down to the previous multiple of `m`.

However, the condition `elif m - r <= n:` is redundant and can be removed without affecting the correctness of the solution. The simplified version would directly compute the minimum cost without this additional check.

Given the logic and the examples provided, the solution works as expected and produces the correct output for the given test cases. Therefore, despite the unnecessary condition, the program is functionally correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

