
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
PolandBall is a young, clever Ball. He is interested in prime numbers. He has stated a following hypothesis: "There exists such a positive integer n that for each positive integer m number n·m + 1 is a prime number".

Unfortunately, PolandBall is not experienced yet and doesn't know that his hypothesis is incorrect. Could you prove it wrong? Write a program that finds a counterexample for any n.


-----Input-----

The only number in the input is n (1 ≤ n ≤ 1000) — number from the PolandBall's hypothesis. 


-----Output-----

Output such m that n·m + 1 is not a prime number. Your answer will be considered correct if you output any suitable m such that 1 ≤ m ≤ 10^3. It is guaranteed the the answer exists.


-----Examples-----
Input
3

Output
1
Input
4

Output
2


-----Note-----

A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

For the first sample testcase, 3·1 + 1 = 4. We can output 1.

In the second sample testcase, 4·1 + 1 = 5. We cannot output 1 because 5 is prime. However, m = 2 is okay since 4·2 + 1 = 9, which is not a prime number.

- Program: 
n = int(input())
for m in range(1, 1001):
    if not func_1(n * m + 1):
        print(m)
        break

def func_1(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True



- Annotated Code: 
n = int(input())
for m in range(1, 1001):
    if not func_1(n * m + 1):
        print(m)
        break

#State of the program right berfore the function call: num is an integer such that 1 ≤ num ≤ 1000.
def func_1(num):
    if (num < 2) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: num is an integer such that 2 ≤ num ≤ 1000.
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
        
    #State of the program after the  for loop has been executed: `num` is an integer such that 2 ≤ num ≤ 1000, `i` is `int(num
    return True
    #The program returns True
#Overall this is what the function does:The function `func_1` accepts an integer `num` (1 ≤ num ≤ 1000) and returns `True` if `num` is a prime number; otherwise, it returns `False`. If `num` is less than 2, the function immediately returns `False`. For numbers greater than or equal to 2, the function checks if `num` is divisible by any integer from 2 up to the square root of `num`. If any such divisor is found, the function returns `False`; otherwise, it returns `True`. The final state of the program is that the function has determined whether the input `num` is a prime number and returned the corresponding boolean value.


Beggining of Original Assessment: 
Correctness: **True**.

Explanation:
The program appears to correctly find a counterexample for any given \( n \) such that \( n \cdot m + 1 \) is not a prime number for some \( m \) in the range \( 1 \leq m \leq 1000 \). Here's a breakdown of why the program works:

1. **Prime Check Function (`func_1`)**:
   - The function `func_1` checks if a number is prime. It returns `False` if the number is less than 2 or if it has any divisors other than 1 and itself.
   - This function is implemented correctly and efficiently by checking divisibility up to the square root of the number.

2. **Main Logic**:
   - The program iterates over possible values of \( m \) from 1 to 1000.
   - For each \( m \), it calculates \( n \cdot m + 1 \) and checks if this number is not prime using the `func_1` function.
   - If a non-prime number is found, it prints the corresponding \( m \) and breaks out of the loop.

3. **Edge Cases**:
   - The program handles the edge case where \( n = 1 \). For \( n = 1 \), \( 1 \cdot m + 1 \) is \( m + 1 \). The smallest \( m \) that makes \( m + 1 \) non-prime is \( m = 1 \) (since \( 2 \) is prime, but \( 3 \) is not).
   - For larger values of \( n \), the program will eventually find a suitable \( m \) because the product \( n \cdot m + 1 \) will grow large enough to include composite numbers.

Given the constraints and the problem description, the program appears to handle all potential cases correctly. Therefore, the program is correct.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

