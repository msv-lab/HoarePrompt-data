
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
PolandBall is a young, clever Ball. He is interested in prime numbers. He has stated a following hypothesis: "There exists such a positive integer n that for each positive integer m number n·m + 1 is a prime number".

Unfortunately, PolandBall is not experienced yet and doesn't know that his hypothesis is incorrect. Could you prove it wrong? Write a program that finds a counterexample for any n.


-----Input-----

The only number in the input is n (1 ≤ n ≤ 1000) — number from the PolandBall's hypothesis. 


-----Output-----

Output such m that n·m + 1 is not a prime number. Your answer will be considered correct if you output any suitable m such that 1 ≤ m ≤ 10^3. It is guaranteed the the answer exists.


-----Examples-----
Input
3

Output
1
Input
4

Output
2


-----Note-----

A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

For the first sample testcase, 3·1 + 1 = 4. We can output 1.

In the second sample testcase, 4·1 + 1 = 5. We cannot output 1 because 5 is prime. However, m = 2 is okay since 4·2 + 1 = 9, which is not a prime number.

- Program: 
n = int(input())
for m in range(1, 1001):
    if not func_1(n * m + 1):
        print(m)
        break

def func_1(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True



- Annotated Code: 
n = int(input())
for m in range(1, 1001):
    if not func_1(n * m + 1):
        print(m)
        break

#State of the program right berfore the function call: num is an integer such that 1 ≤ num ≤ 1000.
def func_1(num):
    if (num < 2) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: num is an integer such that 2 ≤ num ≤ 1000.
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
        
    #State of the program after the  for loop has been executed: `num` is an integer such that 2 ≤ num ≤ 1000, `i` is `int(num
    return True
    #The program returns True



Beggining of Original Assessment: 
Reasoning:

The given Python program aims to find a counterexample for the hypothesis that there exists a positive integer \( n \) such that for every positive integer \( m \), the expression \( n \cdot m + 1 \) is a prime number. The program does this by iterating through possible values of \( m \) from 1 to 1000 and checking if \( n \cdot m + 1 \) is not a prime number using the function `func_1`.

### Analysis of the Program:

1. **Input Handling:**
   - The program reads an integer \( n \) from the input.
   - This is correctly done using `n = int(input())`.

2. **Prime Check Function (`func_1`):**
   - The function `func_1` checks if a number is prime.
   - It returns `False` if the number is less than 2.
   - It checks divisibility from 2 up to the square root of the number, returning `False` if any divisor is found.
   - If no divisors are found, it returns `True`.
   - This function is correctly implemented and efficiently checks for primality.

3. **Main Logic:**
   - The program iterates over \( m \) from 1 to 1000.
   - For each \( m \), it computes \( n \cdot m + 1 \) and checks if it is not a prime number using `func_1`.
   - If a non-prime number is found, it prints \( m \) and breaks out of the loop.
   - This logic is correct and ensures that a valid \( m \) is found within the specified range.

### Conclusion:
The program correctly implements the logic to find a counterexample for the given hypothesis. It uses a well-structured prime check function and iterates through the required range to find a suitable \( m \). Therefore, the program is correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

