
 Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the programâ€™s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
We have a sequence of N integers: A_1, A_2, \cdots, A_N.
You can perform the following operation between 0 and K times (inclusive):
 - Choose two integers i and j such that i \neq j, each between 1 and N (inclusive). Add 1 to A_i and -1 to A_j, possibly producing a negative element.
Compute the maximum possible positive integer that divides every element of A after the operations. Here a positive integer x divides an integer y if and only if there exists an integer z such that y = xz.

-----Constraints-----
 - 2 \leq N \leq 500
 - 1 \leq A_i \leq 10^6
 - 0 \leq K \leq 10^9
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N K
A_1 A_2 \cdots A_{N-1} A_{N}

-----Output-----
Print the maximum possible positive integer that divides every element of A after the operations.

-----Sample Input-----
2 3
8 20

-----Sample Output-----
7

7 will divide every element of A if, for example, we perform the following operation:
 - Choose i = 2, j = 1. A becomes (7, 21).
We cannot reach the situation where 8 or greater integer divides every element of A.

# Functions with Execution Summary:
import math

(N, K) = map(int, input().split())
A = list(map(int, input().split()))
sum_A = sum(A)
gcd_A = func_1(A)
divisors = func_2(sum_A)
for d in divisors:
    if all((a % d == 0 or (sum_A - a) % d <= K for a in A)):
        print(d)
        break

Function number 1 :
 Code:
 '''
def func_1(lst):
    gcd_result = lst[0]
    for num in lst[1:]:
        gcd_result = math.gcd(gcd_result, num)
    return gcd_result
''' 

 Output hints for function1:  The function `func_1` accepts a list `lst` of integers where each integer is between 1 and \(10^6\). It calculates and returns the greatest common divisor (GCD) of all elements in `lst`. If `lst` contains only one element, it returns that single element. The function does not modify the input list `lst`. If the input list is empty, the function will raise an `IndexError` because it attempts to access `lst[0]` without checking if the list is empty.
Function number 2 :
 Code:
 '''
def func_2(x):
    divisors = set()
    for i in range(1, int(math.sqrt(x)) + 1):
        if x % i == 0:
            divisors.add(i)
            divisors.add(x // i)
    return sorted(divisors, reverse=True)
''' 

 Output hints for function2:  The function `func_2` accepts a positive integer `x` and returns a sorted list of all divisors of `x` in descending order. It correctly identifies all divisors by iterating through numbers from 1 to the square root of `x` and adding both the divisor and its corresponding quotient to a set. The function ensures that the returned list is sorted in descending order. Edge cases such as when `x` is 1 (where the only divisor is 1) or when `x` is a prime number (where the only divisors are 1 and `x` itself) are handled correctly.


# Your response:
Reasoning:  
Correctness: **True** or **False**

