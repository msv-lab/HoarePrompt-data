[
    {
        "description": "Rudolf and Bernard decided to play a game with their friends. n people stand\nin a circle and start throwing a ball to each other. They are numbered from 1\nto n in the clockwise order.\n\nLet's call a transition a movement of the ball from one player to his\nneighbor. The transition can be made clockwise or counterclockwise.\n\nLet's call the clockwise (counterclockwise) distance from player y_1 to player\ny_2 the number of transitions clockwise (counterclockwise) that need to be\nmade to move from player y_1 to player y_2 . For example, if n=7 then the\nclockwise distance from 2 to 5 is 3 , and the counterclockwise distance from 2\nto 5 is 4 .\n\nInitially, the ball is with the player number x (players are numbered\nclockwise). On the i -th move the person with the ball throws it at a distance\nof r_i (1 \\le r_i \\le n - 1 ) clockwise or counterclockwise. For example, if\nthere are 7 players, and the 2 nd player, after receiving the ball, throws it\na distance of 5 , then the ball will be caught by either the 7 th player\n(throwing clockwise) or the 4 th player (throwing counterclockwise). An\nillustration of this example is shown below.\n\n![](https://espresso.codeforces.com/29f44c71d01625dfd7795270dbc36b2737f0b368.png)\n\nThe game was interrupted after m throws due to unexpected rain. When the rain\nstopped, the guys gathered again to continue. However, no one could remember\nwho had the ball. As it turned out, Bernard remembered the distances for each\nof the throws and the direction for some of the throws (clockwise or\ncounterclockwise).\n\nRudolf asks you to help him and based on the information from Bernard,\ncalculate the numbers of the players who could have the ball after m throws.\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases. Then follow the descriptions of the test cases.\n\nThe first line of each test case contains three integers n, m, x (2 \\le n \\le\n1000 , 1 \\le m \\le 1000 , 1 \\le x \\le n ) — the number of players, the number\nof throws made, and the number of the player who threw the ball first,\nrespectively.\n\nThe next m lines contain information about each throw in order. Each of them\ncontains an integer r_i (1 \\le r_i \\le n - 1 ) — the distance at which the i\n-th throw was made, and a symbol c_i , equal to '0', '1', or '?':\n\n  * if c_i ='0', then the i -th throw was made clockwise, \n  * if c_i ='1', then the i -th throw was made counterclockwise, \n  * if c_i ='?', then Bernard does not remember the direction and the i -th throw could have been made either clockwise or counterclockwise. \n\nIt is guaranteed that the sum n \\cdot m (n multiplied by m ) over all test\ncases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output two lines.\n\nIn the first line, output the number of players k (1 \\le k \\le n ) who could\nhave the ball at the end of the game.\n\nIn the next line, output k numbers b_i (1 \\le b_i \\le n ) — the numbers of the\nplayers in increasing order. All numbers must be different.\n\nExample\n\nInput\n\n    5\n    \n    6 3 2\n    \n    2 ?\n    \n    2 ?\n    \n    2 ?\n    \n    12 1 2\n    \n    3 1\n    \n    10 7 4\n    \n    2 ?\n    \n    9 1\n    \n    4 ?\n    \n    7 0\n    \n    2 0\n    \n    8 1\n    \n    5 ?\n    \n    5 3 1\n    \n    4 0\n    \n    4 ?\n    \n    1 ?\n    \n    4 1 1\n    \n    2 ?\n\nOutput\n\n    3\n    2 4 6 \n    1\n    11 \n    4\n    3 5 7 9 \n    3\n    2 3 5 \n    1\n    3 \n    \nNote\n\nBelow is an illustration of three throws for the first test case. The arrows\ndenote possible throw directions. Players who could have the ball after the\nthrow are highlighted in gray.\n\n![](https://espresso.codeforces.com/8c70d0cb48359ee6327eabbf182827e664062516.png)\n![](https://espresso.codeforces.com/159cf99566782566b4c267b54062452988d11444.png)\n![](https://espresso.codeforces.com/007b0cb2cc613eba2f2e45e69d5d973f282a9d5d.png)",
        "task_name": "1941-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    n, m, x = map(int, input().split())\n    queue = []\n    for __ in range(m):\n        d, c = input().split()\n        d = int(d)\n        if len(queue) == 0:\n            queue.append(x)\n\n        length = len(queue)\n        \n        for ___ in range(length):\n            if c == '0':\n                queue.append((queue[0]+d) % n if (queue[0]+d) != n else n)\n            elif c == '1':\n                queue.append(n - (d-queue[0]) if queue[0] < d else queue[0]-d)\n            elif c == '?':\n                queue.append((queue[0]+d) % n if (queue[0]+d) != n else n)\n                queue.append(n - (d-queue[0]) if queue[0] <= d else queue[0]-d)\n            queue.pop(0)\n            length -= 1\n        queue = list(set(queue))\n    queue.sort()\n    print(len(queue))\n    for i in queue:\n        print(i, end=\" \")\n    print()",
        "correct": false,
        "task_id": 307
    },
    {
        "description": "Let's define a cyclic shift of some string s as a transformation from s_1 s_2\n\\dots s_{n-1} s_{n} into s_{n} s_1 s_2 \\dots s_{n-1} . In other words, you\ntake one last character s_n and place it before the first character while\nmoving all other characters to the right.\n\nYou are given a binary string s (a string consisting of only 0-s and/or 1-s).\n\nIn one operation, you can choose any substring s_l s_{l+1} \\dots s_r (1 \\le l\n< r \\le |s| ) and cyclically shift it. The cost of such operation is equal to\nr - l + 1 (or the length of the chosen substring).\n\nYou can perform the given operation any number of times. What is the minimum\ntotal cost to make s sorted in non-descending order?\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntest cases.\n\nThe first and only line of each test case contains a binary string s (2 \\le\n|s| \\le 2 \\cdot 10^5 ; s_i \\in {0, 1}) — the string you need to sort.\n\nAdditional constraint on the input: the sum of lengths of strings over all\ntest cases doesn't exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, print the single integer — the minimum total cost to make\nstring sorted using operation above any number of times.\n\nExample\n\nInput\n\n    5\n    \n    10\n    \n    0000\n    \n    11000\n    \n    101011\n    \n    01101001\n\nOutput\n\n    2\n    0\n    9\n    5\n    11\n    \nNote\n\nIn the first test case, you can choose the whole string and perform a cyclic\nshift: 10 \\rightarrow 01. The length of the substring is 2 , so the cost is 2\n.\n\nIn the second test case, the string is already sorted, so you don't need to\nperform any operations.\n\nIn the third test case, one of the optimal strategies is the next:\n\n  1. choose substring [1, 3] : 11000 \\rightarrow 01100; \n  2. choose substring [2, 4] : 01100 \\rightarrow 00110; \n  3. choose substring [3, 5] : 00110 \\rightarrow 00011. \n\nThe total cost is 3 + 3 + 3 = 9 .",
        "task_name": "1969-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\n\nfor _ in range(t):\n\n    s = input()\n\n    n1 = 0\n    ans = 0\n    for i in range(len(s)):\n        if(s[i]==\"1\"):\n            n1+=1\n        else:\n            ans += ((n1+1) if(n1!=0) else 0)\n    \n    print(ans)",
        "correct": true,
        "task_id": 140
    },
    {
        "description": "A square of positive (strictly greater than 0 ) area is located on the\ncoordinate plane, with sides parallel to the coordinate axes. You are given\nthe coordinates of its corners, in random order. Your task is to find the area\nof the square.\n\nInput\n\nEach test consists of several testcases. The first line contains one integer t\n(1 \\le t \\le 100 ) — the number of testcases. The following is a description\nof the testcases.\n\nEach testcase contains four lines, each line contains two integers x_i, y_i\n(-1000\\le x_i, y_i\\le 1000 ), coordinates of the corners of the square.\n\nIt is guaranteed that there is a square with sides parallel to the coordinate\naxes, with positive (strictly greater than 0 ) area, with corners in given\npoints.\n\nOutput\n\nFor each test case, print a single integer, the area of the square.\n\nExample\n\nInput\n\n    3\n    \n    1 2\n    \n    4 5\n    \n    1 5\n    \n    4 2\n    \n    -1 1\n    \n    1 -1\n    \n    1 1\n    \n    -1 -1\n    \n    45 11\n    \n    45 39\n    \n    17 11\n    \n    17 39\n\nOutput\n\n    9\n    4\n    784",
        "task_name": "1921-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range (int(input())):\n    x1,y1=map(int,input().split())\n    x2,y2=map(int,input().split())\n    x3,y3=map(int,input().split())\n    x4,y4=map(int,input().split())\n    if x1==x2:\n        print(abs((y2-y1)*(x3-x1)))\n    if x1==x4:\n        print(abs((y4-y1)*(x3-x1)))\n    if x1==x3:\n        print(abs((y3-y1)*(x2-x1)))",
        "correct": true,
        "task_id": 53
    },
    {
        "description": "You have a strip of paper with a binary string s of length n . You can fold\nthe paper in between any pair of adjacent digits.\n\nA set of folds is considered valid if after the folds, all characters that are\non top of or below each other match. Note that all folds are made at the same\ntime, so the characters don't have to match in between folds.\n\nFor example, these are valid foldings of s = \\mathtt{110110110011} and s =\n\\mathtt{01110} :\n\n![](https://espresso.codeforces.com/a961dc7cc221603a7d5a488247ba5439ce7444da.png)\n\nThe length of the folded strip is the length seen from above after all folds\nare made. So for the two above examples, after the folds shown above, the\nlengths would be 7 and 3 , respectively.\n\nNotice that for the above folding of s = \\mathtt{01110} , if we made either of\nthe two folds on their own, that would not be a valid folding. However,\nbecause we don't check for validity until all folds are made, this folding is\nvalid.\n\nAfter performing a set of valid folds, what is the minimum length strip you\ncan form?\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le\n2\\cdot 10^5 ) — the size of the strip.\n\nThe second line of each test case contains a string s of n characters '0' and\n'1' — a description of the digits on the strip.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single integer — the minimum possible length of\nthe strip after a valid folding.\n\nExample\n\nInput\n\n    6\n    \n    6\n    \n    101101\n    \n    1\n    \n    0\n    \n    12\n    \n    110110110011\n    \n    5\n    \n    01110\n    \n    4\n    \n    1111\n    \n    2\n    \n    01\n\nOutput\n\n    3\n    1\n    3\n    3\n    1\n    2\n    \nNote\n\nFor the first example case, one optimal folding is to fold the strip in the\nmiddle, which produces a strip of length 3.\n\nThe third and fourth example cases correspond to the images above. Note that\nthe folding shown above for s = \\mathtt{110110110011} is not of minimal\nlength.",
        "task_name": "1966-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def compute_prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    return pi\n\ndef minimal_fold_length(s):\n    n = len(s)\n    pi = compute_prefix_function(s)\n    k = n - pi[-1]\n    return k\n\nimport sys\n\ndef main():\n    import sys\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    idx = 1\n    results = []\n    for _ in range(t):\n        if idx >= len(data):\n            n = 0\n            s = ''\n        else:\n            n = int(data[idx])\n            idx += 1\n            if idx >= len(data):\n                s = ''\n            else:\n                s = data[idx]\n                idx += 1\n        if n == 0:\n            results.append(0)\n            continue\n        k = minimal_fold_length(s)\n        results.append(k)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 202
    },
    {
        "description": "Alice and Bob are playing a game. They have an array a_1, a_2,\\ldots,a_n . The\ngame consists of two steps:\n\n  * First, Alice will remove at most k elements from the array. \n  * Second, Bob will multiply at most x elements of the array by -1 . \n\nAlice wants to maximize the sum of elements of the array while Bob wants to\nminimize it. Find the sum of elements of the array after the game if both\nplayers play optimally.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains three integers n , k , and x (1 \\leq\nn \\leq 2 \\cdot 10^5 , 1 \\leq x,k \\leq n ) — the number of elements in the\narray, the limit on the number of elements of the array that Alice can remove,\nand the limit on the number of elements of the array that Bob can multiply -1\nto.\n\nThe second line of each test case contains n integers a_1, a_2,\\ldots, a_n (1\n\\leq a_i \\leq 1000 ) — the elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single integer — the sum of elements of the array\nafter the game if both players play optimally.\n\nExample\n\nInput\n\n    8\n    \n    1 1 1\n    \n    1\n    \n    4 1 1\n    \n    3 1 2 4\n    \n    6 6 3\n    \n    1 4 3 2 5 6\n    \n    6 6 1\n    \n    3 7 3 3 32 15\n    \n    8 5 3\n    \n    5 5 3 3 3 2 9 9\n    \n    10 6 4\n    \n    1 8 2 9 3 3 4 5 3 200\n    \n    2 2 1\n    \n    4 3\n    \n    2 1 2\n    \n    1 3\n\nOutput\n\n    0\n    2\n    0\n    3\n    -5\n    -9\n    0\n    -1\n    \nNote\n\nIn the first test case, it is optimal for Alice to remove the only element of\nthe array. Then, the sum of elements of the array is 0 after the game is over.\n\nIn the second test case, it is optimal for Alice to not remove any elements.\nBob will then multiply 4 by -1 . So the final sum of elements of the array is\n3+1+2-4=2 .\n\nIn the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then\nmultiply 5, 5, 3 by -1 . So the final sum of elements of the array is\n-5-5-3+3+3+2=-5 .",
        "task_name": "1920-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t=int(input())\nfor i in range(t):\n    n,k,x=map(int,input().split())\n    a=list(map(int,input().split()))\n    a.sort()\n    q=[0]\n    p=-10**5\n    for i in range(n):\n        q.append(q[-1]+a[i])\n    for i in range(n-k,n+1):\n        if i-x<1:\n            l=0\n        else:\n            l=i-x    \n        m=2*q[l]-q[i] \n        if m>p:\n            p=m\n    print(p)",
        "correct": false,
        "task_id": 105
    },
    {
        "description": "There is a one-dimensional grid of length n . The i -th cell of the grid\ncontains a character s_i , which is either '<' or '>'.\n\nWhen a pinball is placed on one of the cells, it moves according to the\nfollowing rules:\n\n  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. \n  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). \n  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. \n\nYou need to answer n independent queries. In the i -th query, a pinball will\nbe placed on the i -th cell. Note that we always place a pinball on the\ninitial grid.\n\nFor each query, calculate how many seconds it takes the pinball to leave the\ngrid. It can be shown that the pinball will always leave the grid within a\nfinite number of steps.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^5 ). The description of the test cases follows.\n\nThe first line of each test case contains an integer n (1 \\le n \\le 5 \\cdot\n10^5 ).\n\nThe second line of each test case contains a string s_1s_2 \\ldots s_{n} of\nlength n consisting of characters '<' and '>'.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, for each i (1 \\le i \\le n ) output the answer if a pinball\nis initially placed on the i -th cell.\n\nExample\n\nInput\n\n    3\n    \n    3\n    \n    ><<\n    \n    4\n    \n    <<<<\n    \n    6\n    \n    <><<<>\n\nOutput\n\n    3 6 5 \n    1 2 3 4 \n    1 4 7 10 8 1 \n    \nNote\n\nIn the first test case, the movement of the pinball for i=1 is shown in the\nfollowing pictures. It takes the pinball 3 seconds to leave the grid.\n\n![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)\n\nThe movement of the pinball for i=2 is shown in the following pictures. It\ntakes the pinball 6 seconds to leave the grid.\n\n![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)",
        "task_name": "1936-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    lc,acc = s.count('<'),0\n    ans = []\n    for i,x in enumerate([i for i in range(n) if s[i] == '<']+[i for i in range(n) if s[i] == '>']):\n        if i>=lc:\n            ans.append(n-i+acc)\n        acc += 2*(x-i)\n        if i<lc:\n            ans.append(i+1+acc)\n    print(*ans)",
        "correct": true,
        "task_id": 346
    },
    {
        "description": "You are given two arrays a and b of size n along with a fixed integer v .\n\nAn interval [l, r] is called a good interval if (b_l \\mid b_{l+1} \\mid \\ldots \\mid b_r) \\ge v , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). The beauty of a good interval is defined as \\max(a_l, a_{l+1}, \\ldots, a_r) .\n\nYou are given q queries of two types:\n\n  * \"1 i x\": assign b_i := x ; \n  * \"2 l r\": find the minimum beauty among all good intervals [l_0,r_0] satisfying l \\le l_0 \\le r_0 \\le r . If there is no suitable good interval, output -1 instead. \n\nPlease process all queries.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^5 ). The description of the test cases follows.\n\nThe first line of each test case contains two integers n and v (1 \\le n \\le 2\n\\cdot 10^5 , 1 \\le v \\le 10^9 ).\n\nThe second line of each testcase contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^9 ).\n\nThe third line of each testcase contains n integers b_1, b_2, \\ldots, b_n (1\n\\le b_i \\le 10^9 ).\n\nThe fourth line of each testcase contains one integer q (1 \\le q \\le 2 \\cdot\n10^5 ).\n\nThe i -th of the following q lines contains the description of queries. Each\nline is of one of two types:\n\n  * \"1 i x\" (1 \\le i \\le n , 1 \\le x \\le 10^9) ; \n  * \"2 l r\" (1 \\le l \\le r \\le n ). \n\nIt is guaranteed that both the sum of n and the sum of q over all test cases\ndo not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output the answers for all queries of the second type.\n\nExample\n\nInput\n\n    3\n    \n    3 7\n    \n    2 1 3\n    \n    2 2 3\n    \n    4\n    \n    2 1 3\n    \n    1 2 5\n    \n    2 2 3\n    \n    2 1 3\n    \n    4 5\n    \n    5 1 2 4\n    \n    4 2 3 3\n    \n    6\n    \n    2 1 4\n    \n    1 3 15\n    \n    2 3 4\n    \n    2 2 4\n    \n    1 2 13\n    \n    2 1 4\n    \n    1 5\n    \n    6\n    \n    4\n    \n    1\n    \n    2 1 1\n\nOutput\n\n    -1 3 2 \n    5 2 2 1 \n    -1 \n    \nNote\n\nIn the first test case, a = [2, 1, 3] , b = [2, 2, 3] , and v = 7 .\n\nThe first query is of the second type and has l = 1 and r = 3 . The largest\ninterval available is [1, 3] , and its bitwise OR is b_1 \\mid b_2 \\mid b_3 = 3\nwhich is less than v . Thus, no good interval exists.\n\nThe second query asks to change b_2 to 5 , so b becomes [2, 5, 3] .\n\nThe third query is of the second type and has l = 2 and r = 3 . There are\nthree possible intervals: [2, 2] , [3, 3] , and [2, 3] . However, b_2 = 5 < v\n, b_3 = 3 < v . So only the last interval is good: it has b_2 \\mid b_3 = 7 .\nThe answer is thus \\max(a_2, a_3) = 3 .\n\nThe fourth query is of the second type and has l = 1 and r = 3 . There are\nthree good intervals: [1, 2] , [2, 3] , and [1, 3] . Their beauty is 2 , 3 , 3\ncorrespondingly. The answer is thus 2 .\n\nIn the second test case, a = [5, 1, 2, 4] , b = [4, 2, 3, 3] , and v = 5 .\n\nThe first query has l = 1 and r = 4 . The only good intervals are: [1, 2] ,\n[1, 3] , [1, 4] . Their beauty is 5 , 5 , 5 correspondingly. The answer is\nthus 5 .",
        "task_name": "1937-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\n\n# 更新数组b的元素\ndef update_b(b, index, value):\n    b[index] = value\n\n# 检查区间是否是好的，并返回最大值\ndef check_good_interval(a, b, v, l, r):\n    current_or = 0\n    max_beauty = -1\n    for i in range(l, r+1):\n        current_or |= b[i]\n        max_beauty = max(max_beauty, a[i])\n        if current_or >= v:\n            return max_beauty\n    return -1\n\n# 处理查询\ndef process_queries(n, a, b, v, queries):\n    for query in queries:\n        query_type = int(query[0])\n        if query_type == 1:\n            index, value = int(query[1]), int(query[2])\n            update_b(b, index - 1, value)  # 数组索引从0开始\n        elif query_type == 2:\n            l, r = int(query[1]), int(query[2])\n            print(check_good_interval(a, b, v, l - 1, r - 1), end=' ')  # 数组索引从0开始\n        \n# 主程序\ndef main():\n    t = int(input().strip())  # 读取测试案例数量\n    results = []\n    for _ in range(t):\n        n, v = map(int, input().strip().split())\n        a = list(map(int, input().strip().split()))\n        b = list(map(int, input().strip().split()))\n        q = int(input().strip())\n        queries = []\n        for _ in range(q):\n            queries.append(input().strip().split())\n        process_queries(n, a, b, v, queries)\n        print()  # 每个测试用例之间打印换行\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 329
    },
    {
        "description": "During your journey through computer universes, you stumbled upon a very\ninteresting world. It is a path with n consecutive cells, each of which can\neither be empty, contain thorns, or a coin. In one move, you can move one or\ntwo cells along the path, provided that the destination cell does not contain\nthorns (and belongs to the path). If you move to the cell with a coin, you\npick it up.\n\n![](https://espresso.codeforces.com/34bd88a4aba4a1ae98e5681455c4a47900b7b9a8.png)\nHere, green arrows correspond to legal moves, and the red arrow corresponds to\nan illegal move.\n\nYou want to collect as many coins as possible. Find the maximum number of\ncoins you can collect in the discovered world if you start in the leftmost\ncell of the path.\n\nInput\n\nThe first line of input contains a single integer t (1 \\le t \\le 1000 ) — the\nnumber of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 50 )\n— the length of the path.\n\nThe second line of each test case contains a string of n characters, the\ndescription of the path. The character '.' denotes an empty cell, '@' denotes\na cell with a coin, and '*' denotes a cell with thorns. It is guaranteed that\nthe first cell is empty.\n\nOutput\n\nFor each test case, output a single integer, the maximum number of coins you\ncan collect.\n\nExample\n\nInput\n\n    3\n    \n    10\n    \n    .@@*@.**@@\n    \n    5\n    \n    .@@@@\n    \n    15\n    \n    .@@..@***..@@@*\n\nOutput\n\n    3\n    4\n    3\n    \nNote\n\nThe picture for the first example is in the problem statement.\n\nHere is the picture for the second example:\n\n![](https://espresso.codeforces.com/68fd7116585f37e79535fbc164a552cc8e148b75.png)\n\nAnd here is the picture for the third example:\n\n![](https://espresso.codeforces.com/1695fc45669a1bf1d6e1b3d4901cdd3cda38273c.png)",
        "task_name": "1932-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n  n=int(input())\n  s=input()\n  d=0\n  for i in range(len(s)):\n    if(s[i]=='@'):\n      d+=1\n    if(s[i-1]=='*' and s[i]=='*'):\n      break\n  print(d)",
        "correct": true,
        "task_id": 167
    },
    {
        "description": "You are given an integer n . You choose n cells (x_1,y_1),\n(x_2,y_2),\\dots,(x_n,y_n) in the grid n\\times n where 1\\le x_i\\le n and 1\\le\ny_i\\le n .\n\nLet \\mathcal{H} be the set of distinct Manhattan distances between any pair of\ncells. Your task is to maximize the size of \\mathcal{H} . Examples of sets and\ntheir construction are given in the notes.\n\nIf there exists more than one solution, you are allowed to output any.\n\nManhattan distance between cells (x_1,y_1) and (x_2,y_2) equals\n|x_1-x_2|+|y_1-y_2| .\n\nInput\n\nThe first line contains a single integer t (1\\le t\\le 50 ) — the number of\ntest cases.\n\nEach of the following t lines contains a single integer n (2\\le n\\le 10^3 ).\n\nOutput\n\nFor each test case, output n points which maximize the size of \\mathcal{H} .\nIt is not necessary to output an empty line at the end of the answer for each\ntest case.\n\nExample\n\nInput\n\n    5\n    \n    2\n    \n    3\n    \n    4\n    \n    5\n    \n    6\n\nOutput\n\n    1 1\n    1 2\n    \n    2 1\n    2 3\n    3 1\n    \n    1 1\n    1 3\n    4 3\n    4 4\n    \n    1 1\n    1 3\n    1 4\n    2 1\n    5 5\n    \n    1 4\n    1 5\n    1 6\n    5 2\n    5 5\n    6 1\n    \nNote\n\nIn the first testcase we have n=2 . One of the possible arrangements is:\n\n![](https://espresso.codeforces.com/4d7adaa08c9ee5ebf2a0caba13185ac968d6bcd9.png)\nThe arrangement with cells located in (1,1) and (1,2) . In this case\n\\mathcal{H}=\\\\{|1-1|+|1-1|,|1-1|+|2-2|,|1-1|+|1-2|\\\\}=\\\\{0,0,1\\\\}=\\\\{0,1\\\\} .\nHence, the size of \\mathcal{H} is 2 . It can be shown that it is the greatest\npossible answer.\n\nIn the second testcase we have n=3 . The optimal arrangement is:\n\n![](https://espresso.codeforces.com/52d127e3dbe0141bb58dbdf4158586772a208758.png)\nThe arrangement with cells located in (2,1) , (2,3) and (3,1) .\n\n\\mathcal{H}\n=\\\\{|2-2|+|1-1|,|2-2|+|3-3|,|3-3|+|1-1|,|2-2|+|1-3|,|2-3|+|1-1|,|2-3|+|3-1|\\\\}\n=\\\\{0,0,0,2,1,3\\\\} =\\\\{0,1,2,3\\\\} .\n\nFor n=4 a possible arrangement is:\n\n![](https://espresso.codeforces.com/575a6758d1f67174ceb877b32a1e89770cd2281a.png)\n\nFor n=5 a possible arrangement is:\n\n![](https://espresso.codeforces.com/b790401b426625982c00d04cff13aceec53918b4.png)\n\nFor n=6 a possible arrangement is:\n\n![](https://espresso.codeforces.com/d0f498905660a67115d9f58c6cbc1439ba6e509c.png)",
        "task_name": "1968-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve(n):\n    # For n, we will output n points\n    # A simple strategy is to place points in a diagonal or near-diagonal pattern\n    points = []\n    for i in range(n):\n        # Place points in a diagonal pattern\n        # (i+1, (i*2 % n) + 1) ensures we stay within bounds and spread points\n        x = i + 1\n        y = (i * 2 % n) + 1\n        points.append((x, y))\n    return points\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(t):\n        n = int(data[i + 1])\n        result = solve(n)\n        results.append(result)\n    \n    for result in results:\n        for x, y in result:\n            print(x, y)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 189
    },
    {
        "description": "You are given two integers, n and k . There is a graph on n vertices, numbered\nfrom 1 to n , which initially has no edges.\n\nYou have to assign each vertex an integer; let a_i be the integer on the\nvertex i . All a_i should be distinct integers from 1 to n .\n\nAfter assigning integers, for every pair of vertices (i, j) , you add an edge\nbetween them if |i - j| + |a_i - a_j| \\le k .\n\nYour goal is to create a graph which can be partitioned into the minimum\npossible (for the given values of n and k ) number of cliques. Each vertex of\nthe graph should belong to exactly one clique. Recall that a clique is a set\nof vertices such that every pair of vertices in it are connected with an edge.\n\nSince BledDest hasn't really brushed his programming skills up, he can't solve\nthe problem \"given a graph, partition it into the minimum number of cliques\".\nSo we also ask you to print the partition itself.\n\nInput\n\nThe first line contains one integer t (1 \\le t \\le 1600 ) — the number of test\ncases.\n\nEach test case consists of one line containing two integers n and k (2 \\le n\n\\le 40 ; 1 \\le k \\le 2n ).\n\nOutput\n\nFor each test case, print three lines:\n\n  * the first line should contain n distinct integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le n ) — the values you assign to the vertices; \n  * the second line should contain one integer q (1 \\le q \\le n ) — the number of cliques you partition the graph into; \n  * the third line should contain n integers c_1, c_2, \\dots, c_n (1 \\le c_i \\le q ) — the partition of the graph into cliques. Where two vertices u and v are in the same clique if c_u = c_v . \n\nIf there are multiple answers, print any of them.\n\nExample\n\nInput\n\n    3\n    \n    2 3\n    \n    5 4\n    \n    8 16\n\nOutput\n\n    2 1\n    1\n    1 1\n    3 1 5 2 4\n    2\n    1 1 2 1 2\n    1 2 3 4 5 6 7 8\n    1\n    1 1 1 1 1 1 1 1",
        "task_name": "1948-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n    for _ in range(t):\n        # Read n and k for each test case\n        n, k = map(int, input().split())\n        \n        # Initialize arrays for assigned integers and clique numbers\n        a = [-1] * n\n        c = [-1] * n\n        \n        # Initialize clique counter and starting index\n        cnt = 0\n        beg = 0\n        \n        # Process vertices in chunks\n        while beg < n:\n            # Determine the size of the current chunk\n            k = min(k, n - beg)\n            # Calculate half to help with integer assignment\n            half = (k - 1) // 2\n            \n            # Assign integers and clique numbers for the current chunk\n            for i in range(k):\n                a[beg + i] = beg + (half - 1 - i)\n                # Ensure the assigned integer is within bounds\n                if a[beg + i] < beg:\n                    a[beg + i] += k\n                # Assign the current clique number\n                c[beg + i] = cnt\n            \n            # Increment the clique counter\n            cnt += 1\n            # Move to the next chunk\n            beg += k\n        \n        # Output the results for the current test case\n        print(\" \".join(str(x + 1) for x in a))\n        print(cnt)\n        print(\" \".join(str(x + 1) for x in c))\n\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": 269
    }
]