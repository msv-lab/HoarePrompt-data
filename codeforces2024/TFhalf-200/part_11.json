[
    {
        "description": "Alice and Bob are playing a game on n piles of stones. On each player's turn,\nthey select a positive integer k that is at most the size of the smallest\nnonempty pile and remove k stones from each nonempty pile at once. The first\nplayer who is unable to make a move (because all piles are empty) loses.\n\nGiven that Alice goes first, who will win the game if both players play\noptimally?\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le\n2\\cdot 10^5 ) — the number of piles in the game.\n\nThe next line of each test case contains n integers a_1, a_2, \\ldots a_n (1\n\\le a_i \\le 10^9 ), where a_i is the initial number of stones in the i -th\npile.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, print a single line with the name of the winner, assuming\nboth players play optimally. If Alice wins, print \"Alice\", otherwise print\n\"Bob\" (without quotes).\n\nExample\n\nInput\n\n    7\n    \n    5\n    \n    3 3 3 3 3\n    \n    2\n    \n    1 7\n    \n    7\n    \n    1 3 9 7 4 2 100\n    \n    3\n    \n    1 2 3\n    \n    6\n    \n    2 1 3 4 2 4\n    \n    8\n    \n    5 7 2 9 6 3 3 2\n    \n    1\n    \n    1000000000\n\nOutput\n\n    Alice\n    Bob\n    Alice\n    Alice\n    Bob\n    Alice\n    Alice\n    \nNote\n\nIn the first test case, Alice can win by choosing k=3 on her first turn, which\nwill empty all of the piles at once.\n\nIn the second test case, Alice must choose k=1 on her first turn since there\nis a pile of size 1 , so Bob can win on the next turn by choosing k=6 .",
        "task_name": "1965-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor i in range(0, t):\n    n = int(input())\n    s = set(map(int, input().split()))\n    vals = list(s)\n    if min(vals) != 1:\n        print(\"Alice\")\n    elif len(vals) % 2 == 1:\n        print(\"Alice\")\n    else:\n        offset = 0\n        vals.sort()\n        while vals[offset] == (vals[offset + 1] - 1):\n            offset += 1\n            if offset == (len(vals) - 1):\n                break\n        if offset == (len(vals) - 1):\n            offset += 1\n        if offset % 2 == 0:\n            print(\"Bob\")\n        else:\n            print(\"Alice\")",
        "correct": false,
        "task_id": 344
    },
    {
        "description": "Bob has a grid with 3 rows and n columns, each of which contains either a_i or\n-a_i for some integer 1 \\leq i \\leq n . For example, one possible grid for n=4\nis shown below:\n\nAlice and Bob play a game as follows:\n\n  * Bob shows Alice his grid. \n  * Alice gives Bob an array a_1, a_2, \\dots, a_n of her choosing, whose elements are all \\mathbf{-1} or \\mathbf{1} . \n  * Bob substitutes these values into his grid to make a grid of -1 s and 1 s. \n  * Bob sorts the elements of each column in non-decreasing order. \n  * Alice wins if all the elements in the middle row are 1 ; otherwise, Bob wins. \n\nFor example, suppose Alice gives Bob the array [1, -1, -1, 1] for the grid\nabove. Then the following will happen (colors are added for clarity):\n\nSince the middle row is all 1 , Alice wins.\n\nGiven Bob's grid, determine whether or not Alice can choose the array a to win\nthe game.\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 1000 ) — the number\nof test cases.\n\nThe first line of each test case contains a single integer n (2 \\leq n \\leq\n500 ) — the number of columns of Bob's grid.\n\nThe next three lines each contain n integers, the i -th of which contains\ng_{i,1}, g_{i,2}, \\dots, g_{i,n} (-n \\leq g_{i,j} \\leq n , g_{i,j} \\neq 0 ),\nrepresenting Bob's grid.\n\nIf cell x > 0 is in the input, that cell in Bob's grid should contain a_x ; if\nx < 0 is in the input, that cell in Bob's grid should contain -a_{-x} . See\nthe sample input and notes for a better understanding.\n\nOutput\n\nFor each test case, output \"YES\" (without quotes) if Alice can win, and \"NO\"\n(without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\",\nand \"Yes\" will be recognized as a positive response).\n\nExample\n\nInput\n\n    4\n    \n    4\n    \n    1 -2 -3 -2\n    \n    -4 4 -1 -3\n    \n    1 2 -2 4\n    \n    2\n    \n    1 2\n    \n    -1 -2\n    \n    2 -2\n    \n    5\n    \n    1 2 3 4 5\n    \n    -2 3 -4 -5 -1\n    \n    3 -5 1 2 2\n    \n    6\n    \n    1 3 -6 2 5 2\n    \n    1 3 -2 -3 -6 -5\n    \n    -2 -1 -3 2 3 1\n\nOutput\n\n    YES\n    NO\n    YES\n    NO\n    \nNote\n\nThe first test case is described in the statement.\n\nIn the second test case, Bob's grid is as follows:\n\nFor the last column to have 1 in the middle row when sorted, Alice must pick\na_2 = -1 . However, it is then impossible to choose a_1 such that the first\ncolumn has 1 in the middle when sorted. Thus, Alice cannot win.\n\nIn the third test case, Alice can pick a = [1,1,1,1,1] .",
        "task_name": "1971-H",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def is_solvable(field):\n    n = len(field[0])\n    graph = [[] for i in range(2 * n + 1)]\n    for a, b, c in zip(*field):\n        graph[-a].extend((b, c))\n        graph[-b].extend((a, c))\n        graph[-c].extend((a, b))\n    status = [0] * len(graph)\n    def try_fill(i):\n        traversal = [i]\n        status[i] = 1\n        status[-i] = -1\n        processed = 0\n        while processed < len(traversal):\n            v = traversal[processed]\n            processed += 1\n            for u in graph[v]:\n                if status[u] == -1:\n                    for w in traversal:\n                        status[w] = 0\n                        status[-w] = 0\n                    return False\n                if status[u] == 0:\n                    status[u] = 1\n                    status[-u] = -1\n                    traversal.append(u)\n        return True\n    \n    for i in range(1, n + 1):\n        if status[i] != 0:\n            continue\n        if not (try_fill(i) or try_fill(-i)):\n            return \"NO\"\n    return \"YES\"\n    \nn_tests = int(input())\nfor test_id in range(n_tests):\n    n = int(input())\n    field = []\n    for i in range(3):\n        field.append(list(map(int, input().split())))\n    print(is_solvable(field))",
        "correct": true,
        "task_id": 225
    },
    {
        "description": "Some permutation of length n is guessed.\n\nYou are given the indices of its prefix maximums and suffix maximums.\n\nRecall that a permutation of length k is an array of size k such that each\ninteger from 1 to k occurs exactly once.\n\nPrefix maximums are the elements that are the maximum on the prefix ending at\nthat element. More formally, the element a_i is a prefix maximum if a_i > a_j\nfor every j < i .\n\nSimilarly, suffix maximums are defined, the element a_i is a suffix maximum if\na_i > a_j for every j > i .\n\nYou need to output the number of different permutations that could have been\nguessed.\n\nAs this number can be very large, output the answer modulo 10^9 + 7 .\n\nInput\n\nEach test consists of several test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^4 ) — the number of test cases. Then follows the\ndescription of the test cases.\n\nThe first line of each test case contains three integers n, m_1 and m_2 (1 \\le\nm_1, m_2 \\le n \\le 2 \\cdot 10^5 ) — the length of the permutation, the number\nof prefix maximums, and the number of suffix maximums, respectively.\n\nThe second line of each test case contains m_1 integers p_1 < p_2 < \\ldots <\np_{m_1} (1 \\le p_i \\le n ) — the indices of the prefix maximums in increasing\norder.\n\nThe third line of each test case contains m_2 integers s_1 < s_2 < \\ldots <\ns_{m_2} (1 \\le s_i \\le n ) — the indices of the suffix maximums in increasing\norder.\n\nIt is guaranteed that the sum of the values of n for all test cases does not\nexceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer on a separate line — the number of\nsuitable permutations modulo 10^9 + 7 .\n\nExample\n\nInput\n\n    6\n    \n    1 1 1\n    \n    1\n    \n    1\n    \n    4 2 3\n    \n    1 2\n    \n    2 3 4\n    \n    3 3 1\n    \n    1 2 3\n    \n    3\n    \n    5 3 4\n    \n    1 2 3\n    \n    2 3 4 5\n    \n    20 5 4\n    \n    1 2 3 4 12\n    \n    12 13 18 20\n    \n    6 2 3\n    \n    1 3\n    \n    3 4 6\n\nOutput\n\n    1\n    3\n    1\n    0\n    317580808\n    10\n    \nNote\n\nThe following permutations are suitable for the second set of input data:\n\n  * [1, 4, 3, 2] \n  * [2, 4, 3, 1] \n  * [3, 4, 2, 1] \n\nThe following permutations are suitable for the sixth set of input data:\n\n  * [2, 1, 6, 5, 3, 4] \n  * [3, 1, 6, 5, 2, 4] \n  * [3, 2, 6, 5, 1, 4] \n  * [4, 1, 6, 5, 2, 3] \n  * [4, 2, 6, 5, 1, 3] \n  * [4, 3, 6, 5, 1, 2] \n  * [5, 1, 6, 4, 2, 3] \n  * [5, 2, 6, 4, 1, 3] \n  * [5, 3, 6, 4, 1, 2] \n  * [5, 4, 6, 3, 1, 2]",
        "task_name": "1946-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "U = 1000000007\n\ndef pw(x, y):\n    # Function to compute (x^y) % U using binary exponentiation\n    v = 1\n    while y:\n        if y & 1:\n            v = v * x % U\n        y >>= 1\n        x = x * x % U\n    return v\n\n# Precompute factorials and their modular inverses\nfac = [1]\nfor i in range(1, 200001):\n    fac.append(fac[-1] * i % U)\n\ninv = [0] * 200001\ninv[200000] = pw(fac[200000], U - 2)\nfor i in range(199999, -1, -1):\n    inv[i] = inv[i + 1] * (i + 1) % U\n\nt = int(input())\nfor _ in range(t):\n    n, m1, m2 = [int(z) for z in input().split()]\n    a1 = [int(z) for z in input().split()]\n    a2 = [int(z) for z in input().split()]\n\n    # Check initial conditions for valid permutations\n    if a1[0] != 1 or a1[-1] != a2[0] or a2[-1] != n:\n        print(0)\n    else:\n        m = a2[0]\n        l = m - 1\n        r = n - m\n        # Calculate initial number of permutations\n        v = fac[n - 1] * inv[l] * inv[r] % U\n\n        # Process prefix maximums\n        for i in range(m1 - 2, -1, -1):\n            dx = a1[i + 1] - a1[i] - 1\n            # Update number of permutations for this segment\n            v = v * fac[l - 1] * inv[l - 1 - dx] % U\n            l = a1[i] - 1\n\n        # Process suffix maximums\n        for i in range(m2 - 1):\n            dx = a2[i + 1] - a2[i] - 1\n            # Update number of permutations for this segment\n            v = v * fac[r - 1] * inv[r - 1 - dx] % U\n            r = n - a2[i + 1]\n\n        # Output the result for the current test case\n        print(v)",
        "correct": true,
        "task_id": 296
    },
    {
        "description": "You are given an integer array a of length n . A subarray of a is one of its\ncontiguous subsequences (i. e. an array [a_l, a_{l+1}, \\dots, a_r] for some\nintegers l and r such that 1 \\le l < r \\le n ). Let's call a subarray unique\nif there is an integer that occurs exactly once in the subarray.\n\nYou can perform the following operation any number of times (possibly zero):\nchoose an element of the array and replace it with any integer.\n\nYour task is to calculate the minimum number of aforementioned operation in\norder for all the subarrays of the array a to be unique.\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntest cases.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 3\n\\cdot 10^5 ).\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le n ).\n\nAdditional constraint on the input: the sum of n over all test cases doesn't\nexceed 3 \\cdot 10^5 .\n\nOutput\n\nFor each test case, print a single integer — the minimum number of\naforementioned operation in order for all the subarrays of the array a to be\nunique.\n\nExample\n\nInput\n\n    4\n    \n    3\n    \n    2 1 2\n    \n    4\n    \n    4 4 4 4\n    \n    5\n    \n    3 1 2 1 2\n    \n    5\n    \n    1 3 2 1 2\n\nOutput\n\n    0\n    2\n    1\n    0\n    \nNote\n\nIn the second test case, you can replace the 1 -st and the 3 -rd element, for\nexample, like this: [3, 4, 1, 4] .\n\nIn the third test case, you can replace the 4 -th element, for example, like\nthis: [3, 1, 2, 3, 2] .",
        "task_name": "1969-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections import defaultdict\n\n# Read the number of test cases\nfor _ in range(int(input())):\n    # Read the length of the array\n    n = int(input())\n    # Read the array elements\n    a = list(map(int, input().split()))\n    \n    # Dictionary to count the frequency of each element\n    d = defaultdict(int)\n    \n    # Count the frequency of each element in the array\n    for i in a:\n        d[i] += 1\n    \n    # Initialize the answer for the current test case\n    ans = 0\n    \n    # Iterate over each unique element in the dictionary\n    for i in d:\n        # If the frequency of the element is greater than 2\n        if d[i] > 2:\n            # Calculate the number of replacements needed\n            # We need to replace (d[i] - 2) elements to make the frequency 2\n            ans += (d[i] - 2)\n    \n    # Output the result for the current test case\n    print(ans)",
        "correct": false,
        "task_id": 145
    },
    {
        "description": "Let's say that two strings a and b are equal if you can get the string b by\ncyclically shifting string a . For example, the strings 0100110 and 1100100\nare equal, while 1010 and 1100 are not.\n\nYou are given a binary string s of length n . Its first c characters are 1-s,\nand its last n - c characters are 0-s.\n\nIn one operation, you can replace one 0 with 1.\n\nCalculate the number of unique strings you can get using no more than k\noperations. Since the answer may be too large, print it modulo 10^9 + 7 .\n\nInput\n\nThe first and only line contains three integers n , c and k (1 \\le n \\le 3000\n; 1 \\le c \\le n ; 0 \\le k \\le n - c ) — the length of string s , the length of\nprefix of 1-s and the maximum number of operations.\n\nOutput\n\nPrint the single integer — the number of unique strings you can achieve\nperforming no more than k operations, modulo 10^9 + 7 .\n\nExamples\n\nInput\n\n    1 1 0\n\nOutput\n\n    1\n    \nInput\n\n    3 1 2\n\nOutput\n\n    3\n    \nInput\n\n    5 1 1\n\nOutput\n\n    3\n    \nInput\n\n    6 2 2\n\nOutput\n\n    7\n    \nInput\n\n    24 3 11\n\nOutput\n\n    498062\n    \nNote\n\nIn the first test case, the only possible string is 1.\n\nIn the second test case, the possible strings are: 100, 110, and 111. String\n101 is equal to 110, so we don't count it.\n\nIn the third test case, the possible strings are: 10000, 11000, 10100. String\n10010 is equal to 10100, and 10001 is equal to 11000.",
        "task_name": "1954-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def min_lex_rotation(s):\n    \"\"\" Returns the lexicographically smallest rotation of the string s. \"\"\"\n    s = s + s  # Concatenate string to itself\n    n = len(s) // 2\n    start = 0\n    for i in range(1, n):\n        for j in range(n):\n            if s[start + j] != s[i + j]:\n                if s[start + j] > s[i + j]:\n                    start = i\n                break\n    return s[start:start + n]\n\ndef unique_strings(n, c, k):\n    MOD = 10**9 + 7\n    unique_rotations = set()\n    \n    # Iterate over the number of ones we can have\n    for ones in range(c, c + k + 1):\n        if ones > n:\n            break\n        # Generate all strings with `ones` number of 1s\n        zeros = n - ones\n        from itertools import combinations\n        for positions in combinations(range(n), ones):\n            s = ['0'] * n\n            for pos in positions:\n                s[pos] = '1'\n            s = ''.join(s)\n            # Get the minimum lexicographical rotation\n            min_rotation = min_lex_rotation(s)\n            unique_rotations.add(min_rotation)\n    \n    return len(unique_rotations) % MOD\n\n# Example usage:\nn, c, k = map(int, input().split())\nprint(unique_strings(n, c, k))",
        "correct": false,
        "task_id": 335
    },
    {
        "description": "There is a one-dimensional grid of length n . The i -th cell of the grid\ncontains a character s_i , which is either '<' or '>'.\n\nWhen a pinball is placed on one of the cells, it moves according to the\nfollowing rules:\n\n  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. \n  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). \n  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. \n\nYou need to answer n independent queries. In the i -th query, a pinball will\nbe placed on the i -th cell. Note that we always place a pinball on the\ninitial grid.\n\nFor each query, calculate how many seconds it takes the pinball to leave the\ngrid. It can be shown that the pinball will always leave the grid within a\nfinite number of steps.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^5 ). The description of the test cases follows.\n\nThe first line of each test case contains an integer n (1 \\le n \\le 5 \\cdot\n10^5 ).\n\nThe second line of each test case contains a string s_1s_2 \\ldots s_{n} of\nlength n consisting of characters '<' and '>'.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, for each i (1 \\le i \\le n ) output the answer if a pinball\nis initially placed on the i -th cell.\n\nExample\n\nInput\n\n    3\n    \n    3\n    \n    ><<\n    \n    4\n    \n    <<<<\n    \n    6\n    \n    <><<<>\n\nOutput\n\n    3 6 5 \n    1 2 3 4 \n    1 4 7 10 8 1 \n    \nNote\n\nIn the first test case, the movement of the pinball for i=1 is shown in the\nfollowing pictures. It takes the pinball 3 seconds to leave the grid.\n\n![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)\n\nThe movement of the pinball for i=2 is shown in the following pictures. It\ntakes the pinball 6 seconds to leave the grid.\n\n![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)",
        "task_name": "1937-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\n \ninput = lambda: sys.stdin.readline().rstrip()\nsint = lambda: int(input())\nmint = lambda: map(int, input().split())\nints = lambda: list(map(int, input().split()))\n\nN = 500010\nl,r,lp,rp = [0]*N,[0]*N,[0]*N,[0]*N\n\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    s = input()\n    lcnt,rcnt = 0,0\n    for i in range(n):\n        l[i+1]=r[i+1]=0\n        if s[i]=='<': l[i+1]=1; lcnt+=1; lp[lcnt]=lp[lcnt-1]+i+1\n        else: r[i+1]=1; rcnt+=1; rp[rcnt]=rp[rcnt-1]+i+1\n        l[i+1]+=l[i]\n        r[i+1]+=r[i]\n    for i in range(1, n+1):\n        lright, rleft = r[i-1], l[n]-l[i]\n        k = min(lright, rleft)\n        if s[i-1]=='<':\n            ans = i+2*(lp[l[i]+k]-lp[l[i]])-2*(rp[lright]-rp[lright-k])\n            if rleft<lright:\n                ans += n+1-2*(rp[lright-k]-rp[lright-k-1])\n            print(ans,end=' ')\n        else:\n            ans = 2*(lp[l[i]+k]-lp[l[i]])-2*(rp[lright]-rp[lright-k])-i+n+1\n            if lright<rleft:\n                ans += 2*(lp[l[i]+k+1]-lp[l[i]+k])-n-1\n            print(ans,end=' ')\n    print()",
        "correct": true,
        "task_id": 331
    },
    {
        "description": "In the Master's Assistance Center, Nyam-Nyam was given a homework assignment\nin informatics.\n\nThere is an array a of length n , and you want to divide it into k > 1\nsubsegments^{\\dagger} in such a way that the \\operatorname{MEX} ^{\\ddagger} on\neach subsegment is equal to the same integer.\n\nHelp Nyam-Nyam find any suitable division, or determine that it does not\nexist.\n\n^{\\dagger} A division of an array into k subsegments is defined as k pairs of\nintegers (l_1, r_1), (l_2, r_2), \\ldots, (l_k, r_k) such that l_i \\le r_i and\nfor each 1 \\le j \\le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =\nn . These pairs represent the subsegments themselves.\n\n^{\\ddagger}\\operatorname{MEX} of an array is the smallest non-negative integer\nthat does not belong to the array.\n\nFor example:\n\n  * \\operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. \n  * \\operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. \n  * \\operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. \n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (2 \\le n \\le 10^5\n) — the length of the array a .\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (0\n\\le a_i < n ) — the elements of the array a .\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, output a single integer -1 if a suitable division does not\nexist.\n\nOtherwise, on the first line, output an integer k (2 \\le k \\le n ) — the\nnumber of subsegments in the division.\n\nThen output k lines — the division into subsegments. The i -th line should\ncontain two integers l_i and r_i (1 \\le l_i \\le r_i \\le n ) — the boundaries\nof the i -th subsegment.\n\nThe following conditions must be satisfied:\n\n  * For all 1 \\le j \\le k - 1 , l_{j + 1} = r_j + 1 ;\n  * l_1 = 1 , r_k = n .\n\nIf there are multiple possible solutions, output any of them.\n\nExample\n\nInput\n\n    5\n    \n    2\n    \n    0 0\n    \n    5\n    \n    0 1 2 3 4\n    \n    8\n    \n    0 1 7 1 0 1 0 3\n    \n    3\n    \n    2 2 2\n    \n    4\n    \n    0 1 2 0\n\nOutput\n\n    2\n    1 1\n    2 2\n    -1\n    3\n    1 3\n    4 5\n    6 8\n    3\n    1 1\n    2 2\n    3 3\n    -1\n\nNote\n\nIn the first test case, the array a can be divided into 2 subsegments with\nboundaries [1, 1] and [2, 2] :\n\n  * \\operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. \n  * \\operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. \n\nIn the second test case, it can be proven that the required division does not\nexist.\n\nIn the third test case, the array a can be divided into 3 subsegments with\nboundaries [1, 3] , [4, 5] , [6, 8] :\n\n  * \\operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. \n  * \\operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. \n  * \\operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.",
        "task_name": "1935-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    cur_mex = 0\n    cur_have = [0] * (n + 1)\n    for el in a:\n        cur_have[el] += 1\n    while cur_have[cur_mex]:\n        cur_mex += 1\n\n    another_mex = 0\n    another_have = [0] * (n + 1)\n    for i in range(n):\n        cur_have[a[i]] -= 1\n        if cur_have[a[i]] == 0 and cur_mex > a[i]:\n            cur_mex = a[i]\n\n        another_have[a[i]] += 1\n        while another_have[another_mex]:\n            another_mex += 1\n\n        if cur_mex == another_mex:\n            print(2)\n            print(\"1 \" + str(i + 1))\n            print(str(i + 2) + \" \" + str(n))\n            return\n\n    print(-1)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()",
        "correct": true,
        "task_id": 169
    },
    {
        "description": "Three friends gathered to play a few games of chess together.\n\nIn every game, two of them play against each other. The winner gets 2 points\nwhile the loser gets 0 , and in case of a draw, both players get 1 point each.\nNote that the same pair of players could have played any non-negative number\nof times (possibly zero). It is also possible that no games were played at\nall.\n\nYou've been told that their scores after all the games were played were p_1 ,\np_2 and p_3 . Additionally, it is guaranteed that p_1 \\leq p_2 \\leq p_3 holds.\n\nFind the maximum number of draws that could have happened and print it. If\nthere isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative\nnumber of games between the three players, print -1 instead.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 500 ). The description of the test cases follows.\n\nThe first line of each test case contains three integers p_1 , p_2 and p_3 (0\n\\leq p_1 \\leq p_2 \\leq p_3 \\leq 30 ) — the scores of the three players, sorted\nnon-decreasingly.\n\nOutput\n\nFor each testcase, print one number — the maximum possible number of draws\nthat could've happened, or -1 if the scores aren't consistent with any valid\nset of games and results.\n\nExample\n\nInput\n\n    7\n    \n    0 0 0\n    \n    0 1 1\n    \n    1 1 1\n    \n    1 1 2\n    \n    3 3 3\n    \n    3 4 5\n    \n    1 1 10\n\nOutput\n\n    0\n    1\n    -1\n    2\n    -1\n    6\n    2\n    \nNote\n\nIn the first example, no games were played at all, so no draws could occur\neither.\n\nFor the second example, exactly one game occurred between the second and the\nthird player and it ended in draw, so the answer is 1 .\n\nIt's easy to see that there's no set of games achieving the scores in third\nexample, so the answer for it is -1 .",
        "task_name": "1973-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def chess_for_three(test_cases):\n    results = []\n\n    for p1, p2, p3 in test_cases:\n        # Check if scores are consistent\n        total_points = p1 + p2 + p3\n        if total_points % 2 != 0 or p3 > p1 + p2:\n            results.append(-1)\n            continue\n\n        # Maximum number of draws\n        max_draws = min(p1, p3 - p2) + min(p2, p3 - p1)\n        results.append(max_draws)\n\n    return results\n\n# Input reading\nif __name__ == \"__main__\":\n    t = int(input())  # Number of test cases\n    test_cases = []\n\n    for _ in range(t):\n        p1, p2, p3 = map(int, input().split())\n        test_cases.append((p1, p2, p3))\n\n    # Calculate results\n    results = chess_for_three(test_cases)\n\n    # Output results\n    for result in results:\n        print(result)",
        "correct": false,
        "task_id": 65
    },
    {
        "description": "Alice and Bob are bored, so they decide to play a game with their wallets.\nAlice has a coins in her wallet, while Bob has b coins in his wallet.\n\nBoth players take turns playing, with Alice making the first move. In each\nturn, the player will perform the following steps in order:\n\n  1. Choose to exchange wallets with their opponent, or to keep their current wallets. \n  2. Remove 1 coin from the player's current wallet. The current wallet cannot have 0 coins before performing this step. \n\nThe player who cannot make a valid move on their turn loses. If both Alice and\nBob play optimally, determine who will win the game.\n\nInput\n\nEach test contains multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 1000 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first and only line of each test case contains two integers a and b (1 \\le\na, b \\le 10^9 ) — the number of coins in Alice's and Bob's wallets,\nrespectively.\n\nOutput\n\nFor each test case, output \"Alice\" if Alice will win the game, and \"Bob\" if\nBob will win the game.\n\nExample\n\nInput\n\n    10\n    \n    1 1\n    \n    1 4\n    \n    5 3\n    \n    4 5\n    \n    11 9\n    \n    83 91\n    \n    1032 9307\n    \n    839204 7281\n    \n    1000000000 1000000000\n    \n    53110 2024\n\nOutput\n\n    Bob\n    Alice\n    Bob\n    Alice\n    Bob\n    Bob\n    Alice\n    Alice\n    Bob\n    Bob\n    \nNote\n\nIn the first test case, an example of the game is shown below:\n\n  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=1 . \n  * Since Alice's wallet is empty, Bob must choose to not swap their wallets in step 1 of his move. Now, a=0 and b=0 . \n  * Since both Alice's and Bob's wallets are empty, Alice is unable to make a move. Hence, Bob wins. \n\nIn the second test case, an example of the game is shown below:\n\n  * Alice chooses to swap wallets with Bob in step 1 of her move. Now, a=3 and b=1 . \n  * Bob chooses to swap wallets with Alice in step 1 of his move. Now, a=1 and b=2 . \n  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=2 . \n  * Since Alice's wallet is empty, Bob can only choose to not swap wallets with Alice in step 1 of his move. Now, a=0 and b=1 . \n  * Since Alice's wallet is empty, Alice can only choose to swap wallets with Bob in step 1 of her move. Now, a=0 and b=0 . \n  * Since both Alice's wallet and Bob's wallet are empty, Bob is unable to make a move. Hence, Alice wins.",
        "task_name": "1919-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor i in range (t):\n          a,b= map(int,input().split())\n          if (a+b) %2 == 0 :\n                    print(\"BOB\")\n          else:\n                    print(\"ALICE\")",
        "correct": false,
        "task_id": 39
    },
    {
        "description": "The two versions are different problems. You may want to read both versions.\nYou can make hacks only if both versions are solved.\n\nYou are given two positive integers n , m .\n\nCalculate the number of ordered pairs (a, b) satisfying the following\nconditions:\n\n  * 1\\le a\\le n , 1\\le b\\le m ; \n  * b \\cdot \\gcd(a,b) is a multiple of a+b . \n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\le t\\le 10^4 ). The description of the test cases follows.\n\nThe first line of each test case contains two integers n , m (1\\le n,m\\le 2\n\\cdot 10^6 ).\n\nIt is guaranteed that neither the sum of n nor the sum of m over all test\ncases exceeds 2 \\cdot 10^6 .\n\nOutput\n\nFor each test case, print a single integer: the number of valid pairs.\n\nExample\n\nInput\n\n    6\n    \n    1 1\n    \n    2 3\n    \n    3 5\n    \n    10 8\n    \n    100 1233\n    \n    1000000 1145141\n\nOutput\n\n    0\n    1\n    1\n    6\n    423\n    5933961\n    \nNote\n\nIn the first test case, no pair satisfies the conditions.\n\nIn the fourth test case, (2,2),(3,6),(4,4),(6,3),(6,6),(8,8) satisfy the\nconditions.",
        "task_name": "1972-D2",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def gcd(x, y):  \n    if y == 0:  \n        return x  \n    return gcd(y, x % y)  \n  \ndef solve():  \n    a, b = map(int, input().split())  \n    ans = 0  \n    for x in range(1, int(a**0.5) + 1):  \n        for y in range(1, int(b**0.5) + 1):  \n            if gcd(x, y) == 1:  \n                cnt = min(a // ((x + y) * x), b // ((x + y) * y))  \n                if cnt >= 1:  \n                    ans += cnt  \n    print(ans)  \n  \nif __name__ == \"__main__\":  \n    T = int(input())  \n    for _ in range(T):  \n        solve()",
        "correct": true,
        "task_id": 28
    }
]