[
    {
        "description": "The Czech Technical University campus consists of n buildings, indexed from 1\nto n . In each building, there can be a math class scheduled, or a computer\nscience class, or neither (but not both). Additionally, in each building,\nthere is at most one professor, and each professor is either an expert in\nmathematics or in computer science.\n\nAs an intern at University Express Inc., your job is to quickly transport the\nprofessors to their classes. For this, you have been granted a brand new two-\nperson scooter, able to accommodate yourself, plus at most one passenger.\n\nInitially, you are the only person on the scooter. When you arrive at a\nbuilding, you may drop off or pick up professors to/from that building.\nHowever, in order to improve the efficiency of your task, you are allowed to\ndrive to each of the n buildings at most once, in the order of your choice\n(you can also decide where to start the itinerary).\n\nAfter the end of your itinerary, in each building where a math class is\nscheduled, there must be a professor expert in math, and in each building\nwhere a computer science class is scheduled, there must be a professor expert\nin computer science.\n\nDevise an itinerary that makes it possible to teach all classes.\n\nInput\n\nThe first line contains an integer n (1\\le n \\le 2000 ) — the number of\nbuildings in the campus.\n\nThe second line contains a string of c of length n consisting of the\ncharacters \\texttt{-} , \\texttt{C} , \\texttt{M} — the i -th character denotes\nthe subject of the class scheduled in the i -th building. \\texttt{C} stands\nfor computer science, \\texttt{M} stands for mathematics, while \\texttt{-}\nmeans that there is no class scheduled in the i -th building.\n\nThe third line contains a string p of length n consisting of the characters\n\\texttt{-} , \\texttt{C} , \\texttt{M} — the i -th character denotes the\nexpertise of the professor in the i -th building (if there is a professor).\n\\texttt{C} stands for computer science, \\texttt{M} stands for mathematics,\nwhile \\texttt{-} means that there is no professor in the i -th building.\n\nIt is guaranteed that, for all tests given to your program, there exists a\nvalid itinerary.\n\nOutput\n\nIn the first line print an integer l — the number of operations in your chosen\nitinerary.\n\nThe i -th (1 \\leq i \\leq l ) of the next l lines must contain one of three\ncommands:\n\n  1. \\texttt{DRIVE } x — go to the building with the number x (1 \\leq x \\leq n ); \n  2. \\texttt{PICKUP} — pick up the professor which was initially at the current building; \n  3. \\texttt{DROPOFF} — drop off the passenger professor at the current building. \n\nIn order for the itinerary to be valid, the following conditions must hold:\n\n  1. No two \\texttt{DRIVE} instructions should go to the same building; \n  2. At most one \\texttt{DROPOFF} and one \\texttt{PICKUP} instruction in this order should be issued at each specific building; \n  3. For all \\texttt{PICKUP} instructions, there must be a professor initially at the building, as well as no one already riding along on the scooter; \n  4. For all \\texttt{DROPOFF} instructions, there must be a professor riding along at the time of the command; \n  5. After the itinerary, in each building, if there is a class in that building, there must be a professor expert in the class' subject (either initially, or because they were dropped off there). \n\nNote that, in particular, you cannot pick up a professor that you just dropped\noff for an itinerary to be valid.\n\nExamples\n\nInput\n\n    3\n    \n    CM-\n    \n    -CM\n\nOutput\n\n    7\n    DRIVE 3\n    PICKUP\n    DRIVE 2\n    DROPOFF\n    PICKUP\n    DRIVE 1\n    DROPOFF\n    \nInput\n\n    1\n    \n    C\n    \n    C\n\nOutput\n\n    0\n    \nInput\n\n    2\n    \n    -M\n    \n    MC\n\nOutput\n\n    4\n    DRIVE 1\n    PICKUP\n    DRIVE 2\n    DROPOFF\n\nNote\n\nIn the first sample, You start by driving to building number 3 . You then pick\nup the mathematics professor. After dropping him off at building number 2 ,\nwhere a mathematics class is being held, you pick up the computer science\nprofessor from there, and drop her off at building number 1 , finishing your\nitinerary.",
        "task_name": "1949-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "n = int(input())\nc = input().strip()\np = input().strip()\n\nP_move = {'M': [], 'C': []}  # Professors to move\nC_need = {'M': [], 'C': []}  # Classes needing a professor\nSwap_buildings = []  # Buildings where we can swap professors\n\nfor i in range(n):\n    c_i = c[i]\n    p_i = p[i]\n    building = i + 1  # Buildings are 1-indexed\n\n    if c_i == p_i and c_i != '-':\n        continue  # Professor is already at the right place\n\n    if c_i != '-' and p_i != c_i:\n        if p_i != '-':\n            # Need to swap professors at this building\n            Swap_buildings.append((building, p_i, c_i))\n        else:\n            # Need to bring in a professor\n            C_need[c_i].append(building)\n    elif c_i == '-' and p_i != '-':\n        # Need to move professor away\n        P_move[p_i].append(building)\n    elif c_i != '-' and p_i == '-':\n        # Need to bring in a professor\n        C_need[c_i].append(building)\n\n# Now, match professors to classes\nplan = []\ncurrent_location = None\ncarrying = None\nvisited = set()\n\n# Handle swaps first\nfor building, prof_exp, class_exp in Swap_buildings:\n    if carrying is None:\n        # Need to pick up a professor to bring here\n        if P_move[class_exp]:\n            pickup_building = P_move[class_exp].pop()\n            if current_location != pickup_building:\n                plan.append(f'DRIVE {pickup_building}')\n                current_location = pickup_building\n            plan.append('PICKUP')\n            carrying = class_exp\n        else:\n            # No professor to bring here, should not happen\n            pass\n    if current_location != building:\n        plan.append(f'DRIVE {building}')\n        current_location = building\n    plan.append('DROPOFF')\n    carrying = None  # Dropped off professor\n    plan.append('PICKUP')\n    carrying = prof_exp  # Picked up professor to move away\n    visited.add(building)\n\n# Now handle remaining professors to move\nfor exp in ['M', 'C']:\n    while P_move[exp]:\n        pickup_building = P_move[exp].pop()\n        if current_location != pickup_building:\n            plan.append(f'DRIVE {pickup_building}')\n            current_location = pickup_building\n        if carrying is None:\n            plan.append('PICKUP')\n            carrying = exp\n        # Find a class needing this professor\n        if C_need[exp]:\n            dropoff_building = C_need[exp].pop()\n            if current_location != dropoff_building:\n                plan.append(f'DRIVE {dropoff_building}')\n                current_location = dropoff_building\n            plan.append('DROPOFF')\n            carrying = None\n        else:\n            # No class needing this professor, should not happen\n            pass\n\n# In case we are still carrying someone, try to drop them off\nfor exp in ['M', 'C']:\n    while C_need[exp]:\n        if carrying is None and P_move[exp]:\n            # Pick up a professor\n            pickup_building = P_move[exp].pop()\n            if current_location != pickup_building:\n                plan.append(f'DRIVE {pickup_building}')\n                current_location = pickup_building\n            plan.append('PICKUP')\n            carrying = exp\n        dropoff_building = C_need[exp].pop()\n        if current_location != dropoff_building:\n            plan.append(f'DRIVE {dropoff_building}')\n            current_location = dropoff_building\n        plan.append('DROPOFF')\n        carrying = None\n\nprint(len(plan))\nfor cmd in plan:\n    print(cmd)",
        "correct": false,
        "task_id": 237
    },
    {
        "description": "[The HU - Shireg Shireg](https://youtu.be/SNCx4n2m5_o)\n\nඞ\n\nThere are n cows participating in a coding tournament. Cow i has a Cowdeforces\nrating of a_i (all distinct), and is initially in position i . The tournament\nconsists of n-1 matches as follows:\n\n  * The first match is between the cow in position 1 and the cow in position 2 . \n  * Subsequently, each match i is between the cow in position i+1 and the winner of match i-1 . \n  * In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match. \n\nYou are the owner of cow k . For you, winning the tournament is not important;\nrather, you want your cow to win in as many matches as possible. As an\nacquaintance of the tournament organizers, you can ask them to swap the\nposition of your cow with another cow only once, or you can choose to do\nnothing.\n\nFind the maximum number of wins your cow can achieve.\n\nInput\n\nEach test contains multiple test cases. The first line contains an integer t\n(1 \\le t \\le 10^4 ) — the number of test cases. The description of the test\ncases follows.\n\nThe first line of each test case contains two integers n and k (2 \\le n \\le\n10^5, 1 \\le k \\le n ) — the number of cows and your cow's index.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^9 ) — the Cowdeforces rating of the cows. It is guaranteed that\na_i 's are pairwise different.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, print one integer: the maximum number of wins cow k can\nachieve if you choose to swap (or do nothing) optimally.\n\nExample\n\nInput\n\n    3\n    \n    6 1\n    \n    12 10 14 11 8 3\n    \n    6 5\n    \n    7 2 727 10 12 13\n    \n    2 2\n    \n    1000000000 1\n\nOutput\n\n    1\n    2\n    0\n    \nNote\n\nIn the first test case, it is optimal to do nothing. Let a' be the Cowdeforces\nrating of the cows in the original order (with your cow's rating bolded), then\n\n  * Initially, a' = [\\mathbf{12}, 10, 14, 11, 8, 3] . \n  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\\mathbf{12}, 14, 11, 8, 3] . \n  * Your cow plays against the cow with Cowdeforces rating 14 and loses. \n\nIn total, your cow wins 1 match.\n\nIn the second test case, it is optimal to swap your cow to position 3 . Then,\nlet a' be the Cowdeforces rating of the cows in the order after the swap.\n\n  * Initially, a' = [7, 2, \\mathbf{12}, 10, 727, 13] . \n  * The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, \\mathbf{12}, 10, 727, 13] . \n  * The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [\\mathbf{12}, 10, 727, 13] . \n  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\\mathbf{12}, 727, 13] . \n  * Your cow plays against the cow with Cowdeforces rating 727 and loses. \n\nIn total, your cow wins 2 matches.",
        "task_name": "1951-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def read_tests():\n\tdata = input()\n\treturn int(data)\n\ndef read_one_test():\n\tdata = input()\n\tdata_splitted = data.split()\n\n\tcows, my_cow_pos = int(data_splitted[0]), int(data_splitted[1])\n\n\tratings_line = input()\n\tratings = []\t\n\n\tfor rating in ratings_line.split():\n\t\tratings.append(int(rating))\n\n\treturn (my_cow_pos - 1, ratings)\n\ndef find_higher_ratings(ratings, my_rating_idx):\n\tratings_len = len(ratings)\n\tmy_rating = ratings[my_rating_idx]\n\tfirst_higher_idx = None\n\tsecond_higher_idx = None\n\n\tfor i in range(ratings_len):\n\t\tif (ratings[i] > my_rating):\n\t\t\tif first_higher_idx is None:\n\t\t\t\tfirst_higher_idx = i\n\t\t\telse:\n\t\t\t\tsecond_higher_idx = i\n\t\t\t\tbreak\n\n\treturn (first_higher_idx, second_higher_idx)\n\ndef count_wins(my_idx, first_higher_idx, second_higher_idx, ratings_len):\n\tif first_higher_idx is None and second_higher_idx is None:\n\t\treturn ratings_len - 1\n\telse:\n\t\tif first_higher_idx < my_idx:\n\t\t\t# check swap with beggining or with higher rating\n\t\t\twins_before_first = first_higher_idx - 1\n\t\t\twins_after_first = None\n\t\t\tif second_higher_idx is not None:\n\t\t\t\tif second_higher_idx < my_idx:\n\t\t\t\t\t# wins between first and second higher ratings\n\t\t\t\t\twins_after_first = second_higher_idx - first_higher_idx\n\t\t\t\telse:\n\t\t\t\t\t# wins between initial first higher rating and my rating\n\t\t\t\t\twins_after_first = my_idx - first_higher_idx\n\t\t\telse:\n\n\t\t\t\twins_after_first = my_idx - first_higher_idx\n\n\t\t\tif first_higher_idx == 0:\n\t\t\t\twins_after_first -= 1\n\n\t\t\treturn max(wins_before_first, wins_after_first)\n\t\telse:\n\t\t\t#swap with beggining\n\t\t\treturn first_higher_idx - 1\n\n\ntests_num = read_tests()\n\nfor i in range(tests_num):\n\tmy_idx, ratings = read_one_test()\n\tfirst_idx, second_idx = find_higher_ratings(ratings, my_idx)\n\tbest_case = count_wins(my_idx, first_idx, second_idx, len(ratings))\n\tprint(best_case)",
        "correct": true,
        "task_id": 153
    },
    {
        "description": "Once, the people, elves, dwarves, and other inhabitants of Middle-earth\ngathered to reclaim the treasures stolen from them by Smaug. In the name of\nthis great goal, they rallied around the powerful elf Timothy and began to\nplan the overthrow of the ruler of the Lonely Mountain.\n\nThe army of Middle-earth inhabitants will consist of several squads. It is\nknown that each pair of creatures of the same race, which are in different\nsquads, adds b units to the total strength of the army. But since it will be\ndifficult for Timothy to lead an army consisting of a large number of squads,\nthe total strength of an army consisting of k squads is reduced by (k - 1)\n\\cdot x units. Note that the army always consists of at least one squad.\n\nIt is known that there are n races in Middle-earth, and the number of\ncreatures of the i -th race is equal to c_i . Help the inhabitants of Middle-\nearth determine the maximum strength of the army they can assemble.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 2 \\cdot 10^4 ) — the number of test cases. The\ndescription of the test cases follows.\n\nThe first line of each test case contains three integers n , b , and x (1 \\le\nn \\le 2 \\cdot 10^5 , 1 \\le b \\le 10^6, 0 \\le x \\le 10^9 ) — the number of\nraces and the constants b and x described above.\n\nThe second line of each test case contains n integers c_1, c_2, \\ldots, c_n (1\n\\le c_i \\le 2 \\cdot 10^5 ) — the number of creatures of each of the n races.\n\nIt is guaranteed that the sum of the values c_1 + c_2 + \\ldots + c_n over all\ntest cases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the maximum strength of the army\nthat the inhabitants of Middle-earth can assemble.\n\nExample\n\nInput\n\n    5\n    \n    3 1 0\n    \n    1 2 3\n    \n    3 5 10\n    \n    2 5 3\n    \n    4 3 3\n    \n    3 2 1 2\n    \n    4 1 0\n    \n    4 1 4 2\n    \n    4 1 10\n    \n    4 1 4 2\n\nOutput\n\n    4\n    40\n    9\n    13\n    0\n    \nNote\n\nIn the first test case, the inhabitants of Middle-earth can form 3 squads.\nSince x = 0 , the army's strength will not decrease due to the number of\nsquads. The inhabitants can be distributed among the squads as follows:\n\n  * The single representative of the first species can be sent to the first squad.\n  * The first representative of the second species can be sent to the first squad, the second representative of the second species can be sent to the second squad. Then the total strength of the army will increase by b = 1 .\n  * The first representative of the third species can be sent to the first squad, the second representative of the third species can be sent to the second squad, the third representative of the third species can be sent to the third squad. Then the total strength of the army will increase by 3 \\cdot b = 3 , as they form three pairs in different squads.\n\nThus, the total strength of the army is 4 .\n\nIn the second test case, the inhabitants of Middle-earth can form 3 squads.\nSince x = 10 , the army's strength will decrease by 20 . The inhabitants can\nbe distributed among the squads as follows:\n\n  * The first representative of the first species can be sent to the first squad, the second representative of the first species can be sent to the second squad. Then the total strength of the army will increase by b = 5 .\n  * The first and second representatives of the second species can be sent to the first squad, the third and fourth representatives of the second species can be sent to the second squad, the fifth representative of the second species can be sent to the third squad. Then the total strength of the army will increase by 8 \\cdot b = 40 .\n  * The first representative of the third species can be sent to the first squad, the second representative of the third species can be sent to the second squad, the third representative of the third species can be sent to the third squad. Then the total strength of the army will increase by 3 \\cdot b = 15 , as they form three pairs in different squads.\n\nThus, the total strength of the army is 5 + 40 + 15 - 20 = 40 .",
        "task_name": "1928-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\ninput = sys.stdin.readline\ndef give_pairs(x, slots):\n    mult = x // slots\n    rem = x % slots\n    first = slots - rem\n    ans = ((2 * (x - mult) + ((first-1) * (-mult))) / 2) * first * mult\n    ans += ((2 * (mult + 1) + (slots - first - 2) * (mult+1)) / 2) * (slots - first - 1) * (mult+1)\n\n    return int(ans)\n\ndef get_val(n, arr, slots):\n    ans1 = 0\n    ans2 = 0\n    for i in range(n):\n        ans1 += give_pairs(arr[i], min(slots, arr[i]))\n        ans2 += give_pairs(arr[i], min(slots + 1, arr[i]))\n    return ans1, ans2\n\n\n# print(give_pairs(2, 2))\ndef solve():\n    n, b, x = map(int, input().split())\n    arr = list(map(int, input().split()))\n\n    maxi = -1\n    squares = 0\n    for i in range(n):\n        squares += (arr[i] ** 2)\n        maxi = max(maxi, arr[i])\n    new_maxi = 0\n    ind = 1\n    for i in range(1, maxi+1):\n        if b * squares * (i-1) / (2 * i) - (i-1) * x > new_maxi:\n            new_maxi = b * squares * (i-1) / (2 * i) - (i-1) * x\n            ind = i\n    # print(\"TEST\")\n    # print(new_maxi)\n    # print(ind)\n    if ind == 1:\n        ans1, ans2 = get_val(n, arr, 1)\n        print(max(0, b * ans2 - x))\n        return\n    ans1, ans2 = get_val(n, arr, ind-1)\n    ans2, ans3 = get_val(n, arr, ind)\n    print(max(ans1 * b - (ind - 2) * x, ans2 * b - (ind - 1) * x, ans3 * b - ind * x))\n\n\nfor t in range(int(input())):\n    solve()",
        "correct": false,
        "task_id": 58
    },
    {
        "description": "Vladislav has a playlist consisting of n songs, numbered from 1 to n . Song i\nhas genre g_i and writer w_i . He wants to make a playlist in such a way that\nevery pair of adjacent songs either have the same writer or are from the same\ngenre (or both). He calls such a playlist exciting. Both g_i and w_i are\nstrings of length no more than 10^4 .\n\nIt might not always be possible to make an exciting playlist using all the\nsongs, so the shuffling process occurs in two steps. First, some amount\n(possibly zero) of the songs are removed, and then the remaining songs in the\nplaylist are rearranged to make it exciting.\n\nSince Vladislav doesn't like when songs get removed from his playlist, he\nwants the making playlist to perform as few removals as possible. Help him\nfind the minimum number of removals that need to be performed in order to be\nable to rearrange the rest of the songs to make the playlist exciting.\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 1000 ) —\nthe number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 16 )\n— the number of songs in the original playlist.\n\nThen n lines follow, the i -th of which contains two strings of lowercase\nletters g_i and w_i (1 \\leq |g_i|, |w_i| \\leq 10^4 ) — the genre and the\nwriter of the i -th song. Where |g_i| and |w_i| are lengths of the strings.\n\nThe sum of 2^n over all test cases does not exceed 2^{16} .\n\nThe sum of |g_i| + |w_i| over all test cases does not exceed 4 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the minimum number of removals\nnecessary so that the resulting playlist can be made exciting.\n\nExample\n\nInput\n\n    4\n    \n    1\n    \n    pop taylorswift\n    \n    4\n    \n    electronic themotans\n    \n    electronic carlasdreams\n    \n    pop themotans\n    \n    pop irinarimes\n    \n    7\n    \n    rap eminem\n    \n    rap drdre\n    \n    rap kanyewest\n    \n    pop taylorswift\n    \n    indierock arcticmonkeys\n    \n    indierock arcticmonkeys\n    \n    punkrock theoffspring\n    \n    4\n    \n    a b\n    \n    c d\n    \n    e f\n    \n    g h\n\nOutput\n\n    0\n    0\n    4\n    3\n    \nNote\n\nIn the first test case, the playlist is already exciting.\n\nIn the second test case, if you have the songs in the order 4, 3, 1, 2 , it is\nexciting, so you don't need to remove any songs.\n\nIn the third test case, you can remove songs 4, 5, 6, 7 . Then the playlist\nwith songs in the order 1, 2, 3 is exciting.",
        "task_name": "1950-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def is_exciting(playlist):\n    n = len(playlist)\n    for i in range(n - 1):\n        if playlist[i][0] != playlist[i + 1][0] and playlist[i][1] != playlist[i + 1][1]:\n            return False\n    return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        songs = []\n        for _ in range(n):\n            g, w = data[index].split()\n            songs.append((g, w))\n            index += 1\n        \n        max_size = 0\n        # Check all subsets\n        for mask in range(1 << n):\n            subset = [songs[i] for i in range(n) if (mask & (1 << i))]\n            if is_exciting(subset):\n                max_size = max(max_size, len(subset))\n        \n        # Minimum removals is n - size of largest exciting subset\n        results.append(n - max_size)\n    \n    for result in results:\n        print(result)",
        "correct": false,
        "task_id": 177
    },
    {
        "description": "Jayden has an array a which is initially empty. There are n operations of two\ntypes he must perform in the given order.\n\n  1. Jayden appends an integer x (1 \\leq x \\leq n ) to the end of array a . \n  2. Jayden appends x copies of array a to the end of array a . In other words, array a becomes [a,\\underbrace{a,\\ldots,a}_{x}] . It is guaranteed that he has done at least one operation of the first type before this. \n\nJayden has q queries. For each query, you must tell him the k -th element of\narray a . The elements of the array are numbered from 1 .\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 5000 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains two integers n and q (1 \\leq n, q\n\\leq 10^5 ) — the number of operations and the number of queries.\n\nThe following n lines describe the operations. Each line contains two integers\nb and x (b \\in \\\\{1, 2\\\\} ), where b denotes the type of operation. If b=1 ,\nthen x (1 \\leq x \\leq n ) is the integer Jayden appends to the end of the\narray. If b=2 , then x (1 \\leq x \\leq 10^9 ) is the number of copies Jayden\nappends to the end of the array.\n\nThe next line of each test case contains q integers k_1, k_2, \\ldots, k_q (1\n\\leq k_i \\leq \\min(10^{18}, c) ), which denote the queries, where c is the\nsize of the array after finishing all n operations.\n\nIt is guaranteed that the sum of n and the sum of q over all test cases does\nnot exceed 10^5 .\n\nOutput\n\nFor each test case, output q integers — answers to Jayden's queries.\n\nExample\n\nInput\n\n    4\n    \n    5 10\n    \n    1 1\n    \n    1 2\n    \n    2 1\n    \n    1 3\n    \n    2 3\n    \n    1 2 3 4 5 6 14 15 16 20\n    \n    10 10\n    \n    1 3\n    \n    1 8\n    \n    2 15\n    \n    1 6\n    \n    1 9\n    \n    1 1\n    \n    2 6\n    \n    1 1\n    \n    2 12\n    \n    2 10\n    \n    32752 25178 3198 3199 2460 2461 31450 33260 9016 4996\n    \n    12 5\n    \n    1 6\n    \n    1 11\n    \n    2 392130334\n    \n    1 4\n    \n    2 744811750\n    \n    1 10\n    \n    1 5\n    \n    2 209373780\n    \n    2 178928984\n    \n    1 3\n    \n    2 658326464\n    \n    2 1000000000\n    \n    914576963034536490 640707385283752918 636773368365261971 584126563607944922 1000000000000000000\n    \n    2 2\n    \n    1 1\n    \n    1 2\n    \n    1 2\n\nOutput\n\n    1 2 1 2 3 1 2 3 1 3\n    9 8 1 3 1 3 6 3 8 8\n    11 11 11 10 11\n    1 2\n    \nNote\n\nIn the first test case:\n\n  * After the first operation a = [1] ;\n  * After the second operation a = [1, 2] ;\n  * After the third operation a = [1, 2, 1, 2] ;\n  * After the fourth operation a = [1, 2, 1, 2, 3] ;\n  * After the fifth operation a = [1, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 1, 2, 3] .\n\nIn the fourth test case, after all operations a = [1, 2] .",
        "task_name": "1920-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "# Function to resolve the k-th element query\ndef resolve_query(x):\n    x = int(x)  # Convert the query index to an integer\n    if x in b:\n        return b[x]  # If the index is already in the dictionary, return the value\n    # Iterate over the operations in reverse order\n    for i in a:\n        # Calculate the effective index in the original array\n        x = (x - 1) % i + 1\n        if x in b:\n            return b[x]  # Return the value if found in the dictionary\n\n# Read the number of test cases\nfor _ in range(int(input())):\n    a = [0]  # Initialize the list to store the size of the array after each operation\n    b = {}   # Dictionary to map indices to their values in the array\n    c, d = map(int, input().split())  # Read the number of operations and queries\n\n    # Process each operation\n    for i in range(c):\n        d, e = map(int, input().split())  # Read the operation type and the integer x\n        if a[-1] > 10**19:\n            continue  # Skip if the size of the array exceeds 10^19\n        if d & 1:  # If the operation type is 1 (append integer x)\n            a[-1] += 1  # Increment the size of the array\n            b[a[-1]] = e  # Map the new index to the integer x\n        else:  # If the operation type is 2 (append x copies of the array)\n            a.append(a[-1] * (e + 1))  # Update the size of the array\n\n    a = a[::-1]  # Reverse the list to process operations in reverse order\n    # Read the queries, resolve each query, and print the results\n    print(str(list(map(resolve_query, input().split())))[1:-1].replace(',', ''))",
        "correct": true,
        "task_id": 109
    },
    {
        "description": "You can never buy enough happiness, so here we go again! In this version, you\ncan only buy h_i = 1 unit of happiness each month, but the number of months is\nhugely increased. We are in the realm of quantum happiness and time dilation.\n\nBeing a physicist, Charlie likes to plan his life in simple and precise terms.\n\nFor the next m months, starting with no money, Charlie will work hard and earn\nx pounds per month. For the i -th month (1 \\le i \\le m) , there'll be a single\nopportunity of paying cost c_i pounds to obtain one unit of happiness. You\ncannot buy more than one unit each month.\n\nBorrowing is not allowed. Money earned in the i -th month can only be spent in\na later j -th month (j>i ).\n\nSince physicists don't code, help Charlie find the maximum reachable units of\nhappiness.\n\nInput\n\nThe first line of the input contains t (1 \\leq t \\leq 10^4 ) — the number of\ntest cases.\n\nThe first line of each test case contains two integers, m and x (1 \\le m \\le 2\n\\cdot 10^5 , 1 \\le x \\le 10^3 ) — the total number of months and the monthly\nsalary.\n\nThe second line of each test case contains m integers c_1, c_2, \\dots, c_m (1\n\\leq c_i \\leq 10^3 ) — the cost of one unit of happiness for each month.\n\nIt is guaranteed that sum of m over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output one integer — the maximal amount of happiness\nCharlie can get.\n\nExample\n\nInput\n\n    6\n    \n    3 3\n    \n    2 2 2\n    \n    6 5\n    \n    2 2 8 2 6 8\n    \n    6 4\n    \n    4 10 3 8 6 10\n    \n    2 1\n    \n    1 1\n    \n    4 1\n    \n    4 1 3 1\n    \n    4 2\n    \n    1 3 4 3\n\nOutput\n\n    2\n    4\n    3\n    1\n    2\n    1",
        "task_name": "1974-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import heapq\nrs=[]\nfor _ in range(int(input())):\n    n,m = map(int,input().split())\n    l=list(map(int,input().split()))\n    mx=0;s=0\n    cnt=0\n    h=[]\n    for i in range(n):\n        if s>=l[i]:\n            s-=l[i]\n            heapq.heappush(h,-l[i])\n            cnt+=1\n            mx=max(mx,cnt)\n        else:\n            if h:\n                if l[i]<abs(h[0]):\n                    s+=abs(h[0])-l[i]\n                    heapq.heappop(h)\n                    heapq.heappush(h,-l[i])\n        s+=m                    \n\n\n    rs.append(cnt)\nprint(*rs,sep=\"\\n\")",
        "correct": true,
        "task_id": 69
    },
    {
        "description": "This is the hard version of the problem. In this version l\\le r .\n\nYou are given a string s . For a fixed k , consider a division of s into\nexactly k continuous substrings w_1,\\dots,w_k . Let f_k be the maximal\npossible LCP(w_1,\\dots,w_k) among all divisions.\n\nLCP(w_1,\\dots,w_m) is the length of the Longest Common Prefix of the strings\nw_1,\\dots,w_m .\n\nFor example, if s=abababcab and k=4 , a possible division is\n\\color{red}{ab}\\color{blue}{ab}\\color{orange}{abc}\\color{green}{ab} . The\nLCP(\\color{red}{ab},\\color{blue}{ab},\\color{orange}{abc},\\color{green}{ab}) is\n2 , since ab is the Longest Common Prefix of those four strings. Note that\neach substring consists of a continuous segment of characters and each\ncharacter belongs to exactly one substring.\n\nYour task is to find f_l,f_{l+1},\\dots,f_r .\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntest cases.\n\nThe first line of each test case contains two integers n , l , r (1 \\le l \\le\nr \\le n \\le 2 \\cdot 10^5 ) — the length of the string and the given range.\n\nThe second line of each test case contains string s of length n , all\ncharacters are lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, output r-l+1 values: f_l,\\dots,f_r .\n\nExample\n\nInput\n\n    7\n    \n    3 1 3\n    \n    aba\n    \n    3 2 3\n    \n    aaa\n    \n    7 1 5\n    \n    abacaba\n    \n    9 1 6\n    \n    abababcab\n    \n    10 1 10\n    \n    aaaaaaawac\n    \n    9 1 9\n    \n    abafababa\n    \n    7 2 7\n    \n    vvzvvvv\n\nOutput\n\n    3 1 0 \n    1 1 \n    7 3 1 1 0 \n    9 2 2 2 0 0 \n    10 3 2 1 1 1 1 1 0 0 \n    9 3 2 1 1 0 0 0 0 \n    2 2 1 1 1 0",
        "task_name": "1968-G2",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def lcp_prefix(a, b):\n    # Esta função calcula o comprimento do prefixo comum mais longo entre as strings a e b\n    i = 0\n    while i < len(a) and i < len(b) and a[i] == b[i]:\n        i += 1\n    return i\n\ndef compute_max_lcp_for_k(s, k):\n    n = len(s)\n    max_lcp = 0\n    # Dividir a string em k substrings\n    chunk_size = n // k\n    for i in range(k):\n        # Gerar as substrings para essa divisão\n        start = i * chunk_size\n        end = start + chunk_size if i != k - 1 else n\n        substrings = [s[start:end]]\n        # Calcular o máximo LCP para a divisão da string\n        lcp_value = 0\n        for j in range(i + 1, k):\n            next_start = j * chunk_size\n            next_end = next_start + chunk_size if j != k - 1 else n\n            lcp_value = max(lcp_value, lcp_prefix(substrings[-1], s[next_start:next_end]))\n        max_lcp = max(max_lcp, lcp_value)\n    return max_lcp\n\n# Leitura de entrada\nt = int(input())  # Número de casos de teste\nfor _ in range(t):\n    # Leitura dos parâmetros para cada caso de teste\n    n, l, r = map(int, input().split())\n    s = input().strip()\n\n    # Para cada k no intervalo [l, r], calcula o valor de f_k\n    results = []\n    for k in range(l, r + 1):\n        results.append(compute_max_lcp_for_k(s, k))\n\n    # Imprimir os resultados para este caso de teste\n    print(\" \".join(map(str, results)))",
        "correct": false,
        "task_id": 185
    },
    {
        "description": "The only difference between the two versions of this problem is the constraint\non q . You can make hacks only if both versions of the problem are solved.\n\nThomas is sailing around an island surrounded by the ocean. The ocean and\nisland can be represented by a grid with n rows and m columns. The rows are\nnumbered from 1 to n from top to bottom, and the columns are numbered from 1\nto m from left to right. The position of a cell at row r and column c can be\nrepresented as (r, c) . Below is an example of a valid grid.\n\n![](https://espresso.codeforces.com/95bf34ca1201ffd49c650e2eab82db74ca137561.png)\nExample of a valid grid\n\nThere are three types of cells: island, ocean and underwater volcano. Cells\nrepresenting the island are marked with a '#', cells representing the ocean\nare marked with a '.', and cells representing an underwater volcano are marked\nwith a 'v'. It is guaranteed that there is at least one island cell and at\nleast one underwater volcano cell. It is also guaranteed that the set of all\nisland cells forms a single connected component^{\\dagger} and the set of all\nocean cells and underwater volcano cells forms a single connected component.\nAdditionally, it is guaranteed that there are no island cells at the edge of\nthe grid (that is, at row 1 , at row n , at column 1 , and at column m ).\n\nDefine a round trip starting from cell (x, y) as a path Thomas takes which\nsatisfies the following conditions:\n\n  * The path starts and ends at (x, y) . \n  * If Thomas is at cell (i, j) , he can go to cells (i+1, j) , (i-1, j) , (i, j-1) , and (i, j+1) as long as the destination cell is an ocean cell or an underwater volcano cell and is still inside the grid. Note that it is allowed for Thomas to visit the same cell multiple times in the same round trip. \n  * The path must go around the island and fully encircle it. Some path p fully encircles the island if it is impossible to go from an island cell to a cell on the grid border by only traveling to adjacent on a side or diagonal cells without visiting a cell on path p . In the image below, the path starting from (2, 2) , going to (1, 3) , and going back to (2, 2) the other way does not fully encircle the island and is not considered a round trip. \n\n![](https://espresso.codeforces.com/fbd907724a3f8d94b6d6922444a30df89276270c.png)\nExample of a path that does not fully encircle the island\n\nThe safety of a round trip is the minimum Manhattan distance^{\\ddagger} from a\ncell on the round trip to an underwater volcano (note that the presence of\nisland cells does not impact this distance).\n\nYou have q queries. A query can be represented as (x, y) and for every query,\nyou want to find the maximum safety of a round trip starting from (x, y) . It\nis guaranteed that (x, y) is an ocean cell or an underwater volcano cell.\n\n^{\\dagger} A set of cells forms a single connected component if from any cell\nof this set it is possible to reach any other cell of this set by moving only\nthrough the cells of this set, each time going to a cell with a common side.\n\n^{\\ddagger} Manhattan distance between cells (r_1, c_1) and (r_2, c_2) is\nequal to |r_1 - r_2| + |c_1 - c_2| .\n\nInput\n\nThe first line contains three integers n , m , and q (3 \\leq n, m \\leq 10^5 ,\n9 \\leq n \\cdot m \\leq 3 \\cdot 10^5 , 1 \\leq q \\leq 5 ) — the number of rows\nand columns of the grid and the number of queries.\n\nEach of the following n lines contains m characters describing the cells of\nthe grid. The character '#' denotes an island cell, '.' denotes an ocean cell,\nand 'v' denotes an underwater volcano cell.\n\nIt is guaranteed that there is at least one island cell and at least one\nunderwater volcano cell. It is guaranteed that the set of all island cells\nforms a single connected component and the set of all ocean cells and\nunderwater volcano cells forms a single connected component. Also, it is\nguaranteed that there are no island cells at the edge of the grid (that is, at\nthe row 1 , at the row n , at the column 1 , and at the column m ).\n\nThe following q lines describe the queries. Each of these lines contains two\nintegers x and y (1 \\leq x \\leq n , 1 \\leq y \\leq m ) denoting a round trip\nstarting from (x, y) .\n\nIt is guaranteed that (x, y) is an ocean cell or an underwater volcano cell.\n\nOutput\n\nFor each query, output a single integer — the maximum safety of a round trip\nstarting from the specified position.\n\nExamples\n\nInput\n\n    9 9 3\n    .........\n    .........\n    ....###..\n    ...v#....\n    ..###....\n    ...##...v\n    ...##....\n    .........\n    v........\n    1 1\n    9 1\n    5 7\n    \nOutput\n\n    3\n    0\n    3\n    \nInput\n\n    3 3 5\n    ..v\n    .#.\n    ...\n    1 2\n    1 3\n    2 3\n    2 1\n    3 2\n    \nOutput\n\n    0\n    0\n    0\n    0\n    0\n    \nInput\n\n    14 13 5\n    .............\n    .............\n    .............\n    ...vvvvvvv...\n    ...v.....v...\n    ...v.###.v...\n    ...v.#.#.v...\n    ...v..v..v...\n    ...v..v..v...\n    ....v...v....\n    .....vvv.....\n    .............\n    .............\n    .............\n    1 1\n    7 7\n    5 6\n    4 10\n    13 6\n    \nOutput\n\n    3\n    0\n    1\n    0\n    2\n    \nInput\n\n    10 11 4\n    ...........\n    ..#######..\n    ..#..#..#..\n    ..#.....#..\n    ..#..v..#..\n    ..#.###.#..\n    ..#.#.#.#..\n    ..#...#.#..\n    ..#####.#..\n    ...........\n    7 6\n    3 7\n    6 8\n    1 1\n    \nOutput\n\n    1\n    2\n    3\n    4\n    \nNote\n\nFor the first example, the image below shows an optimal round trip starting\nfrom (1, 1) . The round trip has a safety of 3 as the minimum Manhattan\ndistance from a cell on the round trip to an underwater volcano is 3 .\n\n![](https://espresso.codeforces.com/28c264e0a3e6fbf65ddad506140619cb3bd3e6a0.png)\nExample of an optimal round trip\n\nFor the fourth example, remember that it is allowed for Thomas to visit the\nsame cell multiple times in the same round trip. For example, doing so is\nnecessary for the round trip starting from (7, 6) .",
        "task_name": "1920-F1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    q = int(data[index + 2])\n    index += 3\n    \n    grid = []\n    for _ in range(n):\n        grid.append(data[index])\n        index += 1\n    \n    queries = []\n    for _ in range(q):\n        x = int(data[index]) - 1\n        y = int(data[index + 1]) - 1\n        queries.append((x, y))\n        index += 2\n    \n    # Directions for moving in the grid\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Step 1: Find all volcano positions\n    volcanoes = []\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'v':\n                volcanoes.append((r, c))\n    \n    # Step 2: Calculate distance to nearest volcano for each cell\n    distance_to_volcano = [[float('inf')] * m for _ in range(n)]\n    queue = deque(volcanoes)\n    \n    for r, c in volcanoes:\n        distance_to_volcano[r][c] = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        current_distance = distance_to_volcano[r][c]\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] != '#' and distance_to_volcano[nr][nc] == float('inf'):\n                distance_to_volcano[nr][nc] = current_distance + 1\n                queue.append((nr, nc))\n    \n    # Step 3: Find the boundary of the island\n    island_boundary = set()\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == '#':\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == '.':\n                        island_boundary.add((nr, nc))\n    \n    # Step 4: For each query, calculate the maximum safety\n    results = []\n    for x, y in queries:\n        # We need to find the maximum safety of a round trip starting from (x, y)\n        # The safety is determined by the minimum distance to a volcano from the path\n        # that encircles the island.\n        \n        # Since the problem guarantees that the ocean and volcano cells form a single\n        # connected component, we can assume that any ocean cell can potentially be\n        # part of a valid round trip.\n        \n        # The maximum safety is the minimum distance to a volcano from the island boundary\n        max_safety = min(distance_to_volcano[r][c] for r, c in island_boundary)\n        \n        results.append(max_safety)\n    \n    # Output the results for each query\n    for result in results:\n        print(result)",
        "correct": false,
        "task_id": 108
    },
    {
        "description": "Petya has an array a_i of n integers. His brother Vasya became envious and\ndecided to make his own array of n integers.\n\nTo do this, he found m integers b_i (m\\ge n ), and now he wants to choose some\nn integers of them and arrange them in a certain order to obtain an array c_i\nof length n .\n\nTo avoid being similar to his brother, Vasya wants to make his array as\ndifferent as possible from Petya's array. Specifically, he wants the total\ndifference D = \\sum_{i=1}^{n} |a_i - c_i| to be as large as possible.\n\nHelp Vasya find the maximum difference D he can obtain.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 100 ) — the number of test cases. This is followed by a\ndescription of the test cases.\n\nThe first line of each test case contains two integers n and m (1\\le n\\le m\\le\n2 \\cdot 10^5 ).\n\nThe second line of each test case contains n integers a_i (1\\le a_i\\le 10^9 ).\nThe third line of each test case contains m integers b_i (1\\le b_i\\le 10^9 ).\n\nIt is guaranteed that in a test, the sum of m over all test cases does not\nexceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the maximum total difference D\nthat can be obtained.\n\nExample\n\nInput\n\n    9\n    \n    4 6\n    \n    6 1 2 4\n    \n    3 5 1 7 2 3\n    \n    3 4\n    \n    1 1 1\n    \n    1 1 1 1\n    \n    5 5\n    \n    1 2 3 4 5\n    \n    1 2 3 4 5\n    \n    2 6\n    \n    5 8\n    \n    8 7 5 8 2 10\n    \n    2 2\n    \n    4 1\n    \n    9 6\n    \n    4 6\n    \n    8 10 6 4\n    \n    3 10 6 1 8 9\n    \n    3 5\n    \n    6 5 2\n    \n    1 7 9 7 2\n    \n    5 5\n    \n    9 10 6 3 7\n    \n    5 9 2 3 9\n    \n    1 6\n    \n    3\n    \n    2 7 10 1 1 5\n\nOutput\n\n    16\n    0\n    12\n    11\n    10\n    23\n    15\n    25\n    7\n    \nNote\n\nIn the first example, Vasya can, for example, create the array (1, 5, 7, 2) .\nThen the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .\n\nIn the second example, all the integers available to Vasya are equal to 1, so\nhe can only create the array (1, 1, 1) , for which the difference D = 0 .\n\nIn the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)\n. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =\n4+2+0+2+4 = 12 .",
        "task_name": "1921-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t=int(input())\nfor _ in range(t):\n    n,m=map(int,input().split())\n    a=list(map(int,input().split()))\n    b=list(map(int,input().split()))\n    a.sort()\n    b.sort(reverse=True)\n    diff=0\n    for i in range(n):\n        diff+=max(abs(a[i]-b[i]),abs(a[i-n]-b[i-n]))\n    print(diff)",
        "correct": true,
        "task_id": 52
    },
    {
        "description": "Anton got bored during the hike and wanted to solve something. He asked Kirill\nif he had any new problems, and of course, Kirill had one.\n\nYou are given a permutation p of size n , and a number x that needs to be\nfound. A permutation of length n is an array consisting of n distinct integers\nfrom 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but\n[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is\nalso not a permutation (n=3 but there is 4 in the array).\n\nYou decided that you are a cool programmer, so you will use an advanced\nalgorithm for the search — binary search. However, you forgot that for binary\nsearch, the array must be sorted.\n\nYou did not give up and decided to apply this algorithm anyway, and in order\nto get the correct answer, you can perform the following operation no more\nthan 2 times before running the algorithm: choose the indices i , j (1\\le i, j\n\\le n ) and swap the elements at positions i and j .\n\nAfter that, the binary search is performed. At the beginning of the algorithm,\ntwo variables l = 1 and r = n + 1 are declared. Then the following loop is\nexecuted:\n\n  1. If r - l = 1 , end the loop \n  2. m = \\lfloor \\frac{r + l}{2} \\rfloor \n  3. If p_m \\le x , assign l = m , otherwise r = m . \n\nThe goal is to rearrange the numbers in the permutation before the algorithm\nso that after the algorithm is executed, p_l is equal to x . It can be shown\nthat 2 operations are always sufficient.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 2\\cdot 10^4 ) — the number of test cases. Then follow\nthe descriptions of the test cases.\n\nThe first line of each test case contains two integers n and x (1 \\le x \\le n\n\\le 2\\cdot 10^5 ) — the length of the permutation and the number to be found.\n\nThe second line contains the permutation p separated by spaces (1 \\le p_i \\le\nn ).\n\nIt is guaranteed that the sum of the values of n for all test cases does not\nexceed 2\\cdot 10^5 .\n\nOutput\n\nFor each test case, output an integer k (0 \\le k \\le 2 ) on the first line —\nthe number of operations performed by you. In the next k lines, output 2\nintegers i , j (1 \\le i, j \\le n ) separated by a space, indicating that you\nare swapping the elements at positions i and j .\n\nNote that you do not need to minimize the number of operations.\n\nExample\n\nInput\n\n    5\n    \n    6 3\n    \n    1 2 3 4 5 6\n    \n    6 5\n    \n    3 1 6 5 2 4\n    \n    5 1\n    \n    3 5 4 2 1\n    \n    6 3\n    \n    4 3 1 5 2 6\n    \n    3 2\n    \n    3 2 1\n\nOutput\n\n    0\n    1\n    3 4\n    2\n    2 4\n    1 5\n    2\n    4 5\n    2 4\n    1\n    1 3",
        "task_name": "1945-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "test=int(input())\nwhile test:\n    test-=1\n    n,x=map(int,input().split())\n    p=list(map(int,input().split()))\n    p=[0]+p\n    st=p.index(x)\n\n    l=1\n    r=n+1\n    while l+1<r:\n        m=(l+r)>>1\n        if p[m]<=x:\n            l=m\n        else:\n            r=m\n    if l==st:\n        print(0)\n    else:\n        print(1)\n        print(str(l)+' '+str(st))",
        "correct": true,
        "task_id": 98
    }
]