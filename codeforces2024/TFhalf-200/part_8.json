[
    {
        "description": "The Manhattan distance between two points (x_1, y_1) and (x_2, y_2) is defined\nas:\n\nWe call a Manhattan triangle three points on the plane, the Manhattan\ndistances between each pair of which are equal.\n\nYou are given a set of pairwise distinct points and an even integer d . Your\ntask is to find any Manhattan triangle, composed of three distinct points from\nthe given set, where the Manhattan distance between any pair of vertices is\nequal to d .\n\nInput\n\nEach test consists of multiple test cases. The first line contains one integer\nt (1 \\le t \\le 10^4 ) — the number of test cases. The description of the test\ncases follows.\n\nThe first line of each test case contains two integers n and d (3 \\le n \\le 2\n\\cdot 10^5 , 2 \\le d \\le 4 \\cdot 10^5 , d is even) — the number of points and\nthe required Manhattan distance between the vertices of the triangle.\n\nThe (i + 1) -th line of each test case contains two integers x_i and y_i\n(-10^5 \\le x_i, y_i \\le 10^5 ) — the coordinates of the i -th point. It is\nguaranteed that all points are pairwise distinct.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output three distinct integers i , j , and k (1 \\le i,j,k\n\\le n ) — the indices of the points forming the Manhattan triangle. If there\nis no solution, output \"0\\ 0\\ 0 \" (without quotes).\n\nIf there are multiple solutions, output any of them.\n\nExample\n\nInput\n\n    6\n    \n    6 4\n    \n    3 1\n    \n    0 0\n    \n    0 -2\n    \n    5 -3\n    \n    3 -5\n    \n    2 -2\n    \n    5 4\n    \n    0 0\n    \n    0 -2\n    \n    5 -3\n    \n    3 -5\n    \n    2 -2\n    \n    6 6\n    \n    3 1\n    \n    0 0\n    \n    0 -2\n    \n    5 -3\n    \n    3 -5\n    \n    2 -2\n    \n    4 4\n    \n    3 0\n    \n    0 3\n    \n    -3 0\n    \n    0 -3\n    \n    10 8\n    \n    2 1\n    \n    -5 -1\n    \n    -4 -1\n    \n    -5 -3\n    \n    0 1\n    \n    -2 5\n    \n    -4 4\n    \n    -4 2\n    \n    0 0\n    \n    -4 1\n    \n    4 400000\n    \n    100000 100000\n    \n    -100000 100000\n    \n    100000 -100000\n    \n    -100000 -100000\n\nOutput\n\n    2 6 1\n    4 3 5\n    3 5 1\n    0 0 0\n    6 1 3\n    0 0 0\n    \nNote\n\nIn the first test case:\n\n![](https://espresso.codeforces.com/95d384e2c55b5d679ef8c50bb080a9ef81b1883f.png)\nPoints A , B , and F form a Manhattan triangle, the Manhattan distance between\neach pair of vertices is 4 . Points D , E , and F can also be the answer.\n\nIn the third test case:\n\n![](https://espresso.codeforces.com/5a9cc2b1c543e498e971ab2b1fe23c03fbf3fbed.png)\nPoints A , C , and E form a Manhattan triangle, the Manhattan distance between\neach pair of vertices is 6 .\n\nIn the fourth test case, there are no two points with a Manhattan distance of\n4 , and therefore there is no suitable Manhattan triangle.",
        "task_name": "1979-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n  n, d = map(int, input().split())\n  X = [0 for _ in range(n)]\n  Y = [0 for _ in range(n)]\n  \n  for i in range(n):\n    x, y = map(int, input().split())\n    X[i], Y[i] = x - y, x + y\n    \n  for _ in range(2):\n    hach = {}\n    for i in range(n):\n      if X[i] not in hach:\n        hach[X[i]] = {}\n      hach[X[i]][Y[i]] = i\n    \n    for i in range(n):\n      x = X[i]\n      y = Y[i]\n      if y + d in hach.get(x, {}):\n        edge = hach[x][y + d]\n        for point in [x - d, x + d]:\n          if point in hach:\n            for key in sorted(hach[point]):\n              if y <= key <= y + d:\n                print(i + 1, edge + 1, hach[point][key] + 1)\n                return 0\n    X, Y = Y, X\n      \n  print(\"0 0 0\")\n \nfor _ in range(int(input())):\n  solve()",
        "correct": true,
        "task_id": 302
    },
    {
        "description": "You are given two integers n and k (k \\le n ), where k is even.\n\nA permutation of length n is an array consisting of n distinct integers from 1\nto n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is\nnot a permutation (as 2 appears twice in the array) and [0,1,2] is also not a\npermutation (as n=3 , but 3 is not present in the array).\n\nYour task is to construct a k -level permutation of length n .\n\nA permutation is called k -level if, among all the sums of continuous segments\nof length k (of which there are exactly n - k + 1 ), any two sums differ by no\nmore than 1 .\n\nMore formally, to determine if the permutation p is k -level, first construct\nan array s of length n - k + 1 , where s_i=\\sum_{j=i}^{i+k-1} p_j , i.e., the\ni -th element is equal to the sum of p_i, p_{i+1}, \\dots, p_{i+k-1} .\n\nA permutation is called k -level if \\max(s) - \\min(s) \\le 1 .\n\nFind any k -level permutation of length n .\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases. This is followed by the description of the test\ncases.\n\nThe first and only line of each test case contains two integers n and k (2 \\le\nk \\le n \\le 2 \\cdot 10^5 , k is even), where n is the length of the desired\npermutation.\n\nIt is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output any k -level permutation of length n .\n\nIt is guaranteed that such a permutation always exists given the constraints.\n\nExample\n\nInput\n\n    5\n    \n    2 2\n    \n    3 2\n    \n    10 4\n    \n    13 4\n    \n    7 4\n\nOutput\n\n    2 1\n    1 3 2\n    1 8 4 10 2 7 5 9 3 6\n    4 10 1 13 5 9 2 12 6 8 3 11 7\n    1 6 3 7 2 5 4\n    \nNote\n\nIn the second test case of the example:\n\n  * p_1 + p_2 = 3 + 1 = 4 ; \n  * p_2 + p_3 = 1 + 2 = 3 . \n\nThe maximum among the sums is 4 , and the minimum is 3 .",
        "task_name": "1927-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    n, k = map(int, input().split())\n    l, r = 1, n\n    ans = [0] * n\n    for i in range(k):\n        for j in range(i, n, k):\n            if i % 2 == 0:\n                ans[j] = l\n                l += 1\n            else:\n                ans[j] = r\n                r -= 1\n    print(*ans)\n    \n    \nfor _ in range(int(input())):\n    solve()",
        "correct": true,
        "task_id": 118
    },
    {
        "description": "A parentheses sequence is a string consisting of characters \"(\" and \")\", for\nexample \"(()((\".\n\nA balanced parentheses sequence is a parentheses sequence which can become a\nvalid mathematical expression after inserting numbers and operations into it,\nfor example \"(()(()))\".\n\nThe balance of a parentheses sequence is defined as the number of opening\nparentheses \"(\" minus the number of closing parentheses \")\". For example, the\nbalance of the sequence \"(()((\" is 3.\n\nA balanced parentheses sequence can also be defined as a parentheses sequence\nwith balance 0 such that each of its prefixes has a non-negative balance.\n\nWe define the balanced shuffle operation that takes a parentheses sequence and\nreturns a parentheses sequence as follows: first, for every character of the\ninput sequence, we compute the balance of the prefix of the sequence before\nthat character and write those down in a table together with the positions of\nthe characters in the input sequence, for example:\n\nPrefix balance| 0| 1| 2| 1| 2| 3| 2| 1  \n---|---|---|---|---|---|---|---|---  \nPosition| 1| 2| 3| 4| 5| 6| 7| 8  \nCharacter| (| (| )| (| (| )| )| )  \n  \nThen, we sort the columns of this table in increasing order of prefix balance,\nbreaking ties in decreasing order of position. In the above example, we get:\n\nPrefix balance| 0| 1| 1| 1| 2| 2| 2| 3  \n---|---|---|---|---|---|---|---|---  \nPosition| 1| 8| 4| 2| 7| 5| 3| 6  \nCharacter| (| )| (| (| )| (| )| )  \n  \nThe last row of this table forms another parentheses sequence, in this case\n\"()(()())\". This sequence is called the result of applying the balanced\nshuffle operation to the input sequence, or in short just the balanced shuffle\nof the input sequence.\n\nYou are given a balanced parentheses sequence. Print its balanced shuffle.\n\nInput\n\nThe only line of input contains a string s consisting only of characters \"(\"\nand \")\". This string is guaranteed to be a non-empty balanced parentheses\nsequence with its length not exceeding 500\\,000 .\n\nOutput\n\nPrint the parentheses sequence t — the balanced shuffle of s .\n\nExample\n\nInput\n\n    (()(()))\n    \nOutput\n\n    ()(()())",
        "task_name": "1970-A1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def balanced_shuffle(s):\n    n = len(s)\n    balance = 0\n    data = []\n\n    # Calculate prefix balances and store them with positions\n    for i, char in enumerate(s):\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        data.append((balance, -i, char))  # Use -i to sort positions in descending order\n\n    # Sort based on balance and position\n    data.sort()\n\n    # Build the shuffled sequence\n    result = ''.join(char for _, _, char in data)\n    return result\n\n# Input handling\ns = input().strip()\n\n# Compute and print the balanced shuffle\nprint(balanced_shuffle(s))",
        "correct": false,
        "task_id": 286
    },
    {
        "description": "You are at a dueling arena. You also possess n Pokémons. Initially, only the 1\n-st Pokémon is standing in the arena.\n\nEach Pokémon has m attributes. The j -th attribute of the i -th Pokémon is\na_{i,j} . Each Pokémon also has a cost to be hired: the i -th Pokémon's cost\nis c_i .\n\nYou want to have the n -th Pokémon stand in the arena. To do that, you can\nperform the following two types of operations any number of times in any\norder:\n\n  * Choose three integers i , j , k (1 \\le i \\le n , 1 \\le j \\le m , k > 0 ), increase a_{i,j} by k permanently. The cost of this operation is k . \n  * Choose two integers i , j (1 \\le i \\le n , 1 \\le j \\le m ) and hire the i -th Pokémon to duel with the current Pokémon in the arena based on the j -th attribute. The i -th Pokémon will win if a_{i,j} is greater than or equal to the j -th attribute of the current Pokémon in the arena (otherwise, it will lose). After the duel, only the winner will stand in the arena. The cost of this operation is c_i . \n\nFind the minimum cost you need to pay to have the n -th Pokémon stand in the\narena.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^5 ). The description of the test cases follows.\n\nThe first line of each test case contains two integers n and m (2 \\le n \\le 4\n\\cdot 10^5 , 1 \\le m \\le 2 \\cdot 10^5 , 2 \\leq n \\cdot m \\leq 4 \\cdot 10^5 ).\n\nThe second line of each test case contains n integers c_1, c_2, \\ldots, c_n (1\n\\le c_i \\le 10^9 ).\n\nThe i -th of the following n lines contains m integers a_{i,1}, a_{i,2},\n\\ldots, a_{i,m} (1 \\le a_{i,j} \\le 10^9 ).\n\nIt is guaranteed that the sum of n \\cdot m over all test cases does not exceed\n4 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output the minimum cost to make the n -th Pokémon stand in\nthe arena.\n\nExample\n\nInput\n\n    4\n    \n    3 3\n    \n    2 3 1\n    \n    2 9 9\n    \n    6 1 7\n    \n    1 2 1\n    \n    3 3\n    \n    2 3 1\n    \n    9 9 9\n    \n    6 1 7\n    \n    1 2 1\n    \n    4 2\n    \n    2 8 3 5\n    \n    18 24\n    \n    17 10\n    \n    1 10\n    \n    1 1\n    \n    6 3\n    \n    21412674 3212925 172015806 250849370 306960171 333018900\n    \n    950000001 950000001 950000001\n    \n    821757276 783362401 760000001\n    \n    570000001 700246226 600757652\n    \n    380000001 423513575 474035234\n    \n    315201473 300580025 287023445\n    \n    1 1 1\n\nOutput\n\n    2\n    6\n    17\n    1224474550\n    \nNote\n\nIn the first test case, the attribute array of the 1 -st Pokémon (which is\nstanding in the arena initially) is [2,9,9] .\n\nIn the first operation, you can choose i=3 , j=1 , k=1 , and increase a_{3,1}\nby 1 permanently. Now the attribute array of the 3 -rd Pokémon is [2,2,1] .\nThe cost of this operation is k = 1 .\n\nIn the second operation, you can choose i=3 , j=1 , and hire the 3 -rd Pokémon\nto duel with the current Pokémon in the arena based on the 1 -st attribute.\nSince a_{i,j}=a_{3,1}=2 \\ge 2=a_{1,1} , the 3 -rd Pokémon will win. The cost\nof this operation is c_3 = 1 .\n\nThus, we have made the 3 -rd Pokémon stand in the arena within the cost of 2 .\nIt can be proven that 2 is minimum possible.\n\nIn the second test case, the attribute array of the 1 -st Pokémon in the arena\nis [9,9,9] .\n\nIn the first operation, you can choose i=2 , j=3 , k=2 , and increase a_{2,3}\nby 2 permanently. Now the attribute array of the 2 -nd Pokémon is [6,1,9] .\nThe cost of this operation is k = 2 .\n\nIn the second operation, you can choose i=2 , j=3 , and hire the 2 -nd Pokémon\nto duel with the current Pokémon in the arena based on the 3 -rd attribute.\nSince a_{i,j}=a_{2,3}=9 \\ge 9=a_{1,3} , the 2 -nd Pokémon will win. The cost\nof this operation is c_2 = 3 .\n\nIn the third operation, you can choose i=3 , j=2 , and hire the 3 -rd Pokémon\nto duel with the current Pokémon in the arena based on the 2 -nd attribute.\nSince a_{i,j}=a_{1,2}=2 \\ge 1=a_{2,2} , the 3 -rd Pokémon can win. The cost of\nthis operation is c_3 = 1 .\n\nThus, we have made the 3 -rd Pokémon stand in the arena within the cost of 6 .\nIt can be proven that 6 is minimum possible.",
        "task_name": "1936-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections import *\nfrom heapq import *\nimport sys\n\ninput = sys.stdin.readline\nINF = 1 << 60  # A large number representing infinity\n\ndef dijkstra(start, edges):\n    N = len(edges)\n    dist = [INF] * N  # Distance array initialized to infinity\n    dist[start] = 0  # Starting node distance is 0\n    heap = []\n    heappush(heap, start)  # Push the starting node into the heap\n\n    while heap:\n        current_weight, current_node = divmod(heappop(heap), N)\n        if dist[current_node] != current_weight:\n            continue\n        for neighbor, cost in edges[current_node]:\n            new_cost = cost + current_weight\n            if new_cost < dist[neighbor]:\n                dist[neighbor] = new_cost\n                heappush(heap, new_cost * N + neighbor)\n    return dist\n\ndef answer():\n    N, M = map(int, input().split())\n    edges = [[] for _ in range(N * (M + 1))]\n    costs = list(map(int, input().split()))\n    attributes = [list(map(int, input().split())) for _ in range(N)]\n\n    for i in range(M):\n        # Sort Pokémon based on the i-th attribute\n        sorted_pokemon = [(attributes[j][i], j) for j in range(N)]\n        sorted_pokemon.sort(reverse=True)\n\n        for j in range(N):\n            # Create edges for hiring Pokémon\n            _j = j + (i + 1) * N\n            edges[j].append((_j, costs[j]))\n            edges[_j].append((j, 0))\n\n        for j in range(N - 1):\n            # Create edges for attribute increase\n            vi, idx = sorted_pokemon[j]\n            vj, jdx = sorted_pokemon[j + 1]\n            _idx = idx + (i + 1) * N\n            _jdx = jdx + (i + 1) * N\n            edges[_idx].append((_jdx, 0))\n            edges[_jdx].append((_idx, vi - vj))\n\n    # Find the minimum cost to reach the nth Pokémon\n    distances = dijkstra(N - 1, edges)\n    print(distances[0])\n\n# Process each test case\nfor _ in range(int(input())):\n    answer()",
        "correct": true,
        "task_id": 348
    },
    {
        "description": "The Chaya tribe believes that there are n signs of the apocalypse. Over time,\nit has been found out that the i -th sign occurs every a_i years (in years a_i\n, 2 \\cdot a_i , 3 \\cdot a_i , \\dots ).\n\nAccording to the legends, for the apocalypse to happen, the signs must occur\nsequentially. That is, first they wait for the first sign to occur, then\nstrictly after it, the second sign will occur, and so on. That is, if the i\n-th sign occurred in the year x , the tribe starts waiting for the occurrence\nof the (i+1) -th sign, starting from the year x+1 .\n\nIn which year will the n -th sign occur and the apocalypse will happen?\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 1000 ) —\nthe number of test cases. Then follow the descriptions of the test cases.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 100\n) — the number of signs.\n\nThe second line of each test case contains n integers a_1, a_2, a_3, \\dots,\na_n (1 \\le a_i \\le 10^6 ) — the periodicities of the signs.\n\nOutput\n\nFor each test case, output a single integer — the year in which all n signs\nwill occur.\n\nExample\n\nInput\n\n    4\n    \n    6\n    \n    3 2 4 5 9 18\n    \n    5\n    \n    1 2 3 4 5\n    \n    5\n    \n    1 1 1 1 1\n    \n    6\n    \n    50 30 711 200 503 1006\n\nOutput\n\n    36\n    5\n    5\n    2012\n    \nNote\n\nIn the first set of input data of the example:\n\n  * The tribe will wait for the first sign in the 3 -rd year; \n  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); \n  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); \n  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); \n  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); \n  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).",
        "task_name": "1932-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def find_apocalypse_year(n, periods):\n    current_year = 0\n    for period in periods:\n        # Find the next occurrence of the current sign\n        if current_year % period == 0:\n            current_year += period\n        else:\n            current_year = ((current_year // period) + 1) * period\n    return current_year\n\n# Input reading\nt = int(input())  # Number of test cases\nresults = []\n\nfor _ in range(t):\n    n = int(input())  # Number of signs\n    periods = list(map(int, input().split()))  # Periodicities of the signs\n    results.append(find_apocalypse_year(n, periods))\n\n# Output results\nfor result in results:\n    print(result)",
        "correct": true,
        "task_id": 162
    },
    {
        "description": "A contest contains n problems and the difficulty of the i -th problem is\nexpected to be at most b_i . There are already n problem proposals and the\ndifficulty of the i -th problem is a_i . Initially, both a_1, a_2, \\ldots, a_n\nand b_1, b_2, \\ldots, b_n are sorted in non-decreasing order.\n\nSome of the problems may be more difficult than expected, so the writers must\npropose more problems. When a new problem with difficulty w is proposed, the\nmost difficult problem will be deleted from the contest, and the problems will\nbe sorted in a way that the difficulties are non-decreasing.\n\nIn other words, in each operation, you choose an integer w , insert it into\nthe array a , sort array a in non-decreasing order, and remove the last\nelement from it.\n\nFind the minimum number of new problems to make a_i\\le b_i for all i .\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\le t\\le 100 ). The description of the test cases follows.\n\nThe first line of each test case contains only one positive integer n (1 \\leq\nn \\leq 100 ), representing the number of problems.\n\nThe second line of each test case contains an array a of length n (1\\le a_1\\le\na_2\\le\\cdots\\le a_n\\le 10^9 ).\n\nThe third line of each test case contains an array b of length n (1\\le b_1\\le\nb_2\\le\\cdots\\le b_n\\le 10^9 ).\n\nOutput\n\nFor each test case, print an integer as your answer in a new line.\n\nExample\n\nInput\n\n    2\n    \n    6\n    \n    1000 1400 2000 2000 2200 2700\n    \n    800 1200 1500 1800 2200 3000\n    \n    6\n    \n    4 5 6 7 8 9\n    \n    1 2 3 4 5 6\n\nOutput\n\n    2\n    3\n    \nNote\n\nIn the first test case:\n\n  * Propose a problem with difficulty w=800 and a becomes [800,1000,1400,2000,2000,2200] . \n  * Propose a problem with difficulty w=1800 and a becomes [800,1000,1400,1800,2000,2000] . \n\nIt can be proved that it's impossible to reach the goal by proposing fewer new\nproblems.\n\nIn the second test case:\n\n  * Propose a problem with difficulty w=1 and a becomes [1,4,5,6,7,8] . \n  * Propose a problem with difficulty w=2 and a becomes [1,2,4,5,6,7] . \n  * Propose a problem with difficulty w=3 and a becomes [1,2,3,4,5,6] . \n\nIt can be proved that it's impossible to reach the goal by proposing fewer new\nproblems.",
        "task_name": "1972-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve(a, b):\n    num_new_problems = 0\n\n    for i in range(len(a)):\n        if a[i] > b[i]:\n            num_new_problems += a[i] - b[i]\n\n    return num_new_problems",
        "correct": false,
        "task_id": 30
    },
    {
        "description": "This is the way it always was.\n\nThis is the way it always will be.\n\nAll will be forgotten again soon...\n\nJellyfish is playing a one-player card game called \"Slay the Spire\". There are\nn cards in total numbered from 1 to n . The i -th card has power c_i .\n\nThere is a binary string s of length n . If s_i = \\texttt{0} , the i -th card\nis initially in the draw pile. If s_i = \\texttt{1} , the i -th card is\ninitially in Jellyfish's hand.\n\nJellyfish will repeat the following process until either her hand or the draw\npile is empty.\n\n  1. Let x be the power of the card with the largest power in her hand. \n  2. Place a single card with power x back into the draw pile. \n  3. Randomly draw x cards from the draw pile. All subsets of x cards from the draw pile have an equal chance of being drawn. If there are fewer than x cards in the draw pile, Jellyfish will draw all cards. \n\nAt the end of this process, find the probability that Jellyfish can empty the\ndraw pile, modulo 1\\,000\\,000\\,007 .\n\nFormally, let M=1\\,000\\,000\\,007 . It can be shown that the answer can be\nexpressed as an irreducible fraction \\frac{p}{q} , where p and q are integers\nand q \\not \\equiv 0 \\pmod{M} . Output the integer equal to p \\cdot q^{-1}\n\\bmod M . In other words, output such an integer x that 0 \\le x < M and x\n\\cdot q \\equiv p \\pmod{M} .\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\leq t\\leq 100 ). The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\leq n \\leq\n120 ) — the number of cards.\n\nThe second line of each test case contains n integers c_1,c_2,\\ldots,c_n (0\n\\leq c_i \\leq n ) — the powers of the cards. It is guaranteed that c_1 \\leq\nc_2 \\leq \\ldots \\leq c_n .\n\nThe third line of each test case contains a binary string s of length n . If\ns_i = \\texttt{0} , the i -th card is initially in the draw pile. If s_i =\n\\texttt{1} , the i -th card is initially in Jellyfish's hand.\n\nIt is guaranteed that the sum of n^2 over all test cases does not exceed 120^2\n.\n\nOutput\n\nFor each test case, output the probability that Jellyfish can empty the draw\npile modulo 1\\,000\\,000\\,007 .\n\nExample\n\nInput\n\n    4\n    \n    5\n    \n    0 1 1 1 2\n    \n    00100\n    \n    3\n    \n    2 3 3\n    \n    000\n    \n    10\n    \n    0 0 0 0 0 0 0 1 1 1\n    \n    1111011111\n    \n    20\n    \n    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 3 3 4\n    \n    00000000001000101010\n\nOutput\n\n    500000004\n    0\n    0\n    675898154\n    \nNote\n\nIn the first test case, Jellyfish will keep playing cards with power 1 until\nJellyfish draws a card with power 0 or power 2 . If Jellyfish draws a card\nwith power 0 , she will eventually empty her hand. If Jellyfish draws a card\nwith power 2 , she will eventually empty the draw pile. Since there is an\nequal chance of drawing 0 or 2 , the answer is \\frac{1}{2} , and 2 \\cdot\n500\\,000\\,004 \\equiv 1 \\pmod {10^9+7}",
        "task_name": "1975-I",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    n = int(input())\n    c = list(map(int, input().split()))\n    s = input()\n\n    draw_pile_initial = []\n    hand_initial = []\n    for i in range(n):\n        if s[i] == '0':\n            draw_pile_initial.append(c[i])\n        else:\n            hand_initial.append(c[i])\n\n    if not draw_pile_initial:\n        print(1)\n        return\n\n    if not hand_initial:\n        print(0)\n        return\n\n    has_positive_power_in_hand = any(power > 0 for power in hand_initial)\n\n    if has_positive_power_in_hand:\n        print(1)\n    else:\n        print(0)\n\nt = int(input())\nfor _ in range(t):\n    solve()",
        "correct": false,
        "task_id": 21
    },
    {
        "description": "Let's recall that an increasing subsequence of the array a is a sequence that\ncan be obtained from it by removing some elements without changing the order\nof the remaining elements, and the remaining elements are strictly increasing\n(i. e a_{b_1} < a_{b_2} < \\dots < a_{b_k} and b_1 < b_2 < \\dots < b_k ). Note\nthat an empty subsequence is also increasing.\n\nYou are given a positive integer X . Your task is to find an array of integers\nof length at most 200 , such that it has exactly X increasing subsequences, or\nreport that there is no such array. If there are several answers, you can\nprint any of them.\n\nIf two subsequences consist of the same elements, but correspond to different\npositions in the array, they are considered different (for example, the array\n[2, 2] has two different subsequences equal to [2] ).\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 1000 ) — the number of\ntest cases.\n\nThe only line of each test case contains a single integer X (2 \\le X \\le\n10^{18} ).\n\nOutput\n\nFor each query, print the answer to it. If it is impossible to find the\nrequired array, print -1 on the first line. Otherwise, print a positive\ninteger n on the first line — the length of the array. On the second line,\nprint n integers — the required array itself. If there are several answers,\nyou can print any of them. All elements of the array should be in the range\n[-10^9; 10^9] .\n\nExample\n\nInput\n\n    4\n    \n    2\n    \n    5\n    \n    13\n    \n    37\n\nOutput\n\n    1\n    0\n    3\n    0 1 0\n    5\n    2 2 3 4 2\n    7\n    -1 -1 0 0 2 3 -1",
        "task_name": "1922-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    x = int(input())\n    # Convert X to binary string\n    s = bin(x)\n    \n    # Create a list of indices from 0 to the length of the binary string minus 3\n    a = [*range(len(s[3:]))]\n    \n    # List to store positions of '1's in the binary representation\n    b = []\n    v = 0  # Position counter\n    \n    # Iterate over the binary string from the end to the third character\n    for i in range(len(s) - 1, 2, -1):\n        if s[i] == '1':\n            # If the bit is '1', append the current position to b\n            b.append(v)\n        v += 1  # Increment position counter\n    \n    # Concatenate a and the reversed b to form the final answer\n    ans = a + b[::-1]\n    \n    # Print the length of the array and the array itself\n    print(len(ans))\n    print(*ans)",
        "correct": true,
        "task_id": 208
    },
    {
        "description": "Patrick calls a substring^\\dagger of a binary string^\\ddagger good if this\nsubstring contains exactly one 1.\n\nHelp Patrick count the number of binary strings s such that s contains exactly\nn good substrings and has no good substring of length strictly greater than k\n. Note that substrings are differentiated by their location in the string, so\nif s = 1010 you should count both occurrences of 10.\n\n^\\dagger A string a is a substring of a string b if a can be obtained from b\nby the deletion of several (possibly, zero or all) characters from the\nbeginning and several (possibly, zero or all) characters from the end.\n\n^\\ddagger A binary string is a string that only contains the characters 0 and\n1.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 2500 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe only line of each test case contains two integers n and k (1 \\leq n \\leq\n2500 , 1 \\leq k \\leq n ) — the number of required good substrings and the\nmaximum allowed length of a good substring.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2500 .\n\nOutput\n\nFor each test case, output a single integer — the number of binary strings s\nsuch that s contains exactly n good substrings and has no good substring of\nlength strictly greater than k . Since this integer can be too large, output\nit modulo 998\\,244\\,353 .\n\nExample\n\nInput\n\n    6\n    \n    1 1\n    \n    3 2\n    \n    4 2\n    \n    5 4\n    \n    6 2\n    \n    2450 2391\n\nOutput\n\n    1\n    3\n    5\n    12\n    9\n    259280854\n    \nNote\n\nIn the first test case, the only suitable binary string is 1. String 01 is not\nsuitable because it contains a substring 01 with length 2 > 1 .\n\nIn the second test case, suitable binary strings are 011, 110 and 111.\n\nIn the third test case, suitable binary strings are 101, 0110, 0111, 1110, and\n1111.",
        "task_name": "1920-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "MOD = 998244353\n\ndef count_binary_strings(n, k):\n    # Initialize dp array\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    \n    # Base case: For k = 1, there is only one good substring \"1\"\n    dp[1][1] = 1\n    \n    # Fill the dp array\n    for i in range(2, k + 1):\n        for j in range(1, n + 1):\n            # Transition: Adding a '0' or '1' to the previous state\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n    \n    # Sum up all possible counts for n good substrings\n    result = sum(dp[i][n] for i in range(1, k + 1)) % MOD\n    return result\n\n# Input reading\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(count_binary_strings(n, k))",
        "correct": false,
        "task_id": 111
    },
    {
        "description": "Vladislav has n non-negative integers, and he wants to divide all of them into\nseveral groups so that in any group, any pair of numbers does not have\nmatching bit values among bits from 1 -st to 31 -st bit (i.e., considering the\n31 least significant bits of the binary representation).\n\nFor an integer k , let k_2(i) denote the i -th bit in its binary\nrepresentation (from right to left, indexing from 1). For example, if k=43 ,\nsince 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,\n43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \\dots, 43_2(31)=0 .\n\nFormally, for any two numbers x and y in the same group, the condition x_2(i)\n\\neq y_2(i) must hold for all 1 \\leq i < 32 .\n\nWhat is the minimum number of groups Vlad needs to achieve his goal? Each\nnumber must fall into exactly one group.\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 10^4 ) — the number\nof test cases.\n\nThe first line of each test case contains a single integer n (1 \\leq n \\leq 2\n\\cdot 10^5 ) — the total number of integers.\n\nThe second line of each test case contains n given integers a_1, \\ldots, a_n\n(0 \\leq a_j < 2^{31} ).\n\nThe sum of n over all test cases in a test does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the minimum number of groups\nrequired to satisfy the condition.\n\nExample\n\nInput\n\n    9\n    \n    4\n    \n    1 4 3 4\n    \n    2\n    \n    0 2147483647\n    \n    5\n    \n    476319172 261956880 2136179468 1671164475 1885526767\n    \n    3\n    \n    1335890506 811593141 1128223362\n    \n    4\n    \n    688873446 627404104 1520079543 1458610201\n    \n    4\n    \n    61545621 2085938026 1269342732 1430258575\n    \n    4\n    \n    0 0 2147483647 2147483647\n    \n    3\n    \n    0 0 2147483647\n    \n    8\n    \n    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735\n\nOutput\n\n    4\n    1\n    3\n    2\n    2\n    3\n    2\n    2\n    4\n    \nNote\n\nIn the first test case, any two numbers have the same last 31 bits, so we need\nto place each number in its own group.\n\nIn the second test case, a_1=0000000000000000000000000000000_2 ,\na_2=1111111111111111111111111111111_2 so they can be placed in the same group\nbecause a_1(i) \\ne a_2(i) for each i between 1 and 31 , inclusive.",
        "task_name": "1926-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def are_complementary(x, y):\n    for i in range(1, 32):\n        if (x >> (i - 1)) & 1 == (y >> (i - 1)) & 1:\n            return False\n    return True\n\ndef min_groups(n, integers):\n    groups = []\n    for num in integers:\n        placed = False\n        for group in groups:\n            if are_complementary(num, group[0]):\n                group.append(num)\n                placed = True\n                break\n        if not placed:\n            groups.append([num])\n    return len(groups)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        integers = list(map(int, input().split()))\n        print(min_groups(n, integers))\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 45
    }
]