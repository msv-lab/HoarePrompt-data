[
    {
        "description": "You are in a nuclear laboratory that is about to explode and destroy the\nEarth. You must save the Earth before the final countdown reaches zero.\n\nThe countdown consists of n (1 \\le n \\le 4 \\cdot 10^5 ) mechanical indicators,\neach showing one decimal digit. You noticed that when the countdown changes\nits state from x to x-1 , it doesn't happen in one move. Instead, each change\nof a single digit takes one second.\n\nSo, for example, if the countdown shows 42, then it will change to 41 in one\nsecond, because only one digit is changed, but if the countdown shows 2300,\nthen it will change to 2299 in three seconds, because the three last digits\nare changed.\n\nFind out how much time is left before the countdown reaches zero.\n\nInput\n\nThe first line of input contains a single integer t (1 \\le t \\le 10^4 ) — the\nnumber of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains a single integer n (1\\le n\\le 4\\cdot\n10^5 ).\n\nThe second line contains a string of n digits, the current state of the\ncountdown. It is guaranteed that at least one digit is not zero.\n\nThe sum of n for all tests does not exceed 4\\cdot 10^5 .\n\nOutput\n\nFor each test case, print a single integer without leading zeroes, the number\nof seconds left before the countdown reaches zero. Note that this number may\nbe huge.\n\nExample\n\nInput\n\n    5\n    \n    2\n    \n    42\n    \n    5\n    \n    12345\n    \n    2\n    \n    99\n    \n    4\n    \n    0005\n    \n    27\n    \n    456480697259671309012631002\n\nOutput\n\n    46\n    13715\n    108\n    5\n    507200774732968121125145546\n    \nNote\n\nIn the first example, there are four changes that take 2 seconds: 40 to 39, 30\nto 29, 20 to 19, and 10 to 09, other changes take 1 second each. So the total\ntime is 2\\cdot 4 + 1\\cdot(42-4) = 46 .",
        "task_name": "1932-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve(n, s):\n    s = s[::-1]\n    a = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        a[i] = a[i + 1] + int(s[i])\n    \n    res = []\n    c = 0\n    for i in range(n):\n        c += a[i]\n        res.append(str(c % 10))\n        c //= 10  \n    res.append(str(c))\n    while res and res[-1] == '0':\n        res.pop()\n\n    res = ''.join(res[::-1])\n\n    return res\n\n\ntest_cases = int(input())\nans = []\nfor _ in range(test_cases):\n    n = int(input())\n    number = input()\n    ans.append(solve(n, number))\n\nprint(\"\\n\".join(map(str, ans)))",
        "correct": true,
        "task_id": 168
    },
    {
        "description": "n ships set out to explore the depths of the ocean. The ships are numbered\nfrom 1 to n and follow each other in ascending order; the i -th ship has a\ndurability of a_i .\n\nThe Kraken attacked the ships k times in a specific order. First, it attacks\nthe first of the ships, then the last, then the first again, and so on.\n\nEach attack by the Kraken reduces the durability of the ship by 1 . When the\ndurability of the ship drops to 0 , it sinks and is no longer subjected to\nattacks (thus the ship ceases to be the first or last, and the Kraken only\nattacks the ships that have not yet sunk). If all the ships have sunk, the\nKraken has nothing to attack and it swims away.\n\nFor example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:\n\n  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; \n  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; \n  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; \n  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; \n  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . \n\nHow many ships were sunk after the Kraken's attack?\n\nInput\n\nThe first line contains an integer t (1 \\le t \\le 10^4 ) — the number of test\ncases.\n\nThe first line of each test case contains two integers n and k (1 \\le n \\le 2\n\\cdot 10^5 , 1 \\le k \\le 10^{15} ) — the number of ships and how many times\nthe Kraken will attack the ships.\n\nThe second line of each test case contains n integers a_1, a_2, \\dots, a_n (1\n\\le a_i \\le 10^9 ) — the durability of the ships.\n\nIt is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output the number of ships sunk by the Kraken on a\nseparate line.\n\nExample\n\nInput\n\n    6\n    \n    4 5\n    \n    1 2 4 3\n    \n    4 6\n    \n    1 2 4 3\n    \n    5 20\n    \n    2 7 1 8 2\n    \n    2 2\n    \n    3 2\n    \n    2 15\n    \n    1 5\n    \n    2 7\n    \n    5 2\n\nOutput\n\n    2\n    3\n    5\n    0\n    2\n    2",
        "task_name": "1955-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input()); from collections import deque;\nfor _ in range (t):\n    n, k = map(int, input().split())\n    lit = deque(list((map(int, input().split()))));\n    lastState = -1; sunk = 0;\n    while True:\n        if len(lit) == 0 or k <= 0:\n            break;\n        if lastState == -1:\n            lastState = 0;\n        else:\n            lastState = -1;\n        u = lit[lastState];\n        if u <= k:\n            sunk += 1;\n            if lastState == -1:\n                lit.pop();\n            else:\n                lit.popleft();\n        k -= u;\n    print (sunk);",
        "correct": false,
        "task_id": 313
    },
    {
        "description": "Master Andrey loves trees^{\\dagger} very much, so he has a tree consisting of\nn vertices.\n\nBut it's not that simple. Master Timofey decided to steal one vertex from the\ntree. If Timofey stole vertex v from the tree, then vertex v and all edges\nwith one end at vertex v are removed from the tree, while the numbers of other\nvertices remain unchanged. To prevent Andrey from getting upset, Timofey\ndecided to make the resulting graph a tree again. To do this, he can add edges\nbetween any vertices a and b , but when adding such an edge, he must pay |a -\nb| coins to the Master's Assistance Center.\n\nNote that the resulting tree does not contain vertex v .\n\nTimofey has not yet decided which vertex v he will remove from the tree, so he\nwants to know for each vertex 1 \\leq v \\leq n , the minimum number of coins\nneeded to be spent to make the graph a tree again after removing vertex v , as\nwell as which edges need to be added.\n\n^{\\dagger} A tree is an undirected connected graph without cycles.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (5 \\le n \\le\n2\\cdot10^5 ) — the number of vertices in Andrey's tree.\n\nThe next n - 1 lines contain a description of the tree's edges. The i -th of\nthese lines contains two integers u_i and v_i (1 \\le u_i, v_i \\le n ) — the\nnumbers of vertices connected by the i -th edge.\n\nIt is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of n over all test cases does not exceed\n2\\cdot10^5 .\n\nOutput\n\nFor each test case, output the answer in the following format:\n\nFor each vertex v (in the order from 1 to n ), in the first line output two\nintegers w and m — the minimum number of coins that need to be spent to make\nthe graph a tree again after removing vertex v , and the number of added\nedges.\n\nThen output m lines, each containing two integers a and b (1 \\le a, b \\le n, a\n\\ne v, b \\ne v , a \\ne b ) — the ends of the added edge.\n\nIf there are multiple ways to add edges, you can output any solution with the\nminimum cost.\n\nExample\n\nInput\n\n    3\n    \n    5\n    \n    1 3\n    \n    1 4\n    \n    4 5\n    \n    3 2\n    \n    5\n    \n    4 2\n    \n    4 3\n    \n    3 5\n    \n    5 1\n    \n    5\n    \n    2 1\n    \n    1 5\n    \n    1 4\n    \n    1 3\n\nOutput\n\n    1 1\n    3 4\n    \n    0 0\n    \n    1 1\n    1 2\n    \n    2 1\n    3 5\n    \n    0 0\n    \n    0 0\n    \n    0 0\n    \n    1 1\n    1 2\n    \n    1 1\n    1 2\n    \n    1 1\n    1 2\n    \n    3 3\n    2 3\n    4 5\n    3 4\n    \n    0 0\n    \n    0 0\n    \n    0 0\n    \n    0 0\n    \nNote\n\nIn the first test case:\n\nConsider the removal of vertex 4 :\n\n![](https://espresso.codeforces.com/9af9f3bd91477fd731f4aa715fe753511c288968.png)\n\nThe optimal solution would be to add an edge from vertex 5 to vertex 3 . Then\nwe will spend |5 - 3| = 2 coins.\n\nIn the third test case:\n\nConsider the removal of vertex 1 :\n\n![](https://espresso.codeforces.com/e99252f9766c11f12763d45d8d2bc6f30d2f2305.png)\n\nThe optimal solution would be:\n\n  * Add an edge from vertex 2 to vertex 3 , spending |2 - 3| = 1 coin. \n  * Add an edge from vertex 3 to vertex 4 , spending |3 - 4| = 1 coin. \n  * Add an edge from vertex 4 to vertex 5 , spending |4 - 5| = 1 coin. \n\nThen we will spend a total of 1 + 1 + 1 = 3 coins.\n\nConsider the removal of vertex 2 :\n\n![](https://espresso.codeforces.com/0c40cbfc84a9ac5f32d218257519f18be9a69893.png)\n\nNo edges need to be added, as the graph will remain a tree after removing the\nvertex.",
        "task_name": "1935-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve_test_case(n, edges):\n    # Create an adjacency list to represent the tree\n    tree = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    results = []\n    \n    for v in range(1, n + 1):\n        # Simulate the removal of vertex v\n        # Find the minimum cost to restore the tree\n        min_cost = float('inf')\n        added_edges = []\n        \n        # Check each pair of vertices to see if adding an edge is necessary\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if i != v and j != v:\n                    # Check if adding an edge between i and j is necessary\n                    if not is_connected(tree, i, j, v):\n                        cost = abs(i - j)\n                        if cost < min_cost:\n                            min_cost = cost\n                            added_edges = [(i, j)]\n                        elif cost == min_cost:\n                            added_edges.append((i, j))\n        \n        results.append((min_cost, len(added_edges), added_edges))\n    \n    return results\n\ndef is_connected(tree, i, j, v):\n    # Check if vertices i and j are connected in the tree without using vertex v\n    visited = [False] * (len(tree) + 1)\n    visited[v] = True\n    \n    def dfs(node):\n        if node == j:\n            return True\n        visited[node] = True\n        for neighbor in tree[node]:\n            if not visited[neighbor] and dfs(neighbor):\n                return True\n        return False\n    \n    return dfs(i)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        edges = [tuple(map(int, data[idx + i + 1].split())) for i in range(n - 1)]\n        test_cases.append((n, edges))\n        idx += n\n    \n    for case_num, (n, edges) in enumerate(test_cases):\n        results = solve_test_case(n, edges)\n        for v, (min_cost, num_edges, added_edges) in enumerate(results, start=1):\n            print(min_cost, num_edges)\n            for a, b in added_edges:\n                print(a, b)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 170
    },
    {
        "description": "You have an array a of n integers.\n\nYou can no more than once apply the following operation: select three integers\ni , j , x (1 \\le i \\le j \\le n ) and assign all elements of the array with\nindexes from i to j the value x . The price of this operation depends on the\nselected indices and is equal to (j - i + 1) burles.\n\nFor example, the array is equal to [1, 2, 3, 4, 5, 1] . If we choose i = 2, j\n= 4, x = 8 , then after applying this operation, the array will be equal to\n[1, 8, 8, 8, 5, 1] .\n\nWhat is the least amount of burles you need to spend to make all the elements\nof the array equal?\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ninput test cases. The descriptions of the test cases follow.\n\nThe first line of the description of each test case contains a single integer\nn (1 \\le n \\le 2 \\cdot 10 ^ 5 ) — the size of the array.\n\nThe second line of the description of each test case contains n integers a_1,\na_2, \\dots, a_n (1 \\le a_i \\le n ) — array elements.\n\nIt is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output one integer — the minimum number of burles that\nwill have to be spent to make all the elements of the array equal. It can be\nshown that this can always be done.\n\nExample\n\nInput\n\n    8\n    \n    6\n    \n    1 2 3 4 5 1\n    \n    7\n    \n    1 1 1 1 1 1 1\n    \n    8\n    \n    8 8 8 1 2 8 8 8\n    \n    1\n    \n    1\n    \n    2\n    \n    1 2\n    \n    3\n    \n    1 2 3\n    \n    7\n    \n    4 3 2 7 1 1 3\n    \n    9\n    \n    9 9 2 9 2 5 5 5 3\n\nOutput\n\n    4\n    0\n    2\n    0\n    1\n    2\n    6\n    7",
        "task_name": "1931-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    i1 = 0\n    i2 = 0\n    while i1 < n and a[i1] == a[0]:\n        i1 += 1\n    while i2 < n and a[n - i2 - 1] == a[n - 1]:\n        i2 += 1\n    res = n\n    if a[0] == a[n - 1]:\n        res -= i1\n        res -= i2\n    else:\n        res -= max(i1, i2)\n    print(max(0, res))\n \n \nt = int(input())\n \n \nfor i in range(t):\n    solve()",
        "correct": true,
        "task_id": 355
    },
    {
        "description": "There are n coins on the table forming a circle, and each coin is either\nfacing up or facing down. Alice and Bob take turns to play the following game,\nand Alice goes first.\n\nIn each operation, the player chooses a facing-up coin, removes the coin, and\nflips the two coins that are adjacent to it. If (before the operation) there\nare only two coins left, then one will be removed and the other won't be\nflipped (as it would be flipped twice). If (before the operation) there is\nonly one coin left, no coins will be flipped. If (before the operation) there\nare no facing-up coins, the player loses.\n\nDecide who will win the game if they both play optimally. It can be proved\nthat the game will end in a finite number of operations, and one of them will\nwin.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\le t\\le 100 ). The description of the test cases follows.\n\nThe first line of each test case contains only one positive integer n (1 \\leq\nn \\leq 100 ), representing the number of the coins.\n\nA string s of length n follows on the second line of each test case,\ncontaining only \"U\" and \"D\", representing that each coin is facing up or\nfacing down.\n\nOutput\n\nFor each test case, print \"YES\" if Alice will win the game, and \"NO\"\notherwise.\n\nYou can output the answer in any case (upper or lower). For example, the\nstrings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive\nresponses.\n\nExample\n\nInput\n\n    3\n    \n    5\n    \n    UUDUD\n    \n    5\n    \n    UDDUD\n    \n    2\n    \n    UU\n\nOutput\n\n    YES\n    NO\n    NO\n    \nNote\n\nIn the first test case, the game may go as follows.\n\n  * Alice chooses the first coin and s becomes \"DDUU\". \n  * Bob chooses the last coin and s becomes \"UDD\". \n  * Alice chooses the first coin and s becomes \"UU\". \n  * Bob chooses the first coin and s becomes \"U\". \n  * Alice chooses the only coin and s becomes empty. \n  * Bob can't choose any coin now, and he loses the game. \n\nIt can be proved that Bob will always lose if they both play optimally.",
        "task_name": "1972-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for i in range(int(input())):\n    n = input()\n    s = input()\n\n    cnt_u = 0\n    for j in s:\n        if j == \"U\":\n            cnt_u+=1\n    if cnt_u % 2 == 1:\n        print('Alice')\n    else:\n        print('Bob')",
        "correct": false,
        "task_id": 25
    },
    {
        "description": "A horizontal grid strip of n cells is given. In the i -th cell, there is a\npaint charge of size a_i . This charge can be:\n\n  * either used to the left — then all cells to the left at a distance less than a_i (from \\max(i - a_i + 1, 1) to i inclusive) will be painted, \n  * or used to the right — then all cells to the right at a distance less than a_i (from i to \\min(i + a_i - 1, n) inclusive) will be painted, \n  * or not used at all. \n\nNote that a charge can be used no more than once (that is, it cannot be used\nsimultaneously to the left and to the right). It is allowed for a cell to be\npainted more than once.\n\nWhat is the minimum number of times a charge needs to be used to paint all the\ncells of the strip?\n\nInput\n\nThe first line of the input contains an integer t (1 \\le t \\le 100 ) — the\nnumber of test cases in the test. This is followed by descriptions of t test\ncases.\n\nEach test case is specified by two lines. The first one contains an integer n\n(1 \\le n \\le 100 ) — the number of cells in the strip. The second line\ncontains n positive integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le n ), where\na_i is the size of the paint charge in the i -th cell from the left of the\nstrip.\n\nIt is guaranteed that the sum of the values of n in the test does not exceed\n1000 .\n\nOutput\n\nFor each test case, output the minimum number of times the charges need to be\nused to paint all the cells of the strip.\n\nExample\n\nInput\n\n    13\n    \n    1\n    \n    1\n    \n    2\n    \n    1 1\n    \n    2\n    \n    2 1\n    \n    2\n    \n    1 2\n    \n    2\n    \n    2 2\n    \n    3\n    \n    1 1 1\n    \n    3\n    \n    3 1 2\n    \n    3\n    \n    1 3 1\n    \n    7\n    \n    1 2 3 1 2 4 2\n    \n    7\n    \n    2 1 1 1 2 3 1\n    \n    10\n    \n    2 2 5 1 6 1 8 2 8 2\n    \n    6\n    \n    2 1 2 1 1 2\n    \n    6\n    \n    1 1 4 1 3 2\n\nOutput\n\n    1\n    2\n    1\n    1\n    1\n    3\n    1\n    2\n    3\n    4\n    2\n    3\n    3\n    \nNote\n\nIn the third test case of the example, it is sufficient to use the charge from\nthe 1 -st cell to the right, then it will cover both cells 1 and 2 .\n\nIn the ninth test case of the example, you need to:\n\n  * use the charge from the 3 -rd cell to the left, covering cells from the 1 -st to the 3 -rd; \n  * use the charge from the 5 -th cell to the left, covering cells from the 4 -th to the 5 -th; \n  * use the charge from the 7 -th cell to the left, covering cells from the 6 -th to the 7 -th. \n\nIn the eleventh test case of the example, you need to:\n\n  * use the charge from the 5 -th cell to the right, covering cells from the 5 -th to the 10 -th; \n  * use the charge from the 7 -th cell to the left, covering cells from the 1 -st to the 7 -th.",
        "task_name": "1927-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def min_charges_to_paint(t, test_cases):\n    results = []\n    for test in test_cases:\n        n, a = test\n        painted = [False] * n  \n        charge_count = 0       \n        \n        i = 0  \n        while i < n:\n            if not painted[i]:  \n                charge_count += 1\n                left_start = max(0, i - a[i] + 1)\n                right_end = min(n - 1, i + a[i] - 1)\n                \n                for j in range(left_start, right_end + 1):\n                    painted[j] = True\n            \n            i += 1\n        \n        results.append(charge_count)\n    return results\n\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\nresults = min_charges_to_paint(t, test_cases)\n\nfor res in results:\n    print(res)",
        "correct": false,
        "task_id": 114
    },
    {
        "description": "You are given two integers n and k along with a string s .\n\nYour task is to check whether all possible strings of length n that can be\nformed using the first k lowercase English alphabets occur as a subsequence of\ns . If the answer is NO, you also need to print a string of length n that can\nbe formed using the first k lowercase English alphabets which does not occur\nas a subsequence of s .\n\nIf there are multiple answers, you may print any of them.\n\nNote: A string a is called a subsequence of another string b if a can be\nobtained by deleting some (possibly zero) characters from b without changing\nthe order of the remaining characters.\n\nInput\n\nThe first line of input contains a single integer t \\, (1 \\le t \\le 10^5) ,\nthe number of test cases.\n\nThe first line of each test case contains 3 integers n \\, (1 \\le n \\le 26), \\:\nk \\, (1 \\le k \\le 26), \\: m \\, (1 \\le m \\le 1000) , where n and k are the same\nas described in the input and m is the length of the string s .\n\nThe second line of each test case contains a single string s of length m ,\ncomprising only of the first k lowercase English alphabets.\n\nIt is guaranteed that the sum of m and the sum of n over all test cases does\nnot exceed 10^6 .\n\nOutput\n\nFor each test case, print YES if all possible strings of length n that can be\nformed using the first k lowercase English alphabets occur as a subsequence of\ns , else print NO.\n\nIf your answer is NO, print a string of length n that can be formed using the\nfirst k lowercase English alphabets which does not occur as a subsequence of s\nin the next line.\n\nYou may print each letter of YES or NO in any case (for example, YES, yES, YeS\nwill all be recognized as a positive answer).\n\nExample\n\nInput\n\n    3\n    \n    2 2 4\n    \n    abba\n    \n    2 2 3\n    \n    abb\n    \n    3 3 10\n    \n    aabbccabab\n\nOutput\n\n    YES\n    NO\n    aa\n    NO\n    ccc\n    \nNote\n\nFor the first test case, all possible strings (aa, ab, ba, bb) of length 2\nthat can be formed using the first 2 English alphabets occur as a subsequence\nof abba.\n\nFor the second test case, the string aa is not a subsequence of abb.",
        "task_name": "1924-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "# Read input\nT = input\nfor _ in [0] * int(T()):\n    # Read n, k, m for each test case\n    n, k, m = map(int, T().split())\n    \n    # Create a set of the first k lowercase alphabets\n    a = t = {*map(chr, range(97, 97 + k))}\n    \n    # Initialize result as 'NO ' (we'll append the string if needed)\n    r = 'NO '\n    \n    # Read the string s\n    for x in T():\n        # Remove the character from the set t if it exists\n        t = t - {x} or a\n        \n        # Append the character to result if t is less than a\n        r += x[t < a:]\n    \n    # Print 'YES' if all strings are subsequences, otherwise print 'NO' and the string\n    print(('YES', t := (r + t.pop() * n)[:n + 3])[t > r])",
        "correct": true,
        "task_id": 250
    },
    {
        "description": "Let us call an array x_1,\\dots,x_m interesting if it is possible to divide the\narray into k>1 parts so that [bitwise XOR](http://tiny.cc/xor_wiki_eng) of\nvalues from each part are equal.\n\nMore formally, you must split array x into k consecutive segments, each\nelement of x must belong to exactly 1 segment. Let y_1,\\dots,y_k be the XOR of\nelements from each part respectively. Then y_1=y_2=\\dots=y_k must be\nfulfilled.\n\nFor example, if x = [1, 1, 2, 3, 0] , you can split it as follows:\n[\\color{blue}1], [\\color{green}1], [\\color{red}2, \\color{red}3, \\color{red}0]\n. Indeed \\color{blue}1=\\color{green}1=\\color{red}2 \\oplus \\color{red}3\\oplus\n\\color{red}0 .\n\nYou are given an array a_1,\\dots,a_n . Your task is to answer q queries:\n\n  * For fixed l , r , determine whether the subarray a_l,a_{l+1},\\dots,a_r is interesting. \n\nInput\n\nThe first line contains a single integer t (1\\le t\\le 10^4 ) — the number of\ntest cases.\n\nThe first line of each test case contains two integers n and q (2 \\le n \\le 2\n\\cdot 10^5 , 1 \\le q \\le 2 \\cdot 10^5 ) — the number of elements in the array\nand the number of queries respectively.\n\nThe next line contains n integers a_1,\\dots,a_n (0 \\le a_i < 2^{30} ) —\nelements of the array.\n\nEach of the next q lines contains two integers l and r (1 \\le l < r \\le n )\ndescribing the query.\n\nIt is guaranteed that the sum of n over all testcases does not exceed 2 \\cdot\n10^5 .\n\nIt is guaranteed that the sum of q over all testcases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each query, output \"YES\" if the subarray is interesting and \"NO\"\notherwise.\n\nYou can output \"Yes\" and \"No\" in any case (for example, the strings \"yES\",\n\"yes\", and \"Yes\" will be recognized as correct answers).\n\nExample\n\nInput\n\n    4\n    \n    5 5\n    \n    1 1 2 3 0\n    \n    1 5\n    \n    2 4\n    \n    3 5\n    \n    1 3\n    \n    3 4\n    \n    5 5\n    \n    1 2 3 4 5\n    \n    1 5\n    \n    2 4\n    \n    3 5\n    \n    1 3\n    \n    2 3\n    \n    7 4\n    \n    12 9 10 9 10 11 9\n    \n    1 5\n    \n    1 7\n    \n    2 6\n    \n    2 7\n    \n    11 4\n    \n    0 0 1 0 0 1 0 1 1 0 1\n    \n    1 2\n    \n    2 5\n    \n    6 9\n    \n    7 11\n\nOutput\n\n    YES\n    YES\n    NO\n    NO\n    NO\n    \n    YES\n    NO\n    NO\n    YES\n    NO\n    \n    NO\n    NO\n    NO\n    NO\n    \n    YES\n    NO\n    YES\n    YES\n    \nNote\n\nExplanation for the first test case:\n\nThe first query is described in the statement.\n\nIn the second query, we should divide [1,2,3] . A possible division is\n[1,2],[3] , since 1\\oplus 2=3 .\n\nIt can be shown that for queries 3,4,5 , the subarrays are not interesting.",
        "task_name": "1968-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections import defaultdict\nfrom bisect import *\n\ndef solve():\n    n, q = map(int, input().split())\n    a = [int(i) for i in input().split()]\n\n    pre = [0] * (n + 1)\n    for i in range(n):\n        pre[i + 1] = pre[i] ^ a[i]\n\n    lookup = defaultdict(list)\n    for i, x in enumerate(pre):\n        lookup[x].append(i)\n\n    for _ in range(q):\n        l, r = map(int, input().split())\n        left = lookup[pre[r]][bisect_left(lookup[pre[r]], l)]\n        right = lookup[pre[l - 1]][bisect_left(lookup[pre[l - 1]], r + 1) - 1]\n        print(\"YES\" if left <= right else \"NO\")\n    print()\n\nfor _ in range(int(input())):\n    solve()",
        "correct": true,
        "task_id": 183
    },
    {
        "description": "In the easy version, m = n-1 and there exists a path between u and v for all\nu, v (1 \\leq u, v \\leq n ).\n\nAfter a worker's strike organized by the Dementors asking for equal rights,\nthe prison of Azkaban has suffered some damage. After settling the spirits,\nthe Ministry of Magic is looking to renovate the prison to ensure that the\nDementors are kept in check. The prison consists of n prison cells and m bi-\ndirectional corridors. The i^{th} corridor is from cells u_i to v_i . A subset\nof these cells S is called a complex if any cell in S is reachable from any\nother cell in S . Formally, a subset of cells S is a complex if x and y are\nreachable from each other for all x, y \\in S , using only cells from S on the\nway. The funding required for a complex S consisting of k cells is defined as\nk^2 .\n\nAs part of your Intro to Magical Interior Design course at Hogwarts, you have\nbeen tasked with designing the prison. The Ministry of Magic has asked that\nyou divide the prison into 2 complexes with \\textbf{exactly one corridor}\nconnecting them, so that the Dementors can't organize union meetings. For this\npurpose, you are allowed to build bi-directional corridors. The funding\nrequired to build a corridor between any 2 cells is c .\n\nDue to budget cuts and the ongoing fight against the Death Eaters, you must\nfind the \\textbf{minimum total funding} required to divide the prison as per\nthe Ministry's requirements or -1 if no division is possible.\n\nNote: The total funding is the sum of the funding required for the 2 complexes\nand the corridors built. If after the division, the two complexes have x and y\ncells respectively and you have built a total of a corridors, the total\nfunding will be x^2 + y^2 + c \\times a . Note that x+y=n .\n\nInput\n\nThe first line contains one integer t (1 \\leq t \\leq 10^5 ) — the number of\ntest cases. Then t test cases follow.\n\nThe first line of each test case consists of three integers n, m and c (2 \\leq\nn \\leq 10^5 , m = n - 1 , 1 \\leq c \\leq 10^9 )\n\nm lines follow, each consisting of 2 integers — u_i, v_i indicating a corridor\nis present between cells u_i and v_i (1 \\leq u_i, v_i \\leq n , u_i \\neq v_i )\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5 .\n\nIt is guaranteed that the sum of m over all test cases does not exceed 5\n\\times 10^5 .\n\nIt is guaranteed that there exists at most one corridor between any two cells.\n\nOutput\n\nPrint the \\textbf{minimum funding} required to divide the prison as per the\nMinistry's requirements or -1 if no division is possible.\n\nExample\n\nInput\n\n    2\n    2 1 3\n    1 2\n    8 7 76\n    3 1\n    3 2\n    2 4\n    2 5\n    4 6\n    4 7\n    7 8\n    \nOutput\n\n    2\n    32",
        "task_name": "1970-G1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\n\ndef find_complexes(n, m, c, corridors):\n    count = 0\n    for u, v in corridors:\n        if v - u == 1 or u - v == 1:\n            count += 1\n    if count == 2:\n        return n\n    else:\n        return -1\n\ndef min_funding(t, test_cases):\n    for i in range(t):\n        n, m, c = test_cases[i][0]\n        corridors = test_cases[i][1]\n        result = find_complexes(n, m, c, corridors)\n        print(result)\n\nt = int(sys.stdin.readline().strip())\ntest_cases = []\nfor _ in range(t):\n    case = []\n    n, m, c = map(int, sys.stdin.readline().strip().split())\n    case.append((n, m, c))\n    corridors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(m)]\n    case.append(corridors)\n    test_cases.append(case)\n\nmin_funding(t, test_cases)",
        "correct": false,
        "task_id": 289
    },
    {
        "description": "Elections are taking place in Berland. There are n candidates participating in\nthe elections, numbered from 1 to n . The i -th candidate has a_i fans who\nwill vote for him. Additionally, there are c people who are undecided about\ntheir favorite candidate, let's call them undecided. Undecided people will\nvote for the candidate with the lowest number.\n\nThe candidate who receives the maximum number of votes wins the elections, and\nif multiple candidates receive the same maximum number of votes, the candidate\nwith the lowest number among them wins.\n\nYou found these elections too boring and predictable, so you decided to\nexclude some candidates from them. If you do not allow candidate number i to\nparticipate in the elections, all a_i of his fans will become undecided, and\nwill vote for the candidate with the lowest number.\n\nYou are curious to find, for each i from 1 to n , the minimum number of\ncandidates that need to be excluded from the elections for candidate number i\nto win the elections.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 2 \\cdot 10^4 ) — the number of test cases. The\ndescription of the test cases follows.\n\nThe first line of each test case contains two integers n and c (1 \\le n \\le 2\n\\cdot 10^5 , 0 \\le c \\le 10^9 ) — the number of candidates in the elections\nand the number of undecided people.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (0\n\\le a_i \\le 10^9 ) — the number of fans for each candidate.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output n integers, the i -th of which should be equal to\nthe minimum number of candidates that need to be excluded from the elections\nfor candidate number i to win.\n\nExample\n\nInput\n\n    5\n    \n    3 1\n    \n    2 0 3\n    \n    2 3\n    \n    0 10\n    \n    5 3\n    \n    5 4 3 2 1\n    \n    4 5\n    \n    3 10 7 1\n    \n    6 0\n    \n    2 2 2 3 3 3\n\nOutput\n\n    0 1 2\n    1 0\n    0 1 2 3 4\n    1 0 2 3\n    1 1 2 0 4 5\n    \nNote\n\nIn the first test case:\n\n  * If all candidates are allowed, candidate number 1 will receive 3 votes (1 undecided person will vote for him), candidate number 2 will receive 0 votes, and candidate number 3 will receive 3 votes. Therefore, candidate number 1 wins (he received the same number of votes as candidate 3 , but his number is lower), so the answer for him is 0 .\n  * If candidate number 1 is not allowed, his 2 fans will become undecided. Then candidate number 2 will receive 3 votes (3 undecided people will vote for him) and candidate number 3 will receive 3 votes. Therefore, candidate number 2 wins (he received the same number of votes as candidate 3 , but his number is lower), so the answer for him is 1 .\n  * If candidates with numbers 1 and 2 are not allowed, candidate number 3 wins, so the answer for him is 2 .\n\nIn the second test case, candidate number 1 will win if candidate number 2 is\nnot allowed to participate.",
        "task_name": "1978-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range (int(input())):\n    pref = [0]; sm = [0];\n    n, d = map(int, input().split())\n    lit = list(map(int, input().split()));\n    for i in range (n):\n        pref.append(pref[-1]+lit[i]);\n        sm.append(max(sm[-1], lit[n-i-1]));\n    sm = list(reversed(sm));\n    ans = [float('inf')];\n    u = max(lit); idx = lit.index(u)+1;\n    for i in range (1, n+1):\n        if lit[i-1] == u:\n            if lit[i-1] > lit[0] + d:\n                if i == idx:\n                    ans.append(0);\n                else:\n                    ans.append(i-1);\n            else:\n                ans.append(i-1); \n        else:\n            if pref[i] + d >= sm[i]:\n                ans.append(i-1);\n            else:\n                ans.append(i);\n    print (' '.join(list(map(str, ans[1:]))));",
        "correct": true,
        "task_id": 218
    }
]