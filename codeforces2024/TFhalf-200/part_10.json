[
    {
        "description": "In the village of Letovo, there are n houses. The villagers decided to build a\nbig road that will divide the village into left and right sides. Each resident\nwants to live on either the right or the left side of the street, which is\ndescribed as a sequence a_1, a_2, \\dots, a_n , where a_j = 0 if the resident\nof the j -th house wants to live on the left side of the street; otherwise,\na_j = 1 .\n\nThe road will pass between two houses. The houses to the left of it will be\ndeclared the left-side, and the houses to the right will be declared the\nright-side. More formally, let the road pass between houses i and i+1 . Then\nthe houses at positions between 1 and i will be on the left side of the\nstreet, and at positions between i+1 and n will be on the right side. The road\nalso may pass before the first and after the last house; in this case, the\nentire village is declared to be either the right or left side, respectively.\n\nTo make the design fair, it was decided to lay the road so that at least half\nof the residents on each side of the village are satisfied with the choice.\nThat is, among x residents on one side, at least \\lceil\\frac{x}{2}\\rceil\nshould want to live on that side, where \\lceil x \\rceil denotes rounding up a\nreal number x .\n\n![](https://espresso.codeforces.com/75baa17903d65a630fb0d3334683e857d5fdc345.png)\nTo the left of the road, there will be i houses, among the corresponding a_j\nthere must be at least \\lceil\\frac{i}{2}\\rceil zeros. To the right of the\nroad, there will be n-i houses, among the corresponding a_j there must be at\nleast \\lceil\\frac{n-i}{2}\\rceil ones.\n\nDetermine after which house i the road should be laid in order to satisfy the\ndescribed condition and be as close to the middle of the village as possible.\nFormally, among all suitable positions i , minimize \\left|\\frac{n}{2} -\ni\\right| .\n\nIf there are multiple suitable positions i with the minimum \\left|\\frac{n}{2}\n- i\\right| , output the smaller one.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 2\\cdot 10^4 ). The description of the test cases\nfollows.\n\nThe first line of each test case contains a single integer n (3 \\le n \\le\n3\\cdot 10^5 ). The next line of each test case contains a string a of length n\n, consisting only of 0 and 1 .\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3\\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single number i — the position of the house after\nwhich the road should be laid (if it should be laid before the first house,\noutput 0 ). We can show that the answer always exists.\n\nExample\n\nInput\n\n    7\n    \n    3\n    \n    101\n    \n    6\n    \n    010111\n    \n    6\n    \n    011001\n    \n    3\n    \n    000\n    \n    3\n    \n    110\n    \n    3\n    \n    001\n    \n    4\n    \n    1100\n\nOutput\n\n    2\n    3\n    2\n    3\n    0\n    1\n    0\n    \nNote\n\nLet's consider the first example of input data.\n\nIf we lay the road after the first house, there will be one house a_1 = 1 on\nthe left side of the street, the resident of which would like to live on the\nright side of the street. Then 0 out of 1 residents on the even side will be\nsatisfied with the choice, which means that the road cannot be laid after\nhouse 1 .\n\nIf we lay the road after the second house, 1 out of 2 residents on the left\nside (with preferences a_1 = 1 , a_2 = 0 ) and 1 out of 1 resident on the\nright side (with preference a_3 = 1 ) will be satisfied with the choice. More\nthan half of the residents on each side are satisfied with the choice, which\nmeans that the road can be laid after house 2 . We can show that this is the\noptimal answer.",
        "task_name": "1945-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "# at least half of the residents on each side of the village are satisfied with the choice (⌈x / 2⌉)\n# as close to the middle of the village as possible\nfrom math import ceil\nfor i in range(int(input())):\n    n = int(input())\n    array = [int(i) for i in input()]\n    x, y = 0, 0\n    n1, n2 = n // 2, n - n // 2\n    if n % 2 == 0:\n        for i in range(n // 2):\n            if array[i] == 0:\n                x += 1\n        for i in range(n // 2, n):\n            if array[i] == 1:\n                y += 1\n        if x >= ceil(n1 / 2) and y >= ceil(n2 / 2):\n            print(n // 2)\n        else:\n            temp1, temp2 = x, y\n            inx, inx2 = -1, -1\n            for i in range(n // 2 + 1, n):\n                if array[i] == 0:\n                    x += 1\n                elif array[i] == 1:\n                    y -= 1\n                n1 += 1\n                n2 -= 1\n                if x >= ceil(n1 / 2) and y >= ceil(n2 / 2):\n                    inx = i + 1\n                    break\n            x, y = temp1, temp2\n            for i in range(n // 2 - 1, -1, -1):\n                if  array[i] == 0:\n                    x -= 1\n                elif array[i] == 1:\n                    y += 1\n                n1 -= 1\n                n2 += 1\n                if x >= ceil(n1 / 2) and y >= ceil(n2 / 2):\n                    inx2 = i + 1\n                    break\n            if inx == inx2 == -1:\n                print(0)\n            elif inx != -1 and inx2 != -1:\n                print(min(inx, inx2))\n            else:\n                if inx == -1:\n                    print(inx2)\n                else:\n                    print(inx)\n    else:\n        for i in range(n // 2): # 0\n            if array[i] == 0:\n                x += 1\n        for i in range(n // 2, n): # 1, 2\n            if array[i] == 1:\n                y += 1\n        if x >= ceil(n1 / 2) and y >= ceil(n2 / 2):\n            print(n // 2)\n        else:\n            temp1, temp2 = x, y\n            inx, inx2 = -1, -1\n            for i in range(n // 2, n): \n                if array[i] == 0:\n                    x += 1\n                elif array[i] == 1:\n                    y -= 1\n                n1 += 1\n                n2 -= 1\n                if x >= ceil(n1 / 2) and y >= ceil(n2 / 2):\n                    inx = i + 1\n                    break\n            x, y = temp1, temp2\n            for i in range(n // 2 - 1, -1, -1):\n                if  array[i] == 0:\n                    x -= 1\n                elif array[i] == 1:\n                    y += 1\n                n1 -= 1\n                n2 += 1\n                if x >= ceil(n1 / 2) and y >= ceil(n2 / 2):\n                    inx2 = i + 1\n                    break\n            if inx == inx2 == -1:\n                print(0)\n            elif inx != -1 and inx2 != -1:\n                print(inx, inx2)\n            else:\n                if inx == -1:\n                    print(inx2)\n                else:\n                    print(inx)",
        "correct": false,
        "task_id": 94
    },
    {
        "description": "You and Nene are playing a card game. The deck with 2n cards is used to play\nthis game. Each card has an integer from 1 to n on it, and each of integers 1\nthrough n appears exactly on 2 cards. Additionally, there is a table where\ncards are placed during the game (initially, the table is empty).\n\nIn the beginning of the game, these 2n cards are distributed between you and\nNene so that each player receives n cards.\n\nAfter it, you and Nene alternatively take 2n turns, i.e. each person takes n\nturns, starting with you. On each turn:\n\n  * The player whose turn is it selects one of the cards in his hand. Let x be the number on it. \n  * The player whose turn is it receives 1 point if there is already a card with the integer x on the table (otherwise, he receives no points). After it, he places the selected card with the integer x on the table. \n\nNote that turns are made publicly: each player can see all the cards on the\ntable at each moment.\n\nNene is very smart so she always selects cards optimally in order to maximize\nher score in the end of the game (after 2n rounds). If she has several optimal\nmoves, she selects the move that minimizes your score in the end of the game.\n\nMore formally, Nene always takes turns optimally in order to maximize her\nscore in the end of the game in the first place and to minimize your score in\nthe end of the game in the second place.\n\nAssuming that the cards are already distributed and cards in your hand have\nintegers a_1, a_2, \\ldots, a_n written on them, what is the maximum number of\npoints you can get by taking your turns optimally?\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^4 ). The description of test cases follows.\n\nThe first line contains a single integer n (1 \\le n \\le 2 \\cdot 10^5 ) — the\nnumber of cards you and Nene receive in the beginning of the game.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le n ) —\nthe integers on the cards in your hand. It is guaranteed that each integer\nfrom 1 through n appears in the sequence a_1, a_2, \\ldots, a_n at most 2\ntimes.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output one integer: the maximum number of points you can\nget.\n\nExample\n\nInput\n\n    5\n    \n    4\n    \n    1 1 2 3\n    \n    8\n    \n    7 4 1 2 8 8 5 5\n    \n    8\n    \n    7 1 4 5 3 4 2 6\n    \n    3\n    \n    1 2 3\n    \n    1\n    \n    1\n\nOutput\n\n    1\n    2\n    1\n    0\n    0\n    \nNote\n\nIn the first test case, the integers written on your cards are 1 , 1 , 2 and 3\n. The integers written on Nene's cards are 2 , 3 , 4 and 4 . The game may\nproceed as follows:\n\n  1. You select one of the cards with an integer 1 written on it and place it on the table. \n  2. Nene selects one of the cards with an integer 4 written on it and places it on the table. \n  3. You select the card with an integer 1 written on it, receive 1 point, and place the selected card on the table. \n  4. Nene selects the card with an integer 4 written on it, receive 1 point, and places the selected card on the table. \n  5. You select the card with an integer 2 written on it and place it on the table. \n  6. Nene selects the card with an integer 2 written on it, receive 1 point, and places the selected card on the table. \n  7. You select the card with an integer 3 written on it and place it on the table. \n  8. Nene selects the card with an integer 3 written on it, receive 1 point, and places the selected card on the table. \n\nAt the end of the game, you scored 1 point, and Nene scored 3 . It can be\nshown that you cannot score more than 1 point if Nene plays optimally, so the\nanswer is 1 .\n\nIn the second test case, if both players play optimally, you score 2 points\nand Nene scores 6 points.",
        "task_name": "1956-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for s in[*open(0)][2::2]:print(len(a:=s.split())-len({*a}))",
        "correct": true,
        "task_id": 146
    },
    {
        "description": "You are given an array a_1, a_2, \\ldots, a_n .\n\nIn one move, you can perform either of the following two operations:\n\n  * Choose an element from the array and remove it from the array. As a result, the length of the array decreases by 1 ;\n  * Choose an element from the array and increase its value by 1 . \n\nYou can perform any number of moves. If the current array becomes empty, then\nno more moves can be made.\n\nYour task is to find the minimum number of moves required to make the sum of\nthe elements of the array a divisible by 3 . It is possible that you may need\n0 moves.\n\nNote that the sum of the elements of an empty array (an array of length 0 ) is\nequal to 0 .\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 10^5\n).\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^4 ).\n\nThe sum of n over all test cases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer: the minimum number of moves.\n\nExample\n\nInput\n\n    8\n    \n    4\n    \n    2 2 5 4\n    \n    3\n    \n    1 3 2\n    \n    4\n    \n    3 7 6 8\n    \n    1\n    \n    1\n    \n    4\n    \n    2 2 4 2\n    \n    2\n    \n    5 5\n    \n    7\n    \n    2 4 8 1 9 3 4\n    \n    2\n    \n    4 10\n\nOutput\n\n    1\n    0\n    0\n    1\n    1\n    2\n    1\n    1\n    \nNote\n\nIn the first test case, initially the array a = [2, 2, 5, 4] . One of the\noptimal ways to make moves is:\n\n  * remove the current 4 th element and get a = [2, 2, 5] ; \n\nAs a result, the sum of the elements of the array a will be divisible by 3\n(indeed, a_1 + a_2 + a_3 = 2 + 2 + 5 = 9 ).\n\nIn the second test case, initially, the sum of the array is 1+3+2 = 6 , which\nis divisible by 3 . Therefore, no moves are required. Hence, the answer is 0 .\n\nIn the fourth test case, initially, the sum of the array is 1 , which is not\ndivisible by 3 . By removing its only element, you will get an empty array, so\nits sum is 0 . Hence, the answer is 1 .",
        "task_name": "1933-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "# This is a sample Python script.\na = int(input())\nb = int(input())\nc = list(map(int, input().split()))\ns = 0\ny = 0\nfor i in range(b):\n    s += c[i]\n    if c[i] % 3 == 1:\n        y += 1\nif s % 3 == 0:\n    print(0)\nif s % 3 == 2:\n    print(1)\nif s % 3 == 1:\n    if y > 0:\n        print(1)\n    else:\n        print(2)",
        "correct": false,
        "task_id": 125
    },
    {
        "description": "Fox has found an array p_1, p_2, \\ldots, p_n , that is a permutation of length\nn^\\dagger of the numbers 1, 2, \\ldots, n . She wants to sort the elements in\nincreasing order. Cat wants to help her — he is able to swap any two numbers x\nand y in the array, but only if l \\leq x + y \\leq r (note that the constraint\nis imposed on the values of the elements, not their positions). He can make\nsuch swaps any number of times.\n\nThey don't know the numbers l , r yet, they only know that it's true that 1\n\\leq l \\leq r \\leq 2 \\cdot n .\n\nYou are given the number n and the array p_1, p_2, \\ldots, p_n . Determine how\nmany pairs (l, r) satisfying the conditions are there such that you can sort\nthe permutation if you can only swap two number (x, y) such that l \\leq x + y\n\\leq r (arbitrary number of times, possibly 0 ).\n\n^\\dagger A permutation of length n is an array consisting of n distinct\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\npermutation, but [1,2,2] is not a permutation (2 appears twice in the array),\nand [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^4 ). The description of the test cases follows.\n\nDescription of each test case consists of two lines. The first line contains\none integer n (1 \\leq n \\leq 10^5 ).\n\nThe second line contains n integers: the array p_1, p_2, \\ldots, p_n (1 \\le\np_i \\le n ). It is guaranteed that this array is a permutation of length n .\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, print the number of pairs of integers (l, r) such that 1\n\\leq l \\leq r \\leq 2 \\cdot n , and you can sort the array under the\nconstraints.\n\nExample\n\nInput\n\n    7\n    \n    2\n    \n    2 1\n    \n    3\n    \n    3 1 2\n    \n    4\n    \n    3 2 1 4\n    \n    5\n    \n    5 3 1 2 4\n    \n    5\n    \n    1 2 3 4 5\n    \n    6\n    \n    3 2 1 5 4 6\n    \n    6\n    \n    1 3 2 4 5 6\n\nOutput\n\n    6\n    11\n    23\n    29\n    55\n    46\n    58\n    \nNote\n\nIn the first example, we need to be able to swap 1 and 2 , so we must be able\nto swap numbers with sum 3 . There are exactly 6 pairs satisfying the\ncondition: (1, 3), (2, 3), (3, 3), (1, 4), (2, 4) and (3, 4) , so the answer\nis 6 .\n\nIn the second example, the 11 pairs satisfying the condition are (1, 4), (1,\n5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6), (4, 5) and (4, 6)\n. For example, if we pick the pair (3, 4) we can first swap the numbers 1 and\n2 and then the numbers 1 and 3 , after this, the permutation is sorted.",
        "task_name": "1973-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "ans = []\n \nfor t in range(int(input())):\n\tn = int(input())\n\tp = [int(x) for x in input().split()]\n \n\ttotal = 2*n + n*(2*n-1)\n \n\t#l = r\n\ttrick = -1\n\tunsort = []\n\tfor i in range(n):\n\t\tif p[i] == i+1:\n\t\t\tcontinue\n\t\tunsort.append(i+1)\n\t\tif trick == -1:\n\t\t\ttrick = i+1+p[i]\n\t\telif not trick == i+1+p[i]:\n\t\t\ttrick = -2\n\tif trick > 0: total -= (2*n-1)\n\tif trick == -2: total -= 2*n\n \n\tif len(unsort) > 0:\n\t\ta = n - unsort[0]\n\t\ttotal -= a*(a-1)//2\n\t\tb = unsort[-1]\n\t\ttotal -= b*(b-1)//2\n \n\tans.append(total)\n\t\t\n \nfor a in ans:\n\tprint(a)",
        "correct": true,
        "task_id": 66
    },
    {
        "description": "Being a physicist, Charlie likes to plan his life in simple and precise terms.\n\nFor the next m months, starting with no money, Charlie will work hard and earn\nx pounds per month. For the i -th month (1 \\le i \\le m) , there'll be a single\nopportunity of paying cost c_i pounds to obtain happiness h_i .\n\nBorrowing is not allowed. Money earned in the i -th month can only be spent in\na later j -th month (j>i ).\n\nSince physicists don't code, help Charlie find the maximum obtainable sum of\nhappiness.\n\nInput\n\nThe first line of input contains a single integer t (1 \\le t \\le 1000 ) — the\nnumber of test cases.\n\nThe first line of each test case contains two integers, m and x (1 \\le m \\le\n50 , 1 \\le x \\le 10^8 ) — the total number of months and the monthly salary.\n\nThe i -th of the following m lines contains two integers, c_i and h_i (0 \\le\nc_i \\le 10^8 , 1 \\le h_i \\le 10^3 ) — the cost and happiness on offer for the\ni -th month. Note that some happiness may be free (c_i=0 for some i 's).\n\nIt is guaranteed that the sum of \\sum_i h_i over all test cases does not\nexceed 10^5 .\n\nOutput\n\nFor each test case, print a single integer, the maximum sum of happiness\nCharlie could obtain.\n\nExample\n\nInput\n\n    7\n    \n    1 10\n    \n    1 5\n    \n    2 80\n    \n    0 10\n    \n    200 100\n    \n    3 100\n    \n    70 100\n    \n    100 200\n    \n    150 150\n    \n    5 8\n    \n    3 1\n    \n    5 3\n    \n    3 4\n    \n    1 5\n    \n    5 3\n    \n    2 5\n    \n    1 5\n    \n    2 1\n    \n    5 3\n    \n    2 5\n    \n    2 4\n    \n    4 1\n    \n    5 1\n    \n    3 4\n    \n    5 2\n    \n    2 1\n    \n    1 2\n    \n    3 5\n    \n    3 2\n    \n    3 2\n\nOutput\n\n    0\n    10\n    200\n    15\n    1\n    9\n    9\n    \nNote\n\nIn the first test case, Charlie only gets paid at the end of the month, so is\nunable to afford anything.\n\nIn the second test case, Charlie obtains the free happiness in the first\nmonth.\n\nIn the third test case, it's optimal for Charlie to buy happiness in the\nsecond month. Even with money left at the end, Charlie could not go back in\ntime to obtain the happiness on offer in the first month.",
        "task_name": "1974-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    m, x = map(int, input().split())\n    l = [tuple(map(int, input().split())) for _ in range(m)]\n    s = sum(j for _, j in l)\n    dp = [float('inf')] * (s + 1)\n    dp[0] = 0\n    for i in range(m):\n        c, h = l[i]\n        for k in range(s, h - 1, -1):\n            if dp[k - h] + c <= i * x:\n                dp[k] = min(dp[k], dp[k - h] + c)\n\n    for k in range(s, -1, -1):\n        if dp[k] != float('inf'):\n            print(k)\n            break\n    else:\n        print(0)",
        "correct": true,
        "task_id": 73
    },
    {
        "description": "There are n people in the programming contest chat. Chat participants are\nordered by activity, but each person sees himself at the top of the list.\n\nFor example, there are 4 participants in the chat, and their order is [2, 3,\n1, 4] . Then\n\n  * 1 -st user sees the order [1, 2, 3, 4] . \n  * 2 -nd user sees the order [2, 3, 1, 4] . \n  * 3 -rd user sees the order [3, 2, 1, 4] . \n  * 4 -th user sees the order [4, 2, 3, 1] . \n\nk people posted screenshots in the chat, which show the order of participants\nshown to this user. The screenshots were taken within a short period of time,\nand the order of participants has not changed.\n\nYour task is to determine whether there is a certain order that all\nscreenshots correspond to.\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ninput test cases. The descriptions of test cases follow.\n\nThe first line of the description of each test case contains two integers n\nand k (1 \\le k \\le n \\le 2 \\cdot 10^5, n \\cdot k \\le 2 \\cdot 10^5 ) — the\nnumber of chat participants and the number of participants who posted\nscreenshots.\n\nThe following k lines contain descriptions of screenshots posted by the\nparticipants.\n\nThe i -th row contains n integers a_{ij} each (1 \\le a_{ij} \\le n , all a_{ij}\nare different) — the order of participants shown to the participant a_{i0} ,\nwhere a_{i0} — the author of the screenshot. You can show that in the\nscreenshot description it will always be at the top of the list.\n\nIt is guaranteed that the sum of n \\cdot k for all test cases does not exceed\n2 \\cdot 10^5 . It is also guaranteed that all the authors of the screenshots\nare different.\n\nOutput\n\nOutput t lines, each of which is the answer to the corresponding test case. As\nan answer, output \"YES\" if there exists at least one order of participants,\nunder which all k screenshots could have been obtained. Otherwise, output\n\"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the\nstrings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive\nresponses.\n\nExample\n\nInput\n\n    10\n    \n    5 1\n    \n    1 2 3 4 5\n    \n    4 4\n    \n    1 2 3 4\n    \n    2 3 1 4\n    \n    3 2 1 4\n    \n    4 2 3 1\n    \n    6 2\n    \n    1 3 5 2 4 6\n    \n    6 3 5 2 1 4\n    \n    3 3\n    \n    1 2 3\n    \n    2 3 1\n    \n    3 2 1\n    \n    10 2\n    \n    1 2 3 4 5 6 7 8 9 10\n    \n    10 9 8 7 6 5 4 3 2 1\n    \n    1 1\n    \n    1\n    \n    5 2\n    \n    1 2 3 5 4\n    \n    2 1 3 5 4\n    \n    3 3\n    \n    3 1 2\n    \n    2 3 1\n    \n    1 3 2\n    \n    5 4\n    \n    3 5 1 4 2\n    \n    2 5 1 4 3\n    \n    1 5 4 3 2\n    \n    5 1 4 3 2\n    \n    3 3\n    \n    1 3 2\n    \n    2 1 3\n    \n    3 2 1\n\nOutput\n\n    YES\n    YES\n    YES\n    YES\n    NO\n    YES\n    YES\n    YES\n    YES\n    NO",
        "task_name": "1931-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\n\ninput = stdin.readline\n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    \n    # Graph representation: G[i] contains nodes that i points to\n    G = [set() for _ in range(n + 1)]\n    # In-degree array: I[i] is the number of edges pointing to i\n    I = [0] * (n + 1)\n    \n    for _ in range(k):\n        a = list(map(int, input().split()))\n        # Create directed edges based on the screenshot\n        for a, b in zip(a[1:], a[2:]):\n            if b not in G[a]:\n                G[a].add(b)\n                I[b] += 1\n    \n    # Queue for topological sorting\n    Q = [i for i in range(1, n + 1) if I[i] == 0]\n    C = 0  # Counter for number of nodes processed\n    \n    # Process nodes with zero in-degree\n    for x in Q:\n        C += 1\n        for y in G[x]:\n            I[y] -= 1\n            if I[y] == 0:\n                Q.append(y)\n    \n    # If all nodes are processed, a valid order exists\n    stdout.write(\"YES\\n\" if C == n else \"NO\\n\")",
        "correct": true,
        "task_id": 353
    },
    {
        "description": "Define a function f such that for an array b , f(b) returns the array of\nprefix maxima of b . In other words, f(b) is an array containing only those\nelements b_i , for which b_i=\\max(b_1,b_2,\\ldots,b_i) , without changing their\norder. For example, f([3,10,4,10,15,1])=[3,10,10,15] .\n\nYou are given a tree consisting of n nodes rooted at 1 .\n\nA permutation^\\dagger p of is considered a pre-order of the tree if for all i\nthe following condition holds:\n\n  * Let k be the number of proper descendants^\\ddagger of node p_i . \n  * For all x such that i < x \\leq i+k , p_x is a proper descendant of node p_i . \n\nFind the number of distinct values of f(a) over all possible pre-orders a .\nSince this value might be large, you only need to find it modulo 998\\,244\\,353\n.\n\n^\\dagger A permutation of length n is an array consisting of n distinct\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\npermutation, but [1,2,2] is not a permutation (2 appears twice in the array),\nand [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\n^\\ddagger Node t is a proper descendant of node s if s \\neq t and s is on the\nunique simple path from t to 1 .\n\nInput\n\nEach test contains multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^5 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\leq n \\leq\n10^6 ) — the number of vertices.\n\nThe following next n-1 lines contain two integers u and v (1 \\leq u, v \\leq n\n, u \\neq v ) — denoting an edge between nodes u and v . It is guaranteed that\nthe given edges form a tree.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6 .\n\nOutput\n\nFor each test case, output the number of distinct values of f(a) modulo\n998\\,244\\,353 that you can get.\n\nExample\n\nInput\n\n    6\n    \n    1\n    \n    2\n    \n    1 2\n    \n    3\n    \n    1 2\n    \n    1 3\n    \n    3\n    \n    1 2\n    \n    2 3\n    \n    5\n    \n    1 2\n    \n    1 3\n    \n    1 4\n    \n    1 5\n    \n    10\n    \n    1 2\n    \n    2 3\n    \n    1 4\n    \n    2 5\n    \n    2 6\n    \n    4 7\n    \n    5 8\n    \n    4 9\n    \n    9 10\n\nOutput\n\n    1\n    1\n    2\n    1\n    8\n    6\n    \nNote\n\nIn the first test case, the only valid pre-order is a=[1] . So the only\npossible value of f(a) is [1] .\n\nIn the second test case, the only valid pre-order is a=[1,2] . So the only\npossible value f(a) is [1,2] .\n\nIn the third test case, the two valid pre-orders are a=[1,2,3] and a=[1,3,2] .\nSo the possible values of f(a) are [1,2,3] and [1,3] .\n\nIn the fifth test case, the possible values of f(a) are:\n\n  * [1,5] ; \n  * [1,2,5] ; \n  * [1,3,5] ; \n  * [1,4,5] ; \n  * [1,2,3,5] ; \n  * [1,2,4,5] ; \n  * [1,3,4,5] ; \n  * [1,2,3,4,5] .",
        "task_name": "1930-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef f(b):\n    prefix_max = []\n    current_max = float('-inf')\n    for num in b:\n        if num > current_max:\n            current_max = num\n            prefix_max.append(num)\n    return prefix_max\n\ndef generate_pre_orders(node, tree, visited, current_order):\n    visited[node] = True\n    current_order.append(node)\n    for child in tree[node]:\n        if not visited[child]:\n            generate_pre_orders(child, tree, visited, current_order)\n\ndef count_distinct_prefix_max(n, edges):\n    tree = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    pre_orders = []\n    for root in range(1, n + 1):\n        visited = [False] * (n + 1)\n        current_order = []\n        generate_pre_orders(root, tree, visited, current_order)\n        pre_orders.append(current_order)\n    \n    distinct_prefix_max = set()\n    for order in pre_orders:\n        prefix_max = tuple(f(order))\n        distinct_prefix_max.add(prefix_max)\n    \n    return len(distinct_prefix_max) % 998244353\n\n# Input reading\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    print(count_distinct_prefix_max(n, edges))",
        "correct": false,
        "task_id": 320
    },
    {
        "description": "This is an interactive problem.\n\nThere is a secret sequence p_0, p_1, \\ldots, p_{n-1} , which is a permutation\nof \\\\{0,1,\\ldots,n-1\\\\} .\n\nYou need to find any two indices i and j such that p_i \\oplus p_j is\nmaximized, where \\oplus denotes the [bitwise XOR\noperation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nTo do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \\le a,b,c,d < n ). Next, the jury calculates x = (p_a \\mid p_b) and y = (p_c \\mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .\n\nPlease find any two indices i and j (0 \\le i,j < n ) such that p_i \\oplus p_j\nis maximum among all such pairs, using at most 3n queries. If there are\nmultiple pairs of indices satisfying the condition, you may output any one of\nthem.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 10^3 ). The description of the test cases follows.\n\nInteraction\n\nThe first line of each test case contains one integer n (2 \\le n \\le 10^4 ).\nAt this moment, the permutation p_0, p_1, \\ldots, p_{n-1} is chosen. The\ninteractor in this task is not adaptive. In other words, the sequence p is\nfixed in every test case and does not change during the interaction.\n\nTo ask a query, you need to pick four indices a , b , c , and d (0 \\le a,b,c,d\n< n ) and print the line of the following form:\n\n  * \"? a b c d\" \n\nAfter that, you receive:\n\n  * \"<\" if (p_a \\mid p_b) < (p_c \\mid p_d) ; \n  * \"=\" if (p_a \\mid p_b) = (p_c \\mid p_d) ; \n  * \">\" if (p_a \\mid p_b) > (p_c \\mid p_d) . \n\nYou can make at most 3n queries of this form.\n\nNext, if your program has found a pair of indices i and j (0 \\le i, j < n )\nsuch that p_i \\oplus p_j is maximized, print the line of the following form:\n\n  * \"! i j\" \n\nNote that this line is not considered a query and is not taken into account\nwhen counting the number of queries asked.\n\nAfter this, proceed to the next test case.\n\nIf you make more than 3n queries during an interaction, your program must\nterminate immediately, and you will receive the Wrong Answer verdict.\nOtherwise, you can get an arbitrary verdict because your solution will\ncontinue to read from a closed stream.\n\nAfter printing a query or the answer for a test case, do not forget to output\nthe end of line and flush the output. Otherwise, you will get the verdict\nIdleness Limit Exceeded. To do this, use:\n\n  * fflush(stdout) or cout.flush() in C++; \n  * System.out.flush() in Java; \n  * flush(output) in Pascal; \n  * stdout.flush() in Python; \n  * see the documentation for other languages. \n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4 .\n\nHacks\n\nTo hack, follow the test format below.\n\nThe first line contains the number of test cases t (1 \\le t \\le 10^3 ). The\ndescription of the test cases follows.\n\nThe first line of each test case contains one integer n (2 \\le n \\le 10^4 ).\n\nThe second line of each test case contains n integers p_0,p_1,\\ldots,p_{n-1} ,\nwhich represent a permutation of integers from 0 to n - 1 .\n\nThe sum of n over all test cases should not exceed 10^4 .\n\nExample\n\nInput\n\n    2\n    4\n    \n    <\n    \n    =\n    \n    >\n    \n    2\n    \nOutput\n\n    ? 0 2 3 1\n    \n    ? 1 1 2 3\n    \n    ? 1 2 0 3\n    \n    ! 3 2\n    \n    ! 0 1\n    \nNote\n\nIn the first test case, the hidden permutation is p=[0,3,1,2] .\n\nFor the query \"? 0 2 3 1\", the jury return \"<\" because (p_0 \\mid p_2) = (0\n\\mid 1) =1 < (p_3 \\mid p_1) = (2 \\mid 3) = 3 .\n\nFor the query \"? 1 1 2 3\", the jury return \"=\" because (p_1 \\mid p_1) = (3\\mid\n3)= 3 = (p_2 \\mid p_3) = (1 \\mid 2)=3 .\n\nFor the query \"? 1 2 0 3\", the jury return \">\" because (p_1 \\mid p_2) = (3\n\\mid 1) = 3 > (p_0 \\mid p_3) = (0\\mid 2)=2 .\n\nThe answer i = 3 and j = 2 is valid: (p_3 \\oplus p_2) = (2 \\oplus 1) = 3 is\nindeed equal to the maximum possible value of p_i \\oplus p_j . Another valid\nanswer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,\nthe answer is considered correct.\n\nIn the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any\ncase, p_0 \\oplus p_1 = 1 is maximum possible.",
        "task_name": "1936-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def find(a,b,c,d):\n    print(\"?\",a,b,c,d)\n    return input()\n    \nfor _ in range(int(input())):\n    n = int(input())\n    ans1 = 0\n    for i in range(1,n):\n        x = find(ans1,ans1,i,i)\n        if x == \"<\":\n            ans1 = i\n    mx = 0\n    v = [0]\n    # print(ans1)\n    for i in range(1,n):\n        x = find(mx,ans1,i,ans1)\n        if x == \"<\":\n            v = []\n            mx = i\n            v.append(i)\n        elif x ==\"=\":\n            v.append(i)\n    mx= v[0]\n    # print(v)\n    ans = v[0]\n    for i in range(1,len(v)):\n        x = find(ans,ans,v[i],v[i])\n        if x == \">\":\n            ans = v[i]\n    print(\"!\", ans,ans1)",
        "correct": true,
        "task_id": 350
    },
    {
        "description": "The organizing committee plans to take the participants of the Olympiad on a\nhike after the tour. Currently, the number of tents needed to be taken is\nbeing calculated. It is known that each tent can accommodate up to 3 people.\n\nAmong the participants, there are a introverts, b extroverts, and c\nuniversals:\n\n  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. \n  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. \n  * Each universal is fine with any option (living alone, with one other person, or with two others). \n\nThe organizing committee respects the wishes of each participant very much, so\nthey want to fulfill all of them.\n\nTell us the minimum number of tents needed to be taken so that all\nparticipants can be accommodated according to their preferences. If it is\nimpossible to accommodate the participants in a way that fulfills all the\nwishes, output -1 .\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^4 ) — the number of test cases. This is followed by\nthe descriptions of the test cases.\n\nEach test case is described by a single line containing three integers a , b ,\nc (0 \\le a, b, c \\le 10^9 ) — the number of introverts, extroverts, and\nuniversals, respectively.\n\nOutput\n\nFor each test case, output a single integer — the minimum number of tents, or\n-1 if it is impossible to accommodate the participants.\n\nExample\n\nInput\n\n    10\n    \n    1 2 3\n    \n    1 4 1\n    \n    1 4 2\n    \n    1 1 1\n    \n    1 3 2\n    \n    19 7 18\n    \n    0 0 0\n    \n    7 0 0\n    \n    0 24 0\n    \n    1000000000 1000000000 1000000000\n\nOutput\n\n    3\n    -1\n    3\n    -1\n    3\n    28\n    0\n    7\n    8\n    1666666667\n    \nNote\n\nIn the first test case, 1 tent will be given to the introverts, 1 tent will be\nshared by two extroverts and one universal, and the last tent will be shared\nby two universals. In total, 3 tents are needed.\n\nIn the second test case, three extroverts will take 1 tent, and 1 tent will be\ntaken by an introvert. Then, one extrovert and one universal will be left.\nThis extrovert will not be able to live with two others.",
        "task_name": "1945-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from math import ceil\nt = int(input())\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    extra = b%3\n    if extra and 3 - extra > c:\n        print(-1)\n    else:\n        if 3 - extra <= c:\n            c -= 3 - extra\n        print(a + ceil(b/3) + ceil(c/3))",
        "correct": false,
        "task_id": 97
    },
    {
        "description": "Allen has an array a_1, a_2,\\ldots,a_n . For every positive integer k that is\na divisor of n , Allen does the following:\n\n  * He partitions the array into \\frac{n}{k} disjoint subarrays of length k . In other words, he partitions the array into the following subarrays: \n\n  * Allen earns one point if there exists some positive integer m (m \\geq 2 ) such that if he replaces every element in the array with its remainder when divided by m , then all subarrays will be identical. \n\nHelp Allen find the number of points he will earn.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\leq n \\leq\n2\\cdot10^5 ) — the length of the array a .\n\nThe second line of each test case contains n integers a_1, a_2,\\ldots, a_n (1\n\\leq a_i \\leq n ) — the elements of the array a .\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single integer — the number of points Allen will\nearn.\n\nExample\n\nInput\n\n    8\n    \n    4\n    \n    1 2 1 4\n    \n    3\n    \n    1 2 3\n    \n    5\n    \n    1 1 1 1 1\n    \n    6\n    \n    1 3 1 1 3 1\n    \n    6\n    \n    6 2 6 2 2 2\n    \n    6\n    \n    2 6 3 6 6 6\n    \n    10\n    \n    1 7 5 1 4 3 1 3 1 4\n    \n    1\n    \n    1\n\nOutput\n\n    2\n    1\n    2\n    4\n    4\n    1\n    2\n    1\n    \nNote\n\nIn the first test case, k=2 earns a point since Allen can pick m = 2 and both\nsubarrays will be equal to [1, 0] . k=4 also earns a point, since no matter\nwhat m Allen chooses, there will be only one subarray and thus all subarrays\nare equal.\n\nIn the second test case, Allen earns 1 point for k=3 , where his choice for m\ndoes not matter.",
        "task_name": "1920-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def get_positive_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i and n // i != n:\n                divisors.append(n // i)\n    return sorted(divisors)\n\ndef identical(arr, k):\n    # Return True if k is 1\n\n    # Compare the first subarray of length k with other segments\n    for i in range(k, n, k):\n        if arr[i:i+k] != arr[0:k]:\n            return False\n            \n    return True\n\n    \nt = int(input())\ntest_cases = [(int(input()), input()) for _ in range(t)]\nfor n, array in test_cases:\n    array=[int(i) for i in array.split()]\n    p=1\n    if (identical(array,1))and n >1:\n        p=len(get_positive_divisors(n))+1\n        print(p)\n        continue\n    elif (identical(array,1))and n ==1:\n        p=len(get_positive_divisors(n))\n        print(p)\n        continue\n    \n    array1=array\n    for k in get_positive_divisors(n):\n        m=2\n\n        array=array1\n        while m<=max(array):\n            array=[z%m for z in array]\n            if identical(array,k):\n                p+=1\n                break \n            m+=1\n    print(p)",
        "correct": false,
        "task_id": 106
    }
]