[
    {
        "description": "This is the easy version of the problem. The only difference between the two\nversions is the constraint on t and n . You can make hacks only if both\nversions of the problem are solved.\n\nFor a binary^\\dagger pattern p and a binary string q , both of length m , q is\ncalled p -good if for every i (1 \\leq i \\leq m ), there exist indices l and r\nsuch that:\n\n  * 1 \\leq l \\leq i \\leq r \\leq m , and \n  * p_i is a mode^\\ddagger of the string q_l q_{l+1} \\ldots q_{r} . \n\nFor a pattern p , let f(p) be the minimum possible number of \\mathtt{1} s in a\np -good binary string (of the same length as the pattern).\n\nYou are given a binary string s of size n . Find\n\nIn other words, you need to sum the values of f over all \\frac{n(n+1)}{2}\nsubstrings of s .\n\n^\\dagger A binary pattern is a string that only consists of characters\n\\mathtt{0} and \\mathtt{1} .\n\n^\\ddagger Character c is a mode of string t of length m if the number of\noccurrences of c in t is at least \\lceil \\frac{m}{2} \\rceil . For example,\n\\mathtt{0} is a mode of \\mathtt{010} , \\mathtt{1} is not a mode of\n\\mathtt{010} , and both \\mathtt{0} and \\mathtt{1} are modes of \\mathtt{011010}\n.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 500 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 100\n) — the length of the binary string s .\n\nThe second line of each test case contains a binary string s of length n\nconsisting of only characters \\mathtt{0} and \\mathtt{1} .\n\nIt is guaranteed that the sum of n^2 over all test cases does not exceed 10^4\n.\n\nOutput\n\nFor each test case, output the sum of values of f over all substrings of s .\n\nExample\n\nInput\n\n    4\n    \n    1\n    \n    1\n    \n    2\n    \n    10\n    \n    5\n    \n    00000\n    \n    20\n    \n    11110110000000111111\n\nOutput\n\n    1\n    2\n    0\n    346\n    \nNote\n\nIn the first test case, the only \\mathtt{1} -good string is \\mathtt{1} . Thus,\nf(\\mathtt{1})=1 .\n\nIn the second test case, f(\\mathtt{10})=1 because \\mathtt{01} is \\mathtt{10}\n-good, and \\mathtt{00} is not \\mathtt{10} -good. Thus, the answer is\nf(\\mathtt{1})+f(\\mathtt{10})+f(\\mathtt{0}) = 1 + 1 + 0 = 2 .\n\nIn the third test case, f equals to 0 for all 1 \\leq i \\leq j \\leq 5 . Thus,\nthe answer is 0 .",
        "task_name": "1930-D1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    num_cases = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(num_cases):\n        n = int(data[index])\n        index += 1\n        s = data[index]\n        index += 1\n        \n        # Initialize the DP array\n        dp = [0] * (n + 1)\n        result = 0\n        \n        # Traverse the string from the end to the beginning\n        for i in range(n - 1, -1, -1):\n            if s[i] == '1':\n                # If the current character is '1', calculate the contribution\n                dp[i] = n - i + dp[i + 1]\n            else:\n                # If the current character is '0', carry forward the previous value\n                dp[i] = dp[i + 1]\n        \n        # Sum up all the values in the DP array\n        result = sum(dp[:n])\n        \n        # Store the result for the current test case\n        results.append(result)\n    \n    # Output all results\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    solve()",
        "correct": false,
        "task_id": 325
    },
    {
        "description": "Sasha has two binary strings s and t of the same length n , consisting of the\ncharacters 0 and 1.\n\nThere is also a computing machine that can perform two types of operations on\nbinary strings a and b of the same length k :\n\n  1. If a_{i} = a_{i + 2} = 0, then you can assign b_{i + 1} := 1 (1 \\le i \\le k - 2 ). \n  2. If b_{i} = b_{i + 2} = 1, then you can assign a_{i + 1} := 1 (1 \\le i \\le k - 2 ). \n\nSasha became interested in the following: if we consider the string\na=s_ls_{l+1}\\ldots s_r and the string b=t_lt_{l+1}\\ldots t_r , what is the\nmaximum number of 1 characters in the string a that can be obtained using the\ncomputing machine. Since Sasha is very curious but lazy, it is up to you to\nanswer this question for several pairs (l_i, r_i) that interest him.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^{4} ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 2\n\\cdot 10^5 ) — the length of the strings s and t .\n\nThe second line of each test case contains a binary string s of length n ,\nconsisting of the characters 0 and 1.\n\nThe third line of each test case contains a binary string t of length n ,\nconsisting of the characters 0 and 1.\n\nThe fourth line of each test case contains a single integer q (1 \\le q \\le 2\n\\cdot 10^5 ) — the number of queries.\n\nThe i -th of the following lines contains two integers l_{i} and r_{i} (1 \\le\nl_{i} \\le r_{i} \\le n ) — the boundaries of the i -th pair of substrings that\ninterest Sasha.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 and the sum of q over all test cases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output q integers — the answers to all queries.\n\nExample\n\nInput\n\n    3\n    \n    4\n    \n    1111\n    \n    0000\n    \n    2\n    \n    1 2\n    \n    2 4\n    \n    4\n    \n    1010\n    \n    1101\n    \n    2\n    \n    1 3\n    \n    1 4\n    \n    6\n    \n    010101\n    \n    011010\n    \n    5\n    \n    2 3\n    \n    1 6\n    \n    2 5\n    \n    4 4\n    \n    3 6\n\nOutput\n\n    2\n    3\n    2\n    3\n    1\n    4\n    3\n    1\n    2\n    \nNote\n\nIn the first test case:\n\n  * In the first query, a = 11, so the maximum number of 1 characters is 2 . \n  * In the second query, a = 111, so the maximum number of 1 characters is 3 . \n\nIn the second test case:\n\n  * In the first query, a = 101 and b = 110. No operations can be performed, so the maximum number of 1 characters is 2 . \n  * In the second query, a = 1010 and b = 1101. Since a_2 = a_4 = 0, we can assign b_3 := 1. Now b_1 = b_3 = 1, so we can assign a_2 := 1. The string a becomes 1110, so the maximum number of 1 characters is 3 .",
        "task_name": "1978-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def process_queries(t, test_cases):\n    results = []\n\n    for case in test_cases:\n        n, s, t, q, queries = case\n        case_result = []\n\n        for li, ri in queries:\n            li -= 1\n            a = list(s[li:ri])\n            b = list(t[li:ri])\n            k = ri - li\n\n            while True:\n                changes = 0\n                for i in range(k - 2):\n                    if a[i] == '0' and a[i + 2] == '0' and b[i + 1] == '1' and a[i + 1] == '0':\n                        a[i + 1] = '1'\n                        changes += 1\n                    if b[i] == '1' and b[i + 2] == '1' and a[i + 1] == '0':\n                        a[i + 1] = '1'\n                        changes += 1\n                if changes == 0:\n                    break\n\n            max_ones = a.count('1')\n            case_result.append(max_ones)\n\n        results.append(case_result)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    t = int(data[0])\n    idx = 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        s = data[idx]\n        idx += 1\n        t = data[idx]\n        idx += 1\n        q = int(data[idx])\n        idx += 1\n        queries = []\n\n        for __ in range(q):\n            li, ri = map(int, data[idx:idx + 2])\n            idx += 2\n            queries.append((li, ri))\n\n        test_cases.append((n, s, t, q, queries))\n\n    results = process_queries(t, test_cases)\n\n    output = []\n    for result in results:\n        output.append(\" \".join(map(str, result)))\n\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")",
        "correct": false,
        "task_id": 220
    },
    {
        "description": "You are given a tree with n vertices.\n\nYour task is to find the maximum number x such that it is possible to remove\nexactly k edges from this tree in such a way that the size of each remaining\nconnected component^{\\dagger} is at least x .\n\n^{\\dagger} Two vertices v and u are in the same connected component if there\nexists a sequence of numbers t_1, t_2, \\ldots, t_k of arbitrary length k ,\nsuch that t_1 = v , t_k = u , and for each i from 1 to k - 1 , vertices t_i\nand t_{i+1} are connected by an edge.\n\nInput\n\nEach test consists of several sets of input data. The first line contains a\nsingle integer t (1 \\le t \\le 10^4 ) — the number of sets of input data. This\nis followed by a description of the sets of input data.\n\nThe first line of each set of input data contains two integers n and k (1 \\le\nk < n \\le 10^5 ) — the number of vertices in the tree and the number of edges\nto be removed.\n\nEach of the next n - 1 lines of each set of input data contains two integers v\nand u (1 \\le v, u \\le n ) — the next edge of the tree.\n\nIt is guaranteed that the sum of the values of n for all sets of input data\ndoes not exceed 10^5 .\n\nOutput\n\nFor each set of input data, output a single line containing the maximum number\nx such that it is possible to remove exactly k edges from the tree in such a\nway that the size of each remaining connected component is at least x .\n\nExample\n\nInput\n\n    6\n    \n    5 1\n    \n    1 2\n    \n    1 3\n    \n    3 4\n    \n    3 5\n    \n    2 1\n    \n    1 2\n    \n    6 1\n    \n    1 2\n    \n    2 3\n    \n    3 4\n    \n    4 5\n    \n    5 6\n    \n    3 1\n    \n    1 2\n    \n    1 3\n    \n    8 2\n    \n    1 2\n    \n    1 3\n    \n    2 4\n    \n    2 5\n    \n    3 6\n    \n    3 7\n    \n    3 8\n    \n    6 2\n    \n    1 2\n    \n    2 3\n    \n    1 4\n    \n    4 5\n    \n    5 6\n\nOutput\n\n    2\n    1\n    3\n    1\n    1\n    2\n    \nNote\n\nThe tree in the first set of input data:\n\n![](https://espresso.codeforces.com/799bacd3be0dda357800fdfc3eadbf38ab259c51.png)\n\nAfter removing the edge 1 — 3 , the tree will look as follows:\n\n![](https://espresso.codeforces.com/a59ae10eeac1212e1e56fc7fe5f6a47764269104.png)\n\nThe tree has split into two connected components. The first component consists\nof two vertices: 1 and 2 . The second connected component consists of three\nvertices: 3, 4 and 5 . In both connected components, there are at least two\nvertices. It can be shown that the answer 3 is not achievable, so the answer\nis 2 .",
        "task_name": "1946-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "# Consulted editorial & ChatGPT\nfrom sys import stdin, setrecursionlimit\nimport threading\nsetrecursionlimit(10000000)\nthreading.stack_size(10**8)\n\ndef main():\n    def dfs(r, p, g):\n        s = 1\n        for v in a[r]:\n            if v != p:\n                s += dfs(v, r, g)\n        if s >= g:\n            c[0] += 1\n            return 0\n        return s\n    \n    d = stdin.read().splitlines()\n    i = 1\n    li = len(d)\n    o = []\n    while i < li:\n        n, k = map(int, d[i].split())\n        i += 1\n        a = [[] for _ in range(n + 1)]\n        for _ in range(n - 1):\n            u, v = map(int, d[i].split())\n            a[u].append(v)\n            a[v].append(u)\n            i += 1\n\n        l, r = 1, (n >> 1) + 1\n        while l <= r:\n            m = (l + r) >> 1\n            c = [0]\n            dfs(1, 0, m)\n            if c[0] >= k + 1:\n                l = m + 1\n            else:\n                r = m - 1\n        o.append(r)\n    print('\\n'.join(map(str, o)))\n\nthreading.Thread(target=main).start()",
        "correct": true,
        "task_id": 293
    },
    {
        "description": "Let \\operatorname{lowbit}(x) denote the value of the lowest binary bit of x ,\ne.g. \\operatorname{lowbit}(12)=4 , \\operatorname{lowbit}(8)=8 .\n\nFor an array a of length n , if an array s of length n satisfies\ns_k=\\left(\\sum\\limits_{i=k-\\operatorname{lowbit}(k)+1}^{k}a_i\\right)\\bmod\n998\\,244\\,353 for all k , then s is called the Fenwick Tree of a . Let's\ndenote it as s=f(a) .\n\nFor a positive integer k and an array a , f^k(a) is defined as follows:\n\nYou are given an array b of length n and a positive integer k . Find an array\na that satisfies 0\\le a_i < 998\\,244\\,353 and f^k(a)=b . It can be proved that\nan answer always exists. If there are multiple possible answers, you may print\nany of them.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\le t\\le 10^4 ). The description of the test cases follows.\n\nThe first line of each test case contains two positive integers n (1 \\leq n\n\\leq 2\\cdot 10^5 ) and k (1\\le k\\le 10^9 ), representing the length of the\narray and the number of times the function f is performed.\n\nThe second line of each test case contains an array b_1, b_2, \\ldots, b_n\n(0\\le b_i < 998\\,244\\,353 ).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, print a single line, containing a valid array a of length\nn .\n\nExample\n\nInput\n\n    2\n    \n    8 1\n    \n    1 2 1 4 1 2 1 8\n    \n    6 2\n    \n    1 4 3 17 5 16\n\nOutput\n\n    1 1 1 1 1 1 1 1\n    1 2 3 4 5 6\n    \nNote\n\nIn the first test case, it can be seen that\nf^1([1,1,1,1,1,1,1,1])=[1,2,1,4,1,2,1,8] .\n\nIn the second test case, it can be seen that\nf^2([1,2,3,4,5,6])=f^1([1,3,3,10,5,11])=[1,4,3,17,5,16] .",
        "task_name": "1967-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def lowbit(x):\n    return x & -x\n\ndef fenwick_transform(a, n):\n    s = [0] * n\n    for k in range(1, n + 1):\n        sum_value = 0\n        for i in range(k - lowbit(k) + 1, k + 1):\n            sum_value += a[i - 1]\n        s[k - 1] = sum_value % 998244353\n    return s\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    MOD = 998244353\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # We will simulate the reverse process\n        a = b[:]\n        for _ in range(min(n, k)):\n            a = fenwick_transform(a, n)\n        \n        results.append(' '.join(map(str, a)))\n    \n    sys.stdout.write('\\n'.join(results) + '\\n')",
        "correct": false,
        "task_id": 133
    },
    {
        "description": "import os def generate_files_for_html_in_range(start, end): # 获取当前目录下的所有子文件夹\ncurrent_dir = os.getcwd() subfolders = [f.path for f in\nos.scandir(current_dir) if f.is_dir()] for folder in subfolders: #\n检查文件夹名称是否在指定范围内 folder_name = os.path.basename(folder) if\nfolder_name.isdigit() and start <= int(folder_name) <= end: #\n获取子文件夹中的所有.html文件 html_files = [f for f in os.listdir(folder) if\nf.endswith('.html')] print(f\"Folder '{folder}' contains {len(html_files)} HTML\nfiles.\") # 为每个.html文件生成对应的文件 for html_file in html_files: base_name =\nos.path.splitext(html_file)[0] ac_file = os.path.join(folder,\nf\"{base_name}-ac.py\") wa_file = os.path.join(folder, f\"{base_name}-wa.py\") #\n创建文件 open(ac_file, 'w').close() open(wa_file, 'w').close() print(f\"Generated\nfiles: {ac_file}, {wa_file}\") if __name__ == \"__main__\": # 指定目录范围 start_range\n= 1951 end_range = 1980 generate_files_for_html_in_range(start_range,\nend_range)",
        "task_name": "1951-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    if s.count('1')%2 or n == 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")",
        "correct": false,
        "task_id": 160
    },
    {
        "description": "The guys lined up in a queue of n people, starting with person number i = 1 ,\nto ask Serafim the Owl about the meaning of life. Unfortunately, Kirill was\nvery busy writing the legend for this problem, so he arrived a little later\nand stood at the end of the line after the n -th person. Kirill is completely\ndissatisfied with this situation, so he decided to bribe some people ahead of\nhim.\n\nFor the i -th person in the queue, Kirill knows two values: a_i and b_i . If\nat the moment Kirill is standing at position i , then he can choose any\nposition j such that j < i and exchange places with the person at position j .\nIn this case, Kirill will have to pay him a_j coins. And for each k such that\nj < k < i , Kirill will have to pay b_k coins to the person at position k .\nKirill can perform this action any number of times.\n\nKirill is thrifty, so he wants to spend as few coins as possible, but he\ndoesn't want to wait too long, so Kirill believes he should be among the first\nm people in line.\n\nHelp Kirill determine the minimum number of coins he will have to spend in\norder to not wait too long.\n\nInput\n\nEach test consists of several sets of input data. The first line contains a\nsingle integer t (1 \\le t \\le 10^4 ) — the number of test cases. Then follows\nthe description of the test case.\n\nThe first line of each test case contains two integers n and m (1 \\le m \\le n\n\\le 200\\,000 ) — the number of people in the queue besides Kirill and the\nmaximum allowable final position of Kirill, respectively.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n separated by spaces\n(1 \\le a_i \\le 10^9 ).\n\nThe third line contains n integers b_1, b_2, \\dots, b_n separated by spaces (1\n\\le b_i \\le 10^9 ).\n\nIt is guaranteed that the sum of the values of n over all test cases does not\nexceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the minimum number of coins\nKirill needs to spend.\n\nExample\n\nInput\n\n    4\n    \n    4 2\n    \n    7 3 6 9\n    \n    4 3 8 5\n    \n    6 2\n    \n    6 9 7 1 8 3\n    \n    5 8 8 1 4 1\n    \n    7 7\n    \n    7 2 9 2 6 5 9\n    \n    9 1 10 7 1 4 9\n    \n    2 1\n    \n    2 3\n    \n    1 1\n\nOutput\n\n    14\n    22\n    9\n    3",
        "task_name": "1945-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    n,m = map(int,input().split())\n    a = list(map(int,input().split()))\n    b = list(map(int,input().split()))\n    dp = [0 for i in range(n)]\n    dp[-1] = min(a[-1],b[-1])\n    for i in range(n-2,m-1,-1):\n        dp[i] = dp[i + 1] + min(a[i],b[i])\n    dp[0] = a[0]\n    for i in range(1,m):\n        dp[i] = min(a[i],dp[i-1]+b[i])\n    if m == n:\n        print(dp[m-1])\n    else:\n        print(dp[m-1]+dp[m])",
        "correct": true,
        "task_id": 96
    },
    {
        "description": "There is a grid, consisting of 2 rows and n columns. The rows are numbered\nfrom 1 to 2 from top to bottom. The columns are numbered from 1 to n from left\nto right. Each cell of the grid contains an arrow pointing either to the left\nor to the right. No arrow points outside the grid.\n\nThere is a robot that starts in a cell (1, 1) . Every second, the following\ntwo actions happen one after another:\n\n  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); \n  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). \n\nYour task is to determine whether the robot can reach the cell (2, n) .\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntest cases.\n\nThe first line of each test case contains a single integer (2 \\le n \\le 2\n\\cdot 10^5 ).\n\nThe second line contains a string consisting of exactly n characters < and/or\n> — the first row of the grid.\n\nThe third line contains a string consisting of exactly n characters < and/or >\n— the second row of the grid.\n\nAdditional constraints on the input:\n\n  * n is even; \n  * there are no arrows pointing outside the grid; \n  * the sum of n over all test cases doesn't exceed 2 \\cdot 10^5 . \n\nOutput\n\nFor each test case, print YES if the robot can reach the cell (2, n) ;\notherwise, print NO.\n\nYou can print each letter in any case. For example, yes, Yes, YeS will all be\nrecognized as positive answer.\n\nExample\n\nInput\n\n    4\n    \n    4\n    \n    >><<\n    \n    >>><\n    \n    2\n    \n    ><\n    \n    ><\n    \n    4\n    \n    >>><\n    \n    >><<\n    \n    6\n    \n    >><<><\n    \n    ><>>><\n\nOutput\n\n    YES\n    YES\n    NO\n    YES\n    \nNote\n\nIn the first example, one of the possible paths looks as follows: (1, 1)\n\\rightarrow (1, 2) \\rightarrow (1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) .\n\nIn the second example, one of the possible paths looks as follows: (1, 1)\n\\rightarrow (2, 1) \\rightarrow (2, 2) .\n\nIn the third example, there is no way to reach the cell (2, 4) .\n\nIn the fourth example, one of the possible paths looks as follows: (1, 1)\n\\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (1, 2) \\rightarrow (1, 3)\n\\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (2, 5) \\rightarrow (2, 6) .",
        "task_name": "1948-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    for  i in range(1 ,n ,2):\n        if (i+1<n and a[i]== b[i+1] == \"<\") or (a[i] == b[i-1] == \"<\")  :\n            print(\"No\")\n            break\n    else:\n        print(\"yes\")",
        "correct": true,
        "task_id": 266
    },
    {
        "description": "You are given a tree, consisting of n vertices, numbered from 1 to n . Every\nvertex is colored in some color, denoted by an integer from 1 to n .\n\nA simple path of the tree is called beautiful if:\n\n  * it consists of at least 2 vertices; \n  * the first and the last vertices of the path have the same color; \n  * no other vertex on the path has the same color as the first vertex. \n\nCount the number of the beautiful simple paths of the tree. Note that paths\nare considered undirected (i. e. the path from x to y is the same as the path\nfrom y to x ).\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntestcases.\n\nThe first line of each testcase contains a single integer n (2 \\le n \\le 2\n\\cdot 10^5 ) — the number of vertices in the tree.\n\nThe second line contains n integers c_1, c_2, \\dots, c_n (1 \\le c_i \\le n ) —\nthe color of each vertex.\n\nThe i -th of the next n - 1 lines contains two integers v_i and u_i (1 \\le\nv_i, u_i \\le n ; v_i \\neq u_i ) — the i -th edge of the tree.\n\nThe given edges form a valid tree. The sum of n over all testcases doesn't\nexceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each testcase, print a single integer — the number of the beautiful simple\npaths of the tree.\n\nExample\n\nInput\n\n    4\n    \n    3\n    \n    1 2 1\n    \n    1 2\n    \n    2 3\n    \n    5\n    \n    2 1 2 1 2\n    \n    1 2\n    \n    1 3\n    \n    3 4\n    \n    4 5\n    \n    5\n    \n    1 2 3 4 5\n    \n    1 2\n    \n    1 3\n    \n    3 4\n    \n    4 5\n    \n    4\n    \n    2 2 2 2\n    \n    3 1\n    \n    3 2\n    \n    3 4\n\nOutput\n\n    1\n    3\n    0\n    3",
        "task_name": "1923-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    n = int(input())\n    c = list(map(int, input().split()))\n    \n    # Adjust colors to be zero-indexed\n    for i in range(n):\n        c[i] -= 1\n    \n    # Initialize adjacency list for the tree\n    tree = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        v, u = map(int, input().split())\n        tree[v - 1].append(u - 1)\n        tree[u - 1].append(v - 1)\n    \n    # Arrays to keep track of path counts\n    mas = [0] * n\n    ans = 0\n    kol = [0] * n\n    \n    # Stack for DFS, starting with node 0\n    stack = [[0, 1]]\n    paren = [-1] * n  # To track parent nodes and avoid revisiting\n    \n    while stack:\n        el, pos = stack.pop()\n        \n        if pos == 1:\n            # First visit to the node\n            kol[el] = mas[c[el]]  # Store current path count for this color\n            mas[c[el]] = 0  # Reset path count for this color\n            stack.append([el, 2])  # Mark node for post-visit processing\n            \n            # Explore children\n            for x in tree[el]:\n                if x != paren[el]:  # Avoid revisiting the parent\n                    stack.append([el, 3])  # Mark for path count update\n                    stack.append([x, 1])  # Visit child node\n                    paren[x] = el  # Set parent of child node\n        \n        elif pos == 3:\n            # After visiting a child, update path count\n            ans += mas[c[el]]  # Add paths ending at this node's color\n            mas[c[el]] = 0  # Reset path count for this color\n        \n        else:\n            # Post-visit processing\n            mas[c[el]] = kol[el] + 1  # Restore path count and include this node\n    \n    # Output the total number of beautiful paths\n    print(ans + sum(kol))",
        "correct": true,
        "task_id": 257
    },
    {
        "description": "378QAQ has a tree with n vertices. Initially, all vertices are white.\n\nThere are two chess pieces called P_A and P_B on the tree. P_A and P_B are\ninitially located on vertices a and b respectively. In one step, 378QAQ will\ndo the following in order:\n\n  1. Move P_A to a neighboring vertex. If the target vertex is white, this vertex will be painted red. \n  2. Move P_B to a neighboring vertex. If the target vertex is colored in red, this vertex will be painted blue. \n\nInitially, the vertex a is painted red. If a=b , the vertex a is painted blue\ninstead. Note that both the chess pieces must be moved in each step. Two\npieces can be on the same vertex at any given time.\n\n378QAQ wants to know the minimum number of steps to paint all vertices blue.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\leq t\\leq 10^4 ). The description of the test cases follows.\n\nThe first line of each test case contains one integer n (1\\leq n\\leq 2\\cdot\n10^5 ).\n\nThe second line of each test case contains two integers a and b (1\\leq a,b\\leq\nn ).\n\nThen n - 1 lines follow, each line contains two integers x_i and y_i (1 \\le\nx_i,y_i \\le n ), indicating an edge between vertices x_i and y_i . It is\nguaranteed that these edges form a tree.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, output the minimum number of steps to paint all vertices\nblue.\n\nExample\n\nInput\n\n    3\n    \n    2\n    \n    1 2\n    \n    1 2\n    \n    5\n    \n    1 2\n    \n    1 2\n    \n    1 3\n    \n    1 4\n    \n    1 5\n    \n    8\n    \n    5 4\n    \n    7 1\n    \n    1 5\n    \n    1 8\n    \n    8 3\n    \n    7 2\n    \n    8 6\n    \n    3 4\n\nOutput\n\n    2\n    8\n    13\n    \nNote\n\nIn the first test case, 378QAQ can paint all vertices blue in the following\norder:\n\n  * Initially, P_A is located on the vertex 1 , and P_B is located on the vertex 2 . The vertex 1 is painted red and the vertex 2 is white. \n  * 378QAQ moves P_A to the vertex 2 and paints it red. Then 378QAQ moves P_B to the vertex 1 and paints it blue. \n  * 378QAQ moves P_A to the vertex 1 . Then 378QAQ moves P_B to the vertex 2 and paints it blue.",
        "task_name": "1975-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t=int(input())\nwhile t:\n    t-=1\n    n=int(input())\n    a,b=map(int,input().split())\n    adj_list=[[] for i in range(n+1)]\n    for i in range(n-1):\n        x,y=map(int,input().split())\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n    answer1=0\n    answer3=0\n    store_prev=[0 for i in range(n+1)]\n    store_prev[a]=a\n    queue=[a]\n    visited=[0 for i in range(n+1)]\n    visited[a]=1\n    level=0\n    flag=0\n    while queue:\n        level+=1\n        queue2=[]\n        while queue:\n            node=queue.pop()\n            for i in adj_list[node]:\n                if visited[i]==0:\n                    visited[i]=1\n                    store_prev[i]=node\n                    if i==b:\n                        flag=1\n                        break\n                    queue2.append(i)\n            if flag==1:\n                break\n        if flag==1:\n            break\n        queue=queue2\n    step=int((level+1)/2)\n    answer1=step\n    x=b\n    if a==b:\n        step=0\n        answer1=0\n    while step:\n        x=store_prev[x]\n        step-=1\n    queue=[x]\n    visited=[0 for i in range(n+1)]\n    visited[x]=1\n    level=0\n    while queue:\n        level+=1\n        queue2=[]\n        while queue:\n            node=queue.pop()\n            for i in adj_list[node]:\n                if visited[i]==0:\n                    visited[i]=1\n                    queue2.append(i)\n        queue=queue2\n    answer3=level\n\n    answer2=2*(n-1)\n        \n    \n    print(answer2+answer1-answer3+1)",
        "correct": true,
        "task_id": 22
    },
    {
        "description": "[Proof Geometric Construction Can Solve All Love Affairs -\nmanbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-\nconstruction-can-solve-all-love-affairs)\n\n⠀\n\nThis is the easy version of the problem. The only difference between the two\nversions is the constraint on y . In this version y = 0 . You can make hacks\nonly if both versions are solved.\n\nBessie has received a birthday cake from her best friend Elsie, and it came in\nthe form of a regular polygon with n sides. The vertices of the cake are\nnumbered from 1 to n clockwise. You and Bessie are going to choose some of\nthose vertices to cut non-intersecting diagonals into the cake. In other\nwords, the endpoints of the diagonals must be part of the chosen vertices.\n\nBessie would only like to give out pieces of cake which result in a triangle\nto keep consistency. The size of the pieces doesn't matter, and the whole cake\ndoes not have to be separated into all triangles (other shapes are allowed in\nthe cake, but those will not be counted).\n\nBessie has already chosen x of those vertices that can be used to form\ndiagonals. She wants you to choose no more than y other vertices such that the\nnumber of triangular pieces of cake she can give out is maximized.\n\nWhat is the maximum number of triangular pieces of cake Bessie can give out?\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 10^4 ) — the number\nof test cases.\n\nThe first line of each test case consists of three integers, n , x , and y (4\n\\leq n \\leq 10^9 , 2 \\leq x \\leq \\min(n, 2 \\cdot 10^5) , y = 0 ) — the number\nof sides of the polygon, number of vertices Bessie has chosen, and the maximum\nnumber of other vertices you can choose.\n\nThe second line consists of x distinct integers from 1 to n , representing the\nvertices Bessie has chosen.\n\nIt is guaranteed the sum of x over all test cases does not exceed 2 \\cdot 10^5\n.\n\nOutput\n\nFor each test case, output a single integer: the maximum number of non-\nintersecting triangular pieces of cake she can give out.\n\nExample\n\nInput\n\n    3\n    \n    8 4 0\n    \n    1 6 2 5\n    \n    8 8 0\n    \n    1 3 2 5 4 6 7 8\n    \n    4 2 0\n    \n    1 3\n\nOutput\n\n    2\n    6\n    2\n    \nNote\n\nIn test cases 1 , 2 and 3 , you can get 2 , 6 and 2 non-intersecting\ntriangular pieces of cake, respectively. A possible construction is shown in\nthe following pictures:\n\nThe green dots represent vertices that can be used, the blue lines represent\ndiagonals that are drawn, and the red numbers represent triangles that are\ncounted.\n\n![](https://espresso.codeforces.com/80282d636b83d4002ec89755d465b4adb37b9cfb.png)",
        "task_name": "1942-C1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def cake(n,x,a):\n  res=x-2\n  a.sort()\n  for i in range(x-1):\n    if a[i+1]-a[i]==2:\n      res+=1\n  if a[-1]==n-1 and a[0]==1:\n    res+=1\n  return res\n\nt=int(input())\nfor _ in range(t):\n  [n,x,y]=list(map(int,input().split()))\n  a=list(map(int,input().split()))\n  print(cake(n,x,a))",
        "correct": false,
        "task_id": 87
    }
]