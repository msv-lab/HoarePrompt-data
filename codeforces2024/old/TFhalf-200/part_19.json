[
    {
        "description": "Given an array a of length n . Let's construct a square matrix b of size n\n\\times n , in which the i -th row contains the array a cyclically shifted to\nthe right by (i - 1) . For example, for the array a = [3, 4, 5] , the obtained\nmatrix is\n\nLet's construct the following graph:\n\n  * The graph contains n^2 vertices, each of which corresponds to one of the elements of the matrix. Let's denote the vertex corresponding to the element b_{i, j} as (i, j) .\n  * We will draw an edge between vertices (i_1, j_1) and (i_2, j_2) if |i_1 - i_2| + |j_1 - j_2| \\le k and \\gcd(b_{i_1, j_1}, b_{i_2, j_2}) > 1 , where \\gcd(x, y) denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers x and y . \n\nYour task is to calculate the number of connected components^{\\dagger} in the\nobtained graph.\n\n^{\\dagger} A connected component of a graph is a set of vertices in which any\nvertex is reachable from any other via edges, and adding any other vertex to\nthe set violates this rule.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^5 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains two integers n and k (2 \\le n \\le\n10^6 , 2 \\le k \\le 2 \\cdot 10^6 ) — the length of the array and the parameter\nk .\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^6 ) — the elements of the array a .\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6 .\n\nOutput\n\nFor each test case, output a single integer — the number of connected\ncomponents in the obtained graph.\n\nExample\n\nInput\n\n    6\n    \n    3 3\n    \n    3 4 5\n    \n    3 3\n    \n    3 4 9\n    \n    3 2\n    \n    3 4 9\n    \n    2 2\n    \n    2 8\n    \n    5 3\n    \n    8 27 5 4 3\n    \n    4 10\n    \n    2 2 2 2\n\nOutput\n\n    3\n    2\n    3\n    1\n    4\n    1\n    \nNote\n\nIn the first test case, the matrix b is given in the statement. The first\nconnected component contains the vertices (1, 1) , (2, 2) , and (3, 3) . The\nsecond connected component contains the vertices (1, 2) , (2, 3) , and (3, 1)\n. The third connected component contains the vertices (1, 3) , (2, 1) , and\n(3, 2) . Thus, the graph has 3 connected components.\n\nIn the second test case, the following matrix is obtained:\n\nThe first connected component contains all vertices corresponding to elements\nwith values 3 and 9 . The second connected component contains all vertices\ncorresponding to elements with the value 4 .\n\nIn the fourth test case, all vertices are in one connected component.",
        "task_name": "1978-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from typing import List, Tuple\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef gcd(x: int, y: int) -> int:\n    while y > 0:\n        x, y = y, x % y\n    return x\n\nclass DSU:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0]*N\n\n    def find(self, u: int) -> int:\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u: int, v: int):\n        ru, rv = self.find(u), self.find(v)\n        if ru == rv:\n            return False\n        if self.rank[ru] < self.rank[rv]:\n            ru, rv = rv, ru\n        self.parent[rv] = ru\n        self.rank[ru] += self.rank[rv]\n        return True\n\ndef solve() -> None:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    dsu = DSU(n*n)\n    for i in range(n):\n        for j in range(n):\n            for di in range(-k, k+1):\n                for dj in range(-k, k+1):\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < n and 0 <= nj < n and abs(di)+abs(dj) <= k and gcd(a[(ni+1)%n], a[(j+1)%n]) > 1:\n                        dsu.union((i)*n+(j), (ni)*n+(nj))\n\n    print(sum([1 for r in dsu.rank if r > 0]))\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        solve()",
        "correct": false,
        "task_id": 216
    },
    {
        "description": "You are given a binary (consisting only of 0s and 1s) n \\times m matrix. You\nare also given a XORificator, using which you can invert all the values in a\nchosen row (i.e. replace 0 with 1 and 1 with 0).\n\nA column in the matrix is considered special if it contains exactly one 1.\nYour task is to find the maximum number of columns that can be made special at\nthe same time, and the set of rows the XORificator should be used on to\nachieve that.\n\nInput\n\nEach test contains multiple test cases. The first line of input contains a\nsingle integer t (1 \\le t \\le 10^4 ) — the number of test cases. The\ndescription of the test cases follows.\n\nThe first line of each test case contains two integers n and m (1 \\leq n, m\n\\leq 3 \\cdot 10^5 , n \\cdot m \\leq 3 \\cdot 10^5 ).\n\nEach of the following n lines of the test case contains a binary string of\nlength m .\n\nIt is guaranteed that the sum of n \\cdot m over all test cases does not exceed\n3 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output two lines.\n\nIn the first line, output the maximum number of special columns that is\npossible to get simultaneously.\n\nIn the second line, output a binary string of length n , where the i -th\ncharacter is 0, if you don't use the XORificator on the i -th row, and 1, if\nyou use the XORificator on the i -th row.\n\nIf there are multiple valid XORificator configurations that achieve the\noptimal answer, you can output any of them.\n\nExample\n\nInput\n\n    5\n    \n    3 4\n    \n    1010\n    \n    0110\n    \n    0100\n    \n    1 1\n    \n    1\n    \n    1 1\n    \n    0\n    \n    2 5\n    \n    00101\n    \n    10110\n    \n    3 3\n    \n    101\n    \n    111\n    \n    000\n\nOutput\n\n    3\n    010\n    1\n    0\n    1\n    1\n    3\n    00\n    2\n    010\n    \nNote\n\nIn the first test case, you can use the XORificator on the second row to make\nthe columns 2 , 3 , and 4 special.\n\nIn the second test case, the only column is already special, so you don't need\nto use the XORificator.",
        "task_name": "1977-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\nimport random\n\ndef solve():\n    n, m = map(int, input().split())\n    a = []\n    for _ in range(n):\n        row = list(map(int, input().strip()))\n        a.append(row)\n\n    def rng():\n        return random.randint(0, sys.maxsize)\n\n    INF = 4 * 10**18\n    h = [rng() % INF for _ in range(n)]\n\n    ans = 0\n    dp = {}\n    used = set()\n    for j in range(m):\n        hash_val = 0\n        for i in range(n):\n            if a[i][j]:\n                hash_val ^= h[i]\n        for i in range(n):\n            hash_val ^= h[i]\n            dp[hash_val] = dp.get(hash_val, 0) + 1\n            if dp[hash_val] > ans:\n                ans = dp[hash_val]\n                used.clear()\n                for k in range(n):\n                    if k == i:\n                        if a[k][j] == 0:\n                            used.add(k)\n                    else:\n                        if a[k][j]:\n                            used.add(k)\n            hash_val ^= h[i]\n\n    print(ans)\n    print(''.join('1' if i in used else '0' for i in range(n)))\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        solve()",
        "correct": true,
        "task_id": 260
    },
    {
        "description": "This is the hard version of the problem. The only difference in this version\nis the constraint on t .\n\nRon and Hermione are playing a game on a tree of n nodes that are initially\ninactive. The game consists of t rounds, each of which starts with a stone on\nexactly one node, which is considered as activated. A move consists of picking\nan inactive neighbor of the node with a stone on it and moving the stone there\n(thus activating this neighbor). Ron makes the first move, after which he\nalternates with Hermione until no valid move is available. The player that\ncannot make a move loses the round. If both players play optimally, who wins\neach round of this game?\n\nNote that all the rounds are played with the same tree; only the starting node\nchanges. Moreover, after each round, all active nodes are considered inactive\nagain.\n\nInput\n\nThe first line contains integers n (2 \\leq n \\leq 2\\times 10^5 ), t (1 \\leq t\n\\leq n ), the number of nodes in the tree and the number of rounds,\nrespectively.\n\nThe next n-1 lines contain two integers 1 \\leq u, v \\leq n each, corresponding\nto an edge of the tree.\n\nThe next line contains t integers 1 \\leq u_1 , \\dots , u_t \\leq n ,\ncorresponding to the node where the stone is initially put.\n\nOutput\n\nThe output consists of t lines, each line being either \"Ron\" or \"Hermione\".\n\nExamples\n\nInput\n\n    5 2\n    \n    1 2\n    \n    1 3\n    \n    3 4\n    \n    3 5\n    \n    1 2\n\nOutput\n\n    Ron\n    Ron\n    \nInput\n\n    6 3\n    \n    1 2\n    \n    2 3\n    \n    1 4\n    \n    4 5\n    \n    4 6\n    \n    1 4 6\n\nOutput\n\n    Hermione\n    Ron\n    Hermione",
        "task_name": "1970-C3",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections import defaultdict\nn, t = map(int, input().split())\ngraph = defaultdict(list)\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\nstartNode = list(map(int, input().split()))\ndef iterative_dfs(start, graph, visited):\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\nvisited = set()\nfor node in startNode:\n    if node not in visited:\n        iterative_dfs(node, graph, visited)\nfor node in startNode:\n    print(\"Ron\" if node in visited else \"Hermione\")",
        "correct": false,
        "task_id": 276
    },
    {
        "description": "Sasha decided to give his girlfriend the best handbag, but unfortunately for\nSasha, it is very expensive. Therefore, Sasha wants to earn it. After looking\nat earning tips on the internet, he decided to go to the casino.\n\nSasha knows that the casino operates under the following rules. If Sasha\nplaces a bet of y coins (where y is a positive integer), then in case of\nwinning, he will receive y \\cdot k coins (i.e., his number of coins will\nincrease by y \\cdot (k - 1) ). And in case of losing, he will lose the entire\nbet amount (i.e., his number of coins will decrease by y ).\n\nNote that the bet amount must always be a positive (> 0 ) integer and cannot\nexceed Sasha's current number of coins.\n\nSasha also knows that there is a promotion at the casino: he cannot lose more\nthan x times in a row.\n\nInitially, Sasha has a coins. He wonders whether he can place bets such that\nhe is guaranteed to win any number of coins. In other words, is it true that\nfor any integer n , Sasha can make bets so that for any outcome that does not\ncontradict the rules described above, at some moment of time he will have at\nleast n coins.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 1000 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe single line of each test case contains three integers k, x and a (2 \\leq k\n\\leq 30 , 1 \\leq x \\leq 100 , 1 \\leq a \\leq 10^9 ) — the number of times the\nbet is increased in case of a win, the maximum number of consecutive losses,\nand the initial number of coins Sasha has.\n\nOutput\n\nFor each test case, output \"YES\" (without quotes) if Sasha can achieve it and\n\"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, the strings \"yEs\",\n\"yes\" and \"Yes\" will be recognized as a positive answer).\n\nExample\n\nInput\n\n    9\n    \n    2 1 7\n    \n    2 1 1\n    \n    2 3 15\n    \n    3 3 6\n    \n    4 4 5\n    \n    5 4 7\n    \n    4 88 1000000000\n    \n    25 69 231\n    \n    13 97 18806\n\nOutput\n\n    YES\n    NO\n    YES\n    NO\n    NO\n    YES\n    NO\n    NO\n    NO\n    \nNote\n\nIn the first test case, Sasha can proceed as follows:\n\n  * If Sasha places a bet for the first time or if he won the previous bet, then he places 1 coin.\n  * If Sasha lost the previous bet, then he places 2 coins.\n\nNote that Sasha cannot lose more than once in a row.\n\nIt can be proven that with this strategy, Sasha can obtain as many coins as he\nwants.\n\nIn the second test case, Sasha can only place 1 coin for the first time. But\nin case of a loss, he will not be able to place any more bets, so he will not\nbe able to guarantee having as many coins as he wants.",
        "task_name": "1929-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import math\n\n\ndef solve():\n    k, x, c = map(int, input().split())\n    coins_lost = 0\n    check = True\n    for i in range(x):\n        bet_needed = coins_lost // (k-1) + 1\n        coins_lost += bet_needed\n        if coins_lost > c:\n            check = False\n            break\n\n    win = (c - coins_lost) * k\n    if win > c and check:\n\n        print('YES')\n    else:\n        print('NO')\n\n\n\n\n\n\nfor i in range(int(input())):\n    solve()",
        "correct": true,
        "task_id": 101
    },
    {
        "description": "You have a hand of n cards, where each card has a number written on it, and a\nfixed integer k . You can perform the following operation any number of times:\n\n  * Choose any k cards from your hand that all have the same number. \n  * Exchange these cards for k-1 cards, each of which can have any number you choose (including the number written on the cards you just exchanged). \n\nHere is one possible sequence of operations for the first example case, which\nhas k=3 :\n\n![](https://espresso.codeforces.com/ac8986e55ddc41e4d0ee63ac67222f97e7fcc1bf.png)\n\nWhat is the minimum number of cards you can have in your hand at the end of\nthis process?\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 500 ) —\nthe number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \\le n \\le\n100 , 2 \\le k \\le 100 ) — the number of cards you have, and the number of\ncards you exchange during each operation, respectively.\n\nThe next line of each test case contains n integers c_1, c_2, \\ldots c_n (1\n\\le c_i \\le 100 ) — the numbers written on your cards.\n\nOutput\n\nFor each test case, output a single integer — the minimum number of cards you\ncan have left in your hand after any number of operations.\n\nExample\n\nInput\n\n    7\n    \n    5 3\n    \n    4 1 1 4 4\n    \n    1 10\n    \n    7\n    \n    7 2\n    \n    4 2 1 100 5 2 3\n    \n    10 4\n    \n    1 1 1 1 1 1 1 1 1 1\n    \n    5 2\n    \n    3 8 1 48 7\n    \n    6 2\n    \n    10 20 30 10 20 40\n    \n    6 3\n    \n    10 20 30 10 20 40\n\nOutput\n\n    2\n    1\n    1\n    3\n    5\n    1\n    6\n    \nNote\n\nThe first example case corresponds to the picture above. The sequence of\noperations displayed there is optimal, so the answer is 2 .\n\nIn the second example case, no operations can be performed, so the answer is 1\n.\n\nIn the fourth example case, you can repeatedly select 4 cards numbered with 1\nand replace them with 3 cards numbered with 1 , until there are 3 cards left.",
        "task_name": "1966-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def count_frequencies(arr, k):\n    frequency_table = {}\n\n    for num in arr:\n        frequency_table[num] = frequency_table.get(num, 0) + 1\n        if frequency_table[num] > k :\n            frequency_table[num] = k\n\n    return frequency_table  \n\nt = int(input())\nfor i in range(t):\n    n , k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    if k > n :\n        print(n)\n    elif k == n :\n        print(k - 1)\n    else:\n        freq = count_frequencies(nums, k)\n        if k in freq.values():\n            print(k - 1) \n        else :\n            print(n)\n\n\n\n\n# t = int(input())\n# for i in range(t):\n#     n , k = map(int, input().split())\n#     if k > n :\n#         print(n)\n#     elif k == n :\n#         print(k - 1)\n#     else:\n#         nums = list(map(int, input().split()))\n#         frequency_table = frequencies_of_frequencies(nums, k)\n#         if k in frequency_table and frequency_table[k] > 0:\n#             x = 0\n#             for num in frequency_table:\n#                 if num == k :\n#                     continue\n#                 x += num * frequency_table[num]\n#             print(x)\n#         else :\n#             print(len(nums))",
        "correct": false,
        "task_id": 201
    },
    {
        "description": "You have some cards. An integer between 1 and n is written on each card:\nspecifically, for each i from 1 to n , you have a_i cards which have the\nnumber i written on them.\n\nThere is also a shop which contains unlimited cards of each type. You have k\ncoins, so you can buy k new cards in total, and the cards you buy can contain\nany integer between 1 and n .\n\nAfter buying the new cards, you rearrange all your cards in a line. The score\nof a rearrangement is the number of (contiguous) subarrays of length n which\nare a permutation of [1, 2, \\ldots, n] . What's the maximum score you can get?\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t\\ (1\\le t\\le 100) . The description of the test cases follows.\n\nThe first line of each test case contains two integers n , k (1\\le n \\le 2\n\\cdot 10^5 , 0\\le k \\le 10^{12} ) — the number of distinct types of cards and\nthe number of coins.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^{12} ) — the number of cards of type i you have at the\nbeginning.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single line containing an integer: the maximum\nscore you can get.\n\nExample\n\nInput\n\n    8\n    \n    1 10\n    \n    1\n    \n    2 4\n    \n    8 4\n    \n    3 4\n    \n    6 1 8\n    \n    3 9\n    \n    7 6 2\n    \n    5 3\n    \n    6 6 7 4 6\n    \n    9 7\n    \n    7 6 1 7 6 2 4 3 3\n    \n    10 10\n    \n    1 3 1 2 1 9 3 5 7 5\n    \n    9 8\n    \n    5 8 7 5 1 3 2 9 8\n\nOutput\n\n    11\n    15\n    15\n    22\n    28\n    32\n    28\n    36\n    \nNote\n\nIn the first test case, the final (and only) array we can get is [1, 1, 1, 1,\n1, 1, 1, 1, 1, 1, 1] (including 11 single 1 s), which contains 11 subarrays\nconsisting of a permutation of [1] .\n\nIn the second test case, we can buy 0 cards of type 1 and 4 cards of type 2 ,\nand then we rearrange the cards as following: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,\n1, 2, 1, 2, 1, 2] . There are 8 subarrays equal to [1, 2] and 7 subarrays\nequal to [2, 1] , which make a total of 15 subarrays which are a permutation\nof [1, 2] . It can also be proved that this is the maximum score we can get.\n\nIn the third test case, one of the possible optimal rearrangements is [3, 3,\n1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3] .",
        "task_name": "1967-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def max_score(n, k, a):\n    # Binary search for the maximum number of complete sets\n    left, right = 0, max(a) + k + 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        # Calculate the total number of additional cards needed to make `mid` sets\n        needed = 0\n        for ai in a:\n            if ai < mid:\n                needed += mid - ai\n            if needed > k:\n                break\n        \n        if needed <= k:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left - 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = max_score(n, k, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)",
        "correct": false,
        "task_id": 139
    },
    {
        "description": "Dmitry has n cubes, numbered from left to right from 1 to n . The cube with\nindex f is his favorite.\n\nDmitry threw all the cubes on the table, and the i -th cube showed the value\na_i (1 \\le a_i \\le 100 ). After that, he arranged the cubes in non-increasing\norder of their values, from largest to smallest. If two cubes show the same\nvalue, they can go in any order.\n\nAfter sorting, Dmitry removed the first k cubes. Then he became interested in\nwhether he removed his favorite cube (note that its position could have\nchanged after sorting).\n\nFor example, if n=5 , f=2 , a = [4, \\color{green}3, 3, 2, 3] (the favorite\ncube is highlighted in green), and k = 2 , the following could have happened:\n\n  * After sorting a=[4, \\color{green}3, 3, 3, 2] , since the favorite cube ended up in the second position, it will be removed. \n  * After sorting a=[4, 3, \\color{green}3, 3, 2] , since the favorite cube ended up in the third position, it will not be removed. \n\nInput\n\nThe first line contains an integer t (1 \\le t \\le 1000 ) — the number of test\ncases. Then follow the descriptions of the test cases.\n\nThe first line of each test case description contains three integers n , f ,\nand k (1 \\le f, k \\le n \\le 100 ) — the number of cubes, the index of Dmitry's\nfavorite cube, and the number of removed cubes, respectively.\n\nThe second line of each test case description contains n integers a_i (1 \\le\na_i \\le 100 ) — the values shown on the cubes.\n\nOutput\n\nFor each test case, output one line — \"YES\" if the cube will be removed in all\ncases, \"NO\" if it will not be removed in any case, \"MAYBE\" if it may be either\nremoved or left.\n\nYou can output the answer in any case. For example, the strings \"YES\", \"nO\",\n\"mAyBe\" will be accepted as answers.\n\nExample\n\nInput\n\n    12\n    \n    5 2 2\n    \n    4 3 3 2 3\n    \n    5 5 3\n    \n    4 2 1 3 5\n    \n    5 5 2\n    \n    5 2 4 1 3\n    \n    5 5 5\n    \n    1 2 5 4 3\n    \n    5 5 4\n    \n    3 1 2 4 5\n    \n    5 5 5\n    \n    4 3 2 1 5\n    \n    6 5 3\n    \n    1 2 3 1 2 3\n    \n    10 1 1\n    \n    1 1 1 1 1 1 1 1 1 1\n    \n    1 1 1\n    \n    42\n    \n    5 2 3\n    \n    2 2 1 1 2\n    \n    2 1 1\n    \n    2 1\n    \n    5 3 1\n    \n    3 3 2 3 2\n\nOutput\n\n    MAYBE\n    YES\n    NO\n    YES\n    YES\n    YES\n    MAYBE\n    MAYBE\n    YES\n    YES\n    YES\n    NO",
        "task_name": "1980-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t=int(input())\nfor _ in range(t):\n    n,f,k=map(int,input().split())\n    a=list(map(int,input().split()))\n    special=a[f-1]\n    a.sort(reverse=True)\n    b=[]\n    c=[]\n    for i in range(k):\n        b.append(a[i])\n    for i in range(k,n):\n        c.append(a[i])\n    if special in b and special in c:\n        print(\"MAYBE\")\n    elif special in b and special not in c:\n        print(\"YEs\")\n    elif special in c and special not in b:\n        print(\"No\")",
        "correct": true,
        "task_id": 74
    },
    {
        "description": "Vladislav has a son who really wanted to go to MIT. The college dormitory at\nMIT (Moldova Institute of Technology) can be represented as a tree with n\nvertices, each vertex being a room with exactly one student. A tree is a\nconnected undirected graph with n vertices and n-1 edges.\n\nTonight, there are three types of students:\n\n  * students who want to party and play music (marked with \\texttt{P} ), \n  * students who wish to sleep and enjoy silence (marked with \\texttt{S} ), and \n  * students who don't care (marked with \\texttt{C} ). \n\nInitially, all the edges are thin walls which allow music to pass through, so\nwhen a partying student puts music on, it will be heard in every room.\nHowever, we can place some thick walls on any edges — thick walls don't allow\nmusic to pass through them.\n\nThe university wants to install some thick walls so that every partying\nstudent can play music, and no sleepy student can hear it.\n\nBecause the university lost a lot of money in a naming rights lawsuit, they\nask you to find the minimum number of thick walls they will need to use.\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 1000 ) — the number\nof test cases.\n\nThe first line of each test case contains an integer n (2 \\leq n \\leq 10^5 ) —\nthe number of vertices in the tree.\n\nThe second line of each test case contains n-1 integers a_2, \\dots , a_n (1\n\\leq a_i < i ) — it means there is an edge between i and a_i in the tree.\n\nThe third line of each test case contains a string s of length n consisting of\ncharacters \\texttt{P} , \\texttt{S} , and \\texttt{C} , denoting that student i\nis of type s_i .\n\nThe sum of n over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the minimum number of thick\nwalls needed.\n\nExample\n\nInput\n\n    3\n    \n    3\n    \n    1 1\n    \n    CSP\n    \n    4\n    \n    1 2 2\n    \n    PCSS\n    \n    4\n    \n    1 2 2\n    \n    PPSS\n\nOutput\n\n    1\n    1\n    2\n    \nNote\n\nIn the first case, we can install one thick wall between rooms 1 and 2 , as\nshown below. We cannot install 0 walls, since then the music from room 3 will\nreach room 2 where a student wants to sleep, so the answer is 1 . There are\nother valid solutions.\n\n![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)",
        "task_name": "1926-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    n = int(input())\n    # Read the parent array, with a dummy -1 at the start for 1-based indexing\n    fa = [-1] + list(map(int, input().split()))\n    # Read the string representing student types\n    S = input()\n    \n    # Initialize dp arrays for isolation and non-isolation scenarios\n    dp1, dp2 = [0] * (n + 1), [0] * (n + 1)\n    \n    # Traverse the tree from the last node to the first (bottom-up)\n    for i in range(n - 1, -1, -1):\n        if S[i] == \"S\":\n            dp1[i] = float(\"inf\")  # Must isolate sleepy students\n        elif S[i] == \"P\":\n            dp2[i] = float(\"inf\")  # Must not allow music to pass through partying students\n\n        # Get the parent of the current node\n        p = fa[i] - 1\n        if p != -1:\n            # Update the parent's dp values based on the current node's values\n            dp1[p] += min(dp1[i], dp2[i] + 1)\n            dp2[p] += min(dp1[i] + 1, dp2[i])\n\n    # Output the minimum number of thick walls needed for the root\n    print(min(dp1[0], dp2[0]))",
        "correct": true,
        "task_id": 43
    },
    {
        "description": "You are given n circles on the plane. The i -th of these circles is given by a\ntuple of integers (x_i, y_i, r_i) , where (x_i, y_i) are the coordinates of\nits center, and r_i is the radius of the circle.\n\nPlease find a circle C which meets the following conditions:\n\n  * C is contained inside all n circles given in the input. \n  * Among all circles C that meet the first condition, the radius of the circle is maximum. \n\nLet the largest suitable circle have the radius of a .\n\nYour output C , described as (x,y,r) , will be accepted if it meets the\nfollowing conditions:\n\n  * For each i , \\sqrt{(x_i-x)^2+(y_i-y)^2}+ r \\le r_i+\\max(a,1)\\cdot 10^{-7} . \n  * The absolute or relative error of r does not exceed 10^{-7} . Formally, your answer is accepted if and only if \\frac{\\left|r - a\\right|}{\\max(1, a)} \\le 10^{-7} . \n\nInput\n\nThe first line contains a single integer n (1 \\le n \\le 10^5 ) — the number of\ncircles.\n\nThe i -th of the following n lines contains three integers x_i , y_i , r_i\n(-10^6 \\le x_i,y_i \\le 10^6 , 1 \\le r_i \\le 2 \\cdot 10^6 ).\n\nIt is guaranteed that there is a circle with a radius of at least 10^{-6}\nwhich is contained inside all n circles.\n\nOutput\n\nOutput three real values, x , y , and r — the coordinates of the center and\nthe radius of the circle.\n\nExamples\n\nInput\n\n    4\n    1 1 3\n    -1 1 3\n    1 -1 2\n    -1 -1 2\n    \nOutput\n\n    0.0000000000000000 -0.7637626158259733 0.9724747683480533\n    \nInput\n\n    4\n    41580 -23621 95642\n    -41580 -23621 95642\n    0 47821 95642\n    0 0 109750\n    \nOutput\n\n    0.0000000000000000 0.0000000000000000 47821.0000000000000000\n    \nNote\n\nA two-dimensional plot depicting the first test case is given below. The\noutput circle C is dashed with blue lines.\n\n![](https://espresso.codeforces.com/49e7413ddb467ae8074e60dbafdc7a868155af22.png)\n\nA two-dimensional plot depicting the second test case is given below. The\noutput circle C is dashed with blue lines.\n\n![](https://espresso.codeforces.com/7a3342ebf5aaf2aa55a11b4b8c5eeb2e45b9feb0.png)",
        "task_name": "1936-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import math\n\ndef circle_from_points(x1, y1, x2, y2):\n    # Center of the circle\n    cx = (x1 + x2) / 2\n    cy = (y1 + y2) / 2\n    \n    # Radius of the circle\n    r = math.sqrt((x1 - cx)**2 + (y1 - cy)**2)\n    \n    return (cx, cy, r)\n\ndef circle_from_three_points(x1, y1, x2, y2, x3, y3):\n    # Slopes of the lines formed by the points\n    m1 = (y2 - y1) / (x2 - x1) if x1 != x2 else float('inf')\n    m2 = (y3 - y2) / (x3 - x2) if x2 != x3 else float('inf')\n    \n    # Center of the circle\n    cx = (m1*m2*(y1 - y3) + m2*(x1 + x2) - m1*(x2 + x3)) / (2 * (m2 - m1))\n    cy = (-1/m1) * (cx - (x1 + x2) / 2) + (y1 + y2) / 2 if m1 != 0 else (-1/m2) * (cx - (x2 + x3) / 2) + (y2 + y3) / 2\n    \n    # Radius of the circle\n    r = math.sqrt((x1 - cx)**2 + (y1 - cy)**2)\n    \n    return (cx, cy, r)\n\ndef smallest_enclosing_circle(points):\n    n = len(points)\n    circle = None\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, r1 = points[i]\n            x2, y2, r2 = points[j]\n            \n            # Circles from two points\n            circle = circle_from_points(x1, y1, x2, y2)\n            \n            # Check if the circle contains all points\n            valid = True\n            for k in range(n):\n                x, y, r = points[k]\n                if (x - circle[0])**2 + (y - circle[1])**2 > (r + circle[2])**2:\n                    valid = False\n                    break\n            \n            if valid:\n                return circle\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                x1, y1, r1 = points[i]\n                x2, y2, r2 = points[j]\n                x3, y3, r3 = points[k]\n                \n                # Circle from three points\n                circle = circle_from_three_points(x1, y1, x2, y2, x3, y3)\n                \n                # Check if the circle contains all points\n                valid = True\n                for l in range(n):\n                    x, y, r = points[l]\n                    if (x - circle[0])**2 + (y - circle[1])**2 > (r + circle[2])**2:\n                        valid = False\n                        break\n                \n                if valid:\n                    return circle\n\n# Read the number of circles\nn = int(input().strip())\n\n# Read the circles\ncircles = []\nfor _ in range(n):\n    x, y, r = map(int, input().strip().split())\n    circles.append((x, y, r))\n\n# Find the smallest enclosing circle\nresult = smallest_enclosing_circle(circles)\n\n# Output the result\nprint(\"{:.10f} {:.10f} {:.10f}\".format(result[0], result[1], result[2]))",
        "correct": false,
        "task_id": 347
    },
    {
        "description": "In a well-known school, a physical education lesson took place. As usual,\neveryone was lined up and asked to settle in \"the first–k -th\" position.\n\nAs is known, settling in \"the first–k -th\" position occurs as follows: the\nfirst k people have numbers 1, 2, 3, \\ldots, k , the next k - 2 people have\nnumbers k - 1, k - 2, \\ldots, 2 , the next k people have numbers 1, 2, 3,\n\\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.\nExamples of settling are given in the \"Note\" section.\n\nThe boy Vasya constantly forgets everything. For example, he forgot the number\nk described above. But he remembers the position he occupied in the line, as\nwell as the number he received during the settling. Help Vasya understand how\nmany natural numbers k fit under the given constraints.\n\nNote that the settling exists if and only if k > 1 . In particular, this means\nthat the settling does not exist for k = 1 .\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 100 ) — the number of test cases. This is followed by\nthe description of the test cases.\n\nThe only line of each test case contains two integers n and x (1 \\le x < n \\le\n10^9 ) — Vasya's position in the line and the number Vasya received during the\nsettling.\n\nOutput\n\nFor each test case, output a single integer — the number of different k that\nfit under the given constraints.\n\nIt can be proven that under the given constraints, the answer is finite.\n\nExample\n\nInput\n\n    5\n    \n    10 2\n    \n    3 1\n    \n    76 4\n    \n    100 99\n    \n    1000000000 500000000\n\nOutput\n\n    4\n    1\n    9\n    0\n    1\n    \nNote\n\nIn the first test case, k equals 2, 3, 5, 6 are suitable.\n\nAn example of settling for these k :\n\nk / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   \n---|---|---|---|---|---|---|---|---|---|---  \n2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   \n3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   \n5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   \n6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   \n  \nIn the second test case, k = 2 is suitable.",
        "task_name": "1928-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def find_valid_ks(n, x):\n    def get_even_divisors(value):\n        even_divisors = []\n        for i in range(1, int(value**0.5) + 1):\n            if value % i == 0:\n                if i % 2 == 0:\n                    even_divisors.append(i)\n                if (value // i) % 2 == 0 and i != value // i:\n                    even_divisors.append(value // i)\n        return even_divisors\n\n    # Calculate all even divisors of n - x and n + x - 2\n    divisors_n_x = get_even_divisors(n - x)\n    divisors_n_x_2 = get_even_divisors(n + x - 2)\n\n    # Combine all divisors into a set for uniqueness\n    divisors = set(divisors_n_x + divisors_n_x_2)\n\n    # Count valid k values\n    valid_k_count = 0\n    for d in divisors:\n        k = d // 2 + 1\n        if k > 1 and k >= x:\n            valid_k_count += 1\n\n    return valid_k_count\n\n\ndef main():\n    t = int(input())  # Number of test cases\n    results = []\n\n    for _ in range(t):\n        n, x = map(int, input().split())\n        results.append(find_valid_ks(n, x))\n\n    for res in results:\n        print(res)\n\n\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": 57
    }
]