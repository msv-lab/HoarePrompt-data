[
    {
        "description": "There is a game where you need to move through a labyrinth. The labyrinth\nconsists of n platforms, connected by m passages.\n\nEach platform is at some level l_i , an integer number from 0 to H - 1 . In a\nsingle step, if you are currently on platform i , you can stay on it, or move\nto another platform j . To move to platform j they have to be connected by the\npassage, and their levels have to be the same, namely l_i = l_j .\n\nAfter each step, the levels of all platforms change. The new level of platform\ni is calculated as l'_i = (l_i + s_i) \\bmod H , for all i .\n\nYou start on platform 1 . Find the minimum number of steps you need to get to\nplatform n .\n\nInput\n\nThe first line of input contains a single integer t (1 \\le t \\le 10^4 ) — the\nnumber of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains three integers n , m , and H (2 \\le\nn \\le 10^5 , 1 \\le m \\le 10^5 , 1 \\le H \\le 10^9 ).\n\nThe second line contains n integers l_i , the initial level of each platform\n(0 \\le l_i \\le H-1 ).\n\nThe third line contains n integers s_i , the change of level for each platform\n(0 \\le s_i \\le H-1 ).\n\nNext m lines contain a description of the passages. Each passage is described\nas a pair of integers — the platforms, connected by the passage. There is at\nmost one passage connecting each pair of platforms, and there is no passage\nconnecting a platform to itself.\n\nThe sum of n for all tests does not exceed 10^5 , the sum of m for all tests\ndoes not exceed 10^5 .\n\nOutput\n\nFor each test case, print a single integer, the minimum number of steps needed\nto get from platform 1 to platform n .\n\nIf it is impossible to get to platform n , print -1 .\n\nExample\n\nInput\n\n    3\n    \n    3 3 10\n    \n    1 9 4\n    \n    2 3 0\n    \n    1 2\n    \n    3 2\n    \n    1 3\n    \n    2 1 10\n    \n    1 2\n    \n    4 6\n    \n    1 2\n    \n    8 7 25\n    \n    22 14 5 3 10 14 11 1\n    \n    9 5 4 10 7 16 18 18\n    \n    2 8\n    \n    6 3\n    \n    3 5\n    \n    7 5\n    \n    2 6\n    \n    1 4\n    \n    4 7\n\nOutput\n\n    6\n    -1\n    52\n    \nNote\n\nThis is how levels of the platforms change, and what actions we need to\nperform in the first example.\n\n| Platform 1| Platform 2| Platform 3| Action  \n---|---|---|---|---  \nStep 1| 1| 9| 4| Stay on the platform 1  \nStep 2| 3| 2| 4| Stay on the platform 1  \nStep 3| 5| 5| 4| Move to the platform 2  \nStep 4| 7| 8| 4| Stay on the platform 2  \nStep 5| 9| 1| 4| Stay on the platform 2  \nStep 6| 1| 4| 4| Move to the platform 3",
        "task_name": "1932-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import heapq\nfrom typing import List, Tuple\n\n\ndef compute_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"Compute the Greatest Common Divisor (GCD) of a and b using the Extended Euclidean Algorithm.\"\"\"\n    if a == 0:\n        return b, 0, 1\n    gcd_val, x1, y1 = compute_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd_val, x, y\n\n\ndef find_minimum_steps(num_platforms: int, num_passages: int, max_level: int, levels: List[int], changes: List[int],\n                       passages: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum number of steps needed to reach from platform 1 to platform num_platforms.\"\"\"\n    try:\n        # Initialize graph and distances\n        adjacency_list: List[List[int]] = [[] for _ in range(num_platforms)]\n        for u, v in passages:\n            adjacency_list[u - 1].append(v - 1)\n            adjacency_list[v - 1].append(u - 1)\n\n        distances: List[int] = [-1] * num_platforms\n        distances[0] = 0\n        priority_queue: List[Tuple[int, int]] = [(0, 0)]  # (distance, platform)\n        visited: List[bool] = [False] * num_platforms\n\n        while priority_queue:\n            _, current_platform = heapq.heappop(priority_queue)\n            if visited[current_platform]:\n                continue\n            visited[current_platform] = True\n            for neighbor in adjacency_list[current_platform]:\n                if visited[neighbor]:\n                    continue\n                level_difference = (levels[neighbor] - levels[current_platform] + max_level) % max_level\n                changes_difference = (changes[current_platform] - changes[neighbor] + max_level) % max_level\n                gcd_val, x, y = compute_gcd(changes_difference, max_level)\n                if level_difference % gcd_val != 0:\n                    continue\n                level_difference //= gcd_val\n                x *= level_difference\n                step_difference = distances[current_platform] - x\n                k = (step_difference + (max_level // gcd_val) - 1) // (\n                            max_level // gcd_val) if step_difference >= 0 else -(\n                            (-step_difference) // (max_level // gcd_val))\n                steps = x + k * (max_level // gcd_val)\n                if distances[neighbor] == -1 or distances[neighbor] > steps + 1:\n                    distances[neighbor] = steps + 1\n                    heapq.heappush(priority_queue, (distances[neighbor], neighbor))\n\n        return distances[num_platforms - 1]\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return -1\n\n\ndef main():\n    num_cases: int = int(input())\n    for _ in range(num_cases):\n        num_platforms, num_passages, max_level = map(int, input().split())\n        levels: List[int] = list(map(int, input().split()))\n        changes: List[int] = list(map(int, input().split()))\n        passages: List[Tuple[int, int]] = [tuple(map(int, input().split())) for _ in range(num_passages)]\n        result: int = find_minimum_steps(num_platforms, num_passages, max_level, levels, changes, passages)\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": 164
    },
    {
        "description": "There are n children in a class, m pairs among them are friends. The i -th\npair who are friends have a friendship value of f_i .\n\nThe teacher has to go for k excursions, and for each of the excursions she\nchooses a pair of children randomly, equiprobably and independently. If a pair\nof children who are friends is chosen, their friendship value increases by 1\nfor all subsequent excursions (the teacher can choose a pair of children more\nthan once). The friendship value of a pair who are not friends is considered 0\n, and it does not change for subsequent excursions.\n\nFind the expected value of the sum of friendship values of all k pairs chosen\nfor the excursions (at the time of being chosen). It can be shown that this\nanswer can always be expressed as a fraction \\dfrac{p}{q} where p and q are\ncoprime integers. Calculate p\\cdot q^{-1} \\bmod (10^9+7) .\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 5 \\cdot 10^4 ). Description of the test cases\nfollows.\n\nThe first line of each test case contains 3 integers n , m and k (2 \\le n \\le\n10^5 , 0 \\le m \\le \\min \\Big(10^5 , \\frac{n(n-1)}{2} \\Big) , 1 \\le k \\le 2\n\\cdot 10^5 ) — the number of children, pairs of friends and excursions\nrespectively.\n\nThe next m lines contain three integers each — a_i , b_i , f_i — the indices\nof the pair of children who are friends and their friendship value. (a_i \\neq\nb_i , 1 \\le a_i,b_i \\le n , 1 \\le f_i \\le 10^9 ). It is guaranteed that all\npairs of friends are distinct.\n\nIt is guaranteed that the sum of n and sum m over all test cases does not\nexceed 10^5 and the sum of k over all test cases does not exceed 2 \\cdot 10^5\n.\n\nOutput\n\nFor each test case, print one integer — the answer to the problem.\n\nExample\n\nInput\n\n    4\n    \n    100 0 24\n    \n    2 1 10\n    \n    1 2 1\n    \n    3 1 2\n    \n    2 1 1\n    \n    5 2 4\n    \n    1 2 25\n    \n    3 2 24\n\nOutput\n\n    0\n    55\n    777777784\n    40000020\n    \nNote\n\nFor the first test case, there are no pairs of friends, so the friendship\nvalue of all pairs is 0 and stays 0 for subsequent rounds, hence the\nfriendship value for all excursions is 0 .\n\nFor the second test case, there is only one pair possible (1, 2) and its\nfriendship value is initially 1 , so each turn they are picked and their\nfriendship value increases by 1 . Therefore, the total sum is 1+2+3+\\ldots+10\n= 55 .\n\nFor the third test case, the final answer is \\frac{7}{9} = 777\\,777\\,784\\bmod\n(10^9+7) .",
        "task_name": "1925-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "mod = 1000000007\n\ndef inv(a):\n    if a <= 1:\n        return a\n    return mod - (mod // a) * inv(mod % a) % mod\n\ndef main():\n    tes = int(input())\n    for fuck in range(1, tes + 1):\n        n, m, k = map(int, input().split())\n        sum_val = 0\n        ans = 0\n        for _ in range(m):\n            a, b, c = map(int, input().split())\n            sum_val += c\n        N = inv((n * (n - 1)) // 2)\n        for i in range(k):\n            ans += (i * m * N * N + sum_val * N) % mod\n        print(ans % mod)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 212
    },
    {
        "description": "Congratulations, you have been accepted to the Master's Assistance Center!\nHowever, you were extremely bored in class and got tired of doing nothing, so\nyou came up with a game for yourself.\n\nYou are given a string s and an even integer n . There are two types of\noperations that you can apply to it:\n\n  1. Add the reversed string s to the end of the string s (for example, if s = cpm, then after applying the operation s = cpmmpc). \n  2. Reverse the current string s (for example, if s = cpm, then after applying the operation s = mpc). \n\nIt is required to determine the lexicographically smallest^{\\dagger} string\nthat can be obtained after applying exactly n operations. Note that you can\napply operations of different types in any order, but you must apply exactly n\noperations in total.\n\n^{\\dagger} A string a is lexicographically smaller than a string b if and only\nif one of the following holds:\n\n  * a is a prefix of b , but a \\ne b ; \n  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b . \n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 500 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single even integer n (2 \\leq n\n\\leq 10^9 ) — the number of operations applied to the string s .\n\nThe second line of each test case contains a single string s (1 \\leq |s| \\leq\n100 ), consisting of lowercase English letters, — the string to which the\noperations are applied.\n\nOutput\n\nFor each test case, output a single line — the lexicographically smallest\nstring that can be obtained after applying exactly n operations.\n\nExample\n\nInput\n\n    5\n    \n    4\n    \n    cpm\n    \n    2\n    \n    grib\n    \n    10\n    \n    kupitimilablodarbuz\n    \n    1000000000\n    \n    capybara\n    \n    6\n    \n    abacaba\n\nOutput\n\n    cpm\n    birggrib\n    kupitimilablodarbuz\n    arabypaccapybara\n    abacaba\n    \nNote\n\nIn the first test case, you can apply the operation of the second type (i.e.,\nreverse the string s ) 4 times. Then the string s will remain equal to cpm.\n\nIn the second test case, you can do the following:\n\n  * Apply the operation of the second type, after which s will become equal to birg. \n  * Apply operation of the first type (i.e., add the reversed string s to the end of the string s ), after which s will become equal to birggrib.",
        "task_name": "1935-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "p=int(input())\nfor i in range(p):\n    n=int(input())\n    s=input()\n    lenght=len(s)\n\n    if int(lenght)%2==0 and n%2==0:\n        print(s[::-1]+s)\n    else:\n        print(s)",
        "correct": false,
        "task_id": 173
    },
    {
        "description": "Vladislav has a string of length 5 , whose characters are each either\n\\texttt{A} or \\texttt{B} .\n\nWhich letter appears most frequently: \\texttt{A} or \\texttt{B} ?\n\nInput\n\nThe first line of the input contains an integer t (1 \\leq t \\leq 32 ) — the\nnumber of test cases.\n\nThe only line of each test case contains a string of length 5 consisting of\nletters \\texttt{A} and \\texttt{B} .\n\nAll t strings in a test are different (distinct).\n\nOutput\n\nFor each test case, output one letter (\\texttt{A} or \\texttt{B} ) denoting the\ncharacter that appears most frequently in the string.\n\nExample\n\nInput\n\n    8\n    \n    ABABB\n    \n    ABABA\n    \n    BBBAB\n    \n    AAAAA\n    \n    BBBBB\n    \n    BABAA\n    \n    AAAAB\n    \n    BAAAA\n\nOutput\n\n    B\n    A\n    B\n    A\n    B\n    A\n    A\n    A",
        "task_name": "1926-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "n  = int(input())\nnum_A = int(0)\nnum_B = int(0)\nfor i in range (0, n):\n    x = input()\n    for j in x:\n        if j == 'A':\n           num_A +=1 \n        else:\n            num_B +=1\n    if num_A > num_B:\n           print(\"A\")\n    else:\n           print(\"B\")",
        "correct": false,
        "task_id": 46
    },
    {
        "description": "Having overcome all the difficulties and hardships, Sasha finally decided to\nmarry his girlfriend. To do this, he needs to give her an engagement ring.\nHowever, his girlfriend does not like such romantic gestures, but she does\nlike binary search trees^{\\dagger} . So Sasha decided to give her such a tree.\n\nAfter spending a lot of time on wedding websites for programmers, he found the\nperfect binary search tree with the root at vertex 1 . In this tree, the value\nat vertex v is equal to val_v .\n\nBut after some time, he forgot the values in some vertices. Trying to remember\nthe found tree, Sasha wondered — how many binary search trees could he have\nfound on the website, if it is known that the values in all vertices are\nintegers in the segment [1, C] . Since this number can be very large, output\nit modulo 998\\,244\\,353 .\n\n^{\\dagger} A binary search tree is a rooted binary tree in which for any\nvertex x , the following property holds: the values of all vertices in the\nleft subtree of vertex x (if it exists) are less than or equal to the value at\nvertex x , and the values of all vertices in the right subtree of vertex x (if\nit exists) are greater than or equal to the value at vertex x .\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^5 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains two integers n and C (2 \\leq n \\leq\n5 \\cdot 10^5 , 1 \\leq C \\leq 10^9 ) — the number of vertices in the tree and\nthe maximum allowed value at the vertex.\n\nThe next n lines describe the vertices of the tree. The i -th line contains\nthree integers L_i, R_i and val_i (-1 \\le L_i, R_i \\le n , -1 \\le val_i \\le C\n, L_i, R_i, val_i \\ne 0 ) — the number of the left child, the number of the\nright child, and the value at the i -th vertex, respectively. If L_i = -1 ,\nthen the i -th vertex has no left son. If R_i = -1 , then the i -th vertex has\nno right son. If val_i = -1 , then the value at the i -th vertex is unknown.\n\nIt is guaranteed that at least one suitable binary search tree exists.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single integer — the number of suitable binary\nsearch trees modulo 998\\,244\\,353 .\n\nExample\n\nInput\n\n    3\n    \n    5 5\n    \n    2 3 -1\n    \n    -1 -1 2\n    \n    4 -1 3\n    \n    -1 5 -1\n    \n    -1 -1 -1\n    \n    3 69\n    \n    2 3 47\n    \n    -1 -1 13\n    \n    -1 -1 69\n    \n    3 3\n    \n    2 3 -1\n    \n    -1 -1 -1\n    \n    -1 -1 -1\n\nOutput\n\n    4\n    1\n    10\n    \nNote\n\nIn the first test case, the binary search tree has the following form:\n\n![](https://espresso.codeforces.com/602b54b45d686037e402a803f6366451493d4f00.png)\n\nThen the possible values at the vertices are: [2, 2, 3, 2, 2] , [2, 2, 3, 2,\n3] , [2, 2, 3, 3, 3] , and [3, 2, 3, 3, 3] .\n\nIn the second test case, the values at all vertices are known, so there is\nonly one suitable binary search tree.",
        "task_name": "1929-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\n\n# Constants\nMX = 5 * 10 ** 5\nMOD = 998244353\n\n# Combinatorics class to handle factorials and combinations\nclass Combinatorics:\n    def __init__(self, MX):\n        # Precompute factorials and their inverses\n        self.f = [1] * (MX + 1)\n        self.g = [1] * (MX + 1)\n        for i in range(2, MX + 1):\n            self.f[i] = self.f[i - 1] * i % MOD\n        self.g[-1] = pow(self.f[-1], -1, MOD)\n        for i in range(MX, 1, -1):\n            self.g[i - 1] = self.g[i] * i % MOD\n\n    def fact(self, n):\n        return self.f[n]\n\n    def fact_inv(self, n):\n        return self.g[n]\n\n    def comb(self, n, m):\n        # Calculate combination nCm\n        res = 1\n        for x in range(n, n - m, -1):\n            res = res * x % MOD\n        return (res * self.fact_inv(m)) % MOD\n\n# Initialize combinatorics\nComb = Combinatorics(MX)\n\ndef solve():\n    input = lambda: sys.stdin.readline().rstrip()\n    n, C = map(int, input().split())\n    l_son = [None] * (n + 1)\n    r_son = [None] * (n + 1)\n    vals = [None] * (n + 1)\n    \n    # Read the tree structure and values\n    for i in range(1, n + 1):\n        L, R, val = map(int, input().split())\n        l_son[i] = L if L > 0 else None\n        r_son[i] = R if R > 0 else None\n        vals[i] = val\n    \n    # In-order traversal to collect values\n    stack = []\n    nums = [1]  # Start with a minimum value\n    node = 1\n    while node or stack:\n        while node:\n            stack.append(node)\n            node = l_son[node]\n        node = stack.pop()\n        nums.append(vals[node])\n        node = r_son[node]\n    nums.append(C)  # End with the maximum value\n    \n    # Calculate the number of suitable BSTs\n    res = 1\n    l = -1\n    for r in range(n + 2):\n        if nums[r] > 0:\n            if l != -1:\n                # Calculate combinations for the segment\n                res *= Comb.comb(nums[r] - nums[l] + r - l - 1, r - l - 1)\n                res %= MOD\n            l = r\n    print(res)\n\n# Read number of test cases\nT = int(input())\nfor _ in range(T):\n    solve()",
        "correct": true,
        "task_id": 100
    },
    {
        "description": "You are given an integer n . Output a 2n \\times 2n checkerboard made of 2\n\\times 2 squares alternating '\\texttt{#} ' and '\\texttt{.} ', with the top-\nleft cell being '\\texttt{#} '.\n\n![](https://espresso.codeforces.com/3db665ec1ddded3e1be3e030c4bc89a9f297439c.png)\n\nThe picture above shows the answers for n=1,2,3,4 .\n\nInput\n\nThe first line contains an integer t (1 \\leq t \\leq 20 ) — the number of test\ncases.\n\nThe only line of each test case contains a single integer n (1 \\leq n \\leq 20\n) — it means you need to output a checkerboard of side length 2n .\n\nOutput\n\nFor each test case, output 2n lines, each containing 2n characters without\nspaces — the checkerboard, as described in the statement. Do not output empty\nlines between test cases.\n\nExample\n\nInput\n\n    4\n    \n    1\n    \n    2\n    \n    3\n    \n    4\n\nOutput\n\n    ##\n    ##\n    ##..\n    ##..\n    ..##\n    ..##\n    ##..##\n    ##..##\n    ..##..\n    ..##..\n    ##..##\n    ##..##\n    ##..##..\n    ##..##..\n    ..##..##\n    ..##..##\n    ##..##..\n    ##..##..\n    ..##..##\n    ..##..##",
        "task_name": "1950-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def main():\n    n=int(input())\n    for i in range(1,(2*n)+1):\n        for j in range(1,(2*n)+1):\n            if (i%4==0 or i%4==3):\n                if(j%4==0 or j%4==3):print('#',end='')\n                else:print('.',end='')\n            else:\n                if(j%4==0 or j%4==3):print('.',end='')\n                else:print('#',end='')\n        print()\n\nt=int(input())\nfor i in range(t):\n    main()",
        "correct": true,
        "task_id": 175
    },
    {
        "description": "Rudolf has prepared a set of n problems with complexities a_1 < a_2 < a_3 <\n\\dots < a_n . He is not entirely satisfied with the balance, so he wants to\nadd at most one problem to fix it.\n\nFor this, Rudolf came up with m models of problems and k functions. The\ncomplexity of the i -th model is d_i , and the complexity of the j -th\nfunction is f_j . To create a problem, he selects values i and j (1 \\le i \\le\nm , 1 \\le j \\le k ) and by combining the i -th model with the j -th function,\nhe obtains a new problem with complexity d_i + f_j (a new element is inserted\ninto the array a ).\n\nTo determine the imbalance of the set, Rudolf sorts the complexities of the\nproblems in ascending order and finds the largest value of a_i - a_{i - 1} (i\n> 1 ).\n\nWhat is the minimum value of imbalance that Rudolf can achieve by adding at\nmost one problem, created according to the described rules?\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of testcases.\n\nThe first line of each test case contains three integers n , m , and k (2 \\le\nn \\le 10^5 , 1 \\le m, k \\le 2 \\cdot 10^5 ) — the number of prepared problems,\nthe number of models, and the number of functions, respectively.\n\nThe second line of each test case contains n integers a_1, a_2, a_3, \\dots a_n\n(1 \\le a_i \\le 2 \\cdot 10^9 , a_i < a_{i+1} ) — the complexities of the\nprepared problems.\n\nThe third line of each test case contains m integers d_1, d_2, d_3, \\dots d_m\n(1 \\le d_i \\le 10^9 ) — the complexities of the models.\n\nThe fourth line of each test case contains k integers f_1, f_2, f_3, \\dots f_k\n(1 \\le f_i \\le 10^9 ) — the complexities of the functions.\n\nIt is guaranteed that the sum of n over all testcases does not exceed 10^5 .\n\nIt is guaranteed that the sum of m over all testcases does not exceed 2 \\cdot\n10^5 .\n\nIt is guaranteed that the sum of k over all testcases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each testcase, output a single number — the minimum imbalance that Rudolf\ncan achieve.\n\nExample\n\nInput\n\n    7\n    \n    5 5 5\n    \n    5 10 15 20 26\n    \n    11 14 16 13 8\n    \n    16 4 5 3 1\n    \n    7 6 5\n    \n    1 4 7 10 18 21 22\n    \n    2 3 5 7 4 2\n    \n    6 8 9 3 2\n    \n    7 6 5\n    \n    1 4 7 10 18 21 22\n    \n    2 3 5 7 4 2\n    \n    6 8 13 3 2\n    \n    5 6 3\n    \n    2 10 13 20 25\n    \n    11 6 10 16 14 5\n    \n    6 17 15\n    \n    4 2 2\n    \n    11 12 14 15\n    \n    19 14\n    \n    10 6\n    \n    8 4 2\n    \n    3 10 16 18 21 22 29 30\n    \n    9 13 16 15\n    \n    4 2\n    \n    2 4 7\n    \n    4 21\n    \n    4 15 14 5\n    \n    20 1 15 1 12 5 11\n\nOutput\n\n    5\n    4\n    5\n    8\n    2\n    7\n    11",
        "task_name": "1941-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    n, m, k = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    d = [int(x) for x in input().split()]\n    f = [int(x) for x in input().split()]\n    d.sort()\n    f.sort()\n\n    m1, m2 = 0, 0\n    ind = -1\n    for i in range(1, n):\n        e = a[i] - a[i - 1]\n        m2 = max(m2, e)\n        if m2 > m1:\n            m1, m2 = m2, m1\n            ind = i - 1\n\n    ans = m1\n\n    target = (a[ind] + a[ind + 1]) // 2\n    for model in d:\n        l, r = 0, k - 1\n        while r - l > 1:\n            mid = (r + l) // 2\n            if model + f[mid] <= target:\n                l = mid\n            else:\n                r = mid\n        ans = min(ans, max(m2, abs(model + f[l] - a[ind]), abs(model + f[l] - a[ind + 1])))\n        ans = min(ans, max(m2, abs(model + f[r] - a[ind]), abs(model + f[r] - a[ind + 1])))\n    print(ans)\n\n\nfor _ in range(int(input())):\n    solve()",
        "correct": true,
        "task_id": 304
    },
    {
        "description": "This is the easy version of the problem. The difference in this version is\nthat t=1 and we work on an array-like tree.\n\nRon and Hermione are playing a game on a tree of n nodes that are initially\ninactive. This tree is special because it has exactly two leaves. It can thus\nbe seen as an array. The game consists of t rounds, each of which starts with\na stone on exactly one node, which is considered as activated. A move consists\nof picking an inactive neighbor of the node with a stone on it and moving the\nstone there (thus activating this neighbor). Ron makes the first move, after\nwhich he alternates with Hermione until no valid move is available. The player\nthat cannot make a move loses the round. If both players play optimally, who\nwins each round of this game?\n\nNote that all the rounds are played with the same tree; only the starting node\nchanges. Moreover, after each round, all active nodes are considered inactive\nagain.\n\nInput\n\nThe first line contains integers n (2 \\leq n \\leq 2\\times 10^5 ), t (t=1 ),\nthe number of nodes in the tree and the number of rounds, respectively.\n\nThe next n-1 lines contain two integers 1 \\leq u, v \\leq n each, corresponding\nto an edge of the tree. It is guaranteed that the tree has exactly two leaves.\n\nThe next line contains t integers 1 \\leq u_1 , \\dots, u_t \\leq n ,\ncorresponding to the node where the stone is initially put.\n\nOutput\n\nThe output consists of t=1 line which is either \"Ron\" or \"Hermione\".\n\nExamples\n\nInput\n\n    3 1\n    \n    2 3\n    \n    3 1\n    \n    3\n\nOutput\n\n    Ron\n    \nInput\n\n    5 1\n    \n    1 2\n    \n    2 3\n    \n    3 4\n    \n    4 5\n    \n    5\n\nOutput\n\n    Hermione",
        "task_name": "1970-C1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    n, k = map(int, input().split())\n    tree = {}\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        if u not in tree:\n            tree[u] = []\n        if v not in tree:\n            tree[v] = []\n        tree[u].append(v)\n        tree[v].append(u)\n    h = int(input())\n    c = 1\n    p = 0\n    while True:\n        for u in tree[h]:\n            if u != p:\n                c += 1\n                p = h\n                h = u\n                break\n        if len(tree[h]) == 1:\n            break\n    c2 = n - c + 1\n    if c2 % 2 == 0 or c % 2 == 0:\n        print('Ron')\n    else:\n        print('Hermione')\n\nt = 1\nfor _ in range(t):\n    solve()",
        "correct": true,
        "task_id": 285
    },
    {
        "description": "This is an interactive problem.\n\nAlice has a tree T consisting of n nodes, numbered from 1 to n . Alice will\nshow T to Bob. After observing T , Bob needs to tell Alice two permutations\np_1 and p_2 of [1, 2, \\ldots, n] .\n\nThen, Alice will play q rounds of the following game.\n\n  * Alice will create an array a that is a permutation of [0,1,\\ldots,n-1] . The value of node v will be a_v . \n  * Alice will choose two nodes u and v (1 \\leq u, v \\leq n , u \\neq v ) of T and tell them to Bob. Bob will need to find the \\operatorname{MEX}^\\dagger of the values on the unique simple path between nodes u and v . \n  * To find this value, Bob can ask Alice at most 5 queries. In each query, Bob should give three integers t , l and r to Alice such that t is either 1 or 2 , and 1 \\leq l \\leq r \\leq n . Alice will then tell Bob the value equal to \n\nNote that all rounds are independent of each other. In particular, the values\nof a , u and v can be different in different rounds.\n\nBob is puzzled as he only knows the HLD solution, which requires O(\\log(n))\nqueries per round. So he needs your help to win the game.\n\n^\\dagger The \\operatorname{MEX} (minimum excludant) of a collection of\nintegers c_1, c_2, \\ldots, c_k is defined as the smallest non-negative integer\nx which does not occur in the collection c .\n\nInteraction\n\nEach test contains multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^4 ) — the number of test cases. Read it. The\ndescription of the test cases follows.\n\nThe first line of each test case contains two positive integers n and q (2\n\\leq n \\leq 10^5 , 1 \\leq q \\leq 10^4 ) — the number of nodes in T and the\nnumber of rounds respectively.\n\nThe following next n-1 lines contains two integers u and v (1 \\leq u, v \\leq n\n, u \\neq v ) — denoting an edge between nodes u and v . It is guaranteed that\nthe given edges form a tree.\n\nIt is guaranteed that the sum of n and q over all test cases does not exceed\n10^5 and 10^4 respectively.\n\nIt is also guaranteed that the sum of n \\cdot q does not exceed 3 \\cdot 10^6 .\n\nThe interaction for each test case begins by outputting two permutations p_1\nand p_2 of [1, 2, \\ldots, n] .\n\nOn a new line, output n space-separated distinct integers denoting p_1 .\n\nIn the next line, output n space-separated distinct integers denoting p_2 .\n\nAlice will start playing the game.\n\nFor each round, you must read two integers, u and v (1 \\leq u, v \\leq n , u\n\\neq v ). You need to find the \\operatorname{MEX} of the values on the unique\nsimple path between nodes u and v .\n\nTo make a query, output \"? t l r \" without quotes, such that t is either 1 or\n2 , and 1 \\leq l \\leq r \\leq n . Afterwards, you should read a single integer\n— the answer to your query \\min_{i=l}^{r} a_{p_{t,i}} . You can make at most 5\nsuch queries in each round.\n\nIf you want to print the answer, output \"! x \" (1 \\leq x, y \\leq n ) without\nquotes. After doing that, read a single integer, which is normally equal to 1\n.\n\nIf you receive the integer -1 instead of a valid reply, it means your program\nhas made an invalid query, exceeded the query limit, or gave an incorrect\nanswer on the previous test case. Your program must terminate immediately to\nreceive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict\nbecause your solution will continue to read from a closed stream.\n\nAfter printing a query or the answer, do not forget to output the end of the\nline and flush the output. Otherwise, you will get Idleness limit exceeded. To\ndo this, use:\n\n  * fflush(stdout) or cout.flush() in C++; \n  * System.out.flush() in Java; \n  * flush(output) in Pascal; \n  * stdout.flush() in Python; \n  * see documentation for other languages. \n\nHacks\n\nTo hack, follow the test format below.\n\nThe first line should contain a single integer t (1 \\le t \\le 10^4 ) — the\nnumber of test cases.\n\nThe first line of each test case should contain two positive integers n and q\n(2 \\leq n \\leq 10^5 ; 1 \\leq q \\leq 10^4 ) — the number of nodes in T and the\nnumber of rounds respectively.\n\nThe following next n-1 lines should contain two integers u and v (1 \\leq u, v\n\\leq n , u \\neq v ) — denoting an edge between nodes u and v . The given edges\nmust form a tree.\n\nFor each of the q rounds, first print a permutation of [0, 1, 2, \\ldots, n-1]\non a new line, denoting the array a chosen by Alice during the start of the\nround.\n\nIn the following line, print two distinct nodes u and v (1 \\leq u, v \\leq v ,\nu \\neq v ), representing the endpoints of the path asked by Alice.\n\nThe sum of n and q over all test cases should not exceed 10^5 and 10^4\nrespectively.\n\nThe sum of n \\cdot q should not exceed 3 \\cdot 10^6 .\n\nExample\n\nInput\n\nCopy\n\n    1\n    3 1\n    1 2\n    2 3\n    \n    2 3\n    \n    1\n    \n    0\n    \n    1\n\nOutput\n\nCopy\n\n    1 2 3\n    2 1 3\n    \n    ? 1 2 3\n    \n    ? 2 1 3\n    \n    ! 0\n    \nNote\n\nIn the first test, the interaction proceeds as follows.\n\nSolution| Jury| Explanation  \n---|---|---  \n| 1| There are 1 test cases.  \n| 3 1| The tree T consists of 3 nodes, and Alice will play for only one round.  \n| 1 2| First edge of T  \n| 2 3| Second edge of T  \n1 2 3| | The permutation p_1   \n2 1 3| | The permutation p_2   \n| | Alice shuffles a to a=[0,2,1] before giving the nodes for the only round.  \n| 2 3| Nodes for the round  \n? 1 2 3| 1| \\min(a_{p_{1,2}},a_{p_{1,3}})=\\min(a_2,a_3)=1  \n? 2 1 3| 0| \\min(a_{p_{2,1}},a_{p_{2,2}},a_{p_{2,3}})=\\min(a_2,a_1,a_3)=0  \n! 0| 1| Considering the output of queries, it is clear that \\operatorname{MEX}\nis 0 . Since the output is correct, the jury responds with 1 .  \n  \nAfter each test case, make sure to read 1 or -1 .",
        "task_name": "1930-H",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\nimport random\n\n# Function to query Alice\ndef query(t, l, r):\n    print(f\"? {t} {l} {r}\")\n    sys.stdout.flush()\n    return int(input().strip())\n\n# Function to print the answer\ndef print_answer(ans):\n    print(f\"! {ans}\")\n    sys.stdout.flush()\n    input()  # Read Bob's response (normally 1)\n\n# Function to perform binary search to find MEX\ndef find_mex(n, u, v):\n    l, r = 0, n - 1\n    while l < r:\n        mid = (l + r) // 2\n        if query(1, u + 1, mid + 1):\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\n# Function to shuffle array a\ndef shuffle_array(a):\n    n = len(a)\n    for i in range(n):\n        j = random.randint(i, n - 1)\n        a[i], a[j] = a[j], a[i]\n\n# Main function\ndef main():\n    t = int(input())  # Number of test cases\n    for _ in range(t):\n        n, q = map(int, input().split())  # Number of nodes and rounds\n        adj_list = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            adj_list[u - 1].append(v - 1)\n            adj_list[v - 1].append(u - 1)\n\n        # Generate two random permutations\n        p1 = list(range(1, n + 1))\n        p2 = list(range(1, n + 1))\n        shuffle_array(p1)\n        shuffle_array(p2)\n\n        print(*p1)\n        sys.stdout.flush()\n        print(*p2)\n        sys.stdout.flush()\n\n        # Process each round\n        for _ in range(q):\n            u, v = map(int, input().split())  # Nodes for the round\n            u -= 1\n            v -= 1\n            mex = find_mex(n, u, v)\n            print_answer(mex)\n\n# Execute main function\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 322
    },
    {
        "description": "You are given a binary string s of length n , consisting of zeros and ones.\nYou can perform the following operation exactly once:\n\n  1. Choose an integer p (1 \\le p \\le n ). \n  2. Reverse the substring s_1 s_2 \\ldots s_p . After this step, the string s_1 s_2 \\ldots s_n will become s_p s_{p-1} \\ldots s_1 s_{p+1} s_{p+2} \\ldots s_n . \n  3. Then, perform a cyclic shift of the string s to the left p times. After this step, the initial string s_1s_2 \\ldots s_n will become s_{p+1}s_{p+2} \\ldots s_n s_p s_{p-1} \\ldots s_1 . \n\nFor example, if you apply the operation to the string 110001100110 with p=3 ,\nafter the second step, the string will become 011001100110, and after the\nthird step, it will become 001100110011.\n\nA string s is called k -proper if two conditions are met:\n\n  * s_1=s_2=\\ldots=s_k ; \n  * s_{i+k} \\neq s_i for any i (1 \\le i \\le n - k ). \n\nFor example, with k=3 , the strings 000, 111000111, and 111000 are k -proper,\nwhile the strings 000000, 001100, and 1110000 are not.\n\nYou are given an integer k , which is a divisor of n . Find an integer p (1\n\\le p \\le n ) such that after performing the operation, the string s becomes k\n-proper, or determine that it is impossible. Note that if the string is\ninitially k -proper, you still need to apply exactly one operation to it.\n\nInput\n\nEach test consists of multiple test cases. The first line contains one integer\nt (1 \\le t \\le 10^4 ) — the number of test cases. The description of the test\ncases follows.\n\nThe first line of each test case contains two integers n and k (1 \\le k \\le n\n, 2 \\le n \\le 10^5 ) — the length of the string s and the value of k . It is\nguaranteed that k is a divisor of n .\n\nThe second line of each test case contains a binary string s of length n ,\nconsisting of the characters 0 and 1.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single integer — the value of p to make the\nstring k -proper, or -1 if it is impossible.\n\nIf there are multiple solutions, output any of them.\n\nExample\n\nInput\n\n    7\n    \n    8 4\n    \n    11100001\n    \n    4 2\n    \n    1110\n    \n    12 3\n    \n    111000100011\n    \n    5 5\n    \n    00000\n    \n    6 1\n    \n    101001\n    \n    8 4\n    \n    01110001\n    \n    12 2\n    \n    110001100110\n\nOutput\n\n    3\n    -1\n    7\n    5\n    4\n    -1\n    3\n    \nNote\n\nIn the first test case, if you apply the operation with p=3 , after the second\nstep of the operation, the string becomes 11100001, and after the third step,\nit becomes 00001111. This string is 4 -proper.\n\nIn the second test case, it can be shown that there is no operation after\nwhich the string becomes 2 -proper.\n\nIn the third test case, if you apply the operation with p=7 , after the second\nstep of the operation, the string becomes 100011100011, and after the third\nstep, it becomes 000111000111. This string is 3 -proper.\n\nIn the fourth test case, after the operation with any p , the string becomes 5\n-proper.",
        "task_name": "1979-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def find_p(s, n, k):\n    count = [0] * n\n    for i in range(n):\n        count[i] = count[i - 1] + (1 if s[i] == '1' else 0)\n\n    for p in range(1, n + 1):\n        reversed_count = count[p - 1] + (n - p) - (count[n - 1] - count[p - 1])\n        shifted_count = count[p - 1] + (n - p)\n\n        if reversed_count >= k and shifted_count % k == 0:\n            return p\n\n    return -1",
        "correct": false,
        "task_id": 300
    }
]