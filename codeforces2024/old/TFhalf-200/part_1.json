[
    {
        "description": "Monocarp is playing a computer game (yet again). Guess what is he doing?\nThat's right, killing monsters.\n\nThere are n monsters in a row, numbered from 1 to n . The i -th monster has\ntwo parameters: attack value equal to a_i and defense value equal to d_i . In\norder to kill these monsters, Monocarp put a berserk spell on them, so they're\nattacking each other instead of Monocarp's character.\n\nThe fight consists of n rounds. Every round, the following happens:\n\n  * first, every alive monster i deals a_i damage to the closest alive monster to the left (if it exists) and the closest alive monster to the right (if it exists); \n  * then, every alive monster j which received more than d_j damage during this round dies. I. e. the j -th monster dies if and only if its defense value d_j is strictly less than the total damage it received this round. \n\nFor each round, calculate the number of monsters that will die during that\nround.\n\nInput\n\nThe first line contains one integer t (1 \\le t \\le 10^4 ) — the number of test\ncases.\n\nEach test case consists of three lines:\n\n  * the first line contains one integer n (1 \\le n \\le 3 \\cdot 10^5 ); \n  * the second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le 10^9 ); \n  * the third line contains n integers d_1, d_2, \\dots, d_n (1 \\le d_i \\le 10^9 ). \n\nAdditional constraint on the input: the sum of n over all test cases does not\nexceed 3 \\cdot 10^5 .\n\nOutput\n\nFor each test case, print n integers. The i -th integer should be equal to the\nnumber of monsters that die during the i -th round.\n\nExample\n\nInput\n\n    3\n    \n    5\n    \n    3 4 7 5 10\n    \n    4 9 1 18 1\n    \n    2\n    \n    2 1\n    \n    1 3\n    \n    4\n    \n    1 1 2 4\n    \n    3 3 4 2\n\nOutput\n\n    3 1 0 0 0 \n    0 0 \n    1 1 1 0 \n    \nNote\n\nExplanation for the first test case of the example:\n\nDuring the first round, the following happens:\n\n  * the monster 1 deals 3 damage to the monster 2 ; \n  * the monster 2 deals 4 damage to the monster 1 and the monster 3 ; \n  * the monster 3 deals 7 damage to the monster 2 and the monster 4 ; \n  * the monster 4 deals 5 damage to the monster 3 and the monster 5 ; \n  * the monster 5 deals 10 damage to the monster 4 ; \n  * the monster 1 does not die, since it received 4 damage and its defense is 4 ; \n  * the monster 2 dies, since it received 10 damage and its defense is 9 ; \n  * the monster 3 dies, since it received 9 damage and its defense is 1 ; \n  * the monster 4 does not die, since it received 17 damage and its defense is 18 ; \n  * the monster 5 dies, since it received 5 damage and its defense is 1 . \n\nAfter the first round, the monsters 1 and 4 stay alive.\n\nDuring the second round, the following happens:\n\n  * the monster 1 deals 3 damage to the monster 4 ; \n  * the monster 4 deals 5 damage to the monster 1 ; \n  * the monster 1 dies, since it received 5 damage and its defense is 4 ; \n  * the monster 4 does not die, since it received 3 damage and its defense is 18 . \n\nDuring the next three rounds, only the 4 -th monster is alive, so nothing\nhappens.",
        "task_name": "1922-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\ninput = sys.stdin.readline\n\n# Function to read a list of integers from input\nF = lambda: [*map(int, input().split())]\n\n# Process each test case\nfor _ in range(int(input())):\n    N = int(input())  # Number of monsters\n    A = [0] + F() + [0]  # Attack values with padding\n    D = [0] + F() + [0]  # Defense values with padding\n\n    # Initialize next and previous pointers for each monster\n    NXT = [(i + 1) % (N + 1) for i in range(N + 1)]\n    PRV = [N] + [i for i in range(N)]\n    CHK = [(i + 1) for i in range(N)]  # List of monsters to check\n    ANS = [0] * N  # Array to store the number of deaths per round\n\n    # Simulate each round\n    for round in range(N):\n        cnt = 0  # Counter for the number of deaths in this round\n        TMP = []  # Temporary list for next round's checks\n        RMV = set()  # Set of monsters to be removed\n\n        # Check each monster in the current round\n        for a in CHK:\n            prv, nxt = PRV[a], NXT[a]  # Get previous and next alive monsters\n            # Check if the monster dies\n            if D[a] < A[prv] + A[nxt]:\n                cnt += 1  # Increment death count\n                # Update TMP and RMV\n                if TMP and TMP[-1] == a:\n                    TMP.pop()\n                if (not TMP or TMP[-1] != prv) and prv > 0 and prv not in RMV:\n                    TMP.append(prv)\n                if 1 <= nxt <= N:\n                    TMP.append(nxt)\n                RMV.add(a)\n\n        # Update pointers for dead monsters\n        for a in RMV:\n            prv, nxt = PRV[a], NXT[a]\n            PRV[nxt] = prv\n            NXT[prv] = nxt\n\n        # Update CHK for the next round\n        CHK = TMP[:]\n        ANS[round] = cnt  # Store the number of deaths in this round\n\n        # If no monsters died, break early\n        if cnt == 0:\n            break\n\n    # Output the result for the current test case\n    print(*ANS)",
        "correct": true,
        "task_id": 206
    },
    {
        "description": "There are n \\cdot m unit cubes currently in positions (1, 1, 1) through (n, m,\n1) . Each of these cubes is one of k colors. You want to add additional cubes\nat any integer coordinates such that the subset of cubes of each color is\nconnected, where two cubes are considered connected if they share a face.\n\nIn other words, for every pair of cubes of the same color c , it should be\npossible to travel from one to the other, moving only through cubes of color c\nthat share a face.\n\nThe existing cubes are currently in the corner of a room. There are colorless\ncubes completely filling the planes x = 0 , y = 0 , and z = 0 , preventing you\nfrom placing additional cubes there or at any negative coordinates.\n\n![](https://espresso.codeforces.com/ef91a6482127f2f096398f37bef20533cad70612.png)\n\nFind a solution that uses at most 4 \\cdot 10^5 additional cubes (not including\nthe cubes that are currently present), or determine that there is no solution.\nIt can be shown that under the given constraints, if there is a solution,\nthere is one using at most 4 \\cdot 10^5 additional cubes.\n\nInput\n\nThe first line of the input contains three integers n , m , and k (2 \\le n, m,\nk \\le 50 ) — the number of rows and columns of cubes, and the number of\ncolors, respectively.\n\nThe i -th of the next n lines contains m integers. The j -th of these is\na_{ij} (1 \\le a_{ij} \\le k ) — the color of the cube at position (i, j, 1) .\nFor every color from 1 to k , it is guaranteed that there is at least one cube\nin the input of that color.\n\nOutput\n\nIf there is no solution, print a single integer -1 .\n\nOtherwise, the first line of output should contain a single integer p (0 \\le p\n\\le 4 \\cdot 10^5 ) — the number of additional cubes you will add.\n\nThe next p lines should contain four integers x , y , z and c (1 \\le x, y, z\n\\le 10^6 , 1 \\le c \\le k ) — indicating that you are adding a cube with color\nc at position (x, y, z) .\n\nNo two cubes in the output should have the same coordinates, and no cube in\nthe output should have the same coordinates as any cube in the input.\n\nIf there are multiple solutions, print any.\n\nExamples\n\nInput\n\n    3 4 3\n    \n    3 2 3 1\n    \n    1 1 1 1\n    \n    1 3 3 2\n\nOutput\n\n    13\n    1 1 2 3\n    1 3 2 3\n    2 1 2 3\n    2 2 2 3\n    2 3 2 3\n    3 3 2 3\n    1 2 2 2\n    1 2 3 2\n    1 3 3 2\n    1 4 3 2\n    2 4 3 2\n    3 4 3 2\n    3 4 2 2\n    \nInput\n\n    2 2 2\n    \n    2 1\n    \n    1 2\n\nOutput\n\n    9\n    1 3 1 1\n    2 3 1 1\n    3 1 1 1\n    3 2 1 1\n    3 3 1 1\n    1 1 2 2\n    1 2 2 2\n    2 1 2 2\n    2 2 2 2\n    \nNote\n\nThe image in the statement corresponds to the first example case, with\n\\text{red} = 1 , \\text{blue} = 2 , \\text{green} = 3 .",
        "task_name": "1965-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        index += 1\n        subarray_sums = list(map(int, data[index:index + (n * (n + 1) // 2 - 1)]))\n        index += (n * (n + 1) // 2 - 1)\n        \n        # We need to find the missing subarray sum\n        # Let's assume the missing subarray is the whole array sum\n        # We can calculate the expected total sum of all subarray sums if none were missing\n        total_subarray_sum = sum(subarray_sums)\n        expected_full_subarray_sum = (n * (n + 1) // 2) * (n + 1) // 2\n        \n        # Calculate the missing sum\n        missing_sum = expected_full_subarray_sum - total_subarray_sum\n        \n        # Now we need to construct a valid palindrome array `a` of size `n`\n        # that has all subarray sums as given plus one missing sum that we calculated\n        # This is a constructive problem, we need to ensure the array is a palindrome\n        # and all subarray sums are possible\n        \n        # Simplest valid construction for small cases or specific patterns\n        # For larger n, we need a more sophisticated method to ensure all sums are possible\n        # Here we use a simple heuristic to construct a valid palindrome array\n        \n        # We start by assuming the array is all ones, which is a simple valid palindrome\n        a = [1] * n\n        \n        # We adjust the array to fit the missing sum by increasing the middle elements\n        # since it's a palindrome, we adjust symmetrically\n        mid = n // 2\n        if n % 2 == 1:  # odd length\n            a[mid] += missing_sum\n        else:  # even length, distribute the missing sum to the two middle elements\n            half_missing = missing_sum // 2\n            a[mid - 1] += half_missing\n            a[mid] += half_missing\n        \n        # Output the result for this test case\n        results.append(f\"{n}\")\n        results.append(\" \".join(map(str, a)))\n    \n    # Print all results for each test case\n    print(\"\\n\".join(results))",
        "correct": false,
        "task_id": 345
    },
    {
        "description": "You are given n sticks of lengths a_1, a_2, \\ldots, a_n . Find the maximum\nnumber of regular (equal-sided) polygons you can construct simultaneously,\nsuch that:\n\n  * Each side of a polygon is formed by exactly one stick. \n  * No stick is used in more than 1 polygon. \n\nNote: Sticks cannot be broken.\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 100 ) — the number\nof test cases.\n\nThe first line of each test case contains a single integer n (1 \\leq n \\leq\n100 ) — the number of sticks available.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\leq a_i \\leq 100 ) — the stick lengths.\n\nOutput\n\nFor each test case, output a single integer on a new line — the maximum number\nof regular (equal-sided) polygons you can make simultaneously from the sticks\navailable.\n\nExample\n\nInput\n\n    4\n    \n    1\n    \n    1\n    \n    2\n    \n    1 1\n    \n    6\n    \n    2 2 3 3 3 3\n    \n    9\n    \n    4 2 2 2 2 4 2 4 4\n\nOutput\n\n    0\n    0\n    1\n    2\n    \nNote\n\nIn the first test case, we only have one stick, hence we can't form any\npolygon.\n\nIn the second test case, the two sticks aren't enough to form a polygon\neither.\n\nIn the third test case, we can use the 4 sticks of length 3 to create a\nsquare.\n\nIn the fourth test case, we can make a pentagon with side length 2 , and a\nsquare of side length 4 .",
        "task_name": "1957-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections  import Counter\nimport math\nfor _ in range(int(input())):\n    n=int(input())\n    edges=list(map(int,input().split()))\n\n    count=Counter(edges)\n    polygons=0\n\n    for value in count.values():\n        if value>2:\n            polygons+=value//3\n    print(polygons)",
        "correct": true,
        "task_id": 195
    },
    {
        "description": "[Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)\n\nඞ\n\nThere are m baskets placed along a circle, numbered from 1 to m in clockwise\norder (basket m is next to basket 1 ). Furthermore, there are n balls, where\nball i is initially placed in basket a_i , and no basket contains more than\none ball.\n\nAlice is allowed to perform the following operation, which always takes\nexactly one second whether you move/throw a ball or not:\n\n  * Alice chooses an integer i between 1 and n uniformly at random. \n  * If ball i was thrown away before, do nothing. \n  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. \n\nShe repeats this operation until there is exactly one ball left. Calculate the\nexpected time needed (in seconds) for Alice to end the process.\n\nIt can be proven that the answer can be represented as a rational number\n\\frac{p}{q} with coprime p and q . You need to output p \\cdot q^{-1} \\bmod\n10^9 + 7 . It can be proven that 10^9 + 7 \\nmid q .\n\nInput\n\nEach test contains multiple test cases. The first line contains an integer t\n(1 \\le t \\le 10^4 ) — the number of test cases. The description of the test\ncases follows.\n\nThe first line of each test case contains two integers n and m (1 \\le n \\le 3\n\\cdot 10^5, n \\le m \\le 10^9 ) — the number of balls and the number of\nbaskets.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le m , a_i 's are pairwise distinct) — the initial position of each\nball.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, print one integer: the expected amount of time (in\nseconds) Alice needs to end the process, modulo 10^9 + 7 .\n\nExample\n\nInput\n\n    5\n    \n    3 10\n    \n    5 1 4\n    \n    2 15\n    \n    15 1\n    \n    6 6\n    \n    1 2 3 4 5 6\n    \n    6 9\n    \n    6 5 4 3 2 1\n    \n    1 100\n    \n    69\n\nOutput\n\n    600000042\n    14\n    35\n    333333409\n    0\n    \nNote\n\nIn the first test case, Alice could have proceeded as follows (we define a_i =\n-1 if ball i has been thrown out):\n\n  * Initially, a = [5, 1, 4] . \n  * Alice chooses i = 2 with probability \\frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . \n  * Alice chooses i = 2 with probability \\frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . \n  * Alice chooses i = 2 with probability \\frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . \n  * Alice chooses i = 3 with probability \\frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . \n  * Alice chooses i = 2 with probability \\frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. \n\nThe answer for this test case is \\frac{189}{5} .\n\nThe answer for the second test case is 14 (note that these two balls are next\nto each other).\n\nThe answer for the third test case is 35 .\n\nThe answer for the fourth test case is \\frac{220}{3} .\n\nIn the fifth test case, as there is only one ball initially, the answer is 0 .",
        "task_name": "1951-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "MOD = 10**9 + 7\ninv_2 = (MOD + 1) // 2\ninv_3 = pow(3, MOD - 2, MOD)\n\ntc = int(input())\n\nfor _ in range(tc):\n    n, m = map(int, input().split())\n    a = sorted(list(map(int, input().split())))\n\n    inv_m = pow(m, MOD - 2, MOD)\n    ans = 0\n    for i in range(n):\n        dist = (a[(i + 1) % n] - a[i]) % m\n        prob_last = dist * inv_m % MOD\n        expected_getting_moved = n * inv_2 % MOD\n        expected_time = (m * m - dist * dist) * inv_3 % MOD\n        ans += prob_last * expected_getting_moved % MOD * expected_time % MOD\n        ans %= MOD\n\n    print(ans)",
        "correct": true,
        "task_id": 155
    },
    {
        "description": "There is a clock labeled with the numbers 1 through 12 in clockwise order, as\nshown below.\n\n![](https://espresso.codeforces.com/1e87df1aba4cbffb31068e202e70b895a23a5586.png)\n\nIn this example, (a,b,c,d)=(2,9,10,6) , and the strings intersect.\n\nAlice and Bob have four distinct integers a , b , c , d not more than 12 .\nAlice ties a red string connecting a and b , and Bob ties a blue string\nconnecting c and d . Do the strings intersect? (The strings are straight line\nsegments.)\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 5940 ) — the number\nof test cases.\n\nThe only line of each test case contains four distinct integers a , b , c , d\n(1 \\leq a, b, c, d \\leq 12 ).\n\nOutput\n\nFor each test case, output \"YES\" (without quotes) if the strings intersect,\nand \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\",\nand \"Yes\" will be recognized as a positive response).\n\nExample\n\nInput\n\n    15\n    \n    2 9 10 6\n    \n    3 8 9 1\n    \n    1 2 3 4\n    \n    5 3 4 12\n    \n    1 8 2 10\n    \n    3 12 11 8\n    \n    9 10 12 1\n    \n    12 1 10 2\n    \n    3 12 6 9\n    \n    1 9 8 4\n    \n    6 7 9 12\n    \n    7 12 9 6\n    \n    10 12 11 1\n    \n    3 9 6 12\n    \n    1 4 3 5\n\nOutput\n\n    YES\n    NO\n    NO\n    YES\n    YES\n    NO\n    NO\n    NO\n    NO\n    NO\n    NO\n    YES\n    YES\n    YES\n    YES\n    \nNote\n\nThe first test case is pictured in the statement.\n\nIn the second test case, the strings do not intersect, as shown below.\n\n![](https://espresso.codeforces.com/e089e5742688ef3918a5843591edd82871f9f7dc.png)",
        "task_name": "1971-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def is_intersect(a, b, c, d):\n    # 按照顺时针顺序排列\n    points = sorted([a, b, c, d])\n    # 获取两条线段的位置\n    i1, i2, i3, i4 = points\n    # 判断是否相交：一条线段的端点在另一条线段的两侧\n    # 判断条件：i1-i2 是一条线段，i3-i4 是另一条线段，如果它们交错，则返回 True\n    return (i1 < i3 < i2 < i4)\n\n# 输入处理\nt = int(input())  # 测试用例数量\nresults = []\n\nfor _ in range(t):\n    a, b, c, d = map(int, input().split())\n    if is_intersect(a, b, c, d):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\n# 输出结果\nprint(\"\\n\".join(results))",
        "correct": false,
        "task_id": 224
    },
    {
        "description": "You are given two integers x and y . A sequence a of length n is called\nmodular if a_1=x , and for all 1 < i \\le n the value of a_{i} is either\na_{i-1} + y or a_{i-1} \\bmod y . Here x \\bmod y denotes the remainder from\ndividing x by y .\n\nDetermine if there exists a modular sequence of length n with the sum of its\nelements equal to S , and if it exists, find any such sequence.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1 \\le t \\le 2 \\cdot 10^4 ). The description of the test cases\nfollows.\n\nThe first and only line of each test case contains four integers n , x , y ,\nand s (1 \\le n \\le 2 \\cdot 10^5 , 0 \\le x \\le 2 \\cdot 10^5 , 1 \\le y \\le 2\n\\cdot 10^5 , 0 \\le s \\le 2 \\cdot 10^5 ) — the length of the sequence, the\nparameters x and y , and the required sum of the sequence elements.\n\nThe sum of n over all test cases does not exceed 2 \\cdot 10^5 , and also the\nsum of s over all test cases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, if the desired sequence exists, output \"Yes\" on the first\nline (without quotes). Then, on the second line, output n integers a_1, a_2,\n\\ldots, a_n separated by a space — the elements of the sequence a . If there\nare multiple suitable sequences, output any of them.\n\nIf the sequence does not exist, output \"No\" on a single line.\n\nYou can output each letter in any case (lowercase or uppercase). For example,\nthe strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive\nanswer.\n\nExample\n\nInput\n\n    3\n    \n    5 8 3 28\n    \n    3 5 3 6\n    \n    9 1 5 79\n\nOutput\n\n    YES\n    8 11 2 2 5 \n    NO\n    NO\n    \nNote\n\nIn the first example, the sequence [8, 11, 2, 5, 2] satisfies the conditions.\nThus, a_1 = 8 = x , a_2 = 11 = a_1 + 3 , a_3 = 2 = a_2 \\bmod 3 , a_4 = 5 = a_3\n+ 3 , a_5 = 2 = a_4 \\bmod 3 .\n\nIn the second example, the first element of the sequence should be equal to 5\n, so the sequence [2, 2, 2] is not suitable.",
        "task_name": "1928-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def find_modular_sequence(n, x, y, s):\n    # Initialize the sequence with the first element\n    sequence = [x]\n    current_sum = x\n\n    # Calculate the sequence\n    for i in range(1, n):\n        # Check if adding y or taking mod y will help reach the sum\n        if current_sum + y <= s and (s - current_sum - y) % y == 0:\n            sequence.append(sequence[-1] + y)\n            current_sum += y\n        else:\n            sequence.append(sequence[-1] % y)\n            current_sum += sequence[-1]\n\n        # If the current sum exceeds the required sum, it's not possible\n        if current_sum > s:\n            return None\n\n    # Check if the final sum matches the required sum\n    if current_sum == s:\n        return sequence\n    else:\n        return None\n\n# Input reading\nt = int(input())\nfor _ in range(t):\n    n, x, y, s = map(int, input().split())\n    result = find_modular_sequence(n, x, y, s)\n    if result:\n        print(\"Yes\")\n        print(\" \".join(map(str, result)))\n    else:\n        print(\"No\")",
        "correct": false,
        "task_id": 60
    },
    {
        "description": "Turtle Alice is currently designing a fortune cookie box, and she would like\nto incorporate the theory of LuoShu into it.\n\nThe box can be seen as an n \\times m grid (n, m \\ge 5 ), where the rows are\nnumbered 1, 2, \\dots, n and columns are numbered 1, 2, \\dots, m . Each cell\ncan either be empty or have a single fortune cookie of one of the following\nshapes: circle or square. The cell at the intersection of the a -th row and\nthe b -th column is denoted as (a, b) .\n\nInitially, the entire grid is empty. Then, Alice performs q operations on the\nfortune cookie box. The i -th operation (1 \\le i \\le q ) is as follows:\nspecify a currently empty cell (r_i,c_i) and a shape (circle or square), then\nput a fortune cookie of the specified shape on cell (r_i,c_i) . Note that\nafter the i -th operation, the cell (r_i,c_i) is no longer empty.\n\nBefore all operations and after each of the q operations, Alice wonders what\nthe number of ways to place fortune cookies in all remaining empty cells is,\nsuch that the following condition is satisfied:\n\nNo three consecutive cells (in horizontal, vertical, and both diagonal\ndirections) contain cookies of the same shape. Formally:\n\n  * There does not exist any (i,j) satisfying 1 \\le i \\le n, 1 \\le j \\le m-2 , such that there are cookies of the same shape in cells (i,j), (i,j+1), (i,j+2) . \n  * There does not exist any (i,j) satisfying 1 \\le i \\le n-2, 1 \\le j \\le m , such that there are cookies of the same shape in cells (i,j), (i+1,j), (i+2,j) . \n  * There does not exist any (i,j) satisfying 1 \\le i \\le n-2, 1 \\le j \\le m-2 , such that there are cookies of the same shape in cells (i,j), (i+1,j+1), (i+2,j+2) . \n  * There does not exist any (i,j) satisfying 1 \\le i \\le n-2, 1 \\le j \\le m-2 , such that there are cookies of the same shape in cells (i,j+2), (i+1,j+1), (i+2,j) . \n\nYou should output all answers modulo 998\\,244\\,353 . Also note that it is\npossible that after some operations, the condition is already not satisfied\nwith the already placed candies, in this case you should output 0 .\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^3 ) —\nthe number of test cases.\n\nThe first line of each test case contains three integers n , m , q (5 \\le n, m\n\\le 10^9, 0 \\le q \\le \\min(n \\times m, 10^5) ).\n\nThe i -th of the next q lines contains two integers r_i , c_i and a single\nstring \\text{shape}_i (1 \\le r_i \\le n, 1 \\le c_i \\le m , \\text{shape}_i=\n\"circle\" or \"square\"), representing the operations. It is guaranteed that the\ncell on the r_i -th row and the c_i -th column is initially empty. That means,\neach (r_i,c_i) will appear at most once in the updates.\n\nThe sum of q over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, output q+1 lines. The first line of each test case should\ncontain the answer before any operations. The i -th line (2 \\le i \\le q+1 )\nshould contain the answer after the first i-1 operations. All answers should\nbe taken modulo 998\\,244\\,353 .\n\nExample\n\nInput\n\n    2\n    \n    6 7 4\n    \n    3 3 circle\n    \n    3 6 square\n    \n    5 3 circle\n    \n    5 4 square\n    \n    5 5 3\n    \n    1 1 circle\n    \n    1 2 circle\n    \n    1 3 circle\n\nOutput\n\n    8\n    4\n    3\n    1\n    0\n    8\n    4\n    1\n    0\n    \nNote\n\nIn the second sample, after placing a circle-shaped fortune cookie to cells\n(1,1) , (1,2) and (1,3) , the condition is already not satisfied. Therefore,\nyou should output 0 .",
        "task_name": "1933-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "MOD = 998244353\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        q = int(data[index + 2])\n        index += 3\n        \n        operations = []\n        for __ in range(q):\n            r = int(data[index])\n            c = int(data[index + 1])\n            shape = data[index + 2]\n            operations.append((r, c, shape))\n            index += 3\n        \n        # Initial number of ways\n        total_cells = n * m\n        initial_ways = pow(2, total_cells, MOD)\n        results.append(initial_ways)\n        \n        # Grid to store the current state\n        grid = {}\n        valid = True\n        \n        def check_violation(r, c):\n            # Check horizontal\n            if (r, c) in grid and (r, c+1) in grid and (r, c+2) in grid:\n                if grid[(r, c)] == grid[(r, c+1)] == grid[(r, c+2)]:\n                    return True\n            # Check vertical\n            if (r, c) in grid and (r+1, c) in grid and (r+2, c) in grid:\n                if grid[(r, c)] == grid[(r+1, c)] == grid[(r+2, c)]:\n                    return True\n            # Check diagonal \\\n            if (r, c) in grid and (r+1, c+1) in grid and (r+2, c+2) in grid:\n                if grid[(r, c)] == grid[(r+1, c+1)] == grid[(r+2, c+2)]:\n                    return True\n            # Check diagonal /\n            if (r, c) in grid and (r+1, c-1) in grid and (r+2, c-2) in grid:\n                if grid[(r, c)] == grid[(r+1, c-1)] == grid[(r+2, c-2)]:\n                    return True\n            return False\n        \n        for r, c, shape in operations:\n            if not valid:\n                results.append(0)\n                continue\n            \n            grid[(r, c)] = shape\n            \n            # Check for violations around the newly placed cookie\n            if check_violation(r, c) or check_violation(r, c-1) or check_violation(r, c-2) or \\\n               check_violation(r-1, c) or check_violation(r-2, c):\n                valid = False\n                results.append(0)\n            else:\n                # Calculate the number of ways for the remaining empty cells\n                remaining_cells = total_cells - len(grid)\n                ways = pow(2, remaining_cells, MOD)\n                results.append(ways)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")",
        "correct": false,
        "task_id": 127
    },
    {
        "description": "Alice and Bob came up with a rather strange game. They have an array of\nintegers a_1, a_2,\\ldots, a_n . Alice chooses a certain integer k and tells it\nto Bob, then the following happens:\n\n  * Bob chooses two integers i and j (1 \\le i < j \\le n ), and then finds the maximum among the integers a_i, a_{i + 1},\\ldots, a_j ; \n  * If the obtained maximum is strictly greater than k , Alice wins, otherwise Bob wins. \n\nHelp Alice find the maximum k at which she is guaranteed to win.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (2 \\le n \\le 5\n\\cdot 10^4 ) — the number of elements in the array.\n\nThe second line of each test case contains n integers a_1, a_2,\\ldots, a_n (1\n\\le a_i \\le 10^9 ) — the elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot\n10^4 .\n\nOutput\n\nFor each test case, output one integer — the maximum integer k at which Alice\nis guaranteed to win.\n\nExample\n\nInput\n\n    6\n    \n    4\n    \n    2 4 1 7\n    \n    5\n    \n    1 2 3 4 5\n    \n    2\n    \n    1 1\n    \n    3\n    \n    37 8 16\n    \n    5\n    \n    10 10 10 10 9\n    \n    10\n    \n    3 12 9 5 2 3 2 9 8 2\n\nOutput\n\n    3\n    1\n    0\n    15\n    9\n    2\n    \nNote\n\nIn the first test case, all possible subsegments that Bob can choose look as\nfollows: [2, 4], [2, 4, 1], [2, 4, 1, 7], [4, 1], [4, 1, 7], [1, 7] . The\nmaximums on the subsegments are respectively equal to 4, 4, 7, 4, 7, 7 . It\ncan be shown that 3 is the largest integer such that any of the maximums will\nbe strictly greater than it.\n\nIn the third test case, the only segment that Bob can choose is [1, 1] . So\nthe answer is 0 .",
        "task_name": "1979-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int,input().split()))\n    mini = 0\n    maxi = -1\n    for i in range(1,n):\n        if arr[i] < arr[mini]:\n            mini = i\n  \n    for i in range(mini,-1,-1):\n        if arr[i] > arr[mini]:\n            maxi = arr[i] - 1\n            break\n    \n    for i in range(mini +1, n):\n        if (maxi < 0 or arr[i] < maxi) and arr[i] > arr[mini]:\n            maxi = arr[i] - 1\n            break\n    if maxi < 0:\n        maxi = arr[mini] - 1\n    print(maxi)",
        "correct": false,
        "task_id": 301
    },
    {
        "description": "You have a horizontal strip of n cells. Each cell is either white or black.\n\nYou can choose a continuous segment of cells once and paint them all white.\nAfter this action, all the black cells in this segment will become white, and\nthe white ones will remain white.\n\nWhat is the minimum length of the segment that needs to be painted white in\norder for all n cells to become white?\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases. The descriptions of the test cases follow.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 10 )\n— the length of the strip.\n\nThe second line of each test case contains a string s , consisting of n\ncharacters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white\ncell, and 'B' — a black one. It is guaranteed that at least one cell of the\ngiven strip is black.\n\nOutput\n\nFor each test case, output a single number — the minimum length of a\ncontinuous segment of cells that needs to be painted white in order for the\nentire strip to become white.\n\nExample\n\nInput\n\n    8\n    \n    6\n    \n    WBBWBW\n    \n    1\n    \n    B\n    \n    2\n    \n    WB\n    \n    3\n    \n    BBW\n    \n    4\n    \n    BWWB\n    \n    6\n    \n    BWBWWB\n    \n    6\n    \n    WWBBWB\n    \n    9\n    \n    WBWBWWWBW\n\nOutput\n\n    4\n    1\n    1\n    2\n    4\n    6\n    4\n    7\n    \nNote\n\nIn the first test case of the example for the strip \"WBBWBW\", the minimum\nlength of the segment to be repainted white is 4 . It is necessary to repaint\nto white the segment from the 2 -nd to the 5 -th cell (the cells are numbered\nfrom 1 from left to right).",
        "task_name": "1927-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def min_segment_length(n, s):\n    first_black = -1\n    last_black = -1\n    for i in range(n):\n        if s[i] == 'B':\n            if first_black == -1:\n                first_black = i\n            last_black = i\n    return last_black - first_black + 1\n \ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        results.append(min_segment_length(n, s))\n    for result in results:\n        print(result)\n \nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": 117
    },
    {
        "description": "Today, Cat and Fox found an array a consisting of n non-negative integers.\n\nDefine the loneliness of a as the smallest positive integer k (1 \\le k \\le n )\nsuch that for any two positive integers i and j (1 \\leq i, j \\leq n - k +1 ),\nthe following holds:\n\nwhere x | y denotes the [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR) of x and y . In other words, for every k consecutive elements, their bitwise OR should be the same. Note that the loneliness of a is well-defined, because for k = n the condition is satisfied.\n\nCat and Fox want to know how lonely the array a is. Help them calculate the\nloneliness of the found array.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains one integer n (1 \\leq n \\leq 10^5 )\n— the length of the array a .\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (0\n\\leq a_i < 2^{20} ) — the elements of the array.\n\nIt is guaranteed that the sum of n over all test cases doesn't exceed 10^5 .\n\nOutput\n\nFor each test case, print one integer — the loneliness of the given array.\n\nExample\n\nInput\n\n    7\n    \n    1\n    \n    0\n    \n    3\n    \n    2 2 2\n    \n    3\n    \n    1 0 2\n    \n    5\n    \n    3 0 1 4 2\n    \n    5\n    \n    2 0 4 0 2\n    \n    7\n    \n    0 0 0 0 1 2 4\n    \n    8\n    \n    0 1 3 2 2 1 0 3\n\nOutput\n\n    1\n    1\n    3\n    4\n    4\n    7\n    3\n    \nNote\n\nIn the first example, the loneliness of an array with a single element is\nalways 1 , so the answer is 1 .\n\nIn the second example, the OR of each subarray of length k = 1 is 2 , so the\nloneliness of the whole array is 1 .\n\nIn the seventh example, it's true that (0 | 1 | 3) = (1 | 3 | 2) = (3 | 2 | 2) = (2 | 2 | 1) = (2 | 1 | 0) = (1 | 0 | 3) = 3 , so the condition is satisfied for k = 3 . We can verify that the condition is not true for any smaller k , so the answer is indeed 3 .",
        "task_name": "1973-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    k = 1\n    for i in range(20):\n        prev = -1\n        for j, x in enumerate(a):\n            if x>>i&1 == 1:\n                k = max(k, j - prev)\n                prev = j\n        if prev != -1:\n            k = max(k, n - prev)\n    print(k)",
        "correct": true,
        "task_id": 61
    }
]