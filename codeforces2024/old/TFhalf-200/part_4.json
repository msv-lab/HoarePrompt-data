[
    {
        "description": "Little Rosie has a phone with a desktop (or launcher, as it is also called).\nThe desktop can consist of several screens. Each screen is represented as a\ngrid of size 5 \\times 3 , i.e., five rows and three columns.\n\nThere are x applications with an icon size of 1 \\times 1 cells; such an icon\noccupies only one cell of the screen. There are also y applications with an\nicon size of 2 \\times 2 cells; such an icon occupies a square of 4 cells on\nthe screen. Each cell of each screen can be occupied by no more than one icon.\n\nRosie wants to place the application icons on the minimum number of screens.\nHelp her find the minimum number of screens needed.\n\nInput\n\nThe first line of the input contains t (1 \\leq t \\leq 10^4 ) — the number of\ntest cases.\n\nThe first and only line of each test case contains two integers x and y (0\n\\leq x, y \\leq 99 ) — the number of applications with a 1 \\times 1 icon and\nthe number of applications with a 2 \\times 2 icon, respectively.\n\nOutput\n\nFor each test case, output the minimal number of required screens on a\nseparate line.\n\nExample\n\nInput\n\n    11\n    \n    1 1\n    \n    7 2\n    \n    12 4\n    \n    0 3\n    \n    1 0\n    \n    8 1\n    \n    0 0\n    \n    2 0\n    \n    15 0\n    \n    8 2\n    \n    0 9\n\nOutput\n\n    1\n    1\n    2\n    2\n    1\n    1\n    0\n    1\n    1\n    2\n    5\n    \nNote\n\nThe solution for the first test case can look as follows:\n\n![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)\nBlue squares represent empty spaces for icons, green squares represent 1\n\\times 1 icons, red squares represent 2 \\times 2 icons\n\nThe solution for the third test case can look as follows:\n\n![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)",
        "task_name": "1974-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "n=int(input())\nd=15\nf=14\nfor i in range(n):\n      a,b=map(int,input().split())\n      while a==0 and b==0:\n            d=d-5\n            a=a-1\n            b=b-1\n            f=f+1\n            print(f)",
        "correct": false,
        "task_id": 72
    },
    {
        "description": "Rudolf has a string s of length n . Rudolf considers the string s to be ugly\nif it contains the substring^\\dagger \"pie\" or the substring \"map\", otherwise\nthe string s will be considered beautiful.\n\nFor example, \"ppiee\", \"mmap\", \"dfpiefghmap\" are ugly strings, while \"mathp\",\n\"ppiiee\" are beautiful strings.\n\nRudolf wants to shorten the string s by removing some characters to make it\nbeautiful.\n\nThe main character doesn't like to strain, so he asks you to make the string\nbeautiful by removing the minimum number of characters. He can remove\ncharacters from any positions in the string (not just from the beginning or\nend of the string).\n\n^\\dagger String a is a substring of b if there exists a consecutive segment of\ncharacters in string b equal to a .\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntest cases. The descriptions of the test cases follow.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 10^6\n) — the length of the string s .\n\nThe next line of each test case contains the string s of length n . The string\ns consists of lowercase Latin letters.\n\nThe sum of n over all test cases does not exceed 10^6 .\n\nOutput\n\nFor each test case, output a single integer — the minimum number of characters\nthat need to be deleted to make the string s beautiful. If the string is\ninitially beautiful, then output 0 .\n\nExample\n\nInput\n\n    6\n    \n    9\n    \n    mmapnapie\n    \n    9\n    \n    azabazapi\n    \n    8\n    \n    mappppie\n    \n    18\n    \n    mapmapmapmapmapmap\n    \n    1\n    \n    p\n    \n    11\n    \n    pppiepieeee\n\nOutput\n\n    2\n    0\n    2\n    6\n    0\n    2\n    \nNote\n\nIn the first test case, for example, you can delete the 4 th and 9 th\ncharacters to make the string beautiful.\n\nIn the second test case, the string is already beautiful.",
        "task_name": "1941-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "tt=int(input())\nfor k1 in range(tt):\n    n=input()\n    s=input()\n    cnt=0\n\n    for i in range(len(s)):\n        # print(s[i])\n        if s[i]==\"p\":\n            f1=0\n            f2=0\n            if i-2>=0:\n                # print(s[i-2]+s[i-1]+s[i])\n                if s[i-2]==\"m\" and s[i-1]==\"a\":\n\n                    f1=1\n            if i+2<=len(s)-1:\n                if(s[i+1]==\"i\" and s[i+2]==\"e\"):\n                    f2=1\n            if(f1==1 and f2==1):\n                    cnt+=1\n            if f1==1 or f2==1:\n                    cnt+=1\n            # prin(f1)\n    print(cnt)",
        "correct": false,
        "task_id": 306
    },
    {
        "description": "In TreeWorld, there is a popular two-player game played on a tree with n\nvertices labelled from 1 to n . In this game, the tournament leaders first\nchoose a vertex to be the root of the tree and choose another vertex (possibly\nthe same vertex as the root) to place a coin on. Then, each player will take\nturns moving the coin to any child^\\dagger of the vertex that the coin is\ncurrently on. The first player who is unable to make a move loses.\n\nAlice wants to be a tree LGM, so she spends a lot of time studying the game.\nShe wrote down an n by n matrix s , where s_{i,j} = \\mathtt{1} if the first\nplayer can win with the root of the tree chosen to be vertex i , and the coin\nwas initially placed on vertex j . Otherwise, s_{i, j} = \\mathtt{0} . Alice is\na perfectionist, so she assumes that both players play perfectly in the game.\n\nHowever, she accidentally knocked her head on the way to the tournament and\nforgot what the tree looked like. Determine whether there exists a tree that\nsatisfies the winning and losing states represented by matrix s , and if it\nexists, construct a valid tree.\n\n^\\dagger A vertex c is a child of vertex u if there is an edge between c and u\n, and c does not lie on the unique simple path from the root to vertex u .\n\nInput\n\nThe first line contains a single integer n (1 \\le n \\le 5000 ) — the number of\nvertices in the tree.\n\nEach of the next n lines contains a string with n characters, the j -th\ncharacter of the i -th line representing s_{i, j} (s_{i, j} \\in \\\\{\\mathtt{0},\n\\mathtt{1}\\\\} ) — the winning and losing states of the tree.\n\nOutput\n\nIf there is no tree satisfying the winning and losing states represented by\nmatrix s , print a single line containing \"NO\".\n\nOtherwise, if there exists a tree satisfying matrix s , print \"YES\" on the\nfirst line, followed by n - 1 lines each containing two integers u and v (1\n\\le u, v \\le n ) representing that the tree has an edge between vertices u and\nv .\n\nYou can output the answer in any case (upper or lower). For example, the\nstrings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive\nresponses.\n\nIf there are multiple trees satisfying the winning and losing states\nrepresented by matrix s , print any of them.\n\nExamples\n\nInput\n\n    4\n    \n    1100\n    \n    0101\n    \n    0011\n    \n    0101\n\nOutput\n\n    YES\n    4 1\n    3 2\n    2 4\n    \nInput\n\n    3\n    \n    001\n    \n    010\n    \n    100\n\nOutput\n\n    NO\n    \nNote\n\nIn the first test case, the line graph 1\\\\!-\\\\!4\\\\!-\\\\!2\\\\!-\\\\!3 satisfies the\nwinning and losing states represented by matrix s . For example, s_{3,3} = 1\nas the first player can move the coin from 3\\rightarrow 2 , then the second\nplayer moves the coin from 2\\rightarrow 4 , and finally, the first player\nmoves the coin from 4\\rightarrow 1 . At this point, 1 has no children, so the\nsecond player is unable to make a move and loses. On the other hand, s_{1,3} =\n0 as if 1 is the root, then 3 has no children so the first player is unable to\nmake the first move and loses.\n\nIn the second test case, it is possible to prove that no tree satisfies the\nwinning and losing states represented by matrix s .",
        "task_name": "1919-G",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1:n+1]\n    \n    # Check if the matrix is consistent with a tree structure\n    # We will use a simple line tree structure to check the consistency\n    # and construct the tree if possible.\n    \n    # Check if the matrix is symmetric\n    for i in range(n):\n        for j in range(n):\n            if s[i][j] != s[j][i]:\n                print(\"NO\")\n                return\n    \n    # Check if the diagonal is all zeros\n    for i in range(n):\n        if s[i][i] != '0':\n            print(\"NO\")\n            return\n    \n    # Construct a simple line tree\n    edges = []\n    for i in range(1, n):\n        edges.append((i, i + 1))\n    \n    # Output the result\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)",
        "correct": false,
        "task_id": 33
    },
    {
        "description": "Oleg received a permutation a of length n as a birthday present.\n\nOleg's friend Nechipor asks Oleg q questions, each question is characterized\nby two numbers l and r , in response to the question Oleg must say the number\nof sets of indices (t_1, t_2, \\ldots, t_k) of any length k \\ge 1 such that:\n\n  * l \\le t_i \\le r for each i from 1 to k . \n  * t_i < t_{i+1} for each i from 1 to k-1 . \n  * a_{t_{i+1}} is divisible by a_{t_i} for each i from 1 to k-1 . \n\nHelp Oleg and answer all of Nechipor's questions.\n\nInput\n\nEach test consists of several sets of input data. The first line contains a\nsingle integer t (1 \\le t \\le 10^4 ) — the number of sets of input data. The\ndescription of the sets of input data follows.\n\nThe first line of each set of input data contains two integers n and q (1 \\le\nn, q \\le 10^6 ) — the length of the permutation and the number of Nechipor's\nquestions.\n\nThe second line of each set of input data contains n integers a_1, a_2,\n\\ldots, a_n (1 \\le a_i \\le n ) — the permutation a itself.\n\nIn each of the next q lines of each set of input data, there are two integers\nl and r (1 \\le l \\le r \\le n ) — the next question of Nechipor.\n\nIt is guaranteed that the sum of the values of n and the sum of the values of\nq over all test cases does not exceed 10^6 .\n\nOutput\n\nFor each set of input data, output the answers to all of Nechipor's questions.\n\nExample\n\nInput\n\n    4\n    \n    8 8\n    \n    2 1 6 3 5 4 8 7\n    \n    1 8\n    \n    2 8\n    \n    1 7\n    \n    1 6\n    \n    1 3\n    \n    5 8\n    \n    4 4\n    \n    2 3\n    \n    1 1\n    \n    1\n    \n    1 1\n    \n    3 3\n    \n    3 2 1\n    \n    1 2\n    \n    1 3\n    \n    2 3\n    \n    8 1\n    \n    1 2 3 4 5 6 7 8\n    \n    1 8\n\nOutput\n\n    20 15 18 12 5 5 1 3\n    1\n    2 3 2\n    27\n    \nNote\n\nAll suitable arrays in the first set of input data: (1 ), (2 ), (3 ), (4 ), (5\n), (6 ), (7 ), (8 ), (1, 3 ), (1, 6 ), (1, 7 ), (1, 6, 7 ), (2, 3 ), (2, 4 ),\n(2, 5 ), (2, 6 ), (2, 7 ), (2, 8 ), (2, 6, 7 ), (6, 7 ).\n\nAll suitable arrays in the fourth set of input data: (1 ), (2 ), (3 ), (4 ),\n(5 ), (6 ), (7 ), (8 ), (1, 2 ), (1, 3 ), (1, 4 ), (1, 5 ), (1, 6 ), (1, 7 ),\n(1, 8 ), (1, 2, 4 ), (1, 2, 6 ), (1, 2, 8 ), (1, 2, 4, 8 ), (1, 3, 6 ), (1, 4,\n8 ), (2, 4 ), (2, 6 ), (2, 8 ), (2, 4, 8 ), (3, 6 ), (4, 8 ).",
        "task_name": "1946-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    MOD = 10**9 + 7\n    idx = 0\n    T = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(T):\n        n, k = int(data[idx]), int(data[idx+1])\n        idx += 2\n        a = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        # Calculate the initial sum of the array\n        total_sum = sum(a) % MOD\n        \n        # Function to find the maximum subarray sum using Kadane's algorithm\n        def kadane(arr):\n            max_ending_here = max_so_far = arr[0]\n            for x in arr[1:]:\n                max_ending_here = max(x, max_ending_here + x)\n                max_so_far = max(max_so_far, max_ending_here)\n            return max_so_far\n        \n        # Find the maximum subarray sum\n        max_subarray_sum = kadane(a)\n        \n        # If the maximum subarray sum is positive, we can use it k times\n        if max_subarray_sum > 0:\n            max_increase = (max_subarray_sum * k) % MOD\n            result = (total_sum + max_increase) % MOD\n        else:\n            # If no positive gain, the best sum is the initial sum\n            result = total_sum\n        \n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 292
    },
    {
        "description": "Given an array a_1, a_2, \\ldots, a_n , determine whether it is possible to\nrearrange its elements into b_1, b_2, \\ldots, b_n , such that b_1 \\bmod b_2\n\\bmod \\ldots \\bmod b_n \\neq 0 .\n\nHere x \\bmod y denotes the remainder from dividing x by y . Also, the modulo\noperations are calculated from left to right. That is, x \\bmod y \\bmod z = (x\n\\bmod y) \\bmod z . For example, 2024 \\bmod 1000 \\bmod 8 = (2024 \\bmod 1000)\n\\bmod 8 = 24 \\bmod 8 = 0 .\n\nInput\n\nThe first line of the input contains a single integer t (1 \\le t \\le 10^4 ) —\nthe number of test cases.\n\nThe first line of each test case contains a single integer n (2 \\le n \\le 10^5\n).\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^9 ).\n\nThe sum of n over all test cases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output \"YES\" if it is possible, \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the\nstrings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive\nresponses.\n\nExample\n\nInput\n\n    8\n    \n    6\n    \n    1 2 3 4 5 6\n    \n    5\n    \n    3 3 3 3 3\n    \n    3\n    \n    2 2 3\n    \n    5\n    \n    1 1 2 3 7\n    \n    3\n    \n    1 2 2\n    \n    3\n    \n    1 1 2\n    \n    6\n    \n    5 2 10 10 10 2\n    \n    4\n    \n    3 6 9 3\n\nOutput\n\n    YES\n    NO\n    YES\n    NO\n    YES\n    NO\n    YES\n    NO\n    \nNote\n\nIn the first test case, rearranging the array into b = [1, 2, 3, 4, 5, 6]\n(doing nothing) would result in 1 \\bmod 2 \\bmod 3 \\bmod 4 \\bmod 5 \\bmod 6 = 1\n. Hence it is possible to achieve the goal.\n\nIn the second test case, the array b must be equal to [3, 3, 3, 3, 3] , which\nwould result in 3 \\bmod 3 \\bmod 3 \\bmod 3 \\bmod 3 = 0 . Hence it is impossible\nto achieve the goal.\n\nIn the third test case, rearranging the array into b = [3, 2, 2] would result\nin 3 \\bmod 2 \\bmod 2 = 1 . Hence it is possible to achieve the goal.",
        "task_name": "1933-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    a = int(input())\n    b = list(map(int, input().split()))\n    b.sort()\n    if b[1] == 1:\n        print(\"NO\")\n    elif b[0] == 1:\n        print(\"YES\")\n    else:\n        for i in range(0, a):\n            if b[i] % b[0] != 0:\n                print(\"YES\")\n                break\n        else:\n            if b.count(b[0]) != a and a == 2:\n                print(\"YES\")\n            else:\n                print(\"NO\")",
        "correct": false,
        "task_id": 129
    },
    {
        "description": "Let's call a number a binary decimal if it is a positive integer and all\ndigits in its decimal notation are either 0 or 1 . For example, 1\\,010\\,111 is\na binary decimal, while 10\\,201 and 787\\,788 are not.\n\nGiven a number n , you are asked whether or not it is possible to represent n\nas a product of some (not necessarily distinct) binary decimals.\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 5 \\cdot 10^4 ) — the\nnumber of test cases.\n\nThe only line of each test case contains a single integer n (1 \\leq n \\leq\n10^5 ).\n\nOutput\n\nFor each test case, output \"YES\" (without quotes) if n can be represented as a\nproduct of binary decimals, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\",\nand \"Yes\" will be recognized as a positive response).\n\nExample\n\nInput\n\n    11\n    \n    121\n    \n    1\n    \n    14641\n    \n    12221\n    \n    10110\n    \n    100000\n    \n    99\n    \n    112\n    \n    2024\n    \n    12421\n    \n    1001\n\nOutput\n\n    YES\n    YES\n    YES\n    YES\n    YES\n    YES\n    NO\n    NO\n    NO\n    NO\n    YES\n    \nNote\n\nThe first five test cases can be represented as a product of binary decimals\nas follows:\n\n  * 121 = 11 \\times 11 . \n  * 1 = 1 is already a binary decimal. \n  * 14\\,641 = 11 \\times 11 \\times 11 \\times 11 . \n  * 12\\,221 = 11 \\times 11 \\times 101 . \n  * 10\\,110 = 10\\,110 is already a binary decimal.",
        "task_name": "1950-D",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import bisect\n\n\n\narr=[0, 1, 11010, 11011, 10, 11, 10000, 10001, 13310, 10010, 10011, 100000, 12321, 14641, 12210, 1331, 1210, 12221, 12100, 1221, 11211, 1100, 1101, 12111, 1110, 1111, 10201, 11100, 11101, 121, 100, 101, 11110, 11111, 1000, 1001, 110, 111, 11121, 1010, 1011, 10100, 10101, 13431, 11000, 11001, 10110, 10111]\narr.sort()\nfor _ in range(int(input())):\n    aa=int(input())\n\n    if bisect.bisect_right(arr,aa)==bisect.bisect_left(arr,aa):\n        print('NO')\n    else:\n        print('YES')",
        "correct": true,
        "task_id": 179
    },
    {
        "description": "You are given n positive integers x_1, x_2, \\ldots, x_n and three positive\nintegers n_a, n_b, n_c satisfying n_a+n_b+n_c = n .\n\nYou want to split the n positive integers into three groups, so that:\n\n  * The first group contains n_a numbers, the second group contains n_b numbers, the third group contains n_c numbers.\n  * Let s_a be the sum of the numbers in the first group, s_b be the sum in the second group, and s_c be the sum in the third group. Then s_a, s_b, s_c are the sides of a triangle with positive area.\n\nDetermine if this is possible. If this is possible, find one way to do so.\n\nInput\n\nEach test contains multiple test cases. The first line contains an integer t\n(1\\le t\\le 100\\,000 ) — the number of test cases. The descriptions of the t\ntest cases follow.\n\nThe first line of each test case contains the integers n, n_a, n_b, n_c (3\n\\leq n \\leq 200\\,000, 1\\leq n_a,n_b,n_c \\leq n-2, n_a+n_b+n_c = n ) — the\nnumber of integers to split into three groups, and the desired sizes of the\nthree groups.\n\nThe second line of each test case contains n integers x_1, x_2, \\ldots, x_n (1\n\\leq x_i \\leq 10^{9} ).\n\nIt is guaranteed that the sum of n over all test cases does not exceed\n200\\,000 .\n\nOutput\n\nFor each test case, print \\texttt{YES} if it is possible to split the numbers\ninto three groups satisfying all the conditions. Otherwise, print \\texttt{NO}\n.\n\nIf such a split exists, then describe the three groups as follows.\n\nOn the next line, print n_a integers a_1, a_2, \\ldots, a_{n_a} — the numbers\nin the first group.\n\nOn the next line, print n_b integers b_1, b_2, \\ldots, b_{n_b} — the numbers\nin the second group.\n\nOn the next line, print n_c integers c_1, c_2, \\ldots, c_{n_c} — the numbers\nin the third group.\n\nThese n_a+n_b+n_c=n integers should be a permutation of x_1, x_2, \\ldots, x_n\n, and they should satisfy the conditions from the statement.\n\nIf there are multiple solutions, print any of them.\n\nExample\n\nInput\n\n    4\n    \n    6 2 2 2\n    \n    1 1 1 1 1 1\n    \n    5 3 1 1\n    \n    1 1 1 1 1\n    \n    6 2 2 2\n    \n    1 1 1 1 1 3\n    \n    8 1 2 5\n    \n    16 1 1 1 1 1 1 12\n\nOutput\n\n    YES\n    1 1 \n    1 1 \n    1 1 \n    NO\n    NO\n    YES\n    16 \n    12 1 \n    1 1 1 1 1 \n    \nNote\n\nIn the first test case, we can put two 1 s into each group: the sum in each\ngroup would be 2 , and there exists a triangle with positive area and sides 2\n, 2 , 2 .\n\nIn the second and third test cases, it can be shown that there is no such way\nto split numbers into groups.\n\nIn the fourth test case, we can put number 16 into the first group, with sum\n16 , numbers 12 and 1 into the second group, with sum 13 , and the remaining\nfive 1 s into the third group, with sum 5 , as there exists a triangle with\npositive area and sides 16, 13, 5 .",
        "task_name": "1949-K",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve(T, test_cases):\n    for _ in range(T):\n        n, a = test_cases[_][0], test_cases[_][1]\n        f = sorted(test_cases[_][2])  # Sort numbers in ascending order\n        s = [0] * (n + 1)  # Prefix sums, with s[0] = 0 for convenience\n\n        # Calculate prefix sums\n        for i in range(1, n + 1):\n            s[i] = s[i - 1] + f[i - 1]  # Adjust index for 0-based in Python\n        \n        m = (s[n] - 1) // 2  # Maximum sum for any group to satisfy triangle inequality\n        t = [0] * 3  # Sum of elements in each group\n        v = [[] for _ in range(3)]  # Elements in each group\n\n        y = True  # Flag to check if a valid grouping is possible\n        for i in range(n - 1, -1, -1):  # Reverse iterate through numbers\n            x = True  # Flag to check if current number can be placed\n            for j in range(3):  # Check each group\n                if a[j] and t[j] + f[i] + s[a[j] - 1] <= m:\n                    v[j].append(f[i])  # Add number to group j\n                    a[j] -= 1  # Decrease the count for group j\n                    t[j] += f[i]  # Update the sum for group j\n                    x = False  # Number placed successfully\n                    break\n            if x:  # If not able to place current number in any group\n                print(\"NO\")\n                y = False\n                break\n        \n        if y:  # If successfully placed all numbers\n            print(\"YES\")\n            for group in v:\n                print(\" \".join(map(str, group)))\n\n# Example usage\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n, *a = map(int, input().split())\n    f = list(map(int, input().split()))\n    test_cases.append((n, a, f))\n\nsolve(T, test_cases)",
        "correct": true,
        "task_id": 242
    },
    {
        "description": "You are given an integer n .\n\nYour task is to build a string of uppercase Latin letters. There must be\nexactly n special characters in this string. Let's call a character special if\nit is equal to exactly one of its neighbors.\n\nFor example, there are 6 special characters in the AAABAACC string (at\npositions: 1 , 3 , 5 , 6 , 7 and 8 ).\n\nPrint any suitable string or report that there is no such string.\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 50 ) — the number of\ntest cases.\n\nThe only line of each test case contains a single integer n (1 \\le n \\le 50 ).\n\nOutput\n\nFor each test case, print the answer as follows:\n\n  * if there is no suitable string, print one line containing the string NO; \n  * otherwise, print two lines. The first line should contain the string YES; on the second line print a string of length at most 200  — the answer itself (it can be shown that if some answers exist, then there is an answer of length at most 200 ). If there are several solutions, print any of them. \n\nExample\n\nInput\n\n    3\n    \n    6\n    \n    1\n    \n    2\n\nOutput\n\n    YES\n    AAABAACC\n    NO\n    YES\n    MM",
        "task_name": "1948-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    n = int(input())\n    if n == 1 or n%2!= 0:\n        print('No')\n    else:\n         stri = 'AAB'*(n//2)\n         print('Yes')\n         print(stri)",
        "correct": true,
        "task_id": 268
    },
    {
        "description": "Let \\operatorname{lowbit}(x) denote the value of the lowest binary bit of x ,\ne.g. \\operatorname{lowbit}(12)=4 , \\operatorname{lowbit}(8)=8 .\n\nFor an array a of length n , if an array s of length n satisfies\ns_k=\\left(\\sum\\limits_{i=k-\\operatorname{lowbit}(k)+1}^{k}a_i\\right)\\bmod\n998\\,244\\,353 for all k , then s is called the Fenwick Tree of a . Let's\ndenote it as s=f(a) .\n\nFor a positive integer k and an array a , f^k(a) is defined as follows:\n\nYou are given an array b of length n and a positive integer k . Find an array\na that satisfies 0\\le a_i < 998\\,244\\,353 and f^k(a)=b . It can be proved that\nan answer always exists. If there are multiple possible answers, you may print\nany of them.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\le t\\le 10^4 ). The description of the test cases follows.\n\nThe first line of each test case contains two positive integers n (1 \\leq n\n\\leq 2\\cdot 10^5 ) and k (1\\le k\\le 10^9 ), representing the length of the\narray and the number of times the function f is performed.\n\nThe second line of each test case contains an array b_1, b_2, \\ldots, b_n\n(0\\le b_i < 998\\,244\\,353 ).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, print a single line, containing a valid array a of length\nn .\n\nExample\n\nInput\n\n    2\n    \n    8 1\n    \n    1 2 1 4 1 2 1 8\n    \n    6 2\n    \n    1 4 3 17 5 16\n\nOutput\n\n    1 1 1 1 1 1 1 1\n    1 2 3 4 5 6\n    \nNote\n\nIn the first test case, it can be seen that\nf^1([1,1,1,1,1,1,1,1])=[1,2,1,4,1,2,1,8] .\n\nIn the second test case, it can be seen that\nf^2([1,2,3,4,5,6])=f^1([1,3,3,10,5,11])=[1,4,3,17,5,16] .",
        "task_name": "1972-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "MOD = 998244353\na = [0] * 200010\nb = [0] * 200010\np = [0] * 41\nrevp = [0] * 41\n\n\ndef lowbit(x):\n    return x & -x\n\n\ndef ksm(x, y):\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = (res * x) % MOD\n        x = (x * x) % MOD\n        y >>= 1\n    return res\n\n\ndef C(x, y):\n    ans = 1\n    for i in range(x, x - y, -1):\n        ans = (ans * i) % MOD\n    return (ans * revp[y]) % MOD\n\n\ndef solve():\n    n, k = map(int, input().split())\n    s = list(map(int, input().strip().split()))\n    for i in range(1, n + 1):\n        b[i] = s[i - 1]\n\n    for i in range(1, n + 1):\n        a[i] = b[i]\n        c = 1\n        j = i + lowbit(i)\n        while j <= n:\n            b[j] = (b[j] + MOD - (C(c + k - 1, c) * a[i]) % MOD) % MOD\n            c = c + 1\n            j = j + lowbit(j)\n\n    for i in range(1, n + 1):\n        print(a[i], end=\" \")\n    print()\n\n\np[0] = 1\nrevp[0] = 1\nfor i in range(1, 41):\n    p[i] = (p[i - 1] * i) % MOD\n\nrevp[40] = ksm(p[40], MOD - 2)\nfor i in range(39, 0, -1):\n    revp[i] = (revp[i + 1] * (i + 1)) % MOD\n\nT = int(input().strip())\nfor _ in range(T):\n    solve()",
        "correct": true,
        "task_id": 31
    },
    {
        "description": "This is an interactive problem.\n\nYou are given an integer n .\n\nThe jury has hidden from you a directed graph with n vertices (numbered from 1\nto n ) and some number of edges. You additionally know that:\n\n  * The graph only contains edges of the form i \\leftarrow j , where 1 \\le i < j \\le n . \n  * For any three vertices 1 \\le i < j < k \\le n , at least one of the following holds^\\dagger : \n    * Vertex i is reachable from vertex j , or \n    * Vertex i is reachable from vertex k , or \n    * Vertex j is reachable from vertex k . \n\nYou want to color each vertex in either black or white such that for any two\nvertices i and j (1 \\le i < j \\le n ) of the same color, vertex i is reachable\nfrom vertex j .\n\nTo do that, you can ask queries of the following type:\n\n  * ? i j — is vertex i reachable from vertex j (1 \\le i < j \\le n )? \n\nFind any valid vertex coloring of the hidden graph in at most 2 \\cdot n\nqueries. It can be proven that such a coloring always exists.\n\nNote that the grader is not adaptive: the graph is fixed before any queries\nare made.\n\n^\\dagger Vertex a is reachable from vertex b if there exists a\n[path](https://en.wikipedia.org/wiki/Path_\\(graph_theory\\)) from vertex b to\nvertex a in the graph.\n\nInput\n\nEach test contains multiple test cases. The first line of input contains a\nsingle integer t (1 \\le t \\le 1000 ) — the number of test cases. The\ndescription of the test cases follows.\n\nThe only line of each test case contains a single integer n (3 \\le n \\le 100 )\n— the number of vertices in the hidden graph.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 1000 .\n\nInteraction\n\nThe interaction for each test case begins by reading the integer n .\n\nTo make a query, output \"? i j\" without quotes (1 \\le i < j \\le n ). If vertex\ni is reachable from vertex j , you will get YES as an answer. Otherwise, you\nwill get NO as an answer.\n\nIf you receive the integer -1 instead of an answer or a valid value of n , it\nmeans your program has made an invalid query, has exceeded the limit of\nqueries, or has given an incorrect answer on the previous test case. Your\nprogram must terminate immediately to receive a Wrong Answer verdict.\nOtherwise, you can get an arbitrary verdict because your solution will\ncontinue to read from a closed stream.\n\nWhen you are ready to give the final answer, output \"! c_1 \\ c_2 \\ \\ldots \\\nc_n \" without quotes — the colors of the vertices, where c_i = 0 if the vertex\nis black, and c_i = 1 if the vertex is white. After solving all test cases,\nyour program should be terminated immediately.\n\nAfter printing a query, do not forget to output an end of line and flush the\noutput. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n  * fflush(stdout) or cout.flush() in C++; \n  * System.out.flush() in Java; \n  * flush(output) in Pascal; \n  * stdout.flush() in Python; \n  * see documentation for other languages. \n\nHacks\n\nTo hack, use the following format:\n\nThe first line contains an integer t (1 \\le t \\le 1000 ) — the number of test\ncases.\n\nThe first line of each test case contains two integers n and m (3 \\le n \\le\n100 , 0 \\le m \\le \\frac{n\\cdot(n - 1)}{2} ) — the number of vertices and edges\nin the graph.\n\nEach of the following m lines should contain two integers a and b (1 \\le b < a\n\\le n ), indicating that there is the edge a \\rightarrow b in the graph. The\ngraph should satisfy the conditions above.\n\nThe sum of n over all test cases should not exceed 1000 .\n\nExample\n\nInput\n\n    2\n    4\n    \n    YES\n    \n    YES\n    \n    YES\n    \n    NO\n    \n    NO\n    \n    NO\n    \n    5\n    \nOutput\n\n    ? 1 2\n    \n    ? 2 3\n    \n    ? 1 3\n    \n    ? 1 4\n    \n    ? 2 4\n    \n    ? 3 4\n    \n    ! 0 0 0 1\n    \n    ! 1 1 0 1 0\n    \nNote\n\nThe hidden graph in the first test case:\n\n![](https://espresso.codeforces.com/235e3d067fc8370ed3b4b18dd5f9b9d92a239ec9.png)\n\nThe hidden graph in the second test case:\n\n![](https://espresso.codeforces.com/8f92332d3d9efe005101ba89ebe2733d281bf111.png)\n\nThe interaction happens as follows:\n\nSolution| Jury| Explanation  \n---|---|---  \n| 2| There are 2 test cases.  \n| 4| In the first test case, the graph has 4 vertices.  \n? 1 2 | YES| The solution asks if vertex 1 is reachable from vertex 2 , and the jury answers YES.  \n? 2 3 | YES| The solution asks if vertex 2 is reachable from vertex 3 , and the jury answers YES.  \n? 1 3 | YES| The solution asks if vertex 1 is reachable from vertex 3 , and the jury answers YES.  \n? 1 4 | NO| The solution asks if vertex 1 is reachable from vertex 4 , and the jury answers NO.  \n? 2 4 | NO| The solution asks if vertex 2 is reachable from vertex 4 , and the jury answers NO.  \n? 3 4 | NO| The solution asks if vertex 3 is reachable from vertex 4 , and the jury answers NO.  \n! 0 0 0 1| | The solution has somehow determined a valid coloring and outputs it. Since the output is correct, the jury continues to the next test case.  \n| 5| In the second test case, the graph has 5 vertices.  \n! 1 1 0 1 0| | The solution has somehow determined a valid coloring, and outputs it. Since the output is correct and there are no more test cases, the jury and the solution exit.  \n  \nNote that the line breaks in the example input and output are for the sake of\nclarity, and do not occur in the real interaction.",
        "task_name": "1977-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\n \ninput = stdin.readline\ndef print(s):\n    stdout.write(s+'\\n')\n    stdout.flush()\n \ndef q(type, out):\n    if type:\n        print(\"! \" + ' '.join(map(str, out)))\n    else:\n        print(\"? \" + ' '.join(map(str, out)))\n        res = input().rstrip()\n        if res == '-1':\n            exit()\n        return int(res == \"YES\")\n \nfor _ in range(int(input())):\n    n = int(input())\n \n    if n == -1:\n        exit()\n \n    l = [[n], [], []]\n \n    for i in range(n-1, 0, -1):\n        if len(l[2]):\n            if q(0, (i, l[2][-1])):\n                l[2].append(i)\n            elif q(0, (i, l[0][-1])):\n                l[0].append(i)\n                l[1] += l[2]\n                l[2] = []\n            else:\n                l[1].append(i)\n                l[0] += l[2]\n                l[2] = []\n        else:\n            if len(l[1]):\n                l[q(0, (i, l[0][-1])) + 2*q(0, (i, l[1][-1])) - 1].append(i)\n            else:\n                l[1 - q(0, (i, l[0][-1]))].append(i)\n \n    ans = [0]*n\n    for val in l[0]:\n        ans[val-1] = 1\n \n    q(1, ans)",
        "correct": true,
        "task_id": 262
    }
]