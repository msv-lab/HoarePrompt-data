[
    {
        "description": "You have been offered to play a game. In this game, there are n possible\noutcomes, and for each of them, you must bet a certain integer amount of\ncoins. In the event that the i -th outcome turns out to be winning, you will\nreceive back the amount of coins equal to your bet on that outcome, multiplied\nby k_i . Note that exactly one of the n outcomes will be winning.\n\nYour task is to determine how to distribute the coins in such a way that you\nwill come out ahead in the event of any winning outcome. More formally, the\ntotal amount of coins you bet on all outcomes must be strictly less than the\nnumber of coins received back for each possible winning outcome.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 10^4 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 50 )\n— the number of outcomes.\n\nThe second line of each test case contains n integers k_1,k_2,\\ldots,k_n (2\n\\le k_i \\le 20 ) — the multiplier for the amount of coins if the i -th outcome\nturns out to be winning.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output -1 if there is no way to distribute the coins as\nrequired. Otherwise, output n integers x_1, x_2,\\ldots, x_n (1 \\le x_i \\le\n10^{9} ) — your bets on the outcomes.\n\nIt can be shown that if a solution exists, there is always a solution that\nsatisfies these constraints.\n\nIf there are multiple suitable solutions, output any of them.\n\nExample\n\nInput\n\n    6\n    \n    3\n    \n    3 2 7\n    \n    2\n    \n    3 3\n    \n    5\n    \n    5 5 5 5 5\n    \n    6\n    \n    7 9 3 17 9 13\n    \n    3\n    \n    6 3 2\n    \n    5\n    \n    9 4 6 8 3\n\nOutput\n\n    27 41 12 \n    1 1 \n    -1\n    1989 1547 4641 819 1547 1071 \n    -1\n    8 18 12 9 24\n    \nNote\n\nIn the first test case, the coins can be distributed as follows: 27 coins on\nthe first outcome, 41 coins on the second outcome, 12 coins on the third\noutcome. Then the total amount of coins bet on all outcomes is 27 + 41 + 12 =\n80 coins. If the first outcome turns out to be winning, you will receive back\n3 \\cdot 27 = 81 coins, if the second outcome turns out to be winning, you will\nreceive back 2 \\cdot 41 = 82 coins, if the third outcome turns out to be\nwinning, you will receive back 7 \\cdot 12 = 84 coins. All these values are\nstrictly greater than 80 .\n\nIn the second test case, one way is to bet one coin on each of the outcomes.",
        "task_name": "1979-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from math import gcd\nt = int(input())\nfor T in range(t):\n\t#x, y, k = map(int, input().split())\n\tdef lcm(l):\n\t    g=1\n\t    for i in range(len(l)):\n\t        g=g*l[i]//gcd(g,l[i])\n\t    return g\n\tbets=int(input())\n\ta = [int(x) for x in input().split()]\n\tprod=lcm(a)\n\t\n\tsumo=0\n\tfor i in range(bets):\n\t    a[i]=(prod//a[i])\n\t    sumo+=int(a[i])\n\t\n\tif sumo>=prod:\n\t    print(-1)\n\telse:\n\t    ans=\"\"\n\t    for i in range(bets):\n\t        ans+=str(a[i])+\" \"\n\t    print(ans)",
        "correct": true,
        "task_id": 299
    },
    {
        "description": "You are given two integers n and k along with a string s .\n\nYour task is to check whether all possible strings of length n that can be\nformed using the first k lowercase English alphabets occur as a subsequence of\ns . If the answer is NO, you also need to print a string of length n that can\nbe formed using the first k lowercase English alphabets which does not occur\nas a subsequence of s .\n\nIf there are multiple answers, you may print any of them.\n\nNote: A string a is called a subsequence of another string b if a can be\nobtained by deleting some (possibly zero) characters from b without changing\nthe order of the remaining characters.\n\nInput\n\nThe first line of input contains a single integer t \\, (1 \\le t \\le 10^5) ,\nthe number of test cases.\n\nThe first line of each test case contains 3 integers n \\, (1 \\le n \\le 26), \\:\nk \\, (1 \\le k \\le 26), \\: m \\, (1 \\le m \\le 1000) , where n and k are the same\nas described in the input and m is the length of the string s .\n\nThe second line of each test case contains a single string s of length m ,\ncomprising only of the first k lowercase English alphabets.\n\nIt is guaranteed that the sum of m and the sum of n over all test cases does\nnot exceed 10^6 .\n\nOutput\n\nFor each test case, print YES if all possible strings of length n that can be\nformed using the first k lowercase English alphabets occur as a subsequence of\ns , else print NO.\n\nIf your answer is NO, print a string of length n that can be formed using the\nfirst k lowercase English alphabets which does not occur as a subsequence of s\nin the next line.\n\nYou may print each letter of YES or NO in any case (for example, YES, yES, YeS\nwill all be recognized as a positive answer).\n\nExample\n\nInput\n\n    3\n    \n    2 2 4\n    \n    abba\n    \n    2 2 3\n    \n    abb\n    \n    3 3 10\n    \n    aabbccabab\n\nOutput\n\n    YES\n    NO\n    aa\n    NO\n    ccc\n    \nNote\n\nFor the first test case, all possible strings (aa, ab, ba, bb) of length 2\nthat can be formed using the first 2 English alphabets occur as a subsequence\nof abba.\n\nFor the second test case, the string aa is not a subsequence of abb.",
        "task_name": "1925-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for ii in range(int(input())):\n  n,k,m = map(int,input().split())\n  s = input()\n  t = 0\n  c = 0\n  f = {}\n  r = \"\"\n  for i in range(m):\n    if s[i] not in f:\n      t+=1\n      f[s[i]] = 1\n    if t==k:\n      r+=s[i]\n      c+=1\n      t = 0\n      f = {}\n    if c==n:\n      print(\"YES\")\n      break\n  if c<n:\n    for i in range(k):\n      if chr(ord(\"a\")+i) not in f:\n        r+=chr(ord(\"a\")+i)\n        break\n    e = n-len(r)\n    for i in range(e):\n      r+=\"a\"\n    print(\"NO\")\n    print(r)",
        "correct": true,
        "task_id": 211
    },
    {
        "description": "Sasha gave Anna a list a of n integers for Valentine's Day. Anna doesn't need\nthis list, so she suggests destroying it by playing a game.\n\nPlayers take turns. Sasha is a gentleman, so he gives Anna the right to make\nthe first move.\n\n  * On her turn, Anna must choose an element a_i from the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of 42 , it would become 24 ; if Anna chose the element with a value of 1580 , it would become 851 . Note that leading zeros are removed. After such a turn, the number of elements in the list does not change.\n  * On his turn, Sasha must extract two elements a_i and a_j (i \\ne j ) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to 2007 and 19 , he would remove these two elements from the list and add the integer 200719 or 192007 . After such a turn, the number of elements in the list decreases by 1 .\n\nPlayers can't skip turns. The game ends when Sasha can't make a move, i.e.\nafter Anna's move there is exactly one number left in the list. If this\ninteger is not less than 10^m (i.e., \\ge 10^m ), Sasha wins. Otherwise, Anna\nwins.\n\nIt can be shown that the game will always end. Determine who will win if both\nplayers play optimally.\n\nInput\n\nThe first line contains an integer t (1 \\le t \\le 10^4 ) — the number of test\ncases.\n\nThen follows the description of the test cases.\n\nThe first line of each test case contains integers n , m (1 \\le n \\le 2 \\cdot\n10^5 , 0 \\le m \\le 2 \\cdot 10^6 ) — the number of integers in the list and the\nparameter determining when Sasha wins.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1\n\\le a_i \\le 10^9 ) — the list that Sasha gave to Anna.\n\nIt is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot\n10^5 .\n\nOutput\n\nFor each test case, output:\n\n  * \"Sasha\", if Sasha wins with optimal play; \n  * \"Anna\", if Anna wins with optimal play. \n\nExample\n\nInput\n\n    9\n    \n    2 2\n    \n    14 2\n    \n    3 5\n    \n    9 56 1\n    \n    4 10\n    \n    1 2007 800 1580\n    \n    4 5\n    \n    5000 123 30 4\n    \n    10 10\n    \n    6 4 6 2 3 1 10 9 10 7\n    \n    1 1\n    \n    6\n    \n    1 1\n    \n    10\n    \n    8 9\n    \n    1 2 9 10 10 2 10 2\n    \n    4 5\n    \n    10 10 10 10\n\nOutput\n\n    Sasha\n    Anna\n    Anna\n    Sasha\n    Sasha\n    Anna\n    Anna\n    Anna\n    Sasha\n    \nNote\n\nConsider the first test case.\n\nAnna can reverse the integer 2 , then Sasha can concatenate the integers 2 and\n14 , obtaining the integer 214 , which is greater than 10^2 = 100 . If Anna\nhad reversed the integer 14 , Sasha would have concatenated the integers 41\nand 2 , obtaining the integer 412 , which is greater than 10^2 = 100 . Anna\nhas no other possible moves, so she loses.",
        "task_name": "1931-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def countZero(number):\n    counter = 0\n    for i in range(len(number)-1, 0, -1):\n        if (number[i] != '0'):\n            break;\n        counter += 1\n    return counter\n\ndef anna(arr):\n    idx = 0\n    found = True if arr[0][-1] == '0' else False\n\n    for i in range(1, len(arr)):\n        if arr[i][-1] == '0':\n            if countZero(arr[i]) > countZero(arr[idx]):\n                found = True\n                idx = i\n\n    if found:\n        arr[idx] = str(int(arr[idx][::-1]))\n\n    return arr          # if no ele with 0 at end is found, then we return same arr\n\ndef sasha(arr):\n    idx1 = 0\n    foundOne = False\n    idx2 = 0\n    for i in range(1, len(arr)):\n        if arr[i][-1] == '0':\n            if countZero(arr[i]) > countZero(arr[idx1]):\n                foundOne = True\n                idx1 = i\n    for i in range(1, len(arr)):\n        if i !=idx1 and arr[i][-1] == '0':\n            if countZero(arr[i]) >= countZero(arr[idx2]):\n                idx2 = i\n\n    if (idx2 != 0):    \n        # print(f\"Two 0s found at {{ {idx1} }} and {{ {idx2} }}.\")\n        if countZero(arr[idx1]) > countZero(arr[idx2]):         # The one with less zeros at end would be after more zeros\n            arr[idx1] = arr[idx1] + arr[idx2]\n        else:\n            arr[idx1] = arr[idx2] + arr[idx1]\n        arr.pop(idx2)\n    \n    elif foundOne and idx2 == 0 :\n        for i in range(1, len(arr)):\n            if len(arr[i]) > len(arr[idx2]):\n                idx2 = i\n        # print(f\"Only one 0 found at {{ {idx1} }} other chosen {{ {idx2} }}\")\n        arr[idx1] = arr[idx1] + arr[idx2]\n        arr.pop(idx2)\n\n    else:\n        # print(f\"No zeros found, so just adding the firsttwo; \")\n        arr[0] = arr[0] + arr[1]\n        arr.pop(1)\n\n    return arr\n\ndef play(arr, n, m):\n    if (n > m):\n        return \"Sasha\"\n    elif (n == m):\n        flag1 = False\n        flag2 = False\n        for i in range(n):\n            if (flag2 == False and len(arr[i]) >= 2):\n                if (flag1 == False):\n                    flag1 = True\n                    if (len(arr[i]) > 2) or (arr[i][-1] != '0'):\n                        flag2 = True\n                else:\n                    flag2 = True\n        if (flag2):\n            return \"Sasha\"\n        else:\n            return \"Anna\"\n    else:\n        # print(f\"Starting with {arr}\")\n        while (len(arr) > 1):\n            arr = anna(arr)\n            # print(f\"Anna did {arr}\")\n            arr = sasha(arr)\n            # print(f\"Sasha did {arr}\")\n\n        if (int(arr[0]) >= 10**m):\n            return \"Sasha\"\n        else:\n            return \"Anna\"\n\n# Sasha wants BIG\n# Anna wants smol\n\nt = int(input())\nfor testcase in range(t):\n    n,m = map(int, input().split())    \n    a = input().split(' ')\n\n    print(play(a, n, m))",
        "correct": false,
        "task_id": 358
    },
    {
        "description": "You are given a positive integer x . Find any array of integers a_0, a_1,\n\\ldots, a_{n-1} for which the following holds:\n\n  * 1 \\le n \\le 32 , \n  * a_i is 1 , 0 , or -1 for all 0 \\le i \\le n - 1 , \n  * x = \\displaystyle{\\sum_{i=0}^{n - 1}{a_i \\cdot 2^i}} , \n  * There does not exist an index 0 \\le i \\le n - 2 such that both a_{i} \\neq 0 and a_{i + 1} \\neq 0 . \n\nIt can be proven that under the constraints of the problem, a valid array\nalways exists.\n\nInput\n\nEach test contains multiple test cases. The first line of input contains a\nsingle integer t (1 \\le t \\le 10^4 ) — the number of test cases. The\ndescription of the test cases follows.\n\nThe only line of each test case contains a single positive integer x (1 \\le x\n< 2^{30} ).\n\nOutput\n\nFor each test case, output two lines.\n\nOn the first line, output an integer n (1 \\le n \\le 32 ) — the length of the\narray a_0, a_1, \\ldots, a_{n-1} .\n\nOn the second line, output the array a_0, a_1, \\ldots, a_{n-1} .\n\nIf there are multiple valid arrays, you can output any of them.\n\nExample\n\nInput\n\n    7\n    \n    1\n    \n    14\n    \n    24\n    \n    15\n    \n    27\n    \n    11\n    \n    19\n\nOutput\n\n    1\n    1\n    5\n    0 -1 0 0 1\n    6\n    0 0 0 -1 0 1\n    5\n    -1 0 0 0 1\n    6\n    -1 0 -1 0 0 1\n    5\n    -1 0 -1 0 1\n    5\n    -1 0 1 0 1\n\nNote\n\nIn the first test case, one valid array is [1] , since (1) \\cdot 2^0 = 1 .\n\nIn the second test case, one possible valid array is [0,-1,0,0,1] , since (0)\n\\cdot 2^0 + (-1) \\cdot 2^1 + (0) \\cdot 2^2 + (0) \\cdot 2^3 + (1) \\cdot 2^4 =\n-2 + 16 = 14 .",
        "task_name": "1977-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for x in[*map(int,open(0))][1:]:\n r=[]\n while x:r+=x%2*(1-(x&2)),;x=x-r[-1]>>1\n print(len(r),*r)",
        "correct": true,
        "task_id": 258
    },
    {
        "description": "Harry Potter is hiking in the Alps surrounding Lake Geneva. In this area there\nare m cabins, numbered 1 to m . Each cabin is connected, with one or more\ntrails, to a central meeting point next to the lake. Each trail is either\nshort or long. Cabin i is connected with s_i short trails and l_i long trails\nto the lake.\n\nEach day, Harry walks a trail from the cabin where he currently is to Lake\nGeneva, and then from there he walks a trail to any of the m cabins (including\nthe one he started in). However, as he has to finish the hike in a day, at\nleast one of the two trails has to be short.\n\nHow many possible combinations of trails can Harry take if he starts in cabin\n1 and walks for n days?\n\nGive the answer modulo 10^9 + 7 .\n\nInput\n\nThe first line contains the integers m and n .\n\nThe second line contains m integers, s_1, \\dots, s_m , where s_i is the number\nof short trails between cabin i and Lake Geneva.\n\nThe third and last line contains m integers, l_1, \\dots, l_m , where l_i is\nthe number of long trails between cabin i and Lake Geneva.\n\nWe have the following constraints:\n\n0 \\le s_i, l_i \\le 10^3 .\n\n1 \\le m \\le 10^2 .\n\n1 \\le n \\le 10^3 .\n\nOutput\n\nThe number of possible combinations of trails, modulo 10^9 + 7 .\n\nExample\n\nInput\n\n    3 2\n    \n    1 0 1\n    \n    0 1 1\n\nOutput\n\n    18",
        "task_name": "1970-E1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def generate_words(n):\n    words = []\n    for i in range(n):\n        binary = bin(i)[2:]  # Get binary representation without '0b'\n        word = ''.join('O' if b == '1' else 'X' for b in binary)\n        words.append(word)\n    return words\n\ndef count_unique_substrings(s):\n    substrings = set()\n    length = len(s)\n    for i in range(length):\n        for j in range(i + 1, length + 1):\n            substrings.add(s[i:j])\n    return len(substrings)\n\ndef precompute_powers(words):\n    n = len(words)\n    power_dict = {}\n    for i in range(n):\n        for j in range(n):\n            combined_spell = words[i] + words[j]\n            power = count_unique_substrings(combined_spell)\n            power_dict[power] = (i + 1, j + 1)  # Store 1-based indices\n    return power_dict\n\ndef solve_arithmancy(n, queries):\n    words = generate_words(n)\n    power_dict = precompute_powers(words)\n    results = []\n    for power in queries:\n        if power in power_dict:\n            results.append(power_dict[power])\n        else:\n            results.append(\"NO\")\n    return results\n\n# Example usage\nn = 10  # Number of words to generate\nqueries = [7, 15, 11]  # Example powers to query\nresults = solve_arithmancy(n, queries)\nfor result in results:\n    print(result)",
        "correct": false,
        "task_id": 288
    },
    {
        "description": "This is an interactive problem!\n\nMr. 1048576 is one of those faculty who hates wasting his time in taking class\nattendance. Instead of taking attendance the old-fashioned way, he decided to\ntry out something new today.\n\nThere are n students in his class, having roll numbers 1 to n . He knows that\nexactly 1 student is absent today. In order to determine who is absent, he can\nask some queries to the class. In each query, he can provide two integers l\nand r (1\\leq l\\leq r\\leq n ) and all students whose roll numbers are between l\nand r (inclusive) will raise their hands. He then counts them to determine if\nthe roll number of the absent student lies between these values.\n\nThings seemed fine until his teaching assistant noticed something — the\nstudents are dishonest! Some students whose roll numbers lie in the given\nrange may not raise their hands, while some other students whose roll number\ndoes not lie in the given range may raise their hands. But the students don't\nwant to raise much suspicion. So, only the following 4 cases are possible for\na particular query (l,r) —\n\n  1. True Positive: r-l+1 students are present and r-l+1 students raised their hands. \n  2. True Negative: r-l students are present and r-l students raised their hands. \n  3. False Positive: r-l students are present but r-l+1 students raised their hands. \n  4. False Negative: r-l+1 students are present but r-l students raised their hands. \n\nIn the first two cases, the students are said to be answering honestly, while\nin the last two cases, the students are said to be answering dishonestly. The\nstudents can mutually decide upon their strategy, not known to Mr. 1048576.\nAlso, the students do not want to raise any suspicion and at the same time,\nwant to create a lot of confusion. So, their strategy always meets the\nfollowing two conditions —\n\n  1. The students will never answer honestly 3 times in a row. \n  2. The students will never answer dishonestly 3 times in a row. \n\nMr. 1048576 is frustrated by this act of students. So, he is willing to mark\nat most 2 students as absent (though he knows that only one is). The\nattendance is said to be successful if the student who is actually absent is\namong those two. Also, due to limited class time, he can only ask up to\n\\lceil\\log_{1.116}{n}\\rceil-1 queries (weird numbers but okay). Help him\ncomplete a successful attendance.\n\nInteraction\n\nFirst read a line containing a single integer t (1\\leq t\\leq 2048 ) denoting\nthe number of independent test cases that you must solve.\n\nFor each test case, first read a line containing a single integer n (3\\leq\nn\\leq 10^5 ). Then you may ask up to \\lceil\\log_{1.116}{n}\\rceil-1 queries.\n\nTo ask a query, print a single line in the format \"? l r\" (without quotes)\n(1\\leq l\\leq r\\leq n) . Then read a single line containing a single integer x\n(r-l\\leq x\\leq r-l+1 ) denoting the number of students who raised their hands\ncorresponding to the query.\n\nTo mark a student as absent, print a single line in the format \"! a\" (without\nquotes) (1\\leq a\\leq n) . Then read a single integer y (y\\in\\\\{0,1\\\\} ). If\nthe student with roll number a was absent, y=1 , else, y=0 . Note that this\noperation does not count as a query but you can do this operation at most 2\ntimes.\n\nTo end a test case, print a single line in the format \"#\" (without quotes).\nThen you must continue solving the remaining test cases.\n\nIf you ask more queries than allowed or ask an invalid query, you will get the\nWrong answer verdict.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5 .\n\nAfter printing the answers, do not forget to output end of line and flush the\noutput buffer. Otherwise, you will get the verdict Idleness limit exceeded. To\nflush the buffer, use:\n\n  * fflush(stdout) or cout.flush() in C++; \n  * System.out.flush() in Java; \n  * flush(output) in Pascal; \n  * stdout.flush() in Python; \n  * Read documentation for other languages. \n\nNote that the grader for this problem is adaptive meaning that the answer may\nchange depending on your queries but will always remain consistent with the\nconstraints and the answer to the previous queries.\n\nInput format for Hacks\n\nThe test cases for this problem use both non-adaptive and adaptive graders.\nYou can use the non-adaptive grader for making hacks.\n\nThe first line of input contains a single integer t (1\\leq t\\leq 2048 ).\n\nThe first line of each test case contains three integers g , n and x where g=1\n(to identify that this test case must use the non-adaptive grader), n (3\\leq\nn\\leq 10^5 ) represents the number of students in the class and x (1\\leq x\\leq\nn ) represents the roll number of the student who is absent. You must ensure\nthat the sum of n over all test cases does not exceed 10^5 .\n\nThe second line of each test case contains a single string S (1\\leq\\vert\nS\\vert\\leq 120, S_i\\in \\\\{\\texttt{T},\\texttt{F}\\\\} ). This string represents\nthe pattern of the truth sequence. If S_{(i-1)\\bmod \\vert S\\vert+1}=\n\\texttt{T} , the students will act honestly during the i -th query, otherwise\nthey will act dishonestly. You must also ensure that there is no index i such\nthat S_{(i-1)\\bmod \\vert S\\vert+1} = S_{i\\bmod \\vert S\\vert+1} = S_{(i+1)\\bmod\n\\vert S\\vert+1} .\n\nExample\n\nInput\n\nCopy\n\n    2\n    5\n    \n    3\n    \n    2\n    \n    1\n    \n    2\n    \n    0\n    \n    1\n    \n    0\n    \n    2\n    \n    0\n    \n    1\n    \n    6\n    \n    6\n    \n    2\n    \n    2\n    \n    0\n    \n    1\n    \n    1\n    \n    0\n    \n    0\n    \n    0\n    \n    1\n    \nOutput\n\nCopy\n\n    ? 1 4\n    \n    ? 3 5\n    \n    ? 2 2\n    \n    ? 1 3\n    \n    ? 3 3\n    \n    ? 3 3\n    \n    ! 3\n    \n    ? 2 4\n    \n    ? 4 4\n    \n    ! 2\n    \n    #\n    \n    ? 1 6\n    \n    ? 1 3\n    \n    ? 4 6\n    \n    ? 1 1\n    \n    ? 3 3\n    \n    ? 5 5\n    \n    ! 3\n    \n    ? 2 2\n    \n    ? 4 4\n    \n    ! 4\n    \n    #\n    \nNote\n\nFor the first test case, the student with roll number 2 is absent and the\ntruth sequence (see section for hacks) is TFFTFTTF. During execution of your\nsolution, this test case will use a non-adaptive grader.\n\nFor the second test case, the student with roll number 4 is absent, and the\ntruth sequence is FFTFTTFT. During the execution of your solution, in this\ntest case your program will interact with an adaptive grader. So, the actual\nanswer might be different depending on your queries but will always remain\nconsistent with the responses to the previous queries.",
        "task_name": "1924-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import math\nimport sys\n\ndef ask_query(l, r):\n    print(f\"? {l} {r}\")\n    sys.stdout.flush()\n    x = int(input())\n    return x\n\ndef mark_absent(a):\n    print(f\"! {a}\")\n    sys.stdout.flush()\n    y = int(input())\n    return y\n\ndef solve_test_case(n):\n    max_queries = math.ceil(math.log(n, 1.116)) - 1\n    queries_used = 0\n    possible_absent = set(range(1, n+1))\n\n    while queries_used < max_queries and len(possible_absent) > 2:\n        mid = (min(possible_absent) + max(possible_absent)) // 2\n        x = ask_query(min(possible_absent), mid)\n        if x == mid - min(possible_absent) + 1:\n            possible_absent = set(range(mid+1, max(possible_absent)+1))\n        else:\n            possible_absent = set(range(min(possible_absent), mid+1))\n        queries_used += 1\n\n    if len(possible_absent) == 1:\n        a = next(iter(possible_absent))\n        if mark_absent(a) == 1:\n            return True\n    else:\n        a1, a2 = possible_absent\n        if mark_absent(a1) == 1 or mark_absent(a2) == 1:\n            return True\n\n    return False\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        if solve_test_case(n):\n            print(\"#\")\n            sys.stdout.flush()\n        else:\n            print(\"Failed to determine the absent student\")\n            sys.stdout.flush()\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 247
    },
    {
        "description": "This is the easy version of the problem. The differences between the two\nversions are the constraints on n, m, b_0 and the time limit. You can make\nhacks only if both versions are solved.\n\nLittle R has counted many sets before, and now she decides to count arrays.\n\nLittle R thinks an array b_0, \\ldots, b_n consisting of non-negative integers\nis continuous if and only if, for each i such that 1 \\leq i \\leq n , \\lvert\nb_i - b_{i-1} \\rvert = 1 is satisfied. She likes continuity, so she only wants\nto generate continuous arrays.\n\nIf Little R is given b_0 and a_1, \\ldots, a_n , she will try to generate a\nnon-negative continuous array b , which has no similarity with a . More\nformally, for all 1 \\leq i \\leq n , a_i \\neq b_i holds.\n\nHowever, Little R does not have any array a . Instead, she gives you n , m and\nb_0 . She wants to count the different integer arrays a_1, \\ldots, a_n\nsatisfying:\n\n  * 1 \\leq a_i \\leq m ; \n  * At least one non-negative continuous array b_0, \\ldots, b_n can be generated. \n\nNote that b_i \\geq 0 , but the b_i can be arbitrarily large.\n\nSince the actual answer may be enormous, please just tell her the answer\nmodulo 998\\,244\\,353 .\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t\\ (1 \\leq t \\leq 10^4) . The description of the test cases\nfollows.\n\nThe first and only line of each test case contains three integers n , m , and\nb_0 (1 \\leq n \\leq 2 \\cdot 10^5 , 1 \\leq m \\leq 2 \\cdot 10^5 , 0 \\leq b_0 \\leq\n2\\cdot 10^5 ) — the length of the array a_1, \\ldots, a_n , the maximum\npossible element in a_1, \\ldots, a_n , and the initial element of the array\nb_0, \\ldots, b_n .\n\nIt is guaranteed that the sum of n over all test cases does not exceeds 2\\cdot\n10^5 .\n\nOutput\n\nFor each test case, output a single line containing an integer: the number of\ndifferent arrays a_1, \\ldots, a_n satisfying the conditions, modulo\n998\\,244\\,353 .\n\nExample\n\nInput\n\n    6\n    \n    3 2 1\n    \n    5 5 3\n    \n    13 4 1\n    \n    100 6 7\n    \n    100 11 3\n    \n    1000 424 132\n\nOutput\n\n    6\n    3120\n    59982228\n    943484039\n    644081522\n    501350342\n    \nNote\n\nIn the first test case, for example, when a = [1, 2, 1] , we can set b = [1,\n0, 1, 0] . When a = [1, 1, 2] , we can set b = [1, 2, 3, 4] . In total, there\nare 6 valid choices of a_1, \\ldots, a_n : in fact, it can be proved that only\na = [2, 1, 1] and a = [2, 1, 2] make it impossible to construct a non-negative\ncontinuous b_0, \\ldots, b_n , so the answer is 2^3 - 2 = 6 .",
        "task_name": "1967-E1",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "MOD = 998244353\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        b0 = int(data[index + 2])\n        index += 3\n        \n        # Total number of arrays a\n        total_arrays = mod_exp(m, n, MOD)\n        \n        # Calculate the number of invalid arrays\n        # Invalid arrays are those where no valid b can be constructed\n        # This is a complex part and needs careful consideration\n        # For simplicity, let's assume we have a function to calculate invalid arrays\n        # For now, let's assume invalid_arrays = 0 (as a placeholder)\n        invalid_arrays = 0  # This needs a proper calculation\n        \n        # Valid arrays are total arrays minus invalid arrays\n        valid_arrays = (total_arrays - invalid_arrays) % MOD\n        \n        results.append(valid_arrays)\n    \n    for result in results:\n        print(result)",
        "correct": false,
        "task_id": 137
    },
    {
        "description": "You are playing a very popular Tower Defense game called \"Runnerfield 2\". In\nthis game, the player sets up defensive towers that attack enemies moving from\na certain starting point to the player's base.\n\nYou are given a grid of size n \\times m , on which k towers are already placed\nand a path is laid out through which enemies will move. The cell at the\nintersection of the x -th row and the y -th column is denoted as (x, y) .\n\nEach second, a tower deals p_i units of damage to all enemies within its\nrange. For example, if an enemy is located at cell (x, y) and a tower is at\n(x_i, y_i) with a range of r , then the enemy will take damage of p_i if (x -\nx_i) ^ 2 + (y - y_i) ^ 2 \\le r ^ 2 .\n\nEnemies move from cell (1, 1) to cell (n, m) , visiting each cell of the path\nexactly once. An enemy instantly moves to an adjacent cell horizontally or\nvertically, but before doing so, it spends one second in the current cell. If\nits health becomes zero or less during this second, the enemy can no longer\nmove. The player loses if an enemy reaches cell (n, m) and can make one more\nmove.\n\nBy default, all towers have a zero range, but the player can set a tower's\nrange to an integer r (r > 0 ), in which case the health of all enemies will\nincrease by 3^r . However, each r can only be used for at most one tower.\n\nSuppose an enemy has a base health of h units. If the tower ranges are 2 , 4 ,\nand 5 , then the enemy's health at the start of the path will be h + 3 ^ 2 + 3\n^ 4 + 3 ^ 5 = h + 9 + 81 + 243 = h + 333 . The choice of ranges is made once\nbefore the appearance of enemies and cannot be changed after the game starts.\n\nFind the maximum amount of base health h for which it is possible to set the\nranges so that the player does not lose when an enemy with health h passes\nthrough (without considering the additions for tower ranges).\n\nInput\n\nThe first line contains an integer t (1 \\le t \\le 100 ) — the number of test\ncases.\n\nThe first line of each test case contains three integers n , m , and k (2 \\le\nn, m \\le 50, 1 \\le k < n \\cdot m ) — the dimensions of the field and the\nnumber of towers on it.\n\nThe next n lines each contain m characters — the description of each row of\nthe field, where the character \".\" denotes an empty cell, and the character\n\"#\" denotes a path cell that the enemies will pass through.\n\nThen follow k lines — the description of the towers. Each line of description\ncontains three integers x_i , y_i , and p_i (1 \\le x_i \\le n, 1 \\le y_i \\le m,\n1 \\le p_i \\le 500 ) — the coordinates of the tower and its attack parameter.\nAll coordinates correspond to empty cells on the game field, and all pairs\n(x_i, y_i) are pairwise distinct.\n\nIt is guaranteed that the sum of n \\cdot m does not exceed 2500 for all test\ncases.\n\nOutput\n\nFor each test case, output the maximum amount of base health h on a separate\nline, for which it is possible to set the ranges so that the player does not\nlose when an enemy with health h passes through (without considering the\nadditions for tower ranges).\n\nIf it is impossible to choose ranges even for an enemy with 1 unit of base\nhealth, output \"0\".\n\nExample\n\nInput\n\n    6\n    \n    2 2 1\n    \n    #.\n    \n    ##\n    \n    1 2 1\n    \n    2 2 1\n    \n    #.\n    \n    ##\n    \n    1 2 2\n    \n    2 2 1\n    \n    #.\n    \n    ##\n    \n    1 2 500\n    \n    3 3 2\n    \n    #..\n    \n    ##.\n    \n    .##\n    \n    1 2 4\n    \n    3 1 3\n    \n    3 5 2\n    \n    #.###\n    \n    #.#.#\n    \n    ###.#\n    \n    2 2 2\n    \n    2 4 2\n    \n    5 5 4\n    \n    #....\n    \n    #....\n    \n    #....\n    \n    #....\n    \n    #####\n    \n    3 2 142\n    \n    4 5 9\n    \n    2 5 79\n    \n    1 3 50\n\nOutput\n\n    0\n    1\n    1491\n    11\n    8\n    1797\n    \nNote\n\nIn the first example, there is no point in increasing the tower range, as it\nwill not be able to deal enough damage to the monster even with 1 unit of\nhealth.\n\nIn the second example, the tower has a range of 1 , and it deals damage to the\nmonster in cells (1, 1) and (2, 2) .\n\nIn the third example, the tower has a range of 2 , and it deals damage to the\nmonster in all path cells. If the enemy's base health is 1491 , then after the\naddition for the tower range, its health will be 1491 + 3 ^ 2 = 1500 , which\nexactly equals the damage the tower will deal to it in three seconds.\n\nIn the fourth example, the tower at (1, 2) has a range of 1 , and the tower at\n(3, 1) has a range of 2 .",
        "task_name": "1955-H",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        towers = []\n        for _ in range(k):\n            x = int(data[index]) - 1\n            y = int(data[index + 1]) - 1\n            p = int(data[index + 2])\n            towers.append((x, y, p))\n            index += 3\n        \n        # Find the path\n        path = []\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '#':\n                    path.append((i, j))\n        \n        # Precompute damage for each tower at each path cell for different ranges\n        max_range = 50  # max possible range to consider\n        damage_at_path = [[0] * len(path) for _ in range(k)]\n        \n        for t_idx, (tx, ty, p) in enumerate(towers):\n            for path_idx, (px, py) in enumerate(path):\n                for r in range(max_range + 1):\n                    if (px - tx) ** 2 + (py - ty) ** 2 <= r ** 2:\n                        damage_at_path[t_idx][path_idx] = p\n        \n        # Function to check if a given base health h is possible\n        def can_survive(h):\n            # Try all combinations of ranges for towers\n            from itertools import combinations\n            \n            # Calculate the health increase for each range\n            health_increase = [3 ** r for r in range(max_range + 1)]\n            \n            # Try all combinations of ranges for the towers\n            for ranges in combinations(range(1, max_range + 1), k):\n                total_health = h + sum(health_increase[r] for r in ranges)\n                \n                # Calculate total damage\n                total_damage = 0\n                for path_idx in range(len(path)):\n                    damage = 0\n                    for t_idx in range(k):\n                        r = ranges[t_idx]\n                        if (path[path_idx][0] - towers[t_idx][0]) ** 2 + (path[path_idx][1] - towers[t_idx][1]) ** 2 <= r ** 2:\n                            damage += towers[t_idx][2]\n                    total_damage += damage\n                \n                if total_damage >= total_health:\n                    return True\n            \n            return False\n        \n        # Binary search for the maximum base health h\n        low, high = 0, 10**9\n        answer = 0\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if can_survive(mid):\n                answer = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        results.append(answer)\n    \n    for result in results:\n        print(result)",
        "correct": false,
        "task_id": 314
    },
    {
        "description": "Isaac begins his training. There are n running tracks available, and the i -th\ntrack (1 \\le i \\le n ) consists of a_i equal-length sections.\n\nGiven an integer u (1 \\le u \\le 10^9 ), finishing each section can increase\nIsaac's ability by a certain value, described as follows:\n\n  * Finishing the 1 -st section increases Isaac's performance by u . \n  * Finishing the 2 -nd section increases Isaac's performance by u-1 . \n  * Finishing the 3 -rd section increases Isaac's performance by u-2 . \n  * \\ldots \n  * Finishing the k -th section (k \\ge 1 ) increases Isaac's performance by u+1-k . (The value u+1-k can be negative, which means finishing an extra section decreases Isaac's performance.) \n\nYou are also given an integer l . You must choose an integer r such that l \\le\nr \\le n and Isaac will finish each section of each track l, l + 1, \\dots, r\n(that is, a total of \\sum_{i=l}^r a_i = a_l + a_{l+1} + \\ldots + a_r\nsections).\n\nAnswer the following question: what is the optimal r you can choose that the\nincrease in Isaac's performance is maximum possible?\n\nIf there are multiple r that maximize the increase in Isaac's performance,\noutput the smallest r .\n\nTo increase the difficulty, you need to answer the question for q different\nvalues of l and u .\n\nInput\n\nThe first line of input contains a single integer t (1 \\le t \\le 10^4 ) — the\nnumber of test cases.\n\nThe descriptions of the test cases follow.\n\nThe first line contains a single integer n (1 \\le n \\le 10^5 ).\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^4\n).\n\nThe third line contains a single integer q (1 \\le q \\le 10^5 ).\n\nThe next q lines each contain two integers l and u (1 \\le l \\le n, 1 \\le u \\le\n10^9 ) — the descriptions to each query.\n\nThe sum of n over all test cases does not exceed 2 \\cdot 10^5 . The sum of q\nover all test cases does not exceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, output q integers: the i -th integer contains the optimal\nr for the i -th query. If there are multiple solutions, output the smallest\none.\n\nExample\n\nInput\n\n    5\n    \n    6\n    \n    3 1 4 1 5 9\n    \n    3\n    \n    1 8\n    \n    2 7\n    \n    5 9\n    \n    1\n    \n    10\n    \n    1\n    \n    1 1\n    \n    9\n    \n    5 10 9 6 8 3 10 7 3\n    \n    5\n    \n    8 56\n    \n    1 12\n    \n    9 3\n    \n    1 27\n    \n    5 45\n    \n    5\n    \n    7 9 2 5 2\n    \n    10\n    \n    1 37\n    \n    2 9\n    \n    3 33\n    \n    4 32\n    \n    4 15\n    \n    2 2\n    \n    4 2\n    \n    2 19\n    \n    3 7\n    \n    2 7\n    \n    10\n    \n    9 1 6 7 6 3 10 7 3 10\n    \n    5\n    \n    10 43\n    \n    3 23\n    \n    9 3\n    \n    6 8\n    \n    5 14\n\nOutput\n\n    3 4 5 \n    1 \n    9 2 9 4 9 \n    5 2 5 5 5 2 4 5 4 2 \n    10 6 9 7 7 \n    \nNote\n\nFor the 1 -st query in the first test case:\n\n  * By choosing r = 3 , Isaac finishes a_1 + a_2 + a_3 = 3 + 1 + 4 = 8 sections in total, hence his increase in performance is u+(u-1)+\\ldots+(u-7)=8+7+6+5+4+3+2+1 = 36 . \n  * By choosing r = 4 , Isaac finishes a_1 + a_2 + a_3 + a_4 = 3 + 1 + 4 + 1 = 9 sections in total, hence his increase in performance is u+(u-1)+\\ldots+(u-8)=8+7+6+5+4+3+2+1+0 = 36 . \n\nBoth choices yield the optimal increase in performance, however we want to\nchoose the smallest r . So we choose r = 3 .\n\nFor the 2 -nd query in the first test case, by choosing r = 4 , Isaac finishes\na_2 + a_3 + a_4 = 1 + 4 + 1 = 6 sections in total, hence his increase in\nperformance is u+(u-1)+\\ldots+(u-5)=7+6+5+4+3+2 = 27 . This is the optimal\nincrease in performance.\n\nFor the 3 -rd query in the first test case:\n\n  * By choosing r = 5 , Isaac finishes a_5 = 5 sections in total, hence his increase in performance is u+(u-1)+\\ldots+(u-4)=9+8+7+6+5 = 35 . \n  * By choosing r = 6 , Isaac finishes a_5 + a_6 = 5 + 9 = 14 sections in total, hence his increase in performance is u+(u-1)+\\ldots+(u-13)=9+8+7+6+5+4+3+2+1+0+(-1)+(-2)+(-3)+(-4) = 35 . \n\nBoth choices yield the optimal increase in performance, however we want to\nchoose the smallest r . So we choose r = 5 .\n\nHence the output for the first test case is [3, 4, 5] .",
        "task_name": "1933-E",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def evaluate(array, l, u, r):\n    left = array[l - 1] if l != 0 else 0\n    sections = array[r] - left\n    performance = (u + 1 - sections)\n    return performance > 0\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    sections = list(map(int, input().split()))\n    for i in range(1, n):\n       sections[i] += sections[i - 1]\n    q = int(input())\n    answers = []\n    for _ in range(q):\n        l, u = map(int, input().split())\n        left, right = l - 1, n\n        while left + 1 < right:\n            mid = (left + right)//2\n            if evaluate(sections, l - 1, u, mid):\n                left = mid\n            else:\n                right = mid\n        if left == -1:\n            left += 1\n\n        if left != n - 1:\n            lb = l - 1\n            count_1 = sections[left] - (sections[lb - 1] if lb != 0 else 0)\n            count_2 = sections[left + 1] - (sections[lb - 1] if lb != 0 else 0)\n            sum_1 = (u + u - count_1 + 1) * count_1 / 2\n            sum_2 = (u + u - count_2 + 1) * count_2 / 2\n            if sum_2 > sum_1:\n                left += 1\n        answers.append(left + 1)\n    print(*answers)",
        "correct": true,
        "task_id": 131
    },
    {
        "description": "Let's call the Manhattan value of a permutation^{\\dagger} p the value of the\nexpression |p_1 - 1| + |p_2 - 2| + \\ldots + |p_n - n| .\n\nFor example, for the permutation [1, 2, 3] , the Manhattan value is |1 - 1| +\n|2 - 2| + |3 - 3| = 0 , and for the permutation [3, 1, 2] , the Manhattan\nvalue is |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 .\n\nYou are given integers n and k . Find a permutation p of length n such that\nits Manhattan value is equal to k , or determine that no such permutation\nexists.\n\n^{\\dagger} A permutation of length n is an array consisting of n distinct\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\npermutation, but [1,2,2] is not a permutation (2 appears twice in the array),\nand [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\leq t \\leq 10^{4} ) — the number of test cases. The description\nof the test cases follows.\n\nThe only line of each test case contains two integers n and k (1 \\le n \\le 2\n\\cdot 10^{5}, 0 \\le k \\le 10^{12} ) — the length of the permutation and the\nrequired Manhattan value.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot\n10^{5} .\n\nOutput\n\nFor each test case, if there is no suitable permutation, output \"No\".\nOtherwise, in the first line, output \"Yes\", and in the second line, output n\ndistinct integers p_1, p_2, \\ldots, p_n (1 \\le p_i \\le n ) — a suitable\npermutation.\n\nIf there are multiple solutions, output any of them.\n\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\",\n\"Yes\", and \"YES\" will be recognized as a positive answer).\n\nExample\n\nInput\n\n    8\n    \n    3 4\n    \n    4 5\n    \n    7 0\n    \n    1 1000000000000\n    \n    8 14\n    \n    112 777\n    \n    5 12\n    \n    5 2\n\nOutput\n\n    Yes\n    3 1 2\n    No\n    Yes\n    1 2 3 4 5 6 7\n    No\n    Yes\n    8 2 3 4 5 6 1 7\n    No\n    Yes\n    5 4 3 1 2\n    Yes\n    2 1 3 4 5\n    \nNote\n\nIn the first test case, the permutation [3, 1, 2] is suitable, its Manhattan\nvalue is |3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4 .\n\nIn the second test case, it can be proven that there is no permutation of\nlength 4 with a Manhattan value of 5 .\n\nIn the third test case, the permutation [1,2,3,4,5,6,7] is suitable, its\nManhattan value is |1-1|+|2-2|+|3-3|+|4-4|+|5-5|+|6-6|+|7-7|=0 .",
        "task_name": "1978-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def list_p(n,k):\n    k=k//2\n    l=list(range(1,n+1))\n    c=0\n    for i in range(n,-1,-2):\n        c+=1\n        if k==0:\n            return l\n        if k<i-1:\n            return r_ret(c,k,l)\n        k=k-i+1\n        l=ret(c,l)\n\ndef r_ret(c,k,l):\n    x,y=l[-c],l[-c-k]\n    l[-c],l[-c - k]=y,x\n    return l\n\ndef ret(c,l):\n    x,y=l[-c],l[c-1]\n    l[c-1],l[-c]=x,y\n    return l\n\n\ndef tf():\n    n,k=map(int,input().split())\n    if k%2:\n        return 0,0\n    if n%2:\n        max_k=(n**2-1)//2\n    else:\n        max_k=(n**2)//2\n    if max_k<k:\n        return 0,0\n    return n,k\n\ndef p(l):\n    print('YES')\n    for i in l:\n        print(i,end=' ')\n    print()\n    return\n\ndef solve():\n    n,k=tf()\n    if n==0:\n        print('NO')\n        return\n    l=list_p(n,k)\n    p(l)\n    return\n\nT=int(input())\nfor i in range(T):solve()",
        "correct": true,
        "task_id": 217
    }
]