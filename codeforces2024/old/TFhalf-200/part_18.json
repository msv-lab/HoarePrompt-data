[
    {
        "description": "Find the minimum height of a rooted tree^{\\dagger} with a+b+c vertices that\nsatisfies the following conditions:\n\n  * a vertices have exactly 2 children, \n  * b vertices have exactly 1 child, and \n  * c vertices have exactly 0 children. \n\nIf no such tree exists, you should report it.\n![](https://espresso.codeforces.com/2c46a285050907231e79270368226df35bca33b4.png)\n\nThe tree above is rooted at the top vertex, and each vertex is labeled with\nthe number of children it has. Here a=2 , b=1 , c=3 , and the height is 2 .\n\n^{\\dagger} A rooted tree is a connected graph without cycles, with a special\nvertex called the root. In a rooted tree, among any two vertices connected by\nan edge, one vertex is a parent (the one closer to the root), and the other\none is a child.\n\nThe distance between two vertices in a tree is the number of edges in the\nshortest path between them. The height of a rooted tree is the maximum\ndistance from a vertex to the root.\n\nInput\n\nThe first line contains an integer t (1 \\leq t \\leq 10^4 ) — the number of\ntest cases.\n\nThe only line of each test case contains three integers a , b , and c (0 \\leq\na, b, c \\leq 10^5 ; 1 \\leq a + b + c ).\n\nThe sum of a + b + c over all test cases does not exceed 3 \\cdot 10^5 .\n\nOutput\n\nFor each test case, if no such tree exists, output -1 . Otherwise, output one\ninteger — the minimum height of a tree satisfying the conditions in the\nstatement.\n\nExample\n\nInput\n\n    10\n    \n    2 1 3\n    \n    0 0 1\n    \n    0 1 1\n    \n    1 0 2\n    \n    1 1 3\n    \n    3 1 4\n    \n    8 17 9\n    \n    24 36 48\n    \n    1 0 0\n    \n    0 3 1\n\nOutput\n\n    2\n    0\n    1\n    1\n    -1\n    3\n    6\n    -1\n    -1\n    3\n    \nNote\n\nThe first test case is pictured in the statement. It can be proven that you\ncan't get a height smaller than 2 .\n\nIn the second test case, you can form a tree with a single vertex and no\nedges. It has height 0 , which is clearly optimal.\n\nIn the third test case, you can form a tree with two vertices joined by a\nsingle edge. It has height 1 , which is clearly optimal.",
        "task_name": "1950-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for e in[*open(0)][1:]:a,b,c=map(int,e.split());l=a.bit_length();print(c-a-1and-1or(b-2**l+a+c)//c+l)",
        "correct": true,
        "task_id": 176
    },
    {
        "description": "Little R is a magician who likes non-decreasing arrays. She has an array of\nlength n , initially as a_1, \\ldots, a_n , in which each element is an integer\nbetween [1, m] . She wants it to be non-decreasing, i.e., a_1 \\leq a_2 \\leq\n\\ldots \\leq a_n .\n\nTo do this, she can perform several magic tricks. Little R has a fixed array\nb_1\\ldots b_m of length m . Formally, let's define a trick as a procedure that\ndoes the following things in order:\n\n  * Choose a set S \\subseteq \\\\{1, 2, \\ldots, n\\\\} . \n  * For each u \\in S , assign a_u with b_{a_u} . \n\nLittle R wonders how many tricks are needed at least to make the initial array\nnon-decreasing. If it is not possible with any amount of tricks, print -1\ninstead.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\le t\\le 10^4 ). The description of the test cases follows.\n\nThe first line of each test case contains two integers n and m (1\\leq n \\leq\n10^6 , 1 \\leq m \\leq 10^6 ) — the length of the initial array and the range of\nthe elements in the array.\n\nThe second line of each test case contains n integers a_1, \\ldots, a_n (1 \\leq\na_i \\leq m ) — the initial array.\n\nThe third line of each test case contains m integers b_1, \\ldots, b_m (1 \\leq\nb_i \\leq m ) — the fixed magic array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6\nand the sum of m over all test cases does not exceed 10^6 .\n\nOutput\n\nFor each test case, output a single integer: the minimum number of tricks\nneeded, or -1 if it is impossible to make a_1, \\ldots, a_n non-decreasing.\n\nExample\n\nInput\n\n    3\n    \n    5 8\n    \n    1 6 3 7 1\n    \n    2 3 5 8 7 1 5 6\n    \n    3 3\n    \n    1 3 2\n    \n    2 1 3\n    \n    10 10\n    \n    2 8 5 4 8 4 1 5 10 10\n    \n    6 7 2 6 3 4 1 1 3 5\n\nOutput\n\n    3\n    -1\n    3\n    \nNote\n\nIn the first case, the initial array a_1, \\ldots, a_n is [1, 6, 3, 7, 1] . You\ncan choose S as follows:\n\n  * first trick: S = [2, 4, 5] , a = [1, 1, 3, 5, 2] ; \n  * second trick: S = [5] , a = [1, 1, 3, 5, 3] ; \n  * third trick: S = [5] , a = [1, 1, 3, 5, 5] . \n\nSo it is possible to make a_1, \\ldots, a_n non-decreasing using 3 tricks. It\ncan be shown that this is the minimum possible amount of tricks.\n\nIn the second case, it is impossible to make a_1, \\ldots, a_n non-decreasing.",
        "task_name": "1972-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def dfs(x, visited, stable_state, b):\n    if visited[x]:\n        return stable_state[x]\n    visited[x] = True\n    next_value = b[x - 1]\n    stable_state[x] = dfs(next_value, visited, stable_state, b)\n    return stable_state[x]\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        b = list(map(int, data[index:index + m]))\n        index += m\n\n        # Determine stable states\n        visited = [False] * (m + 1)\n        stable_state = [0] * (m + 1)\n        for i in range(1, m + 1):\n            if not visited[i]:\n                dfs(i, visited, stable_state, b)\n\n        # Transform array a to its stable states\n        new_a = [stable_state[x] for x in a]\n\n        # Check if it's possible to make a non-decreasing\n        if sorted(new_a) != new_a:\n            results.append(-1)\n            continue\n\n        # Count transformations needed\n        transform_count = {}\n        for x in a:\n            if x not in transform_count:\n                count = 0\n                current = x\n                while current != stable_state[current]:\n                    current = b[current - 1]\n                    count += 1\n                transform_count[x] = count\n\n        # Minimize the number of tricks\n        counts = sorted(transform_count.values())\n        tricks = 0\n        while counts:\n            max_count = counts.pop()\n            tricks += 1\n            while counts and counts[-1] == max_count:\n                counts.pop()\n\n        results.append(tricks)\n\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n# Example usage:\n# solve()",
        "correct": false,
        "task_id": 26
    },
    {
        "description": "You are given an integer n and three strings a, b, c , each consisting of n\nlowercase Latin letters.\n\nLet a template be a string t consisting of n lowercase and/or uppercase Latin\nletters. The string s matches the template t if the following conditions hold\nfor all i from 1 to n :\n\n  * if the i -th letter of the template is lowercase, then s_i must be the same as t_i ; \n  * if the i -th letter of the template is uppercase, then s_i must be different from the lowercase version of t_i . For example, if there is a letter 'A' in the template, you cannot use the letter 'a' in the corresponding position of the string. \n\nAccordingly, the string doesn't match the template if the condition doesn't\nhold for at least one i .\n\nDetermine whether there exists a template t such that the strings a and b\nmatch it, while the string c does not.\n\nInput\n\nThe first line contains an integer t (1 \\le t \\le 1000 ) — the number of test\ncases.\n\nThe first line of each test case contains an integer n (1 \\le n \\le 20 ) — the\nlength of the given strings.\n\nThe next three lines contain the strings a, b and c . Each string consists of\nexactly n lowercase Latin letters.\n\nOutput\n\nFor each testcase, print \"YES\" if there exists a template t such that the\nstrings a and b match it, while the string c does not. Otherwise, print \"NO\".\n\nExample\n\nInput\n\n    4\n    \n    1\n    \n    a\n    \n    b\n    \n    c\n    \n    2\n    \n    aa\n    \n    bb\n    \n    aa\n    \n    10\n    \n    mathforces\n    \n    luckforces\n    \n    adhoccoder\n    \n    3\n    \n    acc\n    \n    abd\n    \n    abc\n\nOutput\n\n    YES\n    NO\n    YES\n    NO\n    \nNote\n\nIn the first test case, you can use the template \"C\". The first letter of\nstrings a and b differ from 'c', so they match the template. The first letter\nof string c equals 'c', so it doesn't match.\n\nIn the third test case, you can use the template \"CODEforces\".",
        "task_name": "1922-A",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "for _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    c = input()\n    flag = \"NO\"\n    for i in range(n):\n        if a[i] != c[i] and b[i] != c[i]:\n            flag = \"YES\"\n            break\n    print(flag)",
        "correct": true,
        "task_id": 207
    },
    {
        "description": "This is an interactive problem.\n\nYou are given a grid with n rows and m columns. The coordinates (x, y)\nrepresent the cell on the grid, where x (1 \\leq x \\leq n ) is the row number\ncounting from the top and y (1 \\leq y \\leq m ) is the column number counting\nfrom the left. It is guaranteed that there are exactly 2 mines in the grid at\ndistinct cells, denoted as (x_1, y_1) and (x_2, y_2) . You are allowed to make\nno more than 4 queries to the interactor, and after these queries, you need to\nprovide the location of one of the mines.\n\nIn each query, you can choose any grid cell (x, y) , and in return, you will\nreceive the minimum Manhattan distance from both the mines to the chosen cell,\ni.e., you will receive the value \\min(|x-x_1|+|y-y_1|, |x-x_2|+|y-y_2|) .\n\nYour task is to determine the location of one of the mines after making the\nqueries.\n\nInput\n\nEach test contains multiple test cases. The first line of input contains a\nsingle integer t (1 \\leq t \\leq 3 \\cdot 10^{3} ) — the number of test cases.\n\nThe only line of each test case contains two integers n and m (2 \\leq n \\leq\n10^{8} , 2 \\leq m \\leq 10^{8} ) — the number of rows and columns.\n\nInteraction\n\nFor each test case, the interaction starts with reading n and m .\n\nThen you are allowed to make at most 4 queries in the following way:\n\n\"? x y\" (1 \\leq x \\leq n and 1 \\leq y \\leq m )\n\nAfter each one, you should read an integer d which is equal to\n\\min(|x-x_1|+|y-y_1|, |x-x_2|+|y-y_2|) .\n\nWhen you have found the location of any one of the mines, print a single line\n\"! x y\" (without quotes), representing the row and the column of one of the\nmines. Outputting the answer does not count as a query.\n\nAfter printing the answer, your program must then continue to solve the\nremaining test cases, or exit if all test cases have been solved.\n\nThe interactor for this problem is not adaptive: cells of mines are fixed\nbefore any queries are made.\n\nAfter printing a query, do not forget to output the end of line and flush the\noutput. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n  * fflush(stdout) or cout.flush() in C++; \n  * System.out.flush() in Java; \n  * flush(output) in Pascal; \n  * stdout.flush() in Python; \n  * see the documentation for other languages. \n\nHacks:\n\nTo make a hack, use the following format:\n\nThe first line contains a single integer t (1 \\leq t \\leq 3 \\cdot 10^{3} ) —\nthe number of test cases.\n\nThe description of each test case should consist of three lines.\n\nThe first line contains two integers n and m (2 \\leq n \\leq 10^{8} , 2 \\leq m\n\\leq 10^{8} ) — the number of rows and columns.\n\nThe second line contains the coordinates of the first mine x_1 and y_1 (1 \\leq\nx_1 \\leq n , 1 \\leq y_1 \\leq m ).\n\nThe third line contains the coordinates of the second mine x_2 and y_2 (1 \\leq\nx_2 \\leq n , 1 \\leq y_2 \\leq m ).\n\nThe mines should be located at different positions.\n\nExample\n\nInput\n\n    2\n    4 4\n    \n    3\n    \n    2\n    \n    2\n    \n    0\n    \n    5 5\n    \n    1\n    \n    2\n    \n    3\n    \nOutput\n\n    ? 1 1\n    \n    ? 1 4\n    \n    ? 4 1\n    \n    ? 2 3\n    \n    ! 2 3\n    \n    ? 5 5\n    \n    ? 2 2\n    \n    ? 3 3\n    \n    ! 1 1\n    \nNote\n\nIn the first test case, we start by querying the upper-left corner (1, 1) and\nget the result 3 , which means that there is a mine on the counter diagonal,\nand there is no mine above it.\n\nIn the image below, each cell contains a number indicating the distance to the\nblue cell. The green cells are candidates to contain the nearest mine.\n\n![](https://espresso.codeforces.com/d7550b3a7833b6bf1bda7128868278104d358809.png)\n\nThen we ask three cells on that diagonal, and at the last query, we get the\nresult 0 , which means that a mine is found at the position (2, 3) .\n\nThe second mine was located at the position (3, 2) .\n\nIn the second test case, we start by asking the lower-right corner (5, 5) ,\nand get the result 1 , which means that one of the two neighbours contains a\nmine, let's call it mine 1 .\n\n![](https://espresso.codeforces.com/02e28fb3301e94dcf02f896272409793bca48022.png)\n\nThen we ask cell (2, 2) . We can see that these green cells don't intersect\nwith the green cells from the first query, so they contain the other mine,\nlet's call it mine 2 .\n\n![](https://espresso.codeforces.com/7b5a8f68d0a5bcd1d2de93271789888d5e3e6289.png)\n\nQuery 3 is cell (3, 3) . These cells contain mine 1 , but we still don't know\nwhere exactly. Nevertheless, we can determine that the only possible cell for\nmine 2 is (1, 1) , because all other candidates are at a distance closer than\n3 for this query.\n\n![](https://espresso.codeforces.com/e70571e7b39fef9a48457e0d71abf24692ae99f8.png)",
        "task_name": "1934-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\ninp = lambda func=int: list(map(func, sys.stdin.readline().split()))\nt = inp()[0]\nfor _ in range(t):\n\tn,m = inp()\n\tprint(\"? 1 1\")\n\tsys.stdout.flush()\n\td1 = int(input())\n\tprint(\"?\",1,m)\n\tsys.stdout.flush()\n\td2 = int(input())\n\ty = d1+d2-m+1\n\ty2 = y//2\n\tif (y%2==0 and y2 >= 0 and y2<=n-1):\n\t\tprint(\"?\",y2+1,d1-y2+1)\n\t\tsys.stdout.flush()\n\t\td3 = int(input())\n\t\tif d3==0:\n\t\t\tprint(\"!\",y2+1,d1-y2+1)\n\t\t\tsys.stdout.flush()\n\t\t\tcontinue\n\tprint(\"?\",n,1)\n\tsys.stdout.flush()\n\td4 = int(input())\n\ty = d1+d4-n+1\n\ty2 = y//2\n\tprint(\"!\",d1-y2+1,y2+1)\n\tsys.stdout.flush()",
        "correct": true,
        "task_id": 120
    },
    {
        "description": "Given an integer r , find the number of lattice points that have a Euclidean\ndistance from (0, 0) greater than or equal to r but strictly less than r+1 .\n\nA lattice point is a point with integer coordinates. The Euclidean distance\nfrom (0, 0) to the point (x,y) is \\sqrt{x^2 + y^2} .\n\nInput\n\nThe first line contains a single integer t (1 \\leq t \\leq 1000 ) — the number\nof test cases.\n\nThe only line of each test case contains a single integer r (1 \\leq r \\leq\n10^5 ).\n\nThe sum of r over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, output a single integer — the number of lattice points\nthat have an Euclidean distance d from (0, 0) such that r \\leq d < r+1 .\n\nExample\n\nInput\n\n    6\n    \n    1\n    \n    2\n    \n    3\n    \n    4\n    \n    5\n    \n    1984\n\nOutput\n\n    8\n    16\n    20\n    24\n    40\n    12504\n    \nNote\n\nThe points for the first three test cases are shown below.\n\n![](https://espresso.codeforces.com/66c3f9d945c97358ed2f31c823ce9b70e46c6a4d.png)",
        "task_name": "1971-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "def solve(r):\n    return 3 * r * r\n\nt = int(input())\nfor _ in range(t):\n    r = int(input())\n    print(solve(r))",
        "correct": false,
        "task_id": 222
    },
    {
        "description": "You are given two integer arrays: array a of length n and array b of length\nn+1 .\n\nYou can perform the following operations any number of times in any order:\n\n  * choose any element of the array a and increase it by 1 ; \n  * choose any element of the array a and decrease it by 1 ; \n  * choose any element of the array a , copy it and append the copy to the end of the array a . \n\nYour task is to calculate the minimum number of aforementioned operations\n(possibly zero) required to transform the array a into the array b . It can be\nshown that under the constraints of the problem, it is always possible.\n\nInput\n\nThe first line contains a single integer t (1 \\le t \\le 10^4 ) — the number of\ntest cases.\n\nEach test case consists of three lines:\n\n  * the first line contains a single integer n (1 \\le n \\le 2 \\cdot 10^5 ); \n  * the second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le 10^9 ); \n  * the third line contains n + 1 integers b_1, b_2, \\dots, b_{n + 1} (1 \\le b_i \\le 10^9 ). \n\nAdditional constraint on the input: the sum of n over all test cases doesn't\nexceed 2 \\cdot 10^5 .\n\nOutput\n\nFor each test case, print a single integer — the minimum number of operations\n(possibly zero) required to transform the array a into the array b .\n\nExample\n\nInput\n\n    3\n    \n    1\n    \n    2\n    \n    1 3\n    \n    2\n    \n    3 3\n    \n    3 3 3\n    \n    4\n    \n    4 2 1 2\n    \n    2 1 5 2 3\n\nOutput\n\n    3\n    1\n    8\n    \nNote\n\nIn the first example, you can transform a into b as follows: [2] \\rightarrow\n[2, 2] \\rightarrow [1, 2] \\rightarrow [1, 3] .",
        "task_name": "1976-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "R=lambda:map(int,input().split())\nt,=R()\nwhile t:t-=1;R();a=R();*b,l=R();a=*map(sorted,zip(a,b)),;print(sum(y-x\nfor x,y in a)+min(max(0,x-l)+max(0,l-y)for x,y in a)+1)",
        "correct": true,
        "task_id": 229
    },
    {
        "description": "Mocha likes arrays, so before her departure, Chamo gave her an array a\nconsisting of n positive integers as a gift.\n\nMocha doesn't like arrays containing different numbers, so Mocha decides to\nuse magic to change the array. Mocha can perform the following three-step\noperation some (possibly, zero) times:\n\n  1. Choose indices l and r (1 \\leq l < r \\leq n ) \n  2. Let x be the median^\\dagger of the subarray [a_l, a_{l+1},\\ldots, a_r] \n  3. Set all values a_l, a_{l+1},\\ldots, a_r to x \n\nSuppose a=[1,2,3,4,5] initially:\n\n  * If Mocha chooses (l,r)=(3,4) in the first operation, then x=3 , the array will be changed into a=[1,2,3,3,5] . \n  * If Mocha chooses (l,r)=(1,3) in the first operation, then x=2 , the array will be changed into a=[2,2,2,4,5] . \n\nMocha will perform the operation until the array contains only the same\nnumber. Mocha wants to know what is the maximum possible value of this number.\n\n^\\dagger The median in an array b of length m is an element that occupies\nposition number \\lfloor \\frac{m+1}{2} \\rfloor after we sort the elements in\nnon-decreasing order. For example, the median of [3,1,4,1,5] is 3 and the\nmedian of [5,25,20,24] is 20 .\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of\ntest cases t (1\\leq t\\leq 500 ). The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (2\\leq n\\leq 10^5\n) — the length of the array a .\n\nThe second line of each test case contains n integers a_1,a_2,\\ldots,a_n\n(1\\leq a_i \\leq 10^9 ) — the elements of the array a .\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5 .\n\nOutput\n\nFor each test case, output the maximum value of the number.\n\nExample\n\nInput\n\n    2\n    \n    2\n    \n    1 2\n    \n    5\n    \n    1 2 3 4 5\n\nOutput\n\n    1\n    4\n    \nNote\n\nIn the first test case, a=[1,2] . Mocha can only choose the interval\n(l,r)=(1,2) . The array will be changed to a=[1,1] . Therefore, the answer is\n1 .\n\nIn the second test case, Mocha can perform the following operations:\n\n  * Choose the interval (l,r)=(4,5) , then a=[1,2,3,4,4] . \n  * Choose the interval (l,r)=(3,5) , then a=[1,2,4,4,4] . \n  * Choose the interval (l,r)=(1,5) , then a=[4,4,4,4,4] . \n\nThe array contains only the same number, which is 4 . It can be proven that\nthe maximum value of the final number cannot be greater than 4 .",
        "task_name": "1975-C",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "from collections import Counter\n\ndef max_possible_value(arr):\n    counter = Counter(arr)\n    left, right = min(counter.keys()), max(counter.keys())\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        count = sum(val for key, val in counter.items() if key >= mid)\n        \n        if count * (mid - 1) <= len(arr):\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Test the function\nprint(max_possible_value([1, 2, 3, 4, 5])) # Output: 4\nprint(max_possible_value([1, 2, 1, 2, 1])) # Output: 1",
        "correct": false,
        "task_id": 19
    },
    {
        "description": "There are n bags numbered from 1 to n , the i -th bag contains a_i golden\ncoins and b_i silver coins.\n\nThe value of a gold coin is 1 . The value of a silver coin is either 0 or 1 ,\ndetermined for each silver coin independently (0 with probability \\frac{1}{2}\n, 1 with probability \\frac{1}{2} ).\n\nYou have to answer q independent queries. Each query is the following:\n\n  * l r — calculate the probability that the total value of coins in bags from l to r is strictly greater than the total value in all other bags. \n\nInput\n\nThe first line contains two integers n and q (1 \\le n, q \\le 3 \\cdot 10^5 ) —\nthe number of bags and the number of queries, respectively.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (0 \\le a_i \\le 10^6 )\n— the number of gold coins in the i -th bag.\n\nThe third line contains n integers b_1, b_2, \\dots, b_n (0 \\le b_i \\le 10^6 )\n— the number of silver coins in the i -th bag.\n\nNext q lines contain queries. The j -th of the next q lines contains two\nintegers l_j and r_j (1 \\le l_j \\le r_j \\le n ) — the description of the j -th\nquery.\n\nAdditional constraints on the input:\n\n  * the sum of the array a doesn't exceed 10^6 ; \n  * the sum of the array b doesn't exceed 10^6 . \n\nOutput\n\nFor each query, print one integer — the probability that the total value of\ncoins in bags from l to r is strictly greater than the total value in all\nother bags, taken modulo 998244353 .\n\nFormally, the probability can be expressed as an irreducible fraction\n\\frac{x}{y} . You have to print the value of x \\cdot y^{-1} \\bmod 998244353 ,\nwhere y^{-1} is an integer such that y \\cdot y^{-1} \\bmod 998244353 = 1 .\n\nExamples\n\nInput\n\n    2 2\n    \n    1 0\n    \n    0 2\n    \n    2 2\n    \n    1 1\n\nOutput\n\n    748683265 748683265 \n\nInput\n\n    4 3\n    \n    2 3 4 5\n    \n    1 0 7 3\n    \n    3 3\n    \n    2 3\n    \n    1 4\n\nOutput\n\n    997756929 273932289 1 \n\nNote\n\nIn both queries from the first example, the answer is \\frac{1}{4} .",
        "task_name": "1948-F",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "import sys\n\nMOD = 998244353\n\ndef mod_inverse(a, p):\n    # Calculate the modular inverse using Fermat's little theorem\n    return pow(a, p-2, p)\n\ndef calculate_total_value(a, b):\n    # Calculate the total value of gold and silver coins for each bag\n    total_value = [a[i] + b[i] for i in range(len(a))]\n    return total_value\n\ndef process_query(l, r, total_value, n):\n    # Calculate the total value in the specified range and compare it to the total value in the remaining bags\n    range_value = sum(total_value[i-1] for i in range(l, r+1))\n    other_value = sum(total_value) - range_value\n    \n    # Calculate the probability that the total value in the specified range is strictly greater than the total value in the remaining bags\n    if range_value > other_value:\n        return 1\n    else:\n        return 0\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    a = [int(data[2+i]) for i in range(n)]\n    b = [int(data[2+n+i]) for i in range(n)]\n    \n    total_value = calculate_total_value(a, b)\n    \n    for i in range(q):\n        l = int(data[2+2*n+i*2])\n        r = int(data[2+2*n+i*2+1])\n        \n        probability = process_query(l, r, total_value, n)\n        print(probability)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": 264
    },
    {
        "description": "A progressive square of size n is an n \\times n matrix. Maxim chooses three\nintegers a_{1,1} , c , and d and constructs a progressive square according to\nthe following rules:\n\nFor example, if n = 3 , a_{1,1} = 1 , c=2 , and d=3 , then the progressive\nsquare looks as follows:\n\nLast month Maxim constructed a progressive square and remembered the values of\nn , c , and d . Recently, he found an array b of n^2 integers in random order\nand wants to make sure that these elements are the elements of that specific\nsquare.\n\nIt can be shown that for any values of n , a_{1,1} , c , and d , there exists\nexactly one progressive square that satisfies all the rules.\n\nInput\n\nThe first line contains an integer t (1 \\le t \\le {10} ^ 4 ) — the number of\ntest cases.\n\nThe first line of each test case contains three integers n , c , and d (2 \\le\nn \\le 500 , 1 \\le c, d \\le 10^6 ) — the size of the square and the values of c\nand d as described in the statement.\n\nThe second line of each test case contains n \\cdot n integers b_1, b_2, \\dots,\nb_{n \\cdot n} (1 \\le b_i \\le 10^9 ) — the elements found by Maxim.\n\nIt is guaranteed that the sum of n ^ 2 over all test cases does not exceed 25\n\\cdot {10} ^ 4 .\n\nOutput\n\nFor each test case, output \"YES\" in a separate line if a progressive square\nfor the given n , c , and d can be constructed from the array elements a ,\notherwise output \"NO\".\n\nYou can output each letter in any case (lowercase or uppercase). For example,\nthe strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive\nanswer.\n\nExample\n\nInput\n\n    5\n    \n    3 2 3\n    \n    3 9 6 5 7 1 10 4 8\n    \n    3 2 3\n    \n    3 9 6 5 7 1 11 4 8\n    \n    2 100 100\n    \n    400 300 400 500\n    \n    3 2 3\n    \n    3 9 6 6 5 1 11 4 8\n    \n    4 4 4\n    \n    15 27 7 19 23 23 11 15 7 3 19 23 11 15 11 15\n\nOutput\n\n    NO\n    YES\n    YES\n    NO\n    NO",
        "task_name": "1955-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t = int(input())\n# t = 1\nfor _ in range(0,t):\n    n,c,d = [int(x) for x in input().strip().split()]\n    nums = [int(x) for x in input().split()]\n    nums.sort()\n    orders = []\n\n    for i in range(0,n):\n        for j in range(0,n):\n            orders.append(i*c + d*j + nums[0])\n    # print('orders', orders)\n    # print('nums', nums)\n    if sorted(orders) == sorted(nums):\n        print('YES')\n    # if orders == nums:\n    else:\n        print('NO')",
        "correct": false,
        "task_id": 310
    },
    {
        "description": "Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a\ndrawing and attract her attention.\n\nAs a drawing, he decided to draw a square grid of size n \\times n , in which\nsome cells are colored. But coloring the cells is difficult, so he wants to\ncolor as few cells as possible. But at the same time, he wants at least k\ndiagonals to have at least one colored cell. Note that the square grid of size\nn \\times n has a total of 4n - 2 diagonals.\n\nHelp little Sasha to make the girl fall in love with him and tell him the\nminimum number of cells he needs to color.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single\ninteger t (1 \\le t \\le 1000 ) — the number of test cases. The description of\nthe test cases follows.\n\nThe only line of each test case contains two integers n and k (2 \\leq n \\leq\n10^8 , 1 \\leq k \\leq 4n - 2 ) — the size of the square grid and the minimum\nnumber of diagonals in which there should be at least one colored cell.\n\nOutput\n\nFor each test case, output a single integer — the minimum number of cells that\nneed to be colored.\n\nExample\n\nInput\n\n    7\n    \n    3 4\n    \n    3 3\n    \n    3 10\n    \n    3 9\n    \n    4 7\n    \n    7 11\n    \n    2 3\n\nOutput\n\n    2\n    2\n    6\n    5\n    4\n    6\n    2\n    \nNote\n\nIn the pictures below, the colored cells are marked in black, and all\ndiagonals are marked in purple.\n\nIn the first test case, you can color 2 cells so that 4 diagonals contain at\nleast one colored cell:\n\n![](https://espresso.codeforces.com/c88e80de5be4f91764dbe5bdc534c50fec115db3.png)\n\nIn the third test case, you can color 6 cells so that all 10 diagonals contain\nat least one colored cell:\n\n![](https://espresso.codeforces.com/624a36083689f6fb20bf243e5d1707fdcd71ef60.png)",
        "task_name": "1929-B",
        "dataset": "codeforces2024",
        "model": "human",
        "generated_code": "t=input()\nt=int(t)\nwhile t:\n    n,k=input().split()\n    n=int(n)\n    k=int(k)\n    if(k==4*n-2):\n        a=k//2+1 \n        print(a)\n        t=t-1\n        continue\n    if(k%2!=0):\n        a=k//2+1 \n        print(a)\n        t=t-1\n        continue\n    if(k%2==0):\n        a=k//2 \n        print(a)\n        t=t-1\n        continue",
        "correct": true,
        "task_id": 99
    }
]