Let's analyze the given Python program step by step to determine its correctness.

### Analysis

1. **Initial Checks**:
   ```python
   if (not xs) :
       return float('-inf')
   ```
   This handles the case where the input list `xs` is empty. In this case, it correctly returns `-inf` because the product of an empty list is undefined in this context, and `-inf` is a reasonable choice to indicate no valid product.

2. **Initialization**:
   ```python
   min_ending_here = xs[0]
   max_ending_here = xs[0]
   best_so_far = xs[0]
   ```
   The initial values for `min_ending_here`, `max_ending_here`, and `best_so_far` are set to the first element of the list. This is a good starting point.

3. **Iterate Through List**:
   ```python
   for num in xs[1:]:
       temp = max_ending_here * num
       
       max_ending_here = max(num, temp, min_ending_here * num)
       
       min_ending_here = min(num, temp, min_ending_here * num)
   ```
   - `temp` is calculated as the product of the current `max_ending_here` and the current number `num`.
   - `max_ending_here` is updated to be the maximum of three values: the current number `num`, the product `temp`, and the product of `min_ending_here` and `num`.
   - `min_ending_here` is updated to be the minimum of three values: the current number `num`, the product `temp`, and the product of `min_ending_here` and `num`.

4. **Final Update**:
   ```python
   if (max_ending_here > best_so_far) :
       best_so_far = max_ending_here
   ```
   After the loop, this checks if the current `max_ending_here` is greater than `best_so_far` and updates `best_so_far` accordingly.

### Correctness Check

The logic implemented in the program is correct for finding the maximum product of any sublist. It effectively keeps track of the maximum and minimum products ending at each position, which helps in handling negative numbers that can turn large negative products into large positive products.

### Conclusion

The given program is correct.

**Correctness: True**