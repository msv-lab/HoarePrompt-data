To determine the correctness of the provided solution, let's analyze the logic step-by-step.

### Analysis

1. **Initial Checks**:
   ```python
   if (not xs):
       return float('-inf')
   ```
   This handles the case where the input list `xs` is empty. It correctly returns `-inf`.

2. **Initialization**:
   ```python
   min_ending_here = xs[0]
   max_ending_here = xs[0]
   best_so_far = xs[0]
   ```
   The variables `min_ending_here`, `max_ending_here`, and `best_so_far` are initialized to the first element of the list.

3. **Main Loop**:
   ```python
   for num in xs[1:]:
       temp = max_ending_here * num
       
       max_ending_here = max(num, temp, min_ending_here * num)
       
       min_ending_here = min(num, temp, min_ending_here * num)
   ```
   - `temp` is the product of the current `max_ending_here` and the current number `num`.
   - `max_ending_here` is updated to be the maximum of `num`, `temp`, and `min_ending_here * num`.
   - `min_ending_here` is updated to be the minimum of `num`, `temp`, and `min_ending_here * num`.

4. **Final Check**:
   ```python
   if (max_ending_here > best_so_far):
       best_so_far = max_ending_here
   ```
   This ensures that `best_so_far` is updated if `max_ending_here` is greater than the current `best_so_far`.

5. **Return Statement**:
   ```python
   return best_so_far
   ```
   The function returns the best product found.

### Explanation

- **Correctness**: The algorithm is designed to handle both positive and negative numbers efficiently. By maintaining `min_ending_here` and `max_ending_here`, it can accurately track the maximum product of any sublist, even when encountering negative numbers that can turn a previously small product into a large one.

### Conclusion

The given program is indeed correct. It effectively finds the maximum product of any sublist in a list of integers, considering both positive and negative numbers.

**Correctness: True**