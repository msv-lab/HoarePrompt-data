The provided solution is almost correct but has a minor issue in the loop where it updates `best_so_far`. The variable `best_so_far` should be updated within the loop after each iteration to ensure that it always holds the maximum product found so far. Here's the corrected version of the function:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  
    
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]
    
    for num in xs[1:]:
        temp = max_ending_here * num
        
        max_ending_here = max(num, temp, min_ending_here * num)
        min_ending_here = min(num, temp, min_ending_here * num)
        
        best_so_far = max(best_so_far, max_ending_here)
    
    return best_so_far
```

### Explanation:
1. **Initialization**:
   - `min_ending_here` and `max_ending_here` are initialized to the first element of the list.
   - `best_so_far` is also initialized to the first element of the list.

2. **Loop through the list**:
   - For each element `num` starting from the second element:
     - Calculate the potential new maximum product ending at the current position (`temp`).
     - Update `max_ending_here` to be the maximum of the current number, the product of the current number and the previous maximum product, and the product of the current number and the previous minimum product.
     - Update `min_ending_here` to be the minimum of the current number, the product of the current number and the previous maximum product, and the product of the current number and the previous minimum product.
     - Update `best_so_far` to be the maximum of `best_so_far` and `max_ending_here`.

3. **Return the result**:
   - After processing all elements, `best_so_far` will hold the maximum product of any sublist.

This approach ensures that the function correctly handles both positive and negative numbers, as well as zeros, and finds the maximum product of any sublist.