The provided solution has a logical flaw that could lead to incorrect results in certain cases. Specifically, the update of `best_so_far` should be inside the loop to ensure it captures the maximum value at each step. Here's the corrected version of the function:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  
    
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]
    
    for num in xs[1:]:
        temp = max_ending_here * num
        max_ending_here = max(num, temp, min_ending_here * num)
        min_ending_here = min(num, temp, min_ending_here * num)
        
        # Update best_so_far inside the loop
        best_so_far = max(best_so_far, max_ending_here)
    
    return best_so_far
```

### Explanation:
- **Initialization**: The variables `min_ending_here`, `max_ending_here`, and `best_so_far` are initialized to the first element of the list.
- **Loop**: For each subsequent element in the list:
  - `temp` is the product of the current maximum product ending here and the current number.
  - `max_ending_here` is updated to the maximum of the current number, the product of the current number and the previous maximum product, and the product of the current number and the previous minimum product (to handle negative numbers).
  - `min_ending_here` is updated similarly but to the minimum of the three values.
  - `best_so_far` is updated to the maximum of itself and `max_ending_here`.
- **Return**: Finally, `best_so_far` is returned as the maximum product of any sublist.

This ensures that `best_so_far` always holds the maximum product found so far, even if the maximum product changes within the loop.