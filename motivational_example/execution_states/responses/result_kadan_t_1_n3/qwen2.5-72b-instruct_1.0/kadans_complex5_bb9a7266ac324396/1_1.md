The provided solution is mostly correct but has a minor issue in the logic flow. Specifically, the update of `best_so_far` should be done inside the loop to ensure that it captures the best possible product at each step. Here's the corrected version of the function:

```python
def func_1(xs):
    if not xs:
        return float('-inf')
    
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]
    
    for num in xs[1:]:
        temp = max_ending_here * num
        
        max_ending_here = max(num, temp, min_ending_here * num)
        
        min_ending_here = min(num, temp, min_ending_here * num)
        
        # Update best_so_far inside the loop
        if max_ending_here > best_so_far:
            best_so_far = max_ending_here
    
    return best_so_far
```

### Explanation:
1. **Initial Checks**: The function starts by checking if the list `xs` is empty. If it is, the function returns `-inf` because the product of an empty sublist is undefined, and `-inf` represents the worst possible product.

2. **Initialization**: The variables `min_ending_here`, `max_ending_here`, and `best_so_far` are initialized to the first element of the list. These variables keep track of the minimum and maximum products of sublists ending at the current position, and the best product found so far, respectively.

3. **Loop Through the List**: The loop iterates through the list starting from the second element. For each element:
   - `temp` is calculated as the product of the current maximum product (`max_ending_here`) and the current number (`num`).
   - `max_ending_here` is updated to the maximum of the current number, the product of the current number and the previous maximum product, and the product of the current number and the previous minimum product. This ensures that we consider both positive and negative products.
   - `min_ending_here` is updated similarly but to the minimum value, to handle cases where the product becomes negative.
   - `best_so_far` is updated to the maximum of itself and `max_ending_here`.

4. **Return the Result**: After the loop, `best_so_far` contains the maximum product of any sublist in the list, which is returned by the function.

### Correctness:
- The function correctly handles both positive and negative numbers.
- It updates `best_so_far` at each step to ensure that the maximum product is captured even if the maximum product changes during the iteration.
- The initial checks and variable updates are done correctly.

This corrected version should work as expected for finding the maximum product of any sublist in the given list.