The provided solution is almost correct but has a small issue in how it handles the `best_so_far` variable. The `best_so_far` should be updated in each iteration of the loop to ensure that it captures the maximum product found so far, not just after the loop.

Here's the corrected version of the function:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  # Return negative infinity for empty list as no sublist exists
    
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]
    
    for num in xs[1:]:
        temp = max_ending_here * num
        
        max_ending_here = max(num, temp, min_ending_here * num)
        
        min_ending_here = min(num, temp, min_ending_here * num)
        
        # Update the best_so_far with the maximum value found so far
        best_so_far = max(best_so_far, max_ending_here)
    
    return best_so_far
```

### Explanation:
- **Initialization**: Start with the first element as both `min_ending_here`, `max_ending_here`, and `best_so_far`.
- **Iteration**: For each subsequent number, calculate the possible products (`num`, `temp`, `min_ending_here * num`) to determine the new `max_ending_here` and `min_ending_here`.
- **Update `best_so_far`**: In each iteration, update `best_so_far` to be the maximum of itself and `max_ending_here`. This ensures that `best_so_far` always contains the maximum product of any sublist found so far.
- **Return**: After the loop, return `best_so_far` which contains the maximum product of any sublist.

This updated function correctly solves the problem of finding the maximum product of any sublist in the given integer list.