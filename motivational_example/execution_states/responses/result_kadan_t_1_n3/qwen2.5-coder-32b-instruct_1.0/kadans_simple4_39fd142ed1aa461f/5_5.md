The provided solution is almost correct, but there's a small issue with the way `min_ending_here` and `max_ending_here` are being updated. The current implementation correctly handles the scenario where multiplying by a negative number could turn a small (negative) product into a large (positive) one, and vice versa. However, the logic can be simplified slightly and made more robust.

Here's a revised version of the code with some improvements and comments for clarity:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  # If the list is empty, return negative infinity as there's no valid sublist.
    
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]
    
    for num in xs[1:]:
        # If the current number is negative, swap min and max
        if num < 0:
            min_ending_here, max_ending_here = max_ending_here, min_ending_here
        
        # Calculate the new max_ending_here and min_ending_here
        max_ending_here = max(num, max_ending_here * num)
        min_ending_here = min(num, min_ending_here * num)
        
        # Update the best_so_far if needed
        best_so_far = max(best_so_far, max_ending_here)
    
    return best_so_far

# Example usage:
print(func_1([2, 3, -2, 4]))  # Output should be 6 (sublist [2, 3])
print(func_1([-2, 0, -1]))    # Output should be 0 (sublist [0])
```

### Explanation of the Changes:
1. **Swapping `min_ending_here` and `max_ending_here`**: When encountering a negative number, swapping `min_ending_here` and `max_ending_here` ensures that the product calculations remain consistent with the sign changes.
2. **Updating `best_so_far` Inside the Loop**: By updating `best_so_far` inside the loop after recalculating `max_ending_here`, we ensure that we are always considering the maximum product encountered so far.

This revised version should work correctly for the problem of finding the maximum product of any sublist in the given integer list.