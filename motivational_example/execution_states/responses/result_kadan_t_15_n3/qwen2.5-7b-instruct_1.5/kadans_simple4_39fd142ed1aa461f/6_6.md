The provided solution appears to be correct for finding the maximum product of any sublist in a given integer list. Let's break down the logic to understand why:

### Explanation

1. **Initialization**:
   - `min_ending_here`: Tracks the minimum product ending at the current position.
   - `max_ending_here`: Tracks the maximum product ending at the current position.
   - `best_so_far`: Stores the best (maximum) product found so far.

2. **Main Loop**:
   - For each number in the list starting from the second element (`num`), update:
     - `temp` as `max_ending_here * num`.
     - `max_ending_here` to be the maximum of three values: `num`, `temp`, and `min_ending_here * num`. This is because multiplying by a negative number could turn a small number into a large number and vice versa.
     - `min_ending_here` to be the minimum of three values: `num`, `temp`, and `min_ending_here * num`.

3. **Update Best Result**:
   - If `max_ending_here` is greater than `best_so_far`, update `best_so_far`.

### Edge Case Handling
- The solution handles empty lists correctly by returning `float('-inf')`, which represents negative infinity.

### Example Walkthrough
Consider the list `[2, 3, -2, 4]`:
- Start with `min_ending_here = 2`, `max_ending_here = 2`, and `best_so_far = 2`.
- For `3`: 
  - `temp = 6`
  - `max_ending_here = max(3, 6, -6) = 6`
  - `min_ending_here = min(3, 6, -6) = 3`
- Update `best_so_far` if necessary.
- For `-2`:
  - `temp = 6 * -2 = -12`
  - `max_ending_here = max(-2, -12, 3 * -2) = 3`
  - `min_ending_here = min(-2, -12, 3 * -2) = -12`
- Update `best_so_far` if necessary.
- For `4`:
  - `temp = 3 * 4 = 12`
  - `max_ending_here = max(4, 12, -12 * 4) = 12`
  - `min_ending_here = min(4, 12, -12 * 4) = 4`
- Update `best_so_far` if necessary.
- The final value of `best_so_far` will be `12`.

### Conclusion
The solution is correct and efficiently finds the maximum product of any sublist. You can test it with various input lists to ensure its correctness.