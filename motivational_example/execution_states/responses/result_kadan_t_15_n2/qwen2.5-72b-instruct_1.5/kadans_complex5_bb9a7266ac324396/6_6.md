The solution provided is mostly correct but has a minor flaw that can lead to incorrect results. Let's break down the code and identify the issue:

### Correctness of the Logic:
- **Base Case:** If the list is empty, the function correctly returns negative infinity (`float('-inf')`), indicating no possible product.
- **Initialization:**
  - `min_ending_here` and `max_ending_here` are initialized to the first element of the list.
  - `best_so_far` is also initialized to the first element of the list.
- **Loop:**
  - For each subsequent element `num` in the list, the algorithm updates `min_ending_here` and `max_ending_here` to account for the possibility of a product becoming large or small due to multiplication by a negative number.
  - The `temp` variable stores the product of `max_ending_here` and `num`.
  - `max_ending_here` is updated to the maximum of `num`, `temp`, and `min_ending_here * num`.
  - `min_ending_here` is updated to the minimum of `num`, `temp`, and `min_ending_here * num`.

### Issue:
- **Update of `best_so_far`:** The update of `best_so_far` should be done inside the loop to ensure that the best product found so far is always up-to-date. In the provided code, the update is done outside the loop, which means it only checks the final value of `max_ending_here` against `best_so_far`. This can miss out on the best product found during the iteration.

### Corrected Code:
```python
def max_product_sublist(xs):
    if not xs:
        return float('-inf')
    
    min_ending_here = max_ending_here = best_so_far = xs[0]
    
    for num in xs[1:]:
        temp = max_ending_here * num
        
        max_ending_here = max(num, temp, min_ending_here * num)
        min_ending_here = min(num, temp, min_ending_here * num)
        
        if max_ending_here > best_so_far:
            best_so_far = max_ending_here
    
    return best_so_far
```

### Explanation:
- **Loop Update:** The update of `best_so_far` is now inside the loop, ensuring that the maximum product found at each step is considered.
- **Correct Output:** This ensures that the function returns the maximum product of any sublist, as required.

### Example:
For the input list `[2, 3, -2, 4]`, the corrected function will correctly return `6` (the product of the sublist `[2, 3]`).

### Conclusion:
The original solution is almost correct but needs the `best_so_far` update to be inside the loop to ensure the correct maximum product is returned. The corrected code provided above should work correctly for all test cases.