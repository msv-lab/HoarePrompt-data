The provided Python solution is almost correct but can be made a bit more efficient by avoiding the additional comparison outside the loop. The core logic in the loop already keeps track of the maximum product encountered so far using `best_so_far`, which should be updated within each iteration if a larger product is found.

Here is a revised version of the solution, along with some explanation:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  # or return 0, depending on what you want for an empty list

    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]

    for num in xs[1:]:
        temp_max = max_ending_here * num
        temp_min = min_ending_here * num

        max_ending_here = max(num, temp_max, temp_min)
        min_ending_here = min(num, temp_max, temp_min)
        
        best_so_far = max(best_so_far, max_ending_here)

    return best_so_far
```

### Explanation:

- **Initialization**: We start by initializing `min_ending_here`, `max_ending_here`, and `best_so_far` to the first element of the list. These variables represent the minimum and maximum products ending at the current position in the list, and the maximum product found so far across all sublists, respectively.

- **Iteration**: For each element in the list (starting from the second one), we calculate two temporary values:
  - `temp_max`: The product of the current maximum product ending at the previous position (`max_ending_here`) with the current number.
  - `temp_min`: The product of the current minimum product ending at the previous position (`min_ending_here`) with the current number.
  
  We then update `max_ending_here` and `min_ending_here` by considering the current number alone, the temporary maximum, and the temporary minimum. This step is crucial because multiplying a negative number by the minimum product can yield a larger positive number.

- **Update Best So Far**: Within each iteration, we update `best_so_far` to the maximum value between itself and the current `max_ending_here`. This ensures that after the loop finishes, `best_so_far` holds the maximum product of any sublist.

The revised code correctly implements this logic, ensuring the correct solution to the problem of finding the maximum product of any sublist.