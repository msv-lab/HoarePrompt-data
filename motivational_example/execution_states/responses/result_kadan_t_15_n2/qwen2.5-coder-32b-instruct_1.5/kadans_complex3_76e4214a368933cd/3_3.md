Correctness: **False**

The given solution contains a critical issue. While the code attempts to maintain both the maximum and minimum products up to the current position in the list (necessary because a negative number can turn a large negative product into a large positive one), it does not update `best_so_far` within the loop.

Here's what the code should do:
1. Initialize `best_so_far`, `max_ending_here`, and `min_ending_here` to the first element of the list.
2. For each subsequent element in the list, calculate `temp = max_ending_here * num`.
3. Update `max_ending_here` to be the maximum of `num`, `temp`, and `min_ending_here * num`.
4. Update `min_ending_here` to be the minimum of `num`, `temp`, and `min_ending_here * num`.
5. Update `best_so_far` to be the maximum of `best_so_far` and `max_ending_here`.
6. Return `best_so_far`.

Thus, `best_so_far` should be updated on every iteration of the loop to ensure that it always holds the highest product found so far, not just the highest product ending at the first element.

The corrected part would look something like this:
```python
for num in xs[1:]:
    temp = max_ending_here * num
        
    max_ending_here = max(num, temp, min_ending_here * num)
        
    min_ending_here = min(num, temp, min_ending_here * num)

    if (max_ending_here > best_so_far) :
        best_so_far = max_ending_here
```
With this modification, the provided Python function would correctly compute the maximum product of any sublist in `xs`.