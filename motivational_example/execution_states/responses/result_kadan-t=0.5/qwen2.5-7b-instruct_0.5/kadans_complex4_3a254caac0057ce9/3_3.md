The provided solution is mostly correct but has a few issues that need addressing. Let's go through the code step-by-step to identify and fix these issues.

### Issues Identified:
1. **Initialization of `min_ending_here` and `max_ending_here`:**
   - The initial values of `min_ending_here` and `max_ending_here` should be set to 1 instead of `xs[0]`. This is because the product of two negative numbers can become positive, and we need to keep track of both the maximum and minimum products to handle such cases correctly.

2. **Updating `best_so_far`:**
   - The update of `best_so_far` should be done inside the loop to ensure it captures the maximum product at each step.

3. **Handling the case where all elements are negative:**
   - If all elements in the list are negative, the maximum product will be the smallest (most negative) number. However, the current logic might miss this scenario if the list contains only negative numbers.

### Corrected Solution:
Here is the corrected version of the function:

```python
def func_1(xs):
    if not xs:
        return float('-inf')

    min_ending_here = 1
    max_ending_here = 1
    best_so_far = float('-inf')

    for num in xs:
        temp = max_ending_here * num

        # Update max_ending_here and min_ending_here
        max_ending_here = max(num, temp, min_ending_here * num)
        min_ending_here = min(num, temp, min_ending_here * num)

        # Update best_so_far
        if max_ending_here > best_so_far:
            best_so_far = max_ending_here

    return best_so_far
```

### Explanation:
- **Initialization:** `min_ending_here` and `max_ending_here` are initialized to 1.
- **Loop through the list:** For each number in the list, calculate the temporary product (`temp`) of `max_ending_here` and the current number.
- **Update `max_ending_here` and `min_ending_here`:** Use `max` and `min` functions to update these variables considering the current number, the temporary product, and the product of `min_ending_here` and the current number.
- **Update `best_so_far`:** If the current `max_ending_here` is greater than `best_so_far`, update `best_so_far`.

This approach ensures that the function correctly handles all edge cases, including lists with only negative numbers or zeros.