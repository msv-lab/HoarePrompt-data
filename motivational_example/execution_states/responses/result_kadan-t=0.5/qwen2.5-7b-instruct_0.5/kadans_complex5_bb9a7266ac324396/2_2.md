The provided solution seems to be on the right track but has some issues that need to be addressed. Let's break down the logic and correct it.

### Corrected Solution

```python
def func_1(xs):
    if not xs:
        return float('-inf')

    # Initialize variables
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]

    for num in xs[1:]:
        # Calculate the temporary values for the next iteration
        temp_max = max(num, max_ending_here * num, min_ending_here * num)
        temp_min = min(num, max_ending_here * num, min_ending_here * num)

        # Update the variables
        max_ending_here = temp_max
        min_ending_here = temp_min

        # Update the best so far
        if max_ending_here > best_so_far:
            best_so_far = max_ending_here

    return best_so_far
```

### Explanation

1. **Initialization**:
   - `min_ending_here` and `max_ending_here` are initialized to the first element of the list `xs`.
   - `best_so_far` is also initialized to the first element of the list `xs`.

2. **Iterate through the list**:
   - For each element `num` in the list starting from the second element:
     - Calculate `temp_max` as the maximum of `num`, `max_ending_here * num`, and `min_ending_here * num`.
     - Calculate `temp_min` as the minimum of `num`, `max_ending_here * num`, and `min_ending_here * num`.
     - Update `max_ending_here` to `temp_max` and `min_ending_here` to `temp_min`.
     - If `max_ending_here` is greater than `best_so_far`, update `best_so_far` to `max_ending_here`.

3. **Return the result**:
   - After iterating through the list, return `best_so_far`.

### Example Execution

Let's consider an example list `xs = [2, 3, -2, 4]`:

- Initial values:
  - `min_ending_here = 2`
  - `max_ending_here = 2`
  - `best_so_far = 2`

- Iteration 1 (`num = 3`):
  - `temp_max = max(3, 2*3, 2*3) = 6`
  - `temp_min = min(3, 2*3, 2*3) = 3`
  - Update: `max_ending_here = 6`, `min_ending_here = 3`
  - `best_so_far` remains `2`

- Iteration 2 (`num = -2`):
  - `temp_max = max(-2, 6*(-2), 3*(-2)) = -2`
  - `temp_min = min(-2, 6*(-2), 3*(-2)) = -12`
  - Update: `max_ending_here = -2`, `min_ending_here = -12`
  - `best_so_far` remains `2`

- Iteration 3 (`num = 4`):
  - `temp_max = max(4, -2*4, -12*4) = 4`
  - `temp_min = min(4, -2*4, -12*4) = -48`
  - Update: `max_ending_here = 4`, `min_ending_here = -48`
  - `best_so_far` updates to `4`

The final result is `4`, which is the maximum product of any sublist.

### Conclusion

The corrected code should work as expected for finding the maximum product of any sublist in a given integer list.