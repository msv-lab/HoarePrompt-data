The provided solution seems to be mostly correct, but there are a few points that need clarification and correction:

1. **Initialization of `min_ending_here` and `max_ending_here`:**
   - The initial values of `min_ending_here` and `max_ending_here` should both be set to 1 instead of `xs[0]`. This is because the product of any number with 1 remains the same, and it helps handle cases where the current number itself could be negative.

2. **Handling of `temp`:**
   - The variable `temp` is unnecessary and can be removed. Instead, directly use `max_ending_here * num` and `min_ending_here * num` in the `max()` and `min()` functions.

3. **Final check for `best_so_far`:**
   - The final check for updating `best_so_far` should be done after the loop ends, not inside the loop.

Here's the corrected version of the function:

```python
def func_1(xs):
    if not xs:
        return float('-inf')
    
    # State: xs is a list of integers, and xs is not empty
    min_ending_here = 1
    max_ending_here = 1
    best_so_far = float('-inf')
    
    for num in xs:
        # Update max_ending_here and min_ending_here
        temp_max = max(num, max_ending_here * num, min_ending_here * num)
        temp_min = min(num, max_ending_here * num, min_ending_here * num)
        
        max_ending_here = temp_max
        min_ending_here = temp_min
        
        # Update best_so_far
        if max_ending_here > best_so_far:
            best_so_far = max_ending_here
    
    return best_so_far
```

### Explanation of the Corrected Code:

1. **Initialization:**
   - `min_ending_here` and `max_ending_here` are initialized to 1 to handle cases where the sublist might start from any index and include negative numbers.

2. **Loop through the list:**
   - For each number in the list, update `max_ending_here` and `min_ending_here` using the current number and the previous values of `max_ending_here` and `min_ending_here`.
   - Use `max()` and `min()` to determine the new values of `max_ending_here` and `min_ending_here`.

3. **Update `best_so_far`:**
   - After updating `max_ending_here` and `min_ending_here`, check if `max_ending_here` is greater than `best_so_far` and update `best_so_far` accordingly.

4. **Return the result:**
   - Return `best_so_far` after the loop completes.

This approach ensures that the algorithm correctly handles all edge cases, including lists with negative numbers and zeros.