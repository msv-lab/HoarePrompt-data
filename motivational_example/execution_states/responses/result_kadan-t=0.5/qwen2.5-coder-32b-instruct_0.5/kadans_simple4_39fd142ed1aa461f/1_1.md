The provided solution is almost correct but has a small issue in how it handles the `min_ending_here` and `max_ending_here` updates. Specifically, the `temp` variable is used to store the product of `max_ending_here` and `num`, but this value should be recalculated when updating `min_ending_here` because `max_ending_here` might have been updated already in the same iteration.

Here's the corrected version of the code:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  
    
    min_ending_here = xs[0]
    max_ending_here = xs[0]
    best_so_far = xs[0]
    
    for num in xs[1:]:
        # Calculate the temporary values before updating min_ending_here and max_ending_here
        temp_max = max_ending_here * num
        temp_min = min_ending_here * num
        
        # Update max_ending_here and min_ending_here
        max_ending_here = max(num, temp_max, temp_min)
        min_ending_here = min(num, temp_max, temp_min)
        
        # Update best_so_far
        best_so_far = max(best_so_far, max_ending_here)
    
    return best_so_far
```

### Explanation:
- **Initialization**: Start with the first element as both `min_ending_here`, `max_ending_here`, and `best_so_far`.
- **Iteration**: For each subsequent number, calculate the potential new `max_ending_here` and `min_ending_here` using the current number and the previous `max_ending_here` and `min_ending_here`. This is necessary because multiplying a negative number by the smallest (most negative) product can yield the largest product.
- **Update**: Update `max_ending_here` and `min_ending_here` using the current number, the product of the current number and the previous `max_ending_here`, and the product of the current number and the previous `min_ending_here`.
- **Track Best**: Continuously update `best_so_far` to be the maximum of itself and `max_ending_here`.

This approach ensures that you correctly track the maximum product of any sublist in linear time.