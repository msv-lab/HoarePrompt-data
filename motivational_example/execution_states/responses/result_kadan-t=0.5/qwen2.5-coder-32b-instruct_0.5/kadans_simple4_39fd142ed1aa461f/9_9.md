The provided solution is almost correct but has a small issue in how it handles the `min_ending_here` and `max_ending_here` updates. The logic for updating these variables is correct, but the way the `temp` variable is used can be simplified and clarified. Here's a revised version of the code with comments explaining each step:

```python
def func_1(xs):
    if not xs:
        return float('-inf')  # If the list is empty, return negative infinity as no product can be formed.
    
    min_ending_here = xs[0]  # Initialize the minimum product ending at the current position.
    max_ending_here = xs[0]  # Initialize the maximum product ending at the current position.
    best_so_far = xs[0]      # Initialize the best product found so far.
    
    for num in xs[1:]:
        # Calculate the potential new maximum and minimum products.
        temp_max = max_ending_here * num
        temp_min = min_ending_here * num
        
        # Update the maximum product ending at the current position.
        max_ending_here = max(num, temp_max, temp_min)
        
        # Update the minimum product ending at the current position.
        min_ending_here = min(num, temp_max, temp_min)
        
        # Update the best product found so far.
        best_so_far = max(best_so_far, max_ending_here)
    
    return best_so_far
```

### Explanation:
- **Initialization**: Start by initializing `min_ending_here`, `max_ending_here`, and `best_so_far` with the first element of the list.
- **Iteration**: For each subsequent element in the list:
  - Calculate the potential new maximum (`temp_max`) and minimum (`temp_min`) products by multiplying the current number with the previous `max_ending_here` and `min_ending_here`.
  - Update `max_ending_here` to be the maximum of the current number, `temp_max`, and `temp_min`. This accounts for the possibility that the current number itself might be larger than any product involving previous numbers.
  - Similarly, update `min_ending_here` to be the minimum of the current number, `temp_max`, and `temp_min`.
  - Update `best_so_far` to be the maximum of itself and `max_ending_here`.

This approach ensures that you correctly track both the maximum and minimum products up to the current position, which is necessary because a negative number could turn a large negative product into a large positive product.

### Example:
For the input list `[2, 3, -2, 4]`, the function will correctly compute the maximum product of any sublist as `6`, which comes from the sublist `[2, 3]`.