[
    {
        "task_id": "Mbpp/87",
        "specification": "Write a function to merge three dictionaries into a single dictionary.",
        "generated_code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict1.copy()  # Start with a copy of the first dictionary\n    merged_dict.update(dict2)   # Update with the second dictionary\n    merged_dict.update(dict3)   # Update with the third dictionary\n    return merged_dict\n\n# Tests\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" }) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"}) == {'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" }) == {'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}\n",
        "base_accuracy": 0.0,
        "plus_accuracy": 0.0,
        "assertion_passed": false,
        "counterexample": {
            "test_type": "base",
            "input": [
                {
                    "R": "Red",
                    "P": "Pink"
                },
                {
                    "G": "Green"
                },
                {
                    "O": "Orange",
                    "W": "White",
                    "B": "Black"
                }
            ],
            "expected": {
                "O": "Orange",
                "W": "White",
                "B": "Black",
                "G": "Green",
                "R": "Red",
                "P": "Pink"
            },
            "got": null
        },
        "comment": "description unsure"
    },
    {
        "task_id": "Mbpp/415",
        "specification": "Write a python function to find a pair with highest product from a given array of integers.",
        "generated_code": "def max_Product(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least two integers\")\n    \n    arr.sort()\n    \n    # Product of the two largest numbers\n    max1 = arr[-1]\n    max2 = arr[-2]\n    \n    # Product of the two smallest numbers (in case of negative numbers)\n    min1 = arr[0]\n    min2 = arr[1]\n    \n    if max1 * max2 > min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)\n\n# Tests\nassert max_Product([1,2,3,4,7,0,8,4]) == (7,8)\nassert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)\nassert max_Product([1,2,3]) == (2,3)\n",
        "base_accuracy": 1.0,
        "plus_accuracy": 0.8584070796460177,
        "assertion_passed": false,
        "counterexample": {
            "test_type": "plus",
            "input": [
                [
                    1000000,
                    -1000000,
                    999999,
                    -999999,
                    888888,
                    -888888,
                    777777,
                    -777777
                ]
            ],
            "expected": [
                [
                    1000000,
                    999999
                ]
            ],
            "got": [
                [
                    -1000000,
                    -999999
                ]
            ]
        },
        "comment": "description unsure"
    },
    {
        "task_id": "Mbpp/427",
        "specification": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.",
        "generated_code": "def change_date_format(date_str):\n    year, month, day = date_str.split('-')\n    return f\"{day}-{month}-{year}\"\n\n# Test cases\nassert change_date_format(\"2026-01-02\") == '02-01-2026'\nassert change_date_format(\"2020-11-13\") == '13-11-2020'\nassert change_date_format(\"2021-04-26\") == '26-04-2021'\n",
        "base_accuracy": 1.0,
        "plus_accuracy": 0.10714285714285714,
        "assertion_passed": true,
        "counterexample": {
            "test_type": "plus",
            "input": [
                "2021-1-026"
            ],
            "expected": "02-1-20216",
            "got": "026-1-2021"
        },
        "comment": "description unsure"
    },
    {
        "task_id": "Mbpp/581",
        "specification": "Write a python function to find the surface area of a square pyramid with a given base edge and height.",
        "generated_code": "import math\n\ndef surface_Area(base_edge, height):\n    # Calculate base area\n    base_area = base_edge * base_edge\n    \n    # Calculate slant height\n    slant_height = math.sqrt((base_edge / 2)**2 + height**2)\n    \n    # Calculate area of one triangular face\n    triangle_area = 0.5 * base_edge * slant_height\n    \n    # Calculate lateral area\n    lateral_area = 4 * triangle_area\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return round(total_surface_area)\n\n# Tests\nassert surface_Area(3, 4) == 33\nassert surface_Area(4, 5) == 56\nassert surface_Area(1, 2) == 5\n",
        "base_accuracy": 0.0,
        "plus_accuracy": 0.0,
        "assertion_passed": false,
        "counterexample": {
            "test_type": "base",
            "input": [
                3,
                4
            ],
            "expected": 33,
            "got": null
        },
        "comment": "description unsure"
    },
    {
        "task_id": "Mbpp/603",
        "specification": "Write a function to get all lucid numbers smaller than or equal to a given integer.",
        "generated_code": "def get_ludic(n):\n    if n < 1:\n        return []\n    \n    # Start with a list from 1 to n\n    numbers = list(range(1, n + 1))\n    index = 1  # Start from the second element (1-based index)\n    \n    while index < len(numbers):\n        step = numbers[index]\n        if step > len(numbers):\n            break\n        # Remove every step-th element starting from the step-th element (1-based index)\n        numbers = [num for i, num in enumerate(numbers) if (i + 1) % step != 0 or i == 0]\n        index += 1\n    \n    return numbers\n\n# Tests\nassert get_ludic(10) == [1, 2, 3, 5, 7]\nassert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\nassert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n",
        "base_accuracy": 0.0,
        "plus_accuracy": 0.0,
        "assertion_passed": false,
        "counterexample": {
            "test_type": "base",
            "input": [
                10
            ],
            "expected": [
                1,
                2,
                3,
                5,
                7
            ],
            "got": null
        },
        "comment": "description unsure"
    },
    {
        "task_id": "Mbpp/630",
        "specification": "Write a function to extract all the adjacent coordinates of the given coordinate tuple.",
        "generated_code": "def get_coordinates(coord):\n    x, y = coord\n    adjacent_coords = []\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            adjacent_coords.append([x + dx, y + dy])\n    return adjacent_coords\n\n# Test cases to verify the solution\nassert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\nassert get_coordinates((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\nassert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n",
        "base_accuracy": 1.0,
        "plus_accuracy": 0.008333333333333333,
        "assertion_passed": true,
        "counterexample": {
            "test_type": "plus",
            "input": [
                [
                    1,
                    1,
                    1
                ]
            ],
            "expected": [
                [
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    1
                ],
                [
                    0,
                    0,
                    2
                ],
                [
                    0,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    1
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    2,
                    0
                ],
                [
                    0,
                    2,
                    1
                ],
                [
                    0,
                    2,
                    2
                ],
                [
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    2
                ],
                [
                    1,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    0
                ],
                [
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    2,
                    0,
                    0
                ],
                [
                    2,
                    0,
                    1
                ],
                [
                    2,
                    0,
                    2
                ],
                [
                    2,
                    1,
                    0
                ],
                [
                    2,
                    1,
                    1
                ],
                [
                    2,
                    1,
                    2
                ],
                [
                    2,
                    2,
                    0
                ],
                [
                    2,
                    2,
                    1
                ],
                [
                    2,
                    2,
                    2
                ]
            ],
            "got": null
        },
        "comment": "description unsure"
    },
    {
        "task_id": "Mbpp/305",
        "specification": "Write a function to return two words from a list of words starting with letter 'p'.",
        "generated_code": "def start_withp(words_list):\n    result = []\n    for phrase in words_list:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n            if len(result) == 2:\n                return tuple(result)\n    return tuple(result)\n\n# Test cases\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\nassert start_withp([\"Python Programming\",\"Java Programming\"]) == ('Python','Programming')\nassert start_withp([\"Pqrst Pqr\",\"qrstuv\"]) == ('Pqrst','Pqr')\n\nprint(\"All tests passed!\")\n",
        "base_accuracy": 1.0,
        "plus_accuracy": 0.1588785046728972,
        "assertion_passed": true,
        "counterexample": {
            "test_type": "plus",
            "input": [
                []
            ],
            "expected": null,
            "got": []
        },
        "comment": "description unsure"
    }
]